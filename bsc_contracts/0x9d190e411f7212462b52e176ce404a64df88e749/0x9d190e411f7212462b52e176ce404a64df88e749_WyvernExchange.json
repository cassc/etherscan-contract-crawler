{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/WyvernExchange.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.14;\\n\\nimport \\\"./exchange/Exchange.sol\\\";\\n\\n/**\\n * @title WyvernExchange\\n * @author Wyvern Protocol Developers\\n * @author Unvest\\n * @dev Updated from Wyvern Exchange v3.3\\n */\\ncontract WyvernExchange is Exchange {\\n    string public constant name = \\\"Unvest Protocol\\\";\\n    string public constant version = \\\"1.0\\\";\\n\\n    constructor(\\n        uint256 chainId,\\n        address[] memory registryAddrs,\\n        bytes memory customPersonalSignPrefix\\n    ) {\\n        DOMAIN_SEPARATOR = hash(\\n            EIP712Domain({\\n                name: name,\\n                version: version,\\n                chainId: chainId,\\n                verifyingContract: address(this)\\n            })\\n        );\\n        for (uint256 ind = 0; ind < registryAddrs.length; ind++) {\\n            registries[registryAddrs[ind]] = true;\\n        }\\n        if (customPersonalSignPrefix.length > 0) {\\n            personalSignPrefix = customPersonalSignPrefix;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/exchange/Exchange.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.14;\\n\\nimport \\\"./ExchangeCore.sol\\\";\\n\\n/**\\n * @title Exchange\\n * @author Wyvern Protocol Developers\\n */\\ncontract Exchange is ExchangeCore {\\n    /* external ABI-encodable method wrappers. */\\n\\n    function hashOrder_(\\n        address registry,\\n        address maker,\\n        address staticTarget,\\n        bytes4 staticSelector,\\n        bytes calldata staticExtradata,\\n        uint256 maximumFill,\\n        uint256 listingTime,\\n        uint256 expirationTime,\\n        uint256 salt\\n    ) external pure returns (bytes32 hash) {\\n        return\\n            hashOrder(\\n                Order(\\n                    registry,\\n                    maker,\\n                    staticTarget,\\n                    staticSelector,\\n                    staticExtradata,\\n                    maximumFill,\\n                    listingTime,\\n                    expirationTime,\\n                    salt\\n                )\\n            );\\n    }\\n\\n    function hashToSign_(bytes32 orderHash)\\n        external\\n        view\\n        returns (bytes32 hash)\\n    {\\n        return hashToSign(orderHash);\\n    }\\n\\n    function validateOrderParameters_(\\n        address registry,\\n        address maker,\\n        address staticTarget,\\n        bytes4 staticSelector,\\n        bytes calldata staticExtradata,\\n        uint256 maximumFill,\\n        uint256 listingTime,\\n        uint256 expirationTime,\\n        uint256 salt\\n    ) external view returns (bool) {\\n        Order memory order = Order(\\n            registry,\\n            maker,\\n            staticTarget,\\n            staticSelector,\\n            staticExtradata,\\n            maximumFill,\\n            listingTime,\\n            expirationTime,\\n            salt\\n        );\\n        return validateOrderParameters(order, hashOrder(order));\\n    }\\n\\n    function validateOrderAuthorization_(\\n        bytes32 hash,\\n        address maker,\\n        bytes calldata signature\\n    ) external view returns (bool) {\\n        return validateOrderAuthorization(hash, maker, signature);\\n    }\\n\\n    function approveOrderHash_(bytes32 hash) external {\\n        return approveOrderHash(hash);\\n    }\\n\\n    function approveOrder_(\\n        address registry,\\n        address maker,\\n        address staticTarget,\\n        bytes4 staticSelector,\\n        bytes calldata staticExtradata,\\n        uint256 maximumFill,\\n        uint256 listingTime,\\n        uint256 expirationTime,\\n        uint256 salt,\\n        bool orderbookInclusionDesired\\n    ) external {\\n        return\\n            approveOrder(\\n                Order(\\n                    registry,\\n                    maker,\\n                    staticTarget,\\n                    staticSelector,\\n                    staticExtradata,\\n                    maximumFill,\\n                    listingTime,\\n                    expirationTime,\\n                    salt\\n                ),\\n                orderbookInclusionDesired\\n            );\\n    }\\n\\n    function setOrderFill_(bytes32 hash, uint256 fill) external {\\n        return setOrderFill(hash, fill);\\n    }\\n\\n    function atomicMatch_(\\n        uint256[16] memory uints,\\n        bytes4[2] memory staticSelectors,\\n        bytes memory firstExtradata,\\n        bytes memory firstCalldata,\\n        bytes memory secondExtradata,\\n        bytes memory secondCalldata,\\n        uint8[2] memory howToCalls,\\n        bytes32 metadata,\\n        bytes memory signatures\\n    ) public payable {\\n        return\\n            atomicMatch(\\n                Order(\\n                    address(uint160(uints[0])),\\n                    address(uint160(uints[1])),\\n                    address(uint160(uints[2])),\\n                    staticSelectors[0],\\n                    firstExtradata,\\n                    uints[3],\\n                    uints[4],\\n                    uints[5],\\n                    uints[6]\\n                ),\\n                Call(\\n                    address(uint160(uints[7])),\\n                    AuthenticatedProxy.HowToCall(howToCalls[0]),\\n                    firstCalldata\\n                ),\\n                Order(\\n                    address(uint160(uints[8])),\\n                    address(uint160(uints[9])),\\n                    address(uint160(uints[10])),\\n                    staticSelectors[1],\\n                    secondExtradata,\\n                    uints[11],\\n                    uints[12],\\n                    uints[13],\\n                    uints[14]\\n                ),\\n                Call(\\n                    address(uint160(uints[15])),\\n                    AuthenticatedProxy.HowToCall(howToCalls[1]),\\n                    secondCalldata\\n                ),\\n                signatures,\\n                metadata\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/exchange/ExchangeCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.14;\\n\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\n\\nimport \\\"../lib/StaticCaller.sol\\\";\\nimport \\\"../lib/EIP712.sol\\\";\\nimport \\\"../lib/EIP1271.sol\\\";\\nimport \\\"../registry/ProxyRegistryInterface.sol\\\";\\nimport \\\"../registry/AuthenticatedProxy.sol\\\";\\n\\n/**\\n * @title ExchangeCore\\n * @author Wyvern Protocol Developers\\n */\\ncontract ExchangeCore is ReentrancyGuard, StaticCaller, EIP712 {\\n    bytes4 internal constant EIP_1271_MAGICVALUE = 0x1626ba7e;\\n    bytes internal personalSignPrefix = \\\"\\\\x19Ethereum Signed Message:\\\\n\\\";\\n\\n    /* Struct definitions. */\\n\\n    /* An order, convenience struct. */\\n    struct Order {\\n        /* Order registry address. */\\n        address registry;\\n        /* Order maker address. */\\n        address maker;\\n        /* Order static target. */\\n        address staticTarget;\\n        /* Order static selector. */\\n        bytes4 staticSelector;\\n        /* Order static extradata. */\\n        bytes staticExtradata;\\n        /* Order maximum fill factor. */\\n        uint256 maximumFill;\\n        /* Order listing timestamp. */\\n        uint256 listingTime;\\n        /* Order expiration timestamp - 0 for no expiry. */\\n        uint256 expirationTime;\\n        /* Order salt to prevent duplicate hashes. */\\n        uint256 salt;\\n    }\\n\\n    /* A call, convenience struct. */\\n    struct Call {\\n        /* Target */\\n        address target;\\n        /* How to call */\\n        AuthenticatedProxy.HowToCall howToCall;\\n        /* Calldata */\\n        bytes data;\\n    }\\n\\n    /* Constants */\\n\\n    /* Order typehash for EIP 712 compatibility. */\\n    bytes32 constant ORDER_TYPEHASH =\\n        keccak256(\\n            \\\"Order(address registry,address maker,address staticTarget,bytes4 staticSelector,bytes staticExtradata,uint256 maximumFill,uint256 listingTime,uint256 expirationTime,uint256 salt)\\\"\\n        );\\n\\n    /* Variables */\\n\\n    /* Trusted proxy registry contracts. */\\n    mapping(address => bool) public registries;\\n\\n    /* Order fill status, by maker address then by hash. */\\n    mapping(address => mapping(bytes32 => uint256)) public fills;\\n\\n    /* Orders verified by on-chain approval.\\n       Alternative to ECDSA signatures so that smart contracts can place orders directly.\\n       By maker address, then by hash. */\\n    mapping(address => mapping(bytes32 => bool)) public approved;\\n\\n    /* Events */\\n\\n    event OrderApproved(\\n        bytes32 indexed hash,\\n        address registry,\\n        address indexed maker,\\n        address staticTarget,\\n        bytes4 staticSelector,\\n        bytes staticExtradata,\\n        uint256 maximumFill,\\n        uint256 listingTime,\\n        uint256 expirationTime,\\n        uint256 salt,\\n        bool orderbookInclusionDesired\\n    );\\n    event OrderFillChanged(\\n        bytes32 indexed hash,\\n        address indexed maker,\\n        uint256 newFill\\n    );\\n    event OrdersMatched(\\n        bytes32 firstHash,\\n        bytes32 secondHash,\\n        address indexed firstMaker,\\n        address indexed secondMaker,\\n        uint256 newFirstFill,\\n        uint256 newSecondFill,\\n        bytes32 indexed metadata\\n    );\\n\\n    /* Functions */\\n\\n    function hashOrder(Order memory order)\\n        internal\\n        pure\\n        returns (bytes32 hash)\\n    {\\n        /* Per EIP 712. */\\n        return\\n            keccak256(\\n                abi.encode(\\n                    ORDER_TYPEHASH,\\n                    order.registry,\\n                    order.maker,\\n                    order.staticTarget,\\n                    order.staticSelector,\\n                    keccak256(order.staticExtradata),\\n                    order.maximumFill,\\n                    order.listingTime,\\n                    order.expirationTime,\\n                    order.salt\\n                )\\n            );\\n    }\\n\\n    function hashToSign(bytes32 orderHash)\\n        internal\\n        view\\n        returns (bytes32 hash)\\n    {\\n        /* Calculate the string a user must sign. */\\n        return\\n            keccak256(\\n                abi.encodePacked(\\\"\\\\x19\\\\x01\\\", DOMAIN_SEPARATOR, orderHash)\\n            );\\n    }\\n\\n    function exists(address what) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(what)\\n        }\\n        return size > 0;\\n    }\\n\\n    function validateOrderParameters(Order memory order, bytes32 hash)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        /* Order must be listed and not be expired. */\\n        if (\\n            order.listingTime > block.timestamp ||\\n            (order.expirationTime != 0 &&\\n                order.expirationTime <= block.timestamp)\\n        ) {\\n            return false;\\n        }\\n\\n        /* Order must not have already been completely filled. */\\n        if (fills[order.maker][hash] >= order.maximumFill) {\\n            return false;\\n        }\\n\\n        /* Order static target must exist. */\\n        if (!exists(order.staticTarget)) {\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    function validateOrderAuthorization(\\n        bytes32 hash,\\n        address maker,\\n        bytes memory signature\\n    ) internal view returns (bool) {\\n        /* Memoized authentication. If order has already been partially filled, order must be authenticated. */\\n        if (fills[maker][hash] > 0) {\\n            return true;\\n        }\\n\\n        /* Order authentication. Order must be either: */\\n\\n        /* (a): sent by maker */\\n        if (maker == msg.sender) {\\n            return true;\\n        }\\n\\n        /* (b): previously approved */\\n        if (approved[maker][hash]) {\\n            return true;\\n        }\\n\\n        /* Calculate hash which must be signed. */\\n        bytes32 calculatedHashToSign = hashToSign(hash);\\n\\n        /* Determine whether signer is a contract or account. */\\n        bool isContract = exists(maker);\\n\\n        /* (c): Contract-only authentication: EIP/ERC 1271. */\\n        if (isContract) {\\n            if (\\n                ERC1271(maker).isValidSignature(\\n                    calculatedHashToSign,\\n                    signature\\n                ) == EIP_1271_MAGICVALUE\\n            ) {\\n                return true;\\n            }\\n            return false;\\n        }\\n\\n        /* (d): Account-only authentication: ECDSA-signed by maker. */\\n        (uint8 v, bytes32 r, bytes32 s) = abi.decode(\\n            signature,\\n            (uint8, bytes32, bytes32)\\n        );\\n\\n        if (signature.length > 65 && signature[signature.length - 1] == 0x03) {\\n            // EthSign byte\\n            /* (d.1): Old way: order hash signed by maker using the prefixed personal_sign */\\n            if (\\n                ecrecover(\\n                    keccak256(\\n                        abi.encodePacked(\\n                            personalSignPrefix,\\n                            \\\"32\\\",\\n                            calculatedHashToSign\\n                        )\\n                    ),\\n                    v,\\n                    r,\\n                    s\\n                ) == maker\\n            ) {\\n                return true;\\n            }\\n        }\\n        /* (d.2): New way: order hash signed by maker using sign_typed_data */\\n        else if (ecrecover(calculatedHashToSign, v, r, s) == maker) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    function encodeStaticCall(\\n        Order memory order,\\n        Call memory call,\\n        Order memory counterorder,\\n        Call memory countercall,\\n        address matcher,\\n        uint256 value,\\n        uint256 fill\\n    ) internal pure returns (bytes memory) {\\n        /* This array wrapping is necessary to preserve static call target function stack space. */\\n        address[7] memory addresses = [\\n            order.registry,\\n            order.maker,\\n            call.target,\\n            counterorder.registry,\\n            counterorder.maker,\\n            countercall.target,\\n            matcher\\n        ];\\n        AuthenticatedProxy.HowToCall[2] memory howToCalls = [\\n            call.howToCall,\\n            countercall.howToCall\\n        ];\\n        uint256[6] memory uints = [\\n            value,\\n            order.maximumFill,\\n            order.listingTime,\\n            order.expirationTime,\\n            counterorder.listingTime,\\n            fill\\n        ];\\n        return\\n            abi.encodeWithSelector(\\n                order.staticSelector,\\n                order.staticExtradata,\\n                addresses,\\n                howToCalls,\\n                uints,\\n                call.data,\\n                countercall.data\\n            );\\n    }\\n\\n    function executeStaticCall(\\n        Order memory order,\\n        Call memory call,\\n        Order memory counterorder,\\n        Call memory countercall,\\n        address matcher,\\n        uint256 value,\\n        uint256 fill\\n    ) internal view returns (uint256) {\\n        return\\n            staticCallUint(\\n                order.staticTarget,\\n                encodeStaticCall(\\n                    order,\\n                    call,\\n                    counterorder,\\n                    countercall,\\n                    matcher,\\n                    value,\\n                    fill\\n                )\\n            );\\n    }\\n\\n    function executeCall(\\n        ProxyRegistryInterface registry,\\n        address maker,\\n        Call memory call\\n    ) internal returns (bool) {\\n        /* Assert valid registry. */\\n        require(registries[address(registry)]);\\n\\n        /* Assert target exists. */\\n        require(exists(call.target), \\\"Call target does not exist\\\");\\n\\n        /* Retrieve delegate proxy contract. */\\n        OwnableDelegateProxy delegateProxy = registry.proxies(maker);\\n\\n        /* Assert existence. */\\n        require(\\n            delegateProxy != OwnableDelegateProxy(payable(0)),\\n            \\\"Delegate proxy does not exist for maker\\\"\\n        );\\n\\n        /* Assert implementation. */\\n        require(\\n            delegateProxy.implementation() ==\\n                registry.delegateProxyImplementation(),\\n            \\\"Incorrect delegate proxy implementation for maker\\\"\\n        );\\n\\n        /* Typecast. */\\n        AuthenticatedProxy proxy = AuthenticatedProxy(payable(delegateProxy));\\n\\n        /* Execute order. */\\n        return proxy.proxy(call.target, call.howToCall, call.data);\\n    }\\n\\n    function approveOrderHash(bytes32 hash) internal {\\n        /* CHECKS */\\n\\n        /* Assert order has not already been approved. */\\n        require(!approved[msg.sender][hash], \\\"Order has already been approved\\\");\\n\\n        /* EFFECTS */\\n\\n        /* Mark order as approved. */\\n        approved[msg.sender][hash] = true;\\n    }\\n\\n    function approveOrder(Order memory order, bool orderbookInclusionDesired)\\n        internal\\n    {\\n        /* CHECKS */\\n\\n        /* Assert sender is authorized to approve order. */\\n        require(\\n            order.maker == msg.sender,\\n            \\\"Sender is not the maker of the order and thus not authorized to approve it\\\"\\n        );\\n\\n        /* Calculate order hash. */\\n        bytes32 hash = hashOrder(order);\\n\\n        /* Approve order hash. */\\n        approveOrderHash(hash);\\n\\n        /* Log approval event. */\\n        emit OrderApproved(\\n            hash,\\n            order.registry,\\n            order.maker,\\n            order.staticTarget,\\n            order.staticSelector,\\n            order.staticExtradata,\\n            order.maximumFill,\\n            order.listingTime,\\n            order.expirationTime,\\n            order.salt,\\n            orderbookInclusionDesired\\n        );\\n    }\\n\\n    function setOrderFill(bytes32 hash, uint256 fill) internal {\\n        /* CHECKS */\\n\\n        /* Assert fill is not already set. */\\n        require(\\n            fills[msg.sender][hash] != fill,\\n            \\\"Fill is already set to the desired value\\\"\\n        );\\n\\n        /* EFFECTS */\\n\\n        /* Mark order as accordingly filled. */\\n        fills[msg.sender][hash] = fill;\\n\\n        /* Log order fill change event. */\\n        emit OrderFillChanged(hash, msg.sender, fill);\\n    }\\n\\n    function atomicMatch(\\n        Order memory firstOrder,\\n        Call memory firstCall,\\n        Order memory secondOrder,\\n        Call memory secondCall,\\n        bytes memory signatures,\\n        bytes32 metadata\\n    ) internal nonReentrant {\\n        /* CHECKS */\\n\\n        /* Calculate first order hash. */\\n        bytes32 firstHash = hashOrder(firstOrder);\\n\\n        /* Check first order validity. */\\n        require(\\n            validateOrderParameters(firstOrder, firstHash),\\n            \\\"First order has invalid parameters\\\"\\n        );\\n\\n        /* Calculate second order hash. */\\n        bytes32 secondHash = hashOrder(secondOrder);\\n\\n        /* Check second order validity. */\\n        require(\\n            validateOrderParameters(secondOrder, secondHash),\\n            \\\"Second order has invalid parameters\\\"\\n        );\\n\\n        /* Prevent self-matching (possibly unnecessary, but safer). */\\n        require(firstHash != secondHash, \\\"Self-matching orders is prohibited\\\");\\n\\n        {\\n            /* Calculate signatures (must be awkwardly decoded here due to stack size constraints). */\\n            (bytes memory firstSignature, bytes memory secondSignature) = abi\\n                .decode(signatures, (bytes, bytes));\\n\\n            /* Check first order authorization. */\\n            require(\\n                validateOrderAuthorization(\\n                    firstHash,\\n                    firstOrder.maker,\\n                    firstSignature\\n                ),\\n                \\\"First order failed authorization\\\"\\n            );\\n\\n            /* Check second order authorization. */\\n            require(\\n                validateOrderAuthorization(\\n                    secondHash,\\n                    secondOrder.maker,\\n                    secondSignature\\n                ),\\n                \\\"Second order failed authorization\\\"\\n            );\\n        }\\n\\n        /* INTERACTIONS */\\n\\n        /* Transfer any msg.value.\\n           This is the first \\\"asymmetric\\\" part of order matching: if an order requires Ether, it must be the first order. */\\n        if (msg.value > 0) {\\n            /* Reentrancy prevented by nonReentrant modifier */\\n            (bool success, ) = address(uint160(firstOrder.maker)).call{\\n                value: msg.value\\n            }(\\\"\\\");\\n            require(success, \\\"native token transfer failed.\\\");\\n        }\\n\\n        /* Execute first call, assert success.\\n           This is the second \\\"asymmetric\\\" part of order matching: execution of the second order can depend on state changes in the first order, but not vice-versa. */\\n        require(\\n            executeCall(\\n                ProxyRegistryInterface(firstOrder.registry),\\n                firstOrder.maker,\\n                firstCall\\n            ),\\n            \\\"First call failed\\\"\\n        );\\n\\n        /* Execute second call, assert success. */\\n        require(\\n            executeCall(\\n                ProxyRegistryInterface(secondOrder.registry),\\n                secondOrder.maker,\\n                secondCall\\n            ),\\n            \\\"Second call failed\\\"\\n        );\\n\\n        /* Static calls must happen after the effectful calls so that they can check the resulting state. */\\n\\n        /* Fetch previous first order fill. */\\n        uint256 previousFirstFill = fills[firstOrder.maker][firstHash];\\n\\n        /* Fetch previous second order fill. */\\n        uint256 previousSecondFill = fills[secondOrder.maker][secondHash];\\n\\n        /* Execute first order static call, assert success, capture returned new fill. */\\n        uint256 firstFill = executeStaticCall(\\n            firstOrder,\\n            firstCall,\\n            secondOrder,\\n            secondCall,\\n            msg.sender,\\n            msg.value,\\n            previousFirstFill\\n        );\\n\\n        /* Execute second order static call, assert success, capture returned new fill. */\\n        uint256 secondFill = executeStaticCall(\\n            secondOrder,\\n            secondCall,\\n            firstOrder,\\n            firstCall,\\n            msg.sender,\\n            uint256(0),\\n            previousSecondFill\\n        );\\n\\n        /* EFFECTS */\\n\\n        /* Update first order fill, if necessary. */\\n        if (firstOrder.maker != msg.sender) {\\n            if (firstFill != previousFirstFill) {\\n                fills[firstOrder.maker][firstHash] = firstFill;\\n            }\\n        }\\n\\n        /* Update second order fill, if necessary. */\\n        if (secondOrder.maker != msg.sender) {\\n            if (secondFill != previousSecondFill) {\\n                fills[secondOrder.maker][secondHash] = secondFill;\\n            }\\n        }\\n\\n        /* LOGS */\\n\\n        /* Log match event. */\\n        emit OrdersMatched(\\n            firstHash,\\n            secondHash,\\n            firstOrder.maker,\\n            secondOrder.maker,\\n            firstFill,\\n            secondFill,\\n            metadata\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/StaticCaller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.14;\\n\\n/**\\n * @title StaticCaller\\n * @author Wyvern Protocol Developers\\n */\\ncontract StaticCaller {\\n    function staticCall(address target, bytes memory data)\\n        internal\\n        view\\n        returns (bool result)\\n    {\\n        assembly {\\n            result := staticcall(\\n                gas(),\\n                target,\\n                add(data, 0x20),\\n                mload(data),\\n                mload(0x40),\\n                0\\n            )\\n        }\\n        return result;\\n    }\\n\\n    function staticCallUint(address target, bytes memory data)\\n        internal\\n        view\\n        returns (uint256 ret)\\n    {\\n        bool result;\\n        assembly {\\n            let size := 0x20\\n            let free := mload(0x40)\\n            result := staticcall(\\n                gas(),\\n                target,\\n                add(data, 0x20),\\n                mload(data),\\n                free,\\n                size\\n            )\\n            ret := mload(free)\\n        }\\n        require(result, \\\"Static call failed\\\");\\n        return ret;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/EIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.14;\\n\\n/**\\n * @title EIP712\\n * @author Wyvern Protocol Developers\\n */\\ncontract EIP712 {\\n    struct EIP712Domain {\\n        string name;\\n        string version;\\n        uint256 chainId;\\n        address verifyingContract;\\n    }\\n\\n    bytes32 constant EIP712DOMAIN_TYPEHASH =\\n        keccak256(\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n        );\\n\\n    bytes32 DOMAIN_SEPARATOR;\\n\\n    function hash(EIP712Domain memory eip712Domain)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    EIP712DOMAIN_TYPEHASH,\\n                    keccak256(bytes(eip712Domain.name)),\\n                    keccak256(bytes(eip712Domain.version)),\\n                    eip712Domain.chainId,\\n                    eip712Domain.verifyingContract\\n                )\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/EIP1271.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.14;\\n\\nabstract contract ERC1271 {\\n    // bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\")\\n    bytes4 internal constant MAGICVALUE = 0x1626ba7e;\\n\\n    /**\\n     * @dev Should return whether the signature provided is valid for the provided hash\\n     * @param _hash      Hash of the data to be signed\\n     * @param _signature Signature byte array associated with _hash\\n     *\\n     * MUST return the bytes4 magic value 0x1626ba7e when function passes.\\n     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\\n     * MUST allow external calls\\n     */\\n    function isValidSignature(bytes32 _hash, bytes memory _signature)\\n        public\\n        view\\n        virtual\\n        returns (bytes4 magicValue);\\n}\\n\"\r\n    },\r\n    \"contracts/registry/ProxyRegistryInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.14;\\n\\nimport \\\"./OwnableDelegateProxy.sol\\\";\\n\\n/**\\n * @title ProxyRegistryInterface\\n * @author Wyvern Protocol Developers\\n */\\ninterface ProxyRegistryInterface {\\n    function delegateProxyImplementation() external returns (address);\\n\\n    function proxies(address owner) external returns (OwnableDelegateProxy);\\n}\\n\"\r\n    },\r\n    \"contracts/registry/AuthenticatedProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.14;\\n\\nimport \\\"./ProxyRegistry.sol\\\";\\nimport \\\"./TokenRecipient.sol\\\";\\nimport \\\"./proxy/OwnedUpgradeabilityStorage.sol\\\";\\n\\n/**\\n * @title AuthenticatedProxy\\n * @author Wyvern Protocol Developers\\n * @dev Proxy contract to hold access to assets on behalf of a user (e.g. ERC20 approve) and execute calls under particular conditions.\\n */\\ncontract AuthenticatedProxy is TokenRecipient, OwnedUpgradeabilityStorage {\\n    /* Whether initialized. */\\n    bool initialized = false;\\n\\n    /* Address which owns this proxy. */\\n    address public user;\\n\\n    /* Associated registry with contract authentication information. */\\n    ProxyRegistry public registry;\\n\\n    /* Whether access has been revoked. */\\n    bool public revoked;\\n\\n    /* Delegate call could be used to atomically transfer multiple assets owned by the proxy contract with one order. */\\n    enum HowToCall {\\n        Call,\\n        DelegateCall\\n    }\\n\\n    /* Event fired when the proxy access is revoked or unrevoked. */\\n    event Revoked(bool revoked);\\n\\n    /**\\n     * Initialize an AuthenticatedProxy\\n     *\\n     * @param addrUser Address of user on whose behalf this proxy will act\\n     * @param addrRegistry Address of ProxyRegistry contract which will manage this proxy\\n     */\\n    function initialize(address addrUser, ProxyRegistry addrRegistry) public {\\n        require(!initialized, \\\"Authenticated proxy already initialized\\\");\\n        initialized = true;\\n        user = addrUser;\\n        registry = addrRegistry;\\n    }\\n\\n    /**\\n     * Set the revoked flag (allows a user to revoke ProxyRegistry access)\\n     *\\n     * @dev Can be called by the user only\\n     * @param revoke Whether or not to revoke access\\n     */\\n    function setRevoke(bool revoke) public {\\n        require(\\n            msg.sender == user,\\n            \\\"Authenticated proxy can only be revoked by its user\\\"\\n        );\\n        revoked = revoke;\\n        emit Revoked(revoke);\\n    }\\n\\n    /**\\n     * Execute a message call from the proxy contract\\n     *\\n     * @dev Can be called by the user, or by a contract authorized by the registry as long as the user has not revoked access\\n     * @param dest Address to which the call will be sent\\n     * @param howToCall Which kind of call to make\\n     * @param data Calldata to send\\n     * @return result Result of the call (success or failure)\\n     */\\n    function proxy(\\n        address dest,\\n        HowToCall howToCall,\\n        bytes memory data\\n    ) public returns (bool result) {\\n        require(\\n            msg.sender == user || (!revoked && registry.contracts(msg.sender)),\\n            \\\"Authenticated proxy can only be called by its user, or by a contract authorized by the registry as long as the user has not revoked access\\\"\\n        );\\n        bytes memory ret;\\n        if (howToCall == HowToCall.Call) {\\n            (result, ret) = dest.call(data);\\n        } else if (howToCall == HowToCall.DelegateCall) {\\n            (result, ret) = dest.delegatecall(data);\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * Execute a message call and assert success\\n     *\\n     * @dev Same functionality as `proxy`, just asserts the return value\\n     * @param dest Address to which the call will be sent\\n     * @param howToCall What kind of call to make\\n     * @param data Calldata to send\\n     */\\n    function proxyAssert(\\n        address dest,\\n        HowToCall howToCall,\\n        bytes memory data\\n    ) public {\\n        require(proxy(dest, howToCall, data), \\\"Proxy assertion failed\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/registry/OwnableDelegateProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.14;\\n\\nimport \\\"./proxy/OwnedUpgradeabilityProxy.sol\\\";\\n\\n/**\\n * @title OwnableDelegateProxy\\n * @author Wyvern Protocol Developers\\n */\\ncontract OwnableDelegateProxy is OwnedUpgradeabilityProxy {\\n    constructor(\\n        address owner,\\n        address initialImplementation,\\n        bytes memory data\\n    ) {\\n        setUpgradeabilityOwner(owner);\\n        _upgradeTo(initialImplementation);\\n        (bool success, ) = initialImplementation.delegatecall(data);\\n        require(success, \\\"OwnableDelegateProxy failed implementation\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/registry/proxy/OwnedUpgradeabilityProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.14;\\n\\nimport \\\"./Proxy.sol\\\";\\nimport \\\"./OwnedUpgradeabilityStorage.sol\\\";\\n\\n/**\\n * @title OwnedUpgradeabilityProxy\\n * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\\n */\\ncontract OwnedUpgradeabilityProxy is Proxy, OwnedUpgradeabilityStorage {\\n    /**\\n     * @dev Event to show ownership has been transferred\\n     * @param previousOwner representing the address of the previous owner\\n     * @param newOwner representing the address of the new owner\\n     */\\n    event ProxyOwnershipTransferred(address previousOwner, address newOwner);\\n\\n    /**\\n     * @dev This event will be emitted every time the implementation gets upgraded\\n     * @param implementation representing the address of the upgraded implementation\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Tells the address of the current implementation\\n     * @return address of the current implementation\\n     */\\n    function implementation() public view override returns (address) {\\n        return _implementation;\\n    }\\n\\n    /**\\n     * @dev Upgrades the implementation address\\n     * @param _impl representing the address of the new implementation to be set\\n     */\\n    function _upgradeTo(address _impl) internal {\\n        require(\\n            _implementation != _impl,\\n            \\\"Proxy already uses this implementation\\\"\\n        );\\n        _implementation = _impl;\\n        emit Upgraded(_impl);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyProxyOwner() {\\n        require(\\n            msg.sender == proxyOwner(),\\n            \\\"Only the proxy owner can call this method\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @dev Tells the address of the proxy owner\\n     * @return the address of the proxy owner\\n     */\\n    function proxyOwner() public view returns (address) {\\n        return upgradeabilityOwner();\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param newOwner The address to transfer ownership to.\\n     */\\n    function transferProxyOwnership(address newOwner) public onlyProxyOwner {\\n        require(newOwner != address(0), \\\"New owner cannot be the null address\\\");\\n        emit ProxyOwnershipTransferred(proxyOwner(), newOwner);\\n        setUpgradeabilityOwner(newOwner);\\n    }\\n\\n    /**\\n     * @dev Allows the upgradeability owner to upgrade the current implementation of the proxy.\\n     * @param _impl representing the address of the new implementation to be set.\\n     */\\n    function upgradeTo(address _impl) public onlyProxyOwner {\\n        _upgradeTo(_impl);\\n    }\\n\\n    /**\\n     * @dev Allows the upgradeability owner to upgrade the current implementation of the proxy\\n     * and delegatecall the new implementation for initialization.\\n     * @param _impl representing the address of the new implementation to be set.\\n     * @param data represents the msg.data to bet sent in the low level call. This parameter may include the function\\n     * signature of the implementation to be called with the needed payload\\n     */\\n    function upgradeToAndCall(address _impl, bytes memory data)\\n        public\\n        payable\\n        onlyProxyOwner\\n    {\\n        upgradeTo(_impl);\\n        (bool success, ) = address(this).delegatecall(data);\\n        require(success, \\\"Call failed after proxy upgrade\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/registry/proxy/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.14;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address _impl) internal virtual {\\n        require(_impl != address(0), \\\"Proxy implementation required\\\");\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), _impl, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function implementation() public view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `implementation()`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overridden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {}\\n}\\n\"\r\n    },\r\n    \"contracts/registry/proxy/OwnedUpgradeabilityStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.14;\\n\\n/**\\n * @title OwnedUpgradeabilityStorage\\n * @dev This contract keeps track of the upgradeability owner\\n */\\ncontract OwnedUpgradeabilityStorage {\\n    // Current implementation\\n    address internal _implementation;\\n\\n    // Owner of the contract\\n    address private _upgradeabilityOwner;\\n\\n    /**\\n     * @dev Tells the address of the owner\\n     * @return address address of the owner\\n     */\\n    function upgradeabilityOwner() public view returns (address) {\\n        return _upgradeabilityOwner;\\n    }\\n\\n    /**\\n     * @dev Sets the address of the owner\\n     */\\n    function setUpgradeabilityOwner(address newUpgradeabilityOwner) internal {\\n        _upgradeabilityOwner = newUpgradeabilityOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/registry/ProxyRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.14;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"./OwnableDelegateProxy.sol\\\";\\nimport \\\"./ProxyRegistryInterface.sol\\\";\\n\\n/**\\n * @title ProxyRegistry\\n * @author Wyvern Protocol Developers\\n * @notice\\n * Proxy registry; keeps a mapping of AuthenticatedProxy contracts and mapping of contracts authorized to access them.\\n * Abstracted away from the Exchange (a) to reduce Exchange attack surface and (b) so that the Exchange contract can be upgraded without users needing to transfer assets to new proxies.\\n */\\ncontract ProxyRegistry is Ownable, ProxyRegistryInterface {\\n    /* DelegateProxy implementation contract. Must be initialized. */\\n    address public override delegateProxyImplementation;\\n\\n    /* Authenticated proxies by user. */\\n    mapping(address => OwnableDelegateProxy) public override proxies;\\n\\n    /* Contracts pending access. */\\n    mapping(address => uint256) public pending;\\n\\n    /* Contracts allowed to call those proxies. */\\n    mapping(address => bool) public contracts;\\n\\n    /* Delay period for adding an authenticated contract.\\n       This mitigates a particular class of potential attack on the Wyvern DAO (which owns this registry) - if at any point the value of assets held by proxy contracts exceeded the value of half the WYV supply (votes in the DAO),\\n       a malicious but rational attacker could buy half the Wyvern and grant themselves access to all the proxy contracts. A delay period renders this attack nonthreatening - given two weeks, if that happened, users would have\\n       plenty of time to notice and transfer their assets.\\n    */\\n    uint256 public DELAY_PERIOD = 2 weeks;\\n\\n    /**\\n     * Start the process to enable access for specified contract. Subject to delay period.\\n     *\\n     * @dev ProxyRegistry owner only\\n     * @param addr Address to which to grant permissions\\n     */\\n    function startGrantAuthentication(address addr) public onlyOwner {\\n        require(\\n            !contracts[addr] && pending[addr] == 0,\\n            \\\"Contract is already allowed in registry, or pending\\\"\\n        );\\n        pending[addr] = block.timestamp;\\n    }\\n\\n    /**\\n     * End the process to enable access for specified contract after delay period has passed.\\n     *\\n     * @dev ProxyRegistry owner only\\n     * @param addr Address to which to grant permissions\\n     */\\n    function endGrantAuthentication(address addr) public onlyOwner {\\n        require(\\n            !contracts[addr] &&\\n                pending[addr] != 0 &&\\n                ((pending[addr] + DELAY_PERIOD) < block.timestamp),\\n            \\\"Contract is no longer pending or has already been approved by registry\\\"\\n        );\\n        pending[addr] = 0;\\n        contracts[addr] = true;\\n    }\\n\\n    /**\\n     * Revoke access for specified contract. Can be done instantly.\\n     *\\n     * @dev ProxyRegistry owner only\\n     * @param addr Address of which to revoke permissions\\n     */\\n    function revokeAuthentication(address addr) public onlyOwner {\\n        contracts[addr] = false;\\n    }\\n\\n    /**\\n     * Register a proxy contract with this registry\\n     *\\n     * @dev Must be called by the user which the proxy is for, creates a new AuthenticatedProxy\\n     * @return proxy New AuthenticatedProxy contract\\n     */\\n    function registerProxy() public returns (OwnableDelegateProxy proxy) {\\n        return registerProxyFor(msg.sender);\\n    }\\n\\n    /**\\n     * Register a proxy contract with this registry, overriding any existing proxy\\n     *\\n     * @dev Must be called by the user which the proxy is for, creates a new AuthenticatedProxy\\n     * @return proxy New AuthenticatedProxy contract\\n     */\\n    function registerProxyOverride()\\n        public\\n        returns (OwnableDelegateProxy proxy)\\n    {\\n        proxy = new OwnableDelegateProxy(\\n            msg.sender,\\n            delegateProxyImplementation,\\n            abi.encodeWithSignature(\\n                \\\"initialize(address,address)\\\",\\n                msg.sender,\\n                address(this)\\n            )\\n        );\\n        proxies[msg.sender] = proxy;\\n        return proxy;\\n    }\\n\\n    /**\\n     * Register a proxy contract with this registry\\n     *\\n     * @dev Can be called by any user\\n     * @return proxy New AuthenticatedProxy contract\\n     */\\n    function registerProxyFor(address user)\\n        public\\n        returns (OwnableDelegateProxy proxy)\\n    {\\n        require(\\n            proxies[user] == OwnableDelegateProxy(payable(0)),\\n            \\\"User already has a proxy\\\"\\n        );\\n        proxy = new OwnableDelegateProxy(\\n            user,\\n            delegateProxyImplementation,\\n            abi.encodeWithSignature(\\n                \\\"initialize(address,address)\\\",\\n                user,\\n                address(this)\\n            )\\n        );\\n        proxies[user] = proxy;\\n        return proxy;\\n    }\\n\\n    /**\\n     * Transfer access\\n     */\\n    function transferAccessTo(address from, address to) public {\\n        OwnableDelegateProxy proxy = proxies[from];\\n\\n        /* CHECKS */\\n        require(\\n            OwnableDelegateProxy(payable(msg.sender)) == proxy,\\n            \\\"Proxy transfer can only be called by the proxy\\\"\\n        );\\n        require(\\n            proxies[to] == OwnableDelegateProxy(payable(0)),\\n            \\\"Proxy transfer has existing proxy as destination\\\"\\n        );\\n\\n        /* EFFECTS */\\n        delete proxies[from];\\n        proxies[to] = proxy;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/registry/TokenRecipient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.14;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\n/**\\n * @title TokenRecipient\\n * @author Wyvern Protocol Developers\\n * @dev Modified very slightly from the example on http://ethereum.org/dao (just to index log parameters).\\n */\\ncontract TokenRecipient {\\n    event ReceivedEther(address indexed sender, uint256 amount);\\n    event ReceivedTokens(\\n        address indexed from,\\n        uint256 value,\\n        address indexed token,\\n        bytes extraData\\n    );\\n\\n    /**\\n     * @dev Receive tokens and generate a log event\\n     * @param from Address from which to transfer tokens\\n     * @param value Amount of tokens to transfer\\n     * @param token Address of token\\n     * @param extraData Additional data to log\\n     */\\n    function receiveApproval(\\n        address from,\\n        uint256 value,\\n        address token,\\n        bytes memory extraData\\n    ) public {\\n        ERC20 t = ERC20(token);\\n        require(\\n            t.transferFrom(from, address(this), value),\\n            \\\"ERC20 token transfer failed\\\"\\n        );\\n        emit ReceivedTokens(from, value, token, extraData);\\n    }\\n\\n    /**\\n     * @dev Receive Ether and generate a log event\\n     */\\n    receive() external payable {\\n        emit ReceivedEther(msg.sender, msg.value);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"registryAddrs\",\"type\":\"address[]\"},{\"internalType\":\"bytes\",\"name\":\"customPersonalSignPrefix\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"registry\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staticTarget\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"staticSelector\",\"type\":\"bytes4\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"staticExtradata\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maximumFill\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"listingTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"orderbookInclusionDesired\",\"type\":\"bool\"}],\"name\":\"OrderApproved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFill\",\"type\":\"uint256\"}],\"name\":\"OrderFillChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"firstHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"secondHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"firstMaker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"secondMaker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFirstFill\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSecondFill\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"metadata\",\"type\":\"bytes32\"}],\"name\":\"OrdersMatched\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"approveOrderHash_\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"registry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"staticTarget\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"staticSelector\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"staticExtradata\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"maximumFill\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"listingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"orderbookInclusionDesired\",\"type\":\"bool\"}],\"name\":\"approveOrder_\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"approved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[16]\",\"name\":\"uints\",\"type\":\"uint256[16]\"},{\"internalType\":\"bytes4[2]\",\"name\":\"staticSelectors\",\"type\":\"bytes4[2]\"},{\"internalType\":\"bytes\",\"name\":\"firstExtradata\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"firstCalldata\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"secondExtradata\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"secondCalldata\",\"type\":\"bytes\"},{\"internalType\":\"uint8[2]\",\"name\":\"howToCalls\",\"type\":\"uint8[2]\"},{\"internalType\":\"bytes32\",\"name\":\"metadata\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"}],\"name\":\"atomicMatch_\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"fills\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"registry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"staticTarget\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"staticSelector\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"staticExtradata\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"maximumFill\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"listingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"name\":\"hashOrder_\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"hashToSign_\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"registries\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"fill\",\"type\":\"uint256\"}],\"name\":\"setOrderFill_\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"validateOrderAuthorization_\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"registry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"staticTarget\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"staticSelector\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"staticExtradata\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"maximumFill\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"listingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"name\":\"validateOrderParameters_\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "WyvernExchange", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000038000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000afd759c7356053d6ccbe6d416d4f3b66c6ea6be3000000000000000000000000000000000000000000000000000000000000001a19457468657265756d205369676e6564204d6573736167653a0a000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}