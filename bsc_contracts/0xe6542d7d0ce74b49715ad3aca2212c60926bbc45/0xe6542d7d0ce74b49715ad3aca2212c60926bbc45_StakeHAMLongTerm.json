{"SourceCode": "// SPDX-License-Identifier: Unlicensed\r\n\r\npragma solidity 0.8.0;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\t\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this;\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\t\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\t\r\n    constructor() {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\t\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\t\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\t\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\t\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\ninterface IBEP20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n\tfunction transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\tfunction isExcludedFromFees(address account) external view returns (bool);\r\n}\r\n\r\nlibrary Address {\r\n    \r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\t\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n  \r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n   \r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\t\r\n    function verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeBEP20 {\r\n    using Address for address;\r\n\t\r\n    function safeTransfer(IBEP20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IBEP20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\t\r\n    function _callOptionalReturn(IBEP20 token, bytes memory data) private {\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeBEP20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            require(abi.decode(returndata, (bool)), \"SafeBEP20: BEP20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ncontract StakeHAMLongTerm is Ownable, ReentrancyGuard{\r\n\r\n    using SafeBEP20 for IBEP20;\r\n\t\r\n\tuint256 public poolFee = 50;\r\n\tuint256 public earlyWithdrawalFee = 8000;\r\n\tuint256 public maxStakePoll = 300 * 10**12 * 10**7;\r\n\tuint256 public totalStaked;\r\n\t\r\n\tIBEP20 public stakedToken = IBEP20(0x679D5b2d94f454c950d683D159b87aa8eae37C9e);\r\n\tIBEP20 public rewardToken = IBEP20(0x08Aed8578dAaBf12d48031fA5d9727e4afD42dee);\r\n\t\r\n\tIBEP20 public monthlyRewardToken = IBEP20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\r\n\taddress public developmentWallet = 0xe301726297c6f7A517DfdB945c05F8DbC9CA5376;\r\n\t\r\n\tuint256 constant TIME_STEP = 365 days;\r\n\t\r\n\tuint256[2] public stakingAmount = [1 * 10**12 * 10**7, 1 * 10**12 * 10**7];\r\n\tuint256[2] public stakingTime = [365 days, 730 days];\r\n    uint256[2] public rewardPerMonth = [50 * 10**18, 100 * 10**18];\r\n\tuint256[2] public APR = [1544906166 * 10**16, 1544906166 * 10**16];\r\n\t\r\n\tmapping (address => uint256) public lockedAmount;\r\n\tbool public paused = false;\r\n\tmodifier whenNotPaused() {\r\n\t\trequire(!paused, \"Contract is paused\");\r\n\t\t_;\r\n\t}\r\n\t\r\n\tmodifier whenPaused() {\r\n\t\trequire(paused, \"Contract is unpaused\");\r\n\t\t_;\r\n\t}\r\n\t\r\n\tstruct Deposit {\r\n        uint256 amount; \r\n\t\tuint256 rewardTime;\r\n        uint256 startTime;\r\n\t\tuint256 endTime;\r\n\t\tuint256 monthlyReward;\r\n\t\tuint256 monthlyRewardWithdrawal;\r\n\t\tuint256 package;\r\n\t\tuint256 status;\r\n\t\tuint256 rewardRemaining;\r\n\t\tuint256 monthlyRewardRemaining;\r\n    }\r\n\t\r\n    struct UserInfo {\r\n       Deposit[] deposits;\r\n    }\r\n\r\n\tmapping(address => UserInfo) userInfo;\r\n\t\r\n    event MigrateTokens(address tokenRecovered, uint256 amount);\r\n    event Staked(address indexed user, uint256 amount);\r\n    event NewAPR(uint256 packageOneAPR, uint256 packageTwoAPR);\r\n\tevent NewWithdrawalFee(uint256 newFee);\r\n    event MaxStakePoll(uint256 amount);\r\n    event Withdraw(address indexed user, uint256 amount);\r\n    event SetDevelopmentWallet(address wallet);\r\n\tevent NewRewardPerMonth(uint256 packageOneReward, uint256 packageTwoReward);\r\n\tevent NewPoolFee(uint256 newFee);\r\n\tevent Pause();\r\n    event Unpause();\r\n\t\r\n    constructor() {}\r\n\t\r\n    function deposit(uint256 amount, uint256 package) external nonReentrant{\r\n\t    UserInfo storage user = userInfo[msg.sender];\r\n\t\t\r\n\t\trequire(!paused, \"deposit is paused\");\r\n\t\trequire(stakedToken.balanceOf(msg.sender) >= amount, \"balance not available for staking\");\r\n\t\trequire(stakedToken.isExcludedFromFees(address(this)), \"Contract address is not excluded from fee\");\r\n\t\trequire(package < stakingAmount.length, \"package not found\");\r\n\t\trequire(amount == stakingAmount[package], \"amount is not equal to required staking amount\");\r\n\t\trequire(maxStakePoll >= totalStaked + amount, \"poll staking limit is reached\");\r\n\t\t\r\n\t\tuser.deposits.push(Deposit(amount, block.timestamp, block.timestamp, block.timestamp + stakingTime[package], rewardPerMonth[package], 0, package, 1, 0, 0));\r\n\t\tlockedAmount[msg.sender] = lockedAmount[msg.sender] + amount;\r\n\t\ttotalStaked = totalStaked + amount;\r\n\t\t\r\n\t\tstakedToken.safeTransferFrom(address(msg.sender), address(this), amount);\r\n        emit Staked(msg.sender, amount);\r\n    }\r\n\t\r\n    function withdraw(uint256 stakingID) external nonReentrant{\r\n\t\tUserInfo storage user = userInfo[msg.sender];\r\n\t\trequire(user.deposits.length > stakingID, \"no staking found\");\r\n\t\trequire(user.deposits[stakingID].status == 1, \"staking already unstaked\");\r\n\t\t\r\n\t\tuint256 amount   = user.deposits[stakingID].amount;\r\n\t\tuint256 reward   = pendingreward(msg.sender, stakingID);\r\n\t\tuint256 monthlyPending = rewardpermonth(msg.sender, stakingID);\r\n\t\tuint256 fee = (reward * poolFee) / 10000;\r\n\t\t\r\n\t\trequire(stakedToken.balanceOf(address(this)) >= amount, \"token balance not available for withdraw\");\r\n\t\t\r\n\t\tif(user.deposits[stakingID].endTime > block.timestamp)\r\n\t\t{\r\n\t\t\tuint256 penalty = (amount * earlyWithdrawalFee) / 10000;\r\n\t\t\tstakedToken.safeTransfer(address(developmentWallet), penalty);\r\n\t\t\tstakedToken.safeTransfer(address(msg.sender), amount - penalty);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t    stakedToken.safeTransfer(address(msg.sender), amount);\r\n\t\t}\r\n\t\t\r\n\t\tif(monthlyPending > 0 && monthlyRewardToken.balanceOf(address(this)) >= monthlyPending)\r\n\t\t{\r\n\t\t    monthlyRewardToken.safeTransfer(address(msg.sender), monthlyPending);\r\n\t\t\tuser.deposits[stakingID].monthlyRewardWithdrawal = user.deposits[stakingID].monthlyRewardWithdrawal + monthlyPending;\r\n\t\t}\r\n\t\telse if(monthlyPending > 0)\r\n\t\t{\r\n\t\t    user.deposits[stakingID].monthlyRewardRemaining = monthlyPending;\r\n\t\t}\r\n\t\t\r\n\t\tif(reward > 0 && rewardToken.balanceOf(address(this)) >= reward - fee)\r\n\t\t{\r\n\t\t    rewardToken.safeTransfer(address(msg.sender), reward - fee);\r\n\t\t}\r\n\t\telse if(reward > 0)\r\n\t\t{\r\n\t\t    user.deposits[stakingID].rewardRemaining = reward;\r\n\t\t}\r\n\t\t\r\n\t\tlockedAmount[msg.sender] = lockedAmount[msg.sender] - amount;\r\n\t\tuser.deposits[stakingID].status = 2; \r\n\t\ttotalStaked = totalStaked - amount;\r\n\t\t\r\n\t\temit Withdraw(msg.sender, amount + reward);\r\n    }\r\n\t\r\n\tfunction withdrawReward(uint256 stakingID) external nonReentrant{\r\n\t\tUserInfo storage user = userInfo[msg.sender];\r\n\t\trequire(user.deposits[stakingID].amount > 0, \"no staking found\");\r\n\t\t\r\n\t\tuint256 pending = pendingreward(msg.sender, stakingID);\r\n\t\tuint256 reward  = user.deposits[stakingID].rewardRemaining + pending;\r\n        require(reward > 0, \"no reward found\");\r\n\t\t\r\n\t\tuint256 fee = (reward * poolFee) / 10000;\r\n\t\t\r\n\t\trequire(rewardToken.balanceOf(address(this)) >= reward - fee, \"Token balance not available for withdraw\");\r\n\t\t\r\n\t\tuser.deposits[stakingID].rewardTime = block.timestamp;\r\n\t\tuser.deposits[stakingID].rewardRemaining = 0;\r\n\t\t\r\n\t\trewardToken.safeTransfer(address(msg.sender), reward - fee);\r\n\t\temit Withdraw(msg.sender, reward);\r\n    }\r\n\t\r\n\tfunction pendingreward(address staker, uint256 stakingID) public view returns (uint256) {\r\n        UserInfo storage user = userInfo[staker];\r\n\t\t\r\n\t\tif(user.deposits[stakingID].amount > 0 && user.deposits[stakingID].status == 1)\r\n\t\t{\r\n\t\t\tuint256 sTime  = user.deposits[stakingID].rewardTime;\r\n\t\t\tuint256 eTime  = block.timestamp > user.deposits[stakingID].endTime ? user.deposits[stakingID].endTime : block.timestamp;\r\n\t\t\tuint256 reward = (uint(user.deposits[stakingID].amount) * (APR[user.deposits[stakingID].package]) * (eTime-sTime)) / (TIME_STEP * stakingAmount[user.deposits[stakingID].package]);\r\n\t\t\treturn reward;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t    return 0;\r\n\t\t}\r\n    }\r\n\t\r\n\tfunction withdrawMonthly(uint256 stakingID) external nonReentrant{\r\n\t\tUserInfo storage user = userInfo[msg.sender];\r\n\t\trequire(user.deposits[stakingID].amount > 0, \"No staking found\");\r\n\t\t\r\n\t\tuint256 pending = rewardpermonth(msg.sender, stakingID);\r\n\t\tuint256 reward  = user.deposits[stakingID].monthlyRewardRemaining + pending;\r\n        require(reward > 0, \"No reward found\");\r\n\t\t\r\n\t\trequire(monthlyRewardToken.balanceOf(address(this)) >= reward, \"Token balance not available for withdraw\");\r\n\t\t\r\n\t\tuser.deposits[stakingID].monthlyRewardWithdrawal = user.deposits[stakingID].monthlyRewardWithdrawal + reward;\r\n\t\tuser.deposits[stakingID].monthlyRewardRemaining = 0;\r\n\t\t\r\n\t\tmonthlyRewardToken.safeTransfer(address(msg.sender), reward);\r\n\t\temit Withdraw(msg.sender, reward);\r\n    }\r\n\t\r\n\tfunction rewardpermonth(address staker, uint256 stakingID) public view returns (uint256) {\r\n        UserInfo storage user = userInfo[staker];\r\n\t\t\r\n\t\tif(user.deposits[stakingID].amount > 0 && user.deposits[stakingID].status == 1)\r\n\t\t{\r\n\t\t\tuint256 sTime   = user.deposits[stakingID].startTime;\r\n\t\t\tuint256 eTime   = block.timestamp > user.deposits[stakingID].endTime ? user.deposits[stakingID].endTime : block.timestamp;\r\n\t\t\tuint256 tTime   = (eTime - sTime) / 30 days;\r\n\t\t\tif(tTime > 12)\r\n\t\t\t{\r\n\t\t\t    tTime = 12;\r\n\t\t\t}\r\n\t\t\tuint256 reward  = tTime * user.deposits[stakingID].monthlyReward;\r\n\t\t\tuint256 rewardWithdrawal  = user.deposits[stakingID].monthlyRewardWithdrawal;\r\n\t\t\tuint256 pending = reward - rewardWithdrawal;\r\n\t\t\treturn pending;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t    return 0;\r\n\t\t}\r\n    }\r\n\t\r\n    function getUserStaking(address staker) public view returns (uint256) {\r\n\t    UserInfo storage user = userInfo[staker];\r\n\t\treturn user.deposits.length;\r\n    }\r\n\t\r\n\tfunction getUserStats(address staker, uint256 stakingID) public view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256) {\r\n\t    UserInfo storage user = userInfo[staker];\r\n\t\treturn (user.deposits[stakingID].amount, user.deposits[stakingID].startTime, user.deposits[stakingID].endTime, user.deposits[stakingID].monthlyReward, user.deposits[stakingID].status, user.deposits[stakingID].rewardRemaining, user.deposits[stakingID].monthlyRewardRemaining);\r\n    }\r\n\t\r\n\tfunction migrateTokens(address receiver, address tokenAddress, uint256 tokenAmount) external onlyOwner nonReentrant{\r\n       require(receiver != address(0), \"zero-address not allowed\");\r\n\t   \r\n\t   IBEP20(tokenAddress).safeTransfer(address(receiver), tokenAmount);\r\n       emit MigrateTokens(tokenAddress, tokenAmount);\r\n    }\r\n\t\r\n\tfunction updateMaxStakePoll(uint256 amount) external onlyOwner {\r\n\t    require(stakedToken.totalSupply() >= amount, \"Total supply is less than max staking amount\");\r\n        require(maxStakePoll >= totalStaked, \"Maximum staking amount is less than staked token\");\r\n\t\t\r\n        maxStakePoll = amount;\r\n        emit MaxStakePoll(amount);\r\n    }\r\n\t\r\n\tfunction updateEarlyWithdrawalFee(uint256 newFee) external onlyOwner {\r\n\t    require(earlyWithdrawalFee >= 6000, \"Early withdrawal fee is less than `60%`\");\r\n\t\trequire(earlyWithdrawalFee <= 8500, \"Early withdrawal fee is greater than `85%`\");\r\n\t\t\r\n        earlyWithdrawalFee = newFee;\r\n        emit NewWithdrawalFee(newFee);\r\n    }\r\n\t\r\n\tfunction SetAPR(uint256 packageOneAPR, uint256 packageTwoAPR) external onlyOwner {\r\n\t    require(packageOneAPR >= 1 * 10**10 && packageOneAPR <= rewardToken.totalSupply(), \"APR is less then `0.00000001` token or greater than total supply\");\r\n\t\trequire(packageTwoAPR >= 1 * 10**10 && packageTwoAPR <= rewardToken.totalSupply(), \"APR is less then `0.00000001` token or greater than total supply\");\r\n\r\n\t    APR[0] = packageOneAPR;\r\n        APR[1] = packageTwoAPR;\r\n\t\t\r\n\t\temit NewAPR(packageOneAPR, packageTwoAPR);\r\n    }\r\n\t\r\n\tfunction SetRewardPerMonth(uint256 packageOneReward, uint256 packageTwoReward) external onlyOwner {\r\n\t    require(packageOneReward >= 20 * 10**18 && packageOneReward <= 160 * 10**18, \"Reward amount is less then `20` or greater than `160` BUSD\");\r\n\t\trequire(packageTwoReward >= 30 * 10**18 && packageTwoReward <= 120 * 10**18, \"Reward amount is less then `30` or greater than `120` BUSD\");\r\n\t\t\r\n\t    rewardPerMonth[0] = packageOneReward;\r\n        rewardPerMonth[1] = packageTwoReward;\r\n\t\t\r\n\t\temit NewRewardPerMonth(packageOneReward, packageTwoReward);\r\n    }\r\n\t\r\n\tfunction updatePoolFee(uint256 newFee) external onlyOwner {\r\n\t\trequire(newFee <= 200, \"Fee is greater than `2%`\");\r\n\t\t\r\n        poolFee = newFee;\r\n        emit NewPoolFee(newFee);\r\n    }\r\n\r\n\tfunction setDevelopmentWallet(address payable newWallet) external onlyOwner{\r\n        require(newWallet != address(0), \"zero-address not allowed\");\r\n\t\t\r\n\t    developmentWallet = newWallet;\r\n\t\temit SetDevelopmentWallet(newWallet);\r\n    }\r\n\t\r\n    function pause() whenNotPaused external onlyOwner{\r\n\t\tpaused = true;\r\n\t\temit Pause();\r\n\t}\r\n\t\r\n\tfunction unpause() whenPaused external onlyOwner{\r\n\t\tpaused = false;\r\n\t\temit Unpause();\r\n\t}\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MaxStakePoll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenRecovered\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MigrateTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"packageOneAPR\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"packageTwoAPR\",\"type\":\"uint256\"}],\"name\":\"NewAPR\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"NewPoolFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"packageOneReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"packageTwoReward\",\"type\":\"uint256\"}],\"name\":\"NewRewardPerMonth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"NewWithdrawalFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"SetDevelopmentWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"APR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"packageOneAPR\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"packageTwoAPR\",\"type\":\"uint256\"}],\"name\":\"SetAPR\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"packageOneReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"packageTwoReward\",\"type\":\"uint256\"}],\"name\":\"SetRewardPerMonth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"package\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"developmentWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"earlyWithdrawalFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getUserStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakingID\",\"type\":\"uint256\"}],\"name\":\"getUserStats\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxStakePoll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"migrateTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"monthlyRewardToken\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakingID\",\"type\":\"uint256\"}],\"name\":\"pendingreward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardPerMonth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakingID\",\"type\":\"uint256\"}],\"name\":\"rewardpermonth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"setDevelopmentWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakedToken\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakingAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"updateEarlyWithdrawalFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"updateMaxStakePoll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"updatePoolFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakingID\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakingID\",\"type\":\"uint256\"}],\"name\":\"withdrawMonthly\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakingID\",\"type\":\"uint256\"}],\"name\":\"withdrawReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "StakeHAMLongTerm", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://69507fc53cfaa3ba69534e41c5e4b40a0909723bd7a9a39545001850e46fb9f4"}