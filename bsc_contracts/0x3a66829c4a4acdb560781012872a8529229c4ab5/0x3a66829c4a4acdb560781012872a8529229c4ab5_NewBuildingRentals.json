{"SourceCode": "pragma solidity 0.5.9;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"Transfer to null address is not allowed\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n}\r\n\r\n\r\ncontract Beneficiary is Ownable {\r\n\r\n    address payable public beneficiary;\r\n\r\n    constructor() public  {\r\n        beneficiary = msg.sender;\r\n    }\r\n\r\n    function setBeneficiary(address payable _beneficiary) public onlyOwner {\r\n        beneficiary = _beneficiary;\r\n    }\r\n\r\n    function withdrawal(uint256 value) public onlyOwner {\r\n        if (value > address(this).balance) {\r\n            revert(\"Insufficient balance\");\r\n        }\r\n\r\n        beneficiaryPayout(value);\r\n    }\r\n\r\n    function withdrawalAll() public onlyOwner {\r\n        beneficiaryPayout(address(this).balance);\r\n    }\r\n\r\n    function beneficiaryPayout(uint256 value) internal {\r\n        beneficiary.transfer(value);\r\n        emit BeneficiaryPayout(value);\r\n    }\r\n\r\n    event BeneficiaryPayout(uint256 value);\r\n}\r\n\r\n\r\n\r\ncontract Manageable is Beneficiary {\r\n\r\n    uint256 DECIMALS = 10e8;\r\n\r\n    bool maintenance = false;\r\n\r\n    mapping(address => bool) public managers;\r\n\r\n    modifier onlyManager() {\r\n\r\n        require(managers[msg.sender] || msg.sender == address(this), \"Only managers allowed\");\r\n        _;\r\n    }\r\n\r\n    modifier notOnMaintenance() {\r\n        require(!maintenance);\r\n        _;\r\n    }\r\n\r\n    bool saleOpen = false;\r\n\r\n    modifier onlyOnSale() {\r\n        require(saleOpen);\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        managers[msg.sender] = true;\r\n    }\r\n\r\n    function setMaintenanceStatus(bool _status) public onlyManager {\r\n        maintenance = _status;\r\n        emit Maintenance(_status);\r\n    }\r\n\r\n    function setManager(address _manager) public onlyOwner {\r\n        managers[_manager] = true;\r\n    }\r\n\r\n    function deleteManager(address _manager) public onlyOwner {\r\n        delete managers[_manager];\r\n    }\r\n\r\n    function _addressToPayable(address _address) internal pure returns (address payable) {\r\n        return address(uint160(_address));\r\n    }\r\n\r\n    event Maintenance(bool status);\r\n\r\n    event FailedPayout(address to, uint256 value);\r\n\r\n}\r\n\r\n\r\ncontract Verifier is Manageable {\r\n\r\n    mapping(address => bool) signers;\r\n\r\n    constructor() public {\r\n    }\r\n\r\n    function addSigner(address _signer) public onlyManager {\r\n        signers[_signer] = true;\r\n    }\r\n\r\n    function removeSigner(address _signer) public onlyManager {\r\n        signers[_signer] = false;\r\n    }\r\n    /**\r\n    * @dev Recover signer address from a message by using their signature\r\n    * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n    * @param sig bytes signature, the signature is generated using web3.eth.sign(). Inclusive \"0x...\"\r\n    */\r\n    function verifySignature(bytes32 hash, bytes memory sig) public view returns (address) {\r\n        require(sig.length == 65, \"Require correct length\");\r\n\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // Divide the signature in r, s and v variables\r\n        assembly {\r\n            r := mload(add(sig, 32))\r\n            s := mload(add(sig, 64))\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n\r\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n\r\n        require(v == 27 || v == 28, \"Signature version not match\");\r\n\r\n        address addr = ecrecover(hash, v, r, s);\r\n        require(signers[addr], 'Invalid signature');\r\n\r\n        return addr;\r\n    }\r\n}\r\n\r\nlibrary Strings {\r\n\r\n    function strConcat(string memory _a, string memory _b, string memory _c, string memory _d, string memory _e) internal pure returns (string memory) {\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (uint i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (uint i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (uint i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n        for (uint i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n        return string(babcde);\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b, string memory _c, string memory _d) internal pure returns (string memory) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b, string memory _c) internal pure returns (string memory) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string memory _a, string memory _b) internal pure returns (string memory) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    function uint2str(uint i) internal pure returns (string memory) {\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (i != 0) {\r\n            bstr[k--] = byte(uint8(48 + i % 10));\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    function bytes32ToString(bytes32 x) internal pure returns (string memory) {\r\n        bytes memory bytesString = new bytes(32);\r\n        uint charCount = 0;\r\n        for (uint j = 0; j < 32; j++) {\r\n            byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));\r\n            if (char != 0) {\r\n                bytesString[charCount] = char;\r\n                charCount++;\r\n            }\r\n        }\r\n        bytes memory bytesStringTrimmed = new bytes(charCount);\r\n        for (uint j = 0; j < charCount; j++) {\r\n            bytesStringTrimmed[j] = bytesString[j];\r\n        }\r\n        return string(bytesStringTrimmed);\r\n    }\r\n\r\n    function bytesToUInt(bytes32 b) internal pure returns (uint256){\r\n        uint256 number;\r\n        for(uint i=0;i<b.length;i++){\r\n            number = number + uint256(uint8(b[i]))*(2**(8*(b.length-(i+1))));\r\n        }\r\n        return number;\r\n    }\r\n\r\n}\r\n\r\n\r\ninterface IERC721 {\r\n    function name() external view returns (string memory _name);\r\n\r\n    function symbol() external view returns (string memory _symbol);\r\n\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n\r\n    function approve(address _approved, uint256 _tokenId) external;\r\n\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\r\n\r\n    function baseTokenURI() external view returns (string memory);\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n\r\n}\r\n\r\ncontract LockableToken is Manageable {\r\n    mapping(uint256 => bool) public locks;\r\n\r\n    modifier onlyNotLocked(uint256 _tokenId) {\r\n        require(!locks[_tokenId]);\r\n        _;\r\n    }\r\n\r\n    function isLocked(uint256 _tokenId) public view returns (bool) {\r\n        return locks[_tokenId];\r\n    }\r\n\r\n    function lockToken(uint256 _tokenId) public onlyManager {\r\n        locks[_tokenId] = true;\r\n    }\r\n\r\n    function unlockToken(uint256 _tokenId) public onlyManager {\r\n        locks[_tokenId] = false;\r\n    }\r\n\r\n    function _lockToken(uint256 _tokenId) internal {\r\n        locks[_tokenId] = true;\r\n    }\r\n\r\n    function _unlockToken(uint256 _tokenId) internal {\r\n        locks[_tokenId] = false;\r\n    }\r\n\r\n}\r\n\r\ninterface IERC165 {\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceID The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 gas.\r\n    /// @return `true` if the contract implements `interfaceID` and\r\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\ninterface IERC721Receiver {\r\n    /// @notice Handle the receipt of an NFT\r\n    /// @dev The ERC721 smart contract calls this function on the recipient\r\n    ///  after a `transfer`. This function MAY throw to revert and reject the\r\n    ///  transfer. Return of other than the magic value MUST result in the\r\n    ///  transaction being reverted.\r\n    ///  Note: the contract address is always the message sender.\r\n    /// @param _operator The address which called `safeTransferFrom` function\r\n    /// @param _from The address which previously owned the token\r\n    /// @param _tokenId The NFT identifier which is being transferred\r\n    /// @param _data Additional data with no specified format\r\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    ///  unless throwing\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\r\n}\r\n\r\n\r\n\r\ncontract ERC721 is Manageable, LockableToken, IERC721, IERC165 {\r\n    using Strings for string;\r\n\r\n    mapping(address => uint256) public balances;\r\n    mapping(uint256 => address) public approved;\r\n    mapping(address => mapping(address => bool)) private operators;\r\n    mapping(uint256 => address) private tokenOwner;\r\n\r\n    uint256 public totalSupply = 0;\r\n\r\n    string private _tokenURI = \"\";\r\n\r\n    string private tokenName = '';\r\n    string private tokenSymbol = '';\r\n\r\n    modifier onlyTokenOwner(uint256 _tokenId) {\r\n        require(msg.sender == tokenOwner[_tokenId]);\r\n        _;\r\n    }\r\n\r\n    function setName(string memory _name) public onlyManager {\r\n        tokenName = _name;\r\n    }\r\n\r\n    function setSymbol(string memory _symbol) public onlyManager {\r\n        tokenSymbol = _symbol;\r\n    }\r\n\r\n    function name() external view returns (string memory _name) {\r\n        return tokenName;\r\n    }\r\n\r\n    function symbol() external view returns (string memory _symbol) {\r\n        return tokenSymbol;\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool) {\r\n        return interfaceID == 0x5b5e139f || interfaceID == 0x80ac58cd;\r\n    }\r\n\r\n    function setBaseTokenURI(string memory _newTokenURI) public onlyManager {\r\n        _tokenURI = _newTokenURI;\r\n    }\r\n\r\n    function ownerOf(uint256 _tokenId) public view returns (address) {\r\n        return tokenOwner[_tokenId];\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public onlyNotLocked(_tokenId) {\r\n        require(_to != address(0));\r\n        require(_isApprovedOrOwner(msg.sender, _tokenId));\r\n\r\n        _transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    function approve(address _approved, uint256 _tokenId) public onlyNotLocked(_tokenId) {\r\n        address owner = ownerOf(_tokenId);\r\n        require(_approved != owner);\r\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\r\n\r\n        approved[_tokenId] = _approved;\r\n\r\n        emit Approval(owner, _approved, _tokenId);\r\n    }\r\n\r\n    function setApprovalForAll(address _operator, bool _approved) public {\r\n        require(_operator != msg.sender);\r\n\r\n        operators[msg.sender][_operator] = _approved;\r\n        emit ApprovalForAll(msg.sender, _operator, _approved);\r\n    }\r\n\r\n    function isApprovedForAll(address _owner, address _operator) public view returns (bool) {\r\n        return operators[_owner][_operator];\r\n    }\r\n\r\n    function getApproved(uint256 _tokenId) public view returns (address) {\r\n        return approved[_tokenId];\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\r\n        address owner = ownerOf(tokenId);\r\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n    }\r\n\r\n    function transfer(address _from, address _to, uint256 _tokenId) public onlyTokenOwner(_tokenId) onlyNotLocked(_tokenId) {\r\n        require(_to != address(0));\r\n        _transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    function _transfer(address _from, address _to, uint256 _tokenId) internal {\r\n        require(ownerOf(_tokenId) == _from);\r\n\r\n        delete approved[_tokenId];\r\n\r\n        if (_from != address(0)) {\r\n            balances[_from]--;\r\n        } else {\r\n            totalSupply++;\r\n        }\r\n\r\n        if (_to != address(0)) {\r\n            balances[_to]++;\r\n        }\r\n\r\n        tokenOwner[_tokenId] = _to;\r\n\r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    function _mint(uint256 _tokenId, address _owner) internal {\r\n        _transfer(address(0), _owner, _tokenId);\r\n    }\r\n\r\n    function _burn(uint256 _tokenId) internal {\r\n        _transfer(ownerOf(_tokenId), address(0), _tokenId);\r\n    }\r\n\r\n\r\n    function baseTokenURI() public view returns (string memory) {\r\n        return _tokenURI;\r\n    }\r\n\r\n    function tokenURI(uint256 _tokenId) external view returns (string memory) {\r\n        return Strings.strConcat(\r\n            baseTokenURI(),\r\n            Strings.uint2str(_tokenId)\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable {\r\n        require(_isApprovedOrOwner(msg.sender, _tokenId));\r\n        require(_to != address(0));\r\n\r\n        IERC721Receiver receiver = IERC721Receiver(_to);\r\n\r\n        _transfer(_from, _to, _tokenId);\r\n\r\n        require(receiver.onERC721Received(msg.sender, _from, _tokenId, data) == bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")));\r\n    }\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable {\r\n        require(_isApprovedOrOwner(msg.sender, _tokenId));\r\n        require(_to != address(0));\r\n\r\n        IERC721Receiver receiver = IERC721Receiver(_to);\r\n\r\n        _transfer(_from, _to, _tokenId);\r\n\r\n        require(receiver.onERC721Received(msg.sender, _from, _tokenId, \"\") == bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")));\r\n    }\r\n\r\n    function burn(uint256 _tokenId) public onlyManager {\r\n        _burn(_tokenId);\r\n    }\r\n\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n}\r\n\r\ncontract Land is Manageable, ERC721 {\r\n\r\n    struct Token {\r\n        int64 x;\r\n        int64 y;\r\n        uint8 building;\r\n        uint8 level;\r\n        uint8 buildingType;\r\n    }\r\n\r\n    mapping(int => mapping(int => uint16)) public map;\r\n    mapping(int => mapping(int => uint)) public buyPrice;\r\n    mapping(int => mapping(int => uint256)) public mapReverse;\r\n\r\n    Token[] public tokens;\r\n\r\n    constructor() public {\r\n    }\r\n\r\n    function mint(address _owner, int64 _x, int64 _y) public onlyManager returns (uint256 _tokenId) {\r\n        tokens.push(Token(_x, _y, 0, 0, 0));\r\n        mapReverse[_x][_y] = tokens.length - 1;\r\n        _mint(mapReverse[_x][_y], _owner);\r\n        return tokens.length - 1;\r\n    }\r\n\r\n    function batchBuyPrice(\r\n        int64[] memory _x,\r\n        int64[] memory _y,\r\n        uint[] memory _buyPrice\r\n    ) public onlyManager {\r\n        for(uint i = 0; i < _x.length; i++) {\r\n            buyPrice[_x[i]][_y[i]] = _buyPrice[i];\r\n        }\r\n    }\r\n\r\n    function batchMint(\r\n        address[] memory _owner,\r\n        int64[] memory _x,\r\n        int64[] memory _y,\r\n        uint8[] memory _building,\r\n        uint8[] memory _buildingType,\r\n        uint8[] memory _level,\r\n        uint16[] memory _regionId,\r\n        uint[] memory _buyPrices\r\n    ) public onlyManager {\r\n        for(uint i = 0; i < _owner.length; i++) {\r\n            if(mapReverse[_x[i]][_y[i]] > 0) {\r\n                continue;\r\n            }\r\n            tokens.push(Token(_x[i], _y[i], _building[i], _level[i], _buildingType[i]));\r\n            mapReverse[_x[i]][_y[i]] = tokens.length - 1;\r\n            map[_x[i]][_y[i]] = _regionId[i];\r\n            buyPrice[_x[i]][_y[i]] = _buyPrices[i];\r\n            _mint(mapReverse[_x[i]][_y[i]], _owner[i]);\r\n        }\r\n    }\r\n\r\n    function batchMintHugeBuildings(\r\n        address[] memory _owner,\r\n        int64[] memory _x,\r\n        int64[] memory _y,\r\n        uint8[] memory _building,\r\n        uint8[] memory _buildingType,\r\n        uint8[] memory _type,\r\n        uint16[] memory _regionId\r\n    ) public onlyManager {\r\n        for(uint i = 0; i < _owner.length; i++) {\r\n            if(mapReverse[_x[i]][_y[i]] > 0) {\r\n                continue;\r\n            }\r\n\r\n            if(_type[i] == 1) {\r\n                tokens.push(Token(_x[i], _y[i], _building[i], 6, _buildingType[i]));\r\n\r\n                mapReverse[_x[i]][_y[i]] = tokens.length - 1;\r\n                map[_x[i]][_y[i]] = _regionId[i];\r\n\r\n                mapReverse[_x[i] - 1][_y[i]] = tokens.length - 1;\r\n                map[_x[i] - 1][_y[i]] = _regionId[i];\r\n\r\n            } else if(_type[i] == 2) {\r\n                tokens.push(Token(_x[i], _y[i], _building[i], 6, _buildingType[i]));\r\n\r\n                mapReverse[_x[i]][_y[i]] = tokens.length - 1;\r\n                map[_x[i]][_y[i]] = _regionId[i];\r\n\r\n                mapReverse[_x[i]][_y[i] - 1] = tokens.length - 1;\r\n                map[_x[i]][_y[i] - 1] = _regionId[i];\r\n\r\n            } else if(_type[i] == 3) {\r\n                tokens.push(Token(_x[i], _y[i], _building[i], 7, _buildingType[i]));\r\n\r\n                mapReverse[_x[i]][_y[i]] = tokens.length - 1;\r\n                map[_x[i]][_y[i]] = _regionId[i];\r\n\r\n\r\n                mapReverse[_x[i]][_y[i] - 1] = tokens.length - 1;\r\n                map[_x[i]][_y[i] - 1] = _regionId[i];\r\n\r\n                mapReverse[_x[i] - 1][_y[i]] = tokens.length - 1;\r\n                map[_x[i] - 1][_y[i]] = _regionId[i];\r\n\r\n                mapReverse[_x[i] - 1][_y[i] - 1] = tokens.length - 1;\r\n                map[_x[i] - 1][_y[i] - 1] = _regionId[i];\r\n\r\n            }\r\n            _mint(tokens.length - 1, _owner[i]);\r\n        }\r\n    }\r\n\r\n    function burn(uint _tokenId) public onlyManager {\r\n        _burn(_tokenId);\r\n        delete mapReverse[tokens[_tokenId].x][tokens[_tokenId].y];\r\n        delete tokens[_tokenId];\r\n    }\r\n\r\n    function ownerOfXY(int _x, int _y) public view returns (address) {\r\n        return ownerOf(mapReverse[_x][_y]);\r\n    }\r\n\r\n    function setRegion(int64 _x, int64 _y, uint16 _region) public onlyManager {\r\n        map[_x][_y] = _region;\r\n    }\r\n\r\n    function setCell(int64 _x, int64 _y, uint8 _building, uint8 _level, uint8 _typeId) public onlyManager returns (uint)  {\r\n        require(mapReverse[_x][_y] > 0);\r\n\r\n        Token storage _token = tokens[mapReverse[_x][_y]];\r\n\r\n        _token.building = _building;\r\n        _token.level = _level;\r\n        _token.buildingType = _typeId;\r\n\r\n        return mapReverse[_x][_y];\r\n    }\r\n\r\n    function setToken(uint _tokenId, uint8 _building, uint8 _level, uint8 _typeId) public onlyManager {\r\n        Token storage _token = tokens[_tokenId];\r\n\r\n        _token.building = _building;\r\n        _token.level = _level;\r\n        _token.buildingType = _typeId;\r\n    }\r\n\r\n    function setToken(int64 _x, int64 _y, uint _tokenId) public onlyManager {\r\n        tokens[_tokenId] = Token(_x, _y, 0, 0, 0);\r\n        mapReverse[_x][_y] = _tokenId;\r\n    }\r\n\r\n    function setBuyPrice(int64 _x, int64 _y, uint _buyPrice) public onlyManager {\r\n        buyPrice[_x][_y] = _buyPrice;\r\n    }\r\n\r\n    function getCell(int64 _x, int64 _y) public view\r\n    returns (\r\n        uint8 buildingId,\r\n        uint8 buildingLevel,\r\n        uint8 buildingTypeId,\r\n        uint16 regionId,\r\n        uint tokenId\r\n    ) {\r\n        uint _tokenId = mapReverse[_x][_y];\r\n        uint16 _regionId = map[_x][_y];\r\n        return (tokens[_tokenId].building, tokens[_tokenId].level, tokens[_tokenId].buildingType, _regionId, _tokenId) ;\r\n    }\r\n\r\n    function getCellByToken(uint256 _tokenId) public view\r\n    returns (\r\n        uint8 buildingId,\r\n        uint8 buildingLevel,\r\n        uint8 buildingTypeId,\r\n        uint16 regionId,\r\n        uint tokenId\r\n    ) {\r\n        return getCell(tokens[_tokenId].x, tokens[_tokenId].y);\r\n    }\r\n\r\n    function getRegionId(int64 _x, int64 _y) public view returns (uint16 regionId) {\r\n        return map[_x][_y];\r\n    }\r\n\r\n    function getRegionId(uint _tokenId) public view returns (uint16 regionId) {\r\n        return map[tokens[_tokenId].x][tokens[_tokenId].y];\r\n    }\r\n\r\n    function getTokens(int64 _x, int64 _y, int _radius) public view returns (uint256[] memory tokenIds, uint256[] memory buyPrices, address payable[] memory owners) {\r\n        tokenIds = new uint256[]((uint(_radius) * 2 + 1) ** 2 - 1);\r\n        buyPrices = new uint256[]((uint(_radius) * 2 + 1) ** 2 - 1);\r\n        owners = new address payable[]((uint(_radius) * 2 + 1) ** 2 - 1);\r\n        uint i = 0;\r\n        for (int xi = _x - _radius; xi <= _x + _radius; xi++) {\r\n            for (int yi = _y - _radius; yi <= _y + _radius; yi++) {\r\n                if (_x == xi && _y == yi) {\r\n                    continue;\r\n                }\r\n\r\n                if (buyPrice[xi][yi] > 0) {\r\n                    tokenIds[i] = mapReverse[xi][yi];\r\n                    buyPrices[i] = buyPrice[xi][yi];\r\n                    owners[i] = _addressToPayable(ownerOfXY(xi, yi));\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function buyLand(int64 _x, int64 _y, uint256 _buyPrice, address _owner) public onlyManager {\r\n        require(map[_x][_y] > 0);\r\n        mint(_owner, _x, _y);\r\n        buyPrice[_x][_y] = _buyPrice;\r\n    }\r\n\r\n    function mergeCells(int64[] memory _x, int64[] memory _y, address _owner) public onlyManager returns (uint _baseTokenId) {\r\n        int64[2] memory _max = [_x[0], _y[0]];\r\n\r\n        for(uint i = 0; i < _x.length; i++) {\r\n            require(ownerOfXY(_x[i], _y[i]) == _owner);\r\n            require(tokens[mapReverse[_x[i]][_y[i]]].building == tokens[mapReverse[_x[0]][_y[0]]].building);\r\n            require(tokens[mapReverse[_x[i]][_y[i]]].level == tokens[mapReverse[_x[0]][_y[0]]].level);\r\n            if(_x[i] > _max[0]) {\r\n                _max[0] = _x[i];\r\n            }\r\n\r\n            if(_y[i] > _max[1]) {\r\n                _max[1] = _y[i];\r\n            }\r\n        }\r\n\r\n        _baseTokenId = mapReverse[_max[0]][_max[1]];\r\n\r\n        for(uint i = 0; i < _x.length; i++) {\r\n            if(_baseTokenId != mapReverse[_x[i]][_y[i]]) {\r\n                if(ownerOf(mapReverse[_x[i]][_y[i]]) != address(0)) {\r\n                    _burn(mapReverse[_x[i]][_y[i]]);\r\n                }\r\n                mapReverse[_x[i]][_y[i]] = _baseTokenId;\r\n            }\r\n        }\r\n    }\r\n\r\n    function unmergeToken(uint _tokenId) public onlyManager {\r\n        int64 _x = tokens[_tokenId].x;\r\n        int64 _y = tokens[_tokenId].y;\r\n        address _owner = ownerOf(_tokenId);\r\n\r\n        while(true) {\r\n            if(mapReverse[_x][_y] != _tokenId) {\r\n                _x = tokens[_tokenId].x;\r\n                _y--;\r\n            }\r\n\r\n            if(mapReverse[_x][_y] != _tokenId) {\r\n                break;\r\n            }\r\n\r\n            if(_x != tokens[_tokenId].x || _y != tokens[_tokenId].y) {\r\n                mint(_owner, _x, _y);\r\n            }\r\n\r\n            _x--;\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract Buildings is Manageable {\r\n    struct BuildingLimits {\r\n        uint8 maxCitizen;\r\n        uint8 minCitizen;\r\n        uint8 maxCar;\r\n        uint8 maxAppliance;\r\n        uint8 maxHelicopters;\r\n    }\r\n\r\n    struct Fees {\r\n        uint256 fedFee;\r\n        uint256 distFee;\r\n    }\r\n\r\n    struct Requirements {\r\n        uint8 resourceId;\r\n        uint256 amount;\r\n    }\r\n\r\n    mapping(uint8 => uint8) public buildingTypes;\r\n    uint256[7] public buildingPrices;\r\n    mapping(uint8 => mapping(uint8 => Requirements[])) public buildingResourcesRequirements;\r\n\r\n\r\n    mapping(uint8 => uint256) public resourcesFees;\r\n    mapping(uint8 => mapping(uint8 => Requirements[])) public resourcesProductionRequirements;\r\n\r\n    uint256 public appliancesFee;\r\n    mapping(uint8 => Requirements[]) public appliancesProductionRequirements;\r\n\r\n    mapping(uint8 => Requirements[]) public citizensProductionRequirements;\r\n    Requirements[] public officeCollectRequirements;\r\n    Requirements[] public municipalCollectRequirements;\r\n\r\n    mapping(uint16 => BuildingLimits[8]) public buildingLimits;\r\n\r\n    uint256 public staminaRestoreFee;\r\n    uint256 staminaRestorePrice;\r\n\r\n    uint256[8] public residentialFees;\r\n    mapping(uint8 => uint8[2]) public residentialPercents;\r\n\r\n    mapping(uint8 => uint16[10]) public buildingCarTypes;\r\n\r\n    function addBuildingPrices(uint256[7] memory price) public onlyManager {\r\n        buildingPrices = price;\r\n    }\r\n\r\n    function setResourcesRequirements(\r\n        uint8[] memory typeIds, uint8[] memory levels, uint8[] memory resTypeIds, uint256[] memory resAmounts\r\n    ) public onlyManager {\r\n        uint8 lastTypeId = 0;\r\n        for (uint256 i = 0; i < typeIds.length; i ++) {\r\n            if (lastTypeId != typeIds[i]) {\r\n                delete buildingResourcesRequirements[typeIds[i]][levels[i]];\r\n                lastTypeId = typeIds[i];\r\n            }\r\n\r\n            buildingResourcesRequirements[typeIds[i]][levels[i]].push(\r\n                Requirements(\r\n                    uint8(resTypeIds[i]),\r\n                    resAmounts[i]\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function getResourcesRequirements(uint8 typeId, uint8 level)\r\n    public view returns (uint8[] memory reqTypes, uint256[] memory reqAmounts) {\r\n        if (buildingResourcesRequirements[typeId][level].length > 0) {\r\n            reqTypes = new uint8[](buildingResourcesRequirements[typeId][level].length);\r\n            reqAmounts = new uint256[](buildingResourcesRequirements[typeId][level].length);\r\n            for (uint i = 0; i < buildingResourcesRequirements[typeId][level].length; i++) {\r\n                reqTypes[i] = buildingResourcesRequirements[typeId][level][i].resourceId;\r\n                reqAmounts[i] = buildingResourcesRequirements[typeId][level][i].amount;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getResourcesRequirementsSum(uint8 typeId, uint8 maxLevel)\r\n    public view returns (uint[10] memory resources) {\r\n        for (uint8 _level = 1; _level <= maxLevel; _level++) {\r\n            if (buildingResourcesRequirements[typeId][_level].length > 0) {\r\n                for (uint i = 0; i < buildingResourcesRequirements[typeId][_level].length; i++) {\r\n                    resources[buildingResourcesRequirements[typeId][_level][i].resourceId] += buildingResourcesRequirements[typeId][_level][i].amount;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function addBuildings(uint8[] memory buildingIds, uint8[] memory typeIds) public onlyManager {\r\n        for (uint256 i = 0; i < buildingIds.length; i++) {\r\n            buildingTypes[buildingIds[i]] = typeIds[i];\r\n        }\r\n    }\r\n\r\n    function setBuildingLimit(\r\n        uint8 typeId, uint8[8] memory maxCitizens, uint8[8] memory minCitizens,\r\n        uint8[8] memory maxCars, uint8[8] memory maxAppliances, uint8[8] memory maxHelicopters\r\n    ) public onlyManager {\r\n        for (uint8 level = 1; level < 8; level++) {\r\n            buildingLimits[typeId][level] = BuildingLimits(\r\n                maxCitizens[level],\r\n                minCitizens[level],\r\n                maxCars[level],\r\n                maxAppliances[level],\r\n                maxHelicopters[level]\r\n            );\r\n        }\r\n    }\r\n\r\n    function setResourcesProduction(\r\n        uint8 resourceId, uint8 level,\r\n        uint256[] memory requirements\r\n    ) public onlyManager {\r\n        delete resourcesProductionRequirements[resourceId][level];\r\n        for (uint256 i = 0; i < requirements.length; i += 2) {\r\n            resourcesProductionRequirements[resourceId][level].push(\r\n                Requirements(\r\n                    uint8(requirements[i]),\r\n                    requirements[i + 1]\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function setAppliancesProduction(\r\n        uint8 level, uint256[] memory requirements\r\n    ) public onlyManager {\r\n        delete appliancesProductionRequirements[level];\r\n        for (uint256 i = 0; i < requirements.length; i += 2) {\r\n            appliancesProductionRequirements[level].push(\r\n                Requirements(\r\n                    uint8(requirements[i]),\r\n                    requirements[i + 1]\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function setCitizensProduction(\r\n        uint8[] memory levels, uint8[] memory resTypeIds, uint256[] memory resAmounts\r\n    ) public onlyManager {\r\n        for (uint256 i = 1; i < levels.length; i ++) {\r\n            delete citizensProductionRequirements[levels[i]];\r\n\r\n            citizensProductionRequirements[levels[i]].push(\r\n                Requirements(\r\n                    uint8(resTypeIds[i]),\r\n                    uint256(resAmounts[i])\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function setOfficeCollectRequirements(uint8[] memory resTypeIds, uint256[] memory resAmounts\r\n    ) public onlyManager {\r\n        delete officeCollectRequirements;\r\n        for (uint256 i = 0; i < resTypeIds.length; i ++) {\r\n            officeCollectRequirements.push(\r\n                Requirements(\r\n                    uint8(resTypeIds[i]),\r\n                    uint256(resAmounts[i])\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function setMunicipalCollectRequirements(uint8[] memory resTypeIds, uint256[] memory resAmounts\r\n    ) public onlyManager {\r\n        delete municipalCollectRequirements;\r\n        for (uint256 i = 0; i < resTypeIds.length; i ++) {\r\n            municipalCollectRequirements.push(\r\n                Requirements(\r\n                    uint8(resTypeIds[i]),\r\n                    uint256(resAmounts[i])\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    function setResourcesFees(\r\n        uint8[] memory resourceIds, uint256[] memory fedFees\r\n    ) public onlyManager {\r\n        for (uint i = 0; i < resourceIds.length; i++) {\r\n            resourcesFees[resourceIds[i]] = fedFees[i];\r\n        }\r\n\r\n    }\r\n\r\n    function setAppliancesFee(\r\n        uint256 fee\r\n    ) public onlyManager {\r\n        appliancesFee = fee;\r\n    }\r\n\r\n    function getResourcesProductionRequirements(\r\n        uint8 resourceId, uint8 level\r\n    )\r\n    public view returns (\r\n        uint8[] memory reqTypes,\r\n        uint256[] memory reqAmounts\r\n    ) {\r\n        reqTypes = new uint8[](resourcesProductionRequirements[resourceId][level].length);\r\n        reqAmounts = new uint[](resourcesProductionRequirements[resourceId][level].length);\r\n\r\n        for (uint256 i = 0; i < resourcesProductionRequirements[resourceId][level].length; i++) {\r\n            reqTypes[i] = resourcesProductionRequirements[resourceId][level][i].resourceId;\r\n            reqAmounts[i] = resourcesProductionRequirements[resourceId][level][i].amount;\r\n        }\r\n    }\r\n\r\n    function getAppliancesProductionInfo(\r\n        uint8 level\r\n    )\r\n    public view returns (\r\n        uint8[] memory reqTypes,\r\n        uint256[] memory reqAmounts\r\n    ) {\r\n        reqTypes = new uint8[](appliancesProductionRequirements[level].length);\r\n        reqAmounts = new uint[](appliancesProductionRequirements[level].length);\r\n\r\n        for (uint256 i = 0; i < appliancesProductionRequirements[level].length; i++) {\r\n            reqTypes[i] = appliancesProductionRequirements[level][i].resourceId;\r\n            reqAmounts[i] = appliancesProductionRequirements[level][i].amount;\r\n        }\r\n    }\r\n\r\n    function getCitizensProductionInfo(\r\n        uint8 level\r\n    )\r\n    public view returns (\r\n        uint8[] memory reqTypes,\r\n        uint256[] memory reqAmounts\r\n    ) {\r\n        reqTypes = new uint8[](citizensProductionRequirements[level].length);\r\n        reqAmounts = new uint[](citizensProductionRequirements[level].length);\r\n\r\n        for (uint256 i = 0; i < citizensProductionRequirements[level].length; i++) {\r\n            reqTypes[i] = citizensProductionRequirements[level][i].resourceId;\r\n            reqAmounts[i] = citizensProductionRequirements[level][i].amount;\r\n        }\r\n    }\r\n\r\n    function setStaminaRestoreFee(\r\n        uint256 price, uint256 fee\r\n    ) public onlyManager {\r\n        staminaRestoreFee = fee;\r\n        staminaRestorePrice = price;\r\n    }\r\n\r\n    function getStaminaRestorePrices() public view returns (uint256 fee, uint256 pricePerPoint) {\r\n        fee = staminaRestoreFee;\r\n        pricePerPoint = staminaRestorePrice;\r\n    }\r\n\r\n    function setResidentialFees(\r\n        uint256[8] memory fees\r\n    ) public onlyManager {\r\n        residentialFees = fees;\r\n    }\r\n\r\n    function setBuildingCarTypes(\r\n        uint8[] memory buildingIds, uint16[5][] memory carTypes\r\n    ) public onlyManager {\r\n        for (uint i = 0; i < buildingIds.length; i++) {\r\n            buildingCarTypes[buildingIds[i]] = carTypes[i];\r\n        }\r\n\r\n    }\r\n\r\n    function isAuthorizedCar(uint8 buildingId, uint16 carType) public view returns (bool) {\r\n        for (uint i = 0; i < buildingCarTypes[buildingId].length; i++) {\r\n            if(buildingCarTypes[buildingId][i] == carType) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n\r\n    function getResidentialInfo(uint8 _buildingLevel) public view returns (uint8[2] memory info) {\r\n        info[0] = residentialPercents[_buildingLevel][0];\r\n        info[1] = residentialPercents[_buildingLevel][1];\r\n    }\r\n\r\n    function getBuildingTypeId(uint8 _buildingId) public view returns (uint8) {\r\n        return buildingTypes[_buildingId];\r\n    }\r\n\r\n    function getOfficeCollectResources(uint256 _factor)\r\n    public view returns (\r\n        uint8[] memory reqTypes,\r\n        uint256[] memory reqAmounts\r\n    ) {\r\n        reqTypes = new uint8[](officeCollectRequirements.length);\r\n        reqAmounts = new uint[](officeCollectRequirements.length);\r\n\r\n        for (uint256 i = 0; i < officeCollectRequirements.length; i++) {\r\n            reqTypes[i] = officeCollectRequirements[i].resourceId;\r\n            reqAmounts[i] = officeCollectRequirements[i].amount * _factor;\r\n        }\r\n    }\r\n\r\n    function getMunicipalCollectResources(uint256 _factor)\r\n    public view returns (\r\n        uint8[] memory reqTypes,\r\n        uint256[] memory reqAmounts\r\n    ) {\r\n        reqTypes = new uint8[](municipalCollectRequirements.length);\r\n        reqAmounts = new uint[](municipalCollectRequirements.length);\r\n\r\n        for (uint256 i = 0; i < municipalCollectRequirements.length; i++) {\r\n            reqTypes[i] = municipalCollectRequirements[i].resourceId;\r\n            reqAmounts[i] = municipalCollectRequirements[i].amount * _factor;\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract BnbBank is Manageable {\r\n\r\n    function transferToAddress(address payable _to, uint256 _value) external onlyManager {\r\n        require(_value <= address(this).balance);\r\n\r\n        if(!_to.send(_value)) {\r\n            emit FailedPayout(_to, _value);\r\n        }\r\n    }\r\n\r\n    function() external payable {\r\n\r\n    }\r\n}\r\n\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\ncontract MBe is IERC20, Manageable {\r\n\r\n}\r\n\r\ncontract MegaBank is Manageable {\r\n    MBe public mbe;\r\n    constructor(\r\n        address payable _mbe\r\n\r\n    ) public {\r\n        mbe = MBe(_mbe);\r\n    }\r\n\r\n    function setMBeContract(address payable _mbe) public onlyManager {\r\n        mbe = MBe(_mbe);\r\n    }\r\n\r\n    function transferFromAddress(address _sender, uint _amount) external onlyManager {\r\n        require(_amount > 0);\r\n        require(mbe.transferFrom(_sender, address(this), _amount));\r\n    }\r\n\r\n    function transferToAddress(address payable _to, uint256 _value) external onlyManager {\r\n        require(_value <= mbe.balanceOf(address(this)));\r\n\r\n        require(mbe.transfer(_to, _value));\r\n    }\r\n\r\n    function emergencyWithdrawERC20(uint _amount) public onlyOwner {\r\n        require(mbe.transfer(owner, _amount));\r\n    }\r\n\r\n    function() external payable {\r\n\r\n    }\r\n}\r\n\r\ncontract UserBalance is Manageable {\r\n\r\n    BnbBank bnbBankContract;\r\n\r\n    mapping (address => uint256) public userBalance;\r\n\r\n    constructor(address payable _bnbBank) public {\r\n        bnbBankContract = BnbBank(_bnbBank);\r\n    }\r\n\r\n    function setBnbBank(address payable _bnbBank) public onlyManager {\r\n        bnbBankContract = BnbBank(_bnbBank);\r\n    }\r\n\r\n    function addBalance(address user, uint256 value, uint8 transactionType, uint8 _incomeType) external onlyManager returns (uint256) {\r\n        return _addBalance(user, value, transactionType, _incomeType);\r\n    }\r\n\r\n    function decBalance(address user, uint256 value, uint8 transactionType) public onlyManager returns (uint256) {\r\n        return _decBalance(user, value, transactionType);\r\n    }\r\n\r\n    function _decBalance(address _user, uint _value, uint8 _transactionType) internal returns (uint){\r\n        require(userBalance[_user] >= _value, \"Insufficient balance\");\r\n        userBalance[_user] -= _value;\r\n\r\n        emit DecBalance(_user, _value, _transactionType);\r\n        return userBalance[_user];\r\n    }\r\n\r\n    function _addBalance(address _user, uint _value, uint8 _transactionType, uint8 _incomeType) internal returns (uint){\r\n        userBalance[_user] += _value;\r\n        emit AddBalance(_user, _value, _transactionType, _incomeType);\r\n        return userBalance[_user];\r\n    }\r\n\r\n\r\n    function getBalance(address user) public view returns (uint256) {\r\n        return userBalance[user];\r\n    }\r\n\r\n    function userWithdrawal() public {\r\n        require(false);\r\n    }\r\n\r\n    function store() external payable {\r\n        address(bnbBankContract).transfer(msg.value);\r\n    }\r\n\r\n    function beneficiaryTransfer(uint _value) public onlyManager {\r\n        if(_value > 0) {\r\n            bnbBankContract.transferToAddress(beneficiary, _value);\r\n            emit BeneficiaryPayout(_value);\r\n        }\r\n    }\r\n\r\n    event UserWithdrawalDone(address user, uint256 value);\r\n\r\n    event AddBalance(address user, uint256 value, uint8 transactionType, uint8 _incomeType);\r\n    event DecBalance(address user, uint256 value, uint8 transactionType);\r\n\r\n    function () external payable {\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract Banks is Manageable {\r\n\r\n    uint public DEFAULT_REGION_DISTRIBUTION_PERIOD = 60;\r\n    uint public DEFAULT_GLOBAL_DISTRIBUTION_PERIOD = 365;\r\n    uint public PERIOD = 1 days; //86400;\r\n    uint public INITIAL_PERIOD = now / PERIOD;\r\n\r\n    mapping(uint => uint8) public regionDistributionPeriod;\r\n    uint public globalDistributionPeriod;\r\n\r\n    constructor() public  {\r\n\r\n    }\r\n\r\n    function addToRegionBank(uint _value, uint _region, uint8 _incomeType) public onlyManager {\r\n        emit RegionIncome(_region, _value, _period(), _incomeType);\r\n    }\r\n\r\n    function addToGlobalBank(uint _value, uint8 _incomeType) public onlyManager {\r\n        emit GlobalIncome(_value, _period(), _incomeType);\r\n    }\r\n\r\n    function setRegionDistribution(uint8 _distribution, uint _region) public onlyManager {\r\n        require(_distribution >= 30 && _distribution <= 90);\r\n        regionDistributionPeriod[_region] = _distribution;\r\n        emit RegionDistributionPeriod(_region, _distribution);\r\n    }\r\n\r\n    function setGlobalDistribution(uint _distribution) public onlyManager {\r\n        require(_distribution >= 90 && _distribution <= 365);\r\n        globalDistributionPeriod = _distribution;\r\n        emit GlobalDistributionPeriod(_distribution);\r\n    }\r\n\r\n\r\n    function _period() internal view returns (uint) {\r\n        return now / PERIOD;\r\n    }\r\n\r\n    function currentPeriod() public view returns (uint) {\r\n        return _period();\r\n    }\r\n\r\n    function getRegionDistributionPeriod(uint[] memory _regions) public view returns (uint[] memory _regional) {\r\n        _regional = new uint[](_regions.length);\r\n\r\n        for (uint i = 0; i < _regions.length; i++) {\r\n            _regional[i] = regionDistributionPeriod[_regions[i]] > 0 ? regionDistributionPeriod[_regions[i]] : DEFAULT_REGION_DISTRIBUTION_PERIOD;\r\n        }\r\n    }\r\n\r\n    function getGlobalDistributionPeriod() public view returns (uint _global) {\r\n        return globalDistributionPeriod > 0 ? globalDistributionPeriod : DEFAULT_GLOBAL_DISTRIBUTION_PERIOD;\r\n    }\r\n\r\n    event GlobalDistributionPeriod(uint _distribution);\r\n    event RegionDistributionPeriod(uint _region, uint8 _distribution);\r\n    event GlobalIncome(uint _value, uint _period, uint8 _incomeType);\r\n    event RegionIncome(uint _region, uint _value, uint _period, uint8 _incomeType);\r\n}\r\n\r\n\r\ncontract Region is Manageable, ERC721 {\r\n\r\n    Banks public BanksContract;\r\n\r\n    struct RegionStruct {\r\n        uint8 landPlotPrice;\r\n        uint8 energyTax;\r\n        uint8 productionTax;\r\n        uint8 citizensTax;\r\n        uint8 commercialTax;\r\n        uint8 distributionPeriod;\r\n        uint8 insuranceCommission;\r\n    }\r\n\r\n    uint8[2] public distributionPeriodLimit = [30, 90];\r\n    uint8[2] public insuranceCommissionLimit = [1, 15];\r\n    uint16[2] public productionMinMax = [100, 300];\r\n    uint16[2] public constructionMinMax = [100, 400];\r\n\r\n\r\n    mapping(uint256 => RegionStruct) public regions;\r\n    mapping(uint256 => uint8[5]) public constructionTaxes;\r\n    mapping(uint256 => uint256) public lastChange;\r\n    uint256 changeCooldown = 30 days;\r\n\r\n    constructor(\r\n\r\n    ) public {}\r\n\r\n    function setChangeCooldown(uint256 _changeCooldown) public onlyManager {\r\n        changeCooldown = _changeCooldown;\r\n    }\r\n\r\n    function setLastChange(uint256 _tokenId, uint256 _newCooldown) public onlyManager {\r\n        lastChange[_tokenId] = _newCooldown;\r\n    }\r\n\r\n    function setBanksContract(address payable _banks) public onlyManager {\r\n        BanksContract = Banks(_banks);\r\n    }\r\n\r\n    function setCooldown(uint256 _cooldown) public onlyManager {\r\n        changeCooldown = _cooldown;\r\n    }\r\n\r\n    function mint(address _owner, uint256 _tokenId) public onlyManager returns (uint256) {\r\n        _mint(_tokenId, _owner);\r\n        regions[_tokenId] = RegionStruct(50, 50, 50, 50, 50, 60, 5);\r\n\r\n        uint8[5] memory constructionTax;\r\n        constructionTax = [uint8(50), 50, 50, 50, 50];\r\n        constructionTaxes[_tokenId] = constructionTax;\r\n\r\n        return _tokenId;\r\n    }\r\n\r\n    function setTaxes(\r\n        uint256 _tokenId,\r\n        uint8 landPlotPrice,\r\n        uint8[5] memory constructionTax,\r\n        uint8 energyTax,\r\n        uint8 productionTax,\r\n        uint8 citizensTax,\r\n        uint8 commercialTax,\r\n        uint8 distributionPeriod,\r\n        uint8 insuranceCommission) public onlyTokenOwner(_tokenId)\r\n    {\r\n        require(lastChange[_tokenId] + changeCooldown <= now, 'st2');\r\n\r\n        require(landPlotPrice >= 0 && landPlotPrice <= 100, 'st3');\r\n        _setTaxes(_tokenId, landPlotPrice, constructionTax, energyTax, productionTax, citizensTax, commercialTax, distributionPeriod, insuranceCommission);\r\n    }\r\n\r\n    function adminSetTaxes(uint256 _tokenId,\r\n        uint8 landPlotPrice,\r\n        uint8[5] memory constructionTax,\r\n        uint8 energyTax,\r\n        uint8 productionTax,\r\n        uint8 citizensTax,\r\n        uint8 commercialTax,\r\n        uint8 distributionPeriod,\r\n        uint8 insuranceCommission) public onlyManager\r\n    {\r\n        _setTaxes(_tokenId, landPlotPrice, constructionTax, energyTax, productionTax, citizensTax, commercialTax, distributionPeriod, insuranceCommission);\r\n    }\r\n\r\n\r\n    function _setTaxes(\r\n        uint256 _tokenId,\r\n        uint8 landPlotPrice,\r\n        uint8[5] memory constructionTax,\r\n        uint8 energyTax,\r\n        uint8 productionTax,\r\n        uint8 citizensTax,\r\n        uint8 commercialTax,\r\n        uint8 distributionPeriod,\r\n        uint8 insuranceCommission) internal\r\n    {\r\n        uint16 constructionSum = 0;\r\n        for (uint i = 0; i < 5; i++) {\r\n            require(constructionTax[i] >= 0 && constructionTax[i] <= 100, 'st4');\r\n            constructionSum += constructionTax[i];\r\n        }\r\n        require(energyTax >= 0 && energyTax <= 100, 'st5');\r\n        require(productionTax >= 0 && productionTax <= 100, 'st6');\r\n        require(citizensTax >= 0 && citizensTax <= 100, 'st7');\r\n        require(commercialTax >= 0 && commercialTax <= 100, 'st8');\r\n        require(distributionPeriod >= distributionPeriodLimit[0] && distributionPeriod <= distributionPeriodLimit[1], 'st9');\r\n        require(insuranceCommission >= insuranceCommissionLimit[0] && insuranceCommission <= insuranceCommissionLimit[1], 'st10');\r\n\r\n        uint16 productionSum = uint16(energyTax) + uint16(productionTax) + uint16(citizensTax) + uint16(commercialTax);\r\n\r\n        require(constructionSum >= constructionMinMax[0] && constructionSum <= constructionMinMax[1], 'st11');\r\n        require(productionSum >= productionMinMax[0] && productionSum <= productionMinMax[1], 'st12');\r\n\r\n        regions[_tokenId].landPlotPrice = landPlotPrice;\r\n        regions[_tokenId].energyTax = energyTax;\r\n        regions[_tokenId].productionTax = productionTax;\r\n        regions[_tokenId].citizensTax = citizensTax;\r\n        regions[_tokenId].commercialTax = commercialTax;\r\n        regions[_tokenId].distributionPeriod = distributionPeriod;\r\n        regions[_tokenId].insuranceCommission = insuranceCommission;\r\n\r\n        constructionTaxes[_tokenId] = constructionTax;\r\n\r\n        BanksContract.setRegionDistribution(distributionPeriod, _tokenId);\r\n\r\n        lastChange[_tokenId] = now;\r\n\r\n        emit RegionTaxesChanged(_tokenId);\r\n    }\r\n\r\n    function getConstructionTaxesByType(uint256 _tokenId, uint8 _typeId) public view returns (uint8) {\r\n        if (_typeId == 1) {\r\n            return constructionTaxes[_tokenId][2];\r\n        }\r\n\r\n        if (_typeId == 7 || _typeId == 5) {\r\n            return constructionTaxes[_tokenId][1];\r\n        }\r\n\r\n        if (_typeId == 4 || _typeId == 6) {\r\n            return constructionTaxes[_tokenId][3];\r\n        }\r\n\r\n        if (_typeId == 3) {\r\n            return constructionTaxes[_tokenId][0];\r\n        }\r\n\r\n        if (_typeId == 8) {\r\n            return constructionTaxes[_tokenId][4];\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    function getConstructionTaxes(uint256 _tokenId) public view returns (uint8[5] memory) {\r\n        return constructionTaxes[_tokenId];\r\n    }\r\n\r\n    function getInsuranceCommission(uint256 _tokenId) public view returns (uint8) {\r\n        return regions[_tokenId].insuranceCommission;\r\n    }\r\n\r\n    function getAllTaxes(uint256 _tokenId) public view returns (uint8[7] memory) {\r\n        return [\r\n        regions[_tokenId].landPlotPrice, regions[_tokenId].energyTax, regions[_tokenId].productionTax,\r\n        regions[_tokenId].citizensTax, regions[_tokenId].commercialTax, regions[_tokenId].distributionPeriod,\r\n        regions[_tokenId].insuranceCommission\r\n        ];\r\n    }\r\n\r\n    event RegionTaxesChanged(uint256 _tokenId);\r\n}\r\n\r\ncontract BuildingImprovements is Manageable {\r\n\r\n    mapping(uint256 => uint8) public appliancesCount;\r\n    mapping(uint256 => uint8) public appliancesInfluence;\r\n    mapping(uint256 => uint256) public buildingVersion;\r\n\r\n    function setCitizens(uint256 _tokenId) external onlyManager returns (uint256) {\r\n        return increaseVersion(_tokenId);\r\n    }\r\n\r\n    function removeCitizens(uint256 _tokenId) external onlyManager returns (uint256) {\r\n        return increaseVersion(_tokenId);\r\n    }\r\n\r\n    function setCar(uint256 _tokenId) external onlyManager returns (uint256) {\r\n        return increaseVersion(_tokenId);\r\n    }\r\n\r\n    function removeCar(uint256 _tokenId) external onlyManager returns (uint256) {\r\n        return increaseVersion(_tokenId);\r\n    }\r\n\r\n    function setAppliances(uint256 _tokenId, uint8 _power) external onlyManager {\r\n        require(appliancesCount[_tokenId] < 3, \"Appliances limit\");\r\n        appliancesCount[_tokenId]++;\r\n        appliancesInfluence[_tokenId] += _power;\r\n    }\r\n\r\n    function removeAppliances(uint256 _tokenId) external onlyManager {\r\n        appliancesCount[_tokenId] = 0;\r\n        appliancesInfluence[_tokenId] = 0;\r\n    }\r\n\r\n    function getApplianceInfluence(uint256 _tokenId) public view returns (uint8) {\r\n        return appliancesInfluence[_tokenId];\r\n    }\r\n\r\n\r\n    function clearBuilding(uint256 _tokenId) external onlyManager {\r\n        increaseVersion(_tokenId);\r\n    }\r\n\r\n    function increaseVersion(uint256 _tokenId) public onlyManager returns (uint256) {\r\n        buildingVersion[_tokenId]++;\r\n        return buildingVersion[_tokenId];\r\n    }\r\n\r\n    function getVersion(uint256 _tokenId) public view returns (uint256) {\r\n        return buildingVersion[_tokenId];\r\n    }\r\n}\r\n\r\ncontract Car is Manageable, ERC721 {\r\n\r\n\r\n    mapping(uint256 => uint16) public carType;\r\n\r\n    constructor() public   {\r\n\r\n    }\r\n\r\n    function mint(address _owner, uint16 _carId) public onlyManager returns (uint256){\r\n        carType[totalSupply] = _carId;\r\n        _mint(totalSupply, _owner);\r\n        return totalSupply - 1;\r\n    }\r\n}\r\n\r\ncontract Citizen is Manageable, ERC721 {\r\n\r\n    struct Token {\r\n        uint8[7] special;\r\n        uint8 generation;\r\n        bytes32 look;\r\n    }\r\n\r\n    Token[] public tokens;\r\n\r\n    constructor() public {\r\n    }\r\n\r\n    function mint(address _owner, uint8[7] memory _special, uint8 _generation, bytes32 _look) public onlyManager returns (uint256){\r\n        tokens.push(Token(_special, _generation, _look));\r\n        _mint(tokens.length - 1, _owner);\r\n        return tokens.length - 1;\r\n    }\r\n\r\n    function incSpecial(uint256 _tokenId, uint8 _specId) public onlyManager {\r\n        require(_specId < 8 && tokens[_tokenId].special[_specId] < 12);\r\n\r\n        emit SpecChanged(_tokenId, _specId, tokens[_tokenId].special[_specId]);\r\n    }\r\n\r\n    function decSpecial(uint256 _tokenId, uint8 _specId) public onlyManager {\r\n        require(_specId < 8 && tokens[_tokenId].special[_specId] > 0);\r\n\r\n        tokens[_tokenId].special[_specId]--;\r\n        emit SpecChanged(_tokenId, _specId, tokens[_tokenId].special[_specId]);\r\n    }\r\n\r\n    function getSpecial(uint256 _tokenId) public view returns (uint8[7] memory) {\r\n        return tokens[_tokenId].special;\r\n    }\r\n\r\n    function setLook(uint256 _tokenId, bytes32 _look) public onlyManager {\r\n        tokens[_tokenId].look = _look;\r\n    }\r\n\r\n    function setLookBytes(uint256 _tokenId, byte[] memory value, uint8[] memory position) public onlyManager {\r\n        for(uint256 i = 0; i < value.length; i++) {\r\n            tokens[_tokenId].look = _setByte(tokens[_tokenId].look, position[i], value[i]);\r\n        }\r\n\r\n        emit LookChanged(_tokenId, tokens[_tokenId].look);\r\n    }\r\n\r\n    function setLookByte(uint256 _tokenId, byte value, uint8 position) public onlyManager {\r\n        tokens[_tokenId].look = _setByte(tokens[_tokenId].look, position, value);\r\n        emit LookChanged(_tokenId, tokens[_tokenId].look);\r\n    }\r\n\r\n    function _setByte(bytes32 _bt, uint8 position, byte value) internal pure returns (bytes32) {\r\n        uint256 _c = uint256(_bt);\r\n\r\n        return bytes32((_c & ~(0xFF * (uint256(2) ** position))) | (uint8(value) * (uint256(2) ** position)));\r\n    }\r\n\r\n    event LookChanged(uint256 _tokenId, bytes32 _look);\r\n    event SpecChanged(uint256 _tokenId, uint8 _specId, uint8 _value);\r\n}\r\n\r\ncontract Appliance is Manageable, ERC721 {\r\n\r\n    struct Token {\r\n        uint8 applianceType;\r\n        uint16 status;\r\n    }\r\n\r\n    Token[] public tokens;\r\n\r\n    constructor() public {\r\n    }\r\n\r\n    function mintWithStatus(address _owner, uint8 _applianceType, uint16 _status) public onlyManager returns (uint256) {\r\n        tokens.push(Token(_applianceType, _status));\r\n        _mint(tokens.length - 1, _owner);\r\n        return tokens.length - 1;\r\n    }\r\n\r\n    function setApplianceStatus(uint256 _tokenId, uint16 _newStatus) public onlyManager {\r\n        tokens[_tokenId].status = _newStatus;\r\n    }\r\n\r\n    function mint(address _owner, uint8 _applianceType) public onlyManager returns (uint256){\r\n        tokens.push(Token(_applianceType, 1000));\r\n        _mint(tokens.length - 1, _owner);\r\n        return tokens.length - 1;\r\n    }\r\n}\r\n\r\ncontract ResourcesToken is Manageable, ERC721 {\r\n\r\n    struct ResourceBatch {\r\n        uint8 kind;\r\n        uint256 amount;\r\n        bool presale;\r\n    }\r\n\r\n    ResourceBatch[] public tokens;\r\n\r\n    uint256[3] public presaleAmount;\r\n\r\n    function mintPresalePack(address _owner, uint8 _kind, uint8 _size) public onlyManager {\r\n        tokens.push(ResourceBatch(_kind, _size, true));\r\n        _mint(tokens.length - 1, _owner);\r\n    }\r\n\r\n    function mintPack(address _owner, uint8 _kind, uint256 _amount) public onlyManager {\r\n        tokens.push(ResourceBatch(_kind, _amount, false));\r\n        _mint(tokens.length - 1, _owner);\r\n    }\r\n\r\n}\r\n\r\ncontract Resources is Manageable {\r\n\r\n    ResourcesToken public resourceContract;\r\n\r\n    mapping(uint8 => uint[3]) public presalePackAmount;\r\n\r\n    mapping(address => mapping(uint8 => uint256)) public resources;\r\n\r\n    constructor(address payable _resourceToken) public{\r\n        resourceContract = ResourcesToken(_resourceToken);\r\n\r\n    }\r\n\r\n    function addResources(address _user, uint8 _kind, uint256 _resources) public onlyManager {\r\n        _addResources(_user, _kind, _resources);\r\n    }\r\n\r\n    function setPresalePackAmount(uint8 _kind, uint[3] memory _sizes) public onlyManager {\r\n        presalePackAmount[_kind] = _sizes;\r\n    }\r\n\r\n    function _addResources(address _user, uint8 _kind, uint256 _resources) internal {\r\n        resources[_user][_kind] += _resources;\r\n        emit AddResources(_user, _kind, _resources);\r\n    }\r\n    function decResources(address _user, uint8[] memory _kinds, uint256[] memory _resources) public onlyManager {\r\n        _decResourcesBatch(_user, _kinds, _resources);\r\n    }\r\n\r\n    function _decResourcesBatch(address _user, uint8[] memory _kinds, uint256[] memory _resources) internal {\r\n        for (uint i = 0; i < _kinds.length; i++) {\r\n            require(resources[_user][_kinds[i]] >= _resources[i]);\r\n        }\r\n\r\n        for (uint i = 0; i < _kinds.length; i++) {\r\n            resources[_user][_kinds[i]] -= _resources[i];\r\n        }\r\n    }\r\n\r\n    function _decResources(address _user, uint8 _kind, uint _amount) internal {\r\n        require(resources[_user][_kind] >= _amount);\r\n        resources[_user][_kind] -= _amount;\r\n        emit DecResources(_user, _kind, _amount);\r\n    }\r\n\r\n    function getResources(address _user, uint8[] memory _kinds) public view returns (uint[] memory userResources) {\r\n        userResources = new uint[](_kinds.length);\r\n        for (uint i = 0; i < _kinds.length; i++) {\r\n            userResources[i] = resources[_user][_kinds[i]];\r\n        }\r\n    }\r\n\r\n    function packResources(uint8 _kind, uint256 _amount) public {\r\n        require(resources[msg.sender][_kind] >= _amount);\r\n        _decResources(msg.sender, _kind, _amount);\r\n\r\n        resourceContract.mintPack(msg.sender, _kind, _amount);\r\n\r\n        emit PackResources(msg.sender, resourceContract.totalSupply() - 1, _kind, _amount);\r\n    }\r\n\r\n    function unpackResources(uint256 _tokenId) public {\r\n        require(!resourceContract.locks(_tokenId));\r\n        require(resourceContract.ownerOf(_tokenId) == msg.sender);\r\n        (uint8 _kind, uint _amount, bool _presale) = resourceContract.tokens(_tokenId);\r\n\r\n        resourceContract.burn(_tokenId);\r\n\r\n\r\n        if(_presale) {\r\n            _amount = presalePackAmount[_kind][_amount - 1];\r\n        }\r\n\r\n        _addResources(msg.sender, _kind, _amount);\r\n\r\n        emit UnpackResources(msg.sender, _tokenId, _kind, _amount);\r\n    }\r\n\r\n    event DecResources(address _user, uint8 _resourceId, uint _value);\r\n    event AddResources(address _user, uint8 _resourceId, uint _value);\r\n    event PackResources(address _user, uint256 _tokenId, uint8 _resourceId, uint _value);\r\n    event UnpackResources(address _user, uint256 _tokenId, uint8 _resourceId, uint _value);\r\n}\r\n\r\ncontract Random is Manageable {\r\n\r\n    uint256 public _usedSeeds = 0;\r\n\r\n    constructor() public {\r\n    }\r\n\r\n    function mintInternalSeeds(uint256[] memory _iS) public onlyManager {\r\n    }\r\n\r\n    function addSeedBytes(bytes memory _sB) public onlyManager {\r\n    }\r\n\r\n\r\n    function getRandom(uint256 _seed, uint256 max) public returns (uint256) {\r\n        return 0;\r\n    }\r\n\r\n    function getSomeSeed(uint256 _seed) public view returns (uint256) {\r\n        return 0;\r\n    }\r\n}\r\n\r\ncontract BuildingProduction is Manageable {\r\n\r\n    Land public LandContract;\r\n    Citizen public CitizenContract;\r\n    Car public CarContract;\r\n    Buildings public BuildingsContract;\r\n    BuildingImprovements public BuildingImprovementsContract;\r\n    Resources public ResourcesContract;\r\n    Appliance public ApplianceContract;\r\n    BuildingRentals public BuildingRentalsContract;\r\n    Verifier public VerifierContract;\r\n    Random private RandomContract;\r\n    Region private RegionContract;\r\n    Banks private BanksContract;\r\n    UserBalance private userBalanceContract;\r\n\r\n    uint256 MAX_RAND = 10e20;\r\n    uint FACE = 0;\r\n    uint HAIR = 1;\r\n    uint NOSE = 2;\r\n    uint EYES = 3;\r\n    uint ACCESSORIES = 4;\r\n    uint LIPS = 5;\r\n    uint BEARD = 6;\r\n    uint BROWS = 7;\r\n\r\n    uint8[8] maxLooksMale;\r\n    uint8[8] maxLooksFemale;\r\n\r\n    uint256 public basePriceCoef = 100;\r\n    uint256 public maxPriceCoefResidential = 40;\r\n    uint256 public maxPriceCoefResources = 100;\r\n    uint256 public maxPriceCoefStamina = 100;\r\n    uint256 public developerPart = 50;\r\n    uint256 public regionOwnerPart = 50;\r\n\r\n    uint8 WATER_RESOURCE_ID = 7;\r\n    uint8 ELECTRICITY_RESOURCE_ID = 8;\r\n\r\n    uint32[8] public resourcesCooldown;\r\n    uint32[8] public appliancesCooldown;\r\n    uint32[4] public residentialsCooldowns;\r\n\r\n    uint16[10][8] public speedUpCoefs;\r\n\r\n    constructor(\r\n        address payable _land,\r\n        address payable _buildings,\r\n        address payable _buildingImprovements,\r\n        address payable _buildingRentals,\r\n        address payable _verifier,\r\n        address payable _random,\r\n        address payable _region,\r\n        address payable _banks,\r\n        address payable _userBalance\r\n    ) public  {\r\n        LandContract = Land(_land);\r\n        BuildingsContract = Buildings(_buildings);\r\n        BuildingImprovementsContract = BuildingImprovements(_buildingImprovements);\r\n        BuildingRentalsContract = BuildingRentals(_buildingRentals);\r\n        VerifierContract = Verifier(_verifier);\r\n        RandomContract = Random(_random);\r\n        RegionContract = Region(_region);\r\n        BanksContract = Banks(_banks);\r\n        userBalanceContract = UserBalance(_userBalance);\r\n\r\n        maxLooksMale[FACE] = 5;\r\n        maxLooksMale[HAIR] = 63;\r\n        maxLooksMale[NOSE] = 10;\r\n        maxLooksMale[EYES] = 28;\r\n        maxLooksMale[ACCESSORIES] = 6;\r\n        maxLooksMale[LIPS] = 18;\r\n        maxLooksMale[BEARD] = 12;\r\n        maxLooksMale[BROWS] = 12;\r\n\r\n        maxLooksFemale[FACE] = 5;\r\n        maxLooksFemale[HAIR] = 56;\r\n        maxLooksFemale[NOSE] = 10;\r\n        maxLooksFemale[EYES] = 31;\r\n        maxLooksFemale[ACCESSORIES] = 7;\r\n        maxLooksFemale[LIPS] = 13;\r\n        maxLooksFemale[BEARD] = 0;\r\n        maxLooksFemale[BROWS] = 12;\r\n    }\r\n\r\n    modifier checkOwner(uint256 _tokenId) {\r\n        require(msg.sender == BuildingRentalsContract.getRenterOrOwner(_tokenId), \"Not owned\");\r\n        _;\r\n    }\r\n\r\n    function setBasePriceCoef(uint256 _basePriceCoef) public onlyManager  {\r\n        basePriceCoef = _basePriceCoef;\r\n    }\r\n\r\n    function setMaxPriceCoefResidential(uint256 _maxPriceCoefResidential) public onlyManager  {\r\n        maxPriceCoefResidential = _maxPriceCoefResidential;\r\n    }\r\n\r\n    function setmaxPriceCoefResources(uint256 _maxPriceCoefResources) public onlyManager  {\r\n        maxPriceCoefResources = _maxPriceCoefResources;\r\n    }\r\n\r\n    function setMaxPriceCoefStamina(uint256 _maxPriceCoefStamina) public onlyManager  {\r\n        maxPriceCoefStamina = _maxPriceCoefStamina;\r\n    }\r\n\r\n    function setCitizenContract(address payable _address) public onlyManager {\r\n        CitizenContract = Citizen(_address);\r\n    }\r\n\r\n    function setCarContract(address payable _address) public onlyManager {\r\n        CarContract = Car(_address);\r\n    }\r\n\r\n    function setApplianceContract(address payable _address) public onlyManager {\r\n        ApplianceContract = Appliance(_address);\r\n    }\r\n\r\n    function setResourcesContract(address payable _address) public onlyManager {\r\n        ResourcesContract = Resources(_address);\r\n    }\r\n\r\n    function setCooldown(uint32[8] memory _resourcesCooldown, uint32[8] memory _appliancesCooldown, uint32[4] memory _residentialsCooldowns) public onlyManager {\r\n        resourcesCooldown = _resourcesCooldown;\r\n        appliancesCooldown = _appliancesCooldown;\r\n        residentialsCooldowns = _residentialsCooldowns;\r\n    }\r\n\r\n    function setSpeedUpCoefs(uint16[10][8] memory _coefs) public onlyManager {\r\n        speedUpCoefs = _coefs;\r\n    }\r\n\r\n    function getResourceProductionPrice(uint256 _tokenId, uint8 _resourceId, uint _regionId, uint16 _daysLeft)\r\n    public view returns (uint256[5] memory _prices)\r\n    {\r\n        (,uint8 _energyTax,uint8 _productionTax,,,,) = RegionContract.regions(_regionId);\r\n        ( ,uint8 _buildingLevel,,,) = LandContract.getCellByToken(_tokenId);\r\n\r\n        uint coef = 1;\r\n        if(_daysLeft > 0) {\r\n            coef = speedUpCoefs[_buildingLevel][_daysLeft];\r\n        }\r\n\r\n        uint8 _tax = _resourceId == WATER_RESOURCE_ID || _resourceId == ELECTRICITY_RESOURCE_ID ? _energyTax : _productionTax;\r\n        uint256 _fee;\r\n\r\n        if (_resourceId > 0) {\r\n            _fee = BuildingsContract.resourcesFees(_resourceId);\r\n        } else {\r\n            _fee = BuildingsContract.appliancesFee();\r\n        }\r\n\r\n        _prices[1] = _fee * (basePriceCoef + (maxPriceCoefResources * uint(_tax) / 100)) / 100;\r\n        _prices[1] = _prices[1] * coef;\r\n\r\n        _prices[2] = _prices[1] * developerPart / 100;\r\n        _prices[3] = _prices[1] * regionOwnerPart / 100;\r\n\r\n        _prices[0] = _prices[1] + _prices[1] + _prices[2] + _prices[3];\r\n    }\r\n\r\n    function resourceProduction(address _address, uint256 _tokenId, uint8 _resourceId, uint32 _count, uint16 _daysLeft, uint256 _buildingVersion, bytes memory _signature) payable public checkOwner(_tokenId) {\r\n        bytes32 _hash = hash(keccak256(abi.encode(msg.sender, _tokenId, _resourceId, _count, _daysLeft, _buildingVersion)));\r\n\r\n        VerifierContract.verifySignature(_hash, _signature);\r\n        require(_address == msg.sender, \"Address error\");\r\n        require(BuildingImprovementsContract.buildingVersion(_tokenId) == _buildingVersion, \"Version error\");\r\n        _resourceProduction(_tokenId, _resourceId, _count, _daysLeft);\r\n    }\r\n\r\n    function _resourceProduction(uint256 _tokenId, uint8 _resourceId, uint32 _count, uint16 _daysLeft) internal {\r\n        uint8[2] memory _bInfo;\r\n        uint16 _regionId;\r\n\r\n        (_bInfo[1], _bInfo[0],, _regionId,) = LandContract.getCellByToken(_tokenId);\r\n        _bInfo[1] = BuildingsContract.buildingTypes(_bInfo[1]);\r\n\r\n        uint256[5] memory _prices = getResourceProductionPrice(_tokenId, _resourceId, _regionId, _daysLeft);\r\n\r\n        require(msg.value >= _prices[0], \"not enough money\");\r\n\r\n        _resourceProductionResourcesSpend(_resourceId, _bInfo[0], msg.sender);\r\n\r\n        _priceTransfer(_prices, _regionId, address(0), _bInfo[1]);\r\n\r\n        ResourcesContract.addResources(msg.sender, _resourceId, _count);\r\n\r\n        emit ResourceProduced(msg.sender, _tokenId, _resourceId, _count, now, _prices[0], BuildingImprovementsContract.increaseVersion(_tokenId), _daysLeft > 0);\r\n    }\r\n\r\n    function _resourceProductionResourcesSpend(uint8 _resourceId, uint8 _buildingLevel, address _sender) internal {\r\n        (uint8[] memory _reqTypes, uint256[] memory _reqAmounts) = BuildingsContract.getResourcesProductionRequirements(_resourceId, _buildingLevel);\r\n\r\n        if (_reqTypes.length > 0) {\r\n            uint256[] memory userResources = ResourcesContract.getResources(_sender, _reqTypes);\r\n            for (uint256 i = 0; i < _reqTypes.length; i++) {\r\n                if (_reqTypes[i] == 0) break;\r\n                require(_reqAmounts[i] <= userResources[i], \"not enough resources\");\r\n            }\r\n        }\r\n\r\n        if (_reqTypes.length > 0) {\r\n            ResourcesContract.decResources(_sender, _reqTypes, _reqAmounts);\r\n        }\r\n    }\r\n\r\n    function getApplianceProductionPrice(uint _tokenId, uint _regionId, uint16 _daysLeft)\r\n    public view returns (uint256[5] memory)\r\n    {\r\n        return getResourceProductionPrice(_tokenId, 0, _regionId, _daysLeft);\r\n    }\r\n\r\n    function applianceProduction(address _address, uint256 _tokenId, uint8 _typeId, uint16 _daysLeft, uint256 _buildingVersion, bytes memory _signature) payable public checkOwner(_tokenId) {\r\n        require(_typeId > 0);\r\n        bytes32 _hash = hash(keccak256(abi.encode(msg.sender, _tokenId, _typeId, _daysLeft, _buildingVersion)));\r\n        VerifierContract.verifySignature(_hash, _signature);\r\n        require(_address == msg.sender, \"Address error\");\r\n        require(BuildingImprovementsContract.buildingVersion(_tokenId) == _buildingVersion, \"Version error\");\r\n\r\n        _applianceProduction(_tokenId, _typeId, _daysLeft);\r\n    }\r\n\r\n    function _applianceProduction(uint256 _tokenId, uint8 _typeId, uint16 _daysLeft) internal {\r\n        //0 uint8 _buildingLevel, 1 uint8 buildingTypeId, 2 minCitizens\r\n        uint8[3] memory _bInfo;\r\n        uint16 _regionId;\r\n\r\n        (_bInfo[1], _bInfo[0], , _regionId,) = LandContract.getCellByToken(_tokenId);\r\n        _bInfo[1] = BuildingsContract.buildingTypes(_bInfo[1]);\r\n\r\n        uint256[5] memory _prices = getApplianceProductionPrice(_tokenId, _regionId, _daysLeft);\r\n        require(msg.value >= _prices[0], \"not enough money\");\r\n\r\n        _applianceProductionResourcesSpend(_bInfo[0], msg.sender);\r\n\r\n        _priceTransfer(_prices, _regionId, address(0), _bInfo[1]);\r\n\r\n        emit ApplianceProduced(msg.sender, _tokenId, ApplianceContract.mint(msg.sender, _typeId), _typeId, now, _prices[0], BuildingImprovementsContract.increaseVersion(_tokenId), _daysLeft > 0);\r\n    }\r\n\r\n    function _applianceProductionResourcesSpend(uint8 _buildingLevel, address _sender) internal {\r\n        (uint8[] memory reqTypes, uint256[] memory reqAmounts) = BuildingsContract.getAppliancesProductionInfo(_buildingLevel);\r\n\r\n        if (reqTypes.length > 0) {\r\n            uint256[] memory userResources = ResourcesContract.getResources(_sender, reqTypes);\r\n            for (uint256 i = 0; i < reqTypes.length; i++) {\r\n                if (reqTypes[i] == 0) break;\r\n                require(reqAmounts[i] <= userResources[i], \"not enough resources\");\r\n            }\r\n        }\r\n\r\n        if (reqTypes.length > 0) {\r\n            ResourcesContract.decResources(_sender, reqTypes, reqAmounts);\r\n        }\r\n    }\r\n\r\n    function getCitizensProductionPrice(uint _regionId, uint8 _buildingLevel)\r\n    public view returns (uint256[5] memory _prices)\r\n    {\r\n        (,,,uint8 _citizensTax,,,) = RegionContract.regions(_regionId);\r\n\r\n        uint256 _fedFee = BuildingsContract.residentialFees(_buildingLevel);\r\n        _prices[1] = _fedFee * 2 * (basePriceCoef / 2 + (maxPriceCoefResidential * _citizensTax) / 100) / 100;\r\n        _prices[2] = _prices[1] * developerPart / 100;\r\n        _prices[3] = _prices[1] * regionOwnerPart / 100;\r\n\r\n        _prices[0] = _prices[1] + _prices[1] + _prices[2] + _prices[3];\r\n    }\r\n\r\n    function citizensProduction(address _address, uint256 _tokenId, uint32 _amount, uint8[7] memory _specials,\r\n        uint8[5] memory _info,\r\n        uint256 _buildingVersion, bytes memory _signature\r\n    ) payable public checkOwner(_tokenId) {\r\n        bytes32 _hash = hash(keccak256(abi.encode(msg.sender, _tokenId, _amount, _specials, _info, _buildingVersion)));\r\n        VerifierContract.verifySignature(_hash, _signature);\r\n        require(_address == msg.sender, \"Address error\");\r\n        require(BuildingImprovementsContract.buildingVersion(_tokenId) == _buildingVersion, \"Version error\");\r\n\r\n        (uint256[10] memory _newTokenIds, uint256 _fullPrice) = _citizensProduction(_tokenId, _amount, _specials, _info);\r\n        _citizenSendEvent(_tokenId, _newTokenIds, _fullPrice);\r\n    }\r\n\r\n    function _citizenSendEvent(uint256 _tokenId, uint256[10] memory _newTokenIds, uint256 _fullPrice) internal {\r\n        emit CitizensProduced(msg.sender, _tokenId, _newTokenIds, now, _fullPrice, BuildingImprovementsContract.increaseVersion(_tokenId));\r\n    }\r\n\r\n    function _citizensProduction(uint256 _tokenId, uint32 _amount, uint8[7] memory _specials, uint8[5] memory _info) internal returns (uint256[10] memory _newTokenIds, uint256 _fullPrice) {\r\n\r\n        (uint8 _buildingId, uint8 _buildingLevel, ,uint16 _regionId,) = LandContract.getCellByToken(_tokenId);\r\n        uint8 _buildingTypeId = BuildingsContract.buildingTypes(_buildingId);\r\n\r\n        uint256[5] memory _prices = getCitizensProductionPrice(_regionId, _buildingLevel);\r\n        require(msg.value >= _prices[0], \"not enough money\");\r\n\r\n        (uint8[] memory reqTypes, uint256[] memory reqAmounts) = BuildingsContract.getCitizensProductionInfo(_buildingLevel);\r\n\r\n        if (reqTypes.length > 0) {\r\n            uint256[] memory userResources = ResourcesContract.getResources(msg.sender, reqTypes);\r\n            for (uint256 i = 0; i < reqTypes.length; i++) {\r\n                if (reqTypes[i] == 0) break;\r\n                require(reqAmounts[i] <= userResources[i], \"not enough resources\");\r\n            }\r\n        }\r\n\r\n        if (reqTypes.length > 0) {\r\n            ResourcesContract.decResources(msg.sender, reqTypes, reqAmounts);\r\n        }\r\n\r\n        _priceTransfer(_prices, _regionId, address(0), _buildingTypeId);\r\n\r\n        _newTokenIds = _mintCitizen(_amount, _specials, _buildingLevel, _info);\r\n        _fullPrice = _prices[0];\r\n    }\r\n\r\n\r\n    function _mintCitizen(uint32 _amount, uint8[7] memory _specials, uint8, uint8[5] memory _info) internal returns (uint256[10] memory _newTokenIds) {\r\n\r\n\r\n        uint8[7] memory _newSpecials;\r\n        for (uint8 a = 0; a < _amount; a++) {\r\n            uint256 seed = RandomContract.getRandom(block.number + uint(a), MAX_RAND);\r\n            for (uint8 i = 1; i < 7; i++) {\r\n                seed = seed / 100;\r\n\r\n                uint32 tmp = uint32(_specials[i] * (_info[0] + ((seed % 100) * (_info[1] - _info[0])) / 100));\r\n\r\n                if (tmp < 1000) {\r\n                    tmp = 1000;\r\n                }\r\n\r\n                if (tmp % 1000 >= 500) {\r\n                    tmp += 1000;\r\n                }\r\n\r\n                if (tmp > 10000) {\r\n                    tmp = 10000;\r\n                }\r\n\r\n                _newSpecials[i] = uint8(tmp / 1000);\r\n            }\r\n\r\n            _newTokenIds[a] = CitizenContract.mint(msg.sender, _newSpecials, _info[2], genLook(seed, _info[3]));\r\n        }\r\n    }\r\n\r\n    function getCitizenCooldown(uint8[5] memory _info) public view returns (uint32) {\r\n        return residentialsCooldowns[0] + (\r\n        (residentialsCooldowns[1] - _info[4]) * residentialsCooldowns[2]\r\n        * ((residentialsCooldowns[1] - _info[4]) * 10) / residentialsCooldowns[3]\r\n        ) * 6;\r\n    }\r\n\r\n    function getStaminaRestorePrices(uint256 _points, uint256 _regionId, uint256 _factor)\r\n    public view returns (uint256[5] memory _prices)\r\n    {\r\n        (,,,,uint8 _commercialTax,,) = RegionContract.regions(_regionId);\r\n        if(_factor < 1) {\r\n            _factor = 1;\r\n        }\r\n\r\n        (uint256 _fee, uint256 _pricePerPoint) = BuildingsContract.getStaminaRestorePrices();\r\n\r\n        _prices[1] = _factor * (_fee * (basePriceCoef + (maxPriceCoefStamina * _commercialTax / 100)) / 100);\r\n        _prices[2] = _prices[1] * developerPart / 100;\r\n        _prices[3] = _prices[1] * regionOwnerPart / 100;\r\n        _prices[4] = _factor * (_pricePerPoint * _points);\r\n\r\n        _prices[0] = _prices[1] + _prices[1] + _prices[2] + _prices[3] + _prices[4];\r\n    }\r\n\r\n    function staminaRestore(address _address, uint256 _tokenId, uint256[] memory _citizenIds, uint32 _points, uint256[] memory _landIds, uint256 _buildingVersion, bytes memory _signature) payable public {\r\n        bytes32 _hash = hash(keccak256(abi.encode(msg.sender, _tokenId, _citizenIds, _points, _landIds, _buildingVersion)));\r\n        VerifierContract.verifySignature(_hash, _signature);\r\n        require(_address == msg.sender, \"Address error\");\r\n        require(BuildingImprovementsContract.buildingVersion(_tokenId) == _buildingVersion, \"Version error\");\r\n\r\n        (,, ,uint16 _regionId,) = LandContract.getCellByToken(_tokenId);\r\n\r\n        uint256[5] memory _prices = getStaminaRestorePrices(_points, uint(_regionId), _citizenIds.length);\r\n        require(msg.value >= _prices[0], \"not enough money\");\r\n\r\n        for(uint i = 0; i < _citizenIds.length; i++) {\r\n            address _citizenOwner = CitizenContract.ownerOf(_citizenIds[i]);\r\n            require(_citizenOwner != address(0), \"null citizen address\");\r\n\r\n            emit StaminaRestored(msg.sender, _tokenId, _citizenIds[i], _points, _prices[0] / _citizenIds.length, _prices[4] / _citizenIds.length, _landIds[i], now);\r\n        }\r\n\r\n        _priceTransfer(_prices, _regionId, BuildingRentalsContract.getRenterOrOwner(_tokenId), 4);\r\n    }\r\n\r\n    function _priceTransfer(uint256[5] memory _prices, uint16 _regionId, address _landOwner, uint8 _incomeType) internal {\r\n        require(msg.value >= _prices[0], \"Not enough value\");\r\n\r\n        if (msg.value > _prices[0] && !msg.sender.send(msg.value - _prices[0])) {\r\n            emit FailedPayout(msg.sender, msg.value - _prices[0]);\r\n        }\r\n\r\n        if (_prices[3] + _prices[1] * 2 + _prices[4] > 0) {\r\n            userBalanceContract.store.value(_prices[3] + _prices[1] * 2 + _prices[4])();\r\n        }\r\n\r\n        address _owner = RegionContract.ownerOf(_regionId);\r\n        if (_owner != address(0) && _prices[3] > 0) {\r\n            userBalanceContract.addBalance(_owner, _prices[3], 0, _incomeType);\r\n            emit RegionPayout(_owner, _regionId, _prices[3], 0, _incomeType);\r\n        }\r\n\r\n        if (_prices[1] > 0) {\r\n            BanksContract.addToGlobalBank(_prices[1], _incomeType);\r\n            BanksContract.addToRegionBank(_prices[1], _regionId, _incomeType);\r\n        }\r\n\r\n        if(_prices[4] > 0 && _landOwner != address(0)) {\r\n            userBalanceContract.addBalance(_landOwner, _prices[4], 0, _incomeType);\r\n        }\r\n\r\n        beneficiaryPayout(_prices[2]);\r\n    }\r\n\r\n    function genLook(uint256 _seed, uint8 _fid) internal view returns (bytes32 look) {\r\n\r\n    }\r\n\r\n    function changeAvatar(bytes32 _look, uint256[5] memory _prices, uint _citizenId, uint _landId, bytes memory _signature) public payable {\r\n\r\n    }\r\n\r\n    function _getKeccak(uint256 _seed) internal pure returns (uint256) {\r\n        return 0;\r\n    }\r\n\r\n    function setLastAction(uint _tokenId, uint _time) external onlyManager returns (uint256) {\r\n        return 0;\r\n    }\r\n\r\n    function selectResources(uint _tokenId, uint _resourceId) public checkOwner(_tokenId) {\r\n        emit selectResourcesEvent(_tokenId, _resourceId, now);\r\n    }\r\n\r\n    function hash(bytes32 message) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(message));\r\n    }\r\n\r\n    event ResourceProduced(address _owner, uint256 _tokenId, uint8 _resourceId, uint32 _amount, uint256 _now, uint _fullPrice, uint _buildingVersion, bool _speedUp);\r\n    event ApplianceProduced(address _owner, uint256 _tokenId, uint256 _applianceId, uint8 _typeId, uint256 _now, uint _fullPrice, uint _buildingVersion, bool _speedUp);\r\n    event StaminaRestored(address _owner, uint256 _tokenId, uint256 _citizenId, uint32 _points, uint256 _price, uint256 _ownerPrice,  uint256 _landId, uint256 _now);\r\n    event CitizensProduced(address _owner, uint256 _tokenId, uint256[10] _newTokenIds, uint256 _now, uint _fullPrice, uint _buildingVersion);\r\n    event RegionPayout(address _owner, uint indexed tokenId, uint256 value, uint8 _payoutType, uint8 _incomeType);\r\n    event selectResourcesEvent(uint256 _tokenId, uint _resourceId, uint256 _now);\r\n\r\n    event CitizenLookChanged(uint _citizenId, bytes32 _look, uint _fullPrice, uint _ownerPrice, uint _landId);\r\n    event BuildingVersionChanged(uint _tokenId, uint _buildingVersion);\r\n}\r\n\r\ncontract BuildingManagement is Manageable {\r\n\r\n    Land public LandContract;\r\n    Citizen public CitizenContract;\r\n    Buildings public BuildingsContract;\r\n    BuildingImprovements public BuildingImprovementsContract;\r\n    Car public CarContract;\r\n    Appliance public ApplianceContract;\r\n    BuildingRentals public BuildingRentalsContract;\r\n    BuildingProduction public BuildingProductionContract;\r\n    Verifier public VerifierContract;\r\n\r\n    mapping(uint => uint8) public appliancePower;\r\n\r\n    constructor(\r\n        address payable _land,\r\n        address payable _buildings,\r\n        address payable _buildingImprovements,\r\n        address payable _buildingRentals,\r\n        address payable _buildingProduction,\r\n        address payable _verifier\r\n    ) public  {\r\n        LandContract = Land(_land);\r\n        BuildingsContract = Buildings(_buildings);\r\n        BuildingImprovementsContract = BuildingImprovements(_buildingImprovements);\r\n        BuildingRentalsContract = BuildingRentals(_buildingRentals);\r\n        BuildingProductionContract = BuildingProduction(_buildingProduction);\r\n        VerifierContract = Verifier(_verifier);\r\n\r\n        appliancePower[1] = 25;\r\n        appliancePower[2] = 15;\r\n        appliancePower[3] = 5;\r\n        appliancePower[4] = 10;\r\n        appliancePower[5] = 40;\r\n        appliancePower[6] = 45;\r\n        appliancePower[7] = 50;\r\n        appliancePower[8] = 30;\r\n        appliancePower[9] = 35;\r\n        appliancePower[10] = 20;\r\n    }\r\n\r\n    modifier checkOwner(uint256 _tokenId) {\r\n        require(msg.sender == BuildingRentalsContract.getRenterOrOwner(_tokenId), \"Not owned\");\r\n        _;\r\n    }\r\n\r\n    function setLandContract(address payable _address) public onlyManager {\r\n        LandContract = Land(_address);\r\n    }\r\n\r\n    function setBuildingsContract(address payable _address) public onlyManager {\r\n        BuildingsContract = Buildings(_address);\r\n    }\r\n\r\n    function setBuildingImprovementsContract(address payable _address) public onlyManager {\r\n        BuildingImprovementsContract = BuildingImprovements(_address);\r\n    }\r\n\r\n    function setBuildingRentalsContract(address payable _address) public onlyManager {\r\n        BuildingRentalsContract = BuildingRentals(_address);\r\n    }\r\n\r\n    function setBuildingProductionContract(address payable _address) public onlyManager {\r\n        BuildingProductionContract = BuildingProduction(_address);\r\n    }\r\n\r\n    function setCitizenContract(address payable _address) public onlyManager {\r\n        CitizenContract = Citizen(_address);\r\n    }\r\n\r\n    function setCarContract(address payable _address) public onlyManager {\r\n        CarContract = Car(_address);\r\n    }\r\n\r\n    function setApplianceContract(address payable _address) public onlyManager {\r\n        ApplianceContract = Appliance(_address);\r\n    }\r\n\r\n    function setCitizens(address _address, uint256 _tokenId, uint256[] memory _citizenIds, uint _version, bytes memory _signature) public checkOwner(_tokenId) {\r\n        bytes32 _hash = hash(keccak256(abi.encode(msg.sender, _tokenId, _citizenIds, _version)));\r\n\r\n        VerifierContract.verifySignature(_hash, _signature);\r\n        require(_address == msg.sender);\r\n\r\n        for (uint i = 0; i < _citizenIds.length; i++) {\r\n            require(CitizenContract.ownerOf(_citizenIds[i]) == msg.sender);\r\n        }\r\n\r\n        _version = BuildingImprovementsContract.setCitizens(_tokenId);\r\n        uint256 _lastAction = _setLastAction(_tokenId, now);\r\n\r\n        for (uint i = 0; i < _citizenIds.length; i++) {\r\n            emit BuildingImprovementsEvent(_tokenId, _citizenIds[i], 1 /* Appoint citizen*/, 0, _version, _lastAction);\r\n        }\r\n    }\r\n\r\n    function removeCitizens(address _address, uint256 _tokenId, uint256[] memory _citizenIds, uint _version, bytes memory _signature) public checkOwner(_tokenId) {\r\n        require(BuildingImprovementsContract.getVersion(_tokenId) == _version);\r\n        bytes32 _hash = hash(keccak256(abi.encode(msg.sender, _tokenId, _citizenIds, _version)));\r\n\r\n        VerifierContract.verifySignature(_hash, _signature);\r\n        require(_address == msg.sender);\r\n\r\n        for (uint i = 0; i < _citizenIds.length; i++) {\r\n            require(CitizenContract.ownerOf(_citizenIds[i]) == msg.sender);\r\n        }\r\n\r\n        _version = BuildingImprovementsContract.removeCitizens(_tokenId);\r\n        uint256 _lastAction = _setLastAction(_tokenId, now);\r\n\r\n        for (uint i = 0; i < _citizenIds.length; i++) {\r\n            emit BuildingImprovementsEvent(_tokenId, _citizenIds[i], 2 /* remove citizen*/, 0, _version, _lastAction);\r\n        }\r\n    }\r\n\r\n    function setCar(address _address, uint256 _tokenId, uint256 _carId, uint _version, bytes memory _signature) public checkOwner(_tokenId) {\r\n        require(BuildingImprovementsContract.getVersion(_tokenId) == _version);\r\n        bytes32 _hash = hash(keccak256(abi.encode(msg.sender, _tokenId, _carId, _version)));\r\n\r\n        VerifierContract.verifySignature(_hash, _signature);\r\n        require(_address == msg.sender);\r\n\r\n        //uint8 buildingId, uint8 _buildingLevel, uint8 buildingTypeId,  uint8 cellType, uint16 regionId, uint tokenId\r\n        (uint8 buildingId,,,,) = LandContract.getCellByToken(_tokenId);\r\n\r\n        require(CarContract.ownerOf(_carId) == msg.sender);\r\n\r\n        uint16 carType = CarContract.carType(_carId);\r\n\r\n        require(BuildingsContract.isAuthorizedCar(buildingId, carType), \"Car unauthorized\");\r\n\r\n        emit BuildingImprovementsEvent(_tokenId, _carId, 3 /* set car */, uint8(carType), BuildingImprovementsContract.increaseVersion(_tokenId), 0);\r\n    }\r\n\r\n    function removeCar(address _address, uint256 _tokenId, uint256 _carId, uint256 _version, bytes memory _signature) public {\r\n        require(BuildingImprovementsContract.getVersion(_tokenId) == _version);\r\n        bytes32 _hash = hash(keccak256(abi.encode(msg.sender, _tokenId, _carId, _version)));\r\n\r\n        VerifierContract.verifySignature(_hash, _signature);\r\n        require(_address == msg.sender);\r\n\r\n        require(CarContract.ownerOf(_carId) == msg.sender);\r\n        uint16 carType = CarContract.carType(_carId);\r\n\r\n        bool isHelicopter = false;\r\n        if(carType >= 100) {\r\n            isHelicopter = true;\r\n        }\r\n\r\n        emit BuildingImprovementsEvent(_tokenId, _carId, 4 /* remove car */, 0, BuildingImprovementsContract.increaseVersion(_tokenId), 0);\r\n    }\r\n\r\n    function setAppliance(uint256 _tokenId, uint256 _applianceId) public {\r\n        require(LandContract.ownerOf(_tokenId) == msg.sender, \"not owned 1\");\r\n        // Only real owner\r\n        require(!BuildingRentalsContract.isInRental(_tokenId), \"Rented\");\r\n        require(ApplianceContract.ownerOf(_applianceId) == msg.sender, \"not owned 2\");\r\n        (uint8 applianceType,) = ApplianceContract.tokens(_applianceId);\r\n        require(!ApplianceContract.locks(_applianceId));\r\n        BuildingImprovementsContract.setAppliances(_tokenId, appliancePower[applianceType]);\r\n        ApplianceContract.burn(_applianceId);\r\n\r\n        emit BuildingImprovementsEvent(_tokenId, _applianceId, 5 /* set appliance */, applianceType, BuildingImprovementsContract.increaseVersion(_tokenId), 0);\r\n    }\r\n\r\n    function getAppliancePower(uint8 _type) internal view returns (uint8) {\r\n        return appliancePower[_type];\r\n    }\r\n\r\n    function setAppliancePower(uint8 _type, uint8 _power) public onlyManager {\r\n        appliancePower[_type] = _power;\r\n    }\r\n\r\n    function setLastAction(uint _tokenId, uint _time) public onlyManager returns (uint256) {\r\n        return _setLastAction(_tokenId, _time);\r\n    }\r\n\r\n    function _setLastAction(uint _tokenId, uint _time) internal returns (uint256) {\r\n        return BuildingProductionContract.setLastAction(_tokenId, _time);\r\n    }\r\n\r\n    function clearBuilding(uint256 _tokenId) external onlyManager {\r\n        LandContract.unlockToken(_tokenId);\r\n        BuildingImprovementsContract.clearBuilding(_tokenId);\r\n        emit BuildingImprovementsEvent(_tokenId, 0, 6 /* remove all */, 0, BuildingImprovementsContract.increaseVersion(_tokenId), 0);\r\n\r\n    }\r\n\r\n    function hash(bytes32 message) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", message));\r\n    }\r\n\r\n    event BuildingImprovementsEvent(uint256 _tokenId, uint256 _subTokenId, uint8 _action, uint8 _type, uint256 _buildingVersion, uint256 _now);\r\n}\r\n\r\n\r\ncontract BuildingRentals is Manageable {\r\n    Land public LandContract;\r\n    BuildingImprovements public BuildingImprovementsContract;\r\n    UserBalance public UserBalanceContract;\r\n    BuildingManagement public BuildingManagementContract;\r\n    Buildings public BuildingsContract;\r\n    Banks public BanksContract;\r\n    Region public RegionContract;\r\n\r\n    uint256 public devFeePercent = 25; //2.5\r\n    uint256 public districtOwnerFeePercent = 25; //2.5\r\n    uint256 public regionalBankFeePercent = 25; //2.5\r\n    uint256 public globalBankFeePercent = 25; //2.5\r\n\r\n\r\n    struct RentalStruct {\r\n        uint16 minDays;\r\n        uint16 maxDays;\r\n        uint256 pricePerDay;\r\n        address renter;\r\n        uint256 endOfRental;\r\n        bool flag;\r\n    }\r\n\r\n    mapping(uint256 => RentalStruct) public rentals; // tokenId => RentalStruct\r\n\r\n    constructor(\r\n        address payable _land,\r\n        address payable _buildingImprovements,\r\n        address payable _userBalance,\r\n        address payable _banks,\r\n        address payable _region,\r\n        address payable _buildings\r\n    ) public {\r\n        LandContract = Land(_land);\r\n        BuildingImprovementsContract = BuildingImprovements(_buildingImprovements);\r\n        UserBalanceContract = UserBalance(_userBalance);\r\n        BanksContract = Banks(_banks);\r\n        RegionContract = Region(_region);\r\n        BuildingsContract = Buildings(_buildings);\r\n    }\r\n\r\n    function setPercents(uint256 _devFeePercent, uint256 _districtOwnerFeePercent, uint256 _regionalBankFeePercent, uint256 _globalBankFeePercent) public onlyManager {\r\n        devFeePercent = _devFeePercent; // percent * 10\r\n        districtOwnerFeePercent = _districtOwnerFeePercent;\r\n        regionalBankFeePercent = _regionalBankFeePercent;\r\n        globalBankFeePercent = _globalBankFeePercent;\r\n    }\r\n\r\n    function setBuildingManagement(address payable _buildingManagement) public onlyManager {\r\n        BuildingManagementContract = BuildingManagement(_buildingManagement);\r\n    }\r\n\r\n    function setBuildingContract(address payable _buildings) public onlyManager {\r\n        BuildingsContract = Buildings(_buildings);\r\n    }\r\n\r\n    function rentOut(uint256 _tokenId, uint16 _minDays, uint16 _maxDays, uint256 _pricePerDay) public {\r\n        require(LandContract.ownerOf(_tokenId) == msg.sender, 'owner');\r\n        require(!LandContract.isLocked(_tokenId), \"Locked\");\r\n        require(!rentals[_tokenId].flag, 'flag');\r\n        require(_minDays >= 1);\r\n        require(_maxDays <= 365);\r\n\r\n        (uint8 buildingId,,,,) = LandContract.getCellByToken(_tokenId);\r\n\r\n        uint8 buildingTypeId = BuildingsContract.buildingTypes(buildingId);\r\n\r\n        require(buildingId > 0);\r\n\r\n        if(buildingTypeId == 4 || buildingTypeId == 6 || buildingTypeId == 8) {\r\n            revert('buildingTypeId');\r\n        }\r\n\r\n        LandContract.lockToken(_tokenId);\r\n        rentals[_tokenId] = RentalStruct(_minDays, _maxDays, _pricePerDay, address(0), 0, true);\r\n\r\n        emit RentOut(_tokenId, _minDays, _maxDays, _pricePerDay);\r\n    }\r\n\r\n    function RemoveFromRental(uint256 _tokenId) public {\r\n        require(LandContract.ownerOf(_tokenId) == msg.sender);\r\n        require(rentals[_tokenId].flag);\r\n        require(rentals[_tokenId].renter == address(0), \"Rented\");\r\n\r\n        uint256 _pricePerDay = rentals[_tokenId].pricePerDay;\r\n        delete rentals[_tokenId];\r\n        LandContract.unlockToken(_tokenId);\r\n\r\n        emit RentalRemove(_tokenId, _pricePerDay);\r\n    }\r\n\r\n    function isInRental(uint256 _tokenId) public view returns (bool) {\r\n        return rentals[_tokenId].flag;\r\n    }\r\n\r\n    function rent(uint256 _tokenId, uint16 _days) public payable {\r\n        require(rentals[_tokenId].flag, \"1\");\r\n        require(rentals[_tokenId].renter == address(0), \"Rented\");\r\n        require(_days >= rentals[_tokenId].minDays, \"2\");\r\n        require(_days <= rentals[_tokenId].maxDays, \"3\");\r\n        require(msg.value >= _days * rentals[_tokenId].pricePerDay, \"not enough money\");\r\n        address _owner = LandContract.ownerOf(_tokenId);\r\n        require(msg.sender != _owner, \"4\");\r\n\r\n        rentals[_tokenId].renter = msg.sender;\r\n        rentals[_tokenId].endOfRental = now + uint256(_days) * uint256(1 days);\r\n\r\n        uint _price = _days * rentals[_tokenId].pricePerDay;\r\n        uint _ownerPrice = (_price * (1000 - devFeePercent - districtOwnerFeePercent - regionalBankFeePercent - globalBankFeePercent)) / 1000;\r\n\r\n        if (msg.value > _price && !msg.sender.send(msg.value - _price)) {\r\n            emit FailedPayout(msg.sender, msg.value - _ownerPrice);\r\n        }\r\n\r\n        UserBalanceContract.addBalance(_owner, _ownerPrice, 8, 0);\r\n        (,,,uint16 _regionId,) = LandContract.getCellByToken(_tokenId);\r\n\r\n        BanksContract.addToGlobalBank(_price * globalBankFeePercent / 1000, 0);\r\n        BanksContract.addToRegionBank(_price * regionalBankFeePercent / 1000, _regionId, 0);\r\n\r\n        address _regionOwner = RegionContract.ownerOf(_regionId);\r\n        if (_owner != address(0)) {\r\n            UserBalanceContract.addBalance(_regionOwner, _price * districtOwnerFeePercent / 1000, 1, 0);\r\n            emit RegionPayout(_owner, _regionId, _price * districtOwnerFeePercent / 1000, 2);\r\n        }\r\n\r\n        beneficiaryPayout(_price * devFeePercent / 1000);\r\n\r\n        UserBalanceContract.store.value(_price - _price * devFeePercent / 1000)();\r\n\r\n        emit Rental(_tokenId, rentals[_tokenId].renter, rentals[_tokenId].endOfRental, _price, _ownerPrice, _days, now);\r\n    }\r\n\r\n    function getRenterOrOwner(uint256 _tokenId) public view returns (address) {\r\n        if (rentals[_tokenId].renter != address(0)) {\r\n            require(rentals[_tokenId].endOfRental > now, \"The rent is over\");\r\n            return rentals[_tokenId].renter;\r\n        }\r\n\r\n        if (rentals[_tokenId].flag) {\r\n            return address(0);\r\n        }\r\n\r\n        return LandContract.ownerOf(_tokenId);\r\n    }\r\n\r\n    function rentalComplete(uint256 _tokenId) public {\r\n        require(LandContract.ownerOf(_tokenId) == msg.sender || rentals[_tokenId].renter == msg.sender);\r\n        require(rentals[_tokenId].renter != address(0));\r\n        require(rentals[_tokenId].endOfRental < now, \"Rental in progress\");\r\n\r\n        BuildingManagementContract.clearBuilding(_tokenId);\r\n        BuildingManagementContract.setLastAction(_tokenId, now);\r\n        rentals[_tokenId].renter = address(0);\r\n        rentals[_tokenId].endOfRental = 0;\r\n\r\n        emit RentalComplete(_tokenId, now);\r\n    }\r\n\r\n    event RentalComplete(uint256 _tokenId, uint256 _now);\r\n    event RentOut(uint256 _tokenId, uint16 _minDays, uint16 _maxDays, uint256 _pricePerDay);\r\n    event RentalRemove(uint256 _tokenId, uint256 _pricePerDay);\r\n    event Rental(uint256 _tokenId, address _renter, uint256 _endOfRental, uint _price, uint _ownerPrice, uint16 _days, uint256 _now);\r\n    event RegionPayout(address _owner, uint indexed tokenId, uint256 value, uint8 _payoutType);\r\n}\r\n\r\n\r\ncontract NewBuildingRentals is Manageable {\r\n    Land public LandContract;\r\n    UserBalance public UserBalanceContract;\r\n    Buildings public BuildingsContract;\r\n    Banks public BanksContract;\r\n    Region public RegionContract;\r\n    Verifier public VerifierContract;\r\n\r\n    uint256 public devFeePercent = 25; //2.5\r\n    uint256 public districtOwnerFeePercent = 25; //2.5\r\n    uint256 public regionalBankFeePercent = 25; //2.5\r\n    uint256 public globalBankFeePercent = 25; //2.5\r\n\r\n\r\n    struct RentalStruct {\r\n        uint16 minDays;\r\n        uint16 maxDays;\r\n        uint256 pricePerDay;\r\n        address renter;\r\n        uint256 endOfRental;\r\n        bool flag;\r\n    }\r\n\r\n    mapping(uint256 => RentalStruct) public rentals; // tokenId => RentalStruct\r\n\r\n    constructor(\r\n        address payable _land,\r\n        address payable _userBalance,\r\n        address payable _banks,\r\n        address payable _region,\r\n        address payable _verifier\r\n    ) public {\r\n        LandContract = Land(_land);\r\n        UserBalanceContract = UserBalance(_userBalance);\r\n        BanksContract = Banks(_banks);\r\n        RegionContract = Region(_region);\r\n        VerifierContract = Verifier(_verifier);\r\n    }\r\n\r\n    function setPercents(uint256 _devFeePercent, uint256 _districtOwnerFeePercent, uint256 _regionalBankFeePercent, uint256 _globalBankFeePercent) public onlyManager {\r\n        devFeePercent = _devFeePercent; // percent * 10\r\n        districtOwnerFeePercent = _districtOwnerFeePercent;\r\n        regionalBankFeePercent = _regionalBankFeePercent;\r\n        globalBankFeePercent = _globalBankFeePercent;\r\n    }\r\n\r\n    function setVerifierContract(address payable _verifier) public onlyManager {\r\n        VerifierContract = Verifier(_verifier);\r\n    }\r\n\r\n    function rentOut(address _address, uint256 _tokenId, uint16 _minDays, uint16 _maxDays, uint256 _pricePerDay, uint8 _buildingTypeId, bytes memory _signature) public {\r\n        bytes32 message = keccak256(abi.encode(_address, _tokenId, _minDays, _maxDays, _pricePerDay, _buildingTypeId));\r\n        VerifierContract.verifySignature(\r\n            keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", message)),\r\n            _signature\r\n        );\r\n\r\n        require(LandContract.ownerOf(_tokenId) == msg.sender);\r\n        require(!LandContract.isLocked(_tokenId), \"Locked\");\r\n        require(!rentals[_tokenId].flag, 'flag');\r\n        require(_minDays >= 1);\r\n        require(_maxDays <= 365);\r\n\r\n        if(_buildingTypeId == 0 || _buildingTypeId == 4 || _buildingTypeId == 6 || _buildingTypeId == 8) {\r\n            revert();\r\n        }\r\n\r\n        LandContract.lockToken(_tokenId);\r\n        rentals[_tokenId] = RentalStruct(_minDays, _maxDays, _pricePerDay, address(0), 0, true);\r\n\r\n        emit RentOut(_tokenId, _minDays, _maxDays, _pricePerDay);\r\n    }\r\n\r\n    function RemoveFromRental(uint256 _tokenId) public {\r\n        require(LandContract.ownerOf(_tokenId) == msg.sender);\r\n        require(rentals[_tokenId].flag);\r\n        require(rentals[_tokenId].renter == address(0), \"Rented\");\r\n\r\n        uint256 _pricePerDay = rentals[_tokenId].pricePerDay;\r\n        rentals[_tokenId].flag = false;\r\n\r\n        LandContract.unlockToken(_tokenId);\r\n\r\n        emit RentalRemove(_tokenId, _pricePerDay);\r\n    }\r\n\r\n    function isInRental(uint256 _tokenId) public view returns (bool) {\r\n        if(rentals[_tokenId].minDays > 0) {\r\n            return rentals[_tokenId].flag;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function rent(uint256 _tokenId, uint16 _days) public payable {\r\n        require(rentals[_tokenId].flag, \"1\");\r\n        require(rentals[_tokenId].renter == address(0), \"Rented\");\r\n        require(_days >= rentals[_tokenId].minDays, \"2\");\r\n        require(_days <= rentals[_tokenId].maxDays, \"3\");\r\n        require(msg.value >= _days * rentals[_tokenId].pricePerDay, \"not enough money\");\r\n        address _owner = LandContract.ownerOf(_tokenId);\r\n        require(msg.sender != _owner, \"4\");\r\n\r\n        rentals[_tokenId].renter = msg.sender;\r\n        rentals[_tokenId].endOfRental = now + uint256(_days) * uint256(1 days);\r\n\r\n        uint _price = _days * rentals[_tokenId].pricePerDay;\r\n        uint _ownerPrice = (_price * (1000 - devFeePercent - districtOwnerFeePercent - regionalBankFeePercent - globalBankFeePercent)) / 1000;\r\n\r\n        if (msg.value > _price && !msg.sender.send(msg.value - _price)) {\r\n            emit FailedPayout(msg.sender, msg.value - _ownerPrice);\r\n        }\r\n\r\n        UserBalanceContract.addBalance(_owner, _ownerPrice, 8, 0);\r\n        (,,,uint16 _regionId,) = LandContract.getCellByToken(_tokenId);\r\n\r\n        BanksContract.addToGlobalBank(_price * globalBankFeePercent / 1000, 0);\r\n        BanksContract.addToRegionBank(_price * regionalBankFeePercent / 1000, _regionId, 0);\r\n\r\n        address _regionOwner = RegionContract.ownerOf(_regionId);\r\n        if (_owner != address(0)) {\r\n            UserBalanceContract.addBalance(_regionOwner, _price * districtOwnerFeePercent / 1000, 1, 0);\r\n            emit RegionPayout(_owner, _regionId, _price * districtOwnerFeePercent / 1000, 2);\r\n        }\r\n\r\n        beneficiaryPayout(_price * devFeePercent / 1000);\r\n\r\n        UserBalanceContract.store.value(_price - _price * devFeePercent / 1000)();\r\n\r\n        emit Rental(_tokenId, rentals[_tokenId].renter, rentals[_tokenId].endOfRental, _price, _ownerPrice, _days, now);\r\n    }\r\n\r\n    function rentalComplete(uint256 _tokenId) public {\r\n        require(LandContract.ownerOf(_tokenId) == msg.sender || rentals[_tokenId].renter == msg.sender);\r\n        require(rentals[_tokenId].renter != address(0));\r\n        require(rentals[_tokenId].endOfRental < now, \"Rental in progress\");\r\n\r\n        LandContract.lockToken(_tokenId);\r\n        rentals[_tokenId].renter = address(0);\r\n        rentals[_tokenId].endOfRental = 0;\r\n\r\n        emit RentalComplete(_tokenId, now);\r\n    }\r\n\r\n    event RentalComplete(uint256 _tokenId, uint256 _now);\r\n    event RentOut(uint256 _tokenId, uint16 _minDays, uint16 _maxDays, uint256 _pricePerDay);\r\n    event RentalRemove(uint256 _tokenId, uint256 _pricePerDay);\r\n    event Rental(uint256 _tokenId, address _renter, uint256 _endOfRental, uint _price, uint _ownerPrice, uint16 _days, uint256 _now);\r\n    event RegionPayout(address _owner, uint indexed tokenId, uint256 value, uint8 _payoutType);\r\n}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"setBeneficiary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"isInRental\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devFeePercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_devFeePercent\",\"type\":\"uint256\"},{\"name\":\"_districtOwnerFeePercent\",\"type\":\"uint256\"},{\"name\":\"_regionalBankFeePercent\",\"type\":\"uint256\"},{\"name\":\"_globalBankFeePercent\",\"type\":\"uint256\"}],\"name\":\"setPercents\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"rentalComplete\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BanksContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_minDays\",\"type\":\"uint16\"},{\"name\":\"_maxDays\",\"type\":\"uint16\"},{\"name\":\"_pricePerDay\",\"type\":\"uint256\"},{\"name\":\"_buildingTypeId\",\"type\":\"uint8\"},{\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"rentOut\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"globalBankFeePercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RegionContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"withdrawal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VerifierContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LandContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"deleteManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_verifier\",\"type\":\"address\"}],\"name\":\"setVerifierContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"regionalBankFeePercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_days\",\"type\":\"uint16\"}],\"name\":\"rent\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rentals\",\"outputs\":[{\"name\":\"minDays\",\"type\":\"uint16\"},{\"name\":\"maxDays\",\"type\":\"uint16\"},{\"name\":\"pricePerDay\",\"type\":\"uint256\"},{\"name\":\"renter\",\"type\":\"address\"},{\"name\":\"endOfRental\",\"type\":\"uint256\"},{\"name\":\"flag\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"UserBalanceContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BuildingsContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"RemoveFromRental\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawalAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setMaintenanceStatus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"districtOwnerFeePercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"managers\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_land\",\"type\":\"address\"},{\"name\":\"_userBalance\",\"type\":\"address\"},{\"name\":\"_banks\",\"type\":\"address\"},{\"name\":\"_region\",\"type\":\"address\"},{\"name\":\"_verifier\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_now\",\"type\":\"uint256\"}],\"name\":\"RentalComplete\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_minDays\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"_maxDays\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"_pricePerDay\",\"type\":\"uint256\"}],\"name\":\"RentOut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_pricePerDay\",\"type\":\"uint256\"}],\"name\":\"RentalRemove\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_renter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_endOfRental\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_ownerPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_days\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"_now\",\"type\":\"uint256\"}],\"name\":\"Rental\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_payoutType\",\"type\":\"uint8\"}],\"name\":\"RegionPayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"Maintenance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"FailedPayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"BeneficiaryPayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]", "ContractName": "NewBuildingRentals", "CompilerVersion": "v0.5.9+commit.c68bc34e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000691d4c4de14f291ce85e137f5c93b1727f817f4b00000000000000000000000011f136f149aff3f539be935a1f0d17032ad2aaa40000000000000000000000002e22f583b90eb36bd8b5cd076c697433b12f9ee8000000000000000000000000565a36aa30e5b166162167889e7bcdcaf6218052000000000000000000000000728eaaab7d2aa6ec9f072518ecbe7e88a702e512", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://76dfbb8ec3b4cb01d18d99792c46a2eeaf08c7e2f8f2a96ae47bb2c435c908b3"}