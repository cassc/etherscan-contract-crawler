{"SourceCode": "// SPDX-License-Identifier: MIT\r\n/**____  _   _ ___ ____  _____                                                                                             \r\n* / ___|| \\ | |_ _|  _ \\| ____|_                                                                                           \r\n* \\___ \\|  \\| || || |_) |  _| (_)                                                                                          \r\n*  ___) | |\\  || ||  __/| |___ _                                                                                           \r\n* |____/|_| \\_|___|_|  _|_____(_)__   _    ____ ____ _____     _______   ____  _______        ___    ____  ____  ____    _ \r\n* | ____|  / \\  |  _ \\| \\ | | |  _ \\ / \\  / ___/ ___|_ _\\ \\   / / ____| |  _ \\| ____\\ \\      / / \\  |  _ \\|  _ \\/ ___|  | |\r\n* |  _|   / _ \\ | |_) |  \\| | | |_) / _ \\ \\___ \\___ \\| | \\ \\ / /|  _|   | |_) |  _|  \\ \\ /\\ / / _ \\ | |_) | | | \\___ \\  | |\r\n* | |___ / ___ \\|  _ <| |\\  | |  __/ ___ \\ ___) |__) | |  \\ V / | |___  |  _ <| |___  \\ V  V / ___ \\|  _ <| |_| |___) | |_|\r\n* |_____/_/   \\_\\_| \\_\\_| \\_| |_| /_/   \\_\\____/____/___|  \\_/  |_____| |_| \\_\\_____|  \\_/\\_/_/   \\_\\_| \\_\\____/|____/  (_)\r\n*/    \r\n\r\n//Powered by snipefinance.com                                                                                                                    \r\n\r\n/**\r\n *DEVELOPED by snipefinance.com \r\n *Development services at: snipefinance.com \r\n *Telegram contact: t.me/SnipeFinanceCom\r\n*/\r\n\r\npragma solidity ^0.7.6;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        returns (\r\n            uint256 amountA,\r\n            uint256 amountB,\r\n            uint256 liquidity\r\n        );\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (\r\n            uint256 amountToken,\r\n            uint256 amountETH,\r\n            uint256 liquidity\r\n        );\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 liquidity,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountA, uint256 amountB);\r\n\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountToken, uint256 amountETH);\r\n\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 liquidity,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint256 amountA, uint256 amountB);\r\n\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint256 amountToken, uint256 amountETH);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapTokensForExactTokens(\r\n        uint256 amountOut,\r\n        uint256 amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapExactETHForTokens(\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable returns (uint256[] memory amounts);\r\n\r\n    function swapTokensForExactETH(\r\n        uint256 amountOut,\r\n        uint256 amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapExactTokensForETH(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapETHForExactTokens(\r\n        uint256 amountOut,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable returns (uint256[] memory amounts);\r\n\r\n    function quote(\r\n        uint256 amountA,\r\n        uint256 reserveA,\r\n        uint256 reserveB\r\n    ) external pure returns (uint256 amountB);\r\n\r\n    function getAmountOut(\r\n        uint256 amountIn,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) external pure returns (uint256 amountOut);\r\n\r\n    function getAmountIn(\r\n        uint256 amountOut,\r\n        uint256 reserveIn,\r\n        uint256 reserveOut\r\n    ) external pure returns (uint256 amountIn);\r\n\r\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\r\n        external\r\n        view\r\n        returns (uint256[] memory amounts);\r\n\r\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\r\n        external\r\n        view\r\n        returns (uint256[] memory amounts);\r\n}\r\n\r\n// File: contracts/IUniswapV2Router02.sol\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountETH);\r\n\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint256 amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(\r\n        address indexed token0,\r\n        address indexed token1,\r\n        address pair,\r\n        uint256\r\n    );\r\n\r\n    function feeTo() external view returns (address);\r\n\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB)\r\n        external\r\n        view\r\n        returns (address pair);\r\n\r\n    function allPairs(uint256) external view returns (address pair);\r\n\r\n    function allPairsLength() external view returns (uint256);\r\n\r\n    function createPair(address tokenA, address tokenB)\r\n        external\r\n        returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\n// File: contracts/IUniswapV2Pair.sol\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    function name() external pure returns (string memory);\r\n\r\n    function symbol() external pure returns (string memory);\r\n\r\n    function decimals() external pure returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\r\n    event Burn(\r\n        address indexed sender,\r\n        uint256 amount0,\r\n        uint256 amount1,\r\n        address indexed to\r\n    );\r\n    event Swap(\r\n        address indexed sender,\r\n        uint256 amount0In,\r\n        uint256 amount1In,\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\r\n\r\n    function factory() external view returns (address);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (\r\n            uint112 reserve0,\r\n            uint112 reserve1,\r\n            uint32 blockTimestampLast\r\n        );\r\n\r\n    function price0CumulativeLast() external view returns (uint256);\r\n\r\n    function price1CumulativeLast() external view returns (uint256);\r\n\r\n    function kLast() external view returns (uint256);\r\n\r\n    function mint(address to) external returns (uint256 liquidity);\r\n\r\n    function burn(address to)\r\n        external\r\n        returns (uint256 amount0, uint256 amount1);\r\n\r\n    function swap(\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address to,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function skim(address to) external;\r\n\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n// File: contracts/IterableMapping.sol\r\n\r\nlibrary IterableMapping {\r\n    // Iterable mapping from address to uint;\r\n    struct Map {\r\n        address[] keys;\r\n        mapping(address => uint256) values;\r\n        mapping(address => uint256) indexOf;\r\n        mapping(address => bool) inserted;\r\n    }\r\n\r\n    function get(Map storage map, address key) public view returns (uint256) {\r\n        return map.values[key];\r\n    }\r\n\r\n    function getIndexOfKey(Map storage map, address key)\r\n        public\r\n        view\r\n        returns (int256)\r\n    {\r\n        if (!map.inserted[key]) {\r\n            return -1;\r\n        }\r\n        return int256(map.indexOf[key]);\r\n    }\r\n\r\n    function getKeyAtIndex(Map storage map, uint256 index)\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        return map.keys[index];\r\n    }\r\n\r\n    function size(Map storage map) public view returns (uint256) {\r\n        return map.keys.length;\r\n    }\r\n\r\n    function set(\r\n        Map storage map,\r\n        address key,\r\n        uint256 val\r\n    ) public {\r\n        if (map.inserted[key]) {\r\n            map.values[key] = val;\r\n        } else {\r\n            map.inserted[key] = true;\r\n            map.values[key] = val;\r\n            map.indexOf[key] = map.keys.length;\r\n            map.keys.push(key);\r\n        }\r\n    }\r\n\r\n    function remove(Map storage map, address key) public {\r\n        if (!map.inserted[key]) {\r\n            return;\r\n        }\r\n\r\n        delete map.inserted[key];\r\n        delete map.values[key];\r\n\r\n        uint256 index = map.indexOf[key];\r\n        uint256 lastIndex = map.keys.length - 1;\r\n        address lastKey = map.keys[lastIndex];\r\n\r\n        map.indexOf[lastKey] = index;\r\n        delete map.indexOf[key];\r\n\r\n        map.keys[index] = lastKey;\r\n        map.keys.pop();\r\n    }\r\n}\r\n\r\n// File: contracts/Ownable.sol\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/IRewardPayingTokenOptional.sol\r\n\r\n/// @title Reward-Paying Token Optional Interface\r\n/// @author Roger Wu (https://github.com/roger-wu)\r\n/// @dev OPTIONAL functions for a reward-paying token contract.\r\ninterface IRewardPayingTokenOptional {\r\n    /// @notice View the amount of reward in wei that an address can withdraw.\r\n    /// @param _owner The address of a token holder.\r\n    /// @return The amount of reward in wei that `_owner` can withdraw.\r\n    function withdrawableRewardOf(address _owner)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /// @notice View the amount of reward in wei that an address has withdrawn.\r\n    /// @param _owner The address of a token holder.\r\n    /// @return The amount of reward in wei that `_owner` has withdrawn.\r\n    function withdrawnRewardOf(address _owner) external view returns (uint256);\r\n\r\n    /// @notice View the amount of reward in wei that an address has earned in total.\r\n    /// @dev accumulativeRewardOf(_owner) = withdrawableRewardOf(_owner) + withdrawnRewardOf(_owner)\r\n    /// @param _owner The address of a token holder.\r\n    /// @return The amount of reward in wei that `_owner` has earned in total.\r\n    function accumulativeRewardOf(address _owner)\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\n// File: contracts/IRewardPayingToken.sol\r\n\r\n/// @title Reward-Paying Token Interface\r\n/// @author Roger Wu (https://github.com/roger-wu)\r\n/// @dev An interface for a reward-paying token contract.\r\ninterface IRewardPayingToken {\r\n    /// @notice View the amount of reward in wei that an address can withdraw.\r\n    /// @param _owner The address of a token holder.\r\n    /// @return The amount of reward in wei that `_owner` can withdraw.\r\n    function rewardOf(address _owner) external view returns (uint256);\r\n\r\n    /// @notice Distributes ether to token holders as rewards.\r\n    /// @dev SHOULD distribute the paid ether to token holders as rewards.\r\n    ///  SHOULD NOT directly transfer ether to token holders in this function.\r\n    ///  MUST emit a `RewardsDistributed` event when the amount of distributed ether is greater than 0.\r\n    function distributeRewards() external payable;\r\n\r\n    /// @notice Withdraws the ether distributed to the sender.\r\n    /// @dev SHOULD transfer `rewardOf(msg.sender)` wei to `msg.sender`, and `rewardOf(msg.sender)` SHOULD be 0 after the transfer.\r\n    ///  MUST emit a `RewardWithdrawn` event if the amount of ether transferred is greater than 0.\r\n    function withdrawReward() external;\r\n\r\n    /// @dev This event MUST emit when ether is distributed to token holders.\r\n    /// @param from The address which sends ether to this contract.\r\n    /// @param weiAmount The amount of distributed ether in wei.\r\n    event RewardsDistributed(address indexed from, uint256 weiAmount);\r\n\r\n    /// @dev This event MUST emit when an address withdraws their reward.\r\n    /// @param to The address which withdraws ether from this contract.\r\n    /// @param weiAmount The amount of withdrawn ether in wei.\r\n    event RewardWithdrawn(\r\n        address indexed to,\r\n        uint256 weiAmount,\r\n        address indexed tokenWithdrawn\r\n    );\r\n}\r\n\r\n// File: contracts/SafeMathInt.sol\r\n\r\n/**\r\n * @title SafeMathInt\r\n * @dev Math operations with safety checks that revert on error\r\n * @dev SafeMath adapted for int256\r\n * Based on code of  https://github.com/RequestNetwork/requestNetwork/blob/master/packages/requestNetworkSmartContracts/contracts/base/math/SafeMathInt.sol\r\n */\r\nlibrary SafeMathInt {\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Prevent overflow when multiplying INT256_MIN with -1\r\n        // https://github.com/RequestNetwork/requestNetwork/issues/43\r\n        require(!(a == -2**255 && b == -1) && !(b == -2**255 && a == -1));\r\n\r\n        int256 c = a * b;\r\n        require((b == 0) || (c / b == a));\r\n        return c;\r\n    }\r\n\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        // Prevent overflow when dividing INT256_MIN by -1\r\n        // https://github.com/RequestNetwork/requestNetwork/issues/43\r\n        require(!(a == -2**255 && b == -1) && (b > 0));\r\n\r\n        return a / b;\r\n    }\r\n\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        require((b >= 0 && a - b <= a) || (b < 0 && a - b > a));\r\n\r\n        return a - b;\r\n    }\r\n\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\r\n        return c;\r\n    }\r\n\r\n    function toUint256Safe(int256 a) internal pure returns (uint256) {\r\n        require(a >= 0);\r\n        return uint256(a);\r\n    }\r\n}\r\n\r\n// File: contracts/SafeMathUint.sol\r\n\r\n/**\r\n * @title SafeMathUint\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMathUint {\r\n    function toInt256Safe(uint256 a) internal pure returns (int256) {\r\n        int256 b = int256(a);\r\n        require(b >= 0);\r\n        return b;\r\n    }\r\n}\r\n\r\n// File: contracts/ERC20.sol\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP SNIPE not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\ninterface IERC20Metadata is IERC20 {\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 internal _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        public\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount)\r\n        public\r\n        virtual\r\n        override\r\n        returns (bool)\r\n    {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(\r\n            sender,\r\n            _msgSender(),\r\n            _allowances[sender][_msgSender()].sub(\r\n                amount,\r\n                \"ERC20: transfer amount exceeds allowance\"\r\n            )\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue)\r\n        public\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        _approve(\r\n            _msgSender(),\r\n            spender,\r\n            _allowances[_msgSender()][spender].add(addedValue)\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue)\r\n        public\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        _approve(\r\n            _msgSender(),\r\n            spender,\r\n            _allowances[_msgSender()][spender].sub(\r\n                subtractedValue,\r\n                \"ERC20: decreased allowance below zero\"\r\n            )\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function _spendAllowance(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(\r\n                currentAllowance >= amount,\r\n                \"ERC20: insufficient allowance\"\r\n            );\r\n            _approve(owner, spender, currentAllowance.sub(amount));\r\n        }\r\n    }\r\n\r\n    function _transfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        _balances[sender] = _balances[sender].sub(\r\n            amount,\r\n            \"ERC20: transfer amount exceeds balance\"\r\n        );\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        _balances[account] = _balances[account].sub(\r\n            amount,\r\n            \"ERC20: burn amount exceeds balance\"\r\n        );\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n}\r\n\r\n// File: contracts/SafeMath.sol\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (bool, uint256)\r\n    {\r\n        uint256 c = a + b;\r\n        if (c < a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (bool, uint256)\r\n    {\r\n        if (b > a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (bool, uint256)\r\n    {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (bool, uint256)\r\n    {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (bool, uint256)\r\n    {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    /**swapAndLiquifyOwner\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/SNIPERewardPayingToken.sol\r\n\r\n/// @title Reward-Paying Token\r\n/// @author Roger Wu (https://github.com/roger-wu)\r\n/// @dev A mintable ERC20 token that allows anyone to pay and distribute ether\r\n///  to token holders as rewards and allows token holders to withdraw their rewards.\r\n///  Reference: the source code of PoWH3D: https://etherscan.io/address/0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe#code\r\ncontract RewardPayingToken is\r\n    ERC20,\r\n    IRewardPayingToken,\r\n    IRewardPayingTokenOptional\r\n{\r\n    using SafeMath for uint256;\r\n    using SafeMathUint for uint256;\r\n    using SafeMathInt for int256;\r\n\r\n    // With `magnitude`, we can properly distribute rewards even if the amount of received ether is small.\r\n    // For more discussion about choosing the value of `magnitude`,\r\n    //  see https://github.com/ethereum/EIPs/issues/1726#issuecomment-472352728\r\n    uint256 internal constant magnitude = 2**128;\r\n\r\n    uint256 internal magnifiedRewardPerShare;\r\n    uint256 internal lastAmount;\r\n\r\n    address public RewardToken =\r\n        address(0x0000000000000000000000000000000000000000);\r\n    address public DefaultUserToken =\r\n        address(0x0000000000000000000000000000000000000000);\r\n    IUniswapV2Router02 public uniswapV2Router;\r\n\r\n    address public masterContract;\r\n\r\n    modifier onlyMaster() {\r\n        require(\r\n            masterContract == msg.sender,\r\n            \"Ownable: caller is not the master contract\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // About rewardCorrection:\r\n    // If the token balance of a `_user` is never changed, the reward of `_user` can be computed with:\r\n    //   `rewardOf(_user) = rewardPerShare * balanceOf(_user)`.\r\n    // When `balanceOf(_user)` is changed (via minting/burning/transferring tokens),\r\n    //   `rewardOf(_user)` should not be changed,\r\n    //   but the computed value of `rewardPerShare * balanceOf(_user)` is changed.\r\n    // To keep the `rewardOf(_user)` unchanged, we add a correction term:\r\n    //   `rewardOf(_user) = rewardPerShare * balanceOf(_user) + rewardCorrectionOf(_user)`,\r\n    //   where `rewardCorrectionOf(_user)` is updated whenever `balanceOf(_user)` is changed:\r\n    //   `rewardCorrectionOf(_user) = rewardPerShare * (old balanceOf(_user)) - (new balanceOf(_user))`.\r\n    // So now `rewardOf(_user)` returns the same value before and after `balanceOf(_user)` is changed.\r\n    mapping(address => int256) internal magnifiedRewardCorrections;\r\n    mapping(address => uint256) internal withdrawnRewards;\r\n    mapping(address => address) public rewardTokenUser;\r\n    mapping(address => bool) public _isRewardSet;\r\n\r\n    uint256 public totalRewardsDistributed;\r\n\r\n    constructor(string memory _name, string memory _symbol)\r\n        ERC20(_name, _symbol)\r\n    {\r\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(\r\n            0x10ED43C718714eb63d5aA57B78B54704E256024E\r\n        );\r\n        uniswapV2Router = _uniswapV2Router;\r\n        masterContract = msg.sender;\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    //added\r\n    function updateMasterContract(address newAddress) public onlyMaster {\r\n        masterContract = newAddress;\r\n    }\r\n\r\n    function updateUniswapV2Router(address newAddress) public onlyMaster {\r\n        uniswapV2Router = IUniswapV2Router02(newAddress);\r\n    }\r\n\r\n    function updateRewardTokenUser(address sender, address _myRewardToken)\r\n        public\r\n        onlyMaster\r\n    {\r\n        rewardTokenUser[sender] = _myRewardToken;\r\n        _isRewardSet[sender] = true;\r\n    }\r\n\r\n    function updateDefaultUserToken(address _newToken) public onlyMaster {\r\n        DefaultUserToken = _newToken;\r\n    }\r\n\r\n    function getRewardTokenUser(address sender) public view returns (address) {\r\n        return rewardTokenUser[sender];\r\n    }\r\n\r\n    function getDefaultUserToken() public view returns (address) {\r\n        return DefaultUserToken;\r\n    }\r\n\r\n    /// @notice Distributes ether to token holders as rewards.\r\n    /// @dev It reverts if the total supply of tokens is 0.\r\n    /// It emits the `RewardsDistributed` event if the amount of received ether is greater than 0.\r\n    /// About undistributed ether:\r\n    ///   In each distribution, there is a small amount of ether not distributed,\r\n    ///     the magnified amount of which is\r\n    ///     `(msg.value * magnitude) % totalSupply()`.\r\n    ///   With a well-chosen `magnitude`, the amount of undistributed ether\r\n    ///     (de-magnified) in a distribution can be less than 1 wei.\r\n    ///   We can actually keep track of the undistributed ether in a distribution\r\n    ///     and try to distribute it in the next distribution,\r\n    ///     but keeping track of such data on-chain costs much more than\r\n    ///     the saved ether, so we don't do that.\r\n    function distributeRewards() public payable override onlyMaster {\r\n        require(totalSupply() > 0);\r\n\r\n        if (msg.value > 0) {\r\n            magnifiedRewardPerShare = magnifiedRewardPerShare.add(\r\n                (msg.value).mul(magnitude) / totalSupply()\r\n            );\r\n            emit RewardsDistributed(msg.sender, msg.value);\r\n\r\n            totalRewardsDistributed = totalRewardsDistributed.add(msg.value);\r\n        }\r\n    }\r\n\r\n    function distributeTokenRewards(uint256 amount) public onlyMaster {\r\n        require(totalSupply() > 0);\r\n\r\n        if (amount > 0) {\r\n            magnifiedRewardPerShare = magnifiedRewardPerShare.add(\r\n                (amount).mul(magnitude) / totalSupply()\r\n            );\r\n            emit RewardsDistributed(msg.sender, amount);\r\n\r\n            totalRewardsDistributed = totalRewardsDistributed.add(amount);\r\n        }\r\n    }\r\n\r\n    /// @notice Withdraws the ether distributed to the sender.\r\n    /// @dev It emits a `RewardWithdrawn` event if the amount of withdrawn ether is greater than 0.\r\n    function withdrawReward() public virtual override {\r\n        _withdrawRewardOfUser(msg.sender);\r\n    }\r\n\r\n    function swapEthForTokens(\r\n        uint256 ethAmount,\r\n        address tokenAddress,\r\n        address receiver\r\n    ) private returns (bool) {\r\n        // generate the uniswap pair path of weth -> token\r\n        address[] memory path = new address[](2);\r\n        path[0] = uniswapV2Router.WETH();\r\n        path[1] = tokenAddress;\r\n\r\n        // make the swap\r\n\r\n        try\r\n            uniswapV2Router.swapExactETHForTokensSupportingFeeOnTransferTokens{\r\n                value: ethAmount\r\n            }(\r\n                0, // accept any amount of ETH\r\n                path,\r\n                receiver,\r\n                block.timestamp.add(300)\r\n            )\r\n        {\r\n            return true;\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /// @notice Withdraws the ether distributed to the sender.\r\n    /// @dev It emits a `RewardWithdrawn` event if the amount of withdrawn ether is greater than 0.\r\n    /// modified to support BNB reward\r\n    function _withdrawRewardOfUser(address payable user)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        uint256 _withdrawableReward = withdrawableRewardOf(user);\r\n        if (_withdrawableReward > 0) {\r\n            withdrawnRewards[user] = withdrawnRewards[user].add(\r\n                _withdrawableReward\r\n            );\r\n\r\n            // newFN\r\n            bool success = false;\r\n            if (_isRewardSet[user]) {\r\n                if (rewardTokenUser[user] == address(0)) {\r\n                    (bool sent, ) = user.call{value: _withdrawableReward}(\"\");\r\n                    success = sent;\r\n                    if (success) {\r\n                        emit RewardWithdrawn(\r\n                            user,\r\n                            _withdrawableReward,\r\n                            RewardToken\r\n                        );\r\n                    }\r\n                } else {\r\n                    success = swapEthForTokens(\r\n                        _withdrawableReward,\r\n                        rewardTokenUser[user],\r\n                        user\r\n                    );\r\n\r\n                    if (success) {\r\n                        emit RewardWithdrawn(\r\n                            user,\r\n                            _withdrawableReward,\r\n                            RewardToken\r\n                        );\r\n                    }\r\n                }\r\n            } else {\r\n                if (DefaultUserToken == address(0)) {\r\n                    (bool sent, ) = user.call{value: _withdrawableReward}(\"\");\r\n                    success = sent;\r\n                    if (success) {\r\n                        emit RewardWithdrawn(\r\n                            user,\r\n                            _withdrawableReward,\r\n                            RewardToken\r\n                        );\r\n                    }\r\n                } else {\r\n                    success = swapEthForTokens(\r\n                        _withdrawableReward,\r\n                        DefaultUserToken,\r\n                        user\r\n                    );\r\n                    if (success) {\r\n                        emit RewardWithdrawn(\r\n                            user,\r\n                            _withdrawableReward,\r\n                            RewardToken\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!success) {\r\n                withdrawnRewards[user] = withdrawnRewards[user].sub(\r\n                    _withdrawableReward\r\n                );\r\n                return 0;\r\n            }\r\n\r\n            return _withdrawableReward;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /// @notice View the amount of reward in wei that an address can withdraw.\r\n    /// @param _owner The address of a token holder.\r\n    /// @return The amount of reward in wei that `_owner` can withdraw.\r\n    function rewardOf(address _owner) public view override returns (uint256) {\r\n        return withdrawableRewardOf(_owner);\r\n    }\r\n\r\n    /// @notice View the amount of reward in wei that an address can withdraw.\r\n    /// @param _owner The address of a token holder.\r\n    /// @return The amount of reward in wei that `_owner` can withdraw.\r\n    function withdrawableRewardOf(address _owner)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return accumulativeRewardOf(_owner).sub(withdrawnRewards[_owner]);\r\n    }\r\n\r\n    /// @notice View the amount of reward in wei that an address has withdrawn.\r\n    /// @param _owner The address of a token holder.\r\n    /// @return The amount of reward in wei that `_owner` has withdrawn.\r\n    function withdrawnRewardOf(address _owner)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return withdrawnRewards[_owner];\r\n    }\r\n\r\n    /// @notice View the amount of reward in wei that an address has earned in total.\r\n    /// @dev accumulativeRewardOf(_owner) = withdrawableRewardOf(_owner) + withdrawnRewardOf(_owner)\r\n    /// = (magnifiedRewardPerShare * balanceOf(_owner) + magnifiedRewardCorrections[_owner]) / magnitude\r\n    /// @param _owner The address of a token holder.\r\n    /// @return The amount of reward in wei that `_owner` has earned in total.\r\n    function accumulativeRewardOf(address _owner)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return\r\n            magnifiedRewardPerShare\r\n                .mul(balanceOf(_owner))\r\n                .toInt256Safe()\r\n                .add(magnifiedRewardCorrections[_owner])\r\n                .toUint256Safe() / magnitude;\r\n    }\r\n\r\n    /// @dev Internal function that transfer tokens from one address to another.\r\n    /// Update magnifiedRewardCorrections to keep rewards unchanged.\r\n    /// @param from The address to transfer from.\r\n    /// @param to The address to transfer to.\r\n    /// @param value The amount to be transferred.\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal virtual override {\r\n        require(false);\r\n\r\n        int256 _magCorrection = magnifiedRewardPerShare\r\n            .mul(value)\r\n            .toInt256Safe();\r\n        magnifiedRewardCorrections[from] = magnifiedRewardCorrections[from].add(\r\n            _magCorrection\r\n        );\r\n        magnifiedRewardCorrections[to] = magnifiedRewardCorrections[to].sub(\r\n            _magCorrection\r\n        );\r\n    }\r\n\r\n    /// @dev Internal function that mints tokens to an account.\r\n    /// Update magnifiedRewardCorrections to keep rewards unchanged.\r\n    /// @param account The account that will receive the created tokens.\r\n    /// @param value The amount that will be created.\r\n    function _mint(address account, uint256 value) internal override {\r\n        super._mint(account, value);\r\n\r\n        magnifiedRewardCorrections[account] = magnifiedRewardCorrections[\r\n            account\r\n        ].sub((magnifiedRewardPerShare.mul(value)).toInt256Safe());\r\n    }\r\n\r\n    /// @dev Internal function that burns an amount of the token of a given account.\r\n    /// Update magnifiedRewardCorrections to keep rewards unchanged.\r\n    /// @param account The account whose tokens will be burnt.\r\n    /// @param value The amount that will be burnt.\r\n    function _burn(address account, uint256 value) internal override {\r\n        super._burn(account, value);\r\n\r\n        magnifiedRewardCorrections[account] = magnifiedRewardCorrections[\r\n            account\r\n        ].add((magnifiedRewardPerShare.mul(value)).toInt256Safe());\r\n    }\r\n\r\n    function _setBalance(address account, uint256 newBalance) internal {\r\n        uint256 currentBalance = balanceOf(account);\r\n\r\n        if (newBalance > currentBalance) {\r\n            uint256 mintAmount = newBalance.sub(currentBalance);\r\n            _mint(account, mintAmount);\r\n        } else if (newBalance < currentBalance) {\r\n            uint256 burnAmount = currentBalance.sub(newBalance);\r\n            _burn(account, burnAmount);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/SNIPE.sol\r\n\r\ncontract SNIPE is ERC20, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    IUniswapV2Router02 public uniswapV2Router;\r\n    address public immutable uniswapV2Pair;\r\n\r\n    address public RewardToken = address(0);\r\n\r\n    mapping(address => bool) public isExemptedFromFee;\r\n    SNIPERewardTracker public rewardTracker;\r\n\r\n    address public burnAddress;\r\n\r\n    uint256 public swapTokensAtAmount = 100 * (10**18);\r\n\r\n    address public marketTokenAddressForFee;\r\n    address public buyBackTokenAddressForFee;\r\n    // swap fees helper\r\n    uint256 public marketFee = 1;\r\n    uint256 public buyBackFee = 1;\r\n    uint256 public liquidityFee = 1;\r\n    uint256 public burnFee = 1;\r\n    uint256 public tokenRewardsFee = 1;\r\n    uint256 public totalFees = 5;\r\n\r\n    //transfer fees\r\n    uint256 Txfees = 5;\r\n\r\n    // buy fees\r\n    uint256 public buyMarketFee = 1;\r\n    uint256 public buyBuyBackFee = 1;\r\n    uint256 public buyTokenRewardsFee = 1;\r\n    uint256 public buyLiquidityFee = 1;\r\n    uint256 public buyBurnFee = 1;\r\n    uint256 public buyTotalFees =\r\n        buyMarketFee\r\n            .add(buyBuyBackFee)\r\n            .add(buyTokenRewardsFee)\r\n            .add(buyLiquidityFee)\r\n            .add(buyBurnFee);\r\n    // sell fees\r\n    uint256 public sellMarketFee = 2;\r\n    uint256 public sellBuyBackFee = 1;\r\n    uint256 public sellTokenRewardsFee = 4;\r\n    uint256 public sellLiquidityFee = 2;\r\n    uint256 public sellBurnFee = 1;\r\n    uint256 public sellTotalFees =\r\n        sellMarketFee\r\n            .add(sellBuyBackFee)\r\n            .add(sellTokenRewardsFee)\r\n            .add(sellLiquidityFee)\r\n            .add(sellBurnFee);\r\n\r\n    //\r\n    uint256 public processRewardTime;\r\n    uint256 public rewardTime = 3600;\r\n\r\n    bool public swapEnabled = true;\r\n    bool public addLiquidityEnabled = true;\r\n    bool public sendrewardEnabled = true;\r\n\r\n    bool public inSwap;\r\n    modifier isSwapping() {\r\n        inSwap = true;\r\n        _;\r\n        inSwap = false;\r\n    }\r\n\r\n    // use by default 300,000 gas to process auto-claiming rewards\r\n    uint256 public gasForProcessing = 1000000;\r\n\r\n    // timestamp for when the token can be traded freely on PanackeSwap\r\n    uint256 public tradingEnabledTimestamp = 1683889413;\r\n\r\n    // blacklisted from all transfers\r\n    mapping(address => bool) private _isBlacklisted;\r\n    // mapping of the last sale timestamp for each address\r\n    mapping(address => uint256) lastSaleTimestamp;\r\n    // cooldown time is in seconds\r\n    uint256 public cooldownTime = 1;\r\n    // exclude from fees\r\n    mapping(address => bool) private _isExcludedFromFees;\r\n\r\n    // store addresses that a automatic market maker pairs. Any transfer *to* these addresses\r\n    // could be subject to a maximum transfer amount\r\n    mapping(address => bool) public automatedMarketMakerPairs;\r\n\r\n    event UpdateRewardTracker(\r\n        address indexed newAddress,\r\n        address indexed oldAddress\r\n    );\r\n\r\n    event UpdateUniswapV2Router(\r\n        address indexed newAddress,\r\n        address indexed oldAddress\r\n    );\r\n\r\n    event UpdateRewardToken(\r\n        address indexed newAddress,\r\n        address indexed oldAddress\r\n    );\r\n\r\n    event ExcludeFromFees(address indexed account, bool isExcluded);\r\n    event ExcludeMultipleAccountsFromFees(address[] accounts, bool isExcluded);\r\n\r\n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\r\n\r\n    event BurnWalletUpdated(\r\n        address indexed newBurnWallet,\r\n        address indexed oldBurnWallet\r\n    );\r\n\r\n    event GasForProcessingUpdated(\r\n        uint256 indexed newValue,\r\n        uint256 indexed oldValue\r\n    );\r\n\r\n    event SwapAndLiquify(\r\n        uint256 tokensSwapped,\r\n        uint256 ethReceived,\r\n        uint256 tokensIntoLiqudity\r\n    );\r\n\r\n    event SendRewards(uint256 tokensSwapped, uint256 amount);\r\n\r\n    event ProcessedRewardTracker(\r\n        uint256 iterations,\r\n        uint256 claims,\r\n        uint256 lastProcessedIndex,\r\n        bool indexed automatic,\r\n        uint256 gas,\r\n        address indexed processor\r\n    );\r\n\r\n    constructor() ERC20(\"SNIPE\", \"SNIPE\") {\r\n        // LP burn address\r\n        burnAddress = address(0xdead);\r\n        uint256 _processRewardTime = block.timestamp;\r\n        processRewardTime = _processRewardTime;\r\n        rewardTracker = new SNIPERewardTracker();\r\n\r\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(\r\n            0x10ED43C718714eb63d5aA57B78B54704E256024E\r\n        );\r\n        \r\n\r\n        // Create a uniswap pair for this new token\r\n        address _uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\r\n            .createPair(address(this), _uniswapV2Router.WETH());\r\n\r\n        uniswapV2Router = _uniswapV2Router;\r\n        uniswapV2Pair = _uniswapV2Pair;\r\n\r\n        _setAutomatedMarketMakerPair(_uniswapV2Pair, true);\r\n\r\n        // exclude from receiving rewards\r\n        rewardTracker.excludeFromRewards(address(rewardTracker));\r\n        rewardTracker.excludeFromRewards(address(this));\r\n        rewardTracker.excludeFromRewards(address(_uniswapV2Router));\r\n\r\n        // exclude from paying fees or having max transaction amount\r\n        excludeFromFees(burnAddress, true);\r\n        excludeFromFees(address(this), true);\r\n        excludeFromFees(owner(), true);\r\n\r\n        /// update marketaddrsss\r\n        marketTokenAddressForFee = msg.sender;\r\n        buyBackTokenAddressForFee = msg.sender;\r\n\r\n        /*\r\n            _mint is an internal function in ERC20.sol that is only called here,\r\n            and CANNOT be called ever again\r\n        */\r\n        _mint(owner(), 1000000 * (10**18));\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function swapAndLiquifyOwner(uint256 _tokens) external onlyOwner {\r\n        swapAndLiquifyforowner(_tokens);\r\n    }\r\n\r\n    function swapAndSendRewardsOwner(uint256 _tokens) external onlyOwner {\r\n        swapAndSendRewardsforadmin(_tokens);\r\n    }\r\n\r\n  function updateRewardTokenUser(address _myRewardToken) external {\r\n        require(address(this) != _myRewardToken, \"own token can't be added\");\r\n        require(\r\n            IUniswapV2Factory(uniswapV2Router.factory()).getPair(\r\n                _myRewardToken,\r\n                uniswapV2Router.WETH()\r\n            ) !=\r\n                address(0) ||\r\n                IUniswapV2Factory(uniswapV2Router.factory()).getPair(\r\n                    uniswapV2Router.WETH(),\r\n                    _myRewardToken\r\n                ) !=\r\n                address(0) || _myRewardToken == address(0),\r\n            \"Pair does not exits\"\r\n        );\r\n        address sender = _msgSender();\r\n        rewardTracker.updateRewardTokenUser(sender, _myRewardToken);\r\n    }\r\n\r\n\r\n    function updateDefaultUserToken(address _newToken) public onlyOwner {\r\n        rewardTracker.updateDefaultUserToken(_newToken);\r\n    }\r\n\r\n    function getRewardTokenUser(address _myAddress)\r\n        external\r\n        view\r\n        returns (address)\r\n    {\r\n        return rewardTracker.getRewardTokenUser(_myAddress);\r\n    }\r\n\r\n    function getDefaultUserToken() external view returns (address) {\r\n        return rewardTracker.getDefaultUserToken();\r\n    }\r\n\r\n    function updaterewardTime(uint256 _rewardTime) external onlyOwner {\r\n        rewardTime = _rewardTime;\r\n    }\r\n\r\n    function updateCooldownTime(uint256 _seconds) public onlyOwner {\r\n        cooldownTime = _seconds;\r\n    }\r\n\r\n    function updateTradingEnabledTime(uint256 newTimeInEpoch)\r\n        external\r\n        onlyOwner\r\n    {\r\n        tradingEnabledTimestamp = newTimeInEpoch;\r\n    }\r\n\r\n    function updateMinimumBalanceForRewards(uint256 newAmountNoDecimials)\r\n        external\r\n        onlyOwner\r\n    {\r\n        rewardTracker.updateMinimumBalanceForRewards(newAmountNoDecimials);\r\n    }\r\n\r\n    function updateSwapAtAmount(uint256 newAmountNoDecimials)\r\n        external\r\n        onlyOwner\r\n    {\r\n        swapTokensAtAmount = newAmountNoDecimials * (10**18);\r\n    }\r\n\r\n    function updateMarketTokenFeeAddress(address newAddress)\r\n        external\r\n        onlyOwner\r\n    {\r\n        marketTokenAddressForFee = newAddress;\r\n        _isExcludedFromFees[newAddress] = true;\r\n    }\r\n\r\n    function updateBuyBackTokenFeeAddress(address newAddress)\r\n        external\r\n        onlyOwner\r\n    {\r\n        buyBackTokenAddressForFee = newAddress;\r\n        _isExcludedFromFees[newAddress] = true;\r\n    }\r\n    function setTxfees(uint256 _new) external onlyOwner{\r\n         Txfees  = _new;\r\n    }\r\n\r\n    function updateBuyFees(\r\n        uint256 _tokenRewardsFee,\r\n        uint256 _liquidityFee,\r\n        uint256 _marketFee,\r\n        uint256 _buyBackFee,\r\n        uint256 _burnFee\r\n    ) external onlyOwner {\r\n        buyTokenRewardsFee = _tokenRewardsFee;\r\n        buyLiquidityFee = _liquidityFee;\r\n        buyMarketFee = _marketFee;\r\n        buyBuyBackFee = _buyBackFee;\r\n        buyBurnFee = _burnFee;\r\n        buyTotalFees = _tokenRewardsFee\r\n            .add(_liquidityFee)\r\n            .add(_marketFee)\r\n            .add(_buyBackFee)\r\n            .add(_burnFee);\r\n    }\r\n\r\n    function updateSellFees(\r\n        uint256 _tokenRewardsFee,\r\n        uint256 _liquidityFee,\r\n        uint256 _marketFee,\r\n        uint256 _buyBackFee,\r\n        uint256 _burnFee\r\n    ) external onlyOwner {\r\n        sellTokenRewardsFee = _tokenRewardsFee;\r\n        sellLiquidityFee = _liquidityFee;\r\n        sellMarketFee = _marketFee;\r\n        sellBuyBackFee = _buyBackFee;\r\n        sellBurnFee = _burnFee;\r\n        sellTotalFees = _tokenRewardsFee\r\n            .add(_liquidityFee)\r\n            .add(_marketFee)\r\n            .add(_buyBackFee)\r\n            .add(_burnFee);\r\n    }\r\n\r\n    function updateRewardTracker(address newAddress) external onlyOwner {\r\n        require(\r\n            newAddress != address(rewardTracker),\r\n            \"SNIPE: The reward tracker already has that address\"\r\n        );\r\n\r\n        SNIPERewardTracker newRewardTracker = SNIPERewardTracker(\r\n            payable(newAddress)\r\n        );\r\n\r\n        require(\r\n            newRewardTracker.owner() == address(this),\r\n            \"SNIPE: The new reward tracker must be owned by the SNIPE token contract\"\r\n        );\r\n\r\n        newRewardTracker.excludeFromRewards(address(newRewardTracker));\r\n        newRewardTracker.excludeFromRewards(address(this));\r\n        newRewardTracker.excludeFromRewards(address(uniswapV2Router));\r\n\r\n        emit UpdateRewardTracker(newAddress, address(rewardTracker));\r\n\r\n        rewardTracker = newRewardTracker;\r\n    }\r\n\r\n    function updateUniswapV2Router(address newAddress) external onlyOwner {\r\n        require(\r\n            newAddress != address(uniswapV2Router),\r\n            \"SNIPE: The router already has that address\"\r\n        );\r\n        emit UpdateUniswapV2Router(newAddress, address(uniswapV2Router));\r\n        uniswapV2Router = IUniswapV2Router02(newAddress);\r\n    }\r\n\r\n    function excludeFromFees(address account, bool excluded) public onlyOwner {\r\n        _isExcludedFromFees[account] = excluded;\r\n    }\r\n\r\n    function blacklistAddress(address account, bool excluded) public onlyOwner {\r\n        _isBlacklisted[account] = excluded;\r\n        rewardTracker.excludeFromRewards(account);\r\n    }\r\n\r\n    function excludeFromRewards(address account) public onlyOwner {\r\n        rewardTracker.excludeFromRewards(account);\r\n    }\r\n\r\n    function enableRewards(address account) public onlyOwner {\r\n        rewardTracker.enableRewards(account);\r\n    }\r\n\r\n    function excludeMultipleAccountsFromFees(\r\n        address[] calldata accounts,\r\n        bool excluded\r\n    ) external onlyOwner {\r\n        for (uint256 i = 0; i < accounts.length; i++) {\r\n            _isExcludedFromFees[accounts[i]] = excluded;\r\n        }\r\n\r\n        emit ExcludeMultipleAccountsFromFees(accounts, excluded);\r\n    }\r\n\r\n    function setAutomatedMarketMakerPair(address pair, bool value)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(\r\n            pair != uniswapV2Pair,\r\n            \"SNIPE: The PancakeSwap pair cannot be removed from automatedMarketMakerPairs\"\r\n        );\r\n\r\n        _setAutomatedMarketMakerPair(pair, value);\r\n    }\r\n\r\n    function _setAutomatedMarketMakerPair(address pair, bool value) private {\r\n        require(\r\n            automatedMarketMakerPairs[pair] != value,\r\n            \"SNIPE: Automated market maker pair is already set to that value\"\r\n        );\r\n        automatedMarketMakerPairs[pair] = value;\r\n\r\n        if (value) {\r\n            rewardTracker.excludeFromRewards(pair);\r\n        }\r\n\r\n        emit SetAutomatedMarketMakerPair(pair, value);\r\n    }\r\n\r\n    function updateGasForProcessing(uint256 newValue) public onlyOwner {\r\n        require(\r\n            newValue >= 200000 && newValue <= 100000000,\r\n            \"SNIPE: gasForProcessing must be in the range\"\r\n        );\r\n        require(\r\n            newValue != gasForProcessing,\r\n            \"SNIPE: Cannot update gasForProcessing to same value\"\r\n        );\r\n        emit GasForProcessingUpdated(newValue, gasForProcessing);\r\n        gasForProcessing = newValue;\r\n    }\r\n\r\n    function withdrawStuckTokens() external onlyOwner {\r\n        require(address(this).balance > 0, \"Can't withdraw negative or zero\");\r\n        payable(owner()).transfer(address(this).balance);\r\n    }\r\n\r\n    function updateClaimWait(uint256 claimWait) external onlyOwner {\r\n        rewardTracker.updateClaimWait(claimWait);\r\n    }\r\n\r\n    function getClaimWait() external view returns (uint256) {\r\n        return rewardTracker.claimWait();\r\n    }\r\n\r\n    function getTotalRewardsDistributed() external view returns (uint256) {\r\n        return rewardTracker.totalRewardsDistributed();\r\n    }\r\n\r\n    function isExcludedFromFees(address account) public view returns (bool) {\r\n        return _isExcludedFromFees[account];\r\n    }\r\n\r\n    function withdrawableRewardOf(address account)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return rewardTracker.withdrawableRewardOf(account);\r\n    }\r\n\r\n    function rewardTokenBalanceOf(address account)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return rewardTracker.balanceOf(account);\r\n    }\r\n\r\n    function getAccountRewardsInfo(address account)\r\n        external\r\n        view\r\n        returns (\r\n            address,\r\n            int256,\r\n            int256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        return rewardTracker.getAccount(account);\r\n    }\r\n\r\n    function getAccountRewardsInfoAtIndex(uint256 index)\r\n        external\r\n        view\r\n        returns (\r\n            address,\r\n            int256,\r\n            int256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        return rewardTracker.getAccountAtIndex(index);\r\n    }\r\n\r\n    function processRewardTracker(uint256 gas) external {\r\n        (\r\n            uint256 iterations,\r\n            uint256 claims,\r\n            uint256 lastProcessedIndex\r\n        ) = rewardTracker.process(gas);\r\n        emit ProcessedRewardTracker(\r\n            iterations,\r\n            claims,\r\n            lastProcessedIndex,\r\n            false,\r\n            gas,\r\n            tx.origin\r\n        );\r\n    }\r\n\r\n    function claim() external {\r\n        rewardTracker.processAccount(msg.sender, false);\r\n    }\r\n\r\n    function getLastProcessedIndex() external view returns (uint256) {\r\n        return rewardTracker.getLastProcessedIndex();\r\n    }\r\n\r\n    function getNumberOfRewardTokenHolders() external view returns (uint256) {\r\n        return rewardTracker.getNumberOfTokenHolders();\r\n    }\r\n\r\n    function getTradingIsEnabled() public view returns (bool) {\r\n        return block.timestamp >= tradingEnabledTimestamp;\r\n    }\r\n\r\n    // added in order to sell eth for something else like usdt,busd,etc\r\n\r\n    function swapEthForTokens(\r\n        uint256 ethAmount,\r\n        address tokenAddress,\r\n        address receiver\r\n    ) private {\r\n        // generate the uniswap pair path of weth -> token\r\n        address[] memory path = new address[](2);\r\n        path[0] = uniswapV2Router.WETH();\r\n        path[1] = tokenAddress;\r\n\r\n        try\r\n            uniswapV2Router.swapExactETHForTokensSupportingFeeOnTransferTokens{\r\n                value: ethAmount\r\n            }(\r\n                0, // accept any amount of ETH\r\n                path,\r\n                receiver,\r\n                block.timestamp\r\n            )\r\n        {\r\n            // Swap succeeded\r\n        } catch {\r\n            // Swap failed\r\n        }\r\n    }\r\n\r\n    function swapTokensForEth(uint256 tokenAmount) private {\r\n        // generate the uniswap pair path of token -> weth\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = uniswapV2Router.WETH();\r\n\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        bool success = false;\r\n\r\n        try\r\n            uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n                tokenAmount,\r\n                0, // accept any amount of ETH\r\n                path,\r\n                address(this),\r\n                block.timestamp.add(300)\r\n            )\r\n        {\r\n            success = true;\r\n        } catch {\r\n            success = false;\r\n        }\r\n    }\r\n\r\n    function swapTokensForTokens(uint256 tokenAmount, address recipient)\r\n        private\r\n    {\r\n        // generate the uniswap pair path of this token -> WETH -> BUSD\r\n        address[] memory path = new address[](3);\r\n        path[0] = address(this);\r\n        path[1] = uniswapV2Router.WETH();\r\n        path[2] = RewardToken;\r\n\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n\r\n        try\r\n            // make the swap\r\n            uniswapV2Router\r\n                .swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n                    tokenAmount,\r\n                    0, // accept any amount of BUSD\r\n                    path,\r\n                    recipient,\r\n                    block.timestamp.add(300)\r\n                )\r\n        {} catch {\r\n            // Swap failed\r\n        }\r\n    }\r\n\r\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) internal {\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        try\r\n            uniswapV2Router.addLiquidityETH{value: ethAmount}(\r\n                address(this),\r\n                tokenAmount,\r\n                0,\r\n                0,\r\n                address(0),\r\n                block.timestamp.add(300)\r\n            )\r\n        {} catch {}\r\n    }\r\n\r\n    // modified to support BNB reward\r\n    function swapAndSendRewards(uint256 tokens) private {\r\n        address payable diviTracker = address(rewardTracker);\r\n        bool success = false;\r\n        uint256 initialBalance = address(this).balance;\r\n        swapTokensForEth(tokens);\r\n        uint256 newBalance = address(this).balance.sub(initialBalance);\r\n        (bool sent, ) = diviTracker.call{value: newBalance}(\"\");\r\n        success = sent;\r\n\r\n        if (success) {\r\n            rewardTracker.distributeTokenRewards(newBalance);\r\n            emit SendRewards(tokens, newBalance);\r\n        }\r\n    }\r\n\r\n    // modified to support BNB reward\r\n    function swapAndSendRewardsforadmin(uint256 tokens) private {\r\n        address payable diviTracker = address(rewardTracker);\r\n        bool success = false;\r\n        uint256 initialBalance = address(this).balance;\r\n        swapTokensForEth(tokens);\r\n        uint256 newBalance = address(this).balance.sub(initialBalance);\r\n        (bool sent, ) = diviTracker.call{value: newBalance}(\"\");\r\n        success = sent;\r\n\r\n        if (success) {\r\n            rewardTracker.distributeTokenRewards(newBalance);\r\n            emit SendRewards(tokens, newBalance);\r\n        }\r\n    }\r\n\r\n    function buyFees() internal {\r\n        marketFee = buyMarketFee;\r\n        buyBackFee = buyBuyBackFee;\r\n        liquidityFee = buyLiquidityFee;\r\n        tokenRewardsFee = buyTokenRewardsFee;\r\n        burnFee = buyBurnFee;\r\n        totalFees = buyTotalFees;\r\n    }\r\n\r\n    function sellFees() internal {\r\n        marketFee = sellMarketFee;\r\n        buyBackFee = sellBuyBackFee;\r\n        tokenRewardsFee = sellTokenRewardsFee;\r\n        liquidityFee = sellLiquidityFee;\r\n        burnFee = sellBurnFee;\r\n        totalFees = sellTotalFees;\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal override {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n        require(!_isBlacklisted[from], \"Blacklisted address cannot transfer!\");\r\n        require(!_isBlacklisted[to], \"Blacklisted address cannot transfer!\");\r\n\r\n        bool tradingIsEnabled = getTradingIsEnabled();\r\n        if (!tradingIsEnabled) {\r\n            revert(\r\n                \"SNIPE: This account cannot send tokens until trading is enabled\"\r\n            );\r\n        }\r\n        if (amount == 0) {\r\n            super._transfer(from, to, 0);\r\n            return;\r\n        } else if (\r\n            !inSwap && !_isExcludedFromFees[from] && !_isExcludedFromFees[to]\r\n        ) {\r\n            bool shouldTakeFee = !inSwap &&\r\n                (!isExemptedFromFee[from] && !isExemptedFromFee[to]);\r\n\r\n            uint256 side = 0;\r\n            address user_ = from;\r\n            address pair_ = to;\r\n\r\n            if (automatedMarketMakerPairs[from]) {\r\n                buyFees();\r\n                side = 1;\r\n                user_ = to;\r\n                pair_ = from;\r\n            } else if (automatedMarketMakerPairs[to]) {\r\n                sellFees();\r\n                side = 2;\r\n            } else {\r\n                shouldTakeFee = false;\r\n            }\r\n\r\n            // swap and liquify\r\n            uint256 tokenBalance = balanceOf(address(this));\r\n            bool canSwap = tokenBalance >= swapTokensAtAmount;\r\n\r\n            if (\r\n                canSwap &&\r\n                swapEnabled &&\r\n                !inSwap &&\r\n                !automatedMarketMakerPairs[_msgSender()]\r\n            ) {\r\n                swapAndLiquify(swapTokensAtAmount);\r\n            }\r\n\r\n            if (\r\n                canSwap &&\r\n                swapEnabled &&\r\n                !inSwap &&\r\n                sendrewardEnabled &&\r\n                !automatedMarketMakerPairs[_msgSender()]\r\n            ) {\r\n                senduserrewardforswapback(swapTokensAtAmount);\r\n            }\r\n            if (\r\n                canSwap &&\r\n                swapEnabled &&\r\n                !inSwap &&\r\n                !automatedMarketMakerPairs[_msgSender()]\r\n            ) {\r\n                SendmarketingBuybackfees(swapTokensAtAmount);\r\n            }\r\n             \r\n\r\n            //send amount\r\n            uint256 amountReceived = shouldTakeFee\r\n                ? takeFee(from, amount)\r\n                : takeTxfees(from,amount);\r\n            amount = amountReceived;\r\n\r\n\r\n        }\r\n\r\n        bool canReward = block.timestamp >= processRewardTime;\r\n        if (\r\n            !inSwap &&\r\n            !_isExcludedFromFees[from] &&\r\n            !_isExcludedFromFees[to] &&\r\n            canReward\r\n        ) {\r\n            uint256 gas = gasForProcessing;\r\n            processRewardTime += rewardTime;\r\n            try rewardTracker.process(gas) returns (\r\n                uint256 iterations,\r\n                uint256 claims,\r\n                uint256 lastProcessedIndex\r\n            ) {\r\n                emit ProcessedRewardTracker(\r\n                    iterations,\r\n                    claims,\r\n                    lastProcessedIndex,\r\n                    true,\r\n                    gas,\r\n                    tx.origin\r\n                );\r\n            } catch {}\r\n        }\r\n        super._transfer(from, to, amount);\r\n        try rewardTracker.setBalance(payable(from), balanceOf(from)) {} catch {}\r\n        try rewardTracker.setBalance(payable(to), balanceOf(to)) {} catch {}\r\n    }\r\n\r\n    function swapAndLiquify(uint256 tokenAmount) private isSwapping {\r\n        uint256 fees;\r\n        if (burnFee > 0) {\r\n            fees = totalFees.sub(burnFee);\r\n        } else {\r\n            fees = totalFees;\r\n        }\r\n\r\n        uint256 part = tokenAmount.div(fees);\r\n        uint256 sendLP = part.mul(liquidityFee);\r\n        uint256 half = sendLP.div(2);\r\n        uint256 initialBalance = address(this).balance;\r\n\r\n        // Swap\r\n        swapTokensForEth(half);\r\n\r\n        // How much ETH did we just receive\r\n        uint256 receivedETH = address(this).balance.sub(initialBalance);\r\n\r\n        // Add liquidity via the PancakeSwap V2 Router\r\n        addLiquidity(half, receivedETH);\r\n\r\n        emit SwapAndLiquify(half, receivedETH, half);\r\n    }\r\n\r\n    function swapAndLiquifyforowner(uint256 tokenAmount) private isSwapping {\r\n        uint256 half = tokenAmount.div(2);\r\n        uint256 initialBalance = address(this).balance;\r\n\r\n        // Swap\r\n        swapTokensForEth(half);\r\n\r\n        // How much ETH did we just receive\r\n        uint256 receivedETH = address(this).balance.sub(initialBalance);\r\n\r\n        // Add liquidity via the PancakeSwap V2 Router\r\n        addLiquidity(half, receivedETH);\r\n\r\n        emit SwapAndLiquify(half, receivedETH, half);\r\n    }\r\n\r\n    function senduserrewardforswapback(uint256 tokenAmount) private isSwapping {\r\n        uint256 fees;\r\n        if (burnFee > 0) {\r\n            fees = totalFees.sub(burnFee);\r\n        } else {\r\n            fees = totalFees;\r\n        }\r\n        uint256 part = tokenAmount.div(fees);\r\n        uint256 amountOfReward = part.mul(tokenRewardsFee);\r\n        swapAndSendRewards(amountOfReward);\r\n    }\r\n\r\n    function SendmarketingBuybackfees(uint256 tokenAmount) private {\r\n        uint256 fees;\r\n        if (burnFee > 0) {\r\n            fees = totalFees.sub(burnFee);\r\n        } else {\r\n            fees = totalFees;\r\n        }\r\n        uint256 part = tokenAmount.div(fees);\r\n        uint256 amountOfmarketfees = part.mul(marketFee);\r\n        uint256 amountOfbuybackfees = part.mul(buyBackFee);\r\n        super._transfer(\r\n            address(this),\r\n            marketTokenAddressForFee,\r\n            amountOfmarketfees\r\n        );\r\n        super._transfer(\r\n            address(this),\r\n            buyBackTokenAddressForFee,\r\n            amountOfbuybackfees\r\n        );\r\n    }\r\n\r\n    function takeFee(address sender, uint256 amount)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        if (burnFee == 0) {\r\n            uint256 feeAmount = amount.mul(totalFees).div(100);\r\n            super._transfer(sender, address(this), feeAmount);\r\n            return amount.sub(feeAmount);\r\n        } else {\r\n            uint256 calcFeeMinusBurn = totalFees.sub(burnFee);\r\n            uint256 feeAmountMinusBurn = amount.mul(calcFeeMinusBurn).div(100);\r\n            uint256 burnAmount = amount.mul(burnFee).div(100);\r\n            amount = amount.sub(feeAmountMinusBurn).sub(burnAmount);\r\n            super._transfer(sender, burnAddress, burnAmount);\r\n            super._transfer(sender, address(this), feeAmountMinusBurn);\r\n            return amount;\r\n        }\r\n    }\r\n\r\n   function takeTxfees(address sender,uint256 amount)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        if (Txfees> 0) {\r\n            uint256 feeAmount = amount.mul(Txfees).div(100);\r\n            super._transfer(sender, address(this), feeAmount);\r\n            return amount.sub(feeAmount);\r\n        }\r\n        return amount;\r\n    }\r\n\r\n\r\n    function setAddLiquidityEnabled(bool _enabled) external onlyOwner {\r\n        addLiquidityEnabled = _enabled;\r\n    }\r\n\r\n    function setsendrewardEnabled(bool _enabled) external onlyOwner {\r\n        sendrewardEnabled = _enabled;\r\n    }\r\n\r\n    function setSwapBackSettings(bool _enabled) external onlyOwner {\r\n        swapEnabled = _enabled;\r\n    }\r\n}\r\n\r\ncontract SNIPERewardTracker is RewardPayingToken, Ownable {\r\n    using SafeMath for uint256;\r\n    using SafeMathInt for int256;\r\n    using IterableMapping for IterableMapping.Map;\r\n\r\n    IterableMapping.Map private tokenHoldersMap;\r\n    uint256 public lastProcessedIndex;\r\n\r\n    mapping(address => bool) public excludedFromRewards;\r\n\r\n    mapping(address => uint256) public lastClaimTimes;\r\n\r\n    uint256 public claimWait;\r\n    uint256 public minimumTokenBalanceForRewards;\r\n\r\n    event ExcludeFromRewards(address indexed account);\r\n    event ClaimWaitUpdated(uint256 indexed newValue, uint256 indexed oldValue);\r\n\r\n    event Claim(\r\n        address indexed account,\r\n        uint256 amount,\r\n        bool indexed automatic\r\n    );\r\n\r\n    constructor()\r\n        RewardPayingToken(\"SNIPE_Reward_Tracker\", \"SNIPE_Reward_Tracker\")\r\n    {\r\n        claimWait = 3600;\r\n        minimumTokenBalanceForRewards = 1000 * (10**18); //must hold 1000+ tokens to get rewards\r\n    }\r\n\r\n    function updateMinimumBalanceForRewards(uint256 newAmountNoDecimials)\r\n        external\r\n        onlyOwner\r\n    {\r\n        minimumTokenBalanceForRewards = newAmountNoDecimials * (10**18);\r\n    }\r\n\r\n    function updateTokenForReward(address newAddress) external onlyOwner {\r\n        RewardToken = newAddress;\r\n    }\r\n\r\n    function _transfer(\r\n        address,\r\n        address,\r\n        uint256\r\n    ) internal pure override {\r\n        require(false, \"SNIPE_Reward_Tracker: No transfers allowed\");\r\n    }\r\n\r\n    function withdrawReward() public pure override {\r\n        require(\r\n            false,\r\n            \"SNIPE_Reward_Tracker: withdrawReward disabled. Use the 'claim' function on the main SNIPE contract.\"\r\n        );\r\n    }\r\n\r\n    function excludeFromRewards(address account) external onlyOwner {\r\n        excludedFromRewards[account] = true;\r\n\r\n        _setBalance(account, 0);\r\n        tokenHoldersMap.remove(account);\r\n    }\r\n\r\n    function enableRewards(address account) external onlyOwner {\r\n        excludedFromRewards[account] = false;\r\n    }\r\n\r\n    function updateClaimWait(uint256 newClaimWait) external onlyOwner {\r\n        require(\r\n            newClaimWait >= 3600 && newClaimWait <= 86400,\r\n            \"SNIPE_Reward_Tracker: claimWait must be updated to between 1 and 24 hours\"\r\n        );\r\n        require(\r\n            newClaimWait != claimWait,\r\n            \"SNIPE_Reward_Tracker: Cannot update claimWait to same value\"\r\n        );\r\n        emit ClaimWaitUpdated(newClaimWait, claimWait);\r\n        claimWait = newClaimWait;\r\n    }\r\n\r\n    function getLastProcessedIndex() external view returns (uint256) {\r\n        return lastProcessedIndex;\r\n    }\r\n\r\n    function getNumberOfTokenHolders() external view returns (uint256) {\r\n        return tokenHoldersMap.keys.length;\r\n    }\r\n\r\n    function getAccount(address _account)\r\n        public\r\n        view\r\n        returns (\r\n            address account,\r\n            int256 index,\r\n            int256 iterationsUntilProcessed,\r\n            uint256 withdrawableRewards,\r\n            uint256 totalRewards,\r\n            uint256 lastClaimTime,\r\n            uint256 nextClaimTime,\r\n            uint256 secondsUntilAutoClaimAvailable\r\n        )\r\n    {\r\n        account = _account;\r\n\r\n        index = tokenHoldersMap.getIndexOfKey(account);\r\n\r\n        iterationsUntilProcessed = -1;\r\n\r\n        if (index >= 0) {\r\n            if (uint256(index) > lastProcessedIndex) {\r\n                iterationsUntilProcessed = index.sub(\r\n                    int256(lastProcessedIndex)\r\n                );\r\n            } else {\r\n                uint256 processesUntilEndOfArray = tokenHoldersMap.keys.length >\r\n                    lastProcessedIndex\r\n                    ? tokenHoldersMap.keys.length.sub(lastProcessedIndex)\r\n                    : 0;\r\n\r\n                iterationsUntilProcessed = index.add(\r\n                    int256(processesUntilEndOfArray)\r\n                );\r\n            }\r\n        }\r\n\r\n        withdrawableRewards = withdrawableRewardOf(account);\r\n        totalRewards = accumulativeRewardOf(account);\r\n\r\n        lastClaimTime = lastClaimTimes[account];\r\n\r\n        nextClaimTime = lastClaimTime > 0 ? lastClaimTime.add(claimWait) : 0;\r\n\r\n        secondsUntilAutoClaimAvailable = nextClaimTime > block.timestamp\r\n            ? nextClaimTime.sub(block.timestamp)\r\n            : 0;\r\n    }\r\n\r\n    function getAccountAtIndex(uint256 index)\r\n        public\r\n        view\r\n        returns (\r\n            address,\r\n            int256,\r\n            int256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        if (index >= tokenHoldersMap.size()) {\r\n            return (\r\n                0x0000000000000000000000000000000000000000,\r\n                -1,\r\n                -1,\r\n                0,\r\n                0,\r\n                0,\r\n                0,\r\n                0\r\n            );\r\n        }\r\n\r\n        address account = tokenHoldersMap.getKeyAtIndex(index);\r\n\r\n        return getAccount(account);\r\n    }\r\n\r\n    function canAutoClaim(uint256 lastClaimTime) private view returns (bool) {\r\n        if (lastClaimTime > block.timestamp) {\r\n            return false;\r\n        }\r\n\r\n        return block.timestamp.sub(lastClaimTime) >= claimWait;\r\n    }\r\n\r\n    function setBalance(address payable account, uint256 newBalance)\r\n        external\r\n        onlyOwner\r\n    {\r\n        if (excludedFromRewards[account]) {\r\n            return;\r\n        }\r\n\r\n        if (newBalance >= minimumTokenBalanceForRewards) {\r\n            _setBalance(account, newBalance);\r\n            tokenHoldersMap.set(account, newBalance);\r\n        } else {\r\n            _setBalance(account, 0);\r\n            tokenHoldersMap.remove(account);\r\n        }\r\n\r\n        processAccount(account, true);\r\n    }\r\n\r\n    function process(uint256 gas)\r\n        public\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        uint256 numberOfTokenHolders = tokenHoldersMap.keys.length;\r\n\r\n        if (numberOfTokenHolders == 0) {\r\n            return (0, 0, lastProcessedIndex);\r\n        }\r\n\r\n        uint256 _lastProcessedIndex = lastProcessedIndex;\r\n\r\n        uint256 gasUsed = 0;\r\n\r\n        uint256 gasLeft = gasleft();\r\n\r\n        uint256 iterations = 0;\r\n        uint256 claims = 0;\r\n\r\n        while (gasUsed < gas && iterations < numberOfTokenHolders) {\r\n            _lastProcessedIndex++;\r\n\r\n            if (_lastProcessedIndex >= tokenHoldersMap.keys.length) {\r\n                _lastProcessedIndex = 0;\r\n            }\r\n\r\n            address account = tokenHoldersMap.keys[_lastProcessedIndex];\r\n\r\n            if (canAutoClaim(lastClaimTimes[account])) {\r\n                if (processAccount(payable(account), true)) {\r\n                    claims++;\r\n                }\r\n            }\r\n\r\n            iterations++;\r\n\r\n            uint256 newGasLeft = gasleft();\r\n\r\n            if (gasLeft > newGasLeft) {\r\n                gasUsed = gasUsed.add(gasLeft.sub(newGasLeft));\r\n            }\r\n\r\n            gasLeft = newGasLeft;\r\n        }\r\n\r\n        lastProcessedIndex = _lastProcessedIndex;\r\n\r\n        return (iterations, claims, lastProcessedIndex);\r\n    }\r\n\r\n    function processAccount(address payable account, bool automatic)\r\n        public\r\n        onlyOwner\r\n        returns (bool)\r\n    {\r\n        uint256 amount = _withdrawRewardOfUser(account);\r\n\r\n        if (amount > 0) {\r\n            lastClaimTimes[account] = block.timestamp;\r\n            emit Claim(account, amount, automatic);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function WithdrawStuckSNIPE(address _address) external onlyOwner {\r\n        require(\r\n            IERC20(_address).balanceOf(address(this)) > 0,\r\n            \"Can't withdraw 0\"\r\n        );\r\n\r\n        IERC20(_address).transfer(\r\n            owner(),\r\n            IERC20(_address).balanceOf(address(this))\r\n        );\r\n    }\r\n\r\n    function withdrawStuckCIC() external onlyOwner {\r\n        require(address(this).balance > 0, \"Can't withdraw negative or zero\");\r\n        payable(owner()).transfer(address(this).balance);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newBurnWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldBurnWallet\",\"type\":\"address\"}],\"name\":\"BurnWalletUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeFromFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeMultipleAccountsFromFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"}],\"name\":\"GasForProcessingUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"iterations\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claims\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastProcessedIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"automatic\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"processor\",\"type\":\"address\"}],\"name\":\"ProcessedRewardTracker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SendRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetAutomatedMarketMakerPair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiqudity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"}],\"name\":\"UpdateRewardToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"}],\"name\":\"UpdateRewardTracker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"}],\"name\":\"UpdateUniswapV2Router\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"RewardToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addLiquidityEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"automatedMarketMakerPairs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"blacklistAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyBackFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyBackTokenAddressForFee\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyBurnFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyBuyBackFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyLiquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyMarketFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTokenRewardsFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTotalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cooldownTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"enableRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeMultipleAccountsFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasForProcessing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAccountRewardsInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getAccountRewardsInfoAtIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getClaimWait\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDefaultUserToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastProcessedIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumberOfRewardTokenHolders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_myAddress\",\"type\":\"address\"}],\"name\":\"getRewardTokenUser\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalRewardsDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTradingIsEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isExemptedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketTokenAddressForFee\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"processRewardTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"}],\"name\":\"processRewardTracker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"rewardTokenBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardTracker\",\"outputs\":[{\"internalType\":\"contract SNIPERewardTracker\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellBurnFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellBuyBackFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellLiquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellMarketFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellTokenRewardsFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellTotalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sendrewardEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setAddLiquidityEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setAutomatedMarketMakerPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setSwapBackSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_new\",\"type\":\"uint256\"}],\"name\":\"setTxfees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setsendrewardEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"swapAndLiquifyOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"swapAndSendRewardsOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTokensAtAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenRewardsFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingEnabledTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"updateBuyBackTokenFeeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenRewardsFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_buyBackFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_burnFee\",\"type\":\"uint256\"}],\"name\":\"updateBuyFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"claimWait\",\"type\":\"uint256\"}],\"name\":\"updateClaimWait\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_seconds\",\"type\":\"uint256\"}],\"name\":\"updateCooldownTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newToken\",\"type\":\"address\"}],\"name\":\"updateDefaultUserToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"updateGasForProcessing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"updateMarketTokenFeeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAmountNoDecimials\",\"type\":\"uint256\"}],\"name\":\"updateMinimumBalanceForRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_myRewardToken\",\"type\":\"address\"}],\"name\":\"updateRewardTokenUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"updateRewardTracker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenRewardsFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_buyBackFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_burnFee\",\"type\":\"uint256\"}],\"name\":\"updateSellFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAmountNoDecimials\",\"type\":\"uint256\"}],\"name\":\"updateSwapAtAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTimeInEpoch\",\"type\":\"uint256\"}],\"name\":\"updateTradingEnabledTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"updateUniswapV2Router\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardTime\",\"type\":\"uint256\"}],\"name\":\"updaterewardTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawStuckTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"withdrawableRewardOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SNIPE", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "IterableMapping:9966c91d937bc1baae59ffd843a5f61e13dce25b", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://c7947ca27cd76d0083cd5c60c8935b111392318ef1ecb502947b03bce872cc6b"}