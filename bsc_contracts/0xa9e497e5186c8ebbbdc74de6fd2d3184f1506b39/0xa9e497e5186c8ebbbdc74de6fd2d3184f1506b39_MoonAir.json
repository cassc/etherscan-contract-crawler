{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/src/contracts/MoonAir.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nlibrary Zero {\\n  function requireNotZero(uint256 a) internal pure {\\n    require(a != 0, \\\"require not zero\\\");\\n  }\\n  function requireNotZero(address addr) internal pure {\\n    require(addr != address(0), \\\"require not zero address\\\");\\n  }\\n  function notZero(address addr) internal pure returns(bool) {\\n    return !(addr == address(0));\\n  }\\n  function isZero(address addr) internal pure returns(bool) {\\n    return addr == address(0);\\n  }\\n}\\nlibrary Percent {\\n  // Solidity automatically throws when dividing by 0\\n  struct percent {\\n    uint256 num;\\n    uint256 den;\\n  }\\n  function mul(percent storage p, uint256 a) internal view returns (uint) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n    return a*p.num/p.den;\\n  }\\n  function div(percent storage p, uint256 a) internal view returns (uint) {\\n    return a/p.num*p.den;\\n  }\\n  function sub(percent storage p, uint256 a) internal view returns (uint) {\\n    uint256 b = mul(p, a);\\n    if (b >= a) return 0;\\n    return a - b;\\n  }\\n  function add(percent storage p, uint256 a) internal view returns (uint) {\\n    return a + mul(p, a);\\n  }\\n}\\n\\ncontract UsersStorage is Ownable {\\n  struct userStaking {\\n    uint256 body;\\n    uint256 value;\\n    uint256 released;\\n    uint256 startFrom;\\n    uint256 endDate;\\n    bool active;\\n  }\\n  struct userProduct {\\n    uint256 value;\\n    uint256 startFrom;\\n  }\\n  struct user {\\n    uint256 keyIndex;\\n    uint256 refBonus;\\n    uint256 turnoverToken;\\n    uint256 turnoverUsd;\\n    uint256 packages;\\n    uint256 refFirst;\\n    uint256 nft;\\n    uint256 careerPercent;\\n    userStaking[] stakings;\\n    userProduct[] products;\\n  }\\n  struct itmap {\\n    mapping(address => user) data;\\n    address[] keys;\\n  }\\n  \\n  itmap internal s;\\n  mapping(address => address) public referral_tree;\\n\\n  event referralTree(address indexed referral, address indexed sponsor);\\n\\n  constructor(address wallet, address sponsor) {\\n    insertUser(wallet, sponsor);\\n  }\\n\\n  function insertUser(address addr, address sponsor) public onlyOwner returns (bool) {\\n    uint256 keyIndex = s.data[addr].keyIndex;\\n    if (keyIndex != 0) return false;\\n    uint256 keysLength = s.keys.length;\\n    keyIndex = keysLength+1;\\n    \\n    s.data[addr].keyIndex = keyIndex;\\n    s.keys.push(addr);\\n\\n    referral_tree[addr] = sponsor;\\n    emit referralTree(addr, sponsor);\\n\\n    return true;\\n  }\\n  function insertStaking(address addr, uint256 body, uint256 value, uint256 duration) public onlyOwner returns (bool) {\\n    if (s.data[addr].keyIndex == 0) return false;\\n    s.data[addr].stakings.push(\\n      userStaking(body, value, 0, block.timestamp, block.timestamp+duration, true)\\n    );\\n    return true;\\n  }\\n  function insertProduct(address addr, uint256 value) public onlyOwner returns (bool) {\\n    if (s.data[addr].keyIndex == 0) return false;\\n    s.data[addr].products.push(\\n      userProduct(value, block.timestamp)\\n    );\\n    return true;\\n  }\\n  function insertNft(address addr, uint256 value) public onlyOwner returns (bool) {\\n      s.data[addr].nft += value;\\n      return true;\\n  }\\n  function deleteNft(address addr, uint256 value) public onlyOwner returns (bool) {\\n      s.data[addr].nft -= value;\\n      return true;\\n  }\\n  function setNotActiveStaking(address addr, uint256 index) public onlyOwner returns (bool) {\\n      s.data[addr].stakings[index].active = false;\\n      return true;\\n  }\\n  function setCareerPercent(address addr, uint256 careerPercent) public onlyOwner {\\n    s.data[addr].careerPercent = careerPercent;\\n  }\\n\\n  function addTurnover(address addr, uint256 turnoverUsd, uint256 turnoverToken) public onlyOwner {\\n    s.data[addr].turnoverUsd += turnoverUsd; \\n    s.data[addr].turnoverToken += turnoverToken;\\n  }\\n\\n  function addPackage(address addr, uint256 package) public onlyOwner {\\n    s.data[addr].packages += package;\\n  }\\n  \\n  function addRefBonus(address addr, uint256 refBonus, uint256 level) public onlyOwner returns (bool) {\\n    if (s.data[addr].keyIndex == 0) return false;\\n    s.data[addr].refBonus += refBonus;\\n    if (level == 1) {\\n     s.data[addr].refFirst += refBonus;\\n    }  \\n    return true;\\n  }\\n  function setStakingReleased(address addr, uint256 index, uint256 released) public onlyOwner returns(bool) {\\n    s.data[addr].stakings[index].released += released;\\n    return true;\\n  }\\n  function userTurnover(address addr) public view returns(uint, uint, uint, uint, uint) {\\n    return (\\n        s.data[addr].turnoverToken,\\n        s.data[addr].turnoverUsd,\\n        s.data[addr].packages,\\n        s.data[addr].nft,\\n        s.data[addr].careerPercent\\n    );\\n  }\\n  function userReferralBonuses(address addr) public view returns(uint, uint) {\\n    return (\\n        s.data[addr].refFirst,\\n        s.data[addr].refBonus\\n    );\\n  }\\n  function userSingleStakingActive(address addr, uint256 index) public view returns(uint256, uint256, uint256, uint256, uint256, bool) {\\n     return (\\n      s.data[addr].stakings[index].body,\\n      s.data[addr].stakings[index].value,\\n      s.data[addr].stakings[index].released,\\n      s.data[addr].stakings[index].startFrom,\\n      s.data[addr].stakings[index].endDate,\\n      s.data[addr].stakings[index].active\\n    );   \\n  }\\n\\n  function userSingleStakingStruct(address addr, uint256 index) public view returns(userStaking memory) {\\n     return (\\n      s.data[addr].stakings[index]\\n    );   \\n  }\\n  function contains(address addr) public view returns (bool) {\\n    return s.data[addr].keyIndex > 0;\\n  }\\n  function haveValue(address addr) public view returns (bool) {\\n    if (s.data[addr].stakings.length > 0) {\\n        for(uint256 i = 0; i < s.data[addr].stakings.length; i++) {\\n            if (s.data[addr].stakings[i].active) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    } else {\\n        return false;\\n    }\\n  }\\n  function getCareerPercent(address addr) public view returns (uint) {\\n    return s.data[addr].careerPercent;\\n  }\\n  function getTotalStaking(address addr) public view returns (uint) {\\n      return s.data[addr].stakings.length;\\n  }\\n  function size() public view returns (uint) {\\n    return s.keys.length;\\n  }\\n  function getUserAddress(uint256 index) public view returns (address) {\\n    return s.keys[index];\\n  }\\n}\\n\\nerror packageBuy__Failed();\\nerror payment__Failed();\\ncontract MoonAir is Context, Ownable, ReentrancyGuard {\\n\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n    using Percent for Percent.percent;\\n    using Zero for *;\\n    struct careerInfo {\\n      uint256 percentFrom;\\n      uint256 turnoverFrom;\\n      uint256 turnoverTo;\\n      uint256 personalFee;\\n      uint256 nft;\\n    }\\n    careerInfo[] public career;\\n\\n    uint256 internal _durationStake;\\n    uint256 internal _periodStake;\\n    uint256 internal _gracePeriod;\\n\\n    struct stakingInfo {\\n      uint256 body;\\n      uint256 value;\\n      uint256 released;\\n      uint256 startDate;\\n      uint256 endDate;\\n      bool active;\\n    }  \\n    \\n    IERC20 public _token;\\n    IERC20 public _usdt;\\n    uint256 public totalPendingStake;\\n    uint256 public totalProfitNFT;\\n\\n    UsersStorage internal _users;\\n\\n    Percent.percent internal percentFee = Percent.percent(15, 100);\\n    Percent.percent internal percentNFT = Percent.percent(20, 100);\\n    Percent.percent internal percentGrace = Percent.percent(10, 100);\\n    Percent.percent internal percentLow = Percent.percent(140, 100);\\n    Percent.percent internal percentMid = Percent.percent(160, 100);\\n    Percent.percent internal percentHigh = Percent.percent(180, 100);\\n\\n    bool public stopM;\\n    uint256 public _rate;\\n\\n    address public newAddress;\\n    uint256 public voteScore;\\n    bool public voteSuccess;\\n    bool public dataTransfered;\\n    mapping(address => uint256) public voteWalletWeight;\\n    mapping(address => bool) public votedWallets;\\n    address[200] public voteWallets;\\n    uint public addedCanVoteWalletsCount;\\n\\n    address payable public _feeaddr; \\n    address payable public _owneraddr;\\n\\n    event compressionBonusPaid(address indexed from, address indexed to, uint256 value, uint256 date);\\n    event referralBonusPaid(address indexed from, address indexed to, uint256 indexed tokenAmount, uint256 value, uint256 date);\\n    event stakingBuyed(address indexed from, uint256 tokenAmount, uint256 bonusAmount, uint256 usdAmount, uint256 duration);\\n    event productBuyed(address indexed from, uint256 package, uint256 typeAir);\\n    event NFTBuyed(address indexed from, uint256 package);\\n    event NFTSelled(address indexed from, uint256 package);\\n    event getWithdraw(address indexed beneficiary, uint256 indexed withdrawAmount, uint256 date);\\n    event priceChanged(uint256 rate, uint256 date);\\n    event WithdrawOriginalBNB(address indexed owner, uint256 value);\\n    event AdminWalletChanged(address indexed oldWallet, address indexed newWallet);\\n    event FeeWalletChanged(address indexed oldWallet, address indexed newWallet);\\n    event WithdrawNftProfit(address indexed beneficiary, uint256 withdrawAmount);\\n\\n    modifier minAmount(uint256 package) {\\n        require(package >= 10*10**18,\\\"Minimal amount is $10\\\");\\n        _;\\n    }\\n\\n    modifier minAmountNFT(uint256 package) {\\n        require(package >= 5000*10**18,\\\"Minimal amount is $5000\\\");\\n        require(addedCanVoteWalletsCount < 200, \\\"No more nft can be added.\\\");\\n        _;\\n    }\\n\\n    modifier canVote() {\\n      require(voteWalletWeight[_msgSender()] > 0, \\\"You cannot vote\\\");\\n      require(votedWallets[_msgSender()] == false, \\\"already vote\\\");\\n      _;\\n    }\\n\\n    modifier activeSponsor(address walletSponsor) {\\n      require(_users.contains(walletSponsor) == true,\\\"No such sponsor\\\");\\n      require(walletSponsor.notZero() == true, \\\"Set a sponsor\\\");\\n      require(walletSponsor != _msgSender(),\\\"You need a sponsor link, not yours\\\");\\n      _;\\n    }\\n\\n    modifier activeUser() {\\n      require(_users.contains(_msgSender()) == true, \\\"No such user\\\");\\n      _;\\n    }\\n\\n    constructor(IERC20 token, IERC20 usdt, address firstwallet, address payable feeaddr, address payable owneraddr) {\\n      _token = token;\\n      _usdt = usdt;\\n      _users = new UsersStorage(firstwallet, address(this));\\n\\n      _feeaddr = feeaddr;\\n      _owneraddr = owneraddr;\\n\\n      _durationStake = 31104000; //- 360days in seconds\\n      _periodStake = 86400; //- 1days in seconds\\n      _gracePeriod = 0; //1 - 31 october\\n\\n      career.push(careerInfo(50, 0, 499, 0, 0)); //5%\\n      career.push(careerInfo(60, 500, 999, 0, 0)); //6%\\n      career.push(careerInfo(70, 1000, 4999, 0, 0)); //7%\\n      career.push(careerInfo(80, 5000, 9999, 0, 0)); //8%\\n      career.push(careerInfo(90, 10000, 24999, 0, 0)); //9%\\n      career.push(careerInfo(100, 25000, 49999, 500, 0)); //10%\\n      career.push(careerInfo(110, 50000, 99999, 1000, 0)); //11%\\n      career.push(careerInfo(120, 100000, 199999, 2000, 0)); //12%\\n      career.push(careerInfo(130, 200000, 299999, 3000, 0)); //13%\\n      career.push(careerInfo(140, 300000, 399999, 4000, 0)); //14%\\n      career.push(careerInfo(150, 400000, 499999, 5000, 0)); //15%\\n      career.push(careerInfo(160, 500000, 999999, 10000, 1)); //16%\\n      career.push(careerInfo(170, 1000000, 1999999, 20000, 2)); //17%\\n      career.push(careerInfo(180, 2000000, 4999999, 50000, 3)); //18%\\n      career.push(careerInfo(190, 5000000, 9999999, 100000, 4)); //19%\\n      career.push(careerInfo(200, 10000000, 10000000000000000, 150000, 5)); //20%\\n    }\\n\\n    function buyProduct(uint256 usdAmount, uint256 typeAir) public payable minAmount(usdAmount) activeUser nonReentrant {\\n      address beneficiary = _msgSender();\\n\\n      require(_usdt.balanceOf(beneficiary) >= usdAmount, \\\"Not enough tokens\\\");\\n      require(_usdt.allowance(beneficiary,address(this)) >= usdAmount, \\\"Please allow fund first\\\");\\n      bool success = _usdt.transferFrom(beneficiary, address(this), usdAmount);\\n      if (!success) {\\n        revert packageBuy__Failed();\\n      } else {\\n          _users.insertProduct(beneficiary, usdAmount);\\n\\n          emit productBuyed(beneficiary, usdAmount, typeAir);\\n\\n          totalProfitNFT += percentNFT.mul(usdAmount);\\n\\n          address payable mySponsor = payable(_users.referral_tree(beneficiary));\\n          if (_users.haveValue(mySponsor)) {\\n            _addReferralBonus(true, beneficiary, mySponsor, usdAmount);\\n          }\\t\\n          _compressionBonus(true, usdAmount, mySponsor, 0, 1);\\n\\n          _usdt.transfer(_feeaddr, percentFee.mul(usdAmount));\\n          _usdt.transfer(_owneraddr, _usdt.balanceOf(address(this))-totalProfitNFT);\\n      }\\n    }\\n\\n    function buyNFT(uint256 usdAmount) public payable minAmountNFT(usdAmount) activeUser nonReentrant {\\n      address beneficiary = _msgSender();\\n\\n      require(_usdt.balanceOf(beneficiary) >= usdAmount, \\\"Not enough tokens\\\");\\n      require(_usdt.allowance(beneficiary,address(this)) >= usdAmount, \\\"Please allow fund first\\\");\\n      bool success = _usdt.transferFrom(beneficiary, address(this), usdAmount);\\n      if (!success) {\\n        revert packageBuy__Failed();\\n      } else {\\n          _users.insertNft(beneficiary, usdAmount/10**18);\\n\\n          voteWalletWeight[beneficiary] = 1;\\n          voteWallets[addedCanVoteWalletsCount] = beneficiary;\\n          addedCanVoteWalletsCount++;\\n\\n          emit NFTBuyed(beneficiary, usdAmount/10**18);\\n\\n          address payable mySponsor = payable(_users.referral_tree(beneficiary));\\n          if (_users.haveValue(mySponsor)) {\\n            _addReferralBonus(true, beneficiary, mySponsor, usdAmount);\\n          }\\t\\n          _compressionBonus(true, usdAmount, mySponsor, 0, 1);\\n\\n          _usdt.transfer(_owneraddr, _usdt.balanceOf(address(this))-totalProfitNFT);\\n      }\\n    }\\n\\n    function setStake(uint256 usdAmount) public payable minAmount(usdAmount) activeUser nonReentrant {\\n      address beneficiary = _msgSender();\\n      uint256 bonus;\\n      uint256 gracebonus;\\n\\n      uint256 tokenAmount = _getTokenAmountByUSD(usdAmount);\\n      require(_usdt.balanceOf(beneficiary) >= usdAmount, \\\"Not enough tokens\\\");\\n      require(_usdt.allowance(beneficiary,address(this)) >= usdAmount, \\\"Please allow fund first\\\");\\n      bool success = _usdt.transferFrom(beneficiary, address(this), usdAmount);\\n      if (!success) {\\n        revert packageBuy__Failed();\\n      } else {\\n          gracebonus = percentGrace.mul(tokenAmount);\\n\\n          if (usdAmount < 1000*10**18) {\\n              bonus = (percentLow.mul(tokenAmount)-(gracebonus*_gracePeriod));\\n          } else if (usdAmount >= 1000*10**18 && usdAmount <= 9999*10**18) {\\n              bonus = (percentMid.mul(tokenAmount)-(gracebonus*_gracePeriod));\\n          } else if (usdAmount >= 10000*10**18) {\\n              bonus = (percentHigh.mul(tokenAmount)-(gracebonus*_gracePeriod));\\n          }\\n\\n          totalPendingStake += tokenAmount+bonus;\\n\\n          totalProfitNFT += percentNFT.mul(usdAmount);\\n\\n          _users.insertStaking(beneficiary, tokenAmount+bonus, bonus, _durationStake);\\n\\n          _users.addPackage(beneficiary, usdAmount/10**18);\\n\\n          emit stakingBuyed(beneficiary, tokenAmount, bonus, usdAmount, _durationStake);\\n\\n          address payable mySponsor = payable(_users.referral_tree(beneficiary));\\n          if (_users.haveValue(mySponsor)) {\\n            _addReferralBonus(true, beneficiary, mySponsor, usdAmount);\\n          }\\t\\n          _compressionBonus(true, usdAmount, mySponsor, 0, 1);\\n\\n          _usdt.transfer(_owneraddr, _usdt.balanceOf(address(this))-totalProfitNFT);\\n      }\\n    }\\n\\n    function withdraw() public payable nonReentrant { \\n      address beneficiary = _msgSender();\\n      uint256 currentTime = block.timestamp;\\n      uint256 stakingAmount;\\n      uint256 totalAmount;\\n      stakingInfo memory stake;\\n\\n      if (_users.contains(beneficiary)) {\\n        for (uint256 i = 0; i < _users.getTotalStaking(beneficiary); i++) {\\n\\n          stake = updateStakingInfo(beneficiary, i);\\n          if (stake.active) {\\n            if (currentTime >= stake.endDate) {\\n              stakingAmount = stake.body.sub(stake.released);\\n              _users.setNotActiveStaking(beneficiary, i);\\n            } else {\\n              uint256 timeFromStart = currentTime.sub(stake.startDate);\\n              uint256 stakingSlicePeriods = timeFromStart.div(_periodStake);\\n              uint256 stakingSeconds = stakingSlicePeriods.mul(_periodStake);\\n              stakingAmount = stake.body.mul(stakingSeconds).div(stake.endDate-stake.startDate);\\n              stakingAmount = stakingAmount.sub(stake.released);\\n            }\\n\\n            totalAmount += stakingAmount;\\n\\n            _users.setStakingReleased(beneficiary, i, stakingAmount);\\n          }\\n\\n        }\\n\\n        totalPendingStake -= totalAmount;\\n        _token.transfer(beneficiary, totalAmount);\\n        emit getWithdraw(beneficiary, totalAmount, block.timestamp);\\n      }\\n    }\\n\\n    function withdrawNFTProfit() public payable onlyOwner nonReentrant {\\n      uint256 share = totalProfitNFT/200; \\n      for(uint256 i = 0; i < voteWallets.length; i++) {\\n        _usdt.transfer(voteWallets[i], share);\\n        emit WithdrawNftProfit(voteWallets[i], share);\\n      }\\n      totalProfitNFT = 0;\\n      _usdt.transfer(_owneraddr, _usdt.balanceOf(address(this)));\\n    }\\n\\n    function updateStakingInfo(address beneficiary, uint256 index) internal view returns (stakingInfo memory stake) {\\n      (stake.body, stake.value, stake.released, stake.startDate, stake.endDate, stake.active) = _users.userSingleStakingActive(beneficiary, index);\\n      return stake;\\n    }\\n\\n    function computeAllStakingAmount(address beneficiary) public view returns (uint256 stakingAmount) {\\n      for (uint256 i = 0; i < _users.getTotalStaking(beneficiary); i++) {\\n        stakingAmount += computeStakingAmount(beneficiary, i);\\n      }\\n    }\\n\\n    function computeStakingAmount(address beneficiary, uint256 index) public view returns (uint256 stakingAmount) {\\n      uint256 currentTime = block.timestamp;\\n      stakingInfo memory stake;\\n      \\n      stake = updateStakingInfo(beneficiary, index);\\n      if (stake.active) {\\n        if (currentTime >= stake.endDate) {\\n          stakingAmount = stake.body.sub(stake.released);\\n        } else {\\n          uint256 timeFromStart = currentTime.sub(stake.startDate);\\n          uint256 stakingSlicePeriods = timeFromStart.div(_periodStake);\\n          uint256 stakingSeconds = stakingSlicePeriods.mul(_periodStake);\\n          stakingAmount = stake.body.mul(stakingSeconds).div(stake.endDate-stake.startDate);\\n          stakingAmount = stakingAmount.sub(stake.released);\\n        }\\n      }  \\n    }\\n\\n    function getSponsorAddress(address referral) internal view returns(address) {\\n        address sponsor = _users.referral_tree(referral);\\n        return sponsor;\\n    }\\n\\n    function _compressionBonus(bool needTransfer, uint256 usdAmount, address payable user, uint256 prevPercent, uint256 line) internal {\\n      address payable mySponsor = payable(_users.referral_tree(user));\\n      if (_users.contains(user)) {\\n        uint256 careerPercent = _users.getCareerPercent(user);\\n        _users.addTurnover(user, usdAmount/10**18, _getTokenAmountByUSD(usdAmount));\\n        _checkCareerPercent(user);\\n        if (_users.haveValue(user)) {\\n          if (line == 1) {\\n            prevPercent = careerPercent;\\n          }\\n          if (line >= 2) {\\n            if (prevPercent < careerPercent) {\\n              uint256 finalPercent = career[careerPercent].percentFrom - career[prevPercent].percentFrom;\\n              uint256 bonus = usdAmount*finalPercent/1000;\\n              if (bonus > 0 && _users.haveValue(user)) {\\n                assert(_users.addRefBonus(user, bonus, line));\\n                if (needTransfer) {\\n                  _usdt.transfer(user, bonus);\\n                }\\n                emit compressionBonusPaid(_msgSender(), user, bonus, block.timestamp);\\n                prevPercent = careerPercent;\\n              }           \\n            }\\n          }\\n        }\\n      }\\n      if (_notZeroNotSender(mySponsor)) {\\n        line = line + 1;\\n        if (line < 51) {\\n          _compressionBonus(needTransfer, usdAmount, mySponsor, prevPercent, line);\\n        }\\n      }\\n    }\\n\\n    function _addReferralBonus(bool needTransfer, address user, address payable sponsor, uint256 usdAmount) internal {\\n      uint256 reward;\\n\\n      uint256 careerPercent = _users.getCareerPercent(sponsor);\\n      reward = usdAmount*career[careerPercent].percentFrom/1000;\\n      assert(_users.addRefBonus(sponsor, reward, 1));\\n      \\n      if (needTransfer) {\\n        _usdt.transfer(sponsor, reward);\\n      }\\n      emit referralBonusPaid(user, sponsor, usdAmount, reward, block.timestamp);\\n    }\\n\\n    function _checkCareerPercent(address addr) internal {\\n      (, uint256 turnoverUsd, uint256 packages, uint256 nft, uint256 careerPercent) = _users.userTurnover(addr);\\n      if (career[careerPercent+1].turnoverFrom <= turnoverUsd && career[careerPercent+1].turnoverTo >= turnoverUsd && career[careerPercent+1].personalFee <= packages && career[careerPercent+1].nft <= nft/5000) {\\n        _users.setCareerPercent(addr, careerPercent+1);\\n      } else if (career[careerPercent+2].turnoverFrom <= turnoverUsd && career[careerPercent+2].turnoverTo >= turnoverUsd && career[careerPercent+2].personalFee <= packages && career[careerPercent+2].nft <= nft/5000) {\\n        _users.setCareerPercent(addr, careerPercent+2);\\n      } else if (career[careerPercent+3].turnoverFrom <= turnoverUsd && career[careerPercent+3].turnoverTo >= turnoverUsd && career[careerPercent+3].personalFee <= packages && career[careerPercent+3].nft <= nft/5000) {\\n        _users.setCareerPercent(addr, careerPercent+3);\\n      } else if (career[careerPercent+4].turnoverFrom <= turnoverUsd && career[careerPercent+4].turnoverTo >= turnoverUsd && career[careerPercent+4].personalFee <= packages && career[careerPercent+4].nft <= nft/5000) {\\n        _users.setCareerPercent(addr, careerPercent+4);\\n      } else if (career[careerPercent+5].turnoverFrom <= turnoverUsd && career[careerPercent+5].turnoverTo >= turnoverUsd && career[careerPercent+5].personalFee <= packages && career[careerPercent+5].nft <= nft/5000) {\\n        _users.setCareerPercent(addr, careerPercent+5);\\n      }\\n    }\\n\\n    function _notZeroNotSender(address addr) internal view returns(bool) {\\n      return addr.notZero() && addr != _msgSender();\\n    }\\n\\n    function _getUsdAmount(uint256 tokenAmount) internal view returns (uint256){\\n      return tokenAmount.mul(_rate).div(10**28);   \\n    }\\n\\n    function _getTokenAmountByUSD(uint256 usdAmount) internal view returns(uint256) {\\n      return usdAmount.mul(10**10).div(_rate);\\n    }\\n\\n    function changeGracePeriod(uint256 period) public onlyOwner {\\n      _gracePeriod = period;\\n    }\\n\\n    function withdrawFreezeToken(IERC20 erctoken, address wallet) public onlyOwner {\\n      require(erctoken != _token, \\\"Only another tokens\\\");\\n      erctoken.transfer(wallet, erctoken.balanceOf(address(this)));\\n    }\\n\\n    function setStakeM(address beneficiary, address sponsor, uint tokenAmount, uint bonus, uint256 duration) public payable onlyOwner {\\n      require(stopM == false, \\\"Old stake done\\\");\\n      \\n      if (!_users.contains(beneficiary)) {\\n        assert(_users.insertUser(beneficiary, sponsor));\\n      }\\n\\n      uint256 package = _getUsdAmount(tokenAmount);\\n      \\n      totalPendingStake += tokenAmount+bonus;\\n\\n      _users.insertStaking(beneficiary, tokenAmount+bonus, bonus, duration);\\n      _users.addPackage(beneficiary, package);\\n      emit stakingBuyed(beneficiary, tokenAmount, bonus, package*10**18, duration);\\n\\n      address payable mySponsor = payable(_users.referral_tree(beneficiary));\\n      if (_users.haveValue(mySponsor)) {\\n        _addReferralBonus(false, beneficiary, mySponsor, package*10**18);\\n      }\\t\\n      _compressionBonus(false, package*10**18, mySponsor, 0, 1);\\n    }\\n\\n    function setStopM() public onlyOwner {\\n      stopM = true;\\n    }\\n\\n    function setRate(uint256 rate) public onlyOwner {\\n      require(rate < 1e11, \\\"support only 10 decimals\\\"); //max token price 99,99 usd\\n      require(rate > 0, \\\"price should be greater than zero\\\");\\n      _rate = rate; //10 decimal\\n      emit priceChanged(rate, block.timestamp);\\n    } \\n\\n    function getAvailableTokenAmount()\\n      public\\n      view\\n      returns(uint256){\\n      return _token.balanceOf(address(this)).sub(totalPendingStake);\\n    }\\n\\n    function setVote(address addr) public onlyOwner {\\n      newAddress = addr;\\n    }\\n    function cancelVote() public onlyOwner {\\n      voteScore = 0;\\n      newAddress = address(0);\\n      voteSuccess = false;\\n      for(uint256 i = 0; i < voteWallets.length; i++) {\\n        votedWallets[voteWallets[i]] = false;\\n      }\\n    }\\n    function vote() public canVote {\\n      require(newAddress.notZero() == true, \\\"No votes at this moment\\\");\\n      voteScore += voteWalletWeight[_msgSender()];\\n      votedWallets[_msgSender()] = true;\\n      if (voteScore >= 360) {\\n        voteSuccess = true;\\n      }\\n    }\\n    function addVoteWallet(address wallet, uint256 weight, uint256 usdAmount, bool needNft) public onlyOwner {\\n      require(addedCanVoteWalletsCount < 200, \\\"No more wallets can be added.\\\");\\n      require(weight < 4, \\\"Weight can be only between 1 and 3\\\");\\n      voteWalletWeight[wallet] = weight;\\n      voteWallets[addedCanVoteWalletsCount] = wallet;\\n      addedCanVoteWalletsCount++;\\n      if (needNft) {\\n        _users.insertNft(wallet, usdAmount);\\n        emit NFTBuyed(wallet, usdAmount);\\n      }\\n    }\\n    function setNewContract(bool newOwnerContracts) public onlyOwner {\\n      if (voteSuccess) {\\n        if (newOwnerContracts) {\\n          _users.transferOwnership(newAddress);\\n          _token.transfer(newAddress, _token.balanceOf(address(this)));\\n        } else {\\n          _token.transfer(newAddress, getAvailableTokenAmount());\\n        }        \\n        voteSuccess = false;\\n        voteScore = 0;\\n        newAddress = address(0);\\n      }\\n    }\\n    function transferNftOwner(address newowner) public {\\n      require(voteWalletWeight[_msgSender()] > 0, \\\"You dont have a vote access\\\");\\n      uint256 weight = voteWalletWeight[_msgSender()];\\n      delete voteWalletWeight[_msgSender()];\\n      for(uint256 i = 0; i < voteWallets.length; i++) {\\n        if (voteWallets[i] == _msgSender()) {\\n          voteWallets[i] = newowner;\\n          voteWalletWeight[newowner] = weight;\\n\\n          _users.deleteNft(_msgSender(), 5000);\\n          _users.insertNft(newowner, 5000);\\n          emit NFTSelled(_msgSender(), 5000);\\n          emit NFTBuyed(newowner, 5000);\\n        }\\n      } \\n    }\\n\\n    function activateReferralLinkByOwner(address sponsor, address referral) public onlyOwner activeSponsor(sponsor) returns(bool) {\\n      _activateReferralLink(sponsor, referral);\\n      return true;\\n    }\\n    function activateReferralLinkByUser(address sponsor) public nonReentrant returns(bool) {\\n      _activateReferralLink(sponsor, _msgSender());\\n      return true;\\n    }\\n    function _activateReferralLink(address sponsor, address referral) internal activeSponsor(sponsor) {\\n      require(_users.contains(referral) == false, \\\"already activate\\\");\\n      assert(_users.insertUser(referral, sponsor));\\n    }\\n    \\n    function withdrawBNB(address payable wallet) public onlyOwner {\\n      uint256 weiAmount = address(this).balance;\\n      wallet.transfer(weiAmount);\\n      emit WithdrawOriginalBNB(_msgSender(), weiAmount);\\n    }\\n\\n    function changeAdminWallet(address payable wallet) public onlyOwner {\\n      require(wallet != address(0), \\\"New admin address is the zero address\\\");\\n      address oldWallet = _owneraddr;\\n      _owneraddr = wallet;\\n      emit AdminWalletChanged(oldWallet, wallet);\\n    }\\n\\n    function changeFeeWallet(address payable wallet) public onlyOwner {\\n      require(wallet != address(0), \\\"New admin address is the zero address\\\");\\n      address oldWallet = _feeaddr;\\n      _feeaddr = wallet;\\n      emit FeeWalletChanged(oldWallet, wallet);\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"usdt\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"firstwallet\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"feeaddr\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"owneraddr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"packageBuy__Failed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"AdminWalletChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"FeeWalletChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"package\",\"type\":\"uint256\"}],\"name\":\"NFTBuyed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"package\",\"type\":\"uint256\"}],\"name\":\"NFTSelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"WithdrawNftProfit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"WithdrawOriginalBNB\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"date\",\"type\":\"uint256\"}],\"name\":\"compressionBonusPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"date\",\"type\":\"uint256\"}],\"name\":\"getWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"date\",\"type\":\"uint256\"}],\"name\":\"priceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"package\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"typeAir\",\"type\":\"uint256\"}],\"name\":\"productBuyed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"date\",\"type\":\"uint256\"}],\"name\":\"referralBonusPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bonusAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"usdAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"stakingBuyed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_feeaddr\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_owneraddr\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_rate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_usdt\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"activateReferralLinkByOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"}],\"name\":\"activateReferralLinkByUser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usdAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"needNft\",\"type\":\"bool\"}],\"name\":\"addVoteWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addedCanVoteWalletsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"usdAmount\",\"type\":\"uint256\"}],\"name\":\"buyNFT\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"usdAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"typeAir\",\"type\":\"uint256\"}],\"name\":\"buyProduct\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"career\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"percentFrom\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"turnoverFrom\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"turnoverTo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"personalFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nft\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"changeAdminWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"changeFeeWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"changeGracePeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"computeAllStakingAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakingAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"computeStakingAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakingAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dataTransfered\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAvailableTokenAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"newOwnerContracts\",\"type\":\"bool\"}],\"name\":\"setNewContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"usdAmount\",\"type\":\"uint256\"}],\"name\":\"setStake\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"setStakeM\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setStopM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopM\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPendingStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalProfitNFT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newowner\",\"type\":\"address\"}],\"name\":\"transferNftOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"voteScore\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"voteSuccess\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"voteWalletWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"voteWallets\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"votedWallets\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"withdrawBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"erctoken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"withdrawFreezeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawNFTProfit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "MoonAir", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000007b2080c3f0bb9f4be77a016145a6921bd763d05900000000000000000000000055d398326f99059ff775485246999027b3197955000000000000000000000000f10f0297c44853c46b41e6a99b7bc6cbdff3e5df0000000000000000000000008cbe4e756dfee5cd8265c536ce56d39439d8dd30000000000000000000000000f777e9a7353c133dad00e4e5aa80e59909df5544", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}