{"SourceCode": "{\"FeeRecipient.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.14;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./Ownable.sol\\\";\\r\\n\\r\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\r\\nlibrary TransferHelper {\\r\\n    function safeApprove(\\r\\n        address token,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        // bytes4(keccak256(bytes(\\u0027approve(address,uint256)\\u0027)));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\r\\n        require(\\r\\n            success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))),\\r\\n            \\u0027TransferHelper::safeApprove: approve failed\\u0027\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeTransfer(\\r\\n        address token,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        // bytes4(keccak256(bytes(\\u0027transfer(address,uint256)\\u0027)));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\r\\n        require(\\r\\n            success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))),\\r\\n            \\u0027TransferHelper::safeTransfer: transfer failed\\u0027\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address token,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        // bytes4(keccak256(bytes(\\u0027transferFrom(address,address,uint256)\\u0027)));\\r\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\r\\n        require(\\r\\n            success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))),\\r\\n            \\u0027TransferHelper::transferFrom: transferFrom failed\\u0027\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeTransferETH(address to, uint256 value) internal {\\r\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\r\\n        require(success, \\u0027TransferHelper::safeTransferETH: ETH transfer failed\\u0027);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract FeeReceiver is Ownable {\\r\\n\\r\\n    // list of all recipients\\r\\n    address[] public recipients;\\r\\n\\r\\n    // maps address to allocation of points\\r\\n    mapping ( address =\\u003e uint256 ) public allocation;\\r\\n\\r\\n    // total points allocated\\r\\n    uint256 public totalAllocation;\\r\\n\\r\\n    function withdraw(address token, address to, uint256 amount) external onlyOwner {\\r\\n        TransferHelper.safeTransfer(token, to, amount);\\r\\n    }\\r\\n\\r\\n    function withdrawETH(address to, uint256 amount) external onlyOwner {\\r\\n        _sendETH(to, amount);\\r\\n    }\\r\\n\\r\\n    function addRecipient(address newRecipient, uint256 newAllocation) external onlyOwner {\\r\\n        require(\\r\\n            allocation[newRecipient] == 0,\\r\\n            \\u0027Already Added\\u0027\\r\\n        );\\r\\n\\r\\n        // add to list\\r\\n        recipients.push(newRecipient);\\r\\n\\r\\n        // set allocation and increase total allocation\\r\\n        allocation[newRecipient] = newAllocation;\\r\\n        unchecked {\\r\\n            totalAllocation += newAllocation;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function removeRecipient(address recipient) external onlyOwner {\\r\\n\\r\\n        // ensure recipient is in the system\\r\\n        uint256 allocation_ = allocation[recipient];\\r\\n        require(\\r\\n            allocation_ \\u003e 0,\\r\\n            \\u0027User Not Present\\u0027\\r\\n        );\\r\\n\\r\\n        // delete allocation, subtract from total allocation\\r\\n        delete allocation[recipient];\\r\\n        unchecked {\\r\\n            totalAllocation -= allocation_;\\r\\n        }\\r\\n\\r\\n        // remove address from array\\r\\n        uint index = recipients.length;\\r\\n        for (uint i = 0; i \\u003c recipients.length;) {\\r\\n            if (recipients[i] == recipient) {\\r\\n                index = i;\\r\\n                break;\\r\\n            }\\r\\n            unchecked { ++i; }\\r\\n        }\\r\\n        require(\\r\\n            index \\u003c recipients.length,\\r\\n            \\u0027Recipient Not Found\\u0027\\r\\n        );\\r\\n\\r\\n        // swap positions with last element then pop last element off\\r\\n        recipients[index] = recipients[recipients.length - 1];\\r\\n        recipients.pop();\\r\\n    }\\r\\n\\r\\n    function setAllocation(address recipient, uint256 newAllocation) external onlyOwner {\\r\\n\\r\\n        // ensure recipient is in the system\\r\\n        uint256 allocation_ = allocation[recipient];\\r\\n        require(\\r\\n            allocation_ \\u003e 0,\\r\\n            \\u0027User Not Present\\u0027\\r\\n        );\\r\\n\\r\\n        // adjust their allocation and the total allocation\\r\\n        allocation[recipient] = ( allocation[recipient] + newAllocation ) - allocation_;\\r\\n        totalAllocation = ( totalAllocation + newAllocation ) - allocation_;\\r\\n    }\\r\\n\\r\\n\\r\\n    function triggerToken(address token) external onlyOwner {\\r\\n\\r\\n        // get balance of token\\r\\n        uint256 amount = IERC20(token).balanceOf(address(this));\\r\\n        require(\\r\\n            amount \\u003e 0,\\r\\n            \\u0027Zero Amount\\u0027\\r\\n        );\\r\\n\\r\\n        // split balance into distributions\\r\\n        uint256[] memory distributions = splitAmount(amount);\\r\\n\\r\\n        // transfer distributions to each recipient\\r\\n        uint len = distributions.length;\\r\\n        for (uint i = 0; i \\u003c len;) {\\r\\n            _send(token, recipients[i], distributions[i]);\\r\\n            unchecked { ++i; }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function triggerETH() external onlyOwner {\\r\\n\\r\\n        // Ensure an ETH balance\\r\\n        require(\\r\\n            address(this).balance \\u003e 0,\\r\\n            \\u0027Zero Amount\\u0027\\r\\n        );\\r\\n\\r\\n        // split balance into distributions\\r\\n        uint256[] memory distributions = splitAmount(address(this).balance);\\r\\n\\r\\n        // transfer distributions to each recipient\\r\\n        uint len = distributions.length;\\r\\n        for (uint i = 0; i \\u003c len;) {\\r\\n            _sendETH(recipients[i], distributions[i]);\\r\\n            unchecked { ++i; }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _sendETH(address to, uint amount) internal {\\r\\n        TransferHelper.safeTransferETH(to, amount);\\r\\n    }\\r\\n\\r\\n    function _send(address token, address to, uint256 amount) internal {\\r\\n        if (to == address(0) || amount == 0) {\\r\\n            return;\\r\\n        }\\r\\n        if (token == address(0)) {\\r\\n            _sendETH(to, amount);\\r\\n        } else {\\r\\n            TransferHelper.safeTransfer(token, to, amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getRecipients() external view returns (address[] memory) {\\r\\n        return recipients;\\r\\n    }\\r\\n\\r\\n    function splitAmount(uint256 amount) public view returns (uint256[] memory distributions) {\\r\\n\\r\\n        // length of recipient list\\r\\n        uint256 len = recipients.length;\\r\\n        distributions = new uint256[](len);\\r\\n\\r\\n        // loop through recipients, setting their allocations\\r\\n        for (uint i = 0; i \\u003c len;) {\\r\\n            distributions[i] = ( ( amount * allocation[recipients[i]] ) / totalAllocation ) - 1;\\r\\n            unchecked { ++i; }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n}\"},\"IERC20.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.14;\\r\\n\\r\\ninterface IERC20 {\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    \\r\\n    function symbol() external view returns(string memory);\\r\\n    \\r\\n    function name() external view returns(string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    \\r\\n    /**\\r\\n     * @dev Returns the number of decimal places\\r\\n     */\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity 0.8.14;\\r\\n\\r\\n/**\\r\\n * @title Owner\\r\\n * @dev Set \\u0026 change owner\\r\\n */\\r\\ncontract Ownable {\\r\\n\\r\\n    address private owner;\\r\\n    \\r\\n    // event for EVM logging\\r\\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\\r\\n    \\r\\n    // modifier to check if caller is owner\\r\\n    modifier onlyOwner() {\\r\\n        // If the first argument of \\u0027require\\u0027 evaluates to \\u0027false\\u0027, execution terminates and all\\r\\n        // changes to the state and to Ether balances are reverted.\\r\\n        // This used to consume all gas in old EVM versions, but not anymore.\\r\\n        // It is often a good idea to use \\u0027require\\u0027 to check if functions are called correctly.\\r\\n        // As a second argument, you can also provide an explanation about what went wrong.\\r\\n        require(msg.sender == owner, \\\"Caller is not owner\\\");\\r\\n        _;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Set contract deployer as owner\\r\\n     */\\r\\n    constructor() {\\r\\n        owner = msg.sender; // \\u0027msg.sender\\u0027 is sender of current call, contract deployer for a constructor\\r\\n        emit OwnerSet(address(0), owner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Change owner\\r\\n     * @param newOwner address of new owner\\r\\n     */\\r\\n    function changeOwner(address newOwner) public onlyOwner {\\r\\n        emit OwnerSet(owner, newOwner);\\r\\n        owner = newOwner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return owner address \\r\\n     * @return address of owner\\r\\n     */\\r\\n    function getOwner() external view returns (address) {\\r\\n        return owner;\\r\\n    }\\r\\n}\"}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerSet\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRecipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newAllocation\",\"type\":\"uint256\"}],\"name\":\"addRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allocation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRecipients\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"recipients\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"removeRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newAllocation\",\"type\":\"uint256\"}],\"name\":\"setAllocation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"splitAmount\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"distributions\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAllocation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"triggerETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"triggerToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "FeeReceiver", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://82492b06f9c16716a4da7a51d1da1180cf437c0e2462e08d1fce29ccf306ad31"}