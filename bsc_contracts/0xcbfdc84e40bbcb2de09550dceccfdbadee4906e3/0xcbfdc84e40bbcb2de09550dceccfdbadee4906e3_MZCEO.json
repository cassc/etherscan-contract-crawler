{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/bsc/MZCEO.sol\": {\r\n      \"content\": \"    // SPDX-License-Identifier: MIT\\n\\n    pragma solidity ^0.8.19;\\n\\n    abstract contract Context {\\n        function _msgSender() internal view virtual returns (address) {\\n            return msg.sender;\\n        }\\n\\n        function _msgData() internal view virtual returns (bytes calldata) {\\n            return msg.data;\\n        }\\n    }\\n\\n    abstract contract Ownable is Context {\\n        address private _owner;\\n\\n        event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n        constructor() {\\n            _transferOwnership(_msgSender());\\n        }\\n\\n        function owner() public view virtual returns (address) {\\n            return _owner;\\n        }\\n\\n        modifier onlyOwner() {\\n            require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n            _;\\n        }\\n\\n        function renounceOwnership() public virtual onlyOwner {\\n            _transferOwnership(address(0));\\n        }\\n\\n        function transferOwnership(address newOwner) public virtual onlyOwner {\\n            require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n            _transferOwnership(newOwner);\\n        }\\n\\n        function _transferOwnership(address newOwner) internal virtual {\\n            address oldOwner = _owner;\\n            _owner = newOwner;\\n            emit OwnershipTransferred(oldOwner, newOwner);\\n        }\\n    }\\n\\n    library SafeMath {\\n        function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n            uint256 c = a + b;\\n            require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n            return c;\\n        }\\n\\n        function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n            return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n        }\\n\\n        function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n            require(b <= a, errorMessage);\\n            uint256 c = a - b;\\n\\n            return c;\\n        }\\n\\n        function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n            if (a == 0) {\\n                return 0;\\n            }\\n\\n            uint256 c = a * b;\\n            require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n            return c;\\n        }\\n\\n        function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n            return div(a, b, \\\"SafeMath: division by zero\\\");\\n        }\\n\\n        function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n            require(b > 0, errorMessage);\\n            uint256 c = a / b;\\n            // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n            return c;\\n        }\\n\\n        function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n            return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n        }\\n\\n        function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n            require(b != 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n\\n    library SafeMathInt {\\n        int256 private constant MIN_INT256 = int256(1) << 255;\\n        int256 private constant MAX_INT256 = ~(int256(1) << 255);\\n\\n        function mul(int256 a, int256 b) internal pure returns (int256) {\\n            int256 c = a * b;\\n\\n            // Detect overflow when multiplying MIN_INT256 with -1\\n            require(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));\\n            require((b == 0) || (c / b == a));\\n            return c;\\n        }\\n        function div(int256 a, int256 b) internal pure returns (int256) {\\n            // Prevent overflow when dividing MIN_INT256 by -1\\n            require(b != -1 || a != MIN_INT256);\\n\\n            // Solidity already throws when dividing by 0.\\n            return a / b;\\n        }\\n        function sub(int256 a, int256 b) internal pure returns (int256) {\\n            int256 c = a - b;\\n            require((b >= 0 && c <= a) || (b < 0 && c > a));\\n            return c;\\n        }\\n        function add(int256 a, int256 b) internal pure returns (int256) {\\n            int256 c = a + b;\\n            require((b >= 0 && c >= a) || (b < 0 && c < a));\\n            return c;\\n        }\\n        function abs(int256 a) internal pure returns (int256) {\\n            require(a != MIN_INT256);\\n            return a < 0 ? -a : a;\\n        }\\n        function toUint256Safe(int256 a) internal pure returns (uint256) {\\n            require(a >= 0);\\n            return uint256(a);\\n        }\\n    }\\n\\n    library SafeMathUint {\\n        function toInt256Safe(uint256 a) internal pure returns (int256) {\\n            int256 b = int256(a);\\n            require(b >= 0);\\n            return b;\\n        }\\n    }\\n\\n    library IterableMapping {\\n        struct Map {\\n            address[] keys;\\n            mapping(address => uint) values;\\n            mapping(address => uint) indexOf;\\n            mapping(address => bool) inserted;\\n        }\\n\\n        function get(Map storage map, address key) public view returns (uint) {\\n            return map.values[key];\\n        }\\n\\n        function getIndexOfKey(Map storage map, address key) public view returns (int) {\\n            if(!map.inserted[key]) {\\n                return -1;\\n            }\\n            return int(map.indexOf[key]);\\n        }\\n\\n        function getKeyAtIndex(Map storage map, uint index) public view returns (address) {\\n            return map.keys[index];\\n        }\\n\\n        function size(Map storage map) public view returns (uint) {\\n            return map.keys.length;\\n        }\\n\\n        function set(Map storage map, address key, uint val) public {\\n            if (map.inserted[key]) {\\n                map.values[key] = val;\\n            } else {\\n                map.inserted[key] = true;\\n                map.values[key] = val;\\n                map.indexOf[key] = map.keys.length;\\n                map.keys.push(key);\\n            }\\n        }\\n\\n        function remove(Map storage map, address key) public {\\n            if (!map.inserted[key]) {\\n                return;\\n            }\\n\\n            delete map.inserted[key];\\n            delete map.values[key];\\n\\n            uint index = map.indexOf[key];\\n            uint lastIndex = map.keys.length - 1;\\n            address lastKey = map.keys[lastIndex];\\n\\n            map.indexOf[lastKey] = index;\\n            delete map.indexOf[key];\\n\\n            map.keys[index] = lastKey;\\n            map.keys.pop();\\n        }\\n    }\\n\\n    interface IUniswapV2Factory {\\n        event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n        function feeTo() external view returns (address);\\n        function feeToSetter() external view returns (address);\\n        function getPair(address tokenA, address tokenB) external view returns (address pair);\\n        function allPairs(uint) external view returns (address pair);\\n        function allPairsLength() external view returns (uint);\\n        function createPair(address tokenA, address tokenB) external returns (address pair);\\n        function setFeeTo(address) external;\\n        function setFeeToSetter(address) external;\\n    }\\n\\n    interface IUniswapV2Pair {\\n        event Approval(address indexed owner, address indexed spender, uint value);\\n        event Transfer(address indexed from, address indexed to, uint value);\\n\\n        function name() external pure returns (string memory);\\n        function symbol() external pure returns (string memory);\\n        function decimals() external pure returns (uint8);\\n        function totalSupply() external view returns (uint);\\n        function balanceOf(address owner) external view returns (uint);\\n        function allowance(address owner, address spender) external view returns (uint);\\n\\n        function approve(address spender, uint value) external returns (bool);\\n        function transfer(address to, uint value) external returns (bool);\\n        function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n        function DOMAIN_SEPARATOR() external view returns (bytes32);\\n        function PERMIT_TYPEHASH() external pure returns (bytes32);\\n        function nonces(address owner) external view returns (uint);\\n\\n        function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n        event Mint(address indexed sender, uint amount0, uint amount1);\\n        event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n        event Swap(\\n            address indexed sender,\\n            uint amount0In,\\n            uint amount1In,\\n            uint amount0Out,\\n            uint amount1Out,\\n            address indexed to\\n        );\\n        event Sync(uint112 reserve0, uint112 reserve1);\\n\\n        function MINIMUM_LIQUIDITY() external pure returns (uint);\\n        function factory() external view returns (address);\\n        function token0() external view returns (address);\\n        function token1() external view returns (address);\\n        function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n        function price0CumulativeLast() external view returns (uint);\\n        function price1CumulativeLast() external view returns (uint);\\n        function kLast() external view returns (uint);\\n\\n        function mint(address to) external returns (uint liquidity);\\n        function burn(address to) external returns (uint amount0, uint amount1);\\n        function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n        function skim(address to) external;\\n        function sync() external;\\n\\n        function initialize(address, address) external;\\n    }\\n\\n    interface IUniswapV2Router01 {\\n        function factory() external pure returns (address);\\n        function WETH() external pure returns (address);\\n\\n        function addLiquidity(\\n            address tokenA,\\n            address tokenB,\\n            uint amountADesired,\\n            uint amountBDesired,\\n            uint amountAMin,\\n            uint amountBMin,\\n            address to,\\n            uint deadline\\n        ) external returns (uint amountA, uint amountB, uint liquidity);\\n        function addLiquidityETH(\\n            address token,\\n            uint amountTokenDesired,\\n            uint amountTokenMin,\\n            uint amountETHMin,\\n            address to,\\n            uint deadline\\n        ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n        function removeLiquidity(\\n            address tokenA,\\n            address tokenB,\\n            uint liquidity,\\n            uint amountAMin,\\n            uint amountBMin,\\n            address to,\\n            uint deadline\\n        ) external returns (uint amountA, uint amountB);\\n        function removeLiquidityETH(\\n            address token,\\n            uint liquidity,\\n            uint amountTokenMin,\\n            uint amountETHMin,\\n            address to,\\n            uint deadline\\n        ) external returns (uint amountToken, uint amountETH);\\n        function removeLiquidityWithPermit(\\n            address tokenA,\\n            address tokenB,\\n            uint liquidity,\\n            uint amountAMin,\\n            uint amountBMin,\\n            address to,\\n            uint deadline,\\n            bool approveMax, uint8 v, bytes32 r, bytes32 s\\n        ) external returns (uint amountA, uint amountB);\\n        function removeLiquidityETHWithPermit(\\n            address token,\\n            uint liquidity,\\n            uint amountTokenMin,\\n            uint amountETHMin,\\n            address to,\\n            uint deadline,\\n            bool approveMax, uint8 v, bytes32 r, bytes32 s\\n        ) external returns (uint amountToken, uint amountETH);\\n        function swapExactTokensForTokens(\\n            uint amountIn,\\n            uint amountOutMin,\\n            address[] calldata path,\\n            address to,\\n            uint deadline\\n        ) external returns (uint[] memory amounts);\\n        function swapTokensForExactTokens(\\n            uint amountOut,\\n            uint amountInMax,\\n            address[] calldata path,\\n            address to,\\n            uint deadline\\n        ) external returns (uint[] memory amounts);\\n        function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n            external\\n            payable\\n            returns (uint[] memory amounts);\\n        function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n            external\\n            returns (uint[] memory amounts);\\n        function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n            external\\n            returns (uint[] memory amounts);\\n        function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n            external\\n            payable\\n            returns (uint[] memory amounts);\\n\\n        function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n        function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n        function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n        function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n        function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n    }\\n\\n    interface IUniswapV2Router02 is IUniswapV2Router01 {\\n        function removeLiquidityETHSupportingFeeOnTransferTokens(\\n            address token,\\n            uint liquidity,\\n            uint amountTokenMin,\\n            uint amountETHMin,\\n            address to,\\n            uint deadline\\n        ) external returns (uint amountETH);\\n        function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n            address token,\\n            uint liquidity,\\n            uint amountTokenMin,\\n            uint amountETHMin,\\n            address to,\\n            uint deadline,\\n            bool approveMax, uint8 v, bytes32 r, bytes32 s\\n        ) external returns (uint amountETH);\\n\\n        function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n            uint amountIn,\\n            uint amountOutMin,\\n            address[] calldata path,\\n            address to,\\n            uint deadline\\n        ) external;\\n        function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n            uint amountOutMin,\\n            address[] calldata path,\\n            address to,\\n            uint deadline\\n        ) external payable;\\n        function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            uint amountIn,\\n            uint amountOutMin,\\n            address[] calldata path,\\n            address to,\\n            uint deadline\\n        ) external;\\n    }\\n\\n    interface IERC20 {\\n        function totalSupply() external view returns (uint256);\\n        function balanceOf(address who) external view returns (uint256);\\n        function allowance(address owner, address spender) external view returns (uint256);\\n        function transfer(address to, uint256 value) external returns (bool);\\n        function approve(address spender, uint256 value) external returns (bool);\\n        function transferFrom(address from, address to, uint256 value) external returns (bool);\\n\\n        event Transfer(address indexed from, address indexed to, uint256 value);\\n        event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    }\\n\\n    interface IERC20Metadata is IERC20 {\\n        function name() external view returns (string memory);\\n        function symbol() external view returns (string memory);\\n        function decimals() external view returns (uint8);\\n    }\\n\\n    contract ERC20 is Context, IERC20, IERC20Metadata {\\n        using SafeMath for uint256;\\n\\n        mapping(address => uint256) private _balances;\\n        mapping(address => mapping(address => uint256)) private _allowances;\\n\\n        uint256 private _totalSupply;\\n        string private _name;\\n        string private _symbol;\\n\\n        constructor(string memory name_, string memory symbol_) {\\n            _name = name_;\\n            _symbol = symbol_;\\n        }\\n\\n        function name() public view virtual override returns (string memory) {\\n            return _name;\\n        }\\n\\n        function symbol() public view virtual override returns (string memory) {\\n            return _symbol;\\n        }\\n\\n        function decimals() public view virtual override returns (uint8) {\\n            return 9;\\n        }\\n\\n        function totalSupply() public view virtual override returns (uint256) {\\n            return _totalSupply;\\n        }\\n\\n        function balanceOf(address account) public view virtual override returns (uint256) {\\n            return _balances[account];\\n        }\\n\\n        function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n            _transfer(_msgSender(), recipient, amount);\\n            return true;\\n        }\\n\\n        function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n            return _allowances[owner][spender];\\n        }\\n\\n        function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n            _approve(_msgSender(), spender, amount);\\n            return true;\\n        }\\n\\n        function transferFrom(\\n            address sender,\\n            address recipient,\\n            uint256 amount\\n        ) public virtual override returns (bool) {\\n            _transfer(sender, recipient, amount);\\n            _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n            return true;\\n        }\\n\\n        function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n            _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n            return true;\\n        }\\n\\n        function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n            _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n            return true;\\n        }\\n\\n        function _transfer(\\n            address sender,\\n            address recipient,\\n            uint256 amount\\n        ) internal virtual {\\n            require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n            require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n            _beforeTokenTransfer(sender, recipient, amount);\\n            _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n            _balances[recipient] = _balances[recipient].add(amount);\\n            emit Transfer(sender, recipient, amount);\\n        }\\n\\n        function _mint(address account, uint256 amount) internal virtual {\\n            require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n            _beforeTokenTransfer(address(0), account, amount);\\n            _totalSupply = _totalSupply.add(amount);\\n            _balances[account] = _balances[account].add(amount);\\n            emit Transfer(address(0), account, amount);\\n        }\\n\\n        function _burn(address account, uint256 amount) internal virtual {\\n            require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n            _beforeTokenTransfer(account, address(0), amount);\\n            _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n            _totalSupply = _totalSupply.sub(amount);\\n            emit Transfer(account, address(0), amount);\\n        }\\n\\n        function _approve(\\n            address owner,\\n            address spender,\\n            uint256 amount\\n        ) internal virtual {\\n            require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n            require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n            _allowances[owner][spender] = amount;\\n            emit Approval(owner, spender, amount);\\n        }\\n\\n        function _beforeTokenTransfer(\\n            address from,\\n            address to,\\n            uint256 amount\\n        ) internal virtual {}\\n    }\\n\\n    interface DividendPayingTokenInterface {\\n        function dividendOf(address _owner) external view returns(uint256);\\n        function withdrawDividend() external;\\n    \\n        event DividendsDistributed(\\n            address indexed from,\\n            uint256 weiAmount\\n        );\\n        event DividendWithdrawn(\\n            address indexed to,\\n            uint256 weiAmount\\n        );\\n    }\\n\\n    interface DividendPayingTokenOptionalInterface {\\n        function withdrawableDividendOf(address _owner) external view returns(uint256);\\n        function withdrawnDividendOf(address _owner) external view returns(uint256);\\n        function accumulativeDividendOf(address _owner) external view returns(uint256);\\n    }\\n\\n    contract DividendPayingToken is ERC20, Ownable, DividendPayingTokenInterface, DividendPayingTokenOptionalInterface {\\n        using SafeMath for uint256;\\n        using SafeMathUint for uint256;\\n        using SafeMathInt for int256;\\n\\n        uint256 constant internal magnitude = 2**128;\\n        uint256 internal magnifiedDividendPerShare;\\n        uint256 public totalDividendsDistributed;\\n        \\n        address public immutable rewardToken;\\n        \\n        mapping(address => int256) internal magnifiedDividendCorrections;\\n        mapping(address => uint256) internal withdrawnDividends;\\n\\n        constructor(string memory _name, string memory _symbol, address _rewardToken) ERC20(_name, _symbol) { \\n            rewardToken = _rewardToken;\\n        }\\n\\n        function distributeDividends(uint256 amount) public onlyOwner{\\n            require(totalSupply() > 0);\\n\\n            if (amount > 0) {\\n                magnifiedDividendPerShare = magnifiedDividendPerShare.add(\\n                    (amount).mul(magnitude) / totalSupply()\\n                );\\n                emit DividendsDistributed(msg.sender, amount);\\n\\n                totalDividendsDistributed = totalDividendsDistributed.add(amount);\\n            }\\n        }\\n\\n        function withdrawDividend() public virtual override {\\n            _withdrawDividendOfUser(payable(msg.sender));\\n        }\\n\\n        function _withdrawDividendOfUser(address payable user) internal returns (uint256) {\\n            uint256 _withdrawableDividend = withdrawableDividendOf(user);\\n            if (_withdrawableDividend > 0) {\\n                withdrawnDividends[user] = withdrawnDividends[user].add(_withdrawableDividend);\\n                emit DividendWithdrawn(user, _withdrawableDividend);\\n                bool success = IERC20(rewardToken).transfer(user, _withdrawableDividend);\\n\\n                if(!success) {\\n                    withdrawnDividends[user] = withdrawnDividends[user].sub(_withdrawableDividend);\\n                    return 0;\\n                }\\n\\n                return _withdrawableDividend;\\n            }\\n            return 0;\\n        }\\n\\n        function dividendOf(address _owner) public view override returns(uint256) {\\n            return withdrawableDividendOf(_owner);\\n        }\\n\\n        function withdrawableDividendOf(address _owner) public view override returns(uint256) {\\n            return accumulativeDividendOf(_owner).sub(withdrawnDividends[_owner]);\\n        }\\n\\n        function withdrawnDividendOf(address _owner) public view override returns(uint256) {\\n            return withdrawnDividends[_owner];\\n        }\\n\\n        function accumulativeDividendOf(address _owner) public view override returns(uint256) {\\n            return magnifiedDividendPerShare.mul(balanceOf(_owner)).toInt256Safe()\\n            .add(magnifiedDividendCorrections[_owner]).toUint256Safe() / magnitude;\\n        }\\n\\n        function _transfer(address from, address to, uint256 value) internal virtual override {\\n            require(false);\\n\\n            int256 _magCorrection = magnifiedDividendPerShare.mul(value).toInt256Safe();\\n            magnifiedDividendCorrections[from] = magnifiedDividendCorrections[from].add(_magCorrection);\\n            magnifiedDividendCorrections[to] = magnifiedDividendCorrections[to].sub(_magCorrection);\\n        }\\n\\n        function _mint(address account, uint256 value) internal override {\\n            super._mint(account, value);\\n\\n            magnifiedDividendCorrections[account] = magnifiedDividendCorrections[account]\\n            .sub( (magnifiedDividendPerShare.mul(value)).toInt256Safe() );\\n        }\\n\\n        function _burn(address account, uint256 value) internal override {\\n            super._burn(account, value);\\n\\n            magnifiedDividendCorrections[account] = magnifiedDividendCorrections[account]\\n            .add( (magnifiedDividendPerShare.mul(value)).toInt256Safe() );\\n        }\\n\\n        function _setBalance(address account, uint256 newBalance) internal {\\n            uint256 currentBalance = balanceOf(account);\\n\\n            if(newBalance > currentBalance) {\\n                uint256 mintAmount = newBalance.sub(currentBalance);\\n                _mint(account, mintAmount);\\n            } else if(newBalance < currentBalance) {\\n                uint256 burnAmount = currentBalance.sub(newBalance);\\n                _burn(account, burnAmount);\\n            }\\n        }\\n    }\\n\\n    contract DividendTracker is Ownable, DividendPayingToken {\\n        using SafeMath for uint256;\\n        using SafeMathInt for int256;\\n        using IterableMapping for IterableMapping.Map;\\n\\n        IterableMapping.Map private tokenHoldersMap;\\n        uint256 public lastProcessedIndex;\\n\\n        mapping (address => bool) public excludedFromDividends;\\n        mapping (address => uint256) public lastClaimTimes;\\n\\n        uint256 public claimWait;\\n        uint256 public minimumTokenBalanceForDividends;\\n\\n        event ExcludeFromDividends(address indexed account);\\n        event ClaimWaitUpdated(uint256 indexed newValue, uint256 indexed oldValue);\\n\\n        event Claim(address indexed account, uint256 amount, bool indexed automatic);\\n\\n        constructor(uint256 minBalance, address _rewardToken) DividendPayingToken(\\\"Reward Tracker\\\", \\\"DividendTracker\\\", _rewardToken) {\\n            claimWait = 3600;\\n            minimumTokenBalanceForDividends = minBalance * 10 ** 9;\\n        }\\n\\n        function _transfer(address, address, uint256) internal pure override {\\n            require(false, \\\"No transfers allowed\\\");\\n        }\\n\\n        function withdrawDividend() public pure override {\\n            require(false, \\\"withdrawDividend disabled. Use the 'claim' function on the main contract.\\\");\\n        }\\n\\n        function updateMinimumTokenBalanceForDividends(uint256 _newMinimumBalance) external onlyOwner {\\n            require(_newMinimumBalance != minimumTokenBalanceForDividends, \\\"New mimimum balance for dividend cannot be same as current minimum balance\\\");\\n            minimumTokenBalanceForDividends = _newMinimumBalance;\\n        }\\n\\n        function excludeFromDividends(address account) external onlyOwner {\\n            require(!excludedFromDividends[account]);\\n            excludedFromDividends[account] = true;\\n\\n            _setBalance(account, 0);\\n            tokenHoldersMap.remove(account);\\n\\n            emit ExcludeFromDividends(account);\\n        }\\n\\n        function updateClaimWait(uint256 newClaimWait) external onlyOwner {\\n            require(newClaimWait >= 3_600 && newClaimWait <= 86_400, \\\"claimWait must be updated to between 1 and 24 hours\\\");\\n            require(newClaimWait != claimWait, \\\"Cannot update claimWait to same value\\\");\\n            emit ClaimWaitUpdated(newClaimWait, claimWait);\\n            claimWait = newClaimWait;\\n        }\\n\\n        function setLastProcessedIndex(uint256 index) external onlyOwner {\\n            lastProcessedIndex = index;\\n        }\\n\\n        function getLastProcessedIndex() external view returns(uint256) {\\n            return lastProcessedIndex;\\n        }\\n\\n        function getNumberOfTokenHolders() external view returns(uint256) {\\n            return tokenHoldersMap.keys.length;\\n        }\\n\\n        function getAccount(address _account)\\n            public view returns (\\n                address account,\\n                int256 index,\\n                int256 iterationsUntilProcessed,\\n                uint256 withdrawableDividends,\\n                uint256 totalDividends,\\n                uint256 lastClaimTime,\\n                uint256 nextClaimTime,\\n                uint256 secondsUntilAutoClaimAvailable) {\\n            account = _account;\\n\\n            index = tokenHoldersMap.getIndexOfKey(account);\\n\\n            iterationsUntilProcessed = -1;\\n\\n            if(index >= 0) {\\n                if(uint256(index) > lastProcessedIndex) {\\n                    iterationsUntilProcessed = index.sub(int256(lastProcessedIndex));\\n                }\\n                else {\\n                    uint256 processesUntilEndOfArray = tokenHoldersMap.keys.length > lastProcessedIndex ?\\n                                                            tokenHoldersMap.keys.length.sub(lastProcessedIndex) :\\n                                                            0;\\n\\n\\n                    iterationsUntilProcessed = index.add(int256(processesUntilEndOfArray));\\n                }\\n            }\\n\\n\\n            withdrawableDividends = withdrawableDividendOf(account);\\n            totalDividends = accumulativeDividendOf(account);\\n\\n            lastClaimTime = lastClaimTimes[account];\\n\\n            nextClaimTime = lastClaimTime > 0 ?\\n                                        lastClaimTime.add(claimWait) :\\n                                        0;\\n\\n            secondsUntilAutoClaimAvailable = nextClaimTime > block.timestamp ?\\n                                                        nextClaimTime.sub(block.timestamp) :\\n                                                        0;\\n        }\\n\\n        function getAccountAtIndex(uint256 index)\\n            public view returns (\\n                address,\\n                int256,\\n                int256,\\n                uint256,\\n                uint256,\\n                uint256,\\n                uint256,\\n                uint256) {\\n            if(index >= tokenHoldersMap.size()) {\\n                return (0x0000000000000000000000000000000000000000, -1, -1, 0, 0, 0, 0, 0);\\n            }\\n\\n            address account = tokenHoldersMap.getKeyAtIndex(index);\\n\\n            return getAccount(account);\\n        }\\n\\n        function canAutoClaim(uint256 lastClaimTime) private view returns (bool) {\\n            if(lastClaimTime > block.timestamp)  {\\n                return false;\\n            }\\n\\n            return block.timestamp.sub(lastClaimTime) >= claimWait;\\n        }\\n\\n        function setBalance(address payable account, uint256 newBalance) external onlyOwner {\\n            if(excludedFromDividends[account]) {\\n                return;\\n            }\\n\\n            if(newBalance >= minimumTokenBalanceForDividends) {\\n                _setBalance(account, newBalance);\\n                tokenHoldersMap.set(account, newBalance);\\n            }\\n            else {\\n                _setBalance(account, 0);\\n                tokenHoldersMap.remove(account);\\n            }\\n\\n            processAccount(account, true);\\n        }\\n\\n        function process(uint256 gas) public returns (uint256, uint256, uint256) {\\n            uint256 numberOfTokenHolders = tokenHoldersMap.keys.length;\\n\\n            if(numberOfTokenHolders == 0) {\\n                return (0, 0, lastProcessedIndex);\\n            }\\n\\n            uint256 _lastProcessedIndex = lastProcessedIndex;\\n\\n            uint256 gasUsed = 0;\\n\\n            uint256 gasLeft = gasleft();\\n\\n            uint256 iterations = 0;\\n            uint256 claims = 0;\\n\\n            while(gasUsed < gas && iterations < numberOfTokenHolders) {\\n                _lastProcessedIndex++;\\n\\n                if(_lastProcessedIndex >= tokenHoldersMap.keys.length) {\\n                    _lastProcessedIndex = 0;\\n                }\\n\\n                address account = tokenHoldersMap.keys[_lastProcessedIndex];\\n\\n                if(canAutoClaim(lastClaimTimes[account])) {\\n                    if(processAccount(payable(account), true)) {\\n                        claims++;\\n                    }\\n                }\\n\\n                iterations++;\\n\\n                uint256 newGasLeft = gasleft();\\n\\n                if(gasLeft > newGasLeft) {\\n                    gasUsed = gasUsed.add(gasLeft.sub(newGasLeft));\\n                }\\n\\n                gasLeft = newGasLeft;\\n            }\\n\\n            lastProcessedIndex = _lastProcessedIndex;\\n\\n            return (iterations, claims, lastProcessedIndex);\\n        }\\n\\n        function processAccount(address payable account, bool automatic) public onlyOwner returns (bool) {\\n            uint256 amount = _withdrawDividendOfUser(account);\\n\\n            if(amount > 0) {\\n                lastClaimTimes[account] = block.timestamp;\\n                emit Claim(account, amount, automatic);\\n                return true;\\n            }\\n\\n            return false;\\n        }\\n    }\\n\\n    contract MZCEO is ERC20, Ownable {\\n        uint256 public burnFeeOnBuy;\\n        uint256 public marketingFeeOnBuy;\\n        uint256 public rewardsFeeOnBuy;\\n\\n        uint256 private totalBuyFee;\\n\\n        uint256 public burnFeeOnSell;\\n        uint256 public marketingFeeOnSell;\\n        uint256 public rewardsFeeOnSell;\\n\\n        uint256 private totalSellFee;\\n\\n        address public marketingWallet;\\n\\n        IUniswapV2Router02 public uniswapV2Router;\\n        address public  uniswapV2Pair;\\n        \\n        address private constant DEAD = 0x000000000000000000000000000000000000dEaD;\\n\\n        bool    private swapping;\\n        uint256 public swapTokensAtAmount;\\n\\n        mapping (address => bool) private _isExcludedFromFees;\\n        mapping (address => bool) public automatedMarketMakerPairs;\\n\\n        DividendTracker public dividendTracker;\\n        address public immutable rewardToken;\\n        uint256 public gasForProcessing = 300_000;\\n\\n        event ExcludeFromFees(address indexed account, bool isExcluded);\\n        event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\\n\\n        event SendMarketing(uint256 bnbSend);\\n        event UpdateUniswapV2Router(address indexed newAddress, address indexed oldAddress);\\n        event UpdateDividendTracker(address indexed newAddress, address indexed oldAddress);\\n        event GasForProcessingUpdated(uint256 indexed newValue, uint256 indexed oldValue);\\n        event SendDividends(uint256 amount);\\n        event ProcessedDividendTracker(\\n            uint256 iterations,\\n            uint256 claims,\\n            uint256 lastProcessedIndex,\\n            bool indexed automatic,\\n            uint256 gas,\\n            address indexed processor\\n        );\\n\\n        constructor() payable ERC20(\\\"Mark Zuckerberg CEO\\\", \\\"MZCEO\\\") {\\n\\n            rewardToken = 0x55d398326f99059fF775485246999027B3197955; // USDT\\n\\n            burnFeeOnBuy        = 2;\\n            marketingFeeOnBuy    = 4;\\n            rewardsFeeOnBuy     = 4;\\n\\n            totalBuyFee         = burnFeeOnBuy + marketingFeeOnBuy + rewardsFeeOnBuy;\\n\\n            burnFeeOnSell       = 2;\\n            marketingFeeOnSell   = 4;\\n            rewardsFeeOnSell    = 4;\\n\\n            totalSellFee        = burnFeeOnSell + marketingFeeOnSell + rewardsFeeOnSell;\\n\\n            marketingWallet = 0xFd178F26F401e26550EFbF31936F41D873c4fFa4;\\n\\n            dividendTracker = new DividendTracker(420 * 10**5, rewardToken);\\n\\n            IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E); // PCS Mainnet\\n            address _uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\\n                .createPair(address(this), _uniswapV2Router.WETH());\\n\\n            uniswapV2Router = _uniswapV2Router;\\n            uniswapV2Pair   = _uniswapV2Pair;\\n\\n            _approve(address(this), address(uniswapV2Router), type(uint256).max);\\n\\n            _setAutomatedMarketMakerPair(_uniswapV2Pair, true);\\n\\n            dividendTracker.excludeFromDividends(address(dividendTracker));\\n            dividendTracker.excludeFromDividends(address(this));\\n            dividendTracker.excludeFromDividends(DEAD);\\n            dividendTracker.excludeFromDividends(address(_uniswapV2Router));\\n\\n            _isExcludedFromFees[owner()] = true;\\n            _isExcludedFromFees[DEAD] = true;\\n            _isExcludedFromFees[address(this)] = true;\\n            _isExcludedFromFees[marketingWallet] = true;\\n        \\n            _mint(owner(), 420 * 10 ** 15 * (10 ** 9));\\n            swapTokensAtAmount = totalSupply() / 5000;\\n        }\\n\\n        receive() external payable {\\n\\n        }\\n\\n        function claimStuckTokens(address token) external onlyOwner {\\n            require(token != address(this), \\\"Owner cannot claim native tokens\\\");\\n            if (token == address(0x0)) {\\n                payable(msg.sender).transfer(address(this).balance);\\n                return;\\n            }\\n            IERC20 ERC20token = IERC20(token);\\n            uint256 balance = ERC20token.balanceOf(address(this));\\n            ERC20token.transfer(msg.sender, balance);\\n        }\\n\\n        function isContract(address account) internal view returns (bool) {\\n            return account.code.length > 0;\\n        }\\n\\n        function sendBNB(address payable recipient, uint256 amount) internal {\\n            require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n            (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n            require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n        }\\n\\n        function _setAutomatedMarketMakerPair(address pair, bool value) private {\\n            require(automatedMarketMakerPairs[pair] != value, \\\"Automated market maker pair is already set to that value\\\");\\n            automatedMarketMakerPairs[pair] = value;\\n\\n            if(value) {\\n                dividendTracker.excludeFromDividends(pair);\\n            }\\n\\n            emit SetAutomatedMarketMakerPair(pair, value);\\n        }\\n\\n        function excludeFromFees(address account, bool excluded) external onlyOwner {\\n            require(_isExcludedFromFees[account] != excluded, \\\"Account is already set to that state\\\");\\n            _isExcludedFromFees[account] = excluded;\\n\\n            emit ExcludeFromFees(account, excluded);\\n        }\\n\\n        function isExcludedFromFees(address account) public view returns(bool) {\\n            return _isExcludedFromFees[account];\\n        }\\n\\n        function _transfer(\\n            address from,\\n            address to,\\n            uint256 amount\\n        ) internal override {\\n            require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n            require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n            if(amount == 0) {\\n                super._transfer(from, to, 0);\\n                return;\\n            }\\n\\n            uint256 contractTokenBalance = balanceOf(address(this));\\n\\n            bool canSwap = contractTokenBalance >= swapTokensAtAmount;\\n\\n            if( canSwap &&\\n                !swapping &&\\n                automatedMarketMakerPairs[to] &&\\n                totalBuyFee + totalSellFee > 0\\n            ) {\\n                swapping = true;\\n                \\n                uint256 burnTokens;\\n\\n                if(burnFeeOnBuy + burnFeeOnSell > 0) {\\n                    burnTokens = contractTokenBalance * (burnFeeOnBuy + burnFeeOnSell) / 100;\\n                    super._transfer(address(this), DEAD, burnTokens);\\n                }\\n\\n                contractTokenBalance -= burnTokens;\\n\\n                uint256 bnbShare = (marketingFeeOnBuy + marketingFeeOnSell) + (rewardsFeeOnBuy + rewardsFeeOnSell);\\n                \\n                if(contractTokenBalance > 0 && bnbShare > 0) {\\n                    uint256 initialBalance = address(this).balance;\\n\\n                    address[] memory path = new address[](2);\\n                    path[0] = address(this);\\n                    path[1] = uniswapV2Router.WETH();\\n\\n                    uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n                        contractTokenBalance,\\n                        0,\\n                        path,\\n                        address(this),\\n                        block.timestamp);\\n                    \\n                    uint256 newBalance = address(this).balance - initialBalance;\\n\\n                    if((marketingFeeOnBuy + marketingFeeOnSell) > 0) {\\n                        uint256 marketingBNB = newBalance * (marketingFeeOnBuy + marketingFeeOnSell) / bnbShare;\\n                        sendBNB(payable(marketingWallet), marketingBNB);\\n                        emit SendMarketing(marketingBNB);\\n                    }\\n\\n                    if((rewardsFeeOnBuy + rewardsFeeOnSell) > 0) {\\n                        uint256 rewardBNB = newBalance * (rewardsFeeOnBuy + rewardsFeeOnSell) / bnbShare;\\n                        swapAndSendDividends(rewardBNB);\\n                    }\\n                }\\n\\n                swapping = false;\\n            }\\n\\n            bool takeFee = !swapping;\\n\\n            if(_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\\n                takeFee = false;\\n            }\\n\\n            // w2w & not excluded from fees\\n            if(from != uniswapV2Pair && to != uniswapV2Pair && takeFee) {\\n                takeFee = false;\\n            }\\n\\n            if(takeFee) {\\n                uint256 _totalFees;\\n                if(from == uniswapV2Pair) {\\n                    _totalFees = totalBuyFee;\\n                } else {\\n                    _totalFees = totalSellFee;\\n                }\\n                uint256 fees = amount * _totalFees / 100;\\n                \\n                amount = amount - fees;\\n\\n                super._transfer(from, address(this), fees);\\n            }\\n\\n            super._transfer(from, to, amount);\\n\\n            try dividendTracker.setBalance(payable(from), balanceOf(from)) {} catch {}\\n            try dividendTracker.setBalance(payable(to), balanceOf(to)) {} catch {}\\n\\n            if(!swapping) {\\n                uint256 gas = gasForProcessing;\\n\\n                try dividendTracker.process(gas) returns (uint256 iterations, uint256 claims, uint256 lastProcessedIndex) {\\n                    emit ProcessedDividendTracker(iterations, claims, lastProcessedIndex, true, gas, tx.origin);\\n                }\\n                catch {\\n\\n                }\\n            }\\n        }\\n\\n        function swapAndSendDividends(uint256 amount) private{\\n            address[] memory path = new address[](2);\\n            path[0] = uniswapV2Router.WETH();\\n            path[1] = rewardToken;\\n\\n            uniswapV2Router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount}(\\n                0,\\n                path,\\n                address(this),\\n                block.timestamp\\n            );\\n            \\n            uint256 balanceRewardToken = IERC20(rewardToken).balanceOf(address(this));\\n            bool success = IERC20(rewardToken).transfer(address(dividendTracker), balanceRewardToken);\\n\\n            if (success) {\\n                dividendTracker.distributeDividends(balanceRewardToken);\\n                emit SendDividends(balanceRewardToken);\\n            }\\n        }\\n\\n        function setSwapTokensAtAmount(uint256 newAmount) external onlyOwner{\\n            require(newAmount > totalSupply() / 100_000, \\\"SwapTokensAtAmount must be greater than 0.001% of total supply\\\");\\n            swapTokensAtAmount = newAmount;\\n        }\\n\\n        function updateClaimWait(uint256 newClaimWait) external onlyOwner {\\n            require(newClaimWait >= 3_600 && newClaimWait <= 86_400, \\\"claimWait must be updated to between 1 and 24 hours\\\");\\n            dividendTracker.updateClaimWait(newClaimWait);\\n        }\\n\\n        function getClaimWait() external view returns(uint256) {\\n            return dividendTracker.claimWait();\\n        }\\n\\n        function getTotalDividendsDistributed() external view returns (uint256) {\\n            return dividendTracker.totalDividendsDistributed();\\n        }\\n\\n        function withdrawableDividendOf(address account) public view returns(uint256) {\\n            return dividendTracker.withdrawableDividendOf(account);\\n        }\\n\\n        function dividendTokenBalanceOf(address account) public view returns (uint256) {\\n            return dividendTracker.balanceOf(account);\\n        }\\n\\n        function totalRewardsEarned(address account) public view returns (uint256) {\\n            return dividendTracker.accumulativeDividendOf(account);\\n        }\\n\\n        function excludeFromDividends(address account) external onlyOwner{\\n            dividendTracker.excludeFromDividends(account);\\n        }\\n\\n        function getAccountDividendsInfo(address account)\\n            external view returns (\\n                address,\\n                int256,\\n                int256,\\n                uint256,\\n                uint256,\\n                uint256,\\n                uint256,\\n                uint256) {\\n            return dividendTracker.getAccount(account);\\n        }\\n\\n        function getAccountDividendsInfoAtIndex(uint256 index)\\n            external view returns (\\n                address,\\n                int256,\\n                int256,\\n                uint256,\\n                uint256,\\n                uint256,\\n                uint256,\\n                uint256) {\\n            return dividendTracker.getAccountAtIndex(index);\\n        }\\n\\n        function processDividendTracker(uint256 gas) external {\\n            (uint256 iterations, uint256 claims, uint256 lastProcessedIndex) = dividendTracker.process(gas);\\n            emit ProcessedDividendTracker(iterations, claims, lastProcessedIndex, false, gas, tx.origin);\\n        }\\n\\n        function claim() external {\\n            dividendTracker.processAccount(payable(msg.sender), false);\\n        }\\n\\n        function claimAddress(address claimee) external onlyOwner {\\n            dividendTracker.processAccount(payable(claimee), false);\\n        }\\n\\n        function getLastProcessedIndex() external view returns(uint256) {\\n            return dividendTracker.getLastProcessedIndex();\\n        }\\n\\n        function setLastProcessedIndex(uint256 index) external onlyOwner {\\n            dividendTracker.setLastProcessedIndex(index);\\n        }\\n\\n        function getNumberOfDividendTokenHolders() external view returns(uint256) {\\n            return dividendTracker.getNumberOfTokenHolders();\\n        }\\n    }\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {\r\n      \"/contracts/bsc/MZCEO.sol\": {\r\n        \"IterableMapping\": \"0x438Ae1a3EC83C765Ba49DdbC7626C53A69CcaD65\"\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeFromFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"}],\"name\":\"GasForProcessingUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"iterations\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claims\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastProcessedIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"automatic\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"processor\",\"type\":\"address\"}],\"name\":\"ProcessedDividendTracker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SendDividends\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bnbSend\",\"type\":\"uint256\"}],\"name\":\"SendMarketing\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetAutomatedMarketMakerPair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"}],\"name\":\"UpdateDividendTracker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"}],\"name\":\"UpdateUniswapV2Router\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"automatedMarketMakerPairs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnFeeOnBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnFeeOnSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"claimee\",\"type\":\"address\"}],\"name\":\"claimAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"claimStuckTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"dividendTokenBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendTracker\",\"outputs\":[{\"internalType\":\"contract DividendTracker\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromDividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasForProcessing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAccountDividendsInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getAccountDividendsInfoAtIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getClaimWait\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastProcessedIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumberOfDividendTokenHolders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalDividendsDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingFeeOnBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingFeeOnSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"}],\"name\":\"processDividendTracker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsFeeOnBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsFeeOnSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"setLastProcessedIndex\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"setSwapTokensAtAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTokensAtAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"totalRewardsEarned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newClaimWait\",\"type\":\"uint256\"}],\"name\":\"updateClaimWait\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"withdrawableDividendOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MZCEO", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}