{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/Users/Shared/rug-zombie-contracts/contracts/DrFrankenstein.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"./interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"./interfaces/IUniswapV2Router02.sol\\\";\\nimport \\\"./access/Ownable.sol\\\";\\nimport \\\"./interfaces/IZombieToken.sol\\\";\\nimport \\\"./interfaces/IUndeadBar.sol\\\";\\nimport \\\"./interfaces/IGraveStakingToken.sol\\\";\\nimport \\\"./interfaces/IRevivedRugNft.sol\\\";\\nimport \\\"./interfaces/IPriceConsumerV3.sol\\\";\\nimport \\\"./libraries/Percentages.sol\\\";\\n\\ninterface IMigratorChef {\\n    // Perform LP token migration from legacy PancakeSwap to CakeSwap.\\n    // Take the current LP token address and return the new LP token address.\\n    // Migrator should have full access to the caller's LP token.\\n    // Return the new LP token address.\\n    //\\n    // XXX Migrator must have allowance access to PancakeSwap LP tokens.\\n    // CakeSwap must mint EXACTLY the same amount of CakeSwap LP tokens or\\n    // else something bad will happen. Traditional PancakeSwap does not\\n    // do that so be careful!\\n    function migrate(IGraveStakingToken token) external returns (IGraveStakingToken);\\n}\\n\\n// DrFrankenstein is the master of the Zombie token, tombs & the graves. He can make Zombie & he is a fair guy.\\n//\\n// Note that it's ownable and the owner wields tremendous power.\\n//\\n// Have fun reading it. Hopefully it's bug-free. God bless.\\ncontract DrFrankenstein is Ownable {\\n    using Percentages for uint256;\\n\\n    // Info of each user.\\n    struct UserInfo {\\n        uint256 amount;                 // How many LP tokens the user has provided.\\n        uint256 rewardDebt;             // Reward debt. See explanation below.\\n        uint256 tokenWithdrawalDate;    // Date user must wait until before early withdrawal fees are lifted.\\n        //\\n        // We do some fancy math here. Basically, any point in time, the amount of ZMBEs\\n        // entitled to a user but is pending to be distributed is:\\n        //\\n        //   pending reward = (user.amount * pool.accZombiePerShare) - user.rewardDebt\\n        //\\n        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\\n        //   1. The pool's `accZombiePerShare` (and `lastRewardBlock`) gets updated.\\n        //   2. User receives the pending reward sent to his/her address.\\n        //   3. User's `amount` gets updated.\\n        //   4. User's `rewardDebt` gets updated.\\n\\n        // User grave info\\n        uint256 rugDeposited;               // How many rugged tokens the user deposited.\\n        bool paidUnlockFee;                 // true if user paid the unlock fee.\\n        uint256  nftRevivalDate;            // Date user must wait until before harvesting their nft.\\n    }\\n\\n    // Info of each pool / grave.\\n    struct PoolInfo {\\n        // Traditional pool variables\\n        IGraveStakingToken lpToken;             // Address of LP token contract.\\n        uint256 allocPoint;                     // How many allocation points assigned to this pool. ZMBEs to distribute per block.\\n        uint256 lastRewardBlock;                // Last block number that ZMBEs distribution occurs.\\n        uint256 accZombiePerShare;              // Accumulated ZMBEs per share, times 1e12. See below.\\n        uint256 minimumStakingTime;             // Duration a user must stake before early withdrawal fee is lifted.\\n        // Grave variables\\n        bool isGrave;                           // True if pool is a grave (provides nft rewards).\\n        bool requiresRug;                       // True if grave require a rugged token deposit before unlocking.\\n        IGraveStakingToken ruggedToken;         // Address of the grave's rugged token (casted to IGraveStakingToken over IBEP20 to save space).\\n        address nft;                            // Address of reward nft.\\n        uint256 unlockFee;                      // Unlock fee (In BUSD, Chainlink Oracle is used to convert fee to current BNB value).\\n        uint256 minimumStake;                   // Minimum amount of lpTokens required to stake.\\n        uint256 nftRevivalTime;                 // Duration a user must stake before they can redeem their nft reward.\\n        uint256 unlocks;                        // Number of times a grave is unlocked\\n    }\\n\\n    // The ZMBE TOKEN!\\n    IZombieToken public zombie;\\n    // The SYRUP TOKEN!\\n    IUndeadBar public undead;\\n    // Dev address.\\n    address public devaddr;\\n    // ZMBE tokens created per block.\\n    uint256 public zombiePerBlock;\\n    // Bonus multiplier for early zombie makers.\\n    uint256 public BONUS_MULTIPLIER = 1;\\n    // The migrator contract. It has a lot of power. Can only be set through governance (owner).\\n    IMigratorChef public migrator;\\n    // Uniswap routerV2\\n    IUniswapV2Router02 public pancakeswapRouter;\\n    // Info of each grave.\\n    PoolInfo[] public poolInfo;\\n    // Info of each user that stakes LP tokens.\\n    mapping (uint256 => mapping (address => UserInfo)) public userInfo;\\n    // Total allocation points. Must be the sum of all allocation points in all pools.\\n    uint256 public totalAllocPoint = 0;\\n    // The block number when CAKE mining starts.\\n    uint256 public startBlock;\\n\\n    // Project addresses\\n    address payable treasury;   // Address of project treasury contract\\n    address public lpStorage; // Address locked LP is sent to (Allows us to migrate lp if Pancakeswap moves to v3 / we start an AMM)\\n    address public burnAddr = 0x000000000000000000000000000000000000dEaD; // Burn address\\n\\n    // Chainlink BNB Price\\n    IPriceConsumerV3 public priceConsumer;\\n\\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\\n    event WithdrawEarly(address indexed user, uint256 indexed pid, uint256 amountWithdrawn, uint256 amountLocked);\\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\\n    event ReviveRug(address indexed to, uint date, address nft, uint indexed id);\\n\\n    constructor(\\n        IZombieToken _zombie,\\n        IUndeadBar _undead,\\n        address _devaddr,\\n        address payable _treasury,\\n        address _lpStorage,\\n        address _pancakeRouter,\\n        address _firstNft,\\n        address _priceConsumer,\\n        uint256 _zombiePerBlock,\\n        uint256 _startBlock\\n    ) {\\n        zombie = _zombie;\\n        undead = _undead;\\n        devaddr = _devaddr;\\n        treasury = _treasury;\\n        lpStorage = _lpStorage;\\n        zombiePerBlock = _zombiePerBlock;\\n        startBlock = _startBlock;\\n\\n        // staking pool\\n        poolInfo.push(PoolInfo({\\n            lpToken: IGraveStakingToken(address(_zombie)),\\n            allocPoint: 100,\\n            lastRewardBlock: startBlock,\\n            accZombiePerShare: 0,\\n            minimumStakingTime: 3 days,\\n            requiresRug: false,\\n            isGrave: true,\\n            ruggedToken: IGraveStakingToken(address(0)),\\n            minimumStake: 5000 * (10 ** 18),\\n            nft: _firstNft,\\n            unlockFee: 5 * (10 ** 18),\\n            nftRevivalTime: 30 days,\\n            unlocks: 0\\n        }));\\n\\n        totalAllocPoint = 100;\\n        pancakeswapRouter = IUniswapV2Router02(_pancakeRouter);\\n        priceConsumer = IPriceConsumerV3(_priceConsumer);\\n    }\\n\\n    // Ensures a pool / grave is unlocked before a user accesses it.\\n    modifier isUnlocked(uint _gid) {\\n        UserInfo memory _user = userInfo[_gid][msg.sender];\\n        PoolInfo memory _pool = poolInfo[_gid];\\n        require(_user.rugDeposited > 0 || _pool.requiresRug == false, 'Locked: User has not deposited the required Rugged Token.');\\n        require(_user.paidUnlockFee == true || _pool.isGrave == false , 'Locked: User has not unlocked pool / grave.');\\n        _;\\n    }\\n\\n    // Ensures a rugged token has been deposited before unlocking accessing grave / pool.\\n    modifier hasDepositedRug(uint _pid) {\\n        require(userInfo[_pid][msg.sender].rugDeposited > 0 || poolInfo[_pid].requiresRug == false, 'Grave: User has not deposited the required Rugged Token.');\\n        _;\\n    }\\n\\n    // Ensures user's withdrawal date has passed before withdrawing.\\n    modifier canWithdraw(uint _pid, uint _amount) {\\n        uint _withdrawalDate = userInfo[_pid][msg.sender].tokenWithdrawalDate;\\n        require((block.timestamp >= _withdrawalDate && _withdrawalDate > 0) || _amount == 0, 'Staking: Token is still locked, use #withdrawEarly / #leaveStakingEarly to withdraw funds before the end of your staking period.');\\n        _;\\n    }\\n\\n    // Ensures a pool / grave exists\\n    modifier poolExists(uint _pid) {\\n        require(_pid <= poolInfo.length - 1, 'Pool: That pool does not exist.');\\n        _;\\n    }\\n\\n    function updateMultiplier(uint256 multiplierNumber) public onlyOwner {\\n        BONUS_MULTIPLIER = multiplierNumber;\\n    }\\n\\n    function poolLength() external view returns (uint256) {\\n        return poolInfo.length;\\n    }\\n\\n    // Add a new pool. Can only be called by the owner.\\n    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.\\n    function addPool(\\n        uint _allocPoint,\\n        IGraveStakingToken _lpToken,\\n        uint _minimumStakingTime,\\n        bool _withUpdate\\n    ) public onlyOwner {\\n        require(address(_lpToken) != address(zombie), 'addGrave: zombie cannot be used as grave lptoken.');\\n        if (_withUpdate) {\\n            massUpdatePools();\\n        }\\n        uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock;\\n        totalAllocPoint = totalAllocPoint + _allocPoint;\\n        poolInfo.push(PoolInfo({\\n            lpToken: _lpToken,\\n            allocPoint: _allocPoint,\\n            lastRewardBlock: lastRewardBlock,\\n            accZombiePerShare: 0,\\n            minimumStakingTime: _minimumStakingTime,\\n            // Null grave variables\\n            isGrave: false,\\n            requiresRug: false,\\n            ruggedToken: IGraveStakingToken(address(0)),\\n            nft: address(0),\\n            minimumStake: 0,\\n            unlockFee: 0,\\n            nftRevivalTime: 0,\\n            unlocks: 0\\n        }));\\n    }\\n\\n    // Add a new grave. Can only be called by the owner.\\n    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.\\n    // LP token will be minted & staked in replace of users zombie token, to simulate zombie staking on graves, without messing up rewards.\\n    function addGrave(\\n        uint256 _allocPoint,\\n        IGraveStakingToken _lpToken,\\n        uint256 _minimumStakingTime,\\n        IGraveStakingToken _ruggedToken,\\n        address _nft,\\n        uint256 _minimumStake,\\n        uint256 _unlockFee,\\n        uint256 _nftRevivalTime,\\n        bool _withUpdate\\n    ) public onlyOwner {\\n        require(address(_lpToken) != address(zombie), 'addGrave: zombie cannot be used as grave lptoken.');\\n        require(_lpToken.getOwner() == address(this), 'addGrave: DrFrankenstein must be lptoken owner.');\\n        if (_withUpdate) {\\n            massUpdatePools();\\n        }\\n        uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock;\\n        totalAllocPoint = totalAllocPoint + _allocPoint;\\n        poolInfo.push(PoolInfo({\\n            lpToken: _lpToken,\\n            allocPoint: _allocPoint,\\n            lastRewardBlock: lastRewardBlock,\\n            accZombiePerShare: 0,\\n            minimumStakingTime: _minimumStakingTime,\\n            // Grave variables\\n            isGrave: true,\\n            requiresRug: true,\\n            ruggedToken: _ruggedToken,\\n            nft: _nft,\\n            minimumStake: _minimumStake,\\n            unlockFee: _unlockFee,\\n            nftRevivalTime: _nftRevivalTime,\\n            unlocks: 0\\n        }));\\n    }\\n\\n    // Update the given pool's ZMBE allocation point. Can only be called by the owner.\\n    function set(uint256 _pid, uint256 _allocPoint, bool _withUpdate) public onlyOwner {\\n        if (_withUpdate) {\\n            massUpdatePools();\\n        }\\n        uint256 prevAllocPoint = poolInfo[_pid].allocPoint;\\n        poolInfo[_pid].allocPoint = _allocPoint;\\n        if (prevAllocPoint != _allocPoint) {\\n            totalAllocPoint = (totalAllocPoint - prevAllocPoint) + _allocPoint;\\n        }\\n    }\\n\\n    // Set the migrator contract. Can only be called by the owner.\\n    function setMigrator(IMigratorChef _migrator) public onlyOwner {\\n        migrator = _migrator;\\n    }\\n\\n    // Migrate lp token to another lp contract. Can be called by anyone. We trust that migrator contract is good.\\n    function migrate(uint256 _pid) public {\\n        require(address(migrator) != address(0), \\\"migrate: no migrator\\\");\\n        PoolInfo storage pool = poolInfo[_pid];\\n        IGraveStakingToken lpToken = pool.lpToken;\\n        uint256 bal = lpToken.balanceOf(address(this));\\n        require(bal == 0 || (lpToken.allowance(address(this), address(migrator)) == 0), 'Migrate: approve from non-zero to non-zero allowance');\\n        lpToken.approve(address(migrator), bal);\\n        IGraveStakingToken newLpToken = migrator.migrate(lpToken);\\n        require(bal == newLpToken.balanceOf(address(this)), \\\"migrate: bad\\\");\\n        pool.lpToken = newLpToken;\\n    }\\n\\n    // Return reward multiplier over the given _from to _to block.\\n    function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) {\\n        return (_to - _from) * BONUS_MULTIPLIER;\\n    }\\n\\n    // View function to see pending ZMBEs on frontend.\\n    function pendingZombie(uint256 _pid, address _user) external view returns (uint256) {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][_user];\\n        uint256 accZombiePerShare = pool.accZombiePerShare;\\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\\n        if (block.number > pool.lastRewardBlock && lpSupply != 0) {\\n            uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\\n            uint256 zombieReward = (multiplier * zombiePerBlock * pool.allocPoint) / totalAllocPoint;\\n            accZombiePerShare = accZombiePerShare + (zombieReward * 1e12) / lpSupply;\\n        }\\n        return ((user.amount * accZombiePerShare) / 1e12) - user.rewardDebt;\\n    }\\n\\n    // Update reward variables for all pools. Be careful of gas spending!\\n    function massUpdatePools() public {\\n        uint256 length = poolInfo.length;\\n        for (uint256 pid = 0; pid < length; ++pid) {\\n            updatePool(pid);\\n        }\\n    }\\n\\n    // Update reward variables of the given pool to be up-to-date.\\n    function updatePool(uint256 _pid) public {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        if (block.number <= pool.lastRewardBlock) {\\n            return;\\n        }\\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\\n        if (lpSupply == 0) {\\n            pool.lastRewardBlock = block.number;\\n            return;\\n        }\\n        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\\n        uint256 zombieReward = (multiplier * zombiePerBlock * pool.allocPoint) / totalAllocPoint;\\n        zombie.mint(devaddr, zombieReward / 10);\\n        zombie.mint(address(undead), zombieReward);\\n        pool.accZombiePerShare = pool.accZombiePerShare + (zombieReward * 1e12) / lpSupply;\\n        pool.lastRewardBlock = block.number;\\n    }\\n\\n    // Deposit LP tokens to MasterChef for ZMBE allocation.\\n    function deposit(uint256 _pid, uint256 _amount) public isUnlocked(_pid) {\\n        require (_pid != 0, 'deposit ZMBE by staking');\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\n        require(user.amount + _amount >= pool.minimumStake, 'Grave: amount staked must be >= grave minimum stake.');\\n\\n        updatePool(_pid);\\n        if (user.amount > 0) {\\n            uint256 pending = ((user.amount * pool.accZombiePerShare) / 1e12) - user.rewardDebt;\\n            if(pending > 0) {\\n                safeZombieTransfer(msg.sender, pending);\\n            }\\n        }\\n        if (_amount > 0) {\\n            user.tokenWithdrawalDate = block.timestamp + pool.minimumStakingTime;\\n            if (user.amount < pool.minimumStake) {\\n                user.nftRevivalDate = block.timestamp + pool.nftRevivalTime;\\n            }\\n            if (pool.isGrave == true) {\\n                pool.lpToken.mint(_amount);\\n                require(zombie.transferFrom(address(msg.sender), address(this), _amount));\\n                user.amount = user.amount + _amount;\\n            } else {\\n                require(pool.lpToken.transferFrom(address(msg.sender), address(this), _amount));\\n                user.amount = user.amount + _amount;\\n            }\\n        }\\n        user.rewardDebt = (user.amount * pool.accZombiePerShare) / 1e12;\\n        emit Deposit(msg.sender, _pid, _amount);\\n    }\\n\\n    // Withdraw LP tokens from MasterChef.\\n    function withdraw(uint256 _pid, uint256 _amount) public canWithdraw(_pid, _amount) {\\n        require (_pid != 0, 'withdraw ZMBE by unstaking');\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\n        require(user.amount >= _amount, \\\"withdraw: not good\\\");\\n        require(\\n            (user.amount - _amount >= pool.minimumStake) || (user.amount - _amount) == 0,\\n            'Grave: when withdrawing from graves the remaining balance must be 0 or >= grave minimum stake.'\\n        );\\n        uint256 _whaleWithdrawalFee = 0;\\n\\n        uint amountBasisPointsOfTotalSupply = pool.lpToken.totalSupply().calcBasisPoints(_amount);\\n        if(amountBasisPointsOfTotalSupply > 500 && pool.isGrave == false) { // tax 8% of on tokens if whale removes > 5% lp supply.\\n            _whaleWithdrawalFee = _amount.calcPortionFromBasisPoints(800);\\n            require(pool.lpToken.transfer(lpStorage, _whaleWithdrawalFee)); // Pool: whale tax is added to locked liquidity (burn address)\\n        }\\n\\n        uint256 _remainingAmount = _amount;\\n        _remainingAmount -= _whaleWithdrawalFee;\\n\\n\\n        updatePool(_pid);\\n        uint256 pending = ((user.amount * pool.accZombiePerShare) / 1e12) - user.rewardDebt;\\n        if(pending > 0) {\\n            safeZombieTransfer(msg.sender, pending);\\n        }\\n\\n        // mint nft\\n        if(pool.isGrave == true && user.amount >= pool.minimumStake && block.timestamp >= user.nftRevivalDate) {\\n            IRevivedRugNft _nft = IRevivedRugNft(pool.nft);\\n            uint256 id = _nft.reviveRug(msg.sender);\\n            user.nftRevivalDate = block.timestamp + pool.nftRevivalTime;\\n            emit ReviveRug(msg.sender, block.timestamp, pool.nft, id);\\n        }\\n\\n        if(_amount > 0) {\\n            if(pool.isGrave == true) {\\n                user.amount = user.amount - _amount;\\n                require(zombie.transfer(msg.sender, _remainingAmount));\\n                pool.lpToken.burn(_amount);\\n            } else {\\n                user.amount = user.amount - _amount;\\n                require(pool.lpToken.transfer(address(msg.sender), _remainingAmount));\\n            }\\n            user.tokenWithdrawalDate = block.timestamp + pool.minimumStakingTime;\\n        }\\n        user.rewardDebt = (user.amount * pool.accZombiePerShare) / 1e12;\\n        emit Withdraw(msg.sender, _pid, _amount);\\n    }\\n\\n    // Withdraw from Grave / Tomb before time is up, takes 5% fee\\n    function withdrawEarly(uint256 _pid, uint256 _amount) public {\\n        require (_pid != 0, 'withdraw ZMBE by unstaking');\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\n        require(user.amount >= _amount, \\\"withdraw: not good\\\");\\n        require(\\n            (user.amount - _amount >= pool.minimumStake) || (user.amount - _amount) == 0,\\n            'Grave: when withdrawing from graves the remaining balance must be 0 or >= grave minimum stake.'\\n        );\\n        uint256 _earlyWithdrawalFee = _amount.calcPortionFromBasisPoints(500);\\n        uint256 _burn = _earlyWithdrawalFee.calcPortionFromBasisPoints(5000);   // Half of zombie is burned\\n        uint256 _toTreasury = _earlyWithdrawalFee - _burn;                      // The rest is sent to the treasury\\n        uint256 _whaleWithdrawalFee = 0;\\n\\n        uint amountBasisPointsOfTotalSupply = pool.lpToken.totalSupply().calcBasisPoints(_amount);\\n        if(amountBasisPointsOfTotalSupply > 500 && pool.isGrave == false) { // tax 8% of on tokens if whale removes > 5% lp supply.\\n            _whaleWithdrawalFee = _amount.calcPortionFromBasisPoints(800);\\n            require(pool.lpToken.transfer(lpStorage, _whaleWithdrawalFee)); // Pool: whale tax is added to locked liquidity (burn address)\\n        }\\n\\n        uint256 _remainingAmount = _amount;\\n        _remainingAmount -= _earlyWithdrawalFee;\\n        _remainingAmount -= _whaleWithdrawalFee;\\n\\n        updatePool(_pid);\\n        uint256 pending = ((user.amount * pool.accZombiePerShare) / 1e12) - user.rewardDebt;\\n        if(pending > 0) {\\n            safeZombieTransfer(msg.sender, pending);\\n        }\\n        if(_amount > 0) {\\n            if(pool.isGrave == true) {\\n                user.amount = user.amount - _amount;\\n                require(zombie.transfer(burnAddr, _burn));\\n                require(zombie.transfer(treasury, _toTreasury));\\n                require(zombie.transfer(msg.sender, _remainingAmount));\\n                pool.lpToken.burn(_amount);\\n            } else {\\n                user.amount = user.amount - _amount;\\n                unpairBurnAndTreasureLP(address(pool.lpToken), _earlyWithdrawalFee);    // unpair lps, burn zombie tokens & send any other tokens to the treasury\\n                require(pool.lpToken.transfer(address(msg.sender), _remainingAmount));       // return the rest of lps to the user\\n            }\\n            user.tokenWithdrawalDate = block.timestamp + pool.minimumStakingTime;\\n        }\\n        user.rewardDebt = (user.amount * pool.accZombiePerShare) / 1e12;\\n        emit WithdrawEarly(msg.sender, _pid, _remainingAmount, _earlyWithdrawalFee);\\n    }\\n\\n    // Stake ZMBE tokens to MasterChef\\n    function enterStaking(uint256 _amount) public isUnlocked(0) {\\n        PoolInfo storage pool = poolInfo[0];\\n        UserInfo storage user = userInfo[0][msg.sender];\\n        require(user.amount + _amount >= pool.minimumStake, 'Grave: amount staked must be >= grave minimum stake.');\\n\\n        updatePool(0);\\n        if (user.amount > 0) {\\n            uint256 pending = ((user.amount * pool.accZombiePerShare) / 1e12) - user.rewardDebt;\\n            if(pending > 0) {\\n                safeZombieTransfer(msg.sender, pending);\\n            }\\n        }\\n        if(_amount > 0) {\\n            if (user.amount < pool.minimumStake) {\\n                user.nftRevivalDate = block.timestamp + pool.nftRevivalTime;\\n            }\\n            require(pool.lpToken.transferFrom(address(msg.sender), address(this), _amount));\\n            user.amount = user.amount + _amount;\\n            user.tokenWithdrawalDate = block.timestamp + pool.minimumStakingTime;\\n        }\\n\\n        user.rewardDebt = (user.amount * pool.accZombiePerShare) / 1e12;\\n\\n        undead.mint(msg.sender, _amount);\\n        emit Deposit(msg.sender, 0, _amount);\\n    }\\n\\n    // Withdraw ZMBE tokens from STAKING.\\n    function leaveStaking(uint256 _amount) public canWithdraw(0, _amount) {\\n        PoolInfo storage pool = poolInfo[0];\\n        UserInfo storage user = userInfo[0][msg.sender];\\n        require(user.amount >= _amount, \\\"withdraw: not good\\\");\\n        require(\\n            (user.amount - _amount >= pool.minimumStake) || (user.amount - _amount) == 0,\\n            'Grave: when withdrawing from graves the remaining balance must be 0 or >= grave minimum stake.'\\n        );\\n\\n        updatePool(0);\\n        uint256 pending = ((user.amount * pool.accZombiePerShare) / 1e12) - user.rewardDebt;\\n        if(pending > 0) {\\n            safeZombieTransfer(msg.sender, pending);\\n        }\\n\\n        // mint nft\\n        if(pool.isGrave == true && user.amount >= pool.minimumStake && block.timestamp >= user.nftRevivalDate) {\\n            uint id = IRevivedRugNft(pool.nft).reviveRug(msg.sender);\\n            user.nftRevivalDate = block.timestamp + pool.nftRevivalTime;\\n            emit ReviveRug(msg.sender, block.timestamp,  pool.nft, id);\\n        }\\n\\n        if(_amount > 0) { // is only true for users who have waited the minimumStakingTime due to modifier\\n            require(pool.lpToken.transfer(address(msg.sender), _amount));\\n            user.amount = user.amount - _amount;\\n            user.tokenWithdrawalDate = block.timestamp + pool.minimumStakingTime;\\n            if(pool.isGrave == true) {\\n                user.nftRevivalDate = block.timestamp + pool.nftRevivalTime;\\n            }\\n        }\\n\\n        user.rewardDebt = (user.amount * pool.accZombiePerShare) / 1e12;\\n\\n        undead.burn(msg.sender, _amount);\\n        emit Withdraw(msg.sender, 0, _amount);\\n    }\\n\\n    function leaveStakingEarly(uint256 _amount) public {\\n        PoolInfo storage pool = poolInfo[0];\\n        UserInfo storage user = userInfo[0][msg.sender];\\n        require(user.amount >= _amount, \\\"withdraw: not good\\\");\\n        require(\\n            user.amount - _amount >= pool.minimumStake || (user.amount - _amount) == 0,\\n            'withdraw: remaining balance must be 0 or >= the graves minimum stake'\\n        );\\n\\n        updatePool(0);\\n        uint256 pending = ((user.amount * pool.accZombiePerShare) / 1e12) - user.rewardDebt;\\n        uint256 _earlyWithdrawalFee = _amount.calcPortionFromBasisPoints(500);  // 5% fee to fund project\\n        uint256 _burn = _earlyWithdrawalFee.calcPortionFromBasisPoints(5000);   // Half of zombie is burned\\n        uint256 _toTreasury = _earlyWithdrawalFee - _burn;                      // The rest is sent to the treasury\\n        uint256 _remainingAmount = _amount - _earlyWithdrawalFee;\\n\\n        if(pending > 0) {\\n            safeZombieTransfer(msg.sender, pending);\\n        }\\n\\n        if(_amount > 0) {\\n            user.amount = user.amount - _amount;\\n            user.tokenWithdrawalDate = block.timestamp + pool.minimumStakingTime;\\n            require(pool.lpToken.transfer(burnAddr, _burn));\\n            require(pool.lpToken.transfer(treasury, _toTreasury));\\n            require(pool.lpToken.transfer(address(msg.sender), _remainingAmount));\\n        }\\n\\n        user.rewardDebt = (user.amount * pool.accZombiePerShare) / 1e12;\\n        undead.burn(msg.sender, _amount);\\n        emit WithdrawEarly(msg.sender, 0, _remainingAmount, _earlyWithdrawalFee);\\n    }\\n\\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\\n    function emergencyWithdraw(uint256 _pid) public {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\n        uint256 _amount = user.amount;\\n        uint256 _remaining = _amount;\\n\\n        // The following fees must still be taken here to prevent #emergencyWithdraw\\n        // from being used as a method to avoid fees.\\n\\n        // Send early withdrawal fees to treasury\\n        if(block.timestamp < user.tokenWithdrawalDate) {\\n            uint256 _earlyWithdrawalFee = _amount / 20; // 5% of amount\\n            if(pool.isGrave == true) {\\n                zombie.transfer(treasury, _earlyWithdrawalFee);\\n            } else {\\n                pool.lpToken.transfer(treasury, _earlyWithdrawalFee);\\n            }\\n            _remaining -= _earlyWithdrawalFee;\\n        }\\n\\n        // Send whale withdrawal fee to treasury\\n        uint amountBasisPointsOfTotalSupply = pool.lpToken.totalSupply().calcBasisPoints(_amount);\\n        if(amountBasisPointsOfTotalSupply > 500 && pool.isGrave == false) { // tax 8% of on tokens if whale removes > 5% lp supply.\\n            uint _whaleWithdrawalFee = _amount.calcPortionFromBasisPoints(800);\\n            pool.lpToken.transfer(lpStorage, _whaleWithdrawalFee); // whale tax is added to lockedLiquidity\\n            _remaining -= _whaleWithdrawalFee;\\n        }\\n\\n        if(pool.isGrave == true && _pid != 0) {\\n            pool.lpToken.burn(_amount);\\n        }\\n\\n        if(pool.isGrave == true) {\\n            require(zombie.transfer(address(msg.sender), _remaining));\\n        } else {\\n            require(pool.lpToken.transfer(address(msg.sender), _remaining));\\n        }\\n\\n        emit EmergencyWithdraw(msg.sender, _pid, user.amount);\\n        user.tokenWithdrawalDate = block.timestamp + pool.minimumStakingTime;\\n        user.nftRevivalDate = block.timestamp + pool.nftRevivalTime;\\n        user.amount = 0;\\n        user.rewardDebt = 0;\\n    }\\n\\n    // Safe zombie transfer function, just in case if rounding error causes pool to not have enough ZMBEs.\\n    function safeZombieTransfer(address _to, uint256 _amount) internal {\\n        undead.safeZombieTransfer(_to, _amount);\\n    }\\n\\n    // Deposits rug into grave before unlocking\\n    function depositRug(uint _pid, uint _amount) external poolExists(_pid) {\\n        require(poolInfo[_pid].isGrave == true, 'Tomb: only graves accept rugged tokens.');\\n        require(poolInfo[_pid].ruggedToken.transferFrom(msg.sender, treasury, _amount));\\n        userInfo[_pid][msg.sender].rugDeposited += _amount;\\n    }\\n\\n    // Unlocks grave, half of fee is sent to treasury, the rest is used to buyBackAndBurn,\\n    function unlock(uint _pid) external payable hasDepositedRug(_pid) {\\n        require(poolInfo[_pid].isGrave == true, 'Tomb: tombs do not require unlocking.');\\n        require(userInfo[_pid][msg.sender].paidUnlockFee == false, 'Grave: unlock fee is already paid.');\\n        uint _unlockFeeInBnb = unlockFeeInBnb(_pid);\\n        require(msg.value >= _unlockFeeInBnb, 'Grave: cannot unlock, insufficient bnb sent.');\\n        uint _projectFunds = msg.value;\\n        uint _toTreasury = _projectFunds.calcPortionFromBasisPoints(5000);\\n        uint _buyBack = _projectFunds - _toTreasury;\\n\\n        treasury.transfer(_toTreasury);     // half of unlock fee goes to treasury\\n        buyBackAndBurn(_buyBack);           // the rest is used to buy back and burn zombie token\\n\\n        poolInfo[_pid].unlocks += 1;\\n        userInfo[_pid][msg.sender].paidUnlockFee = true;\\n    }\\n\\n    // return treasury address\\n    function getTreasury() public view returns(address) {\\n        return address(treasury);\\n    }\\n\\n    // Allow dev to lift 2% wallet balance limit on the zombie token after launch\\n    function liftLaunchWhaleDetection() public onlyOwner {\\n        zombie.liftLaunchWhaleDetection();\\n    }\\n\\n    // Allow dev to change the nft rewarded from a grave\\n    // should only be called on grave's\\n    function setGraveNft(uint _pid, address nft) public onlyOwner {\\n        poolInfo[_pid].nft = nft;\\n    }\\n\\n    // Allow dev to change the unlock fee of a grave\\n    // should only be called on grave's\\n    function setUnlockFee(uint _pid, uint _unlockFee) public onlyOwner {\\n        poolInfo[_pid].unlockFee = _unlockFee;\\n    }\\n\\n    // Warning only call before a grave has users staked in it\\n    // should only be called on grave's\\n    function setGraveMinimumStake(uint _pid, uint _minimumStake) public onlyOwner {\\n        poolInfo[_pid].minimumStake = _minimumStake;\\n    }\\n\\n    // Allow dev to change price consumer oracle address\\n    function setPriceConsumer(IPriceConsumerV3 _priceConsumer) public onlyOwner {\\n        priceConsumer = _priceConsumer;\\n    }\\n\\n    // Allow dev to set router, for when we start an AMM\\n    function setPancakeRouter(address _pancakeRouter) public onlyOwner {\\n        pancakeswapRouter = IUniswapV2Router02(_pancakeRouter);\\n    }\\n\\n    // Helpers\\n    function unpairBurnAndTreasureLP(address lpAddress, uint _amount) private {\\n        // unpair\\n        IUniswapV2Pair lp = IUniswapV2Pair(lpAddress);\\n        IGraveStakingToken _token0 = IGraveStakingToken(lp.token0());\\n        IGraveStakingToken _token1 = IGraveStakingToken(lp.token1());\\n\\n        uint256 _initialToken0Balance = _token0.balanceOf(address(this));\\n        uint256 _initialToken1Balance = _token1.balanceOf(address(this));\\n\\n        // allow pancake router\\n        lp.approve(address(pancakeswapRouter), _amount);\\n\\n        // unpair lp\\n        pancakeswapRouter.removeLiquidity(\\n            address(_token0),\\n            address(_token1),\\n            _amount,\\n            0,\\n            0,\\n            address(this),\\n            block.timestamp\\n        );\\n\\n        uint256 _token0Amount = _token0.balanceOf(address(this)) - _initialToken0Balance;\\n        uint256 _token1Amount = _token1.balanceOf(address(this)) - _initialToken1Balance;\\n\\n        // burn zombie token if included in pair\\n        if(address(_token0) == address(zombie) || address(_token1) == address(zombie)) {\\n            if(address(_token0) == address(zombie)) {             // if _token0 is ZMBE\\n                _token0.transfer(burnAddr, _token0Amount);        // burn the unpaired token0\\n                _token1.transfer(treasury, _token1Amount);          // send the unpaired token1 to treasury\\n            } else {                                            // else if _token1 is ZMBE\\n                _token1.transfer(burnAddr, _token1Amount);        // burn the unpaired token1\\n                _token0.transfer(treasury, _token0Amount);          // send the unpaired token0 to treasury\\n            }\\n        } else { // send both tokens to treasury if pair doesnt contain ZMBE token\\n            _token0.transfer(treasury, _token0Amount);\\n            _token1.transfer(treasury, _token1Amount);\\n        }\\n    }\\n\\n    // Buys Zombie with BNB\\n    function swapZombieForBnb(uint256 bnbAmount) private {\\n        address[] memory path = new address[](2);\\n        path[0] = pancakeswapRouter.WETH();\\n        path[1] = address(zombie);\\n\\n        IGraveStakingToken WBNB = IGraveStakingToken(pancakeswapRouter.WETH());\\n        WBNB.approve(address(pancakeswapRouter), bnbAmount);\\n\\n        // make the swap\\n        pancakeswapRouter.swapExactETHForTokens{value: bnbAmount} (\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n\\n    // Buys and burns zombie\\n    function buyBackAndBurn(uint bnbAmount) private {\\n        uint256 _initialZombieBalance = zombie.balanceOf(address(this));\\n        swapZombieForBnb(bnbAmount);\\n        uint256 _zombieBoughtBack = zombie.balanceOf(address(this)) - _initialZombieBalance;\\n        zombie.transfer(burnAddr, _zombieBoughtBack); // Send bought zombie to burn address\\n    }\\n\\n    // Returns grave unlock fee in bnb\\n    function unlockFeeInBnb(uint _gid) public view returns(uint) {\\n        return priceConsumer.usdToBnb(poolInfo[_gid].unlockFee);\\n    }\\n\\n    // Update dev address by the previous dev.\\n    function dev(address _devaddr) public {\\n        require(msg.sender == devaddr, \\\"dev: wut?\\\");\\n        devaddr = _devaddr;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/Shared/rug-zombie-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor()  {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\"\r\n    },\r\n    \"/Users/Shared/rug-zombie-contracts/contracts/interfaces/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\\n/**x\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\\n      *\\n      * Requirements:\\n      *\\n      * - `from` cannot be the zero address.\\n      * - `to` cannot be the zero address.\\n      * - `tokenId` token must exist and be owned by `from`.\\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n      *\\n      * Emits a {Transfer} event.\\n      */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"/Users/Shared/rug-zombie-contracts/contracts/interfaces/IERC721Receiver.sol\": {\r\n      \"content\": \" // SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"/Users/Shared/rug-zombie-contracts/contracts/interfaces/IGraveStakingToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.8.4;\\n\\ninterface IGraveStakingToken {\\n\\n    /**\\n    * @dev Mints the amount of tokens to the address specified.\\n    */\\n    function mint(address _to, uint256 _amount) external;\\n\\n    /**\\n    * @dev Mints the amount of tokens to the caller's address.\\n    */\\n    function mint(uint _amount) external;\\n\\n    /**\\n    * @dev Burns the amount of tokens from the msg.sender.\\n    */\\n    function burn(uint256 _amount) external;\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the token decimals.\\n     */\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @dev Returns the token symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the bep token owner.\\n     */\\n    function getOwner() external view returns (address);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address _owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"/Users/Shared/rug-zombie-contracts/contracts/interfaces/IPriceConsumerV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\ninterface IPriceConsumerV3 {\\n    function getLatestPrice() external view returns (uint);\\n    function unlockFeeInBnb(uint) external view returns (uint);\\n    function usdToBnb(uint) external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"/Users/Shared/rug-zombie-contracts/contracts/interfaces/IRevivedRugNft.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nimport '../token/ERC721/ERC721.sol';\\nimport '../access/Ownable.sol';\\nimport '../utils/Counters.sol';\\n\\n\\ninterface IRevivedRugNft {\\n    function reviveRug(address _to) external returns(uint);\\n}\\n\"\r\n    },\r\n    \"/Users/Shared/rug-zombie-contracts/contracts/interfaces/IUndeadBar.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n\\n// UndeadBar interface.\\ninterface IUndeadBar {\\n    function mint(address _to, uint256 _amount) external;\\n    function burn(address _from ,uint256 _amount) external;\\n    function safeZombieTransfer(address _to, uint256 _amount) external;\\n    function delegates(address delegator) external view returns (address);\\n    function delegate(address delegatee) external;\\n    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) external;\\n    function getCurrentVotes(address account) external view returns (uint256);\\n    function getPriorVotes(address account, uint blockNumber) external view returns (uint256);\\n    function safe32(uint n, string memory errorMessage) external pure returns (uint32);\\n}\"\r\n    },\r\n    \"/Users/Shared/rug-zombie-contracts/contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\"\r\n    },\r\n    \"/Users/Shared/rug-zombie-contracts/contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n    external\\n    payable\\n    returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n    external\\n    returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n    external\\n    returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n    external\\n    payable\\n    returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\"\r\n    },\r\n    \"/Users/Shared/rug-zombie-contracts/contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\"\r\n    },\r\n    \"/Users/Shared/rug-zombie-contracts/contracts/interfaces/IZombieToken.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n\\n// ZombieToken interface.\\ninterface IZombieToken {\\n    function mint(address _to, uint256 _amount) external;\\n    function delegates(address delegator) external view returns (address);\\n    function delegate(address delegatee) external;\\n    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) external;\\n    function transferOwnership(address newOwner) external;\\n    function getCurrentVotes(address account) external view returns (uint256);\\n    function getPriorVotes(address account, uint blockNumber) external view returns (uint256);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address _owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n    function liftLaunchWhaleDetection() external;\\n}\"\r\n    },\r\n    \"/Users/Shared/rug-zombie-contracts/contracts/libraries/Percentages.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.4;\\n\\nlibrary Percentages {\\n    // Get value of a percent of a number\\n    function calcPortionFromBasisPoints(uint _amount, uint _basisPoints) public pure returns(uint) {\\n        if(_basisPoints == 0 || _amount == 0) {\\n            return 0;\\n        } else {\\n            uint _portion = _amount * _basisPoints / 10000;\\n            return _portion;\\n        }\\n    }\\n\\n    // Get basis points (percentage) of _portion relative to _amount\\n    function calcBasisPoints(uint _amount, uint  _portion) public pure returns(uint) {\\n        if(_portion == 0 || _amount == 0) {\\n            return 0;\\n        } else {\\n            uint _basisPoints = (_portion * 10000) / _amount;\\n            return _basisPoints;\\n        }\\n    }\\n}\"\r\n    },\r\n    \"/Users/Shared/rug-zombie-contracts/contracts/token/ERC721/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"../../interfaces/IERC721.sol\\\";\\nimport \\\"../../interfaces/IERC721Receiver.sol\\\";\\nimport \\\"./extensions/IERC721Metadata.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/Strings.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping (uint256 => address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping (address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping (uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor (string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return interfaceId == type(IERC721).interfaceId\\n        || interfaceId == type(IERC721Metadata).interfaceId\\n        || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _owners[tokenId];\\n        require(owner != address(0), \\\"ERC721: owner query for nonexistent token\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0\\n        ? string(abi.encodePacked(baseURI, tokenId.toString()))\\n        : '';\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. Empty by default, can be overriden\\n     * in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(operator != _msgSender(), \\\"ERC721: approve to caller\\\");\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _owners[tokenId] != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ERC721.ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\\n        _mint(to, tokenId);\\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        _balances[owner] -= 1;\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _balances[from] -= 1;\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits a {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\\n    private returns (bool)\\n    {\\n        if (to.isContract()) {\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver(to).onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    // solhint-disable-next-line no-inline-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\\n}\"\r\n    },\r\n    \"/Users/Shared/rug-zombie-contracts/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"../../../interfaces/IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"/Users/Shared/rug-zombie-contracts/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/Shared/rug-zombie-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns ( bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\"\r\n    },\r\n    \"/Users/Shared/rug-zombie-contracts/contracts/utils/Counters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary Counters {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\nfunction decrement(Counter storage counter) internal {\\n    uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n}\"\r\n    },\r\n    \"/Users/Shared/rug-zombie-contracts/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant alphabet = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = alphabet[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"/Users/Shared/rug-zombie-contracts/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"/Users/Shared/rug-zombie-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {\r\n      \"/Users/Shared/rug-zombie-contracts/contracts/libraries/Percentages.sol\": {\r\n        \"Percentages\": \"0x574F11c6b49d581141dcB5D93536f88DDfE75BEA\"\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IZombieToken\",\"name\":\"_zombie\",\"type\":\"address\"},{\"internalType\":\"contract IUndeadBar\",\"name\":\"_undead\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_devaddr\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_treasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_lpStorage\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pancakeRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_firstNft\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_priceConsumer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_zombiePerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"date\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ReviveRug\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountWithdrawn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountLocked\",\"type\":\"uint256\"}],\"name\":\"WithdrawEarly\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BONUS_MULTIPLIER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"contract IGraveStakingToken\",\"name\":\"_lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minimumStakingTime\",\"type\":\"uint256\"},{\"internalType\":\"contract IGraveStakingToken\",\"name\":\"_ruggedToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nft\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minimumStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_unlockFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nftRevivalTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_withUpdate\",\"type\":\"bool\"}],\"name\":\"addGrave\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"contract IGraveStakingToken\",\"name\":\"_lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minimumStakingTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_withUpdate\",\"type\":\"bool\"}],\"name\":\"addPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositRug\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_devaddr\",\"type\":\"address\"}],\"name\":\"dev\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devaddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"enterStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_to\",\"type\":\"uint256\"}],\"name\":\"getMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTreasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"leaveStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"leaveStakingEarly\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liftLaunchWhaleDetection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpStorage\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"massUpdatePools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrator\",\"outputs\":[{\"internalType\":\"contract IMigratorChef\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pancakeswapRouter\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingZombie\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolInfo\",\"outputs\":[{\"internalType\":\"contract IGraveStakingToken\",\"name\":\"lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accZombiePerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumStakingTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isGrave\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"requiresRug\",\"type\":\"bool\"},{\"internalType\":\"contract IGraveStakingToken\",\"name\":\"ruggedToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"unlockFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nftRevivalTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlocks\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceConsumer\",\"outputs\":[{\"internalType\":\"contract IPriceConsumerV3\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_withUpdate\",\"type\":\"bool\"}],\"name\":\"set\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minimumStake\",\"type\":\"uint256\"}],\"name\":\"setGraveMinimumStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"}],\"name\":\"setGraveNft\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMigratorChef\",\"name\":\"_migrator\",\"type\":\"address\"}],\"name\":\"setMigrator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pancakeRouter\",\"type\":\"address\"}],\"name\":\"setPancakeRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IPriceConsumerV3\",\"name\":\"_priceConsumer\",\"type\":\"address\"}],\"name\":\"setPriceConsumer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_unlockFee\",\"type\":\"uint256\"}],\"name\":\"setUnlockFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAllocPoint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"undead\",\"outputs\":[{\"internalType\":\"contract IUndeadBar\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"unlock\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gid\",\"type\":\"uint256\"}],\"name\":\"unlockFeeInBnb\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"multiplierNumber\",\"type\":\"uint256\"}],\"name\":\"updateMultiplier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"updatePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWithdrawalDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rugDeposited\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"paidUnlockFee\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"nftRevivalDate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEarly\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zombie\",\"outputs\":[{\"internalType\":\"contract IZombieToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zombiePerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "DrFrankenstein", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000050ba8bf9e34f0f83f96a340387d1d3888ba4b3b50000000000000000000000005534984d26d0bc78588752c8ab7caabfbaa7706b0000000000000000000000000662cfc47e366e60121c1f1d8dfca0ef0f2f64a5000000000000000000000000111a8fc09d65f29bbb026884c3034275dc9da49700000000000000000000000024f6f6277eaa3835e90badd5f27c89583c553d9000000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a31ce87eb587666cdae6b35d62a85514a49248b70000000000000000000000000000000000000000000000008ac7230489e800000000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "1", "Implementation": "0x574f11c6b49d581141dcb5d93536f88ddfe75bea", "SwarmSource": ""}