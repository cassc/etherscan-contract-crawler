{"SourceCode": "//SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\n\r\ninterface IBEP20 {\r\n    function totalSupply() external view returns (uint);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function getOwner() external view returns (address);\r\n    function balanceOf(address account) external view returns (uint);\r\n    function transfer(address recipient, uint amount) external returns (bool);\r\n    function allowance(address _owner, address spender) external view returns (uint);\r\n    function approve(address spender, uint amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ninterface IERC721Receiver {\r\n    function onERC721Received(address operator, address from, uint tokenId, bytes calldata data) external returns (bytes4);\r\n}\r\n\r\ninterface IERC721 {\r\n    function ownerOf(uint tokenId) external view returns (address owner);\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint tokenId\r\n    ) external;\r\n    function balanceOf(address owner) external view returns (uint balance);\r\n}\r\n\r\ninterface IERC721Enumerable is IERC721 {\r\n\r\n    function totalSupply() external view returns (uint);\r\n    function tokenOfOwnerByIndex(address owner, uint index)\r\n    external\r\n    view\r\n    returns (uint tokenId);\r\n    function tokenByIndex(uint index) external view returns (uint);\r\n}\r\n\r\ninterface IEpicHeroNFT is IERC721Enumerable {\r\n    function packIdOfToken(uint id) external view returns (uint);\r\n    function getHero(uint heroId) external view returns (uint8 level, uint8 rarity);\r\n}\r\n\r\nenum Permission {\r\n    Authorize,\r\n    Unauthorize,\r\n    LockPermissions,\r\n    RetrieveTokens,\r\n    AdjustVariables,\r\n    RegisterNewMints\r\n}\r\n\r\nabstract contract EpicAuth {\r\n    struct PermissionLock {\r\n        bool isLocked;\r\n        uint64 expiryTime;\r\n    }\r\n\r\n    address public owner;\r\n    mapping(address => mapping(uint => bool)) private authorizations;\r\n\r\n    uint constant NUM_PERMISSIONS = 6; // always has to be adjusted when Permission element is added or removed\r\n    mapping(string => uint) permissionNameToIndex;\r\n\r\n    mapping(uint => PermissionLock) lockedPermissions;\r\n\r\n    constructor(address owner_) {\r\n        owner = owner_;\r\n        for (uint i; i < NUM_PERMISSIONS; i++) {\r\n            authorizations[owner_][i] = true;\r\n        }\r\n\r\n        // a permission name can't be longer than 32 bytes\r\n        permissionNameToIndex[\"Authorize\"] = uint(Permission.Authorize);\r\n        permissionNameToIndex[\"Unauthorize\"] = uint(Permission.Unauthorize);\r\n        permissionNameToIndex[\"LockPermissions\"] = uint(Permission.LockPermissions);\r\n        permissionNameToIndex[\"RetrieveTokens\"] = uint(Permission.RetrieveTokens);\r\n        permissionNameToIndex[\"AdjustVariables\"] = uint(Permission.AdjustVariables);\r\n        permissionNameToIndex[\"RegisterNewMints\"] = uint(Permission.RegisterNewMints);\r\n    }\r\n\r\n    /**\r\n     * Function modifier to require caller to be contract owner\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(msg.sender), \"onlyOwner\"); _;\r\n    }\r\n\r\n    /**\r\n     * Function modifier to require caller to be authorized\r\n     */\r\n    modifier authorizedFor(Permission permission) {\r\n        require(!lockedPermissions[uint(permission)].isLocked, \"Permission is locked.\");\r\n        require(isAuthorizedFor(msg.sender, permission), \"Not authorized\"); _;\r\n    }\r\n\r\n    /**\r\n     * Authorize address for one permission\r\n     */\r\n    function authorizeFor(address adr, string memory permissionName) public authorizedFor(Permission.Authorize) {\r\n        uint permIndex = permissionNameToIndex[permissionName];\r\n        authorizations[adr][permIndex] = true;\r\n        emit AuthorizedFor(adr, permissionName, permIndex);\r\n    }\r\n\r\n    /**\r\n     * Authorize address for multiple permissions\r\n     */\r\n    function authorizeForMultiplePermissions(address adr, string[] calldata permissionNames) public authorizedFor(Permission.Authorize) {\r\n        for (uint i; i < permissionNames.length; i++) {\r\n            uint permIndex = permissionNameToIndex[permissionNames[i]];\r\n            authorizations[adr][permIndex] = true;\r\n            emit AuthorizedFor(adr, permissionNames[i], permIndex);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove address' authorization\r\n     */\r\n    function unauthorizeFor(address adr, string memory permissionName) public authorizedFor(Permission.Unauthorize) {\r\n        require(adr != owner, \"Can't unauthorize owner\");\r\n\r\n        uint permIndex = permissionNameToIndex[permissionName];\r\n        authorizations[adr][permIndex] = false;\r\n        emit UnauthorizedFor(adr, permissionName, permIndex);\r\n    }\r\n\r\n    /**\r\n     * Unauthorize address for multiple permissions\r\n     */\r\n    function unauthorizeForMultiplePermissions(address adr, string[] calldata permissionNames) public authorizedFor(Permission.Unauthorize) {\r\n        require(adr != owner, \"!owner\");\r\n\r\n        for (uint i; i < permissionNames.length; i++) {\r\n            uint permIndex = permissionNameToIndex[permissionNames[i]];\r\n            authorizations[adr][permIndex] = false;\r\n            emit UnauthorizedFor(adr, permissionNames[i], permIndex);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check if address is owner\r\n     */\r\n    function isOwner(address account) public view returns (bool) {\r\n        return account == owner;\r\n    }\r\n\r\n    /**\r\n     * Return address' authorization status\r\n     */\r\n    function isAuthorizedFor(address adr, string memory permissionName) public view returns (bool) {\r\n        return authorizations[adr][permissionNameToIndex[permissionName]];\r\n    }\r\n\r\n    /**\r\n     * Return address' authorization status\r\n     */\r\n    function isAuthorizedFor(address adr, Permission permission) public view returns (bool) {\r\n        return authorizations[adr][uint(permission)];\r\n    }\r\n\r\n    /**\r\n     * Transfer ownership to new address. Caller must be owner.\r\n     */\r\n    function transferOwnership(address payable adr) public onlyOwner {\r\n        address oldOwner = owner;\r\n        owner = adr;\r\n        for (uint i; i < NUM_PERMISSIONS; i++) {\r\n            authorizations[oldOwner][i] = false;\r\n            authorizations[owner][i] = true;\r\n        }\r\n        emit OwnershipTransferred(oldOwner, owner);\r\n    }\r\n\r\n    /**\r\n     * Get the index of the permission by its name\r\n     */\r\n    function getPermissionNameToIndex(string memory permissionName) public view returns (uint) {\r\n        return permissionNameToIndex[permissionName];\r\n    }\r\n\r\n    /**\r\n     * Get the time the timeLock expires\r\n     */\r\n    function getPermissionUnlockTime(string memory permissionName) public view returns (uint) {\r\n        return lockedPermissions[permissionNameToIndex[permissionName]].expiryTime;\r\n    }\r\n\r\n    /**\r\n     * Check if the permission is locked\r\n     */\r\n    function isLocked(string memory permissionName) public view returns (bool) {\r\n        return lockedPermissions[permissionNameToIndex[permissionName]].isLocked;\r\n    }\r\n\r\n    /*\r\n     *Locks the permission from being used for the amount of time provided\r\n     */\r\n    function lockPermission(string memory permissionName, uint64 time) public virtual authorizedFor(Permission.LockPermissions) {\r\n        uint permIndex = permissionNameToIndex[permissionName];\r\n        uint64 expiryTime = uint64(block.timestamp) + time;\r\n        lockedPermissions[permIndex] = PermissionLock(true, expiryTime);\r\n        emit PermissionLocked(permissionName, permIndex, expiryTime);\r\n    }\r\n\r\n    /*\r\n     * Unlocks the permission if the lock has expired\r\n     */\r\n    function unlockPermission(string memory permissionName) public virtual {\r\n        require(block.timestamp > getPermissionUnlockTime(permissionName) , \"TimeLock\");\r\n        uint permIndex = permissionNameToIndex[permissionName];\r\n        lockedPermissions[permIndex].isLocked = false;\r\n        emit PermissionUnlocked(permissionName, permIndex);\r\n    }\r\n\r\n    event PermissionLocked(string permissionName, uint permissionIndex, uint64 expiryTime);\r\n    event PermissionUnlocked(string permissionName, uint permissionIndex);\r\n    event OwnershipTransferred(address from, address to);\r\n    event AuthorizedFor(address adr, string permissionName, uint permissionIndex);\r\n    event UnauthorizedFor(address adr, string permissionName, uint permissionIndex);\r\n}\r\n\r\ncontract EpicHeroReflect is EpicAuth, IERC721Receiver {\r\n    address deadAddress = 0x000000000000000000000000000000000000dEaD;\r\n    address public wbnbAddress = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\r\n    address public epicHeroNFTAddress = 0xafDcB0eCaD1c8Cb22893dCA7D6c510dBFDa3BBeC;\r\n    IEpicHeroNFT EpicHeroNFT;\r\n\r\n    uint128 public totalDividend; // uint128 is enough for over 300,000,000,000,000,000,000 WBNB per EpicHeroNFT\r\n\r\n    uint public totalReflected;\r\n    uint public totalEpicHero;\r\n\r\n    mapping(uint => uint) public dividends;\r\n\r\n    uint public lastContractBalance;\r\n\r\n    constructor() EpicAuth(msg.sender) {\r\n        EpicHeroNFT = IEpicHeroNFT(epicHeroNFTAddress);\r\n\r\n        //RegisterNewMints\r\n        authorizeFor(epicHeroNFTAddress,\"RegisterNewMints\");\r\n\r\n        initializeMints(0, 0);\r\n    }\r\n\r\n    function initializeMints(uint fromIndex, uint toIndex) public authorizedFor(Permission.RegisterNewMints) {\r\n        uint supply = EpicHeroNFT.totalSupply();\r\n\r\n        if(supply == 0){\r\n            return;\r\n        }\r\n\r\n        require(fromIndex < supply,\"Invalid fromIndex\");\r\n\r\n        if(toIndex == 0 || toIndex > supply){\r\n            toIndex = supply;\r\n        }\r\n\r\n        uint balanceOfDead = EpicHeroNFT.balanceOf(deadAddress);\r\n\r\n        uint _totalHeroCounted = 0;\r\n\r\n        for (uint256 i = fromIndex; i < toIndex; i++) {\r\n\r\n            (uint8 level,) = EpicHeroNFT.getHero(i);\r\n\r\n            bool heroOfDead = false;\r\n\r\n            if(level > 0){\r\n                if(balanceOfDead > 0){\r\n                    for(uint j = 0; j < balanceOfDead; j++){\r\n                        uint heroId = EpicHeroNFT.tokenOfOwnerByIndex(deadAddress, j);\r\n                        if(i == heroId){\r\n                            heroOfDead = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if( heroOfDead || level == 0 ){\r\n                dividends[i] = 0;\r\n            }else if(dividends[i] == 0){\r\n                dividends[i] = 1; // to distinguish EpicHeroNFT added before the first reflection from unregistered EpicHeroNFT\r\n                _totalHeroCounted++;\r\n            }\r\n        }\r\n\r\n        totalEpicHero += _totalHeroCounted;\r\n    }\r\n\r\n    function currentRate() public view returns (uint) {\r\n        uint supply = totalEpicHero;\r\n        if (supply == 0) return 0;\r\n        return totalReflected / supply;\r\n    }\r\n\r\n    function claimAllRewards() external {\r\n        claimAllRewards(msg.sender);\r\n    }\r\n\r\n    function claimAllRewards(address user) public {\r\n        uint count = EpicHeroNFT.balanceOf(user);\r\n        require(count > 0, \"User has 0 EpicHeroNFT\");\r\n\r\n        updateRewards();\r\n\r\n        uint total = 0;\r\n        for (uint i = 0; i < count; i++) {\r\n            uint tokenId = EpicHeroNFT.tokenOfOwnerByIndex(user, i);\r\n            uint unrealized = getUnrealizedReward(tokenId);\r\n\r\n            if (unrealized > 0) {\r\n                total += unrealized;\r\n                _setDividend(tokenId, totalDividend, uint128(dividends[tokenId] >> 128) + uint128(unrealized));\r\n            }\r\n        }\r\n\r\n        require(IBEP20(wbnbAddress).transfer(user, total), \"Transfer failed\");\r\n\r\n        updateRewards();\r\n\r\n        emit BatchClaim(user, count, total);\r\n    }\r\n\r\n    function claimReward(uint tokenId) public {\r\n        address owner_ = EpicHeroNFT.ownerOf(tokenId);\r\n        require(owner_ == msg.sender, \"Only owner can claim\");\r\n\r\n        updateRewards();\r\n\r\n        uint unrealized = getUnrealizedReward(tokenId);\r\n        require(unrealized > 0, \"Balance is 0\");\r\n\r\n        require(IBEP20(wbnbAddress).transfer(owner_, unrealized), \"Transfer failed\");\r\n\r\n        updateRewards();\r\n        _setDividend(tokenId, totalDividend, uint128(dividends[tokenId] >> 128) + uint128(unrealized));\r\n\r\n        emit SingleClaim(tokenId, unrealized);\r\n    }\r\n\r\n    function getAllUnrealizedRewards() public view returns (uint) {\r\n        return getAllUnrealizedRewards(msg.sender);\r\n    }\r\n\r\n    function getAllUnrealizedRewards(address user) public view returns (uint) {\r\n        uint count = EpicHeroNFT.balanceOf(user);\r\n        uint total = 0;\r\n\r\n        for (uint i = 0; i < count; i++) {\r\n            uint tokenId = EpicHeroNFT.tokenOfOwnerByIndex(user, i);\r\n            total += getUnrealizedReward(tokenId);\r\n        }\r\n\r\n        return total;\r\n    }\r\n\r\n    function getUnrealizedReward(uint tokenId) public view returns (uint) {\r\n        uint lastDiv = uint128(dividends[tokenId]); // just get the latter 128 bit\r\n        if (lastDiv == 0) return 0; // that means it's not registered in the contract\r\n\r\n        return totalDividend - lastDiv;\r\n    }\r\n\r\n    function getRealizedRewards(address user) public view returns (uint) {\r\n        uint count = EpicHeroNFT.balanceOf(user);\r\n        uint total = 0;\r\n\r\n        for (uint i = 0; i < count; i++) {\r\n            uint tokenId = EpicHeroNFT.tokenOfOwnerByIndex(user, i);\r\n            total += getRealizedReward(tokenId);\r\n        }\r\n\r\n        return total;\r\n    }\r\n\r\n    function getRealizedReward(uint tokenId) public view returns (uint) {\r\n        return uint(uint128(dividends[tokenId] >> 128));\r\n    }\r\n\r\n    function reflectDividend(uint amount) internal returns (bool) {\r\n        uint totalSupply = totalEpicHero;\r\n        if (totalSupply == 0 || amount == 0) { return false; }\r\n\r\n        totalReflected = totalReflected + amount;\r\n        totalDividend = uint128(totalDividend + (amount / totalSupply)); // no accuracy factor needed since it's 18+ divided by 4 digits\r\n\r\n        emit Reflected(amount);\r\n        return true;\r\n    }\r\n\r\n    function updateRewards() public {\r\n        uint tokenBalance = IBEP20(wbnbAddress).balanceOf(address(this));\r\n\r\n        if (tokenBalance == lastContractBalance) { return; }\r\n        else if (tokenBalance > lastContractBalance) {\r\n            // since this function is always called before and after every claim, lastContractBalance should always be up to date so this call shouldn't be able to miss any added balances\r\n            if (!reflectDividend(tokenBalance - lastContractBalance)) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        lastContractBalance = tokenBalance;\r\n    }\r\n\r\n    function registerNewMint(uint tokenId) external authorizedFor(Permission.RegisterNewMints) {\r\n        require(dividends[tokenId] == 0, \"Token already registered\");\r\n\r\n        if (totalDividend == 0) {\r\n            dividends[tokenId] = 1; // to distinguish EpicHeroNFT added before the first reflection from unregistered EpicHeroNFT\r\n        } else {\r\n            dividends[tokenId] = totalDividend;\r\n        }\r\n\r\n        totalEpicHero++;\r\n    }\r\n\r\n    function batchRegisterMints(uint[] memory tokenIds) external authorizedFor(Permission.RegisterNewMints) {\r\n        bool hasDuplicate;\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            uint tokenId = tokenIds[i];\r\n\r\n            if (dividends[tokenId] != 0) {\r\n                hasDuplicate = true;\r\n                break;\r\n            }\r\n\r\n            if (totalDividend == 0) {\r\n                dividends[tokenId] = 1; // to distinguish EpicHeroNFT added before the first reflection from unregistered EpicHeroNFT\r\n            } else {\r\n                dividends[tokenId] = totalDividend;\r\n            }\r\n        }\r\n\r\n        require(!hasDuplicate, \"Contains already registered token(s)\");\r\n\r\n        totalEpicHero += tokenIds.length;\r\n    }\r\n\r\n    function updateBurnedToken(uint tokenId) external authorizedFor(Permission.RegisterNewMints) {\r\n        if(dividends[tokenId] != 0){\r\n            dividends[tokenId] = 0;\r\n            totalEpicHero--;\r\n        }\r\n    }\r\n\r\n    function setWbnbAddress(address _newAddress) external authorizedFor(Permission.AdjustVariables) {\r\n        wbnbAddress = _newAddress;\r\n    }\r\n\r\n    function setEpicHeroNFTAddress(address _newAddress) external authorizedFor(Permission.AdjustVariables) {\r\n        epicHeroNFTAddress = _newAddress;\r\n        EpicHeroNFT = IEpicHeroNFT(_newAddress);\r\n    }\r\n\r\n    // use only in emergencies, could lead to some people being unable to get out the correct rewards\r\n    function teamSetDividend(uint tokenId, uint128 lastDividendAt, uint128 realized) external authorizedFor(Permission.AdjustVariables) {\r\n        _setDividend(tokenId, lastDividendAt, realized);\r\n    }\r\n\r\n    // use only in emergencies, could lead to some people being unable to get out the correct rewards\r\n    function retrieveTokens(address token, uint amount) external authorizedFor(Permission.RetrieveTokens) {\r\n        uint balance = IBEP20(token).balanceOf(address(this));\r\n\r\n        if(amount > balance){\r\n            amount = balance;\r\n        }\r\n\r\n        require(IBEP20(token).transfer(msg.sender, amount), \"Transfer failed\");\r\n    }\r\n\r\n    function retrieveBNB(uint amount) external authorizedFor(Permission.RetrieveTokens) {\r\n        uint balance = address(this).balance;\r\n\r\n        if(amount > balance){\r\n            amount = balance;\r\n        }\r\n\r\n        (bool success,) = payable(msg.sender).call{ value: amount }(\"\");\r\n        require(success, \"Failed\");\r\n    }\r\n\r\n    function onERC721Received(address, address, uint, bytes calldata) public pure override returns (bytes4) {\r\n        return 0x150b7a02;\r\n    }\r\n\r\n    function _setDividend(uint index, uint lastDividendAt, uint realized) internal {\r\n        uint256 div = lastDividendAt;\r\n        div |= realized << 128;\r\n        dividends[index] = div;\r\n    }\r\n\r\n    event SingleClaim(uint tokenId, uint amount);\r\n    event BatchClaim(address user, uint numTokens, uint amount);\r\n    event Reflected(uint amount);\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"permissionName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"permissionIndex\",\"type\":\"uint256\"}],\"name\":\"AuthorizedFor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BatchClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"permissionName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"permissionIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"expiryTime\",\"type\":\"uint64\"}],\"name\":\"PermissionLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"permissionName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"permissionIndex\",\"type\":\"uint256\"}],\"name\":\"PermissionUnlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Reflected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SingleClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"permissionName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"permissionIndex\",\"type\":\"uint256\"}],\"name\":\"UnauthorizedFor\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"permissionName\",\"type\":\"string\"}],\"name\":\"authorizeFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"internalType\":\"string[]\",\"name\":\"permissionNames\",\"type\":\"string[]\"}],\"name\":\"authorizeForMultiplePermissions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"batchRegisterMints\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAllRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"claimAllRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"claimReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epicHeroNFTAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getAllUnrealizedRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllUnrealizedRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"permissionName\",\"type\":\"string\"}],\"name\":\"getPermissionNameToIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"permissionName\",\"type\":\"string\"}],\"name\":\"getPermissionUnlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getRealizedReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getRealizedRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getUnrealizedReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fromIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toIndex\",\"type\":\"uint256\"}],\"name\":\"initializeMints\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"internalType\":\"enum Permission\",\"name\":\"permission\",\"type\":\"uint8\"}],\"name\":\"isAuthorizedFor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"permissionName\",\"type\":\"string\"}],\"name\":\"isAuthorizedFor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"permissionName\",\"type\":\"string\"}],\"name\":\"isLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastContractBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"permissionName\",\"type\":\"string\"},{\"internalType\":\"uint64\",\"name\":\"time\",\"type\":\"uint64\"}],\"name\":\"lockPermission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"registerNewMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"retrieveBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"retrieveTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setEpicHeroNFTAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setWbnbAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"lastDividendAt\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"realized\",\"type\":\"uint128\"}],\"name\":\"teamSetDividend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDividend\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalEpicHero\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalReflected\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"permissionName\",\"type\":\"string\"}],\"name\":\"unauthorizeFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"internalType\":\"string[]\",\"name\":\"permissionNames\",\"type\":\"string[]\"}],\"name\":\"unauthorizeForMultiplePermissions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"permissionName\",\"type\":\"string\"}],\"name\":\"unlockPermission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"updateBurnedToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wbnbAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "EpicHeroReflect", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://26ccf9c519def428bbd063cf5ddda001c328d72c3f6273ddcac10a2f9ccea84a"}