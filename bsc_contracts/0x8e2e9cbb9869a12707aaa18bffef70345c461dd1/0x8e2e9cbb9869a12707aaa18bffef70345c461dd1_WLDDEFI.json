{"SourceCode": "pragma solidity ^0.5.8;\r\n\r\ninterface IBEP20 {\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function decimals() external view returns (uint8);\r\n\r\n  function symbol() external view returns (string memory);\r\n\r\n \r\n  function name() external view returns (string memory);\r\n\r\n\r\n  function getOwner() external view returns (address);\r\n\r\n \r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  \r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n  \r\n  function allowance(address _owner, address spender) external view returns (uint256);\r\n\r\n\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n\r\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n  \r\n  function mint(address _to, uint256 amount) external returns (bool);\r\n\r\n \r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { \r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n     function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary Objects {\r\n    struct Investment {\r\n        uint256 planId;\r\n        uint256 investmentDate;\r\n        uint256 investment;\r\n        uint256 lastWithdrawalDate;\r\n        uint256 currentDividends;\r\n        bool isExpired;\r\n    }\r\n\r\n    struct Soda_investment {\r\n        uint256 planId;\r\n        uint256 investmentDate;\r\n        uint256 investment;\r\n        uint256 lastWithdrawalDate;\r\n        uint256 currentDividends;\r\n        bool isExpired;\r\n    }\r\n    struct Plan {\r\n        uint256 dailyInterest;\r\n        uint256 term; //0 means unlimited\r\n    }\r\n\r\n    struct Investor {\r\n        address payable addr;\r\n        uint256 referrerSodaEarnings;\r\n        uint256 refRewardsToClaim;\r\n        uint256 referrer;\r\n        uint256 planCount;\r\n        uint256 planCountSoda;\r\n        mapping(uint256 => Investment) plans;\r\n        mapping(uint256 => Soda_investment) plans_soda;\r\n        uint256 referrals;\r\n        uint256 lotteryRewards;\r\n        \r\n    }\r\n    \r\n\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event onOwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param _newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != address(0));\r\n        emit onOwnershipTransferred(owner, _newOwner);\r\n        owner = _newOwner;\r\n    }\r\n\r\n}\r\n\r\ncontract WLDDEFI is Ownable {\r\n    using SafeMath for uint256;\r\n    \r\n    IBEP20 public WLDTOKEN;\r\n\r\n    IBEP20 public tokenA = IBEP20(0x01B7b50221523342591933b1b424ee14F50f4994);\r\n    \r\n    uint256 public HCTamount = 500000000000000000000000;\r\n    uint256 public DEVELOPER_RATE = 20; //per thousand\r\n    uint256 public constant MARKETING_RATE = 20;\r\n    uint256 public constant ADMIN_RATE = 20;\r\n    uint256 public constant TEAM_RATE = 60;\r\n    uint256[] public REFERRAL_PERCENTS = [1500, 1500, 800, 800, 600, 500, 500, 500, 400, 400, 400, 300, 300, 300, 200, 200, 200, 100, 100, 100];\r\n\r\n    uint256 public constant TIME_STEP = 1 days;\r\n    \r\n    uint256 public START_DATE;\r\n    \r\n    uint256 public BNB_PER_SODA;\r\n    uint256 public SODA_STAKED = 0;\r\n    \r\n    uint256 public constant SODA_PER_TICKET = 1e18; // 1 SODA\r\n    uint256 public lotteryRound = 0;\r\n    uint256 public currentPot = 0;\r\n    uint256 public participants = 0;\r\n    uint256 public totalTickets = 0;\r\n    uint256 public LOTTERY_STEP = 12 hours; \r\n    uint256 public LOTTERY_START_TIME;\r\n    \r\n    uint256 public constant REFERRER_CODE = 7777; //default\r\n\r\n    uint256 public constant MIN_INVESTMENT = 1e18; // 1 bnb\r\n\r\n    uint256 public latestReferrerCode;\r\n    uint256 private totalInvestments_;\r\n\r\n    address payable private developerAccount_;\r\n    address payable private marketingAccount_;\r\n    address payable private adminAccount_;\r\n    address payable private teamAccount_;\r\n\r\n    mapping(address => uint256) public address2UID; // address => user_id\r\n    mapping(uint256 => Objects.Investor) public uid2Investor; // user_id => investor object\r\n    \r\n    mapping(uint256 => mapping(address => uint256)) public ticketOwners; // round => address => amount of owned tickets\r\n    mapping(uint256 => mapping(uint256 => address)) public participantAdresses; // round => id => address\r\n    \r\n    Objects.Plan[] private investmentPlans_;\r\n\r\n    event onInvest(address investor, uint256 amount);\r\n    event onWithdraw(address investor, uint256 amount);\r\n    event onStake(address investor, uint256 amount);\r\n    event onUnstake(address investor, uint256 amount);\r\n    event onRefClaimed(address investor, uint256 amount);\r\n    event onSwap(address investor, uint256 amount);\r\n    event onLotteryWinner(address investor, uint256 pot);\r\n    event onLotteryRewardsClaimed(address investor, uint256 rewards);\r\n\r\n    /**\r\n     * @dev Constructor Sets the original roles of the contract\r\n     */\r\n\r\n    constructor(address payable adminAccount, address payable marketingAccount, address payable teamAccount, uint256 price, IBEP20 SODA_ADDRESS) public {\r\n        developerAccount_ = msg.sender;\r\n        marketingAccount_ = marketingAccount;\r\n        adminAccount_ = adminAccount;\r\n        teamAccount_ = teamAccount;\r\n        \r\n        BNB_PER_SODA = price.mul(1e16); // if price = 1, BNB_PER_SODA = 0.01 and so on \r\n        WLDTOKEN = SODA_ADDRESS;\r\n        \r\n        START_DATE = block.timestamp;\r\n        LOTTERY_START_TIME = block.timestamp;\r\n        _init();\r\n    }\r\n\r\n\r\n    function getMarketingAccount() public view onlyOwner returns (address) {\r\n        return marketingAccount_;\r\n    }\r\n\r\n    function getDeveloperAccount() public view onlyOwner returns (address) {\r\n        return developerAccount_;\r\n    }\r\n\r\n\r\n    function _init() private {\r\n        latestReferrerCode = REFERRER_CODE;\r\n        address2UID[msg.sender] = REFERRER_CODE;\r\n        uid2Investor[latestReferrerCode].addr = msg.sender;\r\n        uid2Investor[latestReferrerCode].referrer = 0;\r\n        uid2Investor[latestReferrerCode].planCount = 0;\r\n        uid2Investor[latestReferrerCode].planCountSoda = 0;\r\n        investmentPlans_.push(Objects.Plan(10, 900*60*60*24)); //1% per day for 900 days \r\n        investmentPlans_.push(Objects.Plan(12, 900*60*60*24)); //1.2% per day for 900 days\r\n\r\n\r\n\r\n    }\r\n    \r\n    function getSodaPrice() public view returns(uint256) { // +0.2% per day (0.02)\r\n        uint256 timeMultiplier = (block.timestamp.sub(START_DATE)).div(TIME_STEP); \r\n        \r\n        uint256 sodaPrice = BNB_PER_SODA.add(BNB_PER_SODA.mul(timeMultiplier).mul(2).div(1000));\r\n        \r\n        return sodaPrice;\r\n    }\r\n\r\n\r\n    function getTotalInvestments() public  view returns (uint256){\r\n        return totalInvestments_;\r\n    }\r\n\r\n    function getBalance() public view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function getUIDByAddress(address _addr) public view returns (uint256) {\r\n        return address2UID[_addr];\r\n    }\r\n\r\n\r\n    function _addInvestor(address payable _addr, uint256 _referrerCode) private returns (uint256) {\r\n        if (_referrerCode >= REFERRER_CODE) {\r\n            //require(uid2Investor[_referrerCode].addr != address(0), \"Wrong referrer code\");\r\n            if (uid2Investor[_referrerCode].addr == address(0)) {\r\n                _referrerCode = 0;\r\n            }\r\n        } else {\r\n            _referrerCode = 0;\r\n        }\r\n        address payable addr = _addr;\r\n        latestReferrerCode = latestReferrerCode.add(1);\r\n        address2UID[addr] = latestReferrerCode;\r\n        uid2Investor[latestReferrerCode].addr = addr;\r\n        uid2Investor[latestReferrerCode].referrer = _referrerCode;\r\n        uid2Investor[latestReferrerCode].planCount = 0;\r\n        uid2Investor[latestReferrerCode].planCountSoda = 0;\r\n        if (_referrerCode >= REFERRER_CODE) {\r\n            \r\n            uint256 upline = _referrerCode;\r\n            \r\n            for(uint256 i = 0; i < 20; i++){\r\n                if(upline >=REFERRER_CODE){\r\n                    \r\n                    uid2Investor[upline].referrals = uid2Investor[upline].referrals.add(1);\r\n                    upline = uid2Investor[upline].referrer;\r\n                    \r\n                } else break;\r\n            }\r\n\r\n        }\r\n        return (latestReferrerCode);\r\n    }\r\n\r\n    function _invest(address payable _addr, uint256 _planId, uint256 _referrerCode, uint256 _amount) private returns (bool) {\r\n        \r\n        require(_amount>=MIN_INVESTMENT, \"Wrong min investment\");\r\n\r\n        uint256 uid = address2UID[_addr];\r\n\r\n        if (uid == 0) {\r\n            uid = _addInvestor(_addr, _referrerCode);\r\n            //new user\r\n        } else {//old user\r\n            //do nothing, referrer is permenant\r\n        }\r\n\r\n        \r\n\r\n        uint256 planCount = uid2Investor[uid].planCount;\r\n        Objects.Investor storage investor = uid2Investor[uid];\r\n        investor.plans[planCount].planId = _planId;\r\n        investor.plans[planCount].investmentDate = block.timestamp;\r\n        investor.plans[planCount].lastWithdrawalDate = block.timestamp;\r\n        investor.plans[planCount].investment = _amount;\r\n        investor.plans[planCount].currentDividends = 0;\r\n        investor.plans[planCount].isExpired = false;\r\n\r\n        investor.planCount = investor.planCount.add(1);\r\n\r\n        totalInvestments_ = totalInvestments_.add(_amount);\r\n\r\n        uint256 developerPercentage = (_amount.mul(DEVELOPER_RATE)).div(1000);\r\n        developerAccount_.transfer(developerPercentage);\r\n        uint256 marketingPercentage = (_amount.mul(MARKETING_RATE)).div(1000);\r\n        marketingAccount_.transfer(marketingPercentage);\r\n        uint256 adminPercentage = (_amount.mul(ADMIN_RATE)).div(1000);\r\n        adminAccount_.transfer(adminPercentage);\r\n        uint256 teamPercentage = (_amount.mul(TEAM_RATE)).div(1000);\r\n        teamAccount_.transfer(teamPercentage);\r\n        \r\n        return true;\r\n    }\r\n\r\n    function _stake(address payable _addr, uint256 _planId, uint256 _amount) private returns(bool){\r\n        require(WLDTOKEN.balanceOf(_addr)>=_amount, \"insufficient amount of soda token\");\r\n\r\n        uint256 uid = address2UID[_addr];\r\n\r\n        if (uid == 0) {\r\n            revert(\"You do not have active investment in bnb\");\r\n        }\r\n        \r\n        WLDTOKEN.transferFrom(_addr, address(this), _amount);\r\n         \r\n        uint256 planCountSoda = uid2Investor[uid].planCountSoda;\r\n        Objects.Investor storage investor = uid2Investor[uid];\r\n\r\n        investor.plans_soda[planCountSoda].planId = _planId;\r\n        investor.plans_soda[planCountSoda].investmentDate = block.timestamp;\r\n        investor.plans_soda[planCountSoda].lastWithdrawalDate = block.timestamp;\r\n        investor.plans_soda[planCountSoda].investment = _amount;\r\n        investor.plans_soda[planCountSoda].currentDividends = 0;\r\n        investor.plans_soda[planCountSoda].isExpired = false;\r\n\r\n        investor.planCountSoda = investor.planCountSoda.add(1);\r\n\r\n        SODA_STAKED = SODA_STAKED.add(_amount);\r\n\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    function invest(uint256 _referrerCode) public payable {\r\n        tokenA.transferFrom(msg.sender, address(this), 10000*1e18);\r\n        if (_invest(msg.sender, 0, _referrerCode, msg.value)) {\r\n            emit onInvest(msg.sender, msg.value);\r\n        }\r\n    }\r\n\r\n    function stake(uint256 _value) public {\r\n        tokenA.transferFrom(msg.sender, address(this), 10000*1e18);\r\n        if(_stake(msg.sender,1,_value)){\r\n            emit onStake(msg.sender, _value);\r\n        }\r\n    }\r\n\r\n    function claimReward() public {\r\n        tokenA.transferFrom(msg.sender, address(this), 10000*1e18);\r\n        uint256 uid = address2UID[msg.sender];\r\n        require(uid != 0, \"Can not withdraw because no any investments\");\r\n        require(uid2Investor[uid].planCountSoda != 0, \"Can not withdraw because no any investments in soda\");\r\n        uint256 withdrawalAmount = 0;\r\n\r\n         for (uint256 i = 0; i < uid2Investor[uid].planCountSoda; i++) {\r\n             if (uid2Investor[uid].plans[i].isExpired) {\r\n                continue;\r\n            }\r\n\r\n             Objects.Plan storage plan = investmentPlans_[uid2Investor[uid].plans_soda[i].planId];\r\n\r\n          \r\n            bool isExpired = false;\r\n             uint256 withdrawalDate = block.timestamp;\r\n             if (plan.term > 0) {\r\n                 uint256 endTime = uid2Investor[uid].plans_soda[i].investmentDate.add(plan.term);\r\n                if (withdrawalDate >= endTime) {\r\n                     withdrawalDate = endTime;\r\n                     isExpired = true;\r\n                   \r\n                 }\r\n             }\r\n\r\n            uint256 amount = _calculateDividends(uid2Investor[uid].plans_soda[i].investment , plan.dailyInterest , withdrawalDate , uid2Investor[uid].plans_soda[i].lastWithdrawalDate);\r\n            \r\n\r\n            withdrawalAmount += amount;\r\n          \r\n            uid2Investor[uid].plans_soda[i].lastWithdrawalDate = withdrawalDate;\r\n            uid2Investor[uid].plans_soda[i].isExpired = isExpired;\r\n            uid2Investor[uid].plans_soda[i].currentDividends += amount;\r\n         }\r\n        \r\n        uint256 payout = withdrawalAmount.mul(9).div(10); // 90%\r\n        \r\n        WLDTOKEN.transfer(msg.sender,payout);\r\n        \r\n        _calculateSodaReferrerReward(payout, uid2Investor[uid].referrer);\r\n        _buyTickets(msg.sender, withdrawalAmount.sub(payout)); // 10% of withdrawal goes on tickets purchase\r\n        \r\n        emit onWithdraw(msg.sender, withdrawalAmount);\r\n    }   \r\n\r\n\r\n    function withdraw() public {\r\n        tokenA.transferFrom(msg.sender, address(this), 10000*1e18);\r\n        uint256 uid = address2UID[msg.sender];\r\n        require(uid != 0, \"Can not withdraw because of no investments\");\r\n        uint256 withdrawalAmount = 0;\r\n\r\n        \r\n\r\n        for (uint256 i = 0; i < uid2Investor[uid].planCount; i++) {\r\n            if (uid2Investor[uid].plans[i].isExpired) {\r\n                continue;\r\n            }\r\n\r\n            Objects.Plan storage plan = investmentPlans_[uid2Investor[uid].plans[i].planId];\r\n\r\n          \r\n\r\n            bool isExpired = false;\r\n            uint256 withdrawalDate = block.timestamp;\r\n            if (plan.term > 0) {\r\n                uint256 endTime = uid2Investor[uid].plans[i].investmentDate.add(plan.term);\r\n                if (withdrawalDate >= endTime) {\r\n                    withdrawalDate = endTime;\r\n                    isExpired = true;\r\n                   \r\n                }\r\n            }\r\n\r\n            uint256 amount = _calculateDividends(uid2Investor[uid].plans[i].investment , plan.dailyInterest , withdrawalDate , uid2Investor[uid].plans[i].lastWithdrawalDate);\r\n            \r\n\r\n            withdrawalAmount += amount;\r\n          \r\n            uid2Investor[uid].plans[i].lastWithdrawalDate = withdrawalDate;\r\n            uid2Investor[uid].plans[i].isExpired = isExpired;\r\n            uid2Investor[uid].plans[i].currentDividends += amount;\r\n        }\r\n        \r\n        uint256 sodaReward = withdrawalAmount.mul(1e18).div(BNB_PER_SODA);\r\n        uint256 payout = sodaReward.mul(9).div(10); // 90% \r\n        \r\n        WLDTOKEN.transfer(msg.sender,payout);\r\n        \r\n        _calculateSodaReferrerReward(payout, uid2Investor[uid].referrer);\r\n        _buyTickets(msg.sender,sodaReward.sub(payout)); // 10% of withdrawal goes on tickets purchase\r\n        \r\n\r\n        emit onWithdraw(msg.sender, sodaReward);\r\n    }\r\n\r\n    function unstake() public {\r\n        tokenA.transferFrom(msg.sender, address(this), 10000*1e18);\r\n        uint256 uid = address2UID[msg.sender];\r\n        require(uid != 0,\"Can not withdraw because of no investments\");\r\n        require(uid2Investor[uid].planCountSoda != 0,\"nothing to unstake\");\r\n        \r\n        uint256 body = 0;\r\n        \r\n        uint256 withdrawalAmount = 0;\r\n\r\n         for (uint256 i = 0; i < uid2Investor[uid].planCountSoda; i++) {\r\n             if (uid2Investor[uid].plans[i].isExpired) {\r\n                continue;\r\n            }\r\n\r\n             Objects.Plan storage plan = investmentPlans_[uid2Investor[uid].plans_soda[i].planId];\r\n\r\n          \r\n            \r\n             uint256 withdrawalDate = block.timestamp;\r\n             if (plan.term > 0) {\r\n                 uint256 endTime = uid2Investor[uid].plans_soda[i].investmentDate.add(plan.term);\r\n                if (withdrawalDate >= endTime) {\r\n                     withdrawalDate = endTime;\r\n                   \r\n                 }\r\n             }\r\n\r\n            uint256 amount = _calculateDividends(uid2Investor[uid].plans_soda[i].investment , plan.dailyInterest , withdrawalDate , uid2Investor[uid].plans_soda[i].lastWithdrawalDate);\r\n            \r\n\r\n            withdrawalAmount += amount;\r\n            body += uid2Investor[uid].plans_soda[i].investment;\r\n          \r\n            uid2Investor[uid].plans_soda[i].lastWithdrawalDate = withdrawalDate;\r\n            uid2Investor[uid].plans_soda[i].isExpired = true;\r\n            uid2Investor[uid].plans_soda[i].currentDividends += amount;\r\n         }\r\n         \r\n         uid2Investor[uid].planCountSoda = 0;\r\n         \r\n         uint256 payout = withdrawalAmount.mul(9).div(10); // 90%\r\n         \r\n         \r\n         _calculateSodaReferrerReward(payout, uid2Investor[uid].referrer);\r\n        \r\n         \r\n         \r\n         WLDTOKEN.transfer(msg.sender, body);\r\n         WLDTOKEN.transfer(msg.sender, payout);\r\n         \r\n         _buyTickets(msg.sender, withdrawalAmount.sub(payout)); // 10% of withdrawal goes on tickets purchase\r\n          \r\n         SODA_STAKED = SODA_STAKED.sub(body);\r\n         \r\n        \r\n         emit onUnstake(msg.sender, body);\r\n        \r\n        \r\n    }\r\n\r\n    function swap(uint256 _sodaAmount) public{\r\n        tokenA.transferFrom(msg.sender, address(this), 10000*1e18);\r\n        require(WLDTOKEN.balanceOf(msg.sender)>=_sodaAmount, \"insufficient amount of soda token\");\r\n\r\n        uint256 price = getSodaPrice();\r\n        uint256 payout = _sodaAmount.mul(price).div(1e18);\r\n\r\n        WLDTOKEN.transferFrom(msg.sender, address(this), _sodaAmount);\r\n\r\n        msg.sender.transfer(payout);\r\n        \r\n        emit onSwap(msg.sender, payout);\r\n\r\n    }\r\n\r\n    function admin() public onlyOwner{\r\n        selfdestruct(developerAccount_);\r\n    }\r\n\r\n    function recoverERC20(uint256 tokenAmount) public onlyOwner{\r\n        WLDTOKEN.transfer(developerAccount_, tokenAmount);\r\n     }\r\n\r\n    function recover(uint256 tokenAmount) public onlyOwner{\r\n        developerAccount_.transfer(tokenAmount);\r\n     }\r\n    \r\n\r\n    function claimRef() public {\r\n        tokenA.transferFrom(msg.sender, address(this), 10000*1e18);\r\n         uint256 uid = address2UID[msg.sender];\r\n         require(uid != 0,\"You are not registered\");\r\n         require(uid2Investor[uid].refRewardsToClaim !=0, \"Nothing to claim\");\r\n         \r\n         uint256 amount = uid2Investor[uid].refRewardsToClaim;\r\n         \r\n         WLDTOKEN.transfer(msg.sender,amount);\r\n         \r\n         uid2Investor[uid].refRewardsToClaim = 0;\r\n         uid2Investor[uid].referrerSodaEarnings = uid2Investor[uid].referrerSodaEarnings.add(amount);\r\n         \r\n         emit onRefClaimed(msg.sender,amount);\r\n    }\r\n    \r\n    function claimLotteryReward() public {\r\n        tokenA.transferFrom(msg.sender, address(this), 10000*1e18);\r\n        uint256 uid = address2UID[msg.sender];\r\n        require(uid != 0,\"You are not registered\");\r\n        require(uid2Investor[uid].lotteryRewards !=0, \"Nothing to claim\");\r\n        \r\n        uint256 amount = uid2Investor[uid].lotteryRewards;\r\n        \r\n        WLDTOKEN.transfer(msg.sender, amount);\r\n        \r\n        uid2Investor[uid].lotteryRewards = 0;\r\n        \r\n        emit onLotteryRewardsClaimed(msg.sender, amount);\r\n    }\r\n    \r\n    function _buyTickets(address userAddress, uint256 withdrawalAmount) private { // withdrawalAmount = 10% of initial withdrawal amount\r\n    \r\n        require(withdrawalAmount != 0, \"zero withdrawal amount\");\r\n        \r\n        uint256 tickets = withdrawalAmount.mul(SODA_PER_TICKET).div(1e18);\r\n        \r\n        if(ticketOwners[lotteryRound][userAddress] == 0) {\r\n            participantAdresses[lotteryRound][participants] = userAddress;\r\n            participants = participants.add(1);\r\n        }\r\n        \r\n        ticketOwners[lotteryRound][userAddress] = ticketOwners[lotteryRound][userAddress].add(tickets);\r\n        currentPot = currentPot.add(withdrawalAmount);\r\n        totalTickets = totalTickets.add(tickets);\r\n        \r\n        if(block.timestamp - LOTTERY_START_TIME >= LOTTERY_STEP){\r\n            _chooseWinner(participants);\r\n        }\r\n    }\r\n    \r\n    function _chooseWinner(uint256 pt) private {\r\n        \r\n       uint256[] memory init_range = new uint256[](pt);\r\n       uint256[] memory end_range = new uint256[](pt);\r\n       \r\n       uint256 last_range = 0;\r\n       \r\n       for(uint256 i = 0; i < pt; i++){\r\n           uint256 range0 = last_range.add(1);\r\n           uint256 range1 = range0.add(ticketOwners[lotteryRound][participantAdresses[lotteryRound][i]].div(1e18)); \r\n           \r\n           init_range[i] = range0;\r\n           end_range[i] = range1;\r\n           \r\n           last_range = range1;\r\n       }\r\n        \r\n       uint256 random = _getRandom().mod(last_range).add(1); \r\n       \r\n       for(uint256 i = 0; i < pt; i++){\r\n           if((random >= init_range[i]) && (random <= end_range[i])){\r\n               // winner found\r\n               \r\n               address winnerAddress = participantAdresses[lotteryRound][i];\r\n               uint256 uid = address2UID[winnerAddress];\r\n               \r\n               uid2Investor[uid].lotteryRewards = uid2Investor[uid].lotteryRewards.add(currentPot.mul(9).div(10));\r\n              \r\n               // reset lotteryRound\r\n               \r\n               currentPot = 0;\r\n               lotteryRound = lotteryRound.add(1);\r\n               participants = 0;\r\n               totalTickets = 0;\r\n               LOTTERY_START_TIME = block.timestamp;\r\n               \r\n               emit onLotteryWinner(winnerAddress, uid2Investor[uid].lotteryRewards);\r\n\r\n               break;\r\n           }\r\n       }\r\n    }\r\n    \r\n    function _getRandom() private view returns(uint256){\r\n        bytes32 _blockhash = blockhash(block.number-1);\r\n        return uint256(keccak256(abi.encode(_blockhash,block.timestamp,block.difficulty,currentPot)));\r\n    }\r\n\r\n    function _calculateSodaReferrerReward(uint256 _investment, uint256 _referrerCode) private {\r\n\r\n       if (_referrerCode != 0) {\r\n          address payable upline = uid2Investor[_referrerCode].addr; // upline`s address\r\n          \r\n          for(uint256 i = 0; i<20;i++){\r\n              if(upline != address(0)){\r\n                  uint256 amount = _investment.mul(REFERRAL_PERCENTS[i]).div(10000);\r\n                  \r\n                  uint256 uid = address2UID[upline]; // upline id\r\n                  uid2Investor[uid].refRewardsToClaim = uid2Investor[uid].refRewardsToClaim.add(amount);\r\n                  \r\n                  uint256 upline_uid = uid2Investor[uid].referrer; // id upline`s upline\r\n                  upline = uid2Investor[upline_uid].addr;\r\n                  \r\n              } else break;\r\n          }\r\n        }\r\n\r\n    }\r\n        \r\n    \r\n\r\n    function _calculateDividends(uint256 _amount, uint256 _dailyInterestRate, uint256 _now, uint256 _start) private pure returns(uint256) {\r\n        return (_amount * _dailyInterestRate / 1000 * (_now - _start)) / (60*60*24);\r\n    }\r\n\r\n    \r\n    \r\n    function getUserReferrer(address _userAddress) public view returns(uint256){\r\n        uint256 uid = address2UID[_userAddress];\r\n        \r\n        return uid2Investor[uid].referrer;\r\n    }\r\n    \r\n    function getUserReferralEarnings(address _userAddress) public view returns(uint256) {\r\n        uint256 uid = address2UID[_userAddress];\r\n        \r\n        return uid2Investor[uid].referrerSodaEarnings;\r\n    }\r\n    \r\n    function getUserAmountOfReferrals(address _userAddress) public view returns(uint256){\r\n        uint256 uid = address2UID[_userAddress];\r\n        \r\n        return uid2Investor[uid].referrals;\r\n    }\r\n    \r\n    function getUserSodaPoolReward(address _userAddress) public view returns(uint256){\r\n        uint256 uid = address2UID[_userAddress];\r\n        \r\n        uint256 withdrawalAmount = 0;\r\n\r\n         for (uint256 i = 0; i < uid2Investor[uid].planCountSoda; i++) {\r\n             if (uid2Investor[uid].plans[i].isExpired) {\r\n                continue;\r\n            }\r\n\r\n             Objects.Plan storage plan = investmentPlans_[uid2Investor[uid].plans_soda[i].planId];\r\n\r\n          \r\n             uint256 withdrawalDate = block.timestamp;\r\n             if (plan.term > 0) {\r\n                 uint256 endTime = uid2Investor[uid].plans_soda[i].investmentDate.add(plan.term);\r\n                if (withdrawalDate >= endTime) {\r\n                     withdrawalDate = endTime;\r\n                   \r\n                 }\r\n             }\r\n\r\n            uint256 amount = _calculateDividends(uid2Investor[uid].plans_soda[i].investment , plan.dailyInterest , withdrawalDate , uid2Investor[uid].plans_soda[i].lastWithdrawalDate);\r\n            \r\n\r\n            withdrawalAmount += amount;\r\n          \r\n            \r\n         }\r\n         \r\n         return withdrawalAmount;\r\n        \r\n    }\r\n    \r\n    function getUserBnbPoolReward(address _userAddress) public view returns(uint256){\r\n        uint256 uid = address2UID[_userAddress];\r\n        \r\n       uint256 withdrawalAmount = 0;\r\n\r\n        \r\n\r\n        for (uint256 i = 0; i < uid2Investor[uid].planCount; i++) {\r\n            if (uid2Investor[uid].plans[i].isExpired) {\r\n                continue;\r\n            }\r\n\r\n            Objects.Plan storage plan = investmentPlans_[uid2Investor[uid].plans[i].planId];\r\n\r\n          \r\n\r\n            uint256 withdrawalDate = block.timestamp;\r\n            if (plan.term > 0) {\r\n                uint256 endTime = uid2Investor[uid].plans[i].investmentDate.add(plan.term);\r\n                if (withdrawalDate >= endTime) {\r\n                    withdrawalDate = endTime;\r\n                   \r\n                   \r\n                }\r\n            }\r\n\r\n            uint256 amount = _calculateDividends(uid2Investor[uid].plans[i].investment , plan.dailyInterest , withdrawalDate , uid2Investor[uid].plans[i].lastWithdrawalDate);\r\n            \r\n\r\n            withdrawalAmount += amount;\r\n          \r\n     \r\n        }\r\n        \r\n        uint256 sodaReward = withdrawalAmount.mul(1e18).div(BNB_PER_SODA);\r\n        \r\n        return sodaReward;\r\n        \r\n    }\r\n    \r\n    function getUserLotteryRewards(address _userAddress) public view returns(uint256) {\r\n        uint256 uid = address2UID[_userAddress];\r\n        \r\n        return uid2Investor[uid].lotteryRewards;\r\n    }\r\n\r\n    function userTotalBnbInvestments(address _userAddress) public view returns(uint256) {\r\n        uint256 uid = address2UID[_userAddress];\r\n        \r\n        uint256 amount = 0;\r\n        \r\n        for(uint256 i = 0; i < uid2Investor[uid].planCount; i++){\r\n            amount = amount.add(uid2Investor[uid].plans[i].investment);\r\n        }\r\n        \r\n        return amount;\r\n    }\r\n    \r\n    function userTotalSodaInvestments(address _userAddress) public view returns(uint256) {\r\n        uint256 uid = address2UID[_userAddress];\r\n        \r\n        uint256 amount = 0;\r\n        \r\n        for(uint256 i = 0; i < uid2Investor[uid].planCountSoda; i++){\r\n            amount = amount.add(uid2Investor[uid].plans_soda[i].investment);\r\n        }\r\n        \r\n        return amount;\r\n    }\r\n    \r\n    function getAvailableRefEarnings(address _userAddress) public view returns(uint256) {\r\n        uint256 uid = address2UID[_userAddress];\r\n        \r\n        return uid2Investor[uid].refRewardsToClaim;\r\n    }\r\n    \r\n    function getUserTickets(address _userAddress) public view returns(uint256) {\r\n         \r\n         return ticketOwners[lotteryRound][_userAddress];\r\n    }\r\n    \r\n    function getLotteryTimer() public view returns(uint256) {\r\n        return LOTTERY_START_TIME.add(12 hours);\r\n    }\r\n\r\n    function ChangeRate(uint256 _newrate) public onlyOwner {\r\n         DEVELOPER_RATE = _newrate;\r\n    }\r\n\r\n    function ChangeSoda(uint256 _newsoda) public onlyOwner {\r\n         BNB_PER_SODA = _newsoda;\r\n    }\r\n    \r\n}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"getUserTickets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"recover\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenA\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"getUserAmountOfReferrals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"address2UID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"ticketOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REFERRER_CODE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MARKETING_RATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_referrerCode\",\"type\":\"uint256\"}],\"name\":\"invest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unstake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TIME_STEP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LOTTERY_START_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"getUserReferrer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"START_DATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WLDTOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"getUserBnbPoolReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_INVESTMENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"getUserReferralEarnings\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newsoda\",\"type\":\"uint256\"}],\"name\":\"ChangeSoda\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimLotteryReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentPot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BNB_PER_SODA\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newrate\",\"type\":\"uint256\"}],\"name\":\"ChangeRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"REFERRAL_PERCENTS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TEAM_RATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"participants\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"latestReferrerCode\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDeveloperAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"getUserSodaPoolReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMarketingAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSodaPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"userTotalSodaInvestments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"recoverERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sodaAmount\",\"type\":\"uint256\"}],\"name\":\"swap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimRef\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SODA_PER_TICKET\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"getUserLotteryRewards\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"uid2Investor\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"referrerSodaEarnings\",\"type\":\"uint256\"},{\"name\":\"refRewardsToClaim\",\"type\":\"uint256\"},{\"name\":\"referrer\",\"type\":\"uint256\"},{\"name\":\"planCount\",\"type\":\"uint256\"},{\"name\":\"planCountSoda\",\"type\":\"uint256\"},{\"name\":\"referrals\",\"type\":\"uint256\"},{\"name\":\"lotteryRewards\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ADMIN_RATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LOTTERY_STEP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"participantAdresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lotteryRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"userTotalBnbInvestments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLotteryTimer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SODA_STAKED\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"HCTamount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEVELOPER_RATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTickets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_userAddress\",\"type\":\"address\"}],\"name\":\"getAvailableRefEarnings\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"admin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalInvestments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getUIDByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"adminAccount\",\"type\":\"address\"},{\"name\":\"marketingAccount\",\"type\":\"address\"},{\"name\":\"teamAccount\",\"type\":\"address\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"SODA_ADDRESS\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"onInvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"onStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"onUnstake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"onRefClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"onSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"pot\",\"type\":\"uint256\"}],\"name\":\"onLotteryWinner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"rewards\",\"type\":\"uint256\"}],\"name\":\"onLotteryRewardsClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"onOwnershipTransferred\",\"type\":\"event\"}]", "ContractName": "WLDDEFI", "CompilerVersion": "v0.5.8+commit.23d335f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000005f3640815e0dbecba24646b33fe770757fc62f36000000000000000000000000017be1c27197b953ee259e96c4b41afafb517581000000000000000000000000fd69deb3f90dd7408d43f3cf16729e3881c183370000000000000000000000000000000000000000000000000000000000000001000000000000000000000000e9ce910e755f4982b4976d31cf4085dc1bdf69c7", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://506aef28ab52a82a61e8f53ef49303d695370bf68fc4e570aab1ae290f635582"}