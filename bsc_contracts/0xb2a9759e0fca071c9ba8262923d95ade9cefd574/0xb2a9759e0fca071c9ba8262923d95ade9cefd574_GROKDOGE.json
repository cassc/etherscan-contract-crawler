{"SourceCode": "/**\r\n _______  ______    _______  _______  _______ \r\n|       ||    _ |  |       ||       ||       |\r\n|    ___||   | ||  |   _   ||    ___||    ___|\r\n|   | __ |   |_||_ |  | |  ||   | __ |   |___ \r\n|   ||  ||    __  ||  |_|  ||   ||  ||    ___|\r\n|   |_| ||   |  | ||       ||   |_| ||   |___ \r\n|_______||___|  |_||_______||_______||_______|        \r\n                                                                                                                                                                    \r\n\ud83d\udcccTelegram : https://t.me/GrokDogeOfficial\r\n\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\n// File: TOKENS/Libraries/IDividendDistributor.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IDividendDistributor {\r\n    function setDistributionCriteria(uint256 _minPeriod, uint256 _minDistribution) external;\r\n    function setShare(address shareholder, uint256 amount) external;\r\n    function deposit() external payable;\r\n    function process(uint256 gas) external;\r\n    function changeTokenReward(address newTokenDividends) external;\r\n    function changeRouter(address _router) external;\r\n    function unstuckToken(address _receiver) external;\r\n}\r\n// File: TOKENS/Libraries/IDEXRouter.sol\r\n\r\ninterface IDEXRouter {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n// File: TOKENS/Libraries/IDEXFactory.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IDEXFactory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n// File: TOKENS/BasicLibraries/IBEP20.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * BEP20 standard interface.\r\n */\r\ninterface IBEP20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function getOwner() external view returns (address);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function burn(uint256 amount) external;\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n// File: TOKENS/BasicLibraries/Context.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: TOKENS/BasicLibraries/Ownable.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n    * @dev Initializes the contract setting the deployer as the initial owner.\r\n    */\r\n    constructor () {\r\n      address msgSender = _msgSender();\r\n      _owner = msgSender;\r\n      emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the address of the current owner.\r\n    */\r\n    function owner() public view returns (address) {\r\n      return _owner;\r\n    }\r\n\r\n    \r\n    modifier onlyOwner() {\r\n      require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n      _;\r\n    }\r\n\r\n    function renounceOwnership() public onlyOwner {\r\n      emit OwnershipTransferred(_owner, address(0));\r\n      _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n      _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal {\r\n      require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n      emit OwnershipTransferred(_owner, newOwner);\r\n      _owner = newOwner;\r\n    }\r\n}\r\n// File: TOKENS/BasicLibraries/SafeMath.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n// File: TOKENS/Libraries/DividendDistributor.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\ncontract DividendDistributor is IDividendDistributor {\r\n    using SafeMath for uint256;\r\n\r\n    address _token;\r\n\r\n    struct Share {\r\n        uint256 amount;\r\n        uint256 totalExcluded;\r\n        uint256 totalRealised;\r\n        uint256 lastReset;\r\n    }\r\n\r\n    // EARN\r\n    IBEP20 public RWRD = IBEP20(0x0000000000000000000000000000000000000000);\r\n    address WBNB = 0x0000000000000000000000000000000000000000;\r\n    IDEXRouter router;\r\n\r\n    address[] shareholders;\r\n    mapping (address => uint256) shareholderIndexes;\r\n    mapping (address => uint256) shareholderClaims;\r\n\r\n    mapping (address => Share) public shares;\r\n\r\n    uint256 public totalShares;\r\n    uint256 public totalDividends;\r\n    uint256 public totalDistributed;\r\n    uint256 public dividendsPerShare;\r\n    uint256 public dividendsPerShareAccuracyFactor = 10 ** 36;\r\n\r\n    uint256 public minPeriod = 30 * 60;\r\n    uint256 public minDistribution = 1 * (10 ** 12);\r\n    uint256 public lastReset;\r\n\r\n    uint256 currentIndex;\r\n\r\n    bool initialized;\r\n    modifier initialization() {\r\n        require(!initialized);\r\n        _;\r\n        initialized = true;\r\n    }\r\n\r\n    modifier onlyToken() {\r\n        require(msg.sender == _token); _;\r\n    }\r\n\r\n    constructor (address _router, address _WBNB) {\r\n        WBNB = _WBNB;\r\n        router = _router != address(0)\r\n            ? IDEXRouter(_router)\r\n            : IDEXRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n        _token = msg.sender;\r\n    }\r\n\r\n    function setDistributionCriteria(uint256 _minPeriod, uint256 _minDistribution) external override onlyToken {\r\n        minPeriod = _minPeriod;\r\n        minDistribution = _minDistribution;\r\n    }\r\n\r\n    function setShare(address shareholder, uint256 amount) external override onlyToken {\r\n        if(shares[shareholder].amount > 0){\r\n            distributeDividend(shareholder);\r\n        }\r\n\r\n        if(amount > 0 && shares[shareholder].amount == 0){\r\n            addShareholder(shareholder);\r\n        }else if(amount == 0 && shares[shareholder].amount > 0){\r\n            removeShareholder(shareholder);\r\n        }\r\n\r\n        totalShares = totalShares.sub(shares[shareholder].amount).add(amount);\r\n        shares[shareholder].amount = amount;\r\n        shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount);\r\n    }\r\n\r\n    function deposit() external payable override onlyToken {\r\n        uint256 balanceBefore = RWRD.balanceOf(address(this));\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = WBNB;\r\n        path[1] = address(RWRD);\r\n\r\n        router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: msg.value}(\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n\r\n        uint256 amount = RWRD.balanceOf(address(this)).sub(balanceBefore);\r\n\r\n        totalDividends = totalDividends.add(amount);\r\n        dividendsPerShare = dividendsPerShare.add(dividendsPerShareAccuracyFactor.mul(amount).div(totalShares));\r\n    }\r\n\r\n    function process(uint256 gas) external override onlyToken {\r\n        uint256 shareholderCount = shareholders.length;\r\n\r\n        if(shareholderCount == 0) { return; }\r\n\r\n        uint256 gasUsed = 0;\r\n        uint256 gasLeft = gasleft();\r\n\r\n        uint256 iterations = 0;\r\n\r\n        while(gasUsed < gas && iterations < shareholderCount) {\r\n            if(currentIndex >= shareholderCount){\r\n                currentIndex = 0;\r\n            }\r\n\r\n            if(shouldDistribute(shareholders[currentIndex])){\r\n                distributeDividend(shareholders[currentIndex]);\r\n            }\r\n\r\n            gasUsed = gasUsed.add(gasLeft.sub(gasleft()));\r\n            gasLeft = gasleft();\r\n            currentIndex++;\r\n            iterations++;\r\n        }\r\n    }\r\n    \r\n    function shouldDistribute(address shareholder) internal view returns (bool) {\r\n        return shareholderClaims[shareholder] + minPeriod < block.timestamp\r\n                && getUnpaidEarnings(shareholder) > minDistribution;\r\n    }\r\n\r\n    function distributeDividend(address shareholder) internal {\r\n        if(shares[shareholder].amount == 0){ return; }\r\n\r\n        if(shares[shareholder].lastReset != lastReset) {\r\n            shares[shareholder].lastReset = lastReset;\r\n            shares[shareholder].totalRealised = 0;\r\n            shares[shareholder].totalExcluded = 0;\r\n        }\r\n\r\n        uint256 amount = getUnpaidEarnings(shareholder);\r\n        if(amount > 0){\r\n            totalDistributed = totalDistributed.add(amount);\r\n            RWRD.transfer(shareholder, amount);\r\n            shareholderClaims[shareholder] = block.timestamp;\r\n            shares[shareholder].totalRealised = shares[shareholder].totalRealised.add(amount);\r\n            shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount);\r\n        }\r\n    }\r\n    \r\n    function claimDividend(address shareholder) external onlyToken{\r\n        distributeDividend(shareholder);\r\n    }\r\n\r\n    function getUnpaidEarnings(address shareholder) public view returns (uint256) {\r\n        if(shares[shareholder].amount == 0){ return 0; }\r\n\r\n        uint256 shareholderTotalDividends = getCumulativeDividends(shares[shareholder].amount);\r\n        uint256 shareholderTotalExcluded = shares[shareholder].totalExcluded;\r\n\r\n        if(shareholderTotalDividends <= shareholderTotalExcluded){ return 0; }\r\n\r\n        return shareholderTotalDividends.sub(shareholderTotalExcluded);\r\n    }\r\n\r\n    function getCumulativeDividends(uint256 share) internal view returns (uint256) {\r\n        return share.mul(dividendsPerShare).div(dividendsPerShareAccuracyFactor);\r\n    }\r\n\r\n    function addShareholder(address shareholder) internal {\r\n        shareholderIndexes[shareholder] = shareholders.length;\r\n        shareholders.push(shareholder);\r\n    }\r\n\r\n    function removeShareholder(address shareholder) internal {\r\n        shareholders[shareholderIndexes[shareholder]] = shareholders[shareholders.length-1];\r\n        shareholderIndexes[shareholders[shareholders.length-1]] = shareholderIndexes[shareholder];\r\n        shareholders.pop();\r\n    }\r\n\r\n    function reset() internal {\r\n        lastReset = block.timestamp;\r\n        totalDividends = 0;\r\n        totalDistributed = 0; \r\n        dividendsPerShare = 0;\r\n    }\r\n\r\n    function changeTokenReward(address newTokenDividends) external override onlyToken {\r\n        RWRD = IBEP20(newTokenDividends);\r\n        reset();\r\n    }\r\n\r\n    function changeRouter(address _router) external override onlyToken {\r\n        router = IDEXRouter(_router);\r\n    }\r\n\r\n    function unstuckToken(address _receiver) external override onlyToken {\r\n        uint256 amount = RWRD.balanceOf(address(this));\r\n        RWRD.transfer(_receiver, amount);\r\n    }    \r\n}\r\n// File: TOKENS/Test.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\ncontract GROKDOGE is Ownable, IBEP20 {\r\n    using SafeMath for uint256;\r\n\r\n    event AutoLiquify(uint256 amountBNB, uint256 amountTokens);\r\n\r\n    address WETH;\r\n    address DEAD = 0x000000000000000000000000000000000000dEaD;\r\n    address ZERO = 0x0000000000000000000000000000000000000000;\r\n    address routerAdr = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\r\n\r\n    string constant _name = \"GROK DOGE\";\r\n    string constant _symbol = \"GROGE\";\r\n    uint8 constant _decimals = 9;\r\n\r\n    \r\n    uint256 _totalSupply = 1 * 10**6 * 10**_decimals;\r\n\r\n    // 2%\r\n    uint256 public _maxTxAmount = _totalSupply.mul(2).div(100);\r\n    uint256 public _maxWalletToken = _totalSupply.mul(2).div(100);\r\n\r\n    mapping (address => uint256) _balances;\r\n    mapping (address => mapping (address => uint256)) _allowances;\r\n        \r\n    mapping (address => bool) isFeeExempt;\r\n    mapping (address => bool) isDividendExempt;\r\n    mapping (address => bool) isTxLimitExempt;\r\n\r\n    // 50/1000 5%\r\n    uint256 private sellTreasuryFee     = 150;\r\n    uint256 private sellLiquidityFee    = 100;  \r\n    uint256 private sellBurnFee         = 0;       \r\n    uint256 private sellRewardsFee      = 0;\r\n    uint256 private sellBuybackFee      = 0;\r\n    uint256 public sellTotalFeeBase1000 = sellTreasuryFee + sellLiquidityFee + sellRewardsFee + sellBuybackFee + sellBurnFee;\r\n\r\n    uint256 private buyTreasuryFee     = 150;\r\n    uint256 private buyLiquidityFee    = 100;  \r\n    uint256 private buyBurnFee         = 0;       \r\n    uint256 private buyRewardsFee      = 0;\r\n    uint256 private buyBuybackFee      = 0;\r\n    uint256 public buyTotalFeeBase1000 = buyTreasuryFee + buyLiquidityFee + buyRewardsFee + buyBuybackFee + buyBurnFee;\r\n\r\n    uint256 public feeDenominator   = 1000;\r\n\r\n    address private autoLiquidityReceiver;\r\n    address private treasuryFeeReceiver;\r\n    address private buybackFeeReceiver;\r\n\r\n    // 40% of supply\r\n    uint256 targetLiquidity = 80; \r\n    uint256 targetLiquidityDenominator = 100;\r\n\r\n    IDEXRouter public router;\r\n    address public initialPair;\r\n    mapping(address => bool) public isPair;\r\n\r\n    mapping(address => bool) public hasBought;\r\n    mapping(address => uint256) public firstBuy;\r\n   \r\n    address public distributorAdr = address(0);\r\n    DividendDistributor distributor;\r\n    uint256 distributorGas = 500000;\r\n    \r\n    bool public swapEnabled = true;\r\n    bool alternateSwaps = true; \r\n    uint256 smallSwapThreshold = _totalSupply * 142 / 10000;\r\n    uint256 largeSwapThreshold = _totalSupply * 172 / 10000; \r\n    uint256 public swapThreshold = smallSwapThreshold;\r\n    bool inSwap;\r\n    modifier swapping() { inSwap = true; _; inSwap = false; }\r\n\r\n    constructor () {\r\n        router = IDEXRouter(routerAdr);     \r\n        WETH = router.WETH();\r\n        initialPair = IDEXFactory(router.factory()).createPair(WETH, address(this));\r\n        isPair[initialPair] = true;\r\n        \r\n        _allowances[address(this)][address(router)] = type(uint256).max;\r\n        _allowances[address(this)][msg.sender] = type(uint256).max;\r\n\r\n        distributor = new DividendDistributor(address(router), WETH);\r\n        distributorAdr = address(distributor);\r\n        //isDividendExempt[pair] = true;\r\n        isDividendExempt[address(this)] = true;\r\n        isDividendExempt[DEAD] = true;\r\n        isDividendExempt[ZERO] = true;\r\n\r\n        autoLiquidityReceiver = msg.sender;\r\n        treasuryFeeReceiver = msg.sender;\r\n        buybackFeeReceiver = msg.sender;\r\n\r\n        isFeeExempt[msg.sender] = true;\r\n        isFeeExempt[DEAD] = true;\r\n        isFeeExempt[ZERO] = true;\r\n\r\n        isTxLimitExempt[msg.sender] = true;        \r\n        isTxLimitExempt[DEAD] = true;\r\n        isTxLimitExempt[ZERO] = true;\r\n        //isTxLimitExempt[pair] = true;\r\n\r\n        _balances[msg.sender] = _totalSupply;\r\n        emit Transfer(address(0), msg.sender, _totalSupply);\r\n    }\r\n\r\n    receive() external payable { }\r\n\r\n    function totalSupply() external view override returns (uint256) { return _totalSupply; }\r\n    function decimals() external pure override returns (uint8) { return _decimals; }\r\n    function symbol() external pure override returns (string memory) { return _symbol; }\r\n    function name() external pure override returns (string memory) { return _name; }\r\n    function getOwner() external view override returns (address) {return owner();}\r\n    function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }\r\n    function allowance(address holder, address spender) external view override returns (uint256) { return _allowances[holder][spender]; }    \r\n\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function approveMax(address spender) external returns (bool) {\r\n        return approve(spender, type(uint256).max);\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        return _transferFrom(msg.sender, recipient, amount);\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\r\n        if(_allowances[sender][msg.sender] != type(uint256).max){\r\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(amount, \"Insufficient Allowance\");\r\n        }\r\n\r\n        return _transferFrom(sender, recipient, amount);\r\n    }\r\n\r\n    function transferBulk(address [] calldata addresses, uint256 [] calldata amounts) external {\r\n        require(addresses.length == amounts.length, 'Arrays of different size');\r\n        require(addresses.length < 501,\"GAS Error: max limit is 500 addresses\");\r\n        for (uint256 i; i < addresses.length; ++i) {\r\n            _transferFrom(msg.sender, addresses[i], amounts[i]);\r\n        }\r\n    }\r\n\r\n    function burn(uint256 amount) external override {\r\n        _burn(msg.sender, amount);\r\n    }\r\n\r\n    function _burn(address _sender, uint256 amount) internal {\r\n        _transferFrom(_sender, DEAD, amount);\r\n    }\r\n\r\n    function setMaxWalletPercent_base1000(uint256 maxWallPercent_base1000) external onlyOwner {\r\n        require(maxWallPercent_base1000 >= 1,\"Cannot set max wallet less than 0.1%\");\r\n        _maxWalletToken = (_totalSupply * maxWallPercent_base1000 ) / 1000;\r\n    }\r\n\r\n    function setMaxTxPercent_base1000(uint256 maxTXPercentage_base1000) external onlyOwner {\r\n        require(maxTXPercentage_base1000 >= 1,\"Cannot set max transaction less than 0.1%\");\r\n        _maxTxAmount = (_totalSupply * maxTXPercentage_base1000 ) / 1000;\r\n    }\r\n    \r\n    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        if(inSwap) { return _basicTransfer(sender, recipient, amount); }      \r\n        \r\n        if(recipient != address(this) && recipient != address(DEAD) && !isPair[recipient] && recipient != treasuryFeeReceiver && !isTxLimitExempt[recipient]) {\r\n            uint256 heldTokens = balanceOf(recipient);\r\n            require((heldTokens + amount) <= _maxWalletToken,\"Total Holding is currently limited, you can not buy that much.\");\r\n        }\r\n\r\n        if(!hasBought[recipient] && isPair[sender]) {\r\n            hasBought[recipient] = true;\r\n            firstBuy[recipient] = amount;\r\n        }\r\n\r\n        checkTxLimit(sender, amount);\r\n\r\n        if(shouldSwapBack()) { swapBack(); }\r\n       \r\n        _balances[sender] = _balances[sender].sub(amount, \"Insufficient Balance\");\r\n         uint256 amountReceived = (isFeeExempt[sender] || isFeeExempt[recipient]) ? amount : takeFee(sender, amount, recipient);\r\n        _balances[recipient] = _balances[recipient].add(amountReceived);\r\n\r\n        // Dividend tracker //\r\n        if(!isDividendExempt[sender] && !isPair[sender]) {\r\n            try distributor.setShare(sender, _balances[sender]) {} catch {}\r\n        }\r\n\r\n        if(!isDividendExempt[recipient] && !isPair[sender]) {\r\n            try distributor.setShare(recipient, _balances[recipient]) {} catch {} \r\n        }\r\n\r\n        if(sellRewardsFee > 0) {\r\n            try distributor.process(distributorGas) {} catch {}\r\n        }\r\n        \r\n\r\n        emit Transfer(sender, recipient, amountReceived);\r\n        return true;\r\n    }\r\n    \r\n    function _basicTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        _balances[sender] = _balances[sender].sub(amount, \"Insufficient Balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function checkTxLimit(address sender, uint256 amount) internal view {\r\n        require(amount <= _maxTxAmount || isTxLimitExempt[sender] || isPair[sender], \"TX Limit Exceeded\");\r\n    }\r\n\r\n    function shouldTakeFee(address sender) internal view returns (bool) {\r\n        return !isFeeExempt[sender];\r\n    }\r\n\r\n    function takeFee(address sender, uint256 amount, address recipient) internal returns (uint256) {\r\n\r\n        uint256 _totalFeeBase1000 = sellTotalFeeBase1000;\r\n        uint256 _burnFee = sellBurnFee;\r\n        if(isPair[recipient]) {\r\n            //_totalFeeBase1000 = sellTotalFeeBase1000\r\n            //_burnFee = sellBurnFee;\r\n        } else if(isPair[sender]) { // Buy\r\n            _totalFeeBase1000 = buyTotalFeeBase1000;\r\n            _burnFee = buyBurnFee;\r\n        }\r\n\r\n        uint256 feeAmount = amount.mul(_totalFeeBase1000).div(feeDenominator);\r\n        if(_totalFeeBase1000 > 0) {\r\n            uint256 burnTokens = feeAmount.mul(_burnFee).div(_totalFeeBase1000);\r\n            uint256 contractTokens = feeAmount.sub(burnTokens);\r\n\r\n            _balances[address(this)] = _balances[address(this)].add(contractTokens);\r\n            _balances[DEAD] = _balances[DEAD].add(burnTokens);\r\n            emit Transfer(sender, address(this), contractTokens);\r\n            \r\n            if(burnTokens > 0){\r\n                emit Transfer(sender, DEAD, burnTokens);    \r\n            }\r\n        }\r\n\r\n        return amount.sub(feeAmount);\r\n    }\r\n\r\n    function shouldSwapBack() internal view returns (bool) {\r\n        return !isPair[msg.sender]\r\n        && !inSwap\r\n        && swapEnabled\r\n        && _balances[address(this)] >= swapThreshold;    \r\n    }\r\n\r\n    function clearStuckToken(address tokenAddress, uint256 tokens) public onlyOwner returns (bool) {\r\n        require(tokenAddress != address(this), 'You can not withdraw the native token');\r\n        if(tokens == 0){\r\n            tokens = IBEP20 (tokenAddress).balanceOf(address(this));\r\n        }\r\n        return IBEP20 (tokenAddress).transfer(msg.sender, tokens);\r\n    }\r\n\r\n    function ClearStuckBalance() external onlyOwner { \r\n        payable(msg.sender).transfer(address(this).balance);        \r\n    }\r\n\r\n    function swapBack() internal swapping {\r\n        uint256 totalFeeSwapback = sellTotalFeeBase1000.sub(sellBurnFee); //already applied on transfers\r\n        if(totalFeeSwapback == 0) return;\r\n        uint256 dynamicLiquidityFee = isOverLiquified(targetLiquidity, targetLiquidityDenominator) ? 0 : sellLiquidityFee;\r\n        uint256 amountToLiquify = swapThreshold.mul(dynamicLiquidityFee).div(totalFeeSwapback).div(2);\r\n        uint256 amountToSwap = swapThreshold.sub(amountToLiquify);\r\n        \r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = WETH;\r\n\r\n        uint256 balanceBefore = address(this).balance;\r\n\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            amountToSwap,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n\r\n        uint256 amountBNB = address(this).balance.sub(balanceBefore);\r\n        uint256 totalBNBFee = totalFeeSwapback.sub(dynamicLiquidityFee.div(2));\r\n        \r\n        if(totalBNBFee > 0) {\r\n            uint256 amountBNBLiquidity = amountBNB.mul(dynamicLiquidityFee).div(totalBNBFee).div(2);\r\n            uint256 amountBNBTreasury = amountBNB.mul(sellTreasuryFee).div(totalBNBFee);\r\n            uint256 amountBNBbuyback = amountBNB.mul(sellBuybackFee).div(totalBNBFee);\r\n            uint256 amountBNBRewards = amountBNB.mul(sellRewardsFee).div(totalBNBFee);\r\n\r\n            bool tmpSuccess = payable(treasuryFeeReceiver).send(amountBNBTreasury);\r\n            tmpSuccess = payable(buybackFeeReceiver).send(amountBNBbuyback);\r\n            if(amountBNBRewards > 0){\r\n                try distributor.deposit{value: amountBNBRewards}() {} catch {}\r\n            }           \r\n            tmpSuccess = false;\r\n\r\n            addLiq(amountToLiquify, amountBNBLiquidity);\r\n        }\r\n\r\n        swapThreshold = !alternateSwaps ? swapThreshold : swapThreshold == smallSwapThreshold ? largeSwapThreshold : smallSwapThreshold;\r\n    }\r\n\r\n    function addLiq(uint256 tokens, uint256 _value) internal {\r\n        if(tokens > 0){\r\n            router.addLiquidityETH{value: _value}(\r\n                address(this),\r\n                tokens,\r\n                0,\r\n                0,\r\n                autoLiquidityReceiver,\r\n                block.timestamp\r\n            );\r\n            emit AutoLiquify(_value, tokens);\r\n        }\r\n    }\r\n\r\n    function SetIsFeeExempt(address[] calldata addresses, bool status) external onlyOwner {\r\n        _SetIsFeeExempt(addresses, status);\r\n    }\r\n\r\n    function _SetIsFeeExempt(address[] memory addresses, bool status) internal {\r\n        require(addresses.length < 501,\"GAS Error: max limit is 500 addresses\");\r\n        for (uint256 i; i < addresses.length; ++i) {\r\n            isFeeExempt[addresses[i]] = status;\r\n        }\r\n    }\r\n\r\n    function SetIsTxLimitExempt(address[] calldata addresses, bool status) external onlyOwner { //TXLimit Exempt will also Wallet Limit Exempt\r\n        _SetIsTxLimitExempt(addresses, status);\r\n    }\r\n\r\n    function addLiqPair(address liqPair, bool isLiqPair) external onlyOwner {\r\n        require(initialPair != liqPair, \"You can not edit the initial liq pair\");\r\n        isPair[liqPair] = isLiqPair;\r\n    }\r\n\r\n    function _SetIsTxLimitExempt(address[] memory addresses, bool status) internal {\r\n        require(addresses.length < 501,\"GAS Error: max limit is 500 addresses\");\r\n        for (uint256 i; i < addresses.length; ++i) {\r\n            isTxLimitExempt[addresses[i]] = status;\r\n        }\r\n    }\r\n\r\n    function setSellFees(\r\n        uint256 _sellLiquidityFee, \r\n        uint256 _sellTreasuryFee, \r\n        uint256 _sellBuybackFee, \r\n        uint256 _sellRewardsFee, \r\n        uint256 _sellBurnFee\r\n        ) external onlyOwner {\r\n            sellLiquidityFee = _sellLiquidityFee;\r\n            sellTreasuryFee = _sellTreasuryFee;\r\n            sellBuybackFee = _sellBuybackFee;\r\n            sellRewardsFee = _sellRewardsFee;\r\n            sellBurnFee = _sellBurnFee;\r\n\r\n            sellTotalFeeBase1000 = _sellLiquidityFee;\r\n            sellTotalFeeBase1000 += _sellTreasuryFee;\r\n            sellTotalFeeBase1000 += _sellBuybackFee;\r\n            sellTotalFeeBase1000 += _sellRewardsFee;\r\n            sellTotalFeeBase1000 += _sellBurnFee;\r\n            require(sellTotalFeeBase1000 <= 400, \"Fees cannot be more than 40%\");\r\n    }\r\n\r\n    function setBuyFees(\r\n        uint256 _buyLiquidityFee,  \r\n        uint256 _buyTreasuryFee, \r\n        uint256 _buyBuybackFee, \r\n        uint256 _buyRewardsFee, \r\n        uint256 _buyBurnFee\r\n        ) external onlyOwner {\r\n            buyLiquidityFee = _buyLiquidityFee;\r\n            buyTreasuryFee = _buyTreasuryFee;\r\n            buyBuybackFee = _buyBuybackFee;\r\n            buyRewardsFee = _buyRewardsFee;\r\n            buyBurnFee = _buyBurnFee;\r\n\r\n            buyTotalFeeBase1000 = _buyLiquidityFee;\r\n            buyTotalFeeBase1000 += _buyTreasuryFee;\r\n            buyTotalFeeBase1000 += _buyBuybackFee;\r\n            buyTotalFeeBase1000 += _buyRewardsFee;\r\n            buyTotalFeeBase1000 += _buyBurnFee;\r\n            require(buyTotalFeeBase1000 <= 400, \"Fees cannot be more than 40%\");\r\n    }\r\n\r\n    function setFeeReceivers(\r\n        address _autoLiquidityReceiver, \r\n        address _treasuryFeeReceiver, \r\n        address _buybackFeeReceiver\r\n        ) external onlyOwner {\r\n            autoLiquidityReceiver = _autoLiquidityReceiver;\r\n            treasuryFeeReceiver = _treasuryFeeReceiver;\r\n            buybackFeeReceiver = _buybackFeeReceiver;\r\n\r\n            uint256 s = 8;\r\n            address[] memory receivers = new address[](s);\r\n            receivers[0] = autoLiquidityReceiver;\r\n            receivers[1] = treasuryFeeReceiver;\r\n            receivers[2] = buybackFeeReceiver;\r\n\r\n            _SetIsFeeExempt(receivers, true);\r\n            _SetIsTxLimitExempt(receivers, true);\r\n    }\r\n\r\n    function setSwapBackSettings(bool _enabled, uint256 _amountS, uint256 _amountL, bool _alternate) external onlyOwner {\r\n        swapEnabled = _enabled;\r\n        alternateSwaps = _alternate;\r\n        smallSwapThreshold = _amountS;\r\n        largeSwapThreshold = _amountL;\r\n        swapThreshold = smallSwapThreshold;\r\n    }\r\n\r\n    function setTargetLiquidity(uint256 _target, uint256 _denominator) external onlyOwner {\r\n        targetLiquidity = _target;\r\n        targetLiquidityDenominator = _denominator;\r\n    }   \r\n    \r\n    function getCirculatingSupply() public view returns (uint256) {\r\n        return _totalSupply.sub(balanceOf(DEAD)).sub(balanceOf(ZERO));\r\n    }\r\n\r\n    function getLiquidityBacking(uint256 accuracy) public view returns (uint256) {\r\n        return accuracy.mul(balanceOf(initialPair).mul(2)).div(getCirculatingSupply());\r\n    }\r\n\r\n    function isOverLiquified(uint256 target, uint256 accuracy) public view returns (bool) {\r\n        return getLiquidityBacking(accuracy) > target;  \r\n    }  \r\n\r\n    // Rewards //\r\n    function changeDistributor(address newDistributor) external onlyOwner {\r\n        require(isContract(newDistributor), \"Address has to be a contract\");\r\n        distributorAdr = newDistributor;\r\n        distributor = DividendDistributor(distributorAdr);\r\n    }\r\n\r\n    function changeTokenReward(address tokenReward) external onlyOwner {\r\n        require(isContract(tokenReward), \"Address has to be a contract\");\r\n        distributor.changeTokenReward(tokenReward);\r\n    }  \r\n\r\n    function setIsDividendExempt(address holder, bool exempt) external onlyOwner {\r\n        require(holder != address(this) && !isPair[holder]);\r\n        isDividendExempt[holder] = exempt;\r\n        if(exempt){\r\n            distributor.setShare(holder, 0);\r\n        }else{\r\n            distributor.setShare(holder, _balances[holder]);\r\n        }\r\n    }\r\n\r\n    function setDistributionCriteria(uint256 _minPeriod, uint256 _minDistribution) external onlyOwner {\r\n        distributor.setDistributionCriteria(_minPeriod, _minDistribution);\r\n    }    \r\n\r\n    function setRouterDividends(address _router) external onlyOwner {\r\n        require(isContract(_router), \"Address has to be a contract\");\r\n        distributor.changeRouter(_router);\r\n    }\r\n\r\n    function unstuckRewards() external onlyOwner {\r\n        distributor.unstuckToken(msg.sender);\r\n    }  \r\n\r\n    function isContract(address account) internal view returns (bool) { return account.code.length > 0; }\r\n    \r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountBNB\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountTokens\",\"type\":\"uint256\"}],\"name\":\"AutoLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ClearStuckBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"SetIsFeeExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"SetIsTxLimitExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxWalletToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"liqPair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isLiqPair\",\"type\":\"bool\"}],\"name\":\"addLiqPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"approveMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTotalFeeBase1000\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDistributor\",\"type\":\"address\"}],\"name\":\"changeDistributor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenReward\",\"type\":\"address\"}],\"name\":\"changeTokenReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"clearStuckToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributorAdr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"firstBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accuracy\",\"type\":\"uint256\"}],\"name\":\"getLiquidityBacking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasBought\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"target\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accuracy\",\"type\":\"uint256\"}],\"name\":\"isOverLiquified\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isPair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellTotalFeeBase1000\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_buyLiquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_buyTreasuryFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_buyBuybackFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_buyRewardsFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_buyBurnFee\",\"type\":\"uint256\"}],\"name\":\"setBuyFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minDistribution\",\"type\":\"uint256\"}],\"name\":\"setDistributionCriteria\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_autoLiquidityReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasuryFeeReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_buybackFeeReceiver\",\"type\":\"address\"}],\"name\":\"setFeeReceivers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsDividendExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxTXPercentage_base1000\",\"type\":\"uint256\"}],\"name\":\"setMaxTxPercent_base1000\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxWallPercent_base1000\",\"type\":\"uint256\"}],\"name\":\"setMaxWalletPercent_base1000\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"}],\"name\":\"setRouterDividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_sellLiquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sellTreasuryFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sellBuybackFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sellRewardsFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sellBurnFee\",\"type\":\"uint256\"}],\"name\":\"setSellFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_amountS\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountL\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_alternate\",\"type\":\"bool\"}],\"name\":\"setSwapBackSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_target\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_denominator\",\"type\":\"uint256\"}],\"name\":\"setTargetLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"transferBulk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstuckRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "GROKDOGE", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://92beba05ba222924bec2d491a1c3fd6a852fb73033c0909bb4d117f200a1b409"}