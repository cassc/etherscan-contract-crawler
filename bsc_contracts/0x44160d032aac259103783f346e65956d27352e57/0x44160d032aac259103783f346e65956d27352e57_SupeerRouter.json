{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\n/*\r\n----------------------------------------------------------------------------\r\nSupeer Router | Ethereum, Avalanche, Polygon, BNB\r\n----------------------------------------------------------------------------\r\nVersion: 1.0.0\r\nAuthor: 0xYonga | https://twitter.com/0xYonga | cto@supeer.tech\r\nNote: If you initiate transactions within the contract directly, you may lose your assets. Please use supeer.tech itself for any actions.\r\n----------------------------------------------------------------------------\r\n*/\r\n\r\n// File: @openzeppelin/contracts/security/ReentrancyGuard.sol\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\r\n     * `nonReentrant` function in the call stack.\r\n     */\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _status == _ENTERED;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/math/SafeMath.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// CAUTION\r\n// This version of SafeMath should only be used with Solidity 0.8 or later,\r\n// because it relies on the compiler's built in overflow checks.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\n// File: Supeer/SupeerRouter.sol\r\n\r\n\r\npragma solidity ^0.8.18;\r\n\r\n\r\n\r\ncontract SupeerRouter is ReentrancyGuard {\r\n    /*\r\n    ----------------------------------------------------------------------------\r\n    Supeer Router | Ethereum, Avalanche, Polygon, BNB\r\n    ----------------------------------------------------------------------------\r\n    Version: 1.0.0\r\n    Author: 0xYonga | https://twitter.com/0xYonga | cto@supeer.tech\r\n    Note: If you initiate transactions within the contract directly, you may lose your assets. Please use supeer.tech itself for any actions.\r\n    ----------------------------------------------------------------------------\r\n    */\r\n\r\n    using SafeMath for uint256;\r\n\r\n    enum ProcessTypes {\r\n        ticketMint,\r\n        ticketMarket,\r\n        gift,\r\n        peerSale,\r\n        exclusivePeerSale,\r\n        adSpace\r\n    }\r\n\r\n    struct Percents {\r\n        uint256 sellerPercent;\r\n        uint256 originalOwnerPercent;\r\n        uint256 teamPercent;\r\n        uint256 airdropPercent;\r\n        uint256 referralPercent;\r\n    }\r\n\r\n    mapping(ProcessTypes => Percents) public percents;\r\n\r\n    address public teamAddress;\r\n    address public airdropAddress;\r\n    address public admin;\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"Only admin can call this function.\");\r\n        _;\r\n    }\r\n\r\n    event SentCoin(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 amount,\r\n        ProcessTypes processType\r\n    );\r\n\r\n    constructor(\r\n        address _teamAddress,\r\n        address _airdropAddress,\r\n        address _admin\r\n    ) {\r\n        teamAddress = _teamAddress;\r\n        airdropAddress = _airdropAddress;\r\n        admin = _admin;\r\n\r\n        percents[ProcessTypes.ticketMint] = Percents(90, 0, 7, 2, 1);\r\n        percents[ProcessTypes.ticketMarket] = Percents(90, 5, 4, 0, 1);\r\n        percents[ProcessTypes.gift] = Percents(90, 0, 7, 2, 1);\r\n        percents[ProcessTypes.peerSale] = Percents(60, 0, 40, 0, 0);\r\n        percents[ProcessTypes.exclusivePeerSale] = Percents(90, 0, 10, 0, 0);\r\n        percents[ProcessTypes.adSpace] = Percents(60, 0, 40, 0, 0);\r\n    }\r\n\r\n    function sendCoin(\r\n        address payable _recipient,\r\n        address payable _originalOwner,\r\n        address payable _referral,\r\n        ProcessTypes _processType\r\n    ) external payable nonReentrant {\r\n        require(\r\n            _recipient != address(0),\r\n            \"You cannot use a zero address for recipient.\"\r\n        );\r\n\r\n        if (_processType == ProcessTypes.ticketMarket) {\r\n            require(\r\n                _originalOwner != address(0),\r\n                \"You cannot use a zero address for originalOwner.\"\r\n            );\r\n        }\r\n\r\n        uint256 amount = msg.value;\r\n        Percents memory processPercent = percents[_processType];\r\n\r\n        uint256 sellerAmount = amount.mul(processPercent.sellerPercent).div(\r\n            100\r\n        );\r\n        uint256 teamAmount = amount.mul(processPercent.teamPercent).div(100);\r\n        uint256 originalOwnerAmount = amount\r\n            .mul(processPercent.originalOwnerPercent)\r\n            .div(100);\r\n        uint256 airdropAmount = amount.mul(processPercent.airdropPercent).div(\r\n            100\r\n        );\r\n        uint256 referralAmount = amount.mul(processPercent.referralPercent).div(\r\n            100\r\n        );\r\n\r\n        // If referral is zero address, add referralAmount to teamAmount\r\n        if (_referral == address(0)) {\r\n            teamAmount = teamAmount.add(referralAmount);\r\n            referralAmount = 0;\r\n        }\r\n\r\n        (bool recipientSent, ) = _recipient.call{value: sellerAmount}(\"\");\r\n        require(recipientSent, \"Failed to send to recipient.\");\r\n\r\n        (bool teamSent, ) = teamAddress.call{value: teamAmount}(\"\");\r\n        require(teamSent, \"Failed to send to team.\");\r\n\r\n        if (originalOwnerAmount > 0) {\r\n            (bool originalOwnerSent, ) = _originalOwner.call{\r\n                value: originalOwnerAmount\r\n            }(\"\");\r\n            require(originalOwnerSent, \"Failed to send to original owner.\");\r\n        }\r\n\r\n        if (airdropAmount > 0) {\r\n            (bool airdropSent, ) = airdropAddress.call{value: airdropAmount}(\r\n                \"\"\r\n            );\r\n            require(airdropSent, \"Failed to sent to airdrop.\");\r\n        }\r\n\r\n        if (referralAmount > 0) {\r\n            (bool referralSent, ) = _referral.call{value: referralAmount}(\"\");\r\n            require(referralSent, \"Failed to sent to referral.\");\r\n        }\r\n\r\n        emit SentCoin(msg.sender, _recipient, amount, _processType);\r\n    }\r\n\r\n    function setTeamAddress(address _newTeamAddress) external onlyAdmin {\r\n        teamAddress = _newTeamAddress;\r\n    }\r\n\r\n    function setAirdropAddress(address _newAirdropAddress) external onlyAdmin {\r\n        airdropAddress = _newAirdropAddress;\r\n    }\r\n\r\n    function changeAdmin(address newAdmin) external onlyAdmin {\r\n        require(newAdmin != address(0), \"New admin cannot be zero address.\");\r\n        admin = newAdmin;\r\n    }\r\n\r\n    receive() external payable {\r\n        // Refund the Ether back to the sender\r\n        payable(msg.sender).transfer(msg.value);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_teamAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_airdropAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum SupeerRouter.ProcessTypes\",\"name\":\"processType\",\"type\":\"uint8\"}],\"name\":\"SentCoin\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"airdropAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum SupeerRouter.ProcessTypes\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"percents\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"sellerPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"originalOwnerPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"airdropPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referralPercent\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_originalOwner\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_referral\",\"type\":\"address\"},{\"internalType\":\"enum SupeerRouter.ProcessTypes\",\"name\":\"_processType\",\"type\":\"uint8\"}],\"name\":\"sendCoin\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAirdropAddress\",\"type\":\"address\"}],\"name\":\"setAirdropAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newTeamAddress\",\"type\":\"address\"}],\"name\":\"setTeamAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SupeerRouter", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000b7128f81ecc2b436f57d1a60abd458fb81b48ca9000000000000000000000000a2a43cbe1b096fbd5b8f9fd47b71006c156201580000000000000000000000006427d56b32ffa07a62d2495e203932becc7d233f", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ff0202477906a37df627c95798c323ac6c8b9f6f1deb61a960f4fe5b91153a76"}