{"SourceCode": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity 0.8.19;\r\n\r\n/// @notice Simple ERC20 + EIP-2612 implementation.\r\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/tokens/ERC20.sol)\r\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\r\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol)\r\n///\r\n/// @dev Note:\r\n/// - The ERC20 standard allows minting and transferring to and from the zero address,\r\n///   minting and transferring zero tokens, as well as self-approvals.\r\n///   For performance, this implementation WILL NOT revert for such actions.\r\n///   Please add any checks with overrides if desired.\r\n/// - The `permit` function uses the ecrecover precompile (0x1).\r\n///\r\n/// If you are overriding:\r\n/// - NEVER violate the ERC20 invariant:\r\n///   the total sum of all balances must be equal to `totalSupply()`.\r\n/// - Check that the overridden function is actually used in the function you want to\r\n///   change the behavior of. Much of the code has been manually inlined for performance.\r\nabstract contract ERC20 {\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                       CUSTOM ERRORS                        */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev The total supply has overflowed.\r\n    error TotalSupplyOverflow();\r\n\r\n    /// @dev The allowance has overflowed.\r\n    error AllowanceOverflow();\r\n\r\n    /// @dev The allowance has underflowed.\r\n    error AllowanceUnderflow();\r\n\r\n    /// @dev Insufficient balance.\r\n    error InsufficientBalance();\r\n\r\n    /// @dev Insufficient allowance.\r\n    error InsufficientAllowance();\r\n\r\n    /// @dev The permit is invalid.\r\n    error InvalidPermit();\r\n\r\n    /// @dev The permit has expired.\r\n    error PermitExpired();\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                           EVENTS                           */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Emitted when `amount` tokens is transferred from `from` to `to`.\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n\r\n    /// @dev Emitted when `amount` tokens is approved by `owner` to be used by `spender`.\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n\r\n    /// @dev `keccak256(bytes(\"Transfer(address,address,uint256)\"))`.\r\n    uint256 private constant _TRANSFER_EVENT_SIGNATURE =\r\n        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;\r\n\r\n    /// @dev `keccak256(bytes(\"Approval(address,address,uint256)\"))`.\r\n    uint256 private constant _APPROVAL_EVENT_SIGNATURE =\r\n        0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925;\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                          STORAGE                           */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev The storage slot for the total supply.\r\n    uint256 private constant _TOTAL_SUPPLY_SLOT = 0x05345cdf77eb68f44c;\r\n\r\n    /// @dev The balance slot of `owner` is given by:\r\n    /// ```\r\n    ///     mstore(0x0c, _BALANCE_SLOT_SEED)\r\n    ///     mstore(0x00, owner)\r\n    ///     let balanceSlot := keccak256(0x0c, 0x20)\r\n    /// ```\r\n    uint256 private constant _BALANCE_SLOT_SEED = 0x87a211a2;\r\n\r\n    /// @dev The allowance slot of (`owner`, `spender`) is given by:\r\n    /// ```\r\n    ///     mstore(0x20, spender)\r\n    ///     mstore(0x0c, _ALLOWANCE_SLOT_SEED)\r\n    ///     mstore(0x00, owner)\r\n    ///     let allowanceSlot := keccak256(0x0c, 0x34)\r\n    /// ```\r\n    uint256 private constant _ALLOWANCE_SLOT_SEED = 0x7f5e9f20;\r\n\r\n    /// @dev The nonce slot of `owner` is given by:\r\n    /// ```\r\n    ///     mstore(0x0c, _NONCES_SLOT_SEED)\r\n    ///     mstore(0x00, owner)\r\n    ///     let nonceSlot := keccak256(0x0c, 0x20)\r\n    /// ```\r\n    uint256 private constant _NONCES_SLOT_SEED = 0x38377508;\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                         CONSTANTS                          */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev `(_NONCES_SLOT_SEED << 16) | 0x1901`.\r\n    uint256 private constant _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX = 0x383775081901;\r\n\r\n    /// @dev `keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")`.\r\n    bytes32 private constant _DOMAIN_TYPEHASH =\r\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;\r\n\r\n    /// @dev `keccak256(\"1\")`.\r\n    bytes32 private constant _VERSION_HASH =\r\n        0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;\r\n\r\n    /// @dev `keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")`.\r\n    bytes32 private constant _PERMIT_TYPEHASH =\r\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                       ERC20 METADATA                       */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Returns the name of the token.\r\n    function name() public view virtual returns (string memory);\r\n\r\n    /// @dev Returns the symbol of the token.\r\n    function symbol() public view virtual returns (string memory);\r\n\r\n    /// @dev Returns the decimals places of the token.\r\n    function decimals() public view virtual returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                           ERC20                            */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Returns the amount of tokens in existence.\r\n    function totalSupply() public view virtual returns (uint256 result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            result := sload(_TOTAL_SUPPLY_SLOT)\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the amount of tokens owned by `owner`.\r\n    function balanceOf(address owner) public view virtual returns (uint256 result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x0c, _BALANCE_SLOT_SEED)\r\n            mstore(0x00, owner)\r\n            result := sload(keccak256(0x0c, 0x20))\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the amount of tokens that `spender` can spend on behalf of `owner`.\r\n    function allowance(address owner, address spender)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256 result)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x20, spender)\r\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\r\n            mstore(0x00, owner)\r\n            result := sload(keccak256(0x0c, 0x34))\r\n        }\r\n    }\r\n\r\n    /// @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n    ///\r\n    /// Emits a {Approval} event.\r\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Compute the allowance slot and store the amount.\r\n            mstore(0x20, spender)\r\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\r\n            mstore(0x00, caller())\r\n            sstore(keccak256(0x0c, 0x34), amount)\r\n            // Emit the {Approval} event.\r\n            mstore(0x00, amount)\r\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, caller(), shr(96, mload(0x2c)))\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /// @dev Transfer `amount` tokens from the caller to `to`.\r\n    ///\r\n    /// Requirements:\r\n    /// - `from` must at least have `amount`.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\r\n        _beforeTokenTransfer(msg.sender, to, amount);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Compute the balance slot and load its value.\r\n            mstore(0x0c, _BALANCE_SLOT_SEED)\r\n            mstore(0x00, caller())\r\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\r\n            let fromBalance := sload(fromBalanceSlot)\r\n            // Revert if insufficient balance.\r\n            if gt(amount, fromBalance) {\r\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Subtract and store the updated balance.\r\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\r\n            // Compute the balance slot of `to`.\r\n            mstore(0x00, to)\r\n            let toBalanceSlot := keccak256(0x0c, 0x20)\r\n            // Add and store the updated balance of `to`.\r\n            // Will not overflow because the sum of all user balances\r\n            // cannot exceed the maximum uint256 value.\r\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\r\n            // Emit the {Transfer} event.\r\n            mstore(0x20, amount)\r\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, caller(), shr(96, mload(0x0c)))\r\n        }\r\n        _afterTokenTransfer(msg.sender, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Transfers `amount` tokens from `from` to `to`.\r\n    ///\r\n    /// Note: Does not update the allowance if it is the maximum uint256 value.\r\n    ///\r\n    /// Requirements:\r\n    /// - `from` must at least have `amount`.\r\n    /// - The caller must have at least `amount` of allowance to transfer the tokens of `from`.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function transferFrom(address from, address to, uint256 amount) public virtual returns (bool) {\r\n        _beforeTokenTransfer(from, to, amount);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let from_ := shl(96, from)\r\n            // Compute the allowance slot and load its value.\r\n            mstore(0x20, caller())\r\n            mstore(0x0c, or(from_, _ALLOWANCE_SLOT_SEED))\r\n            let allowanceSlot := keccak256(0x0c, 0x34)\r\n            let allowance_ := sload(allowanceSlot)\r\n            // If the allowance is not the maximum uint256 value.\r\n            if add(allowance_, 1) {\r\n                // Revert if the amount to be transferred exceeds the allowance.\r\n                if gt(amount, allowance_) {\r\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\r\n                    revert(0x1c, 0x04)\r\n                }\r\n                // Subtract and store the updated allowance.\r\n                sstore(allowanceSlot, sub(allowance_, amount))\r\n            }\r\n            // Compute the balance slot and load its value.\r\n            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\r\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\r\n            let fromBalance := sload(fromBalanceSlot)\r\n            // Revert if insufficient balance.\r\n            if gt(amount, fromBalance) {\r\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Subtract and store the updated balance.\r\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\r\n            // Compute the balance slot of `to`.\r\n            mstore(0x00, to)\r\n            let toBalanceSlot := keccak256(0x0c, 0x20)\r\n            // Add and store the updated balance of `to`.\r\n            // Will not overflow because the sum of all user balances\r\n            // cannot exceed the maximum uint256 value.\r\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\r\n            // Emit the {Transfer} event.\r\n            mstore(0x20, amount)\r\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\r\n        }\r\n        _afterTokenTransfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                          EIP-2612                          */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev For more performance, override to return the constant value\r\n    /// of `keccak256(bytes(name()))` if `name()` will never change.\r\n    function _constantNameHash() internal view virtual returns (bytes32 result) {}\r\n\r\n    /// @dev Returns the current nonce for `owner`.\r\n    /// This value is used to compute the signature for EIP-2612 permit.\r\n    function nonces(address owner) public view virtual returns (uint256 result) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Compute the nonce slot and load its value.\r\n            mstore(0x0c, _NONCES_SLOT_SEED)\r\n            mstore(0x00, owner)\r\n            result := sload(keccak256(0x0c, 0x20))\r\n        }\r\n    }\r\n\r\n    /// @dev Sets `value` as the allowance of `spender` over the tokens of `owner`,\r\n    /// authorized by a signed approval by `owner`.\r\n    ///\r\n    /// Emits a {Approval} event.\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public virtual {\r\n        bytes32 nameHash = _constantNameHash();\r\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\r\n        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Revert if the block timestamp is greater than `deadline`.\r\n            if gt(timestamp(), deadline) {\r\n                mstore(0x00, 0x1a15a3cc) // `PermitExpired()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            let m := mload(0x40) // Grab the free memory pointer.\r\n            // Clean the upper 96 bits.\r\n            owner := shr(96, shl(96, owner))\r\n            spender := shr(96, shl(96, spender))\r\n            // Compute the nonce slot and load its value.\r\n            mstore(0x0e, _NONCES_SLOT_SEED_WITH_SIGNATURE_PREFIX)\r\n            mstore(0x00, owner)\r\n            let nonceSlot := keccak256(0x0c, 0x20)\r\n            let nonceValue := sload(nonceSlot)\r\n            // Prepare the domain separator.\r\n            mstore(m, _DOMAIN_TYPEHASH)\r\n            mstore(add(m, 0x20), nameHash)\r\n            mstore(add(m, 0x40), _VERSION_HASH)\r\n            mstore(add(m, 0x60), chainid())\r\n            mstore(add(m, 0x80), address())\r\n            mstore(0x2e, keccak256(m, 0xa0))\r\n            // Prepare the struct hash.\r\n            mstore(m, _PERMIT_TYPEHASH)\r\n            mstore(add(m, 0x20), owner)\r\n            mstore(add(m, 0x40), spender)\r\n            mstore(add(m, 0x60), value)\r\n            mstore(add(m, 0x80), nonceValue)\r\n            mstore(add(m, 0xa0), deadline)\r\n            mstore(0x4e, keccak256(m, 0xc0))\r\n            // Prepare the ecrecover calldata.\r\n            mstore(0x00, keccak256(0x2c, 0x42))\r\n            mstore(0x20, and(0xff, v))\r\n            mstore(0x40, r)\r\n            mstore(0x60, s)\r\n            let t := staticcall(gas(), 1, 0, 0x80, 0x20, 0x20)\r\n            // If the ecrecover fails, the returndatasize will be 0x00,\r\n            // `owner` will be checked if it equals the hash at 0x00,\r\n            // which evaluates to false (i.e. 0), and we will revert.\r\n            // If the ecrecover succeeds, the returndatasize will be 0x20,\r\n            // `owner` will be compared against the returned address at 0x20.\r\n            if iszero(eq(mload(returndatasize()), owner)) {\r\n                mstore(0x00, 0xddafbaef) // `InvalidPermit()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Increment and store the updated nonce.\r\n            sstore(nonceSlot, add(nonceValue, t)) // `t` is 1 if ecrecover succeeds.\r\n            // Compute the allowance slot and store the value.\r\n            // The `owner` is already at slot 0x20.\r\n            mstore(0x40, or(shl(160, _ALLOWANCE_SLOT_SEED), spender))\r\n            sstore(keccak256(0x2c, 0x34), value)\r\n            // Emit the {Approval} event.\r\n            log3(add(m, 0x60), 0x20, _APPROVAL_EVENT_SIGNATURE, owner, spender)\r\n            mstore(0x40, m) // Restore the free memory pointer.\r\n            mstore(0x60, 0) // Restore the zero pointer.\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the EIP-712 domain separator for the EIP-2612 permit.\r\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32 result) {\r\n        bytes32 nameHash = _constantNameHash();\r\n        //  We simply calculate it on-the-fly to allow for cases where the `name` may change.\r\n        if (nameHash == bytes32(0)) nameHash = keccak256(bytes(name()));\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let m := mload(0x40) // Grab the free memory pointer.\r\n            mstore(m, _DOMAIN_TYPEHASH)\r\n            mstore(add(m, 0x20), nameHash)\r\n            mstore(add(m, 0x40), _VERSION_HASH)\r\n            mstore(add(m, 0x60), chainid())\r\n            mstore(add(m, 0x80), address())\r\n            result := keccak256(m, 0xa0)\r\n        }\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                  INTERNAL MINT FUNCTIONS                   */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Mints `amount` tokens to `to`, increasing the total supply.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function _mint(address to, uint256 amount) internal virtual {\r\n        _beforeTokenTransfer(address(0), to, amount);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let totalSupplyBefore := sload(_TOTAL_SUPPLY_SLOT)\r\n            let totalSupplyAfter := add(totalSupplyBefore, amount)\r\n            // Revert if the total supply overflows.\r\n            if lt(totalSupplyAfter, totalSupplyBefore) {\r\n                mstore(0x00, 0xe5cfe957) // `TotalSupplyOverflow()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Store the updated total supply.\r\n            sstore(_TOTAL_SUPPLY_SLOT, totalSupplyAfter)\r\n            // Compute the balance slot and load its value.\r\n            mstore(0x0c, _BALANCE_SLOT_SEED)\r\n            mstore(0x00, to)\r\n            let toBalanceSlot := keccak256(0x0c, 0x20)\r\n            // Add and store the updated balance.\r\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\r\n            // Emit the {Transfer} event.\r\n            mstore(0x20, amount)\r\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, 0, shr(96, mload(0x0c)))\r\n        }\r\n        _afterTokenTransfer(address(0), to, amount);\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                  INTERNAL BURN FUNCTIONS                   */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Burns `amount` tokens from `from`, reducing the total supply.\r\n    ///\r\n    /// Emits a {Transfer} event.\r\n    function _burn(address from, uint256 amount) internal virtual {\r\n        _beforeTokenTransfer(from, address(0), amount);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Compute the balance slot and load its value.\r\n            mstore(0x0c, _BALANCE_SLOT_SEED)\r\n            mstore(0x00, from)\r\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\r\n            let fromBalance := sload(fromBalanceSlot)\r\n            // Revert if insufficient balance.\r\n            if gt(amount, fromBalance) {\r\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Subtract and store the updated balance.\r\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\r\n            // Subtract and store the updated total supply.\r\n            sstore(_TOTAL_SUPPLY_SLOT, sub(sload(_TOTAL_SUPPLY_SLOT), amount))\r\n            // Emit the {Transfer} event.\r\n            mstore(0x00, amount)\r\n            log3(0x00, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, shl(96, from)), 0)\r\n        }\r\n        _afterTokenTransfer(from, address(0), amount);\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                INTERNAL TRANSFER FUNCTIONS                 */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Moves `amount` of tokens from `from` to `to`.\r\n    function _transfer(address from, address to, uint256 amount) internal virtual {\r\n        _beforeTokenTransfer(from, to, amount);\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let from_ := shl(96, from)\r\n            // Compute the balance slot and load its value.\r\n            mstore(0x0c, or(from_, _BALANCE_SLOT_SEED))\r\n            let fromBalanceSlot := keccak256(0x0c, 0x20)\r\n            let fromBalance := sload(fromBalanceSlot)\r\n            // Revert if insufficient balance.\r\n            if gt(amount, fromBalance) {\r\n                mstore(0x00, 0xf4d678b8) // `InsufficientBalance()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            // Subtract and store the updated balance.\r\n            sstore(fromBalanceSlot, sub(fromBalance, amount))\r\n            // Compute the balance slot of `to`.\r\n            mstore(0x00, to)\r\n            let toBalanceSlot := keccak256(0x0c, 0x20)\r\n            // Add and store the updated balance of `to`.\r\n            // Will not overflow because the sum of all user balances\r\n            // cannot exceed the maximum uint256 value.\r\n            sstore(toBalanceSlot, add(sload(toBalanceSlot), amount))\r\n            // Emit the {Transfer} event.\r\n            mstore(0x20, amount)\r\n            log3(0x20, 0x20, _TRANSFER_EVENT_SIGNATURE, shr(96, from_), shr(96, mload(0x0c)))\r\n        }\r\n        _afterTokenTransfer(from, to, amount);\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                INTERNAL ALLOWANCE FUNCTIONS                */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Updates the allowance of `owner` for `spender` based on spent `amount`.\r\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Compute the allowance slot and load its value.\r\n            mstore(0x20, spender)\r\n            mstore(0x0c, _ALLOWANCE_SLOT_SEED)\r\n            mstore(0x00, owner)\r\n            let allowanceSlot := keccak256(0x0c, 0x34)\r\n            let allowance_ := sload(allowanceSlot)\r\n            // If the allowance is not the maximum uint256 value.\r\n            if add(allowance_, 1) {\r\n                // Revert if the amount to be transferred exceeds the allowance.\r\n                if gt(amount, allowance_) {\r\n                    mstore(0x00, 0x13be252b) // `InsufficientAllowance()`.\r\n                    revert(0x1c, 0x04)\r\n                }\r\n                // Subtract and store the updated allowance.\r\n                sstore(allowanceSlot, sub(allowance_, amount))\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Sets `amount` as the allowance of `spender` over the tokens of `owner`.\r\n    ///\r\n    /// Emits a {Approval} event.\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let owner_ := shl(96, owner)\r\n            // Compute the allowance slot and store the amount.\r\n            mstore(0x20, spender)\r\n            mstore(0x0c, or(owner_, _ALLOWANCE_SLOT_SEED))\r\n            sstore(keccak256(0x0c, 0x34), amount)\r\n            // Emit the {Approval} event.\r\n            mstore(0x00, amount)\r\n            log3(0x00, 0x20, _APPROVAL_EVENT_SIGNATURE, shr(96, owner_), shr(96, mload(0x2c)))\r\n        }\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                     HOOKS TO OVERRIDE                      */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Hook that is called before any transfer of tokens.\r\n    /// This includes minting and burning.\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\r\n\r\n    /// @dev Hook that is called after any transfer of tokens.\r\n    /// This includes minting and burning.\r\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\r\n}\r\n\r\ninterface IFeeSplitter {\r\n    function split() external;\r\n    function token() external view returns (address);\r\n}\r\n\r\ninterface ILiquidityGauge {\r\n    struct Reward {\r\n        address token;\r\n        address distributor;\r\n        // solhint-disable-next-line\r\n        uint256 period_finish;\r\n        uint256 rate;\r\n        // solhint-disable-next-line\r\n        uint256 last_update;\r\n        uint256 integral;\r\n    }\r\n\r\n    // solhint-disable-next-line\r\n    function deposit_reward_token(address _rewardToken, uint256 _amount) external;\r\n\r\n    // solhint-disable-next-line\r\n    function claim_rewards_for(address _user, address _recipient) external;\r\n\r\n    // solhint-disable-next-line\r\n    function working_balances(address _address) external view returns (uint256);\r\n\r\n    // solhint-disable-next-line\r\n    function deposit(uint256 _value, address _addr) external;\r\n\r\n    // solhint-disable-next-line\r\n    function reward_tokens(uint256 _i) external view returns (address);\r\n\r\n    // solhint-disable-next-line\r\n    function reward_data(address _tokenReward) external view returns (Reward memory);\r\n\r\n    function balanceOf(address) external returns (uint256);\r\n\r\n    // solhint-disable-next-line\r\n    function claimable_reward(address _user, address _reward_token) external view returns (uint256);\r\n\r\n    // solhint-disable-next-line\r\n    function claimable_tokens(address _user) external returns (uint256);\r\n\r\n    // solhint-disable-next-line\r\n    function user_checkpoint(address _user) external returns (bool);\r\n\r\n    // solhint-disable-next-line\r\n    function commit_transfer_ownership(address) external;\r\n\r\n    // solhint-disable-next-line\r\n    function claim_rewards() external;\r\n\r\n    // solhint-disable-next-line\r\n    function claim_rewards(address) external;\r\n\r\n    // solhint-disable-next-line\r\n    function claim_rewards(address, address) external;\r\n\r\n    // solhint-disable-next-line\r\n    function add_reward(address, address) external;\r\n\r\n    // solhint-disable-next-line\r\n    function set_claimer(address) external;\r\n\r\n    function admin() external view returns (address);\r\n\r\n    function future_admin() external view returns (address);\r\n\r\n    // solhint-disable-next-line\r\n    function set_reward_distributor(address _rewardToken, address _newDistrib) external;\r\n\r\n    function initialize(\r\n        // solhint-disable-next-line\r\n        address staking_token,\r\n        address admin,\r\n        address sdt,\r\n        // solhint-disable-next-line\r\n        address voting_escrow,\r\n        // solhint-disable-next-line\r\n        address veBoost_proxy,\r\n        address distributor\r\n    ) external;\r\n\r\n    function totalSupply() external returns (uint256);\r\n\r\n    function withdraw(uint256 _value, bool _claimReward) external;\r\n\r\n    // solhint-disable-next-line\r\n    function accept_transfer_ownership() external;\r\n\r\n    // solhint-disable-next-line\r\n    function claimed_reward(address _addr, address _token) external view returns (uint256);\r\n\r\n    // solhint-disable-next-line\r\n    function set_rewards_receiver(address _receiver) external;\r\n}\r\n\r\ninterface ISDTDistributor {\r\n    function distribute(address gaugeAddr) external;\r\n}\r\n\r\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\r\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\r\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\r\n///\r\n/// @dev Note:\r\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\r\n/// - For ERC20s, this implementation won't check that a token has code,\r\n///   responsibility is delegated to the caller.\r\nlibrary SafeTransferLib {\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                       CUSTOM ERRORS                        */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev The ETH transfer has failed.\r\n    error ETHTransferFailed();\r\n\r\n    /// @dev The ERC20 `transferFrom` has failed.\r\n    error TransferFromFailed();\r\n\r\n    /// @dev The ERC20 `transfer` has failed.\r\n    error TransferFailed();\r\n\r\n    /// @dev The ERC20 `approve` has failed.\r\n    error ApproveFailed();\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                         CONSTANTS                          */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\r\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\r\n\r\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\r\n    /// storage reads and writes, but low enough to prevent griefing.\r\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                       ETH OPERATIONS                       */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\r\n    //\r\n    // The regular variants:\r\n    // - Forwards all remaining gas to the target.\r\n    // - Reverts if the target reverts.\r\n    // - Reverts if the current contract has insufficient balance.\r\n    //\r\n    // The force variants:\r\n    // - Forwards with an optional gas stipend\r\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\r\n    // - If the target reverts, or if the gas stipend is exhausted,\r\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\r\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\r\n    // - Reverts if the current contract has insufficient balance.\r\n    //\r\n    // The try variants:\r\n    // - Forwards with a mandatory gas stipend.\r\n    // - Instead of reverting, returns whether the transfer succeeded.\r\n\r\n    /// @dev Sends `amount` (in wei) ETH to `to`.\r\n    function safeTransferETH(address to, uint256 amount) internal {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\r\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Sends all the ETH in the current contract to `to`.\r\n    function safeTransferAllETH(address to) internal {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // Transfer all the ETH and check if it succeeded or not.\r\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\r\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\r\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            if lt(selfbalance(), amount) {\r\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\r\n                mstore(0x00, to) // Store the address in scratch space.\r\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\r\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\r\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\r\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\r\n                mstore(0x00, to) // Store the address in scratch space.\r\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\r\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\r\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\r\n    function forceSafeTransferETH(address to, uint256 amount) internal {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            if lt(selfbalance(), amount) {\r\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\r\n                mstore(0x00, to) // Store the address in scratch space.\r\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\r\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\r\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\r\n    function forceSafeTransferAllETH(address to) internal {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            // forgefmt: disable-next-item\r\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\r\n                mstore(0x00, to) // Store the address in scratch space.\r\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\r\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\r\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\r\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\r\n        }\r\n    }\r\n\r\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\r\n    function trySafeTransferAllETH(address to, uint256 gasStipend)\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\r\n        }\r\n    }\r\n\r\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\r\n    /*                      ERC20 OPERATIONS                      */\r\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\r\n\r\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\r\n    /// Reverts upon failure.\r\n    ///\r\n    /// The `from` account must have at least `amount` approved for\r\n    /// the current contract to manage.\r\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let m := mload(0x40) // Cache the free memory pointer.\r\n            mstore(0x60, amount) // Store the `amount` argument.\r\n            mstore(0x40, to) // Store the `to` argument.\r\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\r\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\r\n            // Perform the transfer, reverting upon failure.\r\n            if iszero(\r\n                and( // The arguments of `and` are evaluated from right to left.\r\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\r\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\r\n                )\r\n            ) {\r\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            mstore(0x60, 0) // Restore the zero slot to zero.\r\n            mstore(0x40, m) // Restore the free memory pointer.\r\n        }\r\n    }\r\n\r\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\r\n    /// Reverts upon failure.\r\n    ///\r\n    /// The `from` account must have their entire balance approved for\r\n    /// the current contract to manage.\r\n    function safeTransferAllFrom(address token, address from, address to)\r\n        internal\r\n        returns (uint256 amount)\r\n    {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            let m := mload(0x40) // Cache the free memory pointer.\r\n            mstore(0x40, to) // Store the `to` argument.\r\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\r\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\r\n            // Read the balance, reverting upon failure.\r\n            if iszero(\r\n                and( // The arguments of `and` are evaluated from right to left.\r\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\r\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\r\n                )\r\n            ) {\r\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\r\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\r\n            // Perform the transfer, reverting upon failure.\r\n            if iszero(\r\n                and( // The arguments of `and` are evaluated from right to left.\r\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\r\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\r\n                )\r\n            ) {\r\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            mstore(0x60, 0) // Restore the zero slot to zero.\r\n            mstore(0x40, m) // Restore the free memory pointer.\r\n        }\r\n    }\r\n\r\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\r\n    /// Reverts upon failure.\r\n    function safeTransfer(address token, address to, uint256 amount) internal {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x14, to) // Store the `to` argument.\r\n            mstore(0x34, amount) // Store the `amount` argument.\r\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\r\n            // Perform the transfer, reverting upon failure.\r\n            if iszero(\r\n                and( // The arguments of `and` are evaluated from right to left.\r\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\r\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\r\n                )\r\n            ) {\r\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\r\n        }\r\n    }\r\n\r\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\r\n    /// Reverts upon failure.\r\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\r\n            mstore(0x20, address()) // Store the address of the current contract.\r\n            // Read the balance, reverting upon failure.\r\n            if iszero(\r\n                and( // The arguments of `and` are evaluated from right to left.\r\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\r\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\r\n                )\r\n            ) {\r\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            mstore(0x14, to) // Store the `to` argument.\r\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\r\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\r\n            // Perform the transfer, reverting upon failure.\r\n            if iszero(\r\n                and( // The arguments of `and` are evaluated from right to left.\r\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\r\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\r\n                )\r\n            ) {\r\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\r\n        }\r\n    }\r\n\r\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\r\n    /// Reverts upon failure.\r\n    function safeApprove(address token, address to, uint256 amount) internal {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x14, to) // Store the `to` argument.\r\n            mstore(0x34, amount) // Store the `amount` argument.\r\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\r\n            // Perform the approval, reverting upon failure.\r\n            if iszero(\r\n                and( // The arguments of `and` are evaluated from right to left.\r\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\r\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\r\n                )\r\n            ) {\r\n                mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\r\n                revert(0x1c, 0x04)\r\n            }\r\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\r\n        }\r\n    }\r\n\r\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\r\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\r\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\r\n    /// Reverts upon failure.\r\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x14, to) // Store the `to` argument.\r\n            mstore(0x34, amount) // Store the `amount` argument.\r\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\r\n            // Perform the approval, retrying upon failure.\r\n            if iszero(\r\n                and( // The arguments of `and` are evaluated from right to left.\r\n                    or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\r\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\r\n                )\r\n            ) {\r\n                mstore(0x34, 0) // Store 0 for the `amount`.\r\n                mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\r\n                pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\r\n                mstore(0x34, amount) // Store back the original `amount`.\r\n                // Retry the approval, reverting upon failure.\r\n                if iszero(\r\n                    and(\r\n                        or(eq(mload(0x00), 1), iszero(returndatasize())), // Returned 1 or nothing.\r\n                        call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\r\n                    )\r\n                ) {\r\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\r\n                    revert(0x1c, 0x04)\r\n                }\r\n            }\r\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\r\n    /// Returns zero if the `token` does not exist.\r\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x14, account) // Store the `account` argument.\r\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\r\n            amount :=\r\n                mul(\r\n                    mload(0x20),\r\n                    and( // The arguments of `and` are evaluated from right to left.\r\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\r\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\r\n                    )\r\n                )\r\n        }\r\n    }\r\n}\r\n\r\n/// @title Accumulator\r\n/// @notice Abstract contract used for any accumulator\r\n/// @author StakeDAO\r\nabstract contract Accumulator {\r\n    /// @notice Denominator for fixed point math.\r\n    uint256 public constant DENOMINATOR = 10_000;\r\n\r\n    /// @notice sd gauge\r\n    address public immutable gauge;\r\n\r\n    /// @notice sd locker\r\n    address public immutable locker;\r\n\r\n    /// @notice governance\r\n    address public governance;\r\n\r\n    /// @notice future governance\r\n    address public futureGovernance;\r\n\r\n    /// @notice SDT distributor\r\n    address public sdtDistributor;\r\n\r\n    /// @notice dao fee in percentage (10_000 = 100%)\r\n    uint256 public daoFee;\r\n\r\n    /// @notice dao fee recipient address\r\n    address public daoFeeRecipient;\r\n\r\n    /// @notice liquidity fee in percentage (10_000 = 100%)\r\n    uint256 public liquidityFee;\r\n\r\n    /// @notice liquidity fee recipient\r\n    address public liquidityFeeRecipient;\r\n\r\n    /// @notice claimer fee (msg.sender) in percentage (10_000 = 100%)\r\n    uint256 public claimerFee;\r\n\r\n    /// @notice fee splitter contract to pull strategies fees\r\n    address public feeSplitter;\r\n\r\n    ////////////////////////////////////////////////////////////////\r\n    /// --- EVENTS & ERRORS\r\n    ///////////////////////////////////////////////////////////////\r\n\r\n    /// @notice Event emitted when the claimer fee is set\r\n    event ClaimerFeeSet(uint256 claimerFee);\r\n\r\n    /// @notice Event emitted when the dao fee is set\r\n    event DaoFeeSet(uint256 daoFee);\r\n\r\n    /// @notice Event emitted when the dao fee recipient is set\r\n    event DaoFeeRecipientSet(address daoFeeRecipient);\r\n\r\n    /// @notice Event emitted when the fees are charged during reward notify\r\n    event FeeCharged(uint256 daoPart, uint256 liquidityPart, uint256 claimerPart);\r\n\r\n    /// @notice Emitted when the fee splitter is set\r\n    event FeeSplitterSet(address _feeSplitter);\r\n\r\n    /// @notice Event emitted when an ERC20 token is rescued\r\n    event ERC20Rescued(address token, uint256 amount);\r\n\r\n    /// @notice Event emitted when the liquidity fee percentage is set\r\n    event LiquidityFeeSet(uint256 liquidityFee);\r\n\r\n    /// @notice Event emitted when a liquidity fee recipient  is set\r\n    event LiquidityFeeRecipientSet(address liquidityFeeRecipient);\r\n\r\n    /// @notice Event emitted when a new reward has notified\r\n    event RewardNotified(address gauge, address tokenReward, uint256 amountNotified);\r\n\r\n    /// @notice Event emitted when a new future governance has set\r\n    event TransferGovernance(address futureGovernance);\r\n\r\n    /// @notice Event emitted when the future governance accepts to be the governance\r\n    event GovernanceChanged(address governance);\r\n\r\n    /// @notice Error emitted when an onlyGovernance function has called by a different address\r\n    error GOVERNANCE();\r\n\r\n    /// @notice Error emitted when the total fee would be more than 100%\r\n    error FEE_TOO_HIGH();\r\n\r\n    /// @notice Error emitted when an onlyFutureGovernance function has called by a different address\r\n    error FUTURE_GOVERNANCE();\r\n\r\n    /// @notice Error emitted when a zero address is pass\r\n    error ZERO_ADDRESS();\r\n\r\n    //////////////////////////////////////////////////////\r\n    /// --- MODIFIERS\r\n    //////////////////////////////////////////////////////\r\n\r\n    /// @notice Modifier to check if the caller is the governance\r\n    modifier onlyGovernance() {\r\n        if (msg.sender != governance) revert GOVERNANCE();\r\n        _;\r\n    }\r\n\r\n    /// @notice Modifier to check if the caller is the future governance\r\n    modifier onlyFutureGovernance() {\r\n        if (msg.sender != futureGovernance) revert FUTURE_GOVERNANCE();\r\n        _;\r\n    }\r\n\r\n    //////////////////////////////////////////////////////\r\n    /// --- CONSTRUCTOR\r\n    //////////////////////////////////////////////////////\r\n\r\n    /// @notice Constructor\r\n    /// @param _gauge sd gauge\r\n    /// @param _locker sd locker\r\n    /// @param _daoFeeRecipient dao fee recipient\r\n    /// @param _liquidityFeeRecipient liquidity fee recipient\r\n    /// @param _governance governance\r\n    constructor(\r\n        address _gauge,\r\n        address _locker,\r\n        address _daoFeeRecipient,\r\n        address _liquidityFeeRecipient,\r\n        address _governance\r\n    ) {\r\n        gauge = _gauge;\r\n        locker = _locker;\r\n        daoFeeRecipient = _daoFeeRecipient;\r\n        liquidityFeeRecipient = _liquidityFeeRecipient;\r\n\r\n        governance = _governance;\r\n\r\n        // default fees\r\n        daoFee = 500; // 5%\r\n        liquidityFee = 1_000; // 10%\r\n        claimerFee = 50; // 0.5%\r\n    }\r\n\r\n    //////////////////////////////////////////////////////\r\n    /// --- MUTATIVE FUNCTIONS\r\n    //////////////////////////////////////////////////////\r\n\r\n    /// @notice Claims all rewards tokens for the locker and notify them to the LGV4\r\n    function claimAndNotifyAll(bool _notifySDT, bool _pullFromFeeSplitter) external virtual {}\r\n\r\n    /// @notice Claims a reward token for the locker and notify them to the LGV4\r\n    function claimTokenAndNotifyAll(address _token, bool _notifySDT, bool _pullFromFeeSplitter) external virtual {}\r\n\r\n    /// @notice Notify the whole acc balance of a token\r\n    /// @param _token token to notify\r\n    /// @param _notifySDT if notify SDT or not\r\n    /// @param _pullFromFeeSplitter if pull tokens from the fee splitter or not\r\n    function notifyReward(address _token, bool _notifySDT, bool _pullFromFeeSplitter) public virtual {\r\n        uint256 amount = ERC20(_token).balanceOf(address(this));\r\n        // notify token as reward in sdToken gauge\r\n        _notifyReward(_token, amount, _pullFromFeeSplitter);\r\n\r\n        if (_notifySDT) {\r\n            // notify SDT\r\n            _distributeSDT();\r\n        }\r\n    }\r\n\r\n    //////////////////////////////////////////////////////\r\n    /// --- INTERNAL FUNCTIONS\r\n    //////////////////////////////////////////////////////\r\n\r\n    /// @notice Notify the new reward to the LGV4\r\n    /// @param _tokenReward token to notify\r\n    /// @param _amount amount to notify\r\n    function _notifyReward(address _tokenReward, uint256 _amount, bool _pullFromFeeSplitter) internal virtual {\r\n        _chargeFee(_tokenReward, _amount);\r\n\r\n        if (_pullFromFeeSplitter) {\r\n            // Pull token reserved for acc from FeeSplitter if there is any\r\n            IFeeSplitter(feeSplitter).split();\r\n\r\n            address rewardToken = IFeeSplitter(feeSplitter).token();\r\n            if (_tokenReward != rewardToken) {\r\n                uint256 _rewardTokenAmount = ERC20(rewardToken).balanceOf(address(this));\r\n\r\n                if (_rewardTokenAmount == 0) return;\r\n                ILiquidityGauge(gauge).deposit_reward_token(rewardToken, _rewardTokenAmount);\r\n            }\r\n        }\r\n\r\n        _amount = ERC20(_tokenReward).balanceOf(address(this));\r\n        if (_amount == 0) return;\r\n        ILiquidityGauge(gauge).deposit_reward_token(_tokenReward, _amount);\r\n\r\n        emit RewardNotified(gauge, _tokenReward, _amount);\r\n    }\r\n\r\n    /// @notice Distribute SDT to the gauge\r\n    function _distributeSDT() internal {\r\n        if (sdtDistributor != address(0)) {\r\n            ISDTDistributor(sdtDistributor).distribute(gauge);\r\n        }\r\n    }\r\n\r\n    /// @notice Charge fee for dao, liquidity, claimer\r\n    /// @param _token token to charge fee for\r\n    /// @param _amount amount to charge fee for\r\n    function _chargeFee(address _token, uint256 _amount) internal returns (uint256 _charged) {\r\n        if (_amount == 0) return 0;\r\n\r\n        uint256 daoPart;\r\n        uint256 liquidityPart;\r\n        uint256 claimerPart;\r\n\r\n        if (daoFee != 0) {\r\n            daoPart = _amount * daoFee / DENOMINATOR;\r\n            SafeTransferLib.safeTransfer(_token, daoFeeRecipient, daoPart);\r\n            _charged += daoPart;\r\n        }\r\n        if (liquidityFee != 0) {\r\n            liquidityPart = _amount * liquidityFee / DENOMINATOR;\r\n            SafeTransferLib.safeTransfer(_token, liquidityFeeRecipient, liquidityPart);\r\n            _charged += liquidityPart;\r\n        }\r\n        if (claimerFee != 0) {\r\n            claimerPart = _amount * claimerFee / DENOMINATOR;\r\n            SafeTransferLib.safeTransfer(_token, msg.sender, claimerPart);\r\n            _charged += claimerPart;\r\n        }\r\n        emit FeeCharged(daoPart, liquidityPart, claimerPart);\r\n    }\r\n\r\n    //////////////////////////////////////////////////////\r\n    /// --- GOVERNANCE FUNCTIONS\r\n    //////////////////////////////////////////////////////\r\n\r\n    /// @notice Sets dao fee recipient\r\n    /// @dev Can be called only by the governance\r\n    /// @param _daoFeeRecipient dao fee recipient\r\n    function setDaoFeeRecipient(address _daoFeeRecipient) external onlyGovernance {\r\n        emit DaoFeeRecipientSet(daoFeeRecipient = _daoFeeRecipient);\r\n    }\r\n\r\n    /// @notice Sets liquidity fee recipient\r\n    /// @dev Can be called only by the governance\r\n    /// @param _liquidityFeeRecipient liquidity fee recipient\r\n    function setLiquidityFeeRecipient(address _liquidityFeeRecipient) external onlyGovernance {\r\n        emit LiquidityFeeRecipientSet(liquidityFeeRecipient = _liquidityFeeRecipient);\r\n    }\r\n\r\n    /// @notice Sets dao fee\r\n    /// @dev Can be called only by the governance\r\n    /// @param _daoFee dao fee in percentage (10_000 = 100%)\r\n    function setDaoFee(uint256 _daoFee) external onlyGovernance {\r\n        if (_daoFee + liquidityFee + claimerFee > DENOMINATOR) revert FEE_TOO_HIGH();\r\n        emit DaoFeeSet(daoFee = _daoFee);\r\n    }\r\n\r\n    /// @notice Sets liquidity fee\r\n    /// @dev Can be called only by the governance\r\n    /// @param _liquidityFee liquidity fee in percentage (10_000 = 100%)\r\n    function setLiquidityFee(uint256 _liquidityFee) external onlyGovernance {\r\n        if (daoFee + _liquidityFee + claimerFee > DENOMINATOR) revert FEE_TOO_HIGH();\r\n        emit LiquidityFeeSet(liquidityFee = _liquidityFee);\r\n    }\r\n\r\n    /// @notice Sets claimer fee\r\n    /// @dev Can be called only by the governance\r\n    /// @param _claimerFee claimer fee in percentage (10_000 = 100%)\r\n    function setClaimerFee(uint256 _claimerFee) external onlyGovernance {\r\n        if (daoFee + liquidityFee + _claimerFee > DENOMINATOR) revert FEE_TOO_HIGH();\r\n        emit ClaimerFeeSet(claimerFee = _claimerFee);\r\n    }\r\n\r\n    /// @notice Set a fee splitter\r\n    /// @param _feeSplitter fee splitter address\r\n    function setFeeSplitter(address _feeSplitter) external onlyGovernance {\r\n        emit FeeSplitterSet(feeSplitter = _feeSplitter);\r\n    }\r\n\r\n    /// @notice Set a new future governance that can accept it\r\n    /// @dev Can be called only by the governance\r\n    /// @param _futureGovernance future governance address\r\n    function transferGovernance(address _futureGovernance) external onlyGovernance {\r\n        if (_futureGovernance == address(0)) revert ZERO_ADDRESS();\r\n        futureGovernance = _futureGovernance;\r\n        emit TransferGovernance(_futureGovernance);\r\n    }\r\n\r\n    /// @notice Accept the governance\r\n    /// @dev Can be called only by future governance\r\n    function acceptGovernance() external onlyFutureGovernance {\r\n        governance = futureGovernance;\r\n        emit GovernanceChanged(governance);\r\n    }\r\n\r\n    /// @notice A function that rescue any ERC20 token\r\n    /// @dev Can be called only by the governance\r\n    /// @param _token token address\r\n    /// @param _amount amount to rescue\r\n    /// @param _recipient address to send token rescued\r\n    function rescueERC20(address _token, uint256 _amount, address _recipient) external onlyGovernance {\r\n        if (_recipient == address(0)) revert ZERO_ADDRESS();\r\n        SafeTransferLib.safeTransfer(_token, _recipient, _amount);\r\n        emit ERC20Rescued(_token, _amount);\r\n    }\r\n}\r\n\r\ninterface ICakeLocker {\r\n    function claimRevenue(address[] memory revenueSharingPools) external;\r\n    function setRevenueSharingPoolGateway(address rspg) external;\r\n    function rspg() external view returns (address);\r\n}\r\n\r\ninterface IRevenueSharingPool {\r\n    function checkpointToken() external;\r\n    function rewardToken() external returns (address);\r\n    function balanceOfAtUser(address _user, uint256 _ts) external view returns (uint256);\r\n    function tokensPerWeek(uint256 _period) external view returns (uint256);\r\n}\r\n\r\n/// @notice A contract that accumulates CAKE rewards and notifies them to the sdCAKE gauge\r\n/// @author StakeDAO\r\ncontract CakeAccumulator is Accumulator {\r\n    /// @notice CAKE token address\r\n    address public constant CAKE = 0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82;\r\n\r\n    //////////////////////////////////////////////////////\r\n    /// --- CONSTRUCTOR\r\n    //////////////////////////////////////////////////////\r\n\r\n    /// @notice Constructor\r\n    /// @param _gauge sd gauge\r\n    /// @param _locker sd locker\r\n    /// @param _daoFeeRecipient dao fee recipient\r\n    /// @param _liquidityFeeRecipient liquidity fee recipient\r\n    /// @param _governance governance\r\n    constructor(\r\n        address _gauge,\r\n        address _locker,\r\n        address _daoFeeRecipient,\r\n        address _liquidityFeeRecipient,\r\n        address _governance\r\n    ) Accumulator(_gauge, _locker, _daoFeeRecipient, _liquidityFeeRecipient, _governance) {\r\n        SafeTransferLib.safeApprove(CAKE, _gauge, type(uint256).max);\r\n    }\r\n\r\n    //////////////////////////////////////////////////////\r\n    /// --- MUTATIVE FUNCTIONS\r\n    //////////////////////////////////////////////////////\r\n\r\n    /// @notice Claim CAKE rewards for the locker and notify all to the LGV4\r\n    /// @param _revenueSharingPools pancake revenue sharing pools\r\n    /// @param _notifySDT if notify SDT or not\r\n    /// @param _pullFromFeeSplitter if pull tokens from the fee splitter or not\r\n    function claimAndNotifyAll(address[] memory _revenueSharingPools, bool _notifySDT, bool _pullFromFeeSplitter)\r\n        external\r\n    {\r\n        /// Claim Revenue Reward.\r\n        ICakeLocker(locker).claimRevenue(_revenueSharingPools);\r\n\r\n        /// Notify the first revenue sharing pool.\r\n        address tokenReward = IRevenueSharingPool(_revenueSharingPools[0]).rewardToken();\r\n        notifyReward(tokenReward, _notifySDT, _pullFromFeeSplitter);\r\n\r\n        for (uint256 i = 1; i < _revenueSharingPools.length;) {\r\n            tokenReward = IRevenueSharingPool(_revenueSharingPools[i]).rewardToken();\r\n\r\n            /// We don't want to pull from the fee splitter for the rest of the pools.\r\n            notifyReward(tokenReward, false, false);\r\n\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Approve the distribution of a new token reward from the Accumulator.\r\n    /// @param _newTokenReward New token reward to be approved.\r\n    function approveNewTokenReward(address _newTokenReward) external onlyGovernance {\r\n        SafeTransferLib.safeApprove(_newTokenReward, gauge, type(uint256).max);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gauge\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_locker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_daoFeeRecipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_liquidityFeeRecipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_governance\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"FEE_TOO_HIGH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FUTURE_GOVERNANCE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GOVERNANCE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZERO_ADDRESS\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimerFee\",\"type\":\"uint256\"}],\"name\":\"ClaimerFeeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"daoFeeRecipient\",\"type\":\"address\"}],\"name\":\"DaoFeeRecipientSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"daoFee\",\"type\":\"uint256\"}],\"name\":\"DaoFeeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ERC20Rescued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"daoPart\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidityPart\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimerPart\",\"type\":\"uint256\"}],\"name\":\"FeeCharged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_feeSplitter\",\"type\":\"address\"}],\"name\":\"FeeSplitterSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"governance\",\"type\":\"address\"}],\"name\":\"GovernanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"liquidityFeeRecipient\",\"type\":\"address\"}],\"name\":\"LiquidityFeeRecipientSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidityFee\",\"type\":\"uint256\"}],\"name\":\"LiquidityFeeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenReward\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountNotified\",\"type\":\"uint256\"}],\"name\":\"RewardNotified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"futureGovernance\",\"type\":\"address\"}],\"name\":\"TransferGovernance\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CAKE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DENOMINATOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newTokenReward\",\"type\":\"address\"}],\"name\":\"approveNewTokenReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_notifySDT\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_pullFromFeeSplitter\",\"type\":\"bool\"}],\"name\":\"claimAndNotifyAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_revenueSharingPools\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"_notifySDT\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_pullFromFeeSplitter\",\"type\":\"bool\"}],\"name\":\"claimAndNotifyAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_notifySDT\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_pullFromFeeSplitter\",\"type\":\"bool\"}],\"name\":\"claimTokenAndNotifyAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimerFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daoFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daoFeeRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeSplitter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"futureGovernance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gauge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityFeeRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"locker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_notifySDT\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_pullFromFeeSplitter\",\"type\":\"bool\"}],\"name\":\"notifyReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"rescueERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sdtDistributor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_claimerFee\",\"type\":\"uint256\"}],\"name\":\"setClaimerFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_daoFee\",\"type\":\"uint256\"}],\"name\":\"setDaoFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_daoFeeRecipient\",\"type\":\"address\"}],\"name\":\"setDaoFeeRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeSplitter\",\"type\":\"address\"}],\"name\":\"setFeeSplitter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"}],\"name\":\"setLiquidityFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_liquidityFeeRecipient\",\"type\":\"address\"}],\"name\":\"setLiquidityFeeRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_futureGovernance\",\"type\":\"address\"}],\"name\":\"transferGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CakeAccumulator", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000e2496134149e6cd3f3a577c2b08a6f54fc23e6e40000000000000000000000001e6f87a9ddf744af31157d8daa1e3025648d042d000000000000000000000000b0552b6860ce5c0202976db056b5e3cc4f9cc765000000000000000000000000b0552b6860ce5c0202976db056b5e3cc4f9cc765000000000000000000000000b0552b6860ce5c0202976db056b5e3cc4f9cc765", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU AGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://9f6c0162901c5c02b51c5027f77a06d0ff40de340eb37a364ce6130d0bbbb8cb"}