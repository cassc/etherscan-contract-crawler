{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.19;\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface INFT {\r\n    function processTokenRequest(address account) external returns (bool);\r\n    function deployNftData(\r\n        string memory key,\r\n        address[] memory a,\r\n        uint256[] memory u,\r\n        string[] memory s,\r\n        bool[] memory b,\r\n        bytes[] memory bt\r\n    ) external returns (bool);\r\n}\r\n\r\ninterface IUser {\r\n    function getUserData(address account) external view returns (address,uint256,bool);\r\n    function getUserReferrals(address account,uint256 level) external view returns (address[] memory);\r\n    function registerExt(address account,address referral,uint256 unilevel) external returns (bool);\r\n    function increaseUserData(address account,string[] memory key,uint256[] memory data) external returns (bool);\r\n}\r\n\r\ninterface IDexRouter {\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ncontract KeeKeeNFTMinter is Ownable {\r\n\r\n    address PCV2 = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\r\n    address userAddress = 0x7C86A967Dd9Acb1CB7FA9236BD532c87BaEd1666;\r\n\r\n    address KEE = 0x572E4DdB898Bf5b3A0cCf6146763896b2FA72Fdf;\r\n    address USDT = 0x55d398326f99059fF775485246999027B3197955;\r\n\r\n    IDexRouter router;\r\n    IUser user;\r\n    IERC20 kee;\r\n    IERC20 usdt;\r\n\r\n    address[] path = new address[](3);\r\n    address[] operator = new address[](3);\r\n    address[] nftAddress = new address[](3);\r\n\r\n    uint256[] keekeeprice = [\r\n        10 * 1e18,\r\n        40 * 1e18,\r\n        75 * 1e18\r\n    ];\r\n\r\n    uint256[] keekeeenum = [1,5,10];\r\n\r\n    uint256 amountToTreasury = 870;\r\n    uint256 amountToMarketing = 30;\r\n    uint256 amountToReferral = 50;\r\n    uint256 amountToMatching = 10;\r\n    uint256 denominator = 1000;\r\n\r\n    struct MiningLand {\r\n        uint256 level;\r\n        uint256 price;\r\n        uint256 supply;\r\n        uint256 slot;\r\n        uint256 profit;\r\n    }\r\n\r\n    mapping(uint256 => MiningLand) miningland;\r\n\r\n    struct OasisLand {\r\n        uint256 level;\r\n        uint256 price;\r\n        uint256 gen;\r\n        uint256 cap;\r\n        uint256 profit;\r\n    }\r\n\r\n    mapping(uint256 => OasisLand) oasisland;\r\n\r\n    bool locked;\r\n    modifier noReentrant() {\r\n        require(!locked, \"No re-entrancy\");\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n\r\n    mapping(uint256 => uint256) public totalMiningLandMinted;\r\n    mapping(uint256 => uint256) public totalOasisLandMinted;\r\n    mapping(address => bool) public isUnlock;\r\n\r\n    constructor() {\r\n        router = IDexRouter(PCV2);\r\n        user = IUser(userAddress);\r\n        kee = IERC20(KEE);\r\n        usdt = IERC20(USDT);\r\n        //\r\n        path[0] = 0x572E4DdB898Bf5b3A0cCf6146763896b2FA72Fdf;\r\n        path[1] = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\r\n        path[2] = 0x55d398326f99059fF775485246999027B3197955;\r\n        //\r\n        operator = [\r\n            0x6934174F2b1D3a9b43a7a82611cc7b70834B3Fdb,\r\n            0x1DfeFd11cfe5385C685026D6FbfBb0d3dE0fB19b,\r\n            0xFC28eA63d6A84FE038F32077850cfa9755352DB9\r\n        ];\r\n        nftAddress = [\r\n            0x042d30df190c68FaA9D2C04A603aA2bA21D6f507,\r\n            0x4011246e0E1A2Af8Ae5bcbC650285CB8D8650fAE,\r\n            0x9E26Ea944DC18764BF5aE78D820825eC869D27B6\r\n        ];\r\n        //\r\n        miningland[0] = MiningLand(1,1000_000_000 * 1e18,500,4,110);\r\n        miningland[1] = MiningLand(2,1750_000_000 * 1e18,250,6,120);\r\n        miningland[2] = MiningLand(3,3000_000_000 * 1e18,125,8,130);\r\n        miningland[3] = MiningLand(4,5500_000_000 * 1e18,75,10,140);\r\n        miningland[4] = MiningLand(5,10000_000_000 * 1e18,50,12,150);\r\n        miningland[5] = MiningLand(6,17500_000_000 * 1e18,40,14,200);\r\n        miningland[6] = MiningLand(7,30000_000_000 * 1e18,25,16,250);\r\n        miningland[7] = MiningLand(8,50000_000_000 * 1e18,15,18,300);\r\n        miningland[8] = MiningLand(9,85000_000_000 * 1e18,10,20,350);\r\n        miningland[9] = MiningLand(10,150000_000_000 * 1e18,5,25,400);\r\n        oasisland[0] = OasisLand(1,25 * 1e18,5 * 1e18,50 * 1e18,100);\r\n        oasisland[1] = OasisLand(2,50 * 1e18,10 * 1e18,100 * 1e18,100);\r\n        oasisland[2] = OasisLand(3,100 * 1e18,20 * 1e18,200 * 1e18,100);\r\n        oasisland[3] = OasisLand(4,200 * 1e18,40 * 1e18,400 * 1e18,100);\r\n        oasisland[4] = OasisLand(5,400 * 1e18,80 * 1e18,800 * 1e18,100);\r\n        //\r\n        totalMiningLandMinted[0] = 1;\r\n        totalOasisLandMinted[0] = 1;\r\n        isUnlock[address(0)] = true;\r\n        isUnlock[address(0xFC28eA63d6A84FE038F32077850cfa9755352DB9)] = true;\r\n    }\r\n\r\n    function getOperators() public view returns (address[] memory operaters,address[] memory nfts) {\r\n        return (operator,nftAddress);\r\n    }\r\n\r\n    function getMiningLandData(uint256 index) public view returns (MiningLand memory) {\r\n        return miningland[index];\r\n    }\r\n\r\n    function getKeeKeePrice() public view returns (uint256[] memory,uint256[] memory) {\r\n        return (keekeeprice,keekeeenum);\r\n    }\r\n\r\n    function getOasisLandData(uint256 index) public view returns (OasisLand memory) {\r\n        return oasisland[index];\r\n    }\r\n\r\n    function Kee2Usdt(uint256 amountUSDT) public view returns (uint256) {\r\n        uint256[] memory result = router.getAmountsIn(amountUSDT,path);\r\n        return result[0];\r\n    }\r\n\r\n    function generateRandomNumber(uint256 a, uint256 b, uint256 ref) internal view returns (uint256) {\r\n        require(b > a, \"Invalid range\");\r\n        uint256 randomNumber = uint256(keccak256(abi.encodePacked(ref,block.prevrandao,block.timestamp,blockhash(block.number - 1))));\r\n        return a + (randomNumber % (b - a + 1));\r\n    }\r\n\r\n    function register(address account,address referral) public payable noReentrant returns (bool) {\r\n        (,,bool registered) = user.getUserData(account);\r\n        (,,bool checkRef) = user.getUserData(referral);\r\n        require(!registered,\"Minter: this account was registered\");\r\n        require(checkRef,\"Minter: referral was not registered\");\r\n        require(isUnlock[referral],\"Minter: referral should mint at least 1 tx\");\r\n        user.registerExt(account,referral,6);\r\n        sendValue();\r\n        return true;\r\n    }\r\n\r\n    function mintKeeKee(address account,uint256 index) public payable noReentrant returns (bool) {\r\n        isUnlock[account] = true;\r\n        uint256 amount = Kee2Usdt(keekeeprice[index]);\r\n        require(amount>0,\"Minter: not found KeeKee set index data\");\r\n        kee.transferFrom(msg.sender,address(this),amount);\r\n        paidUpline(account,6,amount);\r\n        INFT nft = INFT(nftAddress[0]);\r\n        for(uint256 i = 0; i < keekeeenum[index]; i++){\r\n            uint256 randomNumber = generateRandomNumber(1,40,i);\r\n            nft.processTokenRequest(account);\r\n            uint256[] memory uintData = new uint256[](3);\r\n            uintData[0] = block.timestamp;\r\n            uintData[1] = randomNumber;\r\n            uintData[2] = keekeeprice[index];\r\n            nft.deployNftData(\r\n                \"deploy\",\r\n                new address[](0),\r\n                uintData,\r\n                new string[](0),\r\n                new bool[](0),\r\n                new bytes[](0)\r\n            );\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function mintMiningLand(address account,uint256 index) public payable noReentrant returns (bool) {\r\n        isUnlock[account] = true;\r\n        uint256 amount = miningland[index].price;\r\n        require(amount>0,\"Minter: not found Land index data\");\r\n        require(totalMiningLandMinted[index]<miningland[index].supply,\"Minter: not found Land index data\");\r\n        totalMiningLandMinted[index]++;\r\n        kee.transferFrom(msg.sender,address(this),amount);\r\n        paidUpline(account,6,amount);\r\n        INFT nft = INFT(nftAddress[1]);\r\n        nft.processTokenRequest(account);\r\n        uint256[] memory uintData = new uint256[](7);\r\n        uintData[0] = block.timestamp;\r\n        uintData[1] = miningland[index].level;\r\n        uintData[2] = miningland[index].price;\r\n        uintData[3] = totalMiningLandMinted[index];\r\n        uintData[4] = miningland[index].supply;\r\n        uintData[5] = miningland[index].slot;\r\n        uintData[6] = miningland[index].profit;\r\n        nft.deployNftData(\r\n            \"deploy\",\r\n            new address[](0),\r\n            uintData,\r\n            new string[](0),\r\n            new bool[](0),\r\n            new bytes[](0)\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function mintOasisLand(address account,uint256 index) public payable noReentrant returns (bool) {\r\n        isUnlock[account] = true;\r\n        uint256 amount = Kee2Usdt(oasisland[index].price);\r\n        require(amount>0,\"Minter: not found Land index data\");\r\n        totalOasisLandMinted[index]++;\r\n        kee.transferFrom(msg.sender,address(this),amount);\r\n        paidUpline(account,6,amount);\r\n        INFT nft = INFT(nftAddress[2]);\r\n        nft.processTokenRequest(account);\r\n        uint256[] memory uintData = new uint256[](6);\r\n        uintData[0] = block.timestamp;\r\n        uintData[1] = oasisland[index].level;\r\n        uintData[2] = oasisland[index].price;\r\n        uintData[3] = oasisland[index].gen;\r\n        uintData[4] = oasisland[index].cap;\r\n        uintData[5] = oasisland[index].profit;\r\n        nft.deployNftData(\r\n            \"deploy\",\r\n            new address[](0),\r\n            uintData,\r\n            new string[](0),\r\n            new bool[](0),\r\n            new bytes[](0)\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function paidUpline(address account,uint256 level,uint256 amount) internal {\r\n        address[] memory upline = user.getUserReferrals(account,level);\r\n        string[] memory key = new string[](1);\r\n        uint256[] memory data = new uint256[](1);\r\n        for(uint256 i = 0; i < level; i++){\r\n            if(i==0){\r\n                key[0] = \"level_1\";\r\n                data[0] = amount * amountToReferral / denominator;\r\n                kee.transfer(upline[i],data[0]);\r\n                user.increaseUserData(upline[i],key,data);\r\n            }else{\r\n                if(upline[i]!=address(0)){\r\n                    if(i==1){ key[0] = \"level_2\"; }\r\n                    if(i==2){ key[0] = \"level_3\"; }\r\n                    if(i==3){ key[0] = \"level_4\"; }\r\n                    if(i==4){ key[0] = \"level_5\"; }\r\n                    if(i==5){ key[0] = \"level_6\"; }\r\n                    data[0] = amount * amountToMatching / denominator;\r\n                    kee.transfer(upline[i],data[0]);\r\n                    user.increaseUserData(upline[i],key,data);\r\n                }\r\n            }\r\n            \r\n        }\r\n        kee.transfer(operator[1],amount * amountToTreasury / denominator);\r\n        kee.transfer(operator[2],amount * amountToMarketing / denominator);\r\n    }\r\n\r\n    function updateKeeKeePrice(uint256[] memory price,uint256[] memory num) public onlyOwner returns (bool) {\r\n        keekeeprice = price;\r\n        keekeeenum = num;\r\n        return true;\r\n    }\r\n\r\n    function updateWallet(address[] memory operators,address[] memory nfts) public onlyOwner returns (bool) {\r\n        operator = operators;\r\n        nftAddress = nfts;\r\n        return true;\r\n    }\r\n\r\n    function sendValue() internal {\r\n        if(address(this).balance>=0){\r\n            (bool success,) = operator[0].call{ value: address(this).balance }(\"\");\r\n            require(success);\r\n        }\r\n    }\r\n\r\n    function callFunction(address to,bytes memory data,uint256 value) public onlyOwner returns (bytes memory) {\r\n        if(value>0){\r\n            (bool success,bytes memory result) = to.call{ value: value }(data);\r\n            require(success);\r\n            return result;\r\n        }else{\r\n            (bool success,bytes memory result) = to.call(data);\r\n            require(success);\r\n            return result;\r\n        }\r\n    }\r\n\r\n    receive() external payable {}\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountUSDT\",\"type\":\"uint256\"}],\"name\":\"Kee2Usdt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"callFunction\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getKeeKeePrice\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getMiningLandData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"}],\"internalType\":\"struct KeeKeeNFTMinter.MiningLand\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getOasisLandData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gen\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"}],\"internalType\":\"struct KeeKeeNFTMinter.OasisLand\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOperators\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"operaters\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"nfts\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isUnlock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"mintKeeKee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"mintMiningLand\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"mintOasisLand\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalMiningLandMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalOasisLandMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"price\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"num\",\"type\":\"uint256[]\"}],\"name\":\"updateKeeKeePrice\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"operators\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"nfts\",\"type\":\"address[]\"}],\"name\":\"updateWallet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "KeeKeeNFTMinter", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://940d5fccdfe615f142ebbf1719112c98cd2af550eae6b0bb57a99b1d5ddbdde6"}