{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.7;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary SafeMathInt {\r\n    int256 private constant MIN_INT256 = int256(1) << 255;\r\n    int256 private constant MAX_INT256 = ~(int256(1) << 255);\r\n\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a * b;\r\n\r\n        // Detect overflow when multiplying MIN_INT256 with -1\r\n        require(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));\r\n        require((b == 0) || (c / b == a));\r\n        return c;\r\n    }\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        // Prevent overflow when dividing MIN_INT256 by -1\r\n        require(b != -1 || a != MIN_INT256);\r\n\r\n        // Solidity already throws when dividing by 0.\r\n        return a / b;\r\n    }\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\r\n        return c;\r\n    }\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\r\n        return c;\r\n    }\r\n    function abs(int256 a) internal pure returns (int256) {\r\n        require(a != MIN_INT256);\r\n        return a < 0 ? -a : a;\r\n    }\r\n    function toUint256Safe(int256 a) internal pure returns (uint256) {\r\n        require(a >= 0);\r\n        return uint256(a);\r\n    }\r\n}\r\n\r\nlibrary SafeMathUint {\r\n  function toInt256Safe(uint256 a) internal pure returns (int256) {\r\n    int256 b = int256(a);\r\n    require(b >= 0);\r\n    return b;\r\n  }\r\n}\r\n\r\nlibrary IterableMapping {\r\n    struct Map {\r\n        address[] keys;\r\n        mapping(address => uint) values;\r\n        mapping(address => uint) indexOf;\r\n        mapping(address => bool) inserted;\r\n    }\r\n\r\n    function get(Map storage map, address key) public view returns (uint) {\r\n        return map.values[key];\r\n    }\r\n\r\n    function getIndexOfKey(Map storage map, address key) public view returns (int) {\r\n        if(!map.inserted[key]) {\r\n            return -1;\r\n        }\r\n        return int(map.indexOf[key]);\r\n    }\r\n\r\n    function getKeyAtIndex(Map storage map, uint index) public view returns (address) {\r\n        return map.keys[index];\r\n    }\r\n\r\n    function size(Map storage map) public view returns (uint) {\r\n        return map.keys.length;\r\n    }\r\n\r\n    function set(Map storage map, address key, uint val) public {\r\n        if (map.inserted[key]) {\r\n            map.values[key] = val;\r\n        } else {\r\n            map.inserted[key] = true;\r\n            map.values[key] = val;\r\n            map.indexOf[key] = map.keys.length;\r\n            map.keys.push(key);\r\n        }\r\n    }\r\n\r\n    function remove(Map storage map, address key) public {\r\n        if (!map.inserted[key]) {\r\n            return;\r\n        }\r\n\r\n        delete map.inserted[key];\r\n        delete map.values[key];\r\n\r\n        uint index = map.indexOf[key];\r\n        uint lastIndex = map.keys.length - 1;\r\n        address lastKey = map.keys[lastIndex];\r\n\r\n        map.indexOf[lastKey] = index;\r\n        delete map.indexOf[key];\r\n\r\n        map.keys[index] = lastKey;\r\n        map.keys.pop();\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor () public {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n    function initialize(address, address) external;\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IERC20Metadata is IERC20 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    constructor(string memory name_, string memory symbol_) public {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    function _transfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n}\r\n\r\ninterface DividendPayingTokenInterface {\r\n  function dividendOf(address _owner) external view returns(uint256);\r\n  function distributeDividends() external payable;\r\n  function withdrawDividend() external;\r\n  event DividendsDistributed(\r\n    address indexed from,\r\n    uint256 weiAmount\r\n  );\r\n event DividendWithdrawn(\r\n    address indexed to,\r\n    uint256 weiAmount\r\n  );\r\n}\r\n\r\ninterface DividendPayingTokenOptionalInterface {\r\n  function withdrawableDividendOf(address _owner) external view returns(uint256);\r\n  function withdrawnDividendOf(address _owner) external view returns(uint256);\r\n  function accumulativeDividendOf(address _owner) external view returns(uint256);\r\n}\r\n\r\n/// @title Dividend-Paying Token\r\n/// @author Roger Wu (https://github.com/roger-wu)\r\n/// @dev A mintable ERC20 token that allows anyone to pay and distribute ether\r\n///  to token holders as dividends and allows token holders to withdraw their dividends.\r\n///  Reference: the source code of PoWH3D: https://etherscan.io/address/0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe#code\r\ncontract DividendPayingToken is ERC20, DividendPayingTokenInterface, DividendPayingTokenOptionalInterface {\r\n  using SafeMath for uint256;\r\n  using SafeMathUint for uint256;\r\n  using SafeMathInt for int256;\r\n\r\n  // With `magnitude`, we can properly distribute dividends even if the amount of received ether is small.\r\n  // For more discussion about choosing the value of `magnitude`,\r\n  //  see https://github.com/ethereum/EIPs/issues/1726#issuecomment-472352728\r\n  uint256 constant internal magnitude = 2**128;\r\n  uint256 internal magnifiedDividendPerShare;\r\n  uint256 public totalDividendsDistributed;\r\n\r\n  // About dividendCorrection:\r\n  // If the token balance of a `_user` is never changed, the dividend of `_user` can be computed with:\r\n  //   `dividendOf(_user) = dividendPerShare * balanceOf(_user)`.\r\n  // When `balanceOf(_user)` is changed (via minting/burning/transferring tokens),\r\n  //   `dividendOf(_user)` should not be changed,\r\n  //   but the computed value of `dividendPerShare * balanceOf(_user)` is changed.\r\n  // To keep the `dividendOf(_user)` unchanged, we add a correction term:\r\n  //   `dividendOf(_user) = dividendPerShare * balanceOf(_user) + dividendCorrectionOf(_user)`,\r\n  //   where `dividendCorrectionOf(_user)` is updated whenever `balanceOf(_user)` is changed:\r\n  //   `dividendCorrectionOf(_user) = dividendPerShare * (old balanceOf(_user)) - (new balanceOf(_user))`.\r\n  // So now `dividendOf(_user)` returns the same value before and after `balanceOf(_user)` is changed.\r\n  mapping(address => int256) internal magnifiedDividendCorrections;\r\n  mapping(address => uint256) internal withdrawnDividends;\r\n\r\n  constructor(string memory _name, string memory _symbol) public ERC20(_name, _symbol) {}\r\n\r\n  /// @dev Distributes dividends whenever ether is paid to this contract.\r\n  receive() external payable {\r\n    distributeDividends();\r\n  }\r\n\r\n  /// @notice Distributes ether to token holders as dividends.\r\n  /// @dev It reverts if the total supply of tokens is 0.\r\n  /// It emits the `DividendsDistributed` event if the amount of received ether is greater than 0.\r\n  /// About undistributed ether:\r\n  ///   In each distribution, there is a small amount of ether not distributed,\r\n  ///     the magnified amount of which is\r\n  ///     `(msg.value * magnitude) % totalSupply()`.\r\n  ///   With a well-chosen `magnitude`, the amount of undistributed ether\r\n  ///     (de-magnified) in a distribution can be less than 1 wei.\r\n  ///   We can actually keep track of the undistributed ether in a distribution\r\n  ///     and try to distribute it in the next distribution,\r\n  ///     but keeping track of such data on-chain costs much more than\r\n  ///     the saved ether, so we don't do that.\r\n  function distributeDividends() public override payable {\r\n    require(totalSupply() > 0);\r\n    if (msg.value > 0) {\r\n      magnifiedDividendPerShare = magnifiedDividendPerShare.add((msg.value).mul(magnitude) / totalSupply());\r\n      emit DividendsDistributed(msg.sender, msg.value);\r\n      totalDividendsDistributed = totalDividendsDistributed.add(msg.value);\r\n    }\r\n  }\r\n  function withdrawDividend() public virtual override {\r\n    _withdrawDividendOfUser(payable(msg.sender));\r\n  }\r\n  function _withdrawDividendOfUser(address payable user) internal returns (uint256) {\r\n    uint256 _withdrawableDividend = withdrawableDividendOf(user);\r\n    if (_withdrawableDividend > 0) {\r\n      withdrawnDividends[user] = withdrawnDividends[user].add(_withdrawableDividend);\r\n      emit DividendWithdrawn(user, _withdrawableDividend);\r\n      (bool success,) = user.call{value: _withdrawableDividend, gas: 3000}(\"\");\r\n      if(!success) {\r\n        withdrawnDividends[user] = withdrawnDividends[user].sub(_withdrawableDividend);\r\n        return 0;\r\n      }\r\n      return _withdrawableDividend;\r\n    }\r\n    return 0;\r\n  }\r\n  function dividendOf(address _owner) public view override returns(uint256) {\r\n    return withdrawableDividendOf(_owner);\r\n  }\r\n  function withdrawableDividendOf(address _owner) public view override returns(uint256) {\r\n    return accumulativeDividendOf(_owner).sub(withdrawnDividends[_owner]);\r\n  }\r\n  function withdrawnDividendOf(address _owner) public view override returns(uint256) {\r\n    return withdrawnDividends[_owner];\r\n  }\r\n  function accumulativeDividendOf(address _owner) public view override returns(uint256) {\r\n    return magnifiedDividendPerShare.mul(balanceOf(_owner)).toInt256Safe()\r\n      .add(magnifiedDividendCorrections[_owner]).toUint256Safe() / magnitude;\r\n  }\r\n  function _transfer(address from, address to, uint256 value) internal virtual override {\r\n    require(false);\r\n    int256 _magCorrection = magnifiedDividendPerShare.mul(value).toInt256Safe();\r\n    magnifiedDividendCorrections[from] = magnifiedDividendCorrections[from].add(_magCorrection);\r\n    magnifiedDividendCorrections[to] = magnifiedDividendCorrections[to].sub(_magCorrection);\r\n  }\r\n  function _mint(address account, uint256 value) internal override {\r\n    super._mint(account, value);\r\n    magnifiedDividendCorrections[account] = magnifiedDividendCorrections[account]\r\n      .sub( (magnifiedDividendPerShare.mul(value)).toInt256Safe() );\r\n  }\r\n  function _burn(address account, uint256 value) internal override {\r\n    super._burn(account, value);\r\n    magnifiedDividendCorrections[account] = magnifiedDividendCorrections[account]\r\n      .add( (magnifiedDividendPerShare.mul(value)).toInt256Safe() );\r\n  }\r\n\r\n  function _setBalance(address account, uint256 newBalance) internal {\r\n    uint256 currentBalance = balanceOf(account);\r\n    if(newBalance > currentBalance) {\r\n      uint256 mintAmount = newBalance.sub(currentBalance);\r\n      _mint(account, mintAmount);\r\n    } else if(newBalance < currentBalance) {\r\n      uint256 burnAmount = currentBalance.sub(newBalance);\r\n      _burn(account, burnAmount);\r\n    }\r\n  }\r\n}\r\n\r\ncontract Kodi is ERC20, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    IUniswapV2Router02 public uniswapV2Router;\r\n    address public immutable uniswapV2Pair;\r\n    \r\n    string private _name = \"Kodi\";\r\n    string private _symbol = \"KODI\";\r\n    uint8 private _decimals = 18;\r\n\r\n    KODIDividendTracker public dividendTracker;\r\n    \r\n    bool public isTradingEnabled;\r\n    uint256 private _tradingPausedTimestamp;\r\n    // initialSupply is 100 billion\r\n    uint256 constant initialSupply = 100000000000 * (10**18);\r\n    // max wallet is 2% of initialSupply \r\n    uint256 public maxWalletAmount = initialSupply * 200 / 10000;  \r\n    // max buy and sell tx is 0.2% of initialSupply\r\n    uint256 public maxTxAmount = initialSupply * 20 / 10000; //200_000_000 \r\n    bool private _swapping;\r\n    uint256 public minimumTokensBeforeSwap = 25000000 * (10**18); \r\n    uint256 public gasForProcessing = 300000;\r\n    uint256 private _liquidityTokensToSwap;\r\n    uint256 private _marketingTokensToSwap;\r\n    uint256 private _buyBackTokensToSwap;\r\n    uint256 private _salaryTokensToSwap;\r\n    uint256 private _holdersTokensToSwap;\r\n    \r\n    address public marketingWallet;\r\n    address public liquidityWallet;\r\n    address public buyBackWallet;\r\n    address public salaryWallet;\r\n    \r\n    struct CustomTaxPeriod {\r\n        bytes23 periodName;\r\n        uint8 blocksInPeriod;\r\n        uint256 timeInPeriod;\r\n        uint256 liquidityFeeOnBuy;\r\n        uint256 liquidityFeeOnSell;\r\n        uint256 marketingFeeOnBuy;\r\n        uint256 marketingFeeOnSell;\r\n        uint256 buyBackFeeOnBuy;\r\n        uint256 buyBackFeeOnSell;\r\n        uint256 salaryFeeOnBuy;\r\n        uint256 salaryFeeOnSell;\r\n        uint256 holdersFeeOnBuy;\r\n        uint256 holdersFeeOnSell;\r\n    }\r\n    // Launch taxes\r\n    bool private _isLanched;\r\n    uint256 private _launchStartTimestamp;\r\n    uint256 private _launchBlockNumber;\r\n    uint256 private _launchSellMaximum =  initialSupply * 20 / 10000;\r\n    CustomTaxPeriod private _launch1 = CustomTaxPeriod('launch1',3,0,10000,0,0,0,0,0,0,0,0,0);\r\n    CustomTaxPeriod private _launch2 = CustomTaxPeriod('launch2',0,3600,0,500,0,500,0,1500,0,0,0,1500);\r\n    CustomTaxPeriod private _launch3 = CustomTaxPeriod('launch3',0,82800,0,500,0,500,0,500,0,0,0,1000); \r\n\r\n    // Base taxes\r\n    uint256 public liquidityFeeOnBuy = 100;\r\n    uint256 public marketingFeeOnBuy = 300;\r\n    uint256 public holdersFeeOnBuy = 300;\r\n    uint256 public salaryFeeOnBuy = 100;\r\n    uint256 public buyBackFeeOnBuy = 300;\r\n\r\n    uint256 public liquidityFeeOnSell = 200;\r\n    uint256 public marketingFeeOnSell = 300;\r\n    uint256 public holdersFeeOnSell = 300;\r\n    uint256 public salaryFeeOnSell = 100;\r\n    uint256 public buyBackFeeOnSell = 300;\r\n   \r\n    // Roar taxes\r\n    uint256 private _roarStartTimestamp;\r\n    CustomTaxPeriod private _roar1 = CustomTaxPeriod('roar1', 0,3600,0,0,100,750,0,750,0,0,0,750);\r\n    CustomTaxPeriod private _roar2 = CustomTaxPeriod('roar2', 0,3600,0,0,0,600,0,600,0,0,0,1200);\r\n    CustomTaxPeriod private _roar3 = CustomTaxPeriod('roar3', 0,3600,0,0,0,450,0,450,0,0,0,900);\r\n    \r\n    uint256 private _blacklistTimeLimit = 21600;\r\n    mapping (address => bool) private _isExcludedFromFee;\r\n    mapping (address => bool) private _isExcludedFromMaxTransactionLimit;\r\n    mapping (address => bool) private _isExcludedFromMaxWalletLimit;\r\n    mapping (address => bool) private _isBlacklisted;\r\n    mapping (address => bool) public automatedMarketMakerPairs;\r\n    mapping (address => uint256) private _buyTimesInLaunch;\r\n\r\n    event AutomatedMarketMakerPairChange(address indexed pair, bool indexed value);\r\n    event DividendTrackerChange(address indexed newAddress, address indexed oldAddress);\r\n    event UniswapV2RouterChange(address indexed newAddress, address indexed oldAddress);\r\n    event ExcludeFromFeesChange(address indexed account, bool isExcluded);\r\n    event LiquidityWalletChange(address indexed newLiquidityWallet, address indexed oldLiquidityWallet);\r\n    event MarketingWalletChange(address indexed newMarketingWallet, address indexed oldMarketingWallet);\r\n    event BuyBackWalletChange(address indexed newBuyBackWallet, address indexed oldBuyBackWallet);\r\n    event SalaryWalletChange(address indexed newSalaryWallet, address indexed oldSalaryWallet);\r\n    event GasForProcessingChange(uint256 indexed newValue, uint256 indexed oldValue);\r\n    event FeeOnSellChange(uint256 indexed newValue, uint256 indexed oldValue, string indexed taxType);\r\n    event FeeOnBuyChange(uint256 indexed newValue, uint256 indexed oldValue, string indexed taxType);\r\n    event CustomTaxPeriodChange(uint256 indexed newValue, uint256 indexed oldValue, string indexed taxType, bytes23 period);\r\n    event BlacklistChange(address indexed holder, bool indexed status);\r\n    event KodiRoarChange(bool indexed newValue, bool indexed oldValue);\r\n    event MaxTransactionAmountChange(uint256 indexed newValue, uint256 indexed oldValue);\r\n    event MaxWalletAmountChange(uint256 indexed newValue, uint256 indexed oldValue);\r\n    event MinTokenAmountBeforeSwapChange(uint256 indexed newValue, uint256 indexed oldValue);\r\n    event ExcludeFromMaxTransferChange(address indexed account, bool isExcluded);\r\n    event ExcludeFromMaxWalletChange(address indexed account, bool isExcluded);\r\n    event MinTokenAmountForDividendsChange(uint256 indexed newValue, uint256 indexed oldValue);\r\n    \r\n    event ExcludeFromDividendsChange(address indexed account, bool isExcluded);\r\n    event DividendsSent(uint256 tokensSwapped);\r\n    event SwapAndLiquify(uint256 tokensSwapped, uint256 ethReceived,uint256 tokensIntoLiqudity);\r\n    event ProcessedDividendTracker(\r\n    \tuint256 iterations,\r\n    \tuint256 claims,\r\n        uint256 lastProcessedIndex,\r\n    \tbool indexed automatic,\r\n    \tuint256 gas,\r\n    \taddress indexed processor\r\n    );\r\n\r\n    constructor() public ERC20(\"KODI\", \"KODI\") {\r\n        liquidityWallet = address(0xD7B3DA72a306574F2f806A22521b1E3BD47C86F4);\r\n    \tmarketingWallet = address(0x56baAa0824228d12fAdFbE32514d1dD70BB92E9A);\r\n    \tsalaryWallet = address(0x0e38abe3b61c596c8caaCdd5c75584bF37a94c65);\r\n    \tbuyBackWallet = address(0x208954B59941cF7ab19c7e6FAc0A902f13281f61);\r\n    \t\r\n    \tdividendTracker = new KODIDividendTracker();\r\n    \r\n        //IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0xD99D1c33F9fC3444f8101754aBC46c52416550D1); // Testnet\r\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E); // Mainnet\r\n        address _uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\r\n        uniswapV2Router = _uniswapV2Router;\r\n        uniswapV2Pair = _uniswapV2Pair;\r\n        _setAutomatedMarketMakerPair(_uniswapV2Pair, true);\r\n        \r\n        _isExcludedFromFee[owner()] = true;\r\n        _isExcludedFromFee[address(this)] = true;\r\n    \r\n        dividendTracker.excludeFromDividends(address(dividendTracker));\r\n        dividendTracker.excludeFromDividends(address(this));\r\n        dividendTracker.excludeFromDividends(address(0x000000000000000000000000000000000000dEaD));\r\n        dividendTracker.excludeFromDividends(owner());\r\n        dividendTracker.excludeFromDividends(address(_uniswapV2Router));\r\n\r\n        _isExcludedFromMaxTransactionLimit[address(dividendTracker)] = true;\r\n        _isExcludedFromMaxTransactionLimit[address(this)] = true;\r\n        \r\n        _isExcludedFromMaxWalletLimit[_uniswapV2Pair] = true;\r\n        _isExcludedFromMaxWalletLimit[address(uniswapV2Router)] = true;\r\n        _isExcludedFromMaxWalletLimit[address(this)] = true;\r\n        _isExcludedFromMaxWalletLimit[owner()] = true;\r\n        \r\n        _mint(owner(), initialSupply);\r\n    }\r\n    \r\n    receive() external payable {}\r\n    \r\n    // Setters\r\n    function _getNow() private view returns (uint256) {\r\n        return block.timestamp;\r\n    }\r\n    function launch() public onlyOwner {\r\n        _launchStartTimestamp = _getNow();\r\n        _launchBlockNumber = block.number;\r\n         isTradingEnabled = true;\r\n        _isLanched = true;\r\n    }\r\n    function cancelLaunch() public onlyOwner {\r\n        require(this.isInLaunch(), \"KODI: Launch is not set\");\r\n        _launchStartTimestamp = 0;\r\n        _launchBlockNumber = 0;\r\n    }\r\n    function activateTrading() public onlyOwner {\r\n        isTradingEnabled = true;\r\n    }\r\n    function deactivateTrading() public onlyOwner {\r\n        isTradingEnabled = false;\r\n        _tradingPausedTimestamp = _getNow();\r\n    }\r\n    function setKodiRoar() public onlyOwner {\r\n        require(!this.isInRoar(), \"KODI: Roar is already set\");\r\n        require(isTradingEnabled, \"KODI: Trading must be enabled first\");\r\n        require(!this.isInLaunch(), \"KODI: Must not be in launch period\");\r\n        emit KodiRoarChange(true, false);\r\n        _roarStartTimestamp = _getNow();\r\n    }\r\n    function cancelKodiRoar() public onlyOwner {\r\n        require(this.isInRoar(), \"KODI: Roar is not set\");\r\n        emit KodiRoarChange(false, true);\r\n        _roarStartTimestamp = 0;\r\n    }\r\n    function updateDividendTracker(address newAddress) public onlyOwner {\r\n        require(newAddress != address(dividendTracker), \"KODI: The dividend tracker already has that address\");\r\n        KODIDividendTracker newDividendTracker = KODIDividendTracker(payable(newAddress));\r\n        require(newDividendTracker.owner() == address(this), \"KODI: The new dividend tracker must be owned by the KODI token contract\");\r\n        newDividendTracker.excludeFromDividends(address(newDividendTracker));\r\n        newDividendTracker.excludeFromDividends(address(this));\r\n        newDividendTracker.excludeFromDividends(owner());\r\n        newDividendTracker.excludeFromDividends(address(uniswapV2Router));\r\n        emit DividendTrackerChange(newAddress, address(dividendTracker));\r\n        dividendTracker = newDividendTracker;\r\n    }\r\n    function _setAutomatedMarketMakerPair(address pair, bool value) private {\r\n        require(automatedMarketMakerPairs[pair] != value, \"KODI: Automated market maker pair is already set to that value\");\r\n        automatedMarketMakerPairs[pair] = value;\r\n        if(value) {\r\n            dividendTracker.excludeFromDividends(pair);\r\n        }\r\n        emit AutomatedMarketMakerPairChange(pair, value);\r\n    }\r\n    function excludeFromFees(address account, bool excluded) public onlyOwner {\r\n        require(_isExcludedFromFee[account] != excluded, \"KODI: Account is already the value of 'excluded'\");\r\n        _isExcludedFromFee[account] = excluded;\r\n        emit ExcludeFromFeesChange(account, excluded);\r\n    }\r\n    function excludeFromDividends(address account) public onlyOwner {\r\n        dividendTracker.excludeFromDividends(account);\r\n    }\r\n    function excludeFromMaxTransactionLimit(address account, bool excluded) public onlyOwner {\r\n        require(_isExcludedFromMaxTransactionLimit[account] != excluded, \"KODI: Account is already the value of 'excluded'\");\r\n        _isExcludedFromMaxTransactionLimit[account] = excluded;\r\n        emit ExcludeFromMaxTransferChange(account, excluded);\r\n    }\r\n    function excludeFromMaxWalletLimit(address account, bool excluded) public onlyOwner {\r\n        require(_isExcludedFromMaxWalletLimit[account] != excluded, \"KODI: Account is already the value of 'excluded'\");\r\n        _isExcludedFromMaxWalletLimit[account] = excluded;\r\n        emit ExcludeFromMaxWalletChange(account, excluded);\r\n    }\r\n    function blacklistAccount(address account) public onlyOwner {\r\n        uint256 currentTimestamp = _getNow();\r\n        require(!_isBlacklisted[account], \"KODI: Account is already blacklisted\");\r\n        if (_isLanched) {\r\n            require(currentTimestamp.sub(_launchStartTimestamp) < _blacklistTimeLimit, \"KODI: Time to blacklist accounts has expired\");\r\n        }\r\n        _isBlacklisted[account] = true;\r\n        emit BlacklistChange(account, true);\r\n    }\r\n    function unBlacklistAccount(address account) public onlyOwner {\r\n        require(_isBlacklisted[account], \"KODI: Account is not blacklisted\");\r\n        _isBlacklisted[account] = false;\r\n        emit BlacklistChange(account, false);\r\n    }\r\n    function setLiquidityWallet(address newAddress) public onlyOwner {\r\n        require(liquidityWallet != newAddress, \"KODI: The liquidityWallet is already that address\");\r\n        emit LiquidityWalletChange(newAddress, liquidityWallet);\r\n        liquidityWallet = newAddress;\r\n    }\r\n    function setMarketingWallet(address newAddress) public onlyOwner {\r\n        require(marketingWallet != newAddress, \"KODI: The marketingWallet is already that address\");\r\n        emit MarketingWalletChange(newAddress, marketingWallet);\r\n        marketingWallet = newAddress;\r\n    }\r\n    function setBuyBackWallet(address newAddress) public onlyOwner {\r\n        require(buyBackWallet != newAddress, \"KODI: The buyBackWallet is already that address\");\r\n        emit BuyBackWalletChange(newAddress, buyBackWallet);\r\n        buyBackWallet = newAddress;\r\n    }\r\n    function setSalaryWallet(address newAddress) public onlyOwner {\r\n        require(salaryWallet != newAddress, \"KODI: The salaryWallet is already that address\");\r\n        emit SalaryWalletChange(newAddress, salaryWallet);\r\n        salaryWallet = newAddress;\r\n    }\r\n    function setLiquidityFeeOnBuy(uint256 newvalue) public onlyOwner {\r\n        require(liquidityFeeOnBuy != newvalue, \"KODI: The liquidityFeeOnBuy is already that value\");\r\n        emit FeeOnBuyChange(newvalue, liquidityFeeOnBuy, \"liquidityFeeOnBuy\");\r\n        liquidityFeeOnBuy = newvalue;\r\n    }\r\n    function setMarketingFeeOnBuy(uint256 newvalue) public onlyOwner {\r\n        require(marketingFeeOnBuy != newvalue, \"KODI: The marketingFeeOnBuy is already that value\");\r\n        emit FeeOnBuyChange(newvalue, marketingFeeOnBuy, \"marketingFeeOnBuy\");\r\n        marketingFeeOnBuy = newvalue;\r\n    }\r\n    function setHolderFeeOnBuy(uint256 newvalue) public onlyOwner {\r\n        require(holdersFeeOnBuy != newvalue, \"KODI: The holdersFeeOnBuy is already that value\");\r\n        emit FeeOnBuyChange(newvalue, holdersFeeOnBuy, \"holdersFeeOnBuy\");\r\n        holdersFeeOnBuy = newvalue;\r\n    }\r\n    function setBuyBackFeeOnBuy(uint256 newvalue) public onlyOwner {\r\n        require(buyBackFeeOnBuy != newvalue, \"KODI: The buyBackFeeOnBuy is already that value\");\r\n        emit FeeOnBuyChange(newvalue, buyBackFeeOnBuy, \"buyBackFeeOnBuy\");\r\n        buyBackFeeOnBuy = newvalue;\r\n    }\r\n    function setSalaryFeeOnBuy(uint256 newvalue) public onlyOwner {\r\n        require(salaryFeeOnBuy != newvalue, \"KODI: The salaryFeeOnBuy is already that value\");\r\n        emit FeeOnBuyChange(newvalue, salaryFeeOnBuy, \"salaryFeeOnBuy\");\r\n        salaryFeeOnBuy = newvalue;\r\n    }\r\n    function setLiquidityFeeOnSell(uint256 newvalue) public onlyOwner {\r\n        require(liquidityFeeOnSell != newvalue, \"KODI: The liquidityFeeOnSell is already that value\");\r\n        emit FeeOnSellChange(newvalue, liquidityFeeOnSell, \"liquidityFeeOnSell\");\r\n        liquidityFeeOnSell = newvalue;\r\n    }\r\n    function setMarketingFeeOnSell(uint256 newvalue) public onlyOwner {\r\n        require(marketingFeeOnSell != newvalue, \"KODI: The marketingFeeOnSell is already that value\");\r\n        emit FeeOnSellChange(newvalue, marketingFeeOnSell, \"marketingFeeOnSell\");\r\n        marketingFeeOnSell = newvalue;\r\n    }\r\n    function setHolderFeeOnSell(uint256 newvalue) public onlyOwner {\r\n        require(holdersFeeOnSell != newvalue, \"KODI: The holdersFeeOnSell is already that value\");\r\n        emit FeeOnSellChange(newvalue, holdersFeeOnSell, \"holdersFeeOnSell\");\r\n        holdersFeeOnSell = newvalue;\r\n    }\r\n    function setBuyBackFeeOnSell(uint256 newvalue) public onlyOwner {\r\n        require(buyBackFeeOnSell != newvalue, \"KODI: The buyBackFeeOnSell is already that value\");\r\n        emit FeeOnSellChange(newvalue, buyBackFeeOnSell, \"buyBackFeeOnSell\");\r\n        buyBackFeeOnSell = newvalue;\r\n    }\r\n    function setSalaryFeeOnSell(uint256 newvalue) public onlyOwner {\r\n        require(salaryFeeOnSell != newvalue, \"KODI: The salaryFeeOnSell is already that value\");\r\n        emit FeeOnSellChange(newvalue, salaryFeeOnSell, \"salaryFeeOnSell\");\r\n        salaryFeeOnSell = newvalue;\r\n    }\r\n    function setRoar1BuyFees(uint256 _liquidityFeeOnBuy,uint256 _marketingFeeOnBuy,uint256 _buyBackFeeOnBuy,uint256 _salaryFeeOnBuy,uint256 _holdersFeeOnBuy) public onlyOwner {\r\n        _setCustomBuyTaxPeriod(_roar1,_liquidityFeeOnBuy, _marketingFeeOnBuy,_buyBackFeeOnBuy,_salaryFeeOnBuy,_holdersFeeOnBuy);\r\n    }\r\n    function setRoar1SellFees(uint256 _liquidityFeeOnSell,uint256 _marketingFeeOnSell,uint256 _buyBackFeeOnSell,uint256 _salaryFeeOnSell,uint256 _holdersFeeOnSell) public onlyOwner {\r\n        _setCustomSellTaxPeriod(_roar1,_liquidityFeeOnSell, _marketingFeeOnSell,_buyBackFeeOnSell,_salaryFeeOnSell,_holdersFeeOnSell);\r\n    }\r\n    function setRoar2BuyFees(uint256 _liquidityFeeOnBuy,uint256 _marketingFeeOnBuy,uint256 _buyBackFeeOnBuy,uint256 _salaryFeeOnBuy,uint256 _holdersFeeOnBuy) public onlyOwner {\r\n        _setCustomBuyTaxPeriod(_roar2,_liquidityFeeOnBuy, _marketingFeeOnBuy,_buyBackFeeOnBuy,_salaryFeeOnBuy,_holdersFeeOnBuy);\r\n    }\r\n    function setRoar2SellFees(uint256 _liquidityFeeOnSell,uint256 _marketingFeeOnSell,uint256 _buyBackFeeOnSell,uint256 _salaryFeeOnSell,uint256 _holdersFeeOnSell) public onlyOwner {\r\n        _setCustomSellTaxPeriod(_roar2,_liquidityFeeOnSell, _marketingFeeOnSell,_buyBackFeeOnSell,_salaryFeeOnSell,_holdersFeeOnSell);\r\n    }\r\n    function setRoar3BuyFees(uint256 _liquidityFeeOnBuy,uint256 _marketingFeeOnBuy,uint256 _buyBackFeeOnBuy,uint256 _salaryFeeOnBuy,uint256 _holdersFeeOnBuy) public onlyOwner {\r\n        _setCustomBuyTaxPeriod(_roar3,_liquidityFeeOnBuy, _marketingFeeOnBuy,_buyBackFeeOnBuy,_salaryFeeOnBuy,_holdersFeeOnBuy);\r\n    }\r\n    function setRoar3SellFees(uint256 _liquidityFeeOnSell,uint256 _marketingFeeOnSell,uint256 _buyBackFeeOnSell,uint256 _salaryFeeOnSell,uint256 _holdersFeeOnSell) public onlyOwner {\r\n        _setCustomSellTaxPeriod(_roar3,_liquidityFeeOnSell, _marketingFeeOnSell,_buyBackFeeOnSell,_salaryFeeOnSell,_holdersFeeOnSell);\r\n    }\r\n    function setUniswapV2Router(address newAddress) public onlyOwner {\r\n        require(newAddress != address(uniswapV2Router), \"KODI: The router already has that address\");\r\n        emit UniswapV2RouterChange(newAddress, address(uniswapV2Router));\r\n        uniswapV2Router = IUniswapV2Router02(newAddress);\r\n    }\r\n    function setGasForProcessing(uint256 newValue) public onlyOwner {\r\n        require(newValue >= 200000 && newValue <= 500000, \"KODI: gasForProcessing must be between 200,000 and 500,000\");\r\n        require(newValue != gasForProcessing, \"KODI: Cannot update gasForProcessing to same value\");\r\n        emit GasForProcessingChange(newValue, gasForProcessing);\r\n        gasForProcessing = newValue;\r\n    }\r\n    function setMaxTxAmount(uint256 newValue) public onlyOwner {\r\n        require(newValue != maxTxAmount, \"KODI: Cannot update maxTxAmount to same value\");\r\n        emit MaxTransactionAmountChange(newValue, maxTxAmount);\r\n        maxTxAmount = newValue;\r\n    }\r\n    function setMaxWalletAmount(uint256 newValue) public onlyOwner {\r\n        require(newValue != maxWalletAmount, \"KODI: Cannot update maxWalletAmount to same value\");\r\n        emit MaxWalletAmountChange(newValue, maxWalletAmount);\r\n        maxWalletAmount = newValue;\r\n    }\r\n    function setMinimumTokensBeforeSwap(uint256 newValue) public onlyOwner {\r\n        require(newValue != minimumTokensBeforeSwap, \"KODI: Cannot update minimumTokensBeforeSwap to same value\");\r\n        emit MinTokenAmountBeforeSwapChange(newValue, minimumTokensBeforeSwap);\r\n        minimumTokensBeforeSwap = newValue;\r\n    }\r\n    function setMinimumTokenBalanceForDividends(uint256 newValue) public onlyOwner {\r\n        dividendTracker.setTokenBalanceForDividends(newValue);\r\n    }\r\n    function updateClaimWait(uint256 claimWait) external onlyOwner {\r\n        dividendTracker.updateClaimWait(claimWait);\r\n    }\r\n    function processDividendTracker(uint256 gas) external {\r\n\t\t(uint256 iterations, uint256 claims, uint256 lastProcessedIndex) = dividendTracker.process(gas);\r\n\t\temit ProcessedDividendTracker(iterations, claims, lastProcessedIndex, false, gas, tx.origin);\r\n    }\r\n    function claim() external {\r\n\t\tdividendTracker.processAccount(payable(msg.sender), false);\r\n    }\r\n    \r\n    // Getters\r\n    function isInRoar() external view returns (bool) {\r\n        uint256 currentTimestamp = !isTradingEnabled && _tradingPausedTimestamp > _roarStartTimestamp  ? _tradingPausedTimestamp : _getNow();\r\n        uint256 totalRoarTime = _roar1.timeInPeriod.add(_roar2.timeInPeriod).add(_roar3.timeInPeriod);\r\n        uint256 timeSinceRoar = currentTimestamp.sub(_roarStartTimestamp);\r\n        if(timeSinceRoar < totalRoarTime) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function isInLaunch() external view returns (bool) {\r\n        uint256 currentTimestamp = !isTradingEnabled && _tradingPausedTimestamp > _launchStartTimestamp  ? _tradingPausedTimestamp : _getNow();\r\n        uint256 timeSinceLaunch = currentTimestamp.sub(_launchStartTimestamp);\r\n        uint256 blocksSinceLaunch = block.number.sub(_launchBlockNumber);\r\n        uint256 totalLaunchTime =  _launch1.timeInPeriod.add(_launch2.timeInPeriod).add(_launch3.timeInPeriod);\r\n        \r\n        if(_isLanched && (timeSinceLaunch < totalLaunchTime || blocksSinceLaunch < _launch1.blocksInPeriod )) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function getClaimWait() external view returns(uint256) {\r\n        return dividendTracker.claimWait();\r\n    }\r\n    function getTotalDividendsDistributed() external view returns (uint256) {\r\n        return dividendTracker.totalDividendsDistributed();\r\n    }\r\n    function withdrawableDividendOf(address account) public view returns(uint256) {\r\n    \treturn dividendTracker.withdrawableDividendOf(account);\r\n  \t}\r\n\tfunction dividendTokenBalanceOf(address account) public view returns (uint256) {\r\n\t\treturn dividendTracker.balanceOf(account);\r\n\t}\r\n    function getAccountDividendsInfo(address account)\r\n        external view returns (\r\n            address,\r\n            int256,\r\n            int256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256) {\r\n        return dividendTracker.getAccount(account);\r\n    }\r\n    function getLastProcessedIndex() external view returns(uint256) {\r\n    \treturn dividendTracker.getLastProcessedIndex();\r\n    }\r\n    function getNumberOfDividendTokenHolders() external view returns(uint256) {\r\n        return dividendTracker.getNumberOfTokenHolders();\r\n    }\r\n    function getRoar1BuyFees() external view returns (uint256, uint256, uint256,uint256, uint256){\r\n        return (_roar1.liquidityFeeOnBuy,_roar1.marketingFeeOnBuy, _roar1.buyBackFeeOnBuy, _roar1.salaryFeeOnBuy, _roar1.holdersFeeOnBuy);\r\n    }\r\n    function getRoar1SellFees() external view returns (uint256, uint256, uint256,uint256, uint256){\r\n        return (_roar1.liquidityFeeOnSell,_roar1.marketingFeeOnSell, _roar1.buyBackFeeOnSell, _roar1.salaryFeeOnSell, _roar1.holdersFeeOnSell);\r\n    }\r\n    function getRoar2BuyFees() external view returns (uint256, uint256, uint256,uint256, uint256){\r\n        return (_roar2.liquidityFeeOnBuy,_roar2.marketingFeeOnBuy, _roar2.buyBackFeeOnBuy, _roar2.salaryFeeOnBuy, _roar2.holdersFeeOnBuy);\r\n    }\r\n    function getRoar2SellFees() external view returns (uint256, uint256, uint256,uint256, uint256){\r\n        return (_roar2.liquidityFeeOnSell,_roar2.marketingFeeOnSell, _roar2.buyBackFeeOnSell, _roar2.salaryFeeOnSell, _roar2.holdersFeeOnSell);\r\n    }\r\n    function getRoar3BuyFees() external view returns (uint256, uint256, uint256,uint256, uint256){\r\n        return (_roar3.liquidityFeeOnBuy,_roar3.marketingFeeOnBuy, _roar3.buyBackFeeOnBuy, _roar3.salaryFeeOnBuy, _roar3.holdersFeeOnBuy);\r\n    }\r\n    function getRoar3SellFees() external view returns (uint256, uint256, uint256,uint256, uint256){\r\n        return (_roar3.liquidityFeeOnSell,_roar3.marketingFeeOnSell, _roar3.buyBackFeeOnSell, _roar3.salaryFeeOnSell, _roar3.holdersFeeOnSell);\r\n    }\r\n    \r\n    // Main\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal override {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        if(amount == 0) {\r\n            super._transfer(from, to, 0);\r\n            return;\r\n        }\r\n        \r\n        bool isBuyFromLp = automatedMarketMakerPairs[from];\r\n        bool isSelltoLp = automatedMarketMakerPairs[to];\r\n        bool _isInLaunch = this.isInLaunch();\r\n        \r\n        uint256 currentTimestamp = !isTradingEnabled && _tradingPausedTimestamp > _launchStartTimestamp  ? _tradingPausedTimestamp : _getNow();\r\n        \r\n        if(from != owner() && to != owner()) {\r\n            require(isTradingEnabled, \"KODI: Trading is currently disabled.\");\r\n            require(!_isBlacklisted[to], \"KODI: Account is blacklisted\");\r\n            require(!_isBlacklisted[from], \"KODI: Account is blacklisted\");\r\n            if (_isInLaunch && currentTimestamp.sub(_launchStartTimestamp) <= 300 && isBuyFromLp) {\r\n                require(currentTimestamp.sub(_buyTimesInLaunch[to]) > 60, \"KODI: Cannot buy more than once per min in first 5min of launch\");\r\n            }\r\n            if (!_isExcludedFromMaxTransactionLimit[to] && !_isExcludedFromMaxTransactionLimit[from]) {\r\n                require(amount <= maxTxAmount, \"KODI: Buy amount exceeds the maxTxBuyAmount.\");\r\n            }\r\n            if (!_isExcludedFromMaxWalletLimit[to]) {\r\n                require(balanceOf(to).add(amount) <= maxWalletAmount, \"KODI: Expected wallet amount exceeds the maxWalletAmount.\");\r\n            }\r\n        }\r\n        \r\n        bool canSwap = balanceOf(address(this)) >= minimumTokensBeforeSwap;\r\n        \r\n        if (\r\n            isTradingEnabled && \r\n            canSwap &&\r\n            !_swapping &&\r\n            !automatedMarketMakerPairs[from] &&\r\n            from != liquidityWallet && to != liquidityWallet &&\r\n            from != marketingWallet && to != marketingWallet &&\r\n            from != buyBackWallet && to != buyBackWallet &&\r\n            from != salaryWallet && to != salaryWallet\r\n        ) {\r\n            _swapping = true;\r\n            _swapAndLiquify();\r\n            _swapping = false;\r\n        }\r\n        \r\n        bool takeFee = !_swapping && isTradingEnabled;\r\n        \r\n        if(_isExcludedFromFee[from] || _isExcludedFromFee[to]){\r\n            takeFee = false;\r\n        }\r\n        if (takeFee) {\r\n            (uint256 returnAmount, uint256 fee) = _getCurrentTotalFee(isBuyFromLp, amount);\r\n            amount = returnAmount;\r\n            super._transfer(from, address(this), fee);\r\n        }\r\n        \r\n        if (_isInLaunch && currentTimestamp.sub(_launchStartTimestamp) <= 300) {\r\n            if (to != owner() && isBuyFromLp  && currentTimestamp.sub(_buyTimesInLaunch[to]) > 60) {\r\n                _buyTimesInLaunch[to] = currentTimestamp;\r\n            }\r\n        }\r\n        \r\n        super._transfer(from, to, amount);\r\n        \r\n        try dividendTracker.setBalance(payable(from), balanceOf(from)) {} catch {}\r\n        try dividendTracker.setBalance(payable(to), balanceOf(to)) {} catch {}\r\n        \r\n        if(!_swapping) {\r\n\t    \tuint256 gas = gasForProcessing;\r\n\t    \ttry dividendTracker.process(gas) returns (uint256 iterations, uint256 claims, uint256 lastProcessedIndex) {\r\n\t    \t\temit ProcessedDividendTracker(iterations, claims, lastProcessedIndex, true, gas, tx.origin);\r\n\t    \t} \r\n\t    \tcatch {}\r\n        }\r\n    }\r\n    function _getCurrentTotalFee(bool isBuyFromLp, uint256 amount) internal returns (uint256 returnAmount, uint256 fee) {\r\n        uint256 _liquidityFee = isBuyFromLp ? liquidityFeeOnBuy : liquidityFeeOnSell;\r\n        uint256 _marketingFee = isBuyFromLp ? marketingFeeOnBuy : marketingFeeOnSell;\r\n        uint256 _salaryFee = isBuyFromLp ? salaryFeeOnBuy : salaryFeeOnSell;\r\n        uint256 _buyBackFee = isBuyFromLp ? buyBackFeeOnBuy : buyBackFeeOnSell;\r\n        uint256 _holdersFee = isBuyFromLp ? holdersFeeOnBuy : holdersFeeOnSell;\r\n        \r\n        if (this.isInLaunch()) {\r\n            bool _isInLaunch1Period = _isInLaunch1();\r\n            bool _isInLaunch2Period = _isInLaunch2();\r\n           \r\n            if (isBuyFromLp) {\r\n                _liquidityFee = _isInLaunch1Period ? _launch1.liquidityFeeOnBuy : _liquidityFee;\r\n            }\r\n            else {\r\n                _liquidityFee = _isInLaunch1Period ? _liquidityFee : _isInLaunch2Period ? _launch2.liquidityFeeOnSell : _launch3.liquidityFeeOnSell;\r\n                _marketingFee = _isInLaunch1Period ? _marketingFee : _isInLaunch2Period ? _launch2.marketingFeeOnSell : _launch3.marketingFeeOnSell;\r\n                _buyBackFee = _isInLaunch1Period ? _buyBackFee : _isInLaunch2Period ? _launch2.buyBackFeeOnSell : _launch3.buyBackFeeOnSell;\r\n                _holdersFee = _isInLaunch1Period ? _holdersFee : _isInLaunch2Period ? _launch2.holdersFeeOnSell : _launch3.holdersFeeOnSell;\r\n            }\r\n        }\r\n        if (this.isInRoar()) {\r\n            if (_isInRoar1()) {\r\n                _liquidityFee = isBuyFromLp && _roar1.liquidityFeeOnBuy > 0 ? _roar1.liquidityFeeOnBuy : !isBuyFromLp && _roar1.liquidityFeeOnSell > 0 ? _roar1.liquidityFeeOnSell : _liquidityFee;\r\n                _marketingFee = isBuyFromLp && _roar1.marketingFeeOnBuy > 0 ? _roar1.marketingFeeOnBuy : !isBuyFromLp && _roar1.marketingFeeOnSell > 0 ? _roar1.marketingFeeOnSell : _marketingFee;\r\n                _buyBackFee = isBuyFromLp && _roar1.buyBackFeeOnBuy > 0 ? _roar1.buyBackFeeOnBuy : !isBuyFromLp && _roar1.buyBackFeeOnSell > 0 ? _roar1.buyBackFeeOnSell : _buyBackFee;\r\n                _salaryFee = isBuyFromLp && _roar1.salaryFeeOnBuy > 0 ? _roar1.salaryFeeOnBuy : !isBuyFromLp && _roar1.salaryFeeOnSell > 0 ? _roar1.salaryFeeOnSell : _salaryFee;\r\n                _holdersFee = isBuyFromLp && _roar1.holdersFeeOnBuy > 0 ? _roar1.holdersFeeOnBuy : !isBuyFromLp && _roar1.holdersFeeOnSell > 0 ? _roar1.holdersFeeOnSell : _holdersFee;\r\n            }\r\n            else if (_isInRoar2()) {\r\n                _liquidityFee = isBuyFromLp && _roar2.liquidityFeeOnBuy > 0 ? _roar2.liquidityFeeOnBuy : !isBuyFromLp && _roar2.liquidityFeeOnSell > 0 ? _roar2.liquidityFeeOnSell : _liquidityFee;\r\n                _marketingFee = isBuyFromLp && _roar2.marketingFeeOnBuy > 0 ? _roar2.marketingFeeOnBuy : !isBuyFromLp && _roar2.marketingFeeOnSell > 0 ? _roar2.marketingFeeOnSell : _marketingFee;\r\n                _buyBackFee = isBuyFromLp && _roar2.buyBackFeeOnBuy > 0 ? _roar2.buyBackFeeOnBuy : !isBuyFromLp && _roar2.buyBackFeeOnSell > 0 ? _roar2.buyBackFeeOnSell : _buyBackFee;\r\n                _salaryFee = isBuyFromLp && _roar2.salaryFeeOnBuy > 0 ? _roar2.salaryFeeOnBuy : !isBuyFromLp && _roar2.salaryFeeOnSell > 0 ? _roar2.salaryFeeOnSell : _salaryFee;\r\n                _holdersFee = isBuyFromLp && _roar2.holdersFeeOnBuy > 0 ? _roar2.holdersFeeOnBuy : !isBuyFromLp && _roar2.holdersFeeOnSell > 0 ? _roar2.holdersFeeOnSell : _holdersFee;\r\n            }\r\n            else {\r\n                _liquidityFee = isBuyFromLp && _roar3.liquidityFeeOnBuy > 0 ? _roar3.liquidityFeeOnBuy : !isBuyFromLp && _roar3.liquidityFeeOnSell > 0 ? _roar3.liquidityFeeOnSell : _liquidityFee;\r\n                _marketingFee = isBuyFromLp && _roar3.marketingFeeOnBuy > 0 ? _roar3.marketingFeeOnBuy : !isBuyFromLp && _roar3.marketingFeeOnSell > 0 ? _roar3.marketingFeeOnSell : _marketingFee;\r\n                _buyBackFee = isBuyFromLp && _roar3.buyBackFeeOnBuy > 0 ? _roar3.buyBackFeeOnBuy : !isBuyFromLp && _roar3.buyBackFeeOnSell > 0 ? _roar3.buyBackFeeOnSell : _buyBackFee;\r\n                _salaryFee = isBuyFromLp && _roar3.salaryFeeOnBuy > 0 ? _roar3.salaryFeeOnBuy : !isBuyFromLp && _roar3.salaryFeeOnSell > 0 ? _roar3.salaryFeeOnSell : _salaryFee;\r\n                _holdersFee = isBuyFromLp && _roar3.holdersFeeOnBuy > 0 ? _roar3.holdersFeeOnBuy : !isBuyFromLp && _roar3.holdersFeeOnSell > 0 ? _roar3.holdersFeeOnSell : _holdersFee;\r\n            }\r\n        }\r\n        \r\n        uint256 _totalFee = _liquidityFee.add(_marketingFee).add(_salaryFee).add(_buyBackFee).add(_holdersFee);\r\n\r\n        fee = amount.mul(_totalFee).div(10000);\r\n    \treturnAmount = amount.sub(fee);\r\n    \t_updateTokensToSwap(amount, _liquidityFee,_marketingFee, _buyBackFee, _salaryFee, _holdersFee);\r\n    \treturn (returnAmount, fee);\r\n    }\r\n    function _updateTokensToSwap(uint256 amount, uint256 liquidityFee,uint256 marketingFee, uint256 buyBackFee, uint256 salaryFee, uint256 holdersFee) private {\r\n        _liquidityTokensToSwap = _liquidityTokensToSwap.add(amount.mul(liquidityFee).div(10000));\r\n    \t_marketingTokensToSwap = _marketingTokensToSwap.add(amount.mul(marketingFee).div(10000));\r\n    \t_buyBackTokensToSwap = _buyBackTokensToSwap.add(amount.mul(buyBackFee).div(10000));\r\n    \t_salaryTokensToSwap = _salaryTokensToSwap.add(amount.mul(salaryFee).div(10000));\r\n    \t_holdersTokensToSwap = _holdersTokensToSwap.add(amount.mul(holdersFee).div(10000));\r\n    }\r\n    function _isInLaunch1() internal view returns(bool) {\r\n        uint256 blocksSinceLaunch = block.number.sub(_launchBlockNumber);\r\n        if(blocksSinceLaunch < _launch1.blocksInPeriod) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function _isInLaunch2() internal view returns(bool) {\r\n        uint256 currentTimestamp = !isTradingEnabled && _tradingPausedTimestamp > _launchStartTimestamp  ? _tradingPausedTimestamp : _getNow();\r\n        uint256 blocksSinceLaunch = block.number.sub(_launchBlockNumber);\r\n        uint256 timeSinceLaunch = currentTimestamp.sub(_launchStartTimestamp);\r\n        if (timeSinceLaunch < _launch1.timeInPeriod && blocksSinceLaunch > _launch1.blocksInPeriod ) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function _isInLaunch3() internal view returns(bool) {\r\n        uint256 currentTimestamp = !isTradingEnabled && _tradingPausedTimestamp > _launchStartTimestamp  ? _tradingPausedTimestamp : _getNow();\r\n        uint256 timeSinceLaunch = currentTimestamp.sub(_launchStartTimestamp);\r\n        uint256 blocksSinceLaunch = block.number.sub(_launchBlockNumber);\r\n        uint256 timeInLaunch = _launch3.timeInPeriod.add(_launch2.timeInPeriod);\r\n        if (timeSinceLaunch > _launch2.timeInPeriod && timeSinceLaunch < timeInLaunch && blocksSinceLaunch > _launch1.blocksInPeriod) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function _isInRoar1() internal view returns (bool) {\r\n        uint256 currentTimestamp = !isTradingEnabled && _tradingPausedTimestamp > _roarStartTimestamp  ? _tradingPausedTimestamp : _getNow();\r\n        uint256 timeSinceRoar = currentTimestamp.sub(_roarStartTimestamp);\r\n        if(timeSinceRoar < _roar1.timeInPeriod) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function _isInRoar2() internal view returns (bool) {\r\n        uint256 currentTimestamp = !isTradingEnabled && _tradingPausedTimestamp > _roarStartTimestamp  ? _tradingPausedTimestamp : _getNow();\r\n        uint256 timeSinceRoar = currentTimestamp.sub(_roarStartTimestamp);\r\n        if(timeSinceRoar > _roar1.timeInPeriod && timeSinceRoar < _roar1.timeInPeriod.add(_roar2.timeInPeriod)) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function _isInRoar3() internal view returns (bool) {\r\n        uint256 currentTimestamp = !isTradingEnabled && _tradingPausedTimestamp > _roarStartTimestamp  ? _tradingPausedTimestamp : _getNow();\r\n        uint256 timeSinceRoar = currentTimestamp.sub(_roarStartTimestamp);\r\n        uint256 totalTimeInRoar1 = _roar1.timeInPeriod.add(_roar2.timeInPeriod);\r\n        uint256 totalTimeInRoar2 = _roar1.timeInPeriod.add(_roar2.timeInPeriod).add(_roar3.timeInPeriod);\r\n        if(timeSinceRoar > totalTimeInRoar1 && timeSinceRoar < totalTimeInRoar2) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    function _setCustomSellTaxPeriod(CustomTaxPeriod storage map,\r\n        uint256 _liquidityFeeOnSell,\r\n        uint256 _marketingFeeOnSell,\r\n        uint256 _buyBackFeeOnSell,\r\n        uint256 _salaryFeeOnSell,\r\n        uint256 _holdersFeeOnSell\r\n        ) private {\r\n        if (map.liquidityFeeOnSell != _liquidityFeeOnSell) {\r\n            emit CustomTaxPeriodChange(_liquidityFeeOnSell, map.liquidityFeeOnSell, 'liquidityFeeOnSell', map.periodName);\r\n            map.liquidityFeeOnSell = _liquidityFeeOnSell;\r\n        }\r\n        if (map.marketingFeeOnSell != _marketingFeeOnSell) {\r\n            emit CustomTaxPeriodChange(_marketingFeeOnSell, map.marketingFeeOnSell, 'marketingFeeOnSell', map.periodName);\r\n            map.marketingFeeOnSell = _marketingFeeOnSell;\r\n        }\r\n        if (map.buyBackFeeOnSell != _buyBackFeeOnSell) {\r\n            emit CustomTaxPeriodChange(_buyBackFeeOnSell, map.buyBackFeeOnSell, 'buyBackFeeOnSell', map.periodName);\r\n            map.buyBackFeeOnSell = _buyBackFeeOnSell;\r\n        }\r\n        if (map.salaryFeeOnSell != _salaryFeeOnSell) {\r\n            emit CustomTaxPeriodChange(_salaryFeeOnSell, map.salaryFeeOnSell, 'salaryFeeOnSell', map.periodName);\r\n            map.salaryFeeOnSell = _salaryFeeOnSell;\r\n        }\r\n        if (map.holdersFeeOnSell != _holdersFeeOnSell) {\r\n            emit CustomTaxPeriodChange(_holdersFeeOnSell, map.holdersFeeOnSell, 'holdersFeeOnSell', map.periodName);\r\n            map.holdersFeeOnSell = _holdersFeeOnSell;\r\n        }\r\n    }\r\n    function _setCustomBuyTaxPeriod(CustomTaxPeriod storage map,\r\n        uint256 _liquidityFeeOnBuy,\r\n        uint256 _marketingFeeOnBuy,\r\n        uint256 _buyBackFeeOnBuy,\r\n        uint256 _salaryFeeOnBuy,\r\n        uint256 _holdersFeeOnBuy\r\n        ) private {\r\n        if (map.liquidityFeeOnBuy != _liquidityFeeOnBuy) {\r\n            emit CustomTaxPeriodChange(_liquidityFeeOnBuy, map.liquidityFeeOnBuy, 'liquidityFeeOnBuy', map.periodName);\r\n            map.liquidityFeeOnBuy = _liquidityFeeOnBuy;\r\n        }\r\n        if (map.marketingFeeOnBuy != _marketingFeeOnBuy) {\r\n            emit CustomTaxPeriodChange(_marketingFeeOnBuy, map.marketingFeeOnBuy, 'marketingFeeOnBuy', map.periodName);\r\n            map.marketingFeeOnBuy = _marketingFeeOnBuy;\r\n        }\r\n        if (map.buyBackFeeOnBuy != _buyBackFeeOnBuy) {\r\n            emit CustomTaxPeriodChange(_buyBackFeeOnBuy, map.buyBackFeeOnBuy, 'buyBackFeeOnBuy', map.periodName);\r\n            map.buyBackFeeOnBuy = _buyBackFeeOnBuy;\r\n        }\r\n        if (map.salaryFeeOnBuy != _salaryFeeOnBuy) {\r\n            emit CustomTaxPeriodChange(_salaryFeeOnBuy, map.salaryFeeOnBuy, 'salaryFeeOnBuy', map.periodName);\r\n            map.salaryFeeOnBuy = _salaryFeeOnBuy;\r\n        }\r\n        if (map.holdersFeeOnBuy != _holdersFeeOnBuy) {\r\n            emit CustomTaxPeriodChange(_holdersFeeOnBuy, map.holdersFeeOnBuy, 'holdersFeeOnBuy', map.periodName);\r\n            map.holdersFeeOnBuy = _holdersFeeOnBuy;\r\n        }\r\n    }\r\n    function _swapAndLiquify() private {\r\n        uint256 contractBalance = balanceOf(address(this));\r\n        uint256 totalTokensToSwap = _liquidityTokensToSwap.add(_marketingTokensToSwap).add(_salaryTokensToSwap).add(_buyBackTokensToSwap).add(_holdersTokensToSwap);\r\n        \r\n        // Halve the amount of liquidity tokens\r\n        uint256 tokensInKodiForLiquidity = _liquidityTokensToSwap.div(2);\r\n        uint256 amountToSwapForBNB = contractBalance.sub(tokensInKodiForLiquidity);\r\n        \r\n        // initial BNB balance\r\n        uint256 initialBNBBalance = address(this).balance;\r\n        // Swap the Kodi for BNB\r\n        _swapTokensForBNB(amountToSwapForBNB); \r\n        // Get the balance, minus what we started with\r\n        uint256 bnbBalance = address(this).balance.sub(initialBNBBalance);\r\n        // Divvy up the BNB based on accrued tokens as % of total accrued\r\n        uint256 bnbForMarketing = bnbBalance.mul(_marketingTokensToSwap).div(totalTokensToSwap);\r\n        uint256 bnbForBuyBack = bnbBalance.mul(_buyBackTokensToSwap).div(totalTokensToSwap);\r\n        uint256 bnbForSalary = bnbBalance.mul(_salaryTokensToSwap).div(totalTokensToSwap);\r\n        uint256 bnbForHolders = bnbBalance.mul(_holdersTokensToSwap).div(totalTokensToSwap);\r\n        uint256 bnbForLiquidity = bnbBalance.sub(bnbForMarketing).sub(bnbForBuyBack).sub(bnbForSalary).sub(bnbForHolders);\r\n        \r\n        _liquidityTokensToSwap = 0;\r\n        _marketingTokensToSwap = 0;\r\n        _salaryTokensToSwap = 0;\r\n        _buyBackTokensToSwap = 0;\r\n        _holdersTokensToSwap = 0;\r\n        \r\n        payable(buyBackWallet).transfer(bnbForBuyBack);\r\n        payable(salaryWallet).transfer(bnbForSalary);\r\n        payable(marketingWallet).transfer(bnbForMarketing);\r\n        \r\n        _addLiquidity(tokensInKodiForLiquidity, bnbForLiquidity);\r\n        emit SwapAndLiquify(amountToSwapForBNB, bnbForLiquidity, tokensInKodiForLiquidity);\r\n        \r\n        (bool success,) = address(dividendTracker).call{value: bnbForHolders}(\"\");\r\n        if(success) {\r\n   \t \t\temit DividendsSent(bnbForHolders);\r\n        }\r\n    }\r\n    function _swapTokensForBNB(uint256 tokenAmount) private {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = uniswapV2Router.WETH();\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0, // accept any amount of ETH\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n    function _addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        uniswapV2Router.addLiquidityETH{value: ethAmount}(\r\n            address(this),\r\n            tokenAmount,\r\n            0, // slippage is unavoidable\r\n            0, // slippage is unavoidable\r\n            liquidityWallet,\r\n            block.timestamp\r\n        );\r\n    }\r\n}\r\n\r\n\r\ncontract KODIDividendTracker is DividendPayingToken, Ownable {\r\n    using SafeMath for uint256;\r\n    using SafeMathInt for int256;\r\n    using IterableMapping for IterableMapping.Map;\r\n\r\n    IterableMapping.Map private tokenHoldersMap;\r\n    \r\n    uint256 public lastProcessedIndex;\r\n    mapping (address => bool) public excludedFromDividends;\r\n    mapping (address => uint256) public lastClaimTimes;\r\n    uint256 public claimWait;\r\n    uint256 public minimumTokenBalanceForDividends;\r\n\r\n    event ExcludeFromDividends(address indexed account);\r\n    event ClaimWaitUpdated(uint256 indexed newValue, uint256 indexed oldValue);\r\n    event Claim(address indexed account, uint256 amount, bool indexed automatic);\r\n\r\n    constructor() public DividendPayingToken(\"KODI_Dividend_Tracker\", \"KODI_Dividend_Tracker\") {\r\n    \tclaimWait = 3600;\r\n        minimumTokenBalanceForDividends = 5000000 * (10**18); \r\n    }\r\n    function _transfer(address, address, uint256) internal override {\r\n        require(false, \"KODI_Dividend_Tracker: No transfers allowed\");\r\n    }\r\n    function withdrawDividend() public override {\r\n        require(false, \"KODI_Dividend_Tracker: withdrawDividend disabled. Use the 'claim' function on the main KODI contract.\");\r\n    }\r\n    function excludeFromDividends(address account) external onlyOwner {\r\n    \trequire(!excludedFromDividends[account]);\r\n    \texcludedFromDividends[account] = true;\r\n    \t_setBalance(account, 0);\r\n    \ttokenHoldersMap.remove(account);\r\n    \temit ExcludeFromDividends(account);\r\n    }\r\n    function setTokenBalanceForDividends(uint256 newValue) external onlyOwner {\r\n        require(minimumTokenBalanceForDividends != newValue, \"KODI_Dividend_Tracker: minimumTokenBalanceForDividends already the value of 'newValue'.\");\r\n        minimumTokenBalanceForDividends = newValue;\r\n    } \r\n    function updateClaimWait(uint256 newClaimWait) external onlyOwner {\r\n        require(newClaimWait >= 3600 && newClaimWait <= 86400, \"KODI_Dividend_Tracker: claimWait must be updated to between 1 and 24 hours\");\r\n        require(newClaimWait != claimWait, \"KODI_Dividend_Tracker: Cannot update claimWait to same value\");\r\n        emit ClaimWaitUpdated(newClaimWait, claimWait);\r\n        claimWait = newClaimWait;\r\n    }\r\n    function getLastProcessedIndex() external view returns(uint256) {\r\n    \treturn lastProcessedIndex;\r\n    }\r\n    function getNumberOfTokenHolders() external view returns(uint256) {\r\n        return tokenHoldersMap.keys.length;\r\n    }\r\n    function getAccount(address _account)\r\n        public view returns (\r\n            address account,\r\n            int256 index,\r\n            int256 iterationsUntilProcessed,\r\n            uint256 withdrawableDividends,\r\n            uint256 totalDividends,\r\n            uint256 lastClaimTime,\r\n            uint256 nextClaimTime,\r\n            uint256 secondsUntilAutoClaimAvailable) {\r\n        account = _account;\r\n\r\n        index = tokenHoldersMap.getIndexOfKey(account);\r\n        iterationsUntilProcessed = -1;\r\n        if(index >= 0) {\r\n            if(uint256(index) > lastProcessedIndex) {\r\n                iterationsUntilProcessed = index.sub(int256(lastProcessedIndex));\r\n            }\r\n            else {\r\n                uint256 processesUntilEndOfArray = tokenHoldersMap.keys.length > lastProcessedIndex ? tokenHoldersMap.keys.length.sub(lastProcessedIndex) : 0;\r\n                iterationsUntilProcessed = index.add(int256(processesUntilEndOfArray));\r\n            }\r\n        }\r\n        withdrawableDividends = withdrawableDividendOf(account);\r\n        totalDividends = accumulativeDividendOf(account);\r\n        lastClaimTime = lastClaimTimes[account];\r\n        nextClaimTime = lastClaimTime > 0 ? lastClaimTime.add(claimWait) : 0;\r\n        secondsUntilAutoClaimAvailable = nextClaimTime > block.timestamp ? nextClaimTime.sub(block.timestamp) : 0;\r\n    }\r\n    function getAccountAtIndex(uint256 index)\r\n        public view returns (\r\n            address,\r\n            int256,\r\n            int256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256) {\r\n    \tif(index >= tokenHoldersMap.size()) {\r\n            return (0x0000000000000000000000000000000000000000, -1, -1, 0, 0, 0, 0, 0);\r\n        }\r\n        address account = tokenHoldersMap.getKeyAtIndex(index);\r\n        return getAccount(account);\r\n    }\r\n    function canAutoClaim(uint256 lastClaimTime) private view returns (bool) {\r\n    \tif(lastClaimTime > block.timestamp)  {\r\n    \t\treturn false;\r\n    \t}\r\n    \treturn block.timestamp.sub(lastClaimTime) >= claimWait;\r\n    }\r\n    function setBalance(address payable account, uint256 newBalance) external onlyOwner {\r\n    \tif(excludedFromDividends[account]) {\r\n    \t\treturn;\r\n    \t}\r\n    \tif(newBalance >= minimumTokenBalanceForDividends) {\r\n            _setBalance(account, newBalance);\r\n    \t\ttokenHoldersMap.set(account, newBalance);\r\n    \t}\r\n    \telse {\r\n            _setBalance(account, 0);\r\n    \t\ttokenHoldersMap.remove(account);\r\n    \t}\r\n    \tprocessAccount(account, true);\r\n    }\r\n    function process(uint256 gas) public returns (uint256, uint256, uint256) {\r\n    \tuint256 numberOfTokenHolders = tokenHoldersMap.keys.length;\r\n    \tif(numberOfTokenHolders == 0) {\r\n    \t\treturn (0, 0, lastProcessedIndex);\r\n    \t}\r\n\r\n    \tuint256 _lastProcessedIndex = lastProcessedIndex;\r\n    \tuint256 gasUsed = 0;\r\n    \tuint256 gasLeft = gasleft();\r\n    \tuint256 iterations = 0;\r\n    \tuint256 claims = 0;\r\n\r\n    \twhile(gasUsed < gas && iterations < numberOfTokenHolders) {\r\n    \t\t_lastProcessedIndex++;\r\n    \t\tif(_lastProcessedIndex >= tokenHoldersMap.keys.length) {\r\n    \t\t\t_lastProcessedIndex = 0;\r\n    \t\t}\r\n    \t\taddress account = tokenHoldersMap.keys[_lastProcessedIndex];\r\n    \t\tif(canAutoClaim(lastClaimTimes[account])) {\r\n    \t\t\tif(processAccount(payable(account), true)) {\r\n    \t\t\t\tclaims++;\r\n    \t\t\t}\r\n    \t\t}\r\n\r\n    \t\titerations++;\r\n    \t\tuint256 newGasLeft = gasleft();\r\n    \t\tif(gasLeft > newGasLeft) {\r\n    \t\t\tgasUsed = gasUsed.add(gasLeft.sub(newGasLeft));\r\n    \t\t}\r\n    \t\tgasLeft = newGasLeft;\r\n    \t}\r\n    \tlastProcessedIndex = _lastProcessedIndex;\r\n    \treturn (iterations, claims, lastProcessedIndex);\r\n    }\r\n\r\n    function processAccount(address payable account, bool automatic) public onlyOwner returns (bool) {\r\n        uint256 amount = _withdrawDividendOfUser(account);\r\n    \tif(amount > 0) {\r\n    \t\tlastClaimTimes[account] = block.timestamp;\r\n            emit Claim(account, amount, automatic);\r\n    \t\treturn true;\r\n    \t}\r\n    \treturn false;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"AutomatedMarketMakerPairChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"BlacklistChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newBuyBackWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldBuyBackWallet\",\"type\":\"address\"}],\"name\":\"BuyBackWalletChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"taxType\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes23\",\"name\":\"period\",\"type\":\"bytes23\"}],\"name\":\"CustomTaxPeriodChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"}],\"name\":\"DividendTrackerChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"}],\"name\":\"DividendsSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeFromDividendsChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeFromFeesChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeFromMaxTransferChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeFromMaxWalletChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"taxType\",\"type\":\"string\"}],\"name\":\"FeeOnBuyChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"taxType\",\"type\":\"string\"}],\"name\":\"FeeOnSellChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"}],\"name\":\"GasForProcessingChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"newValue\",\"type\":\"bool\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"oldValue\",\"type\":\"bool\"}],\"name\":\"KodiRoarChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newLiquidityWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldLiquidityWallet\",\"type\":\"address\"}],\"name\":\"LiquidityWalletChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newMarketingWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldMarketingWallet\",\"type\":\"address\"}],\"name\":\"MarketingWalletChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"}],\"name\":\"MaxTransactionAmountChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"}],\"name\":\"MaxWalletAmountChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"}],\"name\":\"MinTokenAmountBeforeSwapChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"}],\"name\":\"MinTokenAmountForDividendsChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"iterations\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claims\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastProcessedIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"automatic\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"processor\",\"type\":\"address\"}],\"name\":\"ProcessedDividendTracker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newSalaryWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldSalaryWallet\",\"type\":\"address\"}],\"name\":\"SalaryWalletChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiqudity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"}],\"name\":\"UniswapV2RouterChange\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"activateTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"automatedMarketMakerPairs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"blacklistAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyBackFeeOnBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyBackFeeOnSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyBackWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelKodiRoar\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelLaunch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deactivateTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"dividendTokenBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendTracker\",\"outputs\":[{\"internalType\":\"contract KODIDividendTracker\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromDividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeFromMaxTransactionLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeFromMaxWalletLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasForProcessing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAccountDividendsInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getClaimWait\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastProcessedIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumberOfDividendTokenHolders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRoar1BuyFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRoar1SellFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRoar2BuyFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRoar2SellFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRoar3BuyFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRoar3SellFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalDividendsDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"holdersFeeOnBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"holdersFeeOnSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isInLaunch\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isInRoar\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isTradingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityFeeOnBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityFeeOnSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingFeeOnBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingFeeOnSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWalletAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumTokensBeforeSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"}],\"name\":\"processDividendTracker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"salaryFeeOnBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"salaryFeeOnSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"salaryWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newvalue\",\"type\":\"uint256\"}],\"name\":\"setBuyBackFeeOnBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newvalue\",\"type\":\"uint256\"}],\"name\":\"setBuyBackFeeOnSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setBuyBackWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"setGasForProcessing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newvalue\",\"type\":\"uint256\"}],\"name\":\"setHolderFeeOnBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newvalue\",\"type\":\"uint256\"}],\"name\":\"setHolderFeeOnSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setKodiRoar\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newvalue\",\"type\":\"uint256\"}],\"name\":\"setLiquidityFeeOnBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newvalue\",\"type\":\"uint256\"}],\"name\":\"setLiquidityFeeOnSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setLiquidityWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newvalue\",\"type\":\"uint256\"}],\"name\":\"setMarketingFeeOnBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newvalue\",\"type\":\"uint256\"}],\"name\":\"setMarketingFeeOnSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setMarketingWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"setMaxTxAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"setMaxWalletAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"setMinimumTokenBalanceForDividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"setMinimumTokensBeforeSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidityFeeOnBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketingFeeOnBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_buyBackFeeOnBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_salaryFeeOnBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_holdersFeeOnBuy\",\"type\":\"uint256\"}],\"name\":\"setRoar1BuyFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidityFeeOnSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketingFeeOnSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_buyBackFeeOnSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_salaryFeeOnSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_holdersFeeOnSell\",\"type\":\"uint256\"}],\"name\":\"setRoar1SellFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidityFeeOnBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketingFeeOnBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_buyBackFeeOnBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_salaryFeeOnBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_holdersFeeOnBuy\",\"type\":\"uint256\"}],\"name\":\"setRoar2BuyFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidityFeeOnSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketingFeeOnSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_buyBackFeeOnSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_salaryFeeOnSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_holdersFeeOnSell\",\"type\":\"uint256\"}],\"name\":\"setRoar2SellFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidityFeeOnBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketingFeeOnBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_buyBackFeeOnBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_salaryFeeOnBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_holdersFeeOnBuy\",\"type\":\"uint256\"}],\"name\":\"setRoar3BuyFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidityFeeOnSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketingFeeOnSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_buyBackFeeOnSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_salaryFeeOnSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_holdersFeeOnSell\",\"type\":\"uint256\"}],\"name\":\"setRoar3SellFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newvalue\",\"type\":\"uint256\"}],\"name\":\"setSalaryFeeOnBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newvalue\",\"type\":\"uint256\"}],\"name\":\"setSalaryFeeOnSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setSalaryWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setUniswapV2Router\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"unBlacklistAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"claimWait\",\"type\":\"uint256\"}],\"name\":\"updateClaimWait\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"updateDividendTracker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"withdrawableDividendOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Kodi", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "IterableMapping:e6ef9fe909e0efa28e9ee26230f0f81dccee9543", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ff71f3c3aed19392abed4e40a505e3126c7ab553fad83a5531dca079f1a04454"}