{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/C/Users/Stew/Documents/The Coin Sack Token/contracts/CoinSackToken.sol\": {\r\n      \"content\": \"/*\\r\\n    ___           _              __             ___               \\r\\n     | |_   _    /   _  o ._    (_   _.  _ |     |  _  |   _  ._  \\r\\n     | | | (/_   \\\\_ (_) | | |   __) (_| (_ |<    | (_) |< (/_ | |  \\r\\n\\r\\n*/\\r\\n\\r\\n\\r\\n\\r\\n// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\n\\r\\n\\r\\nimport './contexts/Manageable.sol';\\r\\n\\r\\nimport './interfaces/IBEP20.sol';\\r\\nimport './interfaces/IPancakeFactory.sol';\\r\\nimport './interfaces/IPancakePair.sol';\\r\\nimport './interfaces/IPancakeRouter02.sol';\\r\\n\\r\\nimport './libraries/SackMath.sol';\\r\\n\\r\\n\\r\\n\\r\\ncontract CoinSackToken is IBEP20, Manageable {\\r\\n    \\r\\n    using SackMath for uint256;\\r\\n\\r\\n\\r\\n    uint256 private constant MAX = ~uint256(0);\\r\\n\\r\\n\\r\\n    string private _name = \\\"Coin Sack\\\";\\r\\n    string private _symbol = \\\"CS\\\";\\r\\n    uint8 private _decimals = 3;\\r\\n    uint256 private _tTotal = 100000000000 * 10**_decimals;\\r\\n\\r\\n\\r\\n    mapping (address => uint256) private _tOwned;\\r\\n    mapping (address => mapping (address => uint256)) private _tAllowances;\\r\\n\\r\\n\\r\\n    bool public _areLimitsEnabled = false;\\r\\n    mapping (address => bool) private _isExcludedFromLimits;\\r\\n    uint256 public _maxTransferAmount = _tTotal.mul(10).div(100);\\r\\n\\r\\n\\r\\n    mapping (address => bool) private _isExcludedFromReflections;\\r\\n    mapping (address => uint256) private _rOwned;\\r\\n    address[] private _excludedFromReflections;\\r\\n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\\r\\n\\r\\n\\r\\n    bool public _areFeesEnabled = false;\\r\\n    mapping (address => bool) private _isExcludedFromFees;\\r\\n    uint256 public _buyFeeManagementPercentage = 3;\\r\\n    uint256 public _buyFeeReservePercentage = 8;\\r\\n    uint256 public _buyFeeReflectionPercentage = 4;\\r\\n\\r\\n    uint256 public _sellFeeManagementPercentage = 5;\\r\\n    uint256 public _sellFeeReservePercentage = 10;\\r\\n    uint256 public _sellFeeReflectionPercentage = 5;\\r\\n\\r\\n    uint256 public _buyFeeTotalPercentage = _buyFeeManagementPercentage + _buyFeeReservePercentage + _buyFeeReflectionPercentage;\\r\\n    uint256 public _sellFeeTotalPercentage = _sellFeeManagementPercentage + _sellFeeReservePercentage + _sellFeeReflectionPercentage;\\r\\n\\r\\n\\r\\n    IPancakeRouter02 public _pancakeRouter;\\r\\n    IPancakePair public _pancakePair;\\r\\n\\r\\n\\r\\n    address[] public _managementFeesRecievers;\\r\\n    mapping (address => bool) private _isManagementFeesReciever;\\r\\n    uint256 public _maxNumberManagementFeesRecievers = 5;\\r\\n\\r\\n\\r\\n    bool public _isAutoFeeLiquifyEnabled = false;\\r\\n    uint256 public _minPendingFeesForAutoLiquify = 55000000 * 10**_decimals;\\r\\n    uint256 public _autoLiquifyFactor = 10;\\r\\n    bool private _isInternallySwapping = false;\\r\\n    uint256 private _amountManagementFeesPendingLiquidation = 0;\\r\\n    uint256 private _amountReserveFeesPendingLiquidation = 0;\\r\\n    uint256 public _amountTotalFeesPendingLiquidation =  _amountManagementFeesPendingLiquidation + _amountReserveFeesPendingLiquidation;\\r\\n\\r\\n\\r\\n    address public _deadAddress = 0x000000000000000000000000000000000000dEaD;\\r\\n    \\r\\n    bool public _isAutoBuybackEnabled = false;\\r\\n    uint256 public _minReserveETHForAutoBuyback = 1 * 10**18 / 2;\\r\\n    uint256 public _autoBuybackFactor = 2;\\r\\n\\r\\n    bool public _isAutoReinjectEnabled = false;\\r\\n    uint256 public _minReserveETHForAutoReinject = 125 * 10**18;\\r\\n    uint256 public _autoReinjectFactor = 1;\\r\\n\\r\\n\\r\\n\\r\\n    constructor(address pancakeRouter) {\\r\\n        _pancakeRouter = IPancakeRouter02(pancakeRouter);\\r\\n        _pancakePair = IPancakePair(IPancakeFactory(_pancakeRouter.factory()).createPair(_contextAddress(), _pancakeRouter.WETH()));\\r\\n\\r\\n        _isExcludedFromReflections[address(_pancakePair)] = true;\\r\\n        _excludedFromReflections.push(address(_pancakePair));\\r\\n\\r\\n        _isExcludedFromFees[_contextAddress()] = true;\\r\\n        _isExcludedFromLimits[_contextAddress()] = true;\\r\\n        _isExcludedFromReflections[_contextAddress()] = true;\\r\\n        _excludedFromReflections.push(_contextAddress());\\r\\n\\r\\n        _isExcludedFromFees[_deadAddress] = true;\\r\\n        _isExcludedFromLimits[_deadAddress] = true;\\r\\n        _isExcludedFromReflections[_deadAddress] = true;\\r\\n        _excludedFromReflections.push(_deadAddress);\\r\\n\\r\\n        _isExcludedFromFees[_msgSender()] = true;\\r\\n        _isExcludedFromLimits[_msgSender()] = true;\\r\\n        _isExcludedFromReflections[_msgSender()] = true;\\r\\n        _excludedFromReflections.push(_msgSender());\\r\\n\\r\\n        _rOwned[_msgSender()] = _rTotal;\\r\\n        _tOwned[_msgSender()] = _tTotal;\\r\\n\\r\\n        emit MintTokens(_tTotal);\\r\\n        emit Transfer(address(0), _msgSender(), _tTotal);\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    function name() public override view returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    function symbol() public override view returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    function decimals() public override view returns (uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n\\r\\n    function totalSupply() public override view returns (uint256) {\\r\\n        return _tTotal;\\r\\n    }\\r\\n\\r\\n    function getOwner() public view returns (address) {\\r\\n        return executiveManager();\\r\\n    }\\r\\n\\r\\n    function balanceOf(address account) public override view returns (uint256) {\\r\\n        return _isExcludedFromReflections[account] ? _tOwned[account] : _rOwned[account].div(_getCurrentReflectionRate());\\r\\n    }\\r\\n\\r\\n    function transfer(address to, uint256 tAmount) public override returns (bool) {\\r\\n        _transfer(_msgSender(), to, tAmount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function allowance(address owner, address spender) public override view returns (uint256) {\\r\\n        return _tAllowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    function approve(address spender, uint256 tAmount) public override returns (bool) {\\r\\n        _approve(_msgSender(), spender, tAmount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(address owner, address to, uint256 amount) public override returns (bool) {\\r\\n        _transfer(owner, to, amount);\\r\\n        _approve(owner, _msgSender(), _tAllowances[owner][_msgSender()].sub(amount, \\\"transfer amount exceeds spender's allowance\\\"));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function increaseAllowance(address spender, uint256 amount) public returns (bool) {\\r\\n        _approve(_msgSender(), spender, _tAllowances[_msgSender()][spender].add(amount));\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function decreaseAllowance(address spender, uint256 amount) public returns (bool) {\\r\\n        if(amount <= _tAllowances[_msgSender()][spender]){\\r\\n            _approve(_msgSender(), spender, _tAllowances[_msgSender()][spender].sub(amount));\\r\\n        } else {\\r\\n            _approve(_msgSender(), spender, 0);\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n\\r\\n    function isExcludedFromReflections(address account) public view returns (bool) {\\r\\n        return _isExcludedFromReflections[account];\\r\\n    }\\r\\n\\r\\n    function isExcludedFromFees(address account) public view returns (bool) {\\r\\n        return _isExcludedFromFees[account];\\r\\n    }\\r\\n\\r\\n    function isExcludedFromLimits(address account) public view returns (bool) {\\r\\n        return _isExcludedFromLimits[account];\\r\\n    }\\r\\n\\r\\n\\r\\n    function _approve(address owner, address spender, uint256 tAmount) private {\\r\\n        require(owner != address(0), \\\"cannot approve allwoance from the zero address\\\");\\r\\n        require(spender != address(0), \\\"cannot approve allwoance to the zero address\\\");\\r\\n\\r\\n        _tAllowances[owner][spender] = tAmount;\\r\\n        emit Approval(owner, spender, tAmount);\\r\\n    }\\r\\n\\r\\n    function _transfer(address from, address to, uint256 tAmount) private {\\r\\n        require(from != address(0) && to != address(0), \\\"cannot transfer tokens from or to the zero address\\\");\\r\\n        require(tAmount <= _maxTransferAmount || !_areLimitsEnabled || _isExcludedFromLimits[from] || _isExcludedFromLimits[to], \\\"transfer amount exceeds transaction limit\\\");\\r\\n\\r\\n        if(tAmount == 0) {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        uint256 fromAccountTBalance = balanceOf(from);\\r\\n        require(fromAccountTBalance >= tAmount, \\\"insufficent from account token balance\\\");\\r\\n\\r\\n        uint256 currentReflectionRate = _getCurrentReflectionRate();\\r\\n\\r\\n        uint256 tManagementFeeAmount = 0;\\r\\n        uint256 tReserveFeeAmount = 0;\\r\\n        uint256 tReflectionsFeeAmount = 0;\\r\\n        if(_areFeesEnabled && !(_isExcludedFromFees[from] || _isExcludedFromFees[to])) {\\r\\n            if(from == address(_pancakePair)){\\r\\n                tManagementFeeAmount = tAmount.mul(_buyFeeManagementPercentage).div(100);\\r\\n                tReserveFeeAmount = tAmount.mul(_buyFeeReservePercentage).div(100);\\r\\n                tReflectionsFeeAmount = tAmount.mul(_buyFeeReflectionPercentage).div(100);\\r\\n            } else if (to == address(_pancakePair)){\\r\\n                tManagementFeeAmount = tAmount.mul(_sellFeeManagementPercentage).div(100);\\r\\n                tReserveFeeAmount = tAmount.mul(_sellFeeReservePercentage).div(100);\\r\\n                tReflectionsFeeAmount = tAmount.mul(_sellFeeReflectionPercentage).div(100);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        uint256 tTransferAmount = tAmount.sub(tManagementFeeAmount).sub(tReserveFeeAmount).sub(tReflectionsFeeAmount);\\r\\n        uint256 rAmount = tAmount.mul(currentReflectionRate);\\r\\n        uint256 rTransferAmount = tTransferAmount.mul(currentReflectionRate);\\r\\n\\r\\n        if(to == address(_pancakePair) && !_isInternallySwapping){\\r\\n            if(_isAutoFeeLiquifyEnabled && _amountTotalFeesPendingLiquidation >= _minPendingFeesForAutoLiquify) {\\r\\n                _liquidateFees(_autoLiquifyFactor);\\r\\n            }\\r\\n\\r\\n            if(_isAutoBuybackEnabled && _contextAddress().balance >= _minReserveETHForAutoBuyback){\\r\\n                _buybackTokens(_autoBuybackFactor);\\r\\n            }\\r\\n\\r\\n            if(_isAutoReinjectEnabled && _contextAddress().balance >= _minReserveETHForAutoReinject && balanceOf(_deadAddress) != 0){\\r\\n                _reinjectTokens(_autoReinjectFactor);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if(_areFeesEnabled && !(_isExcludedFromFees[to] || _isExcludedFromFees[from])){\\r\\n            _tOwned[_contextAddress()] = _tOwned[_contextAddress()].add(tManagementFeeAmount + tReserveFeeAmount);\\r\\n            _rOwned[_contextAddress()] = _rOwned[_contextAddress()].add((tManagementFeeAmount + tReserveFeeAmount).mul(currentReflectionRate));\\r\\n\\r\\n            emit Transfer(from, _contextAddress(), tManagementFeeAmount + tReserveFeeAmount);\\r\\n\\r\\n            _amountManagementFeesPendingLiquidation = _amountManagementFeesPendingLiquidation.add(tManagementFeeAmount);\\r\\n            _amountReserveFeesPendingLiquidation = _amountReserveFeesPendingLiquidation.add(tReserveFeeAmount);\\r\\n            _amountTotalFeesPendingLiquidation = _amountManagementFeesPendingLiquidation + _amountReserveFeesPendingLiquidation;\\r\\n\\r\\n            _rTotal = _rTotal.sub(tReflectionsFeeAmount.mul(currentReflectionRate));\\r\\n            emit ReflectTokens(tReflectionsFeeAmount);\\r\\n        }\\r\\n   \\r\\n        if(_isExcludedFromReflections[from] && !_isExcludedFromReflections[to]){\\r\\n            _tOwned[from] = _tOwned[from].sub(tAmount);\\r\\n            _rOwned[from] = _rOwned[from].sub(rAmount);\\r\\n            _rOwned[to] = _rOwned[to].add(rTransferAmount);\\r\\n        } else if(!_isExcludedFromReflections[from] && _isExcludedFromReflections[to]) {\\r\\n            _rOwned[from] = _rOwned[from].sub(rAmount);\\r\\n            _tOwned[to] = _tOwned[to].add(tTransferAmount);\\r\\n            _rOwned[to] = _rOwned[to].add(rTransferAmount);\\r\\n        } else if(_isExcludedFromReflections[from] && _isExcludedFromReflections[to]) {\\r\\n            _tOwned[from] = _tOwned[from].sub(tAmount);\\r\\n            _rOwned[from] = _rOwned[from].sub(rAmount);\\r\\n            _tOwned[to] = _tOwned[to].add(tTransferAmount);\\r\\n            _rOwned[to] = _rOwned[to].add(rTransferAmount);\\r\\n        } else {\\r\\n            _rOwned[from] = _rOwned[from].sub(rAmount);\\r\\n            _rOwned[to] = _rOwned[to].add(rTransferAmount);\\r\\n        }\\r\\n\\r\\n        emit Transfer(from, to, tTransferAmount);\\r\\n    }\\r\\n\\r\\n    function _getCurrentReflectionRate() private view returns (uint256) {\\r\\n        (uint256 rSupplyCurrent, uint256 tSupplyCurrent) = _getCurrentSupplies();\\r\\n        return rSupplyCurrent.div(tSupplyCurrent);\\r\\n    }\\r\\n\\r\\n    function _getCurrentSupplies() private view returns (uint256, uint256) {\\r\\n        uint256 rSupplyCurrent = _rTotal;\\r\\n        uint256 tSupplyCurrent = _tTotal;\\r\\n        for(uint256 i = 0; i < _excludedFromReflections.length; i++) {\\r\\n            if(_rOwned[_excludedFromReflections[i]] > rSupplyCurrent || _tOwned[_excludedFromReflections[i]] > tSupplyCurrent) {\\r\\n                return (_rTotal, _tTotal);\\r\\n            }\\r\\n            rSupplyCurrent = rSupplyCurrent.sub(_rOwned[_excludedFromReflections[i]]);\\r\\n            tSupplyCurrent = tSupplyCurrent.sub(_tOwned[_excludedFromReflections[i]]);\\r\\n        }\\r\\n        if(rSupplyCurrent < _rTotal.div(_tTotal)) {\\r\\n            return (_rTotal, _tTotal);\\r\\n        }\\r\\n        return (rSupplyCurrent, tSupplyCurrent);\\r\\n    }\\r\\n\\r\\n    function _liquidateFees(uint256 liquifyFactor) private internalSwapLock() {\\r\\n        require(liquifyFactor <= 100, \\\"liquify factor cannot exceed 100\\\");\\r\\n\\r\\n        uint256 tManagementFeesAmountToLiquidate = _amountManagementFeesPendingLiquidation.mul(liquifyFactor).div(100);\\r\\n        uint256 tReserveFeesAmountToLiquidate = _amountReserveFeesPendingLiquidation.mul(liquifyFactor).div(100);\\r\\n        \\r\\n        uint256 tTotalFeesAmountToLiquidate = tManagementFeesAmountToLiquidate + tReserveFeesAmountToLiquidate;\\r\\n\\r\\n        uint256 preSwapContractBalance = _contextAddress().balance;\\r\\n\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = _contextAddress();\\r\\n        path[1] = _pancakeRouter.WETH();\\r\\n\\r\\n        _approve(_contextAddress(), address(_pancakeRouter), tTotalFeesAmountToLiquidate);\\r\\n        _pancakeRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(tTotalFeesAmountToLiquidate, 0, path, _contextAddress(), _msgTimestamp());\\r\\n\\r\\n        emit SwapTokensForETH(tTotalFeesAmountToLiquidate, path);\\r\\n        \\r\\n        _amountManagementFeesPendingLiquidation = _amountManagementFeesPendingLiquidation.sub(tManagementFeesAmountToLiquidate);\\r\\n        _amountReserveFeesPendingLiquidation = _amountReserveFeesPendingLiquidation.sub(tReserveFeesAmountToLiquidate);\\r\\n        _amountTotalFeesPendingLiquidation = _amountManagementFeesPendingLiquidation + _amountReserveFeesPendingLiquidation;\\r\\n\\r\\n        uint256 individualManagementFeesRecieverDistribution = _contextAddress().balance.sub(preSwapContractBalance).mul(tManagementFeesAmountToLiquidate).div(tTotalFeesAmountToLiquidate).div(_managementFeesRecievers.length);\\r\\n        for(uint256 i = 0; i < _managementFeesRecievers.length; i++){\\r\\n            payable(_managementFeesRecievers[i]).transfer(individualManagementFeesRecieverDistribution);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _buybackTokens(uint256 buybackFactor) private internalSwapLock() {\\r\\n        require(buybackFactor <= 100, \\\"buyback factor cannot exceed 100\\\");\\r\\n\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = _pancakeRouter.WETH();\\r\\n        path[1] = _contextAddress();\\r\\n\\r\\n        uint256 reserveETHToUse = _contextAddress().balance.mul(buybackFactor).div(100);\\r\\n\\r\\n        _pancakeRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value: reserveETHToUse}(0, path, _deadAddress, _msgTimestamp().add(300));\\r\\n\\r\\n        emit SwapETHForTokens(reserveETHToUse, path);\\r\\n    }\\r\\n\\r\\n    function _reinjectTokens(uint256 reinjectFactor) private internalSwapLock() {\\r\\n        require(reinjectFactor <= 100, \\\"reinject factor cannot exceed 100\\\");\\r\\n\\r\\n        uint256 deadTokensAvalible = balanceOf(_deadAddress);\\r\\n        _transfer(_deadAddress, _contextAddress(), deadTokensAvalible);\\r\\n        _approve(_contextAddress(), address(_pancakeRouter), deadTokensAvalible);\\r\\n\\r\\n        _pancakeRouter.addLiquidityETH{value: _contextAddress().balance.mul(reinjectFactor).div(100)}(_contextAddress(), deadTokensAvalible, 0, 0, _contextAddress(), _msgTimestamp());\\r\\n\\r\\n        _transfer(_contextAddress(), _deadAddress, balanceOf(_contextAddress()).sub(_amountTotalFeesPendingLiquidation));\\r\\n    }\\r\\n\\r\\n\\r\\n    function excludeFromReflections(address account) public onlyManagement() returns (bool) {\\r\\n        require(!_isExcludedFromReflections[account], \\\"account is already excluded from reflections\\\");\\r\\n        require(account != _deadAddress, \\\"cannot include dead address in reflections\\\");\\r\\n        if(_rOwned[account] > 0) {\\r\\n            _tOwned[account] = _rOwned[account].div(_getCurrentReflectionRate());\\r\\n        }\\r\\n        _isExcludedFromReflections[account] = true;\\r\\n        _excludedFromReflections.push(account);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function includeInReflections(address account) public onlyManagement() returns (bool) {\\r\\n        require(account != _contextAddress(), \\\"cannot include token address in reflections\\\");\\r\\n        require(account != address(_pancakePair), \\\"cannot include pancake pair in reflections\\\");\\r\\n        require(_isExcludedFromReflections[account], \\\"account is already included in reflections\\\");\\r\\n        for(uint256 i = 0; i < _excludedFromReflections.length; i++) {\\r\\n            if(_excludedFromReflections[i] == account){\\r\\n                _excludedFromReflections[i] = _excludedFromReflections[_excludedFromReflections.length - 1];\\r\\n                _tOwned[account] = 0;\\r\\n                _isExcludedFromReflections[account] = false;\\r\\n                _excludedFromReflections.pop();\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function excludeFromFees(address account) public onlyManagement() returns (bool) {\\r\\n        _isExcludedFromFees[account] = true;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function includeInFees(address account) public onlyManagement() returns (bool) {\\r\\n        require(account != _contextAddress(), \\\"cannot include token address in fees\\\");\\r\\n        require(account != _deadAddress, \\\"cannot include dead address in fees\\\");\\r\\n        _isExcludedFromFees[account] = false;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function excludeFromLimits(address account) public onlyManagement() returns (bool) {\\r\\n        _isExcludedFromLimits[account] = true;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function includeInLimits(address account) public onlyManagement() returns (bool) {\\r\\n        require(account != _contextAddress(), \\\"cannot include token address in limits\\\");\\r\\n        require(account != _deadAddress, \\\"cannot include dead address in limits\\\");\\r\\n        _isExcludedFromLimits[account] = false;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n\\r\\n    function addManagementFeesReciever(address managementFeesReciever) public onlyManagement() returns (bool) {\\r\\n        require(!_isManagementFeesReciever[managementFeesReciever], \\\"address is already a management fees reciever\\\");\\r\\n        require(_managementFeesRecievers.length < _maxNumberManagementFeesRecievers, \\\"max number of management fees recievers already reached\\\");\\r\\n        _managementFeesRecievers.push(managementFeesReciever);\\r\\n        _isManagementFeesReciever[managementFeesReciever] = true;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function removeManagementFeesReciever(address managementFeesReciever) public onlyManagement() returns (bool) {\\r\\n        require(_isManagementFeesReciever[managementFeesReciever], \\\"address is already not a management fees reciever\\\");\\r\\n        for(uint256 i = 0; i < _managementFeesRecievers.length; i++) {\\r\\n            if(_managementFeesRecievers[i] == managementFeesReciever){\\r\\n                _managementFeesRecievers[i] = _managementFeesRecievers[_excludedFromReflections.length - 1];\\r\\n                _isManagementFeesReciever[managementFeesReciever] = false;\\r\\n                _managementFeesRecievers.pop();\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setFeesEnabled(bool areFeesEnabled) public onlyManagement() returns (bool) {\\r\\n        _areFeesEnabled = areFeesEnabled;\\r\\n        if(!areFeesEnabled){\\r\\n            _isAutoFeeLiquifyEnabled = false;\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setFeesEnabled(bool areFeesEnabled, bool isAutoFeeLiquifyEnabled) public onlyManagement() returns (bool) {\\r\\n        _areFeesEnabled = areFeesEnabled;\\r\\n        if(!areFeesEnabled){\\r\\n            _isAutoFeeLiquifyEnabled = false;\\r\\n        } else {\\r\\n            _isAutoFeeLiquifyEnabled = isAutoFeeLiquifyEnabled;\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setManagementFeeBuy(uint256 managementFeeBuy) public onlyManagement() returns (bool) {\\r\\n        require(_buyFeeTotalPercentage - _buyFeeManagementPercentage + managementFeeBuy <= 20, \\\"total buy fees cannot exceed 20\\\");\\r\\n        _buyFeeManagementPercentage = managementFeeBuy;\\r\\n        _buyFeeTotalPercentage = _buyFeeManagementPercentage + _buyFeeReservePercentage + _buyFeeReflectionPercentage;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setManagementFeeSell(uint256 managementFeeSell) public onlyManagement() returns (bool) {\\r\\n        require(_sellFeeTotalPercentage - _sellFeeManagementPercentage + managementFeeSell <= 20, \\\"total sell fees cannot exceed 20\\\");\\r\\n        _sellFeeManagementPercentage = managementFeeSell;\\r\\n        _sellFeeTotalPercentage = _sellFeeManagementPercentage + _sellFeeReservePercentage + _sellFeeReflectionPercentage;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setReserveFeeBuy(uint256 reserveFeeBuy) public onlyManagement() returns (bool) {\\r\\n        require(_buyFeeTotalPercentage - _buyFeeReservePercentage + reserveFeeBuy <= 20, \\\"total buy fees cannot exceed 20\\\");\\r\\n        _buyFeeReservePercentage = reserveFeeBuy;\\r\\n        _buyFeeTotalPercentage = _buyFeeManagementPercentage + _buyFeeReservePercentage + _buyFeeReflectionPercentage;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setReserveFeeSell(uint256 reserveFeeSell) public onlyManagement() returns (bool) {\\r\\n        require(_sellFeeTotalPercentage - _sellFeeReservePercentage + reserveFeeSell <= 20, \\\"total sell fees cannot exceed 20\\\");\\r\\n        _sellFeeReservePercentage = reserveFeeSell;\\r\\n        _sellFeeTotalPercentage = _sellFeeManagementPercentage + _sellFeeReservePercentage + _sellFeeReflectionPercentage;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setReflectionsFeeBuy(uint256 reflectionsFeeBuy) public onlyManagement() returns (bool) {\\r\\n        require(_buyFeeTotalPercentage - _buyFeeReflectionPercentage + reflectionsFeeBuy <= 20, \\\"total buy fees cannot exceed 20\\\");\\r\\n        _buyFeeReflectionPercentage = reflectionsFeeBuy;\\r\\n        _buyFeeTotalPercentage = _buyFeeManagementPercentage + _buyFeeReservePercentage + _buyFeeReflectionPercentage;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setReflectionsFeeSell(uint256 reflectionsFeeSell) public onlyManagement() returns (bool) {\\r\\n        require(_sellFeeTotalPercentage - _sellFeeReflectionPercentage + reflectionsFeeSell <= 20, \\\"total sell fees cannot exceed 20\\\");\\r\\n        _sellFeeReflectionPercentage = reflectionsFeeSell;\\r\\n        _sellFeeTotalPercentage = _sellFeeManagementPercentage + _sellFeeReservePercentage + _sellFeeReflectionPercentage;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setAutoFeeLiquifyEnabled(bool isAutoFeeLiquifyEnabled) public onlyManagement() returns (bool) {\\r\\n        require(_areFeesEnabled || !isAutoFeeLiquifyEnabled, \\\"fees must be enabled to enable auto fee liquify\\\");\\r\\n        _isAutoFeeLiquifyEnabled = isAutoFeeLiquifyEnabled;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setAutoLiquifyFactor(uint256 autoLiquifyFactor) public onlyManagement() returns (bool) {\\r\\n        require(autoLiquifyFactor <= 100, \\\"auto liquify factor cannot eceed 100\\\");\\r\\n        _autoLiquifyFactor = autoLiquifyFactor;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setMinPendingFeesForAutoLiquify(uint256 minPendingFeesForAutoLiquify) public onlyManagement() returns (bool) {\\r\\n        _minPendingFeesForAutoLiquify = minPendingFeesForAutoLiquify;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setAutoBuybackEnabled(bool isAutoBuybackEnabled) public onlyManagement() returns (bool) {\\r\\n        _isAutoBuybackEnabled = isAutoBuybackEnabled;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setMinReserveETHForAutoBuyback(uint256 minReserveETHForAutoBuyback) public onlyManagement() returns (bool) {\\r\\n        _minReserveETHForAutoBuyback = minReserveETHForAutoBuyback;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setAutoBuybackFactor(uint256 autoBuybackFactor) public onlyManagement() returns (bool) {\\r\\n        require(autoBuybackFactor <= 100, \\\"auto buyback factor cannot exceed 100\\\");\\r\\n        _autoBuybackFactor = autoBuybackFactor;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setAutoReinjectEnabled(bool isAutoReinjectEnabled) public onlyManagement() returns (bool) {\\r\\n        _isAutoReinjectEnabled = isAutoReinjectEnabled;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setMinReserveETHForAutoReinject(uint256 minReserveETHForAutoReinject) public onlyManagement() returns (bool) {\\r\\n        _minReserveETHForAutoReinject = minReserveETHForAutoReinject;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setAutoReinjectFactor(uint256 autoReinjectFactor) public onlyManagement() returns (bool){\\r\\n        require(autoReinjectFactor <= 100, \\\"auto reinject factor cannot exceed 100\\\");\\r\\n        _autoReinjectFactor = autoReinjectFactor;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setLimitsEnabled(bool areLimitsEnabled) public onlyManagement() returns (bool) {\\r\\n        _areLimitsEnabled = areLimitsEnabled;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setMaxTransferAmount(uint256 maxTransferAmount) public onlyManagement() returns (bool) {\\r\\n        require(maxTransferAmount <= _tTotal, \\\"max transfer amount cannot exceed token supply\\\");\\r\\n        _maxTransferAmount = maxTransferAmount;\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function performManualTokenBuyback(uint256 buybackFactor) public onlyManagement() returns (bool) {\\r\\n        _buybackTokens(buybackFactor);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function performManualFeeLiquidation(uint256 liquifyFactor) public onlyManagement() returns (bool) {\\r\\n        _liquidateFees(liquifyFactor);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function performManualDeadTokenReinjecton(uint256 reinjectFactor) public onlyManagement() returns (bool) {\\r\\n        _reinjectTokens(reinjectFactor);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    \\r\\n\\r\\n    modifier internalSwapLock() {\\r\\n        _isInternallySwapping = true;\\r\\n        _;\\r\\n        _isInternallySwapping = false;\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    event SwapTokensForETH(uint256 amountTokens, address[] path);\\r\\n\\r\\n    event SwapETHForTokens(uint256 amountETH, address[] path);\\r\\n\\r\\n    event MintTokens(uint256 amountTokens);\\r\\n\\r\\n    event ReflectTokens(uint256 amountTokens);\\r\\n\\r\\n}\"\r\n    },\r\n    \"/C/Users/Stew/Documents/The Coin Sack Token/contracts/contexts/Callable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\n\\r\\ncontract Callable {\\r\\n\\r\\n    address payable private _context;\\r\\n    address private _creator;\\r\\n\\r\\n    constructor() { \\r\\n        _context = payable(address(this));\\r\\n        _creator = msg.sender;\\r\\n        emit CreateContext(_context, _creator);\\r\\n    }\\r\\n\\r\\n\\r\\n    function _contextAddress() internal view returns (address payable) {\\r\\n        return _context;\\r\\n    }\\r\\n\\r\\n    function _contextCreator() internal view returns (address) {\\r\\n        return _creator;\\r\\n    }\\r\\n\\r\\n    function _msgSender() internal view returns (address payable) {\\r\\n        return payable(msg.sender);\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view returns (bytes memory) {\\r\\n        this;\\r\\n        return msg.data;\\r\\n    }\\r\\n\\r\\n    function _msgTimestamp() internal view returns (uint256) {\\r\\n        this;\\r\\n        return block.timestamp;\\r\\n    }\\r\\n\\r\\n\\r\\n    receive() external payable { }\\r\\n\\r\\n\\r\\n    event CreateContext(address contextAddress, address contextCreator);\\r\\n    \\r\\n}\"\r\n    },\r\n    \"/C/Users/Stew/Documents/The Coin Sack Token/contracts/contexts/Manageable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\nimport './Callable.sol';\\r\\n\\r\\n\\r\\ncontract Manageable is Callable {\\r\\n\\r\\n    address private _executiveManager;\\r\\n    mapping(address => bool) private _isManager;\\r\\n    address[] private _managers;\\r\\n\\r\\n    bool private _managementIsLocked = false;\\r\\n    uint256 private _managementUnlockTime = 0;\\r\\n\\r\\n\\r\\n    constructor () {\\r\\n        _executiveManager = _contextCreator();\\r\\n        _isManager[_executiveManager] = true;\\r\\n        _managers.push(_executiveManager);\\r\\n\\r\\n        emit ManagerAdded(_executiveManager);\\r\\n        emit ExecutiveManagerChanged(address(0), _executiveManager);\\r\\n    }\\r\\n\\r\\n\\r\\n    function executiveManager() public view returns (address) {\\r\\n        return _executiveManager;\\r\\n    }\\r\\n\\r\\n    function isManager(address account) public view returns (bool) {\\r\\n        return _isManager[account];\\r\\n    }\\r\\n\\r\\n    function managementIsLocked() public view returns (bool) {\\r\\n        return _managementIsLocked;\\r\\n    }\\r\\n\\r\\n    function timeToManagementUnlock() public view returns (uint256) {\\r\\n        return block.timestamp >= _managementUnlockTime ? 0 : _managementUnlockTime - block.timestamp;\\r\\n    }\\r\\n    \\r\\n    function addManager(address newManager) public onlyExecutive() returns (bool) {\\r\\n        require(!_isManager[newManager], \\\"Account is already a manager\\\");\\r\\n        require(newManager != address(0), \\\"0 address cannot be made manager\\\");\\r\\n\\r\\n        _isManager[newManager] = true;\\r\\n        _managers.push(newManager);\\r\\n\\r\\n        emit ManagerAdded(newManager);\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function removeManager(address managerToRemove) public onlyExecutive() returns (bool) {\\r\\n        require(_isManager[managerToRemove], \\\"Account is already not a manager\\\");\\r\\n        require(managerToRemove != _executiveManager, \\\"Executive manager cannot be removed\\\");\\r\\n\\r\\n        _isManager[managerToRemove] = false;\\r\\n        for(uint256 i = 0; i < _managers.length; i++) {\\r\\n            if(_managers[i] == managerToRemove){\\r\\n                _managers[i] = _managers[_managers.length - 1];\\r\\n                _managers.pop();\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        emit ManagerRemoved(managerToRemove);\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function changeExecutiveManager(address newExecutiveManager) public onlyExecutive() returns (bool) {\\r\\n        require(newExecutiveManager != _executiveManager, \\\"Manager is already the executive\\\");\\r\\n\\r\\n        if(!_isManager[newExecutiveManager]){\\r\\n            _isManager[newExecutiveManager] = true;\\r\\n            emit ManagerAdded(newExecutiveManager);\\r\\n        }\\r\\n        _executiveManager = newExecutiveManager;\\r\\n\\r\\n        emit ExecutiveManagerChanged(_executiveManager, newExecutiveManager);\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function lockManagement(uint256 lockDuration) public onlyExecutive() returns (bool) {\\r\\n        _managementIsLocked = true;\\r\\n        _managementUnlockTime = block.timestamp + lockDuration;\\r\\n\\r\\n        emit ManagementLocked(lockDuration);\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function unlockManagement() public onlyExecutive() returns (bool) {\\r\\n        _managementIsLocked = false;\\r\\n        _managementUnlockTime = 0;\\r\\n\\r\\n        emit ManagementUnlocked();\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function renounceManagement() public onlyExecutive() returns (bool) {\\r\\n        while(_managers.length > 0) {\\r\\n            _isManager[_managers[_managers.length - 1]] = false;\\r\\n\\r\\n            emit ManagerRemoved(_managers[_managers.length - 1]);\\r\\n\\r\\n            if(_managers[_managers.length - 1] == _executiveManager){\\r\\n                emit ExecutiveManagerChanged(_executiveManager, address(0));\\r\\n                _executiveManager = address(0);\\r\\n            }\\r\\n\\r\\n            _managers.pop();\\r\\n        }\\r\\n\\r\\n        emit ManagementRenounced();\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    event ManagerAdded(address addedManager);\\r\\n    event ManagerRemoved(address removedManager);\\r\\n    event ExecutiveManagerChanged(address indexed previousExecutiveManager, address indexed newExecutiveManager);\\r\\n    event ManagementLocked(uint256 lockDuration);\\r\\n    event ManagementUnlocked();\\r\\n    event ManagementRenounced();\\r\\n\\r\\n\\r\\n\\r\\n    modifier onlyExecutive() {\\r\\n        require(_msgSender() == _executiveManager, \\\"Caller is not the executive manager\\\");\\r\\n        require(!_managementIsLocked || block.timestamp >= _managementUnlockTime, \\\"Management is locked\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyManagement() {\\r\\n        require(_isManager[_msgSender()], \\\"Caller is not a manager\\\");\\r\\n        require(!_managementIsLocked, \\\"Management is locked\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"/C/Users/Stew/Documents/The Coin Sack Token/contracts/interfaces/IBEP20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0\\npragma solidity >=0.5.0;\\n\\ninterface IBEP20 {\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n}\\n\"\r\n    },\r\n    \"/C/Users/Stew/Documents/The Coin Sack Token/contracts/interfaces/IPancakeFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.5.0;\\n\\ninterface IPancakeFactory {\\n\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n\\n}\\n\"\r\n    },\r\n    \"/C/Users/Stew/Documents/The Coin Sack Token/contracts/interfaces/IPancakePair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.5.0;\\n\\ninterface IPancakePair {\\n\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n\\n}\\n\"\r\n    },\r\n    \"/C/Users/Stew/Documents/The Coin Sack Token/contracts/interfaces/IPancakeRouter01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.6.2;\\n\\ninterface IPancakeRouter01 {\\n\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n\\n}\\n\"\r\n    },\r\n    \"/C/Users/Stew/Documents/The Coin Sack Token/contracts/interfaces/IPancakeRouter02.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.6.2;\\n\\nimport './IPancakeRouter01.sol';\\n\\ninterface IPancakeRouter02 is IPancakeRouter01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"/C/Users/Stew/Documents/The Coin Sack Token/contracts/libraries/SackMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\n\\r\\nlibrary SackMath {\\r\\n\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"addition overflow\\\");\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if(b >= a){\\r\\n            return 0;\\r\\n        }\\r\\n        uint256 c = a - b;\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if (a == 0 || b == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"multiplication overflow\\\");\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b > 0, \\\"division by zero\\\");\\r\\n        uint256 c = a / b;\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b != 0, \\\"modulo by zero\\\");\\r\\n        return a % b;\\r\\n    }\\r\\n\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"constantinople\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pancakeRouter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contextAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contextCreator\",\"type\":\"address\"}],\"name\":\"CreateContext\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousExecutiveManager\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newExecutiveManager\",\"type\":\"address\"}],\"name\":\"ExecutiveManagerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockDuration\",\"type\":\"uint256\"}],\"name\":\"ManagementLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ManagementRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ManagementUnlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addedManager\",\"type\":\"address\"}],\"name\":\"ManagerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"removedManager\",\"type\":\"address\"}],\"name\":\"ManagerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountTokens\",\"type\":\"uint256\"}],\"name\":\"MintTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountTokens\",\"type\":\"uint256\"}],\"name\":\"ReflectTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"SwapETHForTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"SwapTokensForETH\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_amountTotalFeesPendingLiquidation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_areFeesEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_areLimitsEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_autoBuybackFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_autoLiquifyFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_autoReinjectFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_buyFeeManagementPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_buyFeeReflectionPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_buyFeeReservePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_buyFeeTotalPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_deadAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_isAutoBuybackEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_isAutoFeeLiquifyEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_isAutoReinjectEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_managementFeesRecievers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxNumberManagementFeesRecievers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxTransferAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_minPendingFeesForAutoLiquify\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_minReserveETHForAutoBuyback\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_minReserveETHForAutoReinject\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_pancakePair\",\"outputs\":[{\"internalType\":\"contract IPancakePair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_pancakeRouter\",\"outputs\":[{\"internalType\":\"contract IPancakeRouter02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sellFeeManagementPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sellFeeReflectionPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sellFeeReservePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sellFeeTotalPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"managementFeesReciever\",\"type\":\"address\"}],\"name\":\"addManagementFeesReciever\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"addManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tAmount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newExecutiveManager\",\"type\":\"address\"}],\"name\":\"changeExecutiveManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromLimits\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromReflections\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"executiveManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInLimits\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInReflections\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromLimits\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromReflections\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lockDuration\",\"type\":\"uint256\"}],\"name\":\"lockManagement\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"managementIsLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"reinjectFactor\",\"type\":\"uint256\"}],\"name\":\"performManualDeadTokenReinjecton\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"liquifyFactor\",\"type\":\"uint256\"}],\"name\":\"performManualFeeLiquidation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"buybackFactor\",\"type\":\"uint256\"}],\"name\":\"performManualTokenBuyback\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"managementFeesReciever\",\"type\":\"address\"}],\"name\":\"removeManagementFeesReciever\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"managerToRemove\",\"type\":\"address\"}],\"name\":\"removeManager\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceManagement\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isAutoBuybackEnabled\",\"type\":\"bool\"}],\"name\":\"setAutoBuybackEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"autoBuybackFactor\",\"type\":\"uint256\"}],\"name\":\"setAutoBuybackFactor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isAutoFeeLiquifyEnabled\",\"type\":\"bool\"}],\"name\":\"setAutoFeeLiquifyEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"autoLiquifyFactor\",\"type\":\"uint256\"}],\"name\":\"setAutoLiquifyFactor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isAutoReinjectEnabled\",\"type\":\"bool\"}],\"name\":\"setAutoReinjectEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"autoReinjectFactor\",\"type\":\"uint256\"}],\"name\":\"setAutoReinjectFactor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"areFeesEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isAutoFeeLiquifyEnabled\",\"type\":\"bool\"}],\"name\":\"setFeesEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"areFeesEnabled\",\"type\":\"bool\"}],\"name\":\"setFeesEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"areLimitsEnabled\",\"type\":\"bool\"}],\"name\":\"setLimitsEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"managementFeeBuy\",\"type\":\"uint256\"}],\"name\":\"setManagementFeeBuy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"managementFeeSell\",\"type\":\"uint256\"}],\"name\":\"setManagementFeeSell\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxTransferAmount\",\"type\":\"uint256\"}],\"name\":\"setMaxTransferAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minPendingFeesForAutoLiquify\",\"type\":\"uint256\"}],\"name\":\"setMinPendingFeesForAutoLiquify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minReserveETHForAutoBuyback\",\"type\":\"uint256\"}],\"name\":\"setMinReserveETHForAutoBuyback\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minReserveETHForAutoReinject\",\"type\":\"uint256\"}],\"name\":\"setMinReserveETHForAutoReinject\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"reflectionsFeeBuy\",\"type\":\"uint256\"}],\"name\":\"setReflectionsFeeBuy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"reflectionsFeeSell\",\"type\":\"uint256\"}],\"name\":\"setReflectionsFeeSell\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"reserveFeeBuy\",\"type\":\"uint256\"}],\"name\":\"setReserveFeeBuy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"reserveFeeSell\",\"type\":\"uint256\"}],\"name\":\"setReserveFeeSell\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeToManagementUnlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tAmount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlockManagement\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "CoinSackToken", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e", "EVMVersion": "constantinople", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}