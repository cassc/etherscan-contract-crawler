{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Callback for IUniswapV3PoolActions#swap\\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\\ninterface IUniswapV3SwapCallback {\\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\\n    function uniswapV3SwapCallback(\\n        int256 amount0Delta,\\n        int256 amount1Delta,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.7.5;\\npragma abicoder v2;\\n\\nimport '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';\\n\\n/// @title Router token swapping functionality\\n/// @notice Functions for swapping tokens via Uniswap V3\\ninterface ISwapRouter is IUniswapV3SwapCallback {\\n    struct ExactInputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\\n\\n    struct ExactInputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\\n\\n    struct ExactOutputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\\n\\n    struct ExactOutputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPermitV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.6;\\n\\ninterface IPermitV2 {\\n  /// @notice Shared errors between signature based transfers and allowance based transfers.\\n\\n  /// @notice Thrown when validating an inputted signature that is stale\\n  /// @param signatureDeadline The timestamp at which a signature is no longer valid\\n  error SignatureExpired(uint256 signatureDeadline);\\n\\n  /// @notice Thrown when validating that the inputted nonce has not been used\\n  error InvalidNonce();\\n\\n  function approve(\\n    address token,\\n    address spender,\\n    uint160 amount,\\n    uint48 expiration\\n  ) external;\\n\\n  function allowance(\\n    address,\\n    address,\\n    address\\n  )\\n    external\\n    view\\n    returns (\\n      uint160,\\n      uint48,\\n      uint48\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IQuoterV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.6;\\npragma abicoder v2;\\n\\n/// @title QuoterV2 Interface\\n/// @notice Supports quoting the calculated amounts from exact input or exact output swaps.\\n/// @notice For each pool also tells you the number of initialized ticks crossed and the sqrt price of the pool after the swap.\\n/// @dev These functions are not marked view because they rely on calling non-view functions and reverting\\n/// to compute the result. They are also not gas efficient and should not be called on-chain.\\ninterface IQuoterV2 {\\n  /// @notice Returns the amount out received for a given exact input swap without executing the swap\\n  /// @param path The path of the swap, i.e. each token pair and the pool fee\\n  /// @param amountIn The amount of the first token to swap\\n  /// @return amountOut The amount of the last token that would be received\\n  /// @return sqrtPriceX96AfterList List of the sqrt price after the swap for each pool in the path\\n  /// @return initializedTicksCrossedList List of the initialized ticks that the swap crossed for each pool in the path\\n  /// @return gasEstimate The estimate of the gas that the swap consumes\\n  function quoteExactInput(bytes memory path, uint256 amountIn)\\n    external\\n    returns (\\n      uint256 amountOut,\\n      uint160[] memory sqrtPriceX96AfterList,\\n      uint32[] memory initializedTicksCrossedList,\\n      uint256 gasEstimate\\n    );\\n\\n  struct QuoteExactInputSingleParams {\\n    address tokenIn;\\n    address tokenOut;\\n    uint256 amountIn;\\n    uint24 fee;\\n    uint160 sqrtPriceLimitX96;\\n  }\\n\\n  /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\\n  /// @param params The params for the quote, encoded as `QuoteExactInputSingleParams`\\n  /// tokenIn The token being swapped in\\n  /// tokenOut The token being swapped out\\n  /// fee The fee of the token pool to consider for the pair\\n  /// amountIn The desired input amount\\n  /// sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\\n  /// @return amountOut The amount of `tokenOut` that would be received\\n  /// @return sqrtPriceX96After The sqrt price of the pool after the swap\\n  /// @return initializedTicksCrossed The number of initialized ticks that the swap crossed\\n  /// @return gasEstimate The estimate of the gas that the swap consumes\\n  function quoteExactInputSingle(\\n    QuoteExactInputSingleParams memory params\\n  )\\n    external\\n    returns (\\n      uint256 amountOut,\\n      uint160 sqrtPriceX96After,\\n      uint32 initializedTicksCrossed,\\n      uint256 gasEstimate\\n    );\\n\\n  /// @notice Returns the amount in required for a given exact output swap without executing the swap\\n  /// @param path The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order\\n  /// @param amountOut The amount of the last token to receive\\n  /// @return amountIn The amount of first token required to be paid\\n  /// @return sqrtPriceX96AfterList List of the sqrt price after the swap for each pool in the path\\n  /// @return initializedTicksCrossedList List of the initialized ticks that the swap crossed for each pool in the path\\n  /// @return gasEstimate The estimate of the gas that the swap consumes\\n  function quoteExactOutput(bytes memory path, uint256 amountOut)\\n    external\\n    returns (\\n      uint256 amountIn,\\n      uint160[] memory sqrtPriceX96AfterList,\\n      uint32[] memory initializedTicksCrossedList,\\n      uint256 gasEstimate\\n    );\\n\\n  struct QuoteExactOutputSingleParams {\\n    address tokenIn;\\n    address tokenOut;\\n    uint256 amount;\\n    uint24 fee;\\n    uint160 sqrtPriceLimitX96;\\n  }\\n\\n  /// @notice Returns the amount in required to receive the given exact output amount but for a swap of a single pool\\n  /// @param params The params for the quote, encoded as `QuoteExactOutputSingleParams`\\n  /// tokenIn The token being swapped in\\n  /// tokenOut The token being swapped out\\n  /// fee The fee of the token pool to consider for the pair\\n  /// amountOut The desired output amount\\n  /// sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\\n  /// @return amountIn The amount required as the input for the swap in order to receive `amountOut`\\n  /// @return sqrtPriceX96After The sqrt price of the pool after the swap\\n  /// @return initializedTicksCrossed The number of initialized ticks that the swap crossed\\n  /// @return gasEstimate The estimate of the gas that the swap consumes\\n  function quoteExactOutputSingle(\\n    QuoteExactOutputSingleParams memory params\\n  )\\n    external\\n    returns (\\n      uint256 amountIn,\\n      uint160 sqrtPriceX96After,\\n      uint32 initializedTicksCrossed,\\n      uint256 gasEstimate\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniversalRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.6;\\n\\ninterface IUniversalRouter {\\n  /// @notice Thrown when a required command has failed\\n  error ExecutionFailed(uint256 commandIndex, bytes message);\\n\\n  /// @notice Thrown when attempting to send ETH directly to the contract\\n  error ETHNotAccepted();\\n\\n  /// @notice Thrown when executing commands with an expired deadline\\n  error TransactionDeadlinePassed();\\n\\n  /// @notice Thrown when attempting to execute commands and an incorrect number of inputs are provided\\n  error LengthMismatch();\\n\\n  /// @notice Executes encoded commands along with provided inputs. Reverts if deadline has expired.\\n  /// @param commands A set of concatenated commands, each 1 byte in length\\n  /// @param inputs An array of byte strings containing abi encoded inputs for each command\\n  /// @param deadline The deadline by which the transaction must be executed\\n  function execute(\\n    bytes calldata commands,\\n    bytes[] calldata inputs,\\n    uint256 deadline\\n  ) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n  /**\\n   * @dev Returns true if `account` is a contract.\\n   *\\n   * [IMPORTANT]\\n   * ====\\n   * It is unsafe to assume that an address for which this function returns\\n   * false is an externally-owned account (EOA) and not a contract.\\n   *\\n   * Among others, `isContract` will return false for the following\\n   * types of addresses:\\n   *\\n   *  - an externally-owned account\\n   *  - a contract in construction\\n   *  - an address where a contract will be created\\n   *  - an address where a contract lived, but was destroyed\\n   * ====\\n   */\\n  function isContract(address account) internal view returns (bool) {\\n    // This method relies on extcodesize, which returns 0 for contracts in\\n    // construction, since the code is only stored at the end of the\\n    // constructor execution.\\n\\n    uint256 size;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      size := extcodesize(account)\\n    }\\n    return size > 0;\\n  }\\n\\n  /**\\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n   * `recipient`, forwarding all available gas and reverting on errors.\\n   *\\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n   * imposed by `transfer`, making them unable to receive funds via\\n   * `transfer`. {sendValue} removes this limitation.\\n   *\\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n   *\\n   * IMPORTANT: because control is transferred to `recipient`, care must be\\n   * taken to not create reentrancy vulnerabilities. Consider using\\n   * {ReentrancyGuard} or the\\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n   */\\n  function sendValue(address payable recipient, uint256 amount)\\n    internal\\n  {\\n    require(\\n      address(this).balance >= amount,\\n      \\\"Address: insufficient balance\\\"\\n    );\\n\\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n    (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n    require(\\n      success,\\n      \\\"Address: unable to send value, recipient may have reverted\\\"\\n    );\\n  }\\n\\n  /**\\n   * @dev Performs a Solidity function call using a low level `call`. A\\n   * plain`call` is an unsafe replacement for a function call: use this\\n   * function instead.\\n   *\\n   * If `target` reverts with a revert reason, it is bubbled up by this\\n   * function (like regular Solidity function calls).\\n   *\\n   * Returns the raw returned data. To convert to the expected return value,\\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n   *\\n   * Requirements:\\n   *\\n   * - `target` must be a contract.\\n   * - calling `target` with `data` must not revert.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCall(address target, bytes memory data)\\n    internal\\n    returns (bytes memory)\\n  {\\n    return\\n      functionCall(target, data, \\\"Address: low-level call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n   * `errorMessage` as a fallback revert reason when `target` reverts.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, 0, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but also transferring `value` wei to `target`.\\n   *\\n   * Requirements:\\n   *\\n   * - the calling contract must have an ETH balance of at least `value`.\\n   * - the called Solidity function must be `payable`.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value\\n  ) internal returns (bytes memory) {\\n    return\\n      functionCallWithValue(\\n        target,\\n        data,\\n        value,\\n        \\\"Address: low-level call with value failed\\\"\\n      );\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(\\n      address(this).balance >= value,\\n      \\\"Address: insufficient balance for call\\\"\\n    );\\n    require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n    // solhint-disable-next-line avoid-low-level-calls\\n    (bool success, bytes memory returndata) = target.call{\\n      value: value\\n    }(data);\\n    return _verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but performing a static call.\\n   *\\n   * _Available since v3.3._\\n   */\\n  function functionStaticCall(address target, bytes memory data)\\n    internal\\n    view\\n    returns (bytes memory)\\n  {\\n    return\\n      functionStaticCall(\\n        target,\\n        data,\\n        \\\"Address: low-level static call failed\\\"\\n      );\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n   * but performing a static call.\\n   *\\n   * _Available since v3.3._\\n   */\\n  function functionStaticCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal view returns (bytes memory) {\\n    require(\\n      isContract(target),\\n      \\\"Address: static call to non-contract\\\"\\n    );\\n\\n    // solhint-disable-next-line avoid-low-level-calls\\n    (bool success, bytes memory returndata) = target.staticcall(data);\\n    return _verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but performing a delegate call.\\n   *\\n   * _Available since v3.4._\\n   */\\n  function functionDelegateCall(address target, bytes memory data)\\n    internal\\n    returns (bytes memory)\\n  {\\n    return\\n      functionDelegateCall(\\n        target,\\n        data,\\n        \\\"Address: low-level delegate call failed\\\"\\n      );\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n   * but performing a delegate call.\\n   *\\n   * _Available since v3.4._\\n   */\\n  function functionDelegateCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(\\n      isContract(target),\\n      \\\"Address: delegate call to non-contract\\\"\\n    );\\n\\n    // solhint-disable-next-line avoid-low-level-calls\\n    (bool success, bytes memory returndata) = target.delegatecall(\\n      data\\n    );\\n    return _verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  function _verifyCallResult(\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) private pure returns (bytes memory) {\\n    if (success) {\\n      return returndata;\\n    } else {\\n      // Look for revert reason and bubble it up if present\\n      if (returndata.length > 0) {\\n        // The easiest way to bubble the revert reason is using memory via assembly\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n          let returndata_size := mload(returndata)\\n          revert(add(32, returndata), returndata_size)\\n        }\\n      } else {\\n        revert(errorMessage);\\n      }\\n    }\\n  }\\n}\"\r\n    },\r\n    \"contracts/libraries/Commands.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.6;\\n\\n/// @title Commands\\n/// @notice Command Flags used to decode commands\\nlibrary Commands {\\n  // Masks to extract certain bits of commands\\n  bytes1 internal constant FLAG_ALLOW_REVERT = 0x80;\\n  bytes1 internal constant COMMAND_TYPE_MASK = 0x3f;\\n\\n  // Command Types. Maximum supported command at this moment is 0x3f.\\n\\n  // Command Types where value<0x08, executed in the first nested-if block\\n  uint256 constant V3_SWAP_EXACT_IN = 0x00;\\n  uint256 constant V3_SWAP_EXACT_OUT = 0x01;\\n  uint256 constant PERMIT2_TRANSFER_FROM = 0x02;\\n  uint256 constant PERMIT2_PERMIT_BATCH = 0x03;\\n  uint256 constant SWEEP = 0x04;\\n  uint256 constant TRANSFER = 0x05;\\n  uint256 constant PAY_PORTION = 0x06;\\n  // COMMAND_PLACEHOLDER = 0x07;\\n\\n  // The commands are executed in nested if blocks to minimise gas consumption\\n  // The following constant defines one of the boundaries where the if blocks split commands\\n  uint256 constant FIRST_IF_BOUNDARY = 0x08;\\n\\n  // Command Types where 0x08<=value<=0x0f, executed in the second nested-if block\\n  uint256 constant V2_SWAP_EXACT_IN = 0x08;\\n  uint256 constant V2_SWAP_EXACT_OUT = 0x09;\\n  uint256 constant PERMIT2_PERMIT = 0x0a;\\n  uint256 constant WRAP_ETH = 0x0b;\\n  uint256 constant UNWRAP_WETH = 0x0c;\\n  uint256 constant PERMIT2_TRANSFER_FROM_BATCH = 0x0d;\\n  uint256 constant BALANCE_CHECK_ERC20 = 0x0e;\\n  // COMMAND_PLACEHOLDER = 0x0f;\\n\\n  // The commands are executed in nested if blocks to minimise gas consumption\\n  // The following constant defines one of the boundaries where the if blocks split commands\\n  uint256 constant SECOND_IF_BOUNDARY = 0x10;\\n\\n  // Command Types where 0x10<=value<0x18, executed in the third nested-if block\\n  uint256 constant SEAPORT_V1_5 = 0x10;\\n  uint256 constant LOOKS_RARE_V2 = 0x11;\\n  uint256 constant NFTX = 0x12;\\n  uint256 constant CRYPTOPUNKS = 0x13;\\n  // 0x14;\\n  uint256 constant OWNER_CHECK_721 = 0x15;\\n  uint256 constant OWNER_CHECK_1155 = 0x16;\\n  uint256 constant SWEEP_ERC721 = 0x17;\\n\\n  // The commands are executed in nested if blocks to minimise gas consumption\\n  // The following constant defines one of the boundaries where the if blocks split commands\\n  uint256 constant THIRD_IF_BOUNDARY = 0x18;\\n\\n  // Command Types where 0x18<=value<=0x1f, executed in the final nested-if block\\n  uint256 constant X2Y2_721 = 0x18;\\n  uint256 constant SUDOSWAP = 0x19;\\n  uint256 constant NFT20 = 0x1a;\\n  uint256 constant X2Y2_1155 = 0x1b;\\n  uint256 constant FOUNDATION = 0x1c;\\n  uint256 constant SWEEP_ERC1155 = 0x1d;\\n  uint256 constant ELEMENT_MARKET = 0x1e;\\n  // COMMAND_PLACEHOLDER = 0x1f;\\n\\n  // The commands are executed in nested if blocks to minimise gas consumption\\n  // The following constant defines one of the boundaries where the if blocks split commands\\n  uint256 constant FOURTH_IF_BOUNDARY = 0x20;\\n\\n  // Command Types where 0x20<=value\\n  uint256 constant SEAPORT_V1_4 = 0x20;\\n  uint256 constant EXECUTE_SUB_PLAN = 0x21;\\n  uint256 constant APPROVE_ERC20 = 0x22;\\n  // COMMAND_PLACEHOLDER for 0x23 to 0x3f (all unused)\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n  using Address for address;\\n\\n  function safeTransfer(\\n    IERC20 token,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.transfer.selector, to, value)\\n    );\\n  }\\n\\n  function safeTransferFrom(\\n    IERC20 token,\\n    address from,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(\\n        token.transferFrom.selector,\\n        from,\\n        to,\\n        value\\n      )\\n    );\\n  }\\n\\n  /**\\n   * @dev Deprecated. This function has issues similar to the ones found in\\n   * {IERC20-approve}, and its usage is discouraged.\\n   *\\n   * Whenever possible, use {safeIncreaseAllowance} and\\n   * {safeDecreaseAllowance} instead.\\n   */\\n  function safeApprove(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    // safeApprove should only be called when setting an initial allowance,\\n    // or when resetting it to zero. To increase and decrease it, use\\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n    // solhint-disable-next-line max-line-length\\n    require(\\n      (value == 0) || (token.allowance(address(this), spender) == 0),\\n      \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n    );\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(token.approve.selector, spender, value)\\n    );\\n  }\\n\\n  function safeIncreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    uint256 newAllowance = token.allowance(address(this), spender) +\\n      value;\\n    _callOptionalReturn(\\n      token,\\n      abi.encodeWithSelector(\\n        token.approve.selector,\\n        spender,\\n        newAllowance\\n      )\\n    );\\n  }\\n\\n  function safeDecreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    unchecked {\\n      uint256 oldAllowance = token.allowance(address(this), spender);\\n      require(\\n        oldAllowance >= value,\\n        \\\"SafeERC20: decreased allowance below zero\\\"\\n      );\\n      uint256 newAllowance = oldAllowance - value;\\n      _callOptionalReturn(\\n        token,\\n        abi.encodeWithSelector(\\n          token.approve.selector,\\n          spender,\\n          newAllowance\\n        )\\n      );\\n    }\\n  }\\n\\n  /**\\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n   * on the return value: the return value is optional (but if data is returned, it must not be false).\\n   * @param token The token targeted by the call.\\n   * @param data The call data (encoded using abi.encode or one of its variants).\\n   */\\n  function _callOptionalReturn(IERC20 token, bytes memory data)\\n    private\\n  {\\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n    // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n    // the target address contains contract code and also asserts for success in the low-level call.\\n\\n    bytes memory returndata = address(token).functionCall(\\n      data,\\n      \\\"SafeERC20: low-level call failed\\\"\\n    );\\n    if (returndata.length > 0) {\\n      // Return data is optional\\n      // solhint-disable-next-line max-line-length\\n      require(\\n        abi.decode(returndata, (bool)),\\n        \\\"SafeERC20: ERC20 operation did not succeed\\\"\\n      );\\n    }\\n  }\\n}\"\r\n    },\r\n    \"contracts/TemplarRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\\\";\\nimport \\\"./interfaces/IUniversalRouter.sol\\\";\\nimport \\\"./interfaces/IPermitV2.sol\\\";\\nimport \\\"./interfaces/IQuoterV2.sol\\\";\\nimport \\\"./libraries/Commands.sol\\\";\\nimport \\\"./libraries/SafeERC20.sol\\\";\\n\\ninterface IStableRouter {\\n  function exchange(\\n    int128 i,\\n    int128 j,\\n    uint256 dx,\\n    uint256 min_dy\\n  ) external returns (uint256);\\n\\n  function get_dy(\\n    int128 i,\\n    int128 j,\\n    uint256 dx\\n  ) external view returns (uint256);\\n}\\n\\ninterface ITreasury {\\n  function mint(uint256 _amount) external returns (uint256);\\n\\n  function redeem(uint256 _amount) external returns (uint256);\\n\\n  function reserveToTMAmount(uint256 _amount)\\n    external\\n    view\\n    returns (uint256);\\n\\n  function tmToReserveAmount(uint256 _amount)\\n    external\\n    view\\n    returns (uint256);\\n}\\n\\ncontract TemplarRouter is Ownable {\\n  using SafeERC20 for IERC20;\\n  ISwapRouter swapRouter;\\n\\n  address public immutable treasury;\\n  address public immutable tm;\\n  address public immutable usdt;\\n  address public immutable wbnb;\\n  address public immutable tem;\\n  address public immutable stableRouter;\\n  address public immutable uniRouter;\\n  address public immutable permit2;\\n  address public immutable quoter2;\\n\\n  mapping(address => bool) public tokenList;\\n  mapping(address => int128) public tokenParam;\\n\\n  event Swap(\\n    address indexed _address,\\n    address _tokenA,\\n    address _tokenB,\\n    uint256 _amountIn,\\n    uint256 _minAmountOut,\\n    uint256 _amountOut\\n  );\\n\\n  modifier allowTokenList(address _tokenA, address _tokenB) {\\n    require(_tokenA != _tokenB, \\\"not same token\\\");\\n    require(\\n      tokenList[_tokenA] && tokenList[_tokenB],\\n      \\\"token not allow\\\"\\n    );\\n    _;\\n  }\\n\\n  constructor(\\n    address _treasury,\\n    address _tm,\\n    address _busd,\\n    address _usdt,\\n    address _usdc,\\n    address _dai,\\n    address _tem,\\n    address _wbnb,\\n    address _stableRouter,\\n    address _uniRouter,\\n    address _permit2,\\n    address _quoter2\\n  ) {\\n    require(_treasury != address(0), \\\"invalid address\\\");\\n    require(_tm != address(0), \\\"invalid address\\\");\\n    require(_busd != address(0), \\\"invalid address\\\");\\n    require(_usdt != address(0), \\\"invalid address\\\");\\n    require(_usdc != address(0), \\\"invalid address\\\");\\n    require(_dai != address(0), \\\"invalid address\\\");\\n    require(_tem != address(0), \\\"invalid TEM address\\\");\\n    require(_wbnb != address(0), \\\"invalid WBNB address\\\");\\n    require(_stableRouter != address(0), \\\"invalid address\\\");\\n    require(\\n      _uniRouter != address(0),\\n      \\\"invalid UniswapV3 router address\\\"\\n    );\\n    require(_permit2 != address(0), \\\"invalid permit2 address\\\");\\n\\n    treasury = _treasury;\\n    tm = _tm;\\n    usdt = _usdt;\\n    wbnb = _wbnb;\\n    tem = _tem;\\n    stableRouter = _stableRouter;\\n    uniRouter = _uniRouter;\\n    permit2 = _permit2;\\n    quoter2 = _quoter2;\\n\\n    // initial token list\\n    tokenList[_tm] = true;\\n    tokenList[_busd] = true;\\n    tokenList[_usdt] = true;\\n    tokenList[_dai] = true;\\n    tokenList[_usdc] = true;\\n    tokenList[_tem] = true;\\n\\n    // initial stable swap param\\n    tokenParam[_busd] = 0;\\n    tokenParam[_usdt] = 1;\\n    tokenParam[_dai] = 2;\\n    tokenParam[_usdc] = 3;\\n  }\\n\\n  function swap(\\n    address _tokenA,\\n    address _tokenB,\\n    uint256 _amountIn,\\n    uint256 _minAmountOut\\n  )\\n    external\\n    allowTokenList(_tokenA, _tokenB)\\n    returns (uint256 _amountOut)\\n  {\\n    IERC20(_tokenA).safeTransferFrom(\\n      msg.sender,\\n      address(this),\\n      _amountIn\\n    );\\n\\n    if (_tokenA == tem) {\\n      _amountOut = _swapWithUniswapV3(_amountIn, 0, tem, usdt);\\n      if (_tokenB != usdt) {\\n        _amountOut = _swapStableTM(usdt, _tokenB, _amountOut, 0);\\n      }\\n    } else if (_tokenB == tem) {\\n      uint256 amountIn = _amountIn;\\n      if (_tokenA != usdt) {\\n        amountIn = _swapStableTM(_tokenA, usdt, amountIn, 0);\\n      }\\n      _amountOut = _swapWithUniswapV3(amountIn, 0, usdt, tem);\\n    } else {\\n      _amountOut = _swapStableTM(_tokenA, _tokenB, _amountIn, 0);\\n    }\\n\\n    require(_amountOut >= _minAmountOut, \\\"slippage\\\");\\n    IERC20(_tokenB).safeTransfer(msg.sender, _amountOut);\\n\\n    emit Swap(\\n      msg.sender,\\n      _tokenA,\\n      _tokenB,\\n      _amountIn,\\n      _minAmountOut,\\n      _amountOut\\n    );\\n  }\\n\\n  function getAmountOut(\\n    address _tokenA,\\n    address _tokenB,\\n    uint256 _amountIn\\n  )\\n    external\\n    allowTokenList(_tokenA, _tokenB)\\n    returns (uint256 _amountOut)\\n  {\\n    if (_tokenA == tem) {\\n      _amountOut = _getQuoteExactInput(tem, usdt, _amountIn);\\n      if (_tokenB != usdt) {\\n        _amountOut = _getExactInputSwapStableTM(\\n          usdt,\\n          _tokenB,\\n          _amountOut\\n        );\\n      }\\n    } else if (_tokenB == tem) {\\n      uint256 amountIn = _amountIn;\\n      if (_tokenA != usdt) {\\n        amountIn = _getExactInputSwapStableTM(\\n          _tokenA,\\n          usdt,\\n          amountIn\\n        );\\n      }\\n      _amountOut = _getQuoteExactInput(usdt, tem, amountIn);\\n    } else {\\n      _amountOut = _getExactInputSwapStableTM(\\n        _tokenA,\\n        _tokenB,\\n        _amountIn\\n      );\\n    }\\n  }\\n\\n  // ------------------------------\\n  // internal\\n  // ------------------------------\\n  function _getQuoteExactInput(\\n    address _tokenA,\\n    address _tokenB,\\n    uint256 _amountIn\\n  ) internal returns (uint256 amountOut) {\\n    (uint24 fee1, uint24 fee2) = _tokenA == usdt ? (500, 3000) : (3000, 500);\\n    bytes memory paths = abi.encodePacked(\\n      _tokenA,\\n      fee1,\\n      wbnb,\\n      fee2,\\n      _tokenB\\n    );\\n    IQuoterV2 q = IQuoterV2(quoter2);\\n    (amountOut, , , ) = q.quoteExactInput(paths, _amountIn);\\n  }\\n\\n  function _getExactInputSwapStableTM(\\n    address _tokenA,\\n    address _tokenB,\\n    uint256 _amountIn\\n  ) internal view returns (uint256 _amountOut) {\\n    if (_tokenA == tm) {\\n      _amountOut = ITreasury(treasury).tmToReserveAmount(_amountIn);\\n    } else if (_tokenB == tm) {\\n      _amountOut = ITreasury(treasury).reserveToTMAmount(_amountIn);\\n    } else {\\n      _amountOut = IStableRouter(stableRouter).get_dy(\\n        tokenParam[_tokenA],\\n        tokenParam[_tokenB],\\n        _amountIn\\n      );\\n    }\\n  }\\n\\n  function _swapStableTM(\\n    address _tokenA,\\n    address _tokenB,\\n    uint256 _amountIn,\\n    uint256 _minAmountOut\\n  ) internal returns (uint256 _amountOut) {\\n    if (_tokenA == tm) {\\n      _amountOut = _zapRedeem(_tokenB, _amountIn, _minAmountOut);\\n    } else if (_tokenB == tm) {\\n      _amountOut = _zapMint(_tokenA, _amountIn, _minAmountOut);\\n    } else {\\n      _amountOut = _stableSwap(\\n        _tokenA,\\n        _tokenB,\\n        _amountIn,\\n        _minAmountOut\\n      );\\n    }\\n  }\\n\\n  function _zapMint(\\n    address _token,\\n    uint256 _amountIn,\\n    uint256 _minAmountOut\\n  ) internal returns (uint256 _amountOut) {\\n    // swap to USDT\\n    uint256 _balance = (_token == usdt)\\n      ? _amountIn\\n      : _swap(_token, usdt, _amountIn, _minAmountOut);\\n\\n    // mint\\n    IERC20(usdt).safeApprove(treasury, _balance);\\n    _amountOut = ITreasury(treasury).mint(_balance);\\n  }\\n\\n  function _zapRedeem(\\n    address _token,\\n    uint256 _amountIn,\\n    uint256 _minAmountOut\\n  ) internal returns (uint256 _amountOut) {\\n    // redeem to USDT\\n    IERC20(tm).safeApprove(treasury, _amountIn);\\n    uint256 _balance = ITreasury(treasury).redeem(_amountIn);\\n\\n    // swap from USDT\\n    _amountOut = (_token == usdt)\\n      ? _balance\\n      : _swap(usdt, _token, _balance, _minAmountOut);\\n  }\\n\\n  function _stableSwap(\\n    address _tokenA,\\n    address _tokenB,\\n    uint256 _amountIn,\\n    uint256 _minAmountOut\\n  ) internal returns (uint256 _amountOut) {\\n    _amountOut = _swap(_tokenA, _tokenB, _amountIn, _minAmountOut);\\n  }\\n\\n  function _swap(\\n    address _tokenA,\\n    address _tokenB,\\n    uint256 _amountIn,\\n    uint256 _minAmountOut\\n  ) internal returns (uint256 _amountOut) {\\n    IERC20(_tokenA).safeApprove(stableRouter, _amountIn);\\n    _amountOut = IStableRouter(stableRouter).exchange(\\n      tokenParam[_tokenA],\\n      tokenParam[_tokenB],\\n      _amountIn,\\n      _minAmountOut\\n    );\\n  }\\n\\n  function _swapWithUniswapV3(\\n    uint256 _amountIn,\\n    uint256 _minAmountOut,\\n    address _tokenA,\\n    address _tokenB\\n  ) internal returns (uint256 _amountOut) {\\n    // Get balance before\\n    uint256 balanceBefore = IERC20(_tokenB).balanceOf(address(this));\\n\\n    // Permit2 token approval\\n    IERC20(_tokenA).safeApprove(permit2, _amountIn);\\n    IPermitV2(permit2).approve(\\n      _tokenA,\\n      uniRouter,\\n      uint160(_amountIn),\\n      uint48(block.timestamp + 60)\\n    );\\n\\n    // Create commands and inputs\\n    // 0x00 = V3_SWAP_EXACT_IN\\n    bytes memory commands = abi.encodePacked(\\n      bytes1(uint8(Commands.V3_SWAP_EXACT_IN))\\n    );\\n    bytes[] memory inputs = new bytes[](1);\\n\\n    // Just only paths supported\\n    // USDT -> WBNB -> TEM\\n    // TEM -> WBNB -> USDT\\n    (uint24 fee1, uint24 fee2) = _tokenA == usdt ? (500, 3000) : (3000, 500);\\n    bytes memory paths = abi.encodePacked(\\n      _tokenA,\\n      fee1,\\n      wbnb,\\n      fee2,\\n      _tokenB\\n    );\\n\\n    // 0x00 V3_SWAP_EXACT_IN\\n    // (recipient, amountIn, minAmountOut, paths, bool A flag from msg.sender)\\n    inputs[0] = abi.encode(\\n      address(0x0000000000000000000000000000000000000001), // MSG_SENDER\\n      _amountIn,\\n      _minAmountOut,\\n      paths,\\n      true\\n    );\\n\\n    IUniversalRouter router = IUniversalRouter(uniRouter);\\n    router.execute(commands, inputs, block.timestamp + 60);\\n\\n    uint256 balanceAfter = IERC20(_tokenB).balanceOf(address(this));\\n    _amountOut = balanceAfter - balanceBefore;\\n  }\\n\\n  // ------------------------------\\n  // onlyOwner\\n  // ------------------------------\\n  function addTokenList(address _token) external onlyOwner {\\n    require(_token != address(0), \\\"address invalid\\\");\\n    tokenList[_token] = true;\\n  }\\n\\n  function removeTokenList(address _token) external onlyOwner {\\n    require(_token != address(0), \\\"address invalid\\\");\\n    tokenList[_token] = false;\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tm\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_busd\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_usdt\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_usdc\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dai\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tem\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wbnb\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stableRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uniRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_permit2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_quoter2\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_tokenA\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_tokenB\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_minAmountOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amountOut\",\"type\":\"uint256\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"addTokenList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"}],\"name\":\"getAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"permit2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"quoter2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"removeTokenList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stableRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minAmountOut\",\"type\":\"uint256\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tem\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tm\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenParam\",\"outputs\":[{\"internalType\":\"int128\",\"name\":\"\",\"type\":\"int128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wbnb\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "TemplarRouter", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000001cc4994bc2bbc6e5ada11c7b90005e57eee39752000000000000000000000000194d1d62d8d798fcc81a6435e6d13adf8bcc2966000000000000000000000000e9e7cea3dedca5984780bafc599bd69add087d5600000000000000000000000055d398326f99059ff775485246999027b31979550000000000000000000000008ac76a51cc950d9822d68b83fe1ad97b32cd580d0000000000000000000000001af3f329e8be154074d8769d1ffa4ee058b1dbc300000000000000000000000019e6bfc1a6e4b042fb20531244d47e252445df01000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c000000000000000000000000b3f0c9ea1f05e312093fdb031e789a756659b0ac0000000000000000000000005dc88340e1c5c6366864ee415d6034cadd1a9897000000000000000000000000000000000022d473030f116ddee9f6b43ac78ba300000000000000000000000078d78e420da98ad378d7799be8f4af69033eb077", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}