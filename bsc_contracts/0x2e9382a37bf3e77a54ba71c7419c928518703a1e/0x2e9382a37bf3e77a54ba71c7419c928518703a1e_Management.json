{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.0 ;\r\n\r\ninterface IProxy {\r\n    function changeAdmin(address newAdmin) external returns(bool);\r\n    function upgrad(address newLogic) external returns(bool);\r\n}\r\n\r\ninterface IManagement {\r\n    function addNodePropose(address _addr) external;\r\n    function deleteNodePropose(address _addr) external;\r\n    function updateProxyAdminPropose(address _targetAddr, address _addr) external;\r\n    function updateProxyUpgradPropose(address _targetAddr, address _addr) external;\r\n    function excContractPropose(address _targetAddr, bytes memory _data) external;\r\n    function vote(uint256 _proposalId) external;\r\n\r\n}\r\n\r\ncontract Management is IManagement{\r\n    using SafeMath for uint256;\r\n    uint256 public  proposalCount;                           \r\n    mapping(uint256 => ProposalMsg) public proposalMsg;\r\n    uint256 public nodeNum;\r\n    mapping(address => uint256) nodeAddrIndex;\r\n    mapping(uint256 => address) nodeIndexAddr;\r\n    mapping(address => bool) public nodeAddrSta;\r\n    bool private reentrancyLock = false;\r\n\r\n    event Propose(address indexed proposer, uint256 proposalId, string label);\r\n    event Vote(address indexed voter, uint256 proposalId);\r\n    \r\n    struct ProposalMsg {\r\n        address[] proposers;\r\n        bool proposalSta; \r\n        address targetAddr;   \r\n        address addr;  \r\n        bytes data;\r\n\t\tuint256 expire; \r\n        uint256 typeIndex;  \r\n        string  label;  \r\n        mapping(address => bool) voterSta;  \r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(!reentrancyLock);\r\n        reentrancyLock = true;\r\n        _;\r\n        reentrancyLock = false;\r\n    }\r\n\r\n    constructor(address[] memory _nodeAddrs) {\r\n        uint256 len = _nodeAddrs.length;\r\n        require( len> 4,\"The number of node addresses cannot be less than 5\");\r\n        for (uint256 i = 0; i< _nodeAddrs.length; i++){\r\n            addNodeAddr(_nodeAddrs[i]);\r\n        }\r\n    }\r\n \r\n    fallback() external{\r\n\r\n    }\r\n   \r\n    function addNodePropose(address _addr) override external{\r\n        require(!nodeAddrSta[_addr], \"This node is already a node address\");\r\n        bytes memory data = new bytes(0x00);\r\n        _propose(address(0), _addr, data, 2, \"addNode\");\r\n    }\r\n  \r\n    function deleteNodePropose(address _addr) override external{\r\n        require(nodeAddrSta[_addr], \"This node is not a node address\");\r\n        require(nodeNum > 5, \"The number of node addresses cannot be less than 5\");\r\n        _propose(address(0), _addr, new bytes(0x00), 3, \"deleteNode\");\r\n    }\r\n     \r\n    function updateProxyAdminPropose(address _targetAddr, address _addr) override external{\r\n        _propose(_targetAddr, _addr, new bytes(0x00), 4, \"updateProxyAdmin\");\r\n    }\r\n      \r\n    function updateProxyUpgradPropose(address _targetAddr, address _addr) override external{\r\n        _propose(_targetAddr, _addr, new bytes(0x00), 5, \"updateProxyUpgrad\");\r\n    }\r\n   \r\n    function excContractPropose(address _targetAddr, bytes memory _data) override external{\r\n        require(bytesToUint(_data) != 2401778032 && bytesToUint(_data) != 822583150, \"Calls to methods of proxy contracts are not allowed\");\r\n        _propose(_targetAddr, address(0), _data, 6, \"excContract\");\r\n    }\r\n\r\n    function _propose(\r\n        address _targetAddr, \r\n        address _addr, \r\n        bytes memory _data, \r\n        uint256 _typeIndex, \r\n        string memory _label\r\n    ) internal{\r\n        address _sender = msg.sender;\r\n        require(nodeAddrSta[_sender], \"The caller is not the nodeAddr\"); \r\n        uint256 _time = block.timestamp;\r\n        uint256 _proposalId = ++proposalCount;\r\n        ProposalMsg storage _proposalMsg = proposalMsg[_proposalId];\r\n        _proposalMsg.proposers.push(_sender);\r\n        _proposalMsg.targetAddr = _targetAddr;\r\n        _proposalMsg.addr = _addr;\r\n        _proposalMsg.data = _data;\r\n        _proposalMsg.expire = _time.add(86400);\r\n        _proposalMsg.typeIndex = _typeIndex;\r\n        _proposalMsg.label = _label;\r\n        _proposalMsg.voterSta[_sender] = true;\r\n        emit Propose(_sender, _proposalId, _label);\r\n    }\r\n    \r\n    function vote(uint256 _proposalId) override external nonReentrant(){\r\n        address _sender = msg.sender;\r\n        require(nodeAddrSta[_sender], \"The caller is not the nodeAddr\"); \r\n        uint256 _time = block.timestamp;\r\n        ProposalMsg storage _proposalMsg = proposalMsg[_proposalId];\r\n        require(_proposalMsg.expire > _time, \"The vote on the proposal has expired\");\r\n        require(!_proposalMsg.voterSta[_sender], \"The proposer has already voted\");\r\n        _proposalMsg.proposers.push(_sender);\r\n        _proposalMsg.voterSta[_sender] = true;\r\n        uint256 length = _proposalMsg.proposers.length;\r\n        if(length> nodeNum/2 && !_proposalMsg.proposalSta){\r\n            require(_actuator(_proposalId), \"The method call failed\");\r\n            _proposalMsg.proposalSta = true;\r\n        }\r\n        emit Vote(_sender, _proposalId);\r\n    }\r\n    \r\n    function _actuator(uint256 _proposalId) internal returns(bool){\r\n        bool result = false;\r\n        ProposalMsg storage _proposalMsg = proposalMsg[_proposalId];\r\n        uint256 _typeIndex = _proposalMsg.typeIndex;\r\n        if(_typeIndex == 2){\r\n            addNodeAddr(_proposalMsg.addr);\r\n            result = true;\r\n        }else if(_typeIndex == 3){\r\n            deleteNodeAddr(_proposalMsg.addr);\r\n            result = true;\r\n        }else if(_typeIndex == 4){\r\n            IProxy proxy = IProxy(_proposalMsg.targetAddr);\r\n            result = proxy.changeAdmin(_proposalMsg.addr);\r\n        }else if(_typeIndex == 5){\r\n            IProxy proxy = IProxy(_proposalMsg.targetAddr);\r\n            result = proxy.upgrad(_proposalMsg.addr);\r\n        }else if(_typeIndex == 6){\r\n            bytes memory _data = _proposalMsg.data;\r\n            (result, ) = _proposalMsg.targetAddr.call(_data);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function addNodeAddr(address _nodeAddr) internal{\r\n        require(!nodeAddrSta[_nodeAddr], \"This node is already a node address\");\r\n        nodeAddrSta[_nodeAddr] = true;\r\n        uint256 _nodeAddrIndex = nodeAddrIndex[_nodeAddr];\r\n        if (_nodeAddrIndex == 0){\r\n            _nodeAddrIndex = ++nodeNum;\r\n            nodeAddrIndex[_nodeAddr] = _nodeAddrIndex;\r\n            nodeIndexAddr[_nodeAddrIndex] = _nodeAddr;\r\n        }\r\n    }\r\n\r\n    function deleteNodeAddr(address _nodeAddr) internal{\r\n        require(nodeAddrSta[_nodeAddr], \"This node is not a pledge node\");\r\n        nodeAddrSta[_nodeAddr] = false;\r\n        uint256 _nodeAddrIndex = nodeAddrIndex[_nodeAddr];\r\n        if (_nodeAddrIndex > 0){\r\n            uint256 _nodeNum = nodeNum;\r\n            address _lastNodeAddr = nodeIndexAddr[_nodeNum];\r\n            nodeAddrIndex[_lastNodeAddr] = _nodeAddrIndex;\r\n            nodeIndexAddr[_nodeAddrIndex] = _lastNodeAddr;\r\n            nodeAddrIndex[_nodeAddr] = 0;\r\n            nodeIndexAddr[_nodeNum] = address(0x0);\r\n            nodeNum--;\r\n        }\r\n        require(nodeNum > 4, \"The number of node addresses cannot be less than 5\");\r\n    }\r\n\r\n    function bytesToUint(bytes memory _data) internal pure returns (uint256){\r\n        require(_data.length >= 4, \"Insufficient byte length\");\r\n        uint256 number;\r\n        for(uint i= 0; i<4; i++){\r\n            number = number + uint8(_data[i])*(2**(8*(4-(i+1))));\r\n        }\r\n        return  number;\r\n    }\r\n\r\n    function queryVotes(\r\n        uint256 _proposalId\r\n    ) \r\n        external \r\n        view \r\n        returns(\r\n            address[] memory, \r\n            bool, \r\n            address, \r\n            address,\r\n            bytes memory, \r\n            uint256, \r\n            string memory)\r\n    {\r\n        ProposalMsg storage _proposalMsg = proposalMsg[_proposalId];\r\n        uint256 len = _proposalMsg.proposers.length;\r\n        address[] memory proposers = new address[](len);\r\n        for (uint256 i = 0; i < len; i++) {\r\n            proposers[i] = _proposalMsg.proposers[i];\r\n        }\r\n        return (proposers, _proposalMsg.proposalSta, _proposalMsg.targetAddr, _proposalMsg.addr, _proposalMsg.data, \r\n               _proposalMsg.expire, _proposalMsg.label);\r\n    }\r\n\r\n    function queryNodes()  external view returns(address[] memory){\r\n        address[] memory nodes = new address[](nodeNum);\r\n        for (uint256 i = 1; i <= nodeNum; i++) {\r\n            nodes[i-1] = nodeIndexAddr[i];\r\n        }\r\n        return nodes;\r\n    }\r\n\r\n}\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_nodeAddrs\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"label\",\"type\":\"string\"}],\"name\":\"Propose\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proposalId\",\"type\":\"uint256\"}],\"name\":\"Vote\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"addNodePropose\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"deleteNodePropose\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_targetAddr\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"excContractPropose\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nodeAddrSta\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nodeNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposalMsg\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"proposalSta\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"targetAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"expire\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"typeIndex\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"label\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"queryNodes\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_proposalId\",\"type\":\"uint256\"}],\"name\":\"queryVotes\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_targetAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"updateProxyAdminPropose\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_targetAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"updateProxyUpgradPropose\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_proposalId\",\"type\":\"uint256\"}],\"name\":\"vote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Management", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000800000000000000000000000066fe6cb3979fcef6f7d009d51fa900d47ef8950200000000000000000000000036287a7d6ee83903b6cfd048608e12d9c5ea0b250000000000000000000000000d4f5cebcecd89901e9f1e81491509c6e108577a0000000000000000000000007f7ba6605c94443fec5733198db9caba68bcb53a0000000000000000000000007f1a0b063238e8097a35a96a2784fa7e7261a78e000000000000000000000000a1ad09371cc235ad8c5a1c12e75f55442d5f888f000000000000000000000000934d7414a07f4077de65615ff1006c57c3ab62fc0000000000000000000000004eedab5d0ab5788caffe8e21a698fbcb44c59d32", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a9705c3ec694e68a7d66f965f0ce042d353c1aa9a02b32bfe8293ec1085f3870"}