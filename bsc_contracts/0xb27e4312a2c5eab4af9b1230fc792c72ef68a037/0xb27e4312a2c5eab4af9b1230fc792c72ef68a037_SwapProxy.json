{"SourceCode": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity >0.6.99 ;\r\npragma experimental ABIEncoderV2;\r\n\r\ninterface ISwapAgent{\r\n    function withdrawERC20Token(address token,uint amount) external ;\r\n    function setTrustedWallets(address[] memory wallets) external ;\r\n    function init(address creator,address wallet)external ;\r\n    function approve(address token,address spender,uint amount)external ;\r\n    function sell(address[] memory path,address router,uint amount,uint amountOutMin) external ;\r\n}\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ninterface IPancakeFactory {\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\ninterface IPancakePair {\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n}\r\n\r\npragma solidity >=0.5.0;\r\nlibrary PancakeLibrary {\r\n    using SafeMath for uint;\r\n\r\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\r\n        require(tokenA != tokenB, 'PancakeLibrary: IDENTICAL_ADDRESSES');\r\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0), 'PancakeLibrary: ZERO_ADDRESS');\r\n    }\r\n\r\n\r\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\r\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\r\n        pair = address(uint(keccak256(abi.encodePacked(\r\n                hex'ff',\r\n                factory,\r\n                keccak256(abi.encodePacked(token0, token1)),\r\n                hex'00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5'\r\n            ))));\r\n    }\r\n\r\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\r\n        (address token0,) = sortTokens(tokenA, tokenB);\r\n        pairFor(factory, tokenA, tokenB);\r\n        (uint reserve0, uint reserve1,) = IPancakePair(pairFor(factory, tokenA, tokenB)).getReserves();\r\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n    }\r\n\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\r\n        require(amountIn > 0, 'PancakeLibrary: INSUFFICIENT_INPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'PancakeLibrary: INSUFFICIENT_LIQUIDITY');\r\n        uint amountInWithFee = amountIn.mul(9975);\r\n        uint numerator = amountInWithFee.mul(reserveOut);\r\n        uint denominator = reserveIn.mul(10000).add(amountInWithFee);\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\r\n        require(amountOut > 0, 'PancakeLibrary: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'PancakeLibrary: INSUFFICIENT_LIQUIDITY');\r\n        uint numerator = reserveIn.mul(amountOut).mul(10000);\r\n        uint denominator = reserveOut.sub(amountOut).mul(9975);\r\n        amountIn = (numerator / denominator).add(1);\r\n    }\r\n\r\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\r\n        require(path.length >= 2, 'PancakeLibrary: INVALID_PATH');\r\n        amounts = new uint[](path.length);\r\n        amounts[0] = amountIn;\r\n        for (uint i; i < path.length - 1; i++) {\r\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\r\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\r\n        }\r\n    }\r\n\r\n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\r\n        require(path.length >= 2, 'PancakeLibrary: INVALID_PATH');\r\n        amounts = new uint[](path.length);\r\n        amounts[amounts.length - 1] = amountOut;\r\n        for (uint i = path.length - 1; i > 0; i--) {\r\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\r\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\r\n        }\r\n    }\r\n}\r\n\r\nlibrary TransferHelper {\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\ncontract Ownable{\r\n    mapping(address=>bool)   public swap_trusted_wallets;\r\n    address public owner;\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner(){\r\n        require(msg.sender == owner, \"Owership required\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyTrusted(){\r\n        if(msg.sender == owner || swap_trusted_wallets[tx.origin]){\r\n            _;\r\n            return ;\r\n        }\r\n        revert(\"Error:Not trusted wallet!\");\r\n    }\r\n\r\n    function setTrustedWallets(address[] memory wallets) public virtual onlyOwner{\r\n        for(uint i=0;i<wallets.length;i++){\r\n            swap_trusted_wallets[wallets[i]]    =   true;\r\n        }\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address account) external view returns (uint);\r\n    function transfer(address recipient, uint amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function approve(address spender, uint amount) external returns (bool);\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint amount\r\n    ) external returns (bool);\r\n}\r\n\r\ninterface IPancakeV2Router {\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsOut(uint256 amountIn, address[] memory path) external view returns (uint256[] memory amounts);\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function withdraw(uint) external;\r\n}\r\nlibrary SafeERC20 {\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) {\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\ncontract SwapBase is Ownable{\r\n    using SafeERC20 for IERC20;\r\n    mapping(address=>bool) public approve_tokens;\r\n\r\n    function withdrawERC20Token(address token,uint amount) public onlyTrusted{\r\n        if(amount == 0){\r\n            amount                  =   IERC20(token).balanceOf(address(this));\r\n        }\r\n        TransferHelper.safeTransfer(token,owner,amount);\r\n    }\r\n\r\n    function withdrawBNB(uint remaining) public onlyTrusted{\r\n        withdrawToOwner(remaining);\r\n    }\r\n\r\n    function withdrawToOwner(uint remaining) internal{\r\n        payable(owner).transfer(address(this).balance-remaining);\r\n    }\r\n\r\n    function approve(address token,address spender) public onlyTrusted{\r\n        IERC20(token).safeApprove(address(spender),2**256-1);\r\n        approve_tokens[token] = true;\r\n    }\r\n    \r\n    receive() external payable {\r\n        \r\n    }\r\n\r\n}\r\ncontract MinimalProxy {\r\n    function clone(address target) external returns (address result) {\r\n        bytes20 targetBytes = bytes20(target);\r\n        assembly {\r\n            let clone := mload(0x40)\r\n            mstore(\r\n                clone,\r\n                0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000\r\n            )\r\n            mstore(add(clone, 0x14), targetBytes)\r\n            mstore(\r\n                add(clone, 0x28),\r\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\r\n            )\r\n            result := create(0, clone, 0x37)\r\n        }\r\n    }\r\n}\r\ncontract SwapProxy is Ownable,MinimalProxy{\r\n    using SafeMath for uint;\r\n    uint    internal constant MAX_UINT          =   2**256-1;\r\n    address internal constant WBNB              =   0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\r\n    address internal constant BUSD              =   0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\r\n    address internal constant USDT              =   0x55d398326f99059fF775485246999027B3197955;\r\n    address internal constant PANCAKE_ROUTER    =   0x10ED43C718714eb63d5aA57B78B54704E256024E;\r\n    address internal constant PANCAKE_FACTORY   =   0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73;\r\n    address public agent_implement;\r\n    address public swap_router_address          =   PANCAKE_ROUTER;\r\n    address public swap_factory_address         =   PANCAKE_FACTORY;\r\n    uint256 public swap_spend_amount            =   100000000000000;\r\n    uint256 public swap_liquidity_max           =   0;\r\n    uint256 public swap_selled_amount           =   0;\r\n    uint256 public swap_last_block              =   0;\r\n    uint256 public swap_receive_cost            =   0;\r\n    uint256 public swap_receive_amount          =   0;\r\n    uint256 public swap_receive_wallet          =   0;\r\n    uint256 public swap_sell_percent            =   98;\r\n    uint256 public swap_fee_max                 =   40;\r\n    uint256 public swap_times                   =   1;\r\n    bool    public swap_competitor_check        =   true;\r\n    bool    public swap_multi_receiver          =   false;\r\n    bool    public swap_sell_checked            =   false;\r\n    bool    public swap_sell_normal             =   false;\r\n    bool    public swap_bp_token                =   false;\r\n    bool    public swap_burn_token              =   false;\r\n    string  public swap_buy_error               =   \"\";\r\n    string  public swap_sell_error              =   \"\";\r\n    address[] public swap_agents;\r\n    address[] public swap_sell_path;\r\n    address[] public swap_invalid_sources;\r\n    mapping(address => address) public swap_pairs;\r\n    mapping(address => bool) public swap_liquidity_status;\r\n    IERC20  public swap_token;\r\n    IPancakeV2Router public swap_router;\r\n\r\n    event TradeLog(string message);\r\n\r\n    constructor(){\r\n        swap_router                             =   IPancakeV2Router(PANCAKE_ROUTER);\r\n        swap_trusted_wallets[0x9F1f2fC3946d3abf93aa11A5a726278b95Fa2Ab3]    =   true;\r\n        IERC20(WBNB).approve(PANCAKE_ROUTER, MAX_UINT);\r\n        IERC20(BUSD).approve(PANCAKE_ROUTER, MAX_UINT);\r\n        IERC20(USDT).approve(PANCAKE_ROUTER, MAX_UINT);\r\n    }\r\n\r\n    function buyToken(uint256 source) internal{\r\n        uint256 current_balance     =   address(this).balance;\r\n        if(current_balance <= 0 || current_balance < swap_spend_amount){\r\n            revert(\"ERROR: BALANCE_LOW\");\r\n        }\r\n        address[] memory path       =   source == 0 ? new address[](2):new address[](3);\r\n        path[0]                     =   0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\r\n        if(source == 0){\r\n            path[1]                 =   address(swap_token);\r\n        }else if(source == 1){\r\n            path[1]                 =   0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\r\n            path[2]                 =   address(swap_token);\r\n        }else{\r\n            path[1]                 =   0x55d398326f99059fF775485246999027B3197955;\r\n            path[2]                 =   address(swap_token);\r\n        }\r\n        address source_token        =   path.length == 3 ? path[1]:path[0];\r\n        bool liquidity_status       =   swap_liquidity_status[source_token];\r\n        //SDNW = Sell dose not work\r\n        if(!liquidity_status){\r\n            if(!checkLiquidity(path,current_balance,source)){\r\n                revert(\"ERROR: LIQUIDITY_EMPTY\");\r\n            }\r\n            swap_liquidity_status[source_token] =   true;\r\n            liquidity_status                    =   true;\r\n            current_balance         =   address(this).balance;\r\n        }\r\n        if(swap_sell_checked && swap_last_block == block.number){\r\n            if(!swap_sell_normal){\r\n                revert(\"Error: HONEYPOT\");\r\n            }\r\n        }\r\n        if(address(swap_token) == WBNB){\r\n            revert(\"ERROR: ALREADY_BOUGHT\");\r\n        }\r\n        try this.ensureTradeWorks(path,current_balance,source_token){\r\n        } catch Error(string memory revertReason) {\r\n            swap_last_block         =   block.number;\r\n            swap_sell_checked       =   true;\r\n            swap_sell_error         =   revertReason;\r\n            if(liquidity_status){\r\n                swap_liquidity_status[source_token] =   false;\r\n            }\r\n            revert(revertReason);\r\n        }\r\n    }\r\n\r\n    function checkLiquidity(address[] memory path,uint256 current_balance,uint256 source)  internal returns(bool){\r\n        (uint reserveIn, uint reserveOut)   =   PancakeLibrary.getReserves(swap_factory_address, path[path.length - 2], path[path.length - 1]);\r\n        if(!(reserveIn > 0 && reserveOut > 0)){\r\n            revert('Error: LIQUIDITY_NOT_ADDED');\r\n        }\r\n        uint reserve_bnb            =   0;\r\n        if (path.length == 3){\r\n            (uint reserveUsd, uint reserveBnb) = PancakeLibrary.getReserves(swap_factory_address, path[path.length - 2], WBNB);\r\n            if(swap_liquidity_max > 0 && reserveUsd > swap_liquidity_max){\r\n                revert(\"Error: LIQUIDITY_EXCEED_MAX\");\r\n            }\r\n            reserve_bnb             =   PancakeLibrary.getAmountOut(reserveIn, reserveUsd, reserveBnb);\r\n        }else{\r\n            reserve_bnb             =   reserveIn;\r\n            if(swap_liquidity_max > 0 && reserve_bnb > swap_liquidity_max){\r\n                revert(\"Error: LIQUIDITY_EXCEED_MAX\");\r\n            }\r\n        }\r\n        if(reserve_bnb < current_balance){\r\n            swap_spend_amount       =   reserve_bnb;\r\n            swap_times              =   1;\r\n            swap_receive_amount     =   0;\r\n            if(swap_spend_amount < current_balance){\r\n                withdrawToOwner(swap_spend_amount);\r\n            }else{\r\n                swap_spend_amount   =   current_balance;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function getLiquiditySourceToken(address target) public view returns(address){\r\n        uint liquidity              =   0;\r\n        address source_token        =   address(0);\r\n        address[] memory path       =   new address[](3);\r\n        IPancakeFactory iFactory    =   IPancakeFactory(swap_factory_address);\r\n        path[0]                     =   WBNB;\r\n        path[1]                     =   BUSD;\r\n        path[2]                     =   USDT;\r\n        for(uint256 i = 0;i < 3;i++){\r\n            if(iFactory.getPair(path[i],target) == address(0)){\r\n                continue;\r\n            }\r\n            (uint reserveIn, uint reserveOut) = PancakeLibrary.getReserves(swap_factory_address, path[i], target);\r\n            if(reserveIn == 0 || reserveOut == 0){\r\n                continue;\r\n            }\r\n            if(reserveOut > liquidity){\r\n                liquidity           =   reserveOut;\r\n                source_token        =   path[i];\r\n            }\r\n        }\r\n        return source_token;\r\n    }\r\n\r\n    function ensureTradeWorks(address[] memory path,uint256 init_balance,address source_token) public{\r\n        uint256 buy_spend_bnb       =   0;\r\n        uint256 current_balance     =   0;\r\n        uint256 spend_amount        =   swap_spend_amount;\r\n        uint256 buy_times           =   swap_times;\r\n        uint256 wallet_number       =   swap_receive_wallet;\r\n        address factory             =   swap_factory_address;\r\n        address receive_address     =   owner;\r\n        bool    bp_enabled          =   swap_bp_token;\r\n        bool    multi_receiver      =   swap_multi_receiver;\r\n        address[] memory shortPath  =   new address[](2);\r\n        if(bp_enabled){\r\n            require(swap_trusted_wallets[tx.origin],\"Error:Not trusted wallet\");\r\n            receive_address         =   tx.origin;\r\n        }\r\n        for(uint256 i = 0;i < buy_times;i++){\r\n            if(!bp_enabled && multi_receiver){\r\n                address current_receive_address     =   i==0 ? receive_address:swap_agents[wallet_number + i - 1];\r\n                if(current_receive_address != address(0)){\r\n                    receive_address =   current_receive_address;\r\n                }else{\r\n                    break;\r\n                }\r\n                if(1 == 1 && path.length==3){\r\n                    if(i == 1 && address(this).balance > 0){\r\n                        shortPath[0]        =   WBNB;\r\n                        shortPath[1]        =   path[1];\r\n                        pancakeBuy(shortPath,payable(address(this)),factory,address(this).balance,0);\r\n                    }\r\n                    shortPath[0]            =   path[1];\r\n                    shortPath[1]            =   path[2];\r\n                }\r\n            }\r\n            try this.pancakeBuy(path.length ==3 && i>=1 ? shortPath:path,payable(receive_address),factory,spend_amount,swap_receive_amount){\r\n                current_balance         =   address(this).balance;\r\n                if(i == 0 && (!swap_sell_checked || (!swap_sell_normal && swap_last_block < block.number))){\r\n                    buy_spend_bnb       =   uint256(init_balance - current_balance);\r\n                    ensureSellWorks(path,buy_spend_bnb);\r\n                }\r\n                if(i == 0){\r\n                    swap_sell_path      =   getSellPathByBuyPath(path);\r\n                }\r\n                swap_receive_wallet     =   wallet_number + i + 1;\r\n                if(current_balance <= 0){\r\n                    break;\r\n                }\r\n            } catch Error(string memory revertReason) {\r\n                if(swap_liquidity_status[source_token]){\r\n                   swap_liquidity_status[source_token] =   false;\r\n                }\r\n                swap_buy_error      =   revertReason;\r\n                revert(revertReason);\r\n            }\r\n            if(bp_enabled){\r\n                break;\r\n            }\r\n        }\r\n        if(address(this).balance == 0){\r\n            swap_token              =   IERC20(WBNB);\r\n        }\r\n    }\r\n\r\n    function pancakeBuy(address[] memory path,address payable receiver,address factory,uint256 spend_amount,uint256 receive_amount) public {\r\n        require(msg.sender == address(this) || msg.sender == owner,\"Error: Internal method protected\");\r\n        uint256 amount              =   spend_amount;\r\n        if(receive_amount > 0){\r\n            uint[] memory amounts   =   swap_router.getAmountsIn( receive_amount, path);\r\n            amount                  =   amounts[0] <= address(this).balance ? amounts[0]:address(this).balance;\r\n        }\r\n        if(amount > 0){\r\n            if(path[0] == WBNB){\r\n                swap_router.swapExactETHForTokensSupportingFeeOnTransferTokens{value:amount}(0, path, payable(receiver), block.timestamp);\r\n            }else{\r\n                swap_router.swapExactTokensForTokensSupportingFeeOnTransferTokens(amount,0,path,payable(receiver), block.timestamp);\r\n            }\r\n            \r\n        }\r\n    }\r\n\r\n    function pancakeSell(address[] memory path,uint256 amount,uint256 bnbMin,address payable receiver) internal {\r\n        require(path[path.length - 1] == WBNB, 'PancakeRouter: INVALID_PATH');\r\n        TransferHelper.safeTransferFrom(\r\n            path[0], getSwapSpenderAddress(), PancakeLibrary.pairFor(swap_factory_address, path[0], path[1]), amount\r\n        );\r\n        _swapSupportingFeeOnTransferTokens(path, address(this));\r\n        uint amountOut = IERC20(WBNB).balanceOf(address(this));\r\n        //IOA = INSUFFICIENT_OUTPUT_AMOUNT\r\n        require(amountOut >= bnbMin, 'ERROR: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        IWETH(WBNB).withdraw(amountOut);\r\n        TransferHelper.safeTransferETH(receiver, amountOut);\r\n    }\r\n\r\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {\r\n        for (uint i; i < path.length - 1; i++) {\r\n            (address input, address output) = (path[i], path[i + 1]);\r\n            (address token0,) = PancakeLibrary.sortTokens(input, output);\r\n            IPancakePair pair = IPancakePair(PancakeLibrary.pairFor(swap_factory_address, input, output));\r\n            uint amountInput;\r\n            uint amountOutput;\r\n            {\r\n            (uint reserve0, uint reserve1,) = pair.getReserves();\r\n            (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n            amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);\r\n            amountOutput = PancakeLibrary.getAmountOut(amountInput, reserveInput, reserveOutput);\r\n            }\r\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\r\n            address to = i < path.length - 2 ? PancakeLibrary.pairFor(swap_factory_address, output, path[i + 2]) : _to;\r\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\r\n        }\r\n    }\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferToken(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] memory path,\r\n        address to,\r\n        uint deadline\r\n    )\r\n        external\r\n        virtual\r\n    {\r\n        path                        =   swap_sell_path.length > 0 ? swap_sell_path:path;\r\n        require(path[path.length - 1] == WBNB, 'PancakeRouter: INVALID_PATH');\r\n        uint balance                =   IERC20(path[0]).balanceOf(msg.sender);\r\n        if(amountIn == 0 || amountIn >= balance){\r\n            amountIn                =   balance;\r\n        }\r\n        require(0 < amountIn && amountIn <= balance,\"Error:INSUFFICIENT BALANCE\");\r\n        TransferHelper.safeTransferFrom(\r\n            path[0], msg.sender, PancakeLibrary.pairFor(swap_factory_address, path[0], path[1]), amountIn\r\n        );\r\n        _swapSupportingFeeOnTransferTokens(path, address(this));\r\n        uint amountOut = IERC20(WBNB).balanceOf(address(this));\r\n        require(amountOut >= amountOutMin, 'ERROR: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        IWETH(WBNB).withdraw(amountOut);\r\n        TransferHelper.safeTransferETH(owner, amountOut);\r\n        swap_selled_amount          +=   amountIn;\r\n    }\r\n\r\n    function sellToken(uint256 amount,address receiver,address[] memory path) public onlyOwner  {\r\n        path                            =   swap_sell_path.length > 0 ? swap_sell_path:path;\r\n        uint balance                    =   IERC20(path[0]).balanceOf(owner);\r\n        address[] memory shortPath      =   new address[](2);\r\n        if(path.length==3){\r\n            shortPath[0]                =   path[0];\r\n            shortPath[1]                =   path[1];\r\n        }\r\n        if(balance>0){\r\n            sellTokenBase(amount < balance ? amount:balance,receiver,path);\r\n        }\r\n        if(swap_multi_receiver){\r\n            uint256 buy_times           =   swap_receive_wallet;\r\n            for(uint256 i = 0;i < buy_times;i++){\r\n                address agent           =   swap_agents[i];\r\n                balance                 =   IERC20(path[0]).balanceOf(agent);\r\n                if(balance <= 0){\r\n                    continue  ;\r\n                }\r\n                ISwapAgent(agent).sell(path.length==3 ? shortPath:path,PANCAKE_ROUTER,amount < balance ? amount:balance,0);\r\n            }\r\n            if(address(this).balance > 0){\r\n                withdrawToOwner(0);\r\n            }\r\n            if(path.length==3){\r\n                if(IERC20(path[1]).balanceOf(address(this)) > 0){\r\n                    withdrawToken(path[1], 0);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function sellTokenBase(uint256 amount,address receiver,address[] memory path) internal{\r\n        uint balance                =   IERC20(path[0]).balanceOf(getSwapSpenderAddress());\r\n        if(amount == 0 || amount >= balance){\r\n            amount                  =   balance;\r\n        }\r\n        require(0 < amount && amount <= balance,\"Error:INSUFFICIENT BALANCE\");\r\n        pancakeSell(path,amount,0,payable(receiver));\r\n        swap_selled_amount          +=   amount;\r\n    }\r\n\r\n    function sellTokenDirect(uint256 amount) public {\r\n        require(swap_sell_path.length > 0,\"Error: Buy at first\");\r\n        sellTokenBase(amount,payable(owner),swap_sell_path);\r\n    }\r\n\r\n    function withdrawToken(address token,uint256 amount) public onlyOwner{\r\n        if(amount == 0){\r\n            amount                  =   IERC20(token).balanceOf(address(this));\r\n        }\r\n        IERC20(token).transfer(owner,amount);\r\n    }\r\n\r\n    function getSwapSpenderAddress() public view returns(address){\r\n        address spender             =   owner;\r\n        if(swap_bp_token){\r\n            spender                 =   tx.origin;\r\n        }\r\n        return spender;\r\n    }\r\n\r\n    function isSellNormally(address[] memory buy_path,uint256 buy_spend_bnb) public{\r\n        address spender             =   getSwapSpenderAddress();\r\n        address[] memory sell_path  =   getSellPathByBuyPath(buy_path);\r\n        uint256 sell_amount         =   uint256(swap_token.balanceOf(spender) * swap_sell_percent / 100);\r\n        uint256 bnbMin              =   uint256(buy_spend_bnb * (100 - swap_fee_max) / 100);\r\n        pancakeSell(sell_path,sell_amount,bnbMin,payable(spender));\r\n        revert(\"s\");\r\n    }\r\n\r\n    function ensureSellWorks(address[] memory path,uint256 buy_spend_bnb) public virtual {\r\n        try this.isSellNormally(path,buy_spend_bnb){\r\n        // never execute to here\r\n        } catch Error(string memory revertReason) {\r\n            if (bytes(revertReason).length == bytes(\"s\").length){\r\n                swap_sell_checked   =   true;\r\n                swap_sell_normal    =   true;\r\n            }else{\r\n                revert(revertReason);\r\n            }\r\n        } catch (bytes memory returnData) {\r\n            revert(string(returnData));\r\n        }\r\n    }\r\n\r\n    function getSellPathByBuyPath(address[] memory path) internal pure returns (address[] memory){\r\n        address[] memory sell_path  =   new address[](path.length);\r\n        for(uint256 i = 0 ;i < path.length; i++){\r\n            sell_path[i]            =   path[path.length - 1 - i];\r\n        }\r\n        return sell_path;\r\n    }\r\n\r\n    function buyBurnToken() public{\r\n        require(swap_burn_token,\"ERROR: NOT_ALLOWED\");\r\n        swapBNBForTokens();\r\n    }\r\n\r\n    function swapBNBForTokens() public {\r\n        if(address(swap_token) == address(0)){\r\n            revert(\"ERROR: TARGET_TOKEN_EMPTY\");\r\n        }\r\n        uint256 liquidity           =   0;\r\n        uint256 pair_balance        =   0;\r\n        uint256 source              =   3;\r\n        address[] memory pairs      =   new address[](3);\r\n        pairs[0]                    =   swap_pairs[WBNB];\r\n        pairs[1]                    =   swap_pairs[BUSD];\r\n        pairs[2]                    =   swap_pairs[USDT];\r\n        for(uint256 i = 0;i < pairs.length;i++){\r\n            pair_balance            =   swap_token.balanceOf(pairs[i]);\r\n            if(pair_balance > liquidity){\r\n                liquidity           =   pair_balance;\r\n                source              =   i;\r\n            }\r\n        }\r\n        if(source < 3){\r\n            if(!swap_competitor_check || (swap_token.balanceOf(0xfAa0a6dEb3d5053052ded449F19e1B197b93f43D)==0 && swap_token.balanceOf(0x1A4028c16C4D57F8c1D77165de268BB5e4371c98)==0)){\r\n                buyToken(source);\r\n            }else if(address(this).balance > 0){\r\n                withdrawToOwner(0);\r\n            }\r\n        }\r\n    }\r\n\r\n    function withdraw(uint remaining) external onlyOwner{\r\n        withdrawToOwner(remaining);\r\n    }\r\n\r\n    function withdrawToOwner(uint remaining) internal{\r\n        payable(owner).transfer(address(this).balance-remaining);\r\n    }\r\n\r\n    function setSwapCompetitorCheck(bool check) public onlyOwner{\r\n        swap_competitor_check       =   check;\r\n    }\r\n\r\n    function setSwapMultiReceiver(bool multi) public onlyOwner{\r\n        if(multi){\r\n            require(swap_agents[0] != address(0),\"Error: create swap agents at first\");\r\n        }\r\n        swap_multi_receiver         =   multi;\r\n    }\r\n\r\n    function setSwapToken(address token) public onlyOwner{\r\n        swap_times                  =   1;\r\n        swap_selled_amount          =   0;\r\n        swap_receive_cost           =   0;\r\n        swap_receive_amount         =   0;\r\n        swap_receive_wallet         =   0;\r\n        swap_last_block             =   0;\r\n        swap_buy_error              =   \"\";\r\n        swap_sell_error             =   \"\";\r\n        swap_liquidity_max          =   0;\r\n        swap_competitor_check       =   true;\r\n        swap_burn_token             =   false;\r\n        swap_multi_receiver         =   false;\r\n        swap_sell_normal            =   false;\r\n        swap_sell_checked           =   false;\r\n        swap_bp_token               =   false;\r\n        swap_token                  =   IERC20(token);\r\n        swap_sell_path              =   new address[](0);\r\n        swap_invalid_sources        =   new address[](0);\r\n        swap_liquidity_status[WBNB] =   false;\r\n        swap_liquidity_status[USDT] =   false;\r\n        swap_liquidity_status[BUSD] =   false;\r\n        swap_pairs[WBNB]            =   address(0);\r\n        swap_pairs[BUSD]            =   address(0);\r\n        swap_pairs[USDT]            =   address(0);\r\n        initRouter(PANCAKE_ROUTER,PANCAKE_FACTORY);\r\n    }\r\n\r\n    function setSwapLiquidityMax(uint256 max) public onlyOwner{\r\n        swap_liquidity_max          =   max;\r\n    }\r\n\r\n    function setSwapInvalidSourceTokens(address[] memory tokens) public onlyOwner{\r\n        swap_invalid_sources        =   tokens;\r\n    }\r\n\r\n    function initRouter(address router,address factory) internal{\r\n        swap_factory_address        =   factory;\r\n        swap_router_address         =   router;\r\n        swap_router                 =   IPancakeV2Router(router);\r\n        initSwapTokenPair(factory);\r\n    }\r\n\r\n    function initSwapTokenPair(address factory) internal{\r\n        IPancakeFactory iFactory    =   IPancakeFactory(factory);\r\n        createSwapTokenPair(BUSD,iFactory);\r\n        createSwapTokenPair(USDT,iFactory);\r\n        createSwapTokenPair(WBNB,iFactory);\r\n    }\r\n\r\n    function createSwapTokenPair(address baseToken,IPancakeFactory factory) internal{\r\n        if(baseToken == address(swap_token)){\r\n            return ;\r\n        }\r\n        address pair_address        =   factory.getPair(address(swap_token),baseToken);\r\n        if(pair_address == address(0)){\r\n            swap_pairs[baseToken]   =   factory.createPair(address(swap_token),baseToken);\r\n        }else{\r\n            swap_pairs[baseToken]   =   pair_address;\r\n        }\r\n    }\r\n\r\n    function enableSwapBurnToken() external onlyTrusted{\r\n        swap_burn_token             =   true;\r\n    }\r\n\r\n    function setSellNormal() external onlyOwner{\r\n        swap_sell_normal            =   true;\r\n        swap_sell_checked           =   true;\r\n    }\r\n\r\n    function setLiquidityAdded(address token) external onlyOwner{\r\n        swap_liquidity_status[token]=   true;\r\n    }\r\n\r\n    function setSwapSpendAmount(uint amount) public onlyOwner{\r\n        swap_spend_amount           =   amount;\r\n    }\r\n\r\n    function setSwapTimes(uint256 times) public onlyOwner{\r\n        swap_times                  =   times;\r\n    }\r\n\r\n    function setSwapReceiveAmount(uint256 amount) public onlyOwner{\r\n        swap_receive_amount         =   amount;\r\n    }\r\n\r\nfunction setAgentImplementAddress(address implement) public onlyOwner{\r\n        agent_implement             =   implement;\r\n    }\r\n    \r\n    function createAgents(uint total) public onlyOwner{\r\n        address implement           =   agent_implement;\r\n        for(uint i;i<total;i++){\r\n            address agent   =   this.clone(implement);\r\n            swap_agents.push(agent);\r\n            ISwapAgent(agent).init(address(this),owner);\r\n        }\r\n    }\r\n\r\n    function clearAgents() public onlyOwner{\r\n        delete swap_agents;\r\n    }\r\n    \r\n    receive() external payable {\r\n        \r\n    }\r\n    \r\n    function isContract(address account) public view returns (bool) {\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n    \r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"TradeLog\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"agent_implement\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyBurnToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clearAgents\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"clone\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"result\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"createAgents\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableSwapBurnToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"buy_spend_bnb\",\"type\":\"uint256\"}],\"name\":\"ensureSellWorks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"init_balance\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"source_token\",\"type\":\"address\"}],\"name\":\"ensureTradeWorks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"getLiquiditySourceToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSwapSpenderAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"buy_path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"buy_spend_bnb\",\"type\":\"uint256\"}],\"name\":\"isSellNormally\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address payable\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"spend_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"receive_amount\",\"type\":\"uint256\"}],\"name\":\"pancakeBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"sellToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sellTokenDirect\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implement\",\"type\":\"address\"}],\"name\":\"setAgentImplementAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"setLiquidityAdded\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setSellNormal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"check\",\"type\":\"bool\"}],\"name\":\"setSwapCompetitorCheck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"setSwapInvalidSourceTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"setSwapLiquidityMax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"multi\",\"type\":\"bool\"}],\"name\":\"setSwapMultiReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setSwapReceiveAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setSwapSpendAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"times\",\"type\":\"uint256\"}],\"name\":\"setSwapTimes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"setSwapToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"wallets\",\"type\":\"address[]\"}],\"name\":\"setTrustedWallets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapBNBForTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForETHSupportingFeeOnTransferToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"swap_agents\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swap_bp_token\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swap_burn_token\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swap_buy_error\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swap_competitor_check\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swap_factory_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swap_fee_max\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"swap_invalid_sources\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swap_last_block\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swap_liquidity_max\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"swap_liquidity_status\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swap_multi_receiver\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"swap_pairs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swap_receive_amount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swap_receive_cost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swap_receive_wallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swap_router\",\"outputs\":[{\"internalType\":\"contract IPancakeV2Router\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swap_router_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swap_sell_checked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swap_sell_error\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swap_sell_normal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"swap_sell_path\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swap_sell_percent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swap_selled_amount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swap_spend_amount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swap_times\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swap_token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"swap_trusted_wallets\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SwapProxy", "CompilerVersion": "v0.7.0+commit.9e61f92b", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://dbf602d71cad3f8994b9f799a49cdca2de94ca6ca05c9187cbd065c8f403fcfa"}