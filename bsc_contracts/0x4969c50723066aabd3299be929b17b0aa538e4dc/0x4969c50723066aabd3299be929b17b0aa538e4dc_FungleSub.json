{"SourceCode": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity >=0.7.0 <0.9.0;\r\n\r\n/** \r\n * @title FungleSub\r\n * @dev Implements Fungle subscription system\r\n */\r\ncontract FungleSub {\r\n\r\n    struct Sponsor {\r\n        bool isActive;\r\n        uint8 totalSponsored;\r\n        uint8 totalSubs; \r\n        uint8 earnRate; \r\n        uint8 permanentRewards; \r\n        uint currentBalance; \r\n        uint totalBalance;   \r\n    }\r\n\r\n    uint8 private default_earnRate;\r\n    uint8 private default_permanentEarnRate;\r\n    address public owner;\r\n    address public fungle;\r\n\r\n    //customer address => sponsor address\r\n    mapping(address => address) private sponsoredUser;\r\n    mapping(address => Sponsor) private sponsors;\r\n    \r\n    constructor(address fungleAddress) {\r\n        owner = msg.sender;\r\n        fungle = fungleAddress;\r\n        default_earnRate = 20;\r\n        default_permanentEarnRate = 10; \r\n    }\r\n\r\n    //*****************MODIFIER**************************//\r\n\r\n    // modifier to check if caller is owner \r\n    modifier isOwner() {\r\n        require(msg.sender == owner, \"not allowed\");\r\n        _;\r\n    }\r\n\r\n    //***********************OWNER FUNCTIONS****************//\r\n    /**\r\n     * @dev Change owner\r\n     * @param newOwner address of new owner\r\n     */\r\n    function changeOwner(address newOwner) public isOwner {\r\n        owner = newOwner;\r\n    }\r\n    /**\r\n     * @dev Change fungle account\r\n     * @param newAccount address of the new fungle account\r\n     */\r\n    function changeFungleAccount(address newAccount) public isOwner {\r\n        fungle = newAccount;\r\n    }\r\n\r\n\r\n    function updateRewards(address[] calldata spa,uint8 newRewards) public isOwner{\r\n        require(newRewards >= 0 && newRewards <= 100, \"rewards have to be between 0 and 100\");\r\n        for (uint i=0; i<spa.length; i++) {\r\n            sponsors[spa[i]].earnRate = newRewards;\r\n        }\r\n        \r\n    }\r\n    function updatePermanentRewards(address[] calldata spa, uint8 newRewards) public isOwner{\r\n        for (uint i=0; i<spa.length; i++) {\r\n            sponsors[spa[i]].permanentRewards = newRewards;\r\n        }\r\n    }\r\n    function updateDefaultRewards(uint8 newRewards) public isOwner{\r\n        require(newRewards >= 0 && newRewards <= 100, \"rewards have to be between 0 and 100\");\r\n        default_earnRate = newRewards;\r\n    }\r\n\r\n    function updateDefaultPermanentRewards(uint8 newRewards) public isOwner{\r\n        require(newRewards >= 0 && newRewards <= 100, \"rewards have to be between 0 and 100\");\r\n        default_permanentEarnRate = newRewards;\r\n    }\r\n\r\n    function transferEther(address to, uint amount) public payable isOwner{\r\n        payable(to).transfer(amount);\r\n    }\r\n    \r\n\r\n    //***********************READ FUNCTIONS****************//\r\n\r\n    function sponsor_info(address spa) public view returns (uint,uint, uint, uint, uint8, uint8){\r\n        return (sponsors[spa].earnRate,\r\n                sponsors[spa].permanentRewards,\r\n                sponsors[spa].currentBalance,\r\n                sponsors[spa].totalBalance,\r\n                sponsors[spa].totalSponsored,\r\n                sponsors[spa].totalSubs);\r\n    }\r\n\r\n    //***********************WRITE FUNCTIONS****************//\r\n\r\n    /**\r\n    * Allow a person to become a Sponsor\r\n    */\r\n    function becomeSponsor() public {\r\n        require(sponsors[msg.sender].earnRate == 0, \"This Sponsor already exist\");\r\n        sponsors[msg.sender].isActive = true;\r\n        sponsors[msg.sender].earnRate = default_earnRate;\r\n        sponsors[msg.sender].permanentRewards = default_permanentEarnRate;\r\n    }\r\n\r\n    /**\r\n    * @dev A customer can subscribe to fungle services. If sponsor address is valid, the sponsor receive his earnRate\r\n    * @param spa, => sponsor address\r\n    */\r\n    function subscribe(address spa) public payable{\r\n        uint _amount = msg.value;\r\n        uint8 sponsorEarnRate = 0;\r\n        if(spa != msg.sender && sponsors[spa].isActive && (sponsoredUser[msg.sender] == address(0) || sponsoredUser[msg.sender]==spa)){\r\n            if(sponsoredUser[msg.sender] == address(0)){\r\n                sponsorEarnRate = sponsors[spa].earnRate;\r\n                sponsoredUser[msg.sender] = spa;\r\n                sponsors[spa].totalSponsored += 1;\r\n            }else{\r\n                sponsorEarnRate = sponsors[spa].permanentRewards;\r\n            }\r\n            if(sponsorEarnRate > 0){\r\n                payable(fungle).transfer(_amount-(sponsorEarnRate*_amount/100));\r\n                sponsors[spa].currentBalance += sponsorEarnRate*_amount/100;\r\n                sponsors[spa].totalBalance += sponsorEarnRate*_amount/100;\r\n                sponsors[spa].totalSubs += 1;\r\n            }else{\r\n                payable(fungle).transfer(_amount);\r\n            }\r\n        }else{\r\n            payable(fungle).transfer(_amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev A customer can subscribe to fungle services. use this function if the customer is not sponsored. \r\n    */\r\n    function subscribe() public payable{\r\n        uint _amount = msg.value;\r\n        payable(fungle).transfer(_amount);\r\n    }\r\n\r\n    /**\r\n    * @dev A sponsor can claim his current balance.\r\n    */\r\n    function claim() public payable{\r\n        payable(msg.sender).transfer(sponsors[msg.sender].currentBalance);\r\n        sponsors[msg.sender].currentBalance = 0;\r\n    }    \r\n    \r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fungleAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"becomeSponsor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAccount\",\"type\":\"address\"}],\"name\":\"changeFungleAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fungle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spa\",\"type\":\"address\"}],\"name\":\"sponsor_info\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spa\",\"type\":\"address\"}],\"name\":\"subscribe\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"subscribe\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferEther\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"newRewards\",\"type\":\"uint8\"}],\"name\":\"updateDefaultPermanentRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"newRewards\",\"type\":\"uint8\"}],\"name\":\"updateDefaultRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"spa\",\"type\":\"address[]\"},{\"internalType\":\"uint8\",\"name\":\"newRewards\",\"type\":\"uint8\"}],\"name\":\"updatePermanentRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"spa\",\"type\":\"address[]\"},{\"internalType\":\"uint8\",\"name\":\"newRewards\",\"type\":\"uint8\"}],\"name\":\"updateRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "FungleSub", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000ed5235920195c712d9c1577f1d2c58971076bd09", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6b82484938673ff29332fa778b5efdaff5881711e3f6952e98e759a88316451b"}