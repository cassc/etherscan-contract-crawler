{"SourceCode": "/*\r\n\r\n  /$$$$$$  /$$      /$$  /$$$$$$  /$$$$$$$  /$$$$$$$$       /$$$$$$$  /$$$$$$$   /$$$$$$  /$$$$$$$$ /$$$$$$ /$$$$$$$$\r\n /$$__  $$| $$$    /$$$ /$$__  $$| $$__  $$|__  $$__/      | $$__  $$| $$__  $$ /$$__  $$| $$_____/|_  $$_/|__  $$__/\r\n| $$  \\__/| $$$$  /$$$$| $$  \\ $$| $$  \\ $$   | $$         | $$  \\ $$| $$  \\ $$| $$  \\ $$| $$        | $$     | $$\r\n|  $$$$$$ | $$ $$/$$ $$| $$$$$$$$| $$$$$$$/   | $$         | $$$$$$$/| $$$$$$$/| $$  | $$| $$$$$     | $$     | $$\r\n \\____  $$| $$  $$$| $$| $$__  $$| $$__  $$   | $$         | $$____/ | $$__  $$| $$  | $$| $$__/     | $$     | $$\r\n /$$  \\ $$| $$\\  $ | $$| $$  | $$| $$  \\ $$   | $$         | $$      | $$  \\ $$| $$  | $$| $$        | $$     | $$\r\n|  $$$$$$/| $$ \\/  | $$| $$  | $$| $$  | $$   | $$         | $$      | $$  | $$|  $$$$$$/| $$       /$$$$$$   | $$\r\n \\______/ |__/     |__/|__/  |__/|__/  |__/   |__/         |__/      |__/  |__/ \\______/ |__/      |______/   |__/\r\n\r\nWebsite:     https://smart-profit.info/\r\n\r\n */\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.6.12;\r\n\r\ninterface AggregatorV3Interface {\r\n\r\n  function decimals()\r\n    external\r\n    view\r\n    returns (\r\n      uint8\r\n    );\r\n\r\n  function description()\r\n    external\r\n    view\r\n    returns (\r\n      string memory\r\n    );\r\n\r\n  function version()\r\n    external\r\n    view\r\n    returns (\r\n      uint256\r\n    );\r\n\r\n\r\n  function getRoundData(\r\n    uint80 _roundId\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n\r\n  function latestRoundData()\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n  /**\r\n   * @dev Returns the addition of two unsigned integers, reverting on\r\n   * overflow.\r\n   */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, \"SafeMath: addition overflow\");\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a, \"SafeMath: subtraction overflow\");\r\n    uint256 c = a - b;\r\n    return c;\r\n  }\r\n\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    require(c / a == b, \"SafeMath: multiplication overflow\");\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0, \"SafeMath: division by zero\");\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\ncontract SmartProfit {\r\n    using SafeMath for uint256;\r\n\r\n    struct User {\r\n        address payable wallet;\r\n        uint256 row;\r\n        uint256 col;\r\n        uint256 refId;\r\n        uint256 refCount;\r\n        uint256 upgradedRefs;\r\n        uint256 refBonus;\r\n        uint256 earned;\r\n        uint256 last_row;\r\n        uint8 status;\r\n        bool isForSale;\r\n        uint256 expire;\r\n    }\r\n\r\n    mapping (uint256 => User) public users;\r\n    mapping (address => uint256) public userId;\r\n    mapping (uint256 => mapping (uint256 => uint256)) globalPlaces;\r\n    mapping (uint256 => uint256) public lastFreePlaceInRow;\r\n\r\n    AggregatorV3Interface internal priceFeed;\r\n\r\n    uint256[7] private percentage = [11,10,9,8,9,8,10];\r\n\r\n    uint256[3] private prices = [30,90,180];\r\n\r\n    uint256[3] private terms = [60,180,360];\r\n\r\n    uint8[3] private levels = [3,5,7];\r\n\r\n    uint256 public lotteryPool;\r\n\r\n    uint256 public maxBonusAmount;\r\n\r\n    uint256 public gasPrice = 5 * 10 ** 9;\r\n\r\n    uint256 public lastUserId = 1;\r\n\r\n    uint256 public lastPaymentId;\r\n\r\n    uint256 public inactivityPeriod = 7 * 24 * 60 * 60;\r\n\r\n    address payable _owner;\r\n\r\n    uint8 public constant MAX_ROW = 93;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Register(address indexed _wallet, uint256 _userId, uint256 _row, uint256 _col, uint256 _refId, uint8 _status, uint256 _date);\r\n    event RefBonusSent(uint256 _paymentId, uint256 _userId, uint256 _refId, uint256 _amount, uint256 _date);\r\n    event Upgrade(uint256 _userId, uint8 _status, uint8 _plan, uint256 _date);\r\n    event PaymentToUpline(uint256 _paymentId, uint256 _userId, uint256 _refId, uint8 _level, uint256 _amount, uint256 _date);\r\n    event Transfer(uint256 _userId, uint256 amount);\r\n    event StatusUPdate(uint256 _userId, uint8 status);\r\n    event PlaceSold(uint256 _userId, uint8 _status, uint8 _plan, uint256 _date);\r\n\r\n\r\n    constructor (address payable first) public {\r\n        require(first != address(0), 'Zero addresses are prohibited in parameters');\r\n\r\n        //mainnet\r\n        priceFeed = AggregatorV3Interface(0x0567F2323251f0Aab15c8dFb1967E4e8A7D42aeE);\r\n\r\n\r\n        User memory user = User({\r\n                                    wallet: first,\r\n                                    row: 1,\r\n                                    col: 1,\r\n                                    refId: 1,\r\n                                    refCount: 0,\r\n                                    upgradedRefs: 0,\r\n                                    refBonus: 0,\r\n                                    earned: 0,\r\n                                    last_row: 2,\r\n                                    status: 2,\r\n                                    isForSale: false,\r\n                                    expire: 0\r\n                                });\r\n\r\n\r\n        users[1] = user;\r\n        userId[first] = 1;\r\n        globalPlaces[1][1] = 1;\r\n        lastFreePlaceInRow[1] = 2;\r\n        emit Register(first, lastUserId, 1, 1, 1, 0, block.timestamp);\r\n        _owner = first;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n\r\n    }\r\n\r\n\r\n    function getLatestPrice() public view returns (int) {\r\n\r\n        (\r\n            uint80 roundID,\r\n            int price,\r\n            uint startedAt,\r\n            uint timeStamp,\r\n            uint80 answeredInRound\r\n        ) = priceFeed.latestRoundData();\r\n        return price;\r\n\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address payable newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        users[1].wallet = newOwner;\r\n        userId[newOwner] = 1;\r\n        userId[_owner] = 0;\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n\r\n\r\n    function setPrices(uint256[3] memory newPrices) public onlyOwner {\r\n        for (uint256 i = 0; i < newPrices.length; i++) {\r\n          require(newPrices[i] > 0, \"Price must not be zero\");\r\n        }\r\n        prices = newPrices;\r\n    }\r\n\r\n\r\n    function setInactivityPeriod(uint256 _period) public onlyOwner {\r\n        inactivityPeriod = _period;\r\n    }\r\n\r\n    function setPriceFeed(address _feed) public onlyOwner {\r\n        require(_feed != address(0), \"Invalid price feed contract address\");\r\n        priceFeed = AggregatorV3Interface(_feed);\r\n    }\r\n\r\n\r\n    function setTerms(uint256[3] memory newTerms) public onlyOwner {\r\n        for (uint256 i = 0; i < newTerms.length; i++) {\r\n          require(newTerms[i] > 0, \"Term must not be zero\");\r\n        }\r\n        terms = newTerms;\r\n    }\r\n\r\n\r\n    function getTerms() public view returns (uint256[3] memory) {\r\n        uint256[3] memory result = terms;\r\n        return result;\r\n    }\r\n\r\n    function getPrices() public view returns (uint256[3] memory) {\r\n        uint256[3] memory result = prices;\r\n        return result;\r\n    }\r\n\r\n\r\n\r\n    function setGasPrice(uint256 _gp) public onlyOwner {\r\n        require(_gp > 0, \"Gas price must exceed zero\");\r\n        gasPrice = _gp;\r\n    }\r\n\r\n\r\n    function retriveBNB(address payable to, uint256 amount) external onlyOwner {\r\n        require(to != address(0), \"Zero address prohibited\");\r\n        uint256 contractBalance = address(this).balance;\r\n        require(amount <= contractBalance, \"Insufficient contract BNB balance\");\r\n        require(contractBalance.sub(amount) >= lotteryPool, \"Remaining contract balance is lower than lottery pool.\");\r\n        to.transfer(amount);\r\n    }\r\n\r\n\r\n    function setMaxBonusAmount(uint256 _amount) public onlyOwner {\r\n        require(_amount > 0, \"Lottery amount must exceed zero\");\r\n        maxBonusAmount = _amount;\r\n    }\r\n\r\n\r\n    function sendToWinners(uint256[] memory winners) public onlyOwner {\r\n        require(winners.length > 0, \"No wallets to send to.\");\r\n        require(lotteryPool >= maxBonusAmount, \"Lottery pool is less than required.\");\r\n        uint256 amount = lotteryPool.sub(uint256(21000).mul(winners.length).mul(gasPrice)).div(winners.length);\r\n        for (uint256 i = 0; i < winners.length; i++) {\r\n          users[winners[i]].wallet.transfer(amount);\r\n          users[winners[i]].earned = users[winners[i]].earned.add(amount);\r\n        }\r\n        lotteryPool = 0;\r\n    }\r\n\r\n\r\n    function approveSale(uint256 _id) external {\r\n        require(users[_id].refId == userId[msg.sender], \"Only sponsors are allowed to sell places.\");\r\n        require(!users[_id].isForSale, \"Place is already available for sale.\");\r\n        require(isExpired(_id, true), \"Place has not expired yet.\");\r\n        users[_id].isForSale = true;\r\n    }\r\n\r\n\r\n    function findFreePlace(uint256 _refId) internal view returns(uint256, uint256, uint256) {\r\n        uint256 start;\r\n        uint256 end;\r\n        for (uint256 i = users[_refId].last_row; i<=MAX_ROW; i++) {\r\n            start = users[_refId].col.sub(1).mul(5**(i.sub(users[_refId].row)));\r\n            end = start.add(5**(i.sub(users[_refId].row)));\r\n            start = start.add(1);\r\n            if (lastFreePlaceInRow[i] > end) {\r\n                continue;\r\n            }\r\n\r\n            if (lastFreePlaceInRow[i] > start && lastFreePlaceInRow[i] < end) {\r\n                start = lastFreePlaceInRow[i];\r\n            }\r\n\r\n\r\n            for (uint256 j=start; j<=end; j++) {\r\n                if (globalPlaces[i][j] == 0) {\r\n                    if (lastFreePlaceInRow[i] == 0 && start == 1) {\r\n                        return (i,j, 2);\r\n                    } else if (start > lastFreePlaceInRow[i]) {\r\n                        return (i,j, lastFreePlaceInRow[i]);\r\n                    } else {\r\n                        return (i,j, j.add(1));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return (0, 0, 0);\r\n    }\r\n\r\n\r\n    function _update(uint256 _userId) external payable {\r\n        require (msg.sender != address(0), \"Zero address prohibited.\");\r\n        require(lastPaymentId < uint256(-1), \"No more registrations allowed\");\r\n        require(userId[msg.sender] > 0, \"User is not registered\");\r\n        require(users[_userId].wallet != address(0), \"Invalid user ID\");\r\n        uint256 rate = uint256(getLatestPrice());\r\n        require(msg.value >= prices[0].mul(10 ** 26).div(rate), \"Insufficient amount of BNB to participate\");\r\n        (uint8 st, uint256 change) = checkPayment(msg.value, rate);\r\n        if (change > 0) {\r\n          payable(msg.sender).transfer(change);\r\n        }\r\n        users[userId[msg.sender]].expire = block.timestamp.add(terms[st].mul(86400));\r\n        if (st >= users[userId[msg.sender]].status) {\r\n          users[userId[msg.sender]].status = st;\r\n        } else {\r\n          if (users[userId[msg.sender]].refCount == 5) {\r\n            users[userId[msg.sender]].status = 1;\r\n          } else if (users[userId[msg.sender]].upgradedRefs == 5) {\r\n            users[userId[msg.sender]].status = 2;\r\n          }\r\n\r\n        }\r\n        emit Upgrade(_userId, users[userId[msg.sender]].status, st, block.timestamp);\r\n        processUplines(userId[msg.sender], users[_userId].refId, msg.value.sub(change));\r\n\r\n    }\r\n\r\n\r\n    function _buyPlace(uint256 _id) external payable {\r\n        require (msg.sender != address(0), \"Zero address prohibited.\");\r\n        require(userId[msg.sender] == 0, \"User already registered\");\r\n        require(lastPaymentId < uint256(-1), \"No more registrations allowed\");\r\n        require((_id > 0 && _id < uint256(-1)), \"Invalid user ID\");\r\n        require(users[_id].isForSale, \"Place is not for sale\");\r\n        require(users[_id].wallet != address(0), \"Invalid user ID\");\r\n        uint256 rate = uint256(getLatestPrice());\r\n        require(msg.value >= prices[0].mul(10 ** 26).div(rate), \"Insufficient amount of BNB to participate\");\r\n        (uint8 st, uint256 change) = checkPayment(msg.value, rate);\r\n        if (change > 0) {\r\n          payable(msg.sender).transfer(change);\r\n        }\r\n        userId[users[_id].wallet] = 0;\r\n        users[_id].wallet = payable(msg.sender);\r\n        userId[msg.sender] = _id;\r\n        users[_id].expire = block.timestamp.add(terms[st].mul(86400));\r\n        users[_id].isForSale = false;\r\n        if (st >= users[_id].status) {\r\n          users[_id].status = st;\r\n        } else {\r\n          if (users[_id].refCount == 5) {\r\n            users[_id].status = 1;\r\n          } else if (users[_id].upgradedRefs == 5) {\r\n            users[_id].status = 2;\r\n          }\r\n\r\n        }\r\n        emit PlaceSold(_id, users[_id].status, st, block.timestamp);\r\n        processUplines(_id, users[_id].refId, msg.value.sub(change));\r\n\r\n    }\r\n\r\n\r\n    function _support(uint256 _refId, uint256 _id) external payable {\r\n        require (msg.sender != address(0), \"Zero address prohibited.\");\r\n        require(lastPaymentId < uint256(-1), \"No more registrations allowed\");\r\n        require(userId[msg.sender] == 0, \"User already registered\");\r\n        require((_refId > 0 && _refId < uint256(-1)), \"Invalid referral ID\");\r\n        require((_id > 0 && _id < uint256(-1)), \"Invalid upper ID\");\r\n        require(users[_refId].wallet != address(0), \"Invalid referral ID\");\r\n        require(users[_id].wallet != address(0), \"Invalid upper ID\");\r\n        require(lastUserId < uint256(-1), \"No more registrations allowed\");\r\n        require(users[_id].row > users[_refId].row, \"Supported id must be located beneath referal id\");\r\n        uint256 rate = uint256(getLatestPrice());\r\n        require(msg.value >= prices[0].mul(10 ** 26).div(rate), \"Insufficient amount of BNB to participate\");\r\n        (uint8 st, uint256 change) = checkPayment(msg.value, rate);\r\n        if (change > 0) {\r\n          payable(msg.sender).transfer(change);\r\n        }\r\n        (uint256 userRow, uint256 userCol, uint256 newRowLastPlace) = findFreePlace(_id);\r\n        require((userRow != 0 && userCol !=0), \"No free places left in global matrix\");\r\n        lastUserId += 1;\r\n        User memory user = User({\r\n                                    wallet: payable(msg.sender),\r\n                                    row: userRow,\r\n                                    col: userCol,\r\n                                    refId: _refId,\r\n                                    refCount: 0,\r\n                                    upgradedRefs: 0,\r\n                                    refBonus: 0,\r\n                                    earned: 0,\r\n                                    last_row: userRow.add(1),\r\n                                    status: st,\r\n                                    isForSale: false,\r\n                                    expire: block.timestamp.add(terms[st].mul(86400))\r\n                                  });\r\n        users[lastUserId] = user;\r\n        userId[msg.sender] = lastUserId;\r\n        globalPlaces[userRow][userCol] = lastUserId;\r\n        if (users[_id].last_row < userRow) {\r\n            users[_id].last_row = userRow;\r\n        }\r\n        if (newRowLastPlace > lastFreePlaceInRow[userRow]) {\r\n            lastFreePlaceInRow[userRow] = newRowLastPlace;\r\n\r\n        }\r\n        emit Register(msg.sender, lastUserId, userRow, userCol, _refId, st, block.timestamp);\r\n        processUplines(lastUserId, _refId, msg.value.sub(change));\r\n        upgradeReferals(_refId);\r\n    }\r\n\r\n\r\n    function checkPayment(uint256 amount, uint256 rate) internal view returns (uint8 status, uint256 change) {\r\n      if (amount >= prices[2].mul(10 ** 26).div(rate)) {\r\n        return (2, amount.sub(prices[2].mul(10 ** 26).div(rate)));\r\n      } else if (amount >= prices[1].mul(10 ** 26).div(rate)) {\r\n        return (1, amount.sub(prices[1].mul(10 ** 26).div(rate)));\r\n      } else {\r\n        return (0, amount.sub(prices[0].mul(10 ** 26).div(rate)));\r\n      }\r\n\r\n    }\r\n\r\n\r\n    function isExpired(uint256 _id, bool includeInactivityPeriod) internal view returns (bool) {\r\n      if (_id == 1) {\r\n        return false;\r\n      }\r\n      uint256 expireDate = users[_id].expire;\r\n      bool result;\r\n      if (includeInactivityPeriod) {\r\n        result = block.timestamp > expireDate.add(inactivityPeriod);\r\n      } else {\r\n        result = block.timestamp > expireDate;\r\n      }\r\n      return result;\r\n\r\n    }\r\n\r\n\r\n    function upgradeReferals(uint256 _id) internal {\r\n        users[_id].refCount += 1;\r\n        if (users[_id].refCount == 5) {\r\n            if (users[_id].status == 0) {\r\n                users[_id].status = 1;\r\n                emit StatusUPdate(_id, 1);\r\n            }\r\n            uint256 upperId = users[_id].refId;\r\n            users[upperId].upgradedRefs += 1;\r\n            if (users[upperId].upgradedRefs == 5 && users[upperId].status == 1) {\r\n              users[upperId].status = 2;\r\n              emit StatusUPdate(upperId, 2);\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n\r\n    function findUpline(uint256 col) internal pure returns(uint256) {\r\n        return uint256(col.sub(1).div(5).add(1));\r\n    }\r\n\r\n\r\n    function getValues(uint256 _amount) internal view returns(uint256[9] memory) {\r\n        uint256[9] memory result;\r\n        result[0] = _amount.div(10);\r\n        result[1] = _amount.div(4);\r\n        for (uint8 i=2; i<9; i++) {\r\n            result[i] = _amount.mul(percentage[i-2]).div(100);\r\n        }\r\n        return result;\r\n\r\n    }\r\n\r\n\r\n    function checkLevel(uint8 counter_, uint8 status_) internal pure returns (bool) {\r\n        if (status_ == 0 && counter_ <=2) {\r\n            return true;\r\n        } else if (status_ == 1 && counter_ <=4) {\r\n            return true;\r\n        } else if (status_ == 2 && counter_ <=6) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n\r\n    }\r\n\r\n\r\n    function processUplines(uint256 _userId, uint256 _refId, uint256 _amount) internal {\r\n        uint256[9] memory values = getValues(_amount);\r\n        //  10% fo lottery\r\n        lotteryPool = lotteryPool.add(values[0]);\r\n        //25% for referral\r\n        if (!isExpired(_refId, false) || _refId == 1) {\r\n            users[_refId].wallet.transfer(values[1]);\r\n            lastPaymentId += 1;\r\n            users[_refId].refBonus += values[1];\r\n            emit RefBonusSent(lastPaymentId, _userId, _refId, values[1], block.timestamp);\r\n        }\r\n\r\n        uint8 counter = 0;\r\n        uint256 uplineId;\r\n        address payable uplineWallet;\r\n        uint256 _row = users[_userId].row;\r\n        uint256 _col = users[_userId].col;\r\n        while (_row > 1 && counter < 7) {\r\n          _col = findUpline(_col);\r\n          uplineId = globalPlaces[_row.sub(1)][_col];\r\n\r\n          if ((uplineId == 1) || (!isExpired(uplineId, false) && checkLevel(counter, users[uplineId].status))) {\r\n            uplineWallet = users[uplineId].wallet;\r\n            uplineWallet.transfer(values[counter+2]);\r\n            users[uplineId].earned += values[counter+2];\r\n            lastPaymentId += 1;\r\n            emit PaymentToUpline(lastPaymentId, _userId, uplineId, counter+1, values[counter+2], block.timestamp);\r\n          }\r\n          counter++;\r\n          _row--;\r\n        }\r\n    }\r\n\r\n\r\n    function _register(uint256 _refId) external payable {\r\n        require (msg.sender != address(0), \"Zero address prohibited.\");\r\n        require(userId[msg.sender] == 0, \"User already registered\");\r\n        require((_refId > 0 && _refId < uint256(-1)), \"Invalid referral ID\");\r\n        require(users[_refId].wallet != address(0), \"Invalid referral ID\");\r\n        require(lastUserId < uint256(-1), \"No more registrations allowed\");\r\n        require(lastPaymentId < uint256(-1), \"No more registrations allowed\");\r\n        uint256 rate = uint256(getLatestPrice());\r\n        require(msg.value >= prices[0].mul(10 ** 26).div(rate), \"Insufficient amount of BNB to participate\");\r\n        (uint8 st, uint256 change) = checkPayment(msg.value, rate);\r\n        if (change > 0) {\r\n\r\n            payable(msg.sender).transfer(change);\r\n        }\r\n        (uint256 userRow, uint256 userCol, uint256 newRowLastPlace) = findFreePlace(_refId);\r\n        require((userRow != 0 && userCol !=0), \"No free places left in global matrix\");\r\n        lastUserId += 1;\r\n        User memory user = User({\r\n                                    wallet: payable(msg.sender),\r\n                                    row: userRow,\r\n                                    col: userCol,\r\n                                    refId: _refId,\r\n                                    refCount: 0,\r\n                                    upgradedRefs: 0,\r\n                                    refBonus: 0,\r\n                                    earned: 0,\r\n                                    last_row: userRow.add(1),\r\n                                    status: st,\r\n                                    isForSale: false,\r\n                                    expire: block.timestamp.add(terms[st].mul(86400))\r\n                                  });\r\n        users[lastUserId] = user;\r\n        userId[msg.sender] = lastUserId;\r\n        globalPlaces[userRow][userCol] = lastUserId;\r\n        if (users[_refId].last_row < userRow) {\r\n            users[_refId].last_row = userRow;\r\n        }\r\n        if (newRowLastPlace > lastFreePlaceInRow[userRow]) {\r\n            lastFreePlaceInRow[userRow] = newRowLastPlace;\r\n\r\n        }\r\n        emit Register(msg.sender, lastUserId, userRow, userCol, _refId, st, block.timestamp);\r\n        processUplines(lastUserId, _refId, msg.value.sub(change));\r\n        upgradeReferals(_refId);\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"first\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_paymentId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_userId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_refId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_level\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_date\",\"type\":\"uint256\"}],\"name\":\"PaymentToUpline\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_userId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_status\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_plan\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_date\",\"type\":\"uint256\"}],\"name\":\"PlaceSold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_paymentId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_userId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_refId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_date\",\"type\":\"uint256\"}],\"name\":\"RefBonusSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_userId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_row\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_col\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_refId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_status\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_date\",\"type\":\"uint256\"}],\"name\":\"Register\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_userId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"StatusUPdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_userId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_userId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_status\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"_plan\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_date\",\"type\":\"uint256\"}],\"name\":\"Upgrade\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_ROW\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"_buyPlace\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_refId\",\"type\":\"uint256\"}],\"name\":\"_register\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_refId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"_support\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_userId\",\"type\":\"uint256\"}],\"name\":\"_update\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"approveSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestPrice\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPrices\",\"outputs\":[{\"internalType\":\"uint256[3]\",\"name\":\"\",\"type\":\"uint256[3]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTerms\",\"outputs\":[{\"internalType\":\"uint256[3]\",\"name\":\"\",\"type\":\"uint256[3]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inactivityPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lastFreePlaceInRow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastPaymentId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastUserId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lotteryPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBonusAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"retriveBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"winners\",\"type\":\"uint256[]\"}],\"name\":\"sendToWinners\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gp\",\"type\":\"uint256\"}],\"name\":\"setGasPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_period\",\"type\":\"uint256\"}],\"name\":\"setInactivityPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setMaxBonusAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feed\",\"type\":\"address\"}],\"name\":\"setPriceFeed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[3]\",\"name\":\"newPrices\",\"type\":\"uint256[3]\"}],\"name\":\"setPrices\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[3]\",\"name\":\"newTerms\",\"type\":\"uint256[3]\"}],\"name\":\"setTerms\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"row\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"col\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"upgradedRefs\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"earned\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"last_row\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isForSale\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"expire\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "SmartProfit", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000008bb56e53966e7e613201b98767b942d1ff584751", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d81216d220a167f050391a2b8cfbef1558c3254b58283be6e1dd33df7c427394"}