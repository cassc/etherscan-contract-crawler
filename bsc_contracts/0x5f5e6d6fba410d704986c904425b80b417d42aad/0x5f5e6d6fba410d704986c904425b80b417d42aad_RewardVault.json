{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/RewardVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\npragma experimental ABIEncoderV2 ;\\n\\nimport \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./libraries/TransferHelper.sol\\\";\\nimport \\\"./common/Adminable.sol\\\";\\nimport \\\"./common/ReentrancyGuard.sol\\\";\\n\\ncontract RewardVault is Adminable, ReentrancyGuard {\\n    using TransferHelper for IERC20;\\n\\n    event TrancheAdded (uint256 tranchId, uint64 startTime, uint64 endTime, uint64 expireTime, uint256 total, address provider, IERC20 token, uint128 ruleFlag);\\n    event TrancheUpdated (uint256 tranchId, uint64 startTime, uint64 endTime, uint64 expireTime, uint256 add);\\n    event RewardsRecycled (uint256 tranchId, uint256 share);\\n    event RewardClaimed (uint256 tranchId, address account, uint256 share);\\n    event TaxFundWithdrawn (IERC20 token, uint256 share);\\n    event TrancheTreeSet (uint256 tranchId, uint256 unDistribute, uint256 distribute, uint256 tax, bytes32 merkleRoot);\\n\\n    struct Tranche {\\n        bytes32 merkleRoot;\\n        uint64 startTime;\\n        uint64 endTime;\\n        uint64 expireTime;\\n        uint256 total;\\n        uint256 tax;\\n        uint256 unDistribute;\\n        uint256 recycled;\\n        uint256 claimed;\\n        address provider;\\n        IERC20 token;\\n    }\\n\\n    mapping(uint256 => Tranche) public tranches;\\n    // Record of whether user claimed the reward.\\n    mapping(uint256 => mapping(address => bool)) public claimed;\\n    // Stored tax fund of all token.\\n    mapping(IERC20 => uint256) public taxFund;\\n    // Stored share of all token.\\n    mapping(IERC20 => uint) public totalShare;\\n    uint256 public trancheIdx;\\n    uint64 public defaultExpireDuration;\\n    address public distributor;\\n\\n    address private constant _ZERO_ADDRESS = address(0);\\n    bytes32 private constant _INIT_MERKLE_ROOT = 0x0;\\n    bytes32 private constant _NO_MERKLE_ROOT = 0x0000000000000000000000000000000000000000000000000000000000000001;\\n\\n    constructor (address payable _admin, address _distributor, uint256 _trancheIdx, uint64 _defaultExpireDuration){\\n        require(_defaultExpireDuration > 0, \\\"Incorrect inputs\\\");\\n        admin = _admin;\\n        distributor = _distributor;\\n        trancheIdx = _trancheIdx;\\n        defaultExpireDuration = _defaultExpireDuration;\\n    }\\n\\n    /// @notice reward can supply by anyone.\\n    /// @dev If token has a tax rate, the actual received will be used.\\n    /// @param total Provide token amount.\\n    /// @param startTime The time of distribution rewards begins.\\n    /// @param endTime The time of distribution rewards ends.\\n    /// @param ruleFlag Flag corresponds to the rules of reward distribution.\\n    function newTranche(uint256 total, IERC20 token, uint64 startTime, uint64 endTime, uint128 ruleFlag) external payable nonReentrant {\\n        require(startTime > block.timestamp && endTime > startTime && total > 0 && ruleFlag > 0, \\\"Incorrect inputs\\\");\\n        uint256 _transferIn = transferIn(msg.sender, token, total);\\n        uint256 _trancheId = ++ trancheIdx;\\n        uint64 expireTime = endTime + defaultExpireDuration;\\n        tranches[_trancheId] = Tranche(_INIT_MERKLE_ROOT, startTime, endTime, expireTime, _transferIn, 0, 0, 0, 0, msg.sender, token);\\n        emit TrancheAdded(_trancheId, startTime, endTime, expireTime, _transferIn, msg.sender, token, ruleFlag);\\n    }\\n\\n    /// @notice Only provider can update tranche info before the time start.\\n    /// @dev If token has a tax rate, the actual received will be used.\\n    /// @param startTime The time of distribution rewards begins.\\n    /// @param endTime The time of distribution rewards ends.\\n    /// @param add Added token amount.\\n    function updateTranche(uint256 _trancheId, uint64 startTime, uint64 endTime, uint256 add) external payable nonReentrant {\\n        Tranche storage tranche = tranches[_trancheId];\\n        require(tranche.provider == msg.sender, \\\"No permission\\\");\\n        require(block.timestamp < tranche.startTime, 'Already started');\\n        require(startTime > block.timestamp && endTime > startTime, 'Incorrect inputs');\\n        uint256 _transferIn;\\n        if (add > 0){\\n            _transferIn = transferIn(msg.sender, tranche.token, add);\\n            tranche.total = tranche.total + _transferIn;\\n        }\\n        tranche.startTime = startTime;\\n        tranche.endTime = endTime;\\n        tranche.expireTime = endTime + defaultExpireDuration;\\n        emit TrancheUpdated(_trancheId, startTime, endTime, tranche.expireTime, _transferIn);\\n    }\\n\\n    /// @notice Only the reward provider can recycle the undistributed rewards and unclaimed rewards.\\n    function recyclingReward(uint256 _trancheId) external nonReentrant {\\n        (IERC20 token, uint share) = calRecycling(_trancheId);\\n        transferOut(msg.sender, token, share);\\n    }\\n\\n    /// @notice Recycling the undistributed rewards for multiple tranches.\\n    /// @param _trancheIds to recycle, required to be sorted by distributing token addresses.\\n    function recyclingRewards(uint256[] calldata _trancheIds) external nonReentrant{\\n        uint256 len = _trancheIds.length;\\n        require(len > 0, \\\"Incorrect inputs\\\");\\n        IERC20 prevToken;\\n        uint256 prevShare;\\n        for (uint256 i = 0; i < len; i ++) {\\n            (IERC20 token, uint share) = calRecycling(_trancheIds[i]);\\n            if (prevToken != token && prevShare > 0){\\n                transferOut(msg.sender, prevToken, prevShare);\\n                prevShare = 0;\\n            }\\n            prevShare = prevShare + share;\\n            prevToken = token;\\n        }\\n        transferOut(msg.sender, prevToken, prevShare);\\n    }\\n\\n    /// @notice Users can claim the reward.\\n    function claim(uint256 _trancheId, uint256 _share, bytes32[] calldata _merkleProof) external nonReentrant {\\n        IERC20 token = calClaim(_trancheId, _share, _merkleProof);\\n        transferOut(msg.sender, token, _share);\\n    }\\n\\n    function claims(uint256[] calldata _trancheIds, uint256[] calldata _shares, bytes32[][] calldata _merkleProofs) external nonReentrant {\\n        uint256 len = _trancheIds.length;\\n        require(len > 0 && len == _shares.length && len == _merkleProofs.length, \\\"Incorrect inputs\\\");\\n        IERC20 prevToken;\\n        uint256 prevShare;\\n        for (uint256 i = 0; i < len; i ++) {\\n            IERC20 token = calClaim(_trancheIds[i], _shares[i], _merkleProofs[i]);\\n            if (prevToken != token && prevShare > 0){\\n                transferOut(msg.sender, prevToken, prevShare);\\n                prevShare = 0;\\n            }\\n            prevShare = prevShare + _shares[i];\\n            prevToken = token;\\n        }\\n        transferOut(msg.sender, prevToken, prevShare);\\n    }\\n\\n    function verifyClaim(address account, uint256 _trancheId, uint256 _share, bytes32[] calldata _merkleProof) external view returns (bool valid) {\\n        return _verifyClaim(account, tranches[_trancheId].merkleRoot, _share, _merkleProof);\\n    }\\n\\n    function setExpireDuration(uint64 _defaultExpireDuration) external onlyAdmin {\\n        require (_defaultExpireDuration > 0, \\\"Incorrect inputs\\\");\\n        defaultExpireDuration = _defaultExpireDuration;\\n    }\\n\\n    function setDistributor(address _distributor) external onlyAdmin {\\n        distributor = _distributor;\\n    }\\n\\n    /// @notice Only the distributor can set the tranche reward distribute info.\\n    /// @dev If the reward is not distributed for some reason, the merkle root will be set with 1.\\n    /// @param _undistributed The reward of not distributed.\\n    /// @param _distributed The reward of distributed.\\n    /// @param _tax tax fund to admin.\\n    /// @param _merkleRoot reward tree info.\\n    function setTrancheTree(uint256 _trancheId, uint256 _undistributed, uint256 _distributed, uint256 _tax, bytes32 _merkleRoot) external {\\n        require(msg.sender == distributor, \\\"caller must be distributor\\\");\\n        Tranche storage tranche = tranches[_trancheId];\\n        require(tranche.endTime < block.timestamp, 'Not end');\\n        require(_undistributed + _distributed + _tax == tranche.total, 'Incorrect inputs');\\n        tranche.unDistribute = _undistributed;\\n        tranche.merkleRoot = _merkleRoot;\\n        tranche.tax = _tax;\\n        taxFund[tranche.token] = taxFund[tranche.token] + _tax;\\n        emit TrancheTreeSet(_trancheId, _undistributed, _distributed, _tax, _merkleRoot);\\n    }\\n\\n    /// @notice Only admin can withdraw the tax fund.\\n    function withdrawTaxFund(IERC20 token, address payable receiver) external onlyAdmin {\\n        _withdrawTaxFund(token, receiver);\\n    }\\n\\n    function withdrawTaxFunds(IERC20[] calldata tokens, address payable receiver) external onlyAdmin {\\n        uint len = tokens.length;\\n        for (uint256 i = 0; i < len; i ++) {\\n            _withdrawTaxFund(tokens[i], receiver);\\n        }\\n    }\\n\\n    function calRecycling(uint256 _trancheId) private returns (IERC20 token, uint share) {\\n        Tranche storage tranche = tranches[_trancheId];\\n        require(tranche.provider == msg.sender, \\\"No permission\\\");\\n        require(tranche.merkleRoot != _INIT_MERKLE_ROOT, \\\"Not start\\\");\\n        uint recycling = tranche.unDistribute;\\n        uint distributed = getDistribute(tranche);\\n        // can recycle expire\\n        if (block.timestamp >= tranche.expireTime && distributed > tranche.claimed){\\n            recycling = recycling + distributed - tranche.claimed;\\n        }\\n        recycling = recycling - tranche.recycled;\\n        require(recycling > 0, \\\"Invalid amount\\\");\\n        tranche.recycled = tranche.recycled + recycling;\\n        emit RewardsRecycled(_trancheId, recycling);\\n        return (tranche.token, recycling);\\n    }\\n\\n    function calClaim(uint256 _trancheId, uint256 _share, bytes32[] memory _merkleProof) private returns(IERC20 token) {\\n        Tranche storage tranche = tranches[_trancheId];\\n        require(tranche.merkleRoot != _INIT_MERKLE_ROOT, \\\"Not start\\\");\\n        require(tranche.merkleRoot != _NO_MERKLE_ROOT, \\\"No Reward\\\");\\n        require(tranche.expireTime > block.timestamp, \\\"Expired\\\");\\n        require(!claimed[_trancheId][msg.sender], \\\"Already claimed\\\");\\n        uint distributed = getDistribute(tranche);\\n        require(_share > 0 && _share + tranche.claimed <= distributed, \\\"Invalid amount\\\");\\n        require(_verifyClaim(msg.sender, tranche.merkleRoot, _share, _merkleProof), \\\"Incorrect merkle proof\\\");\\n        claimed[_trancheId][msg.sender] = true;\\n        tranche.claimed = tranche.claimed + _share;\\n        emit RewardClaimed(_trancheId, msg.sender, _share);\\n        return tranche.token;\\n    }\\n\\n    function _verifyClaim(address account, bytes32 root, uint256 _share, bytes32[] memory _merkleProof) private pure returns (bool valid) {\\n        bytes32 leaf = keccak256(abi.encodePacked(account, _share));\\n        return MerkleProof.verify(_merkleProof, root, leaf);\\n    }\\n\\n    function _withdrawTaxFund(IERC20 token, address payable receiver) private {\\n        uint withdrawable = taxFund[token];\\n        require(withdrawable > 0, \\\"Not enough\\\");\\n        delete taxFund[token];\\n        transferOut(receiver, token, withdrawable);\\n        emit TaxFundWithdrawn(token, withdrawable);\\n    }\\n\\n    function transferIn(address from, IERC20 token, uint amount) private returns(uint share) {\\n        if (isNativeToken(token)) {\\n            require(msg.value == amount, \\\"Not enough\\\");\\n            share = amount;\\n        } else {\\n            uint beforeBalance = token.balanceOf(address(this));\\n            uint receivedAmount = token.safeTransferFrom(from, address(this), amount);\\n            share = amountToShare(receivedAmount, beforeBalance, totalShare[token]);\\n            require(share > 0, \\\"Not enough\\\");\\n            totalShare[token] = totalShare[token] + share;\\n        }\\n    }\\n\\n    function transferOut(address to, IERC20 token, uint share) private {\\n        if (isNativeToken(token)) {\\n            (bool success,) = to.call{value : share}(\\\"\\\");\\n            require(success);\\n        } else {\\n            uint _totalShare = totalShare[token];\\n            totalShare[token] = _totalShare - share;\\n            token.safeTransfer(to, shareToAmount(share, token.balanceOf(address(this)), _totalShare));\\n        }\\n    }\\n\\n    function getDistribute(Tranche memory tranche) internal pure returns (uint256){\\n        return tranche.total - tranche.unDistribute - tranche.tax;\\n    }\\n\\n    function amountToShare(uint _amount, uint _reserve, uint _totalShare) private pure returns (uint share){\\n        share = _amount > 0 && _totalShare > 0 && _reserve > 0 ? _totalShare * _amount / _reserve : _amount;\\n    }\\n\\n    function shareToAmount(uint _share, uint _reserve, uint _totalShare) private pure returns (uint amount){\\n        if (_share > 0 && _totalShare > 0 && _reserve > 0) {\\n            amount = _reserve * _share / _totalShare;\\n        }\\n        return amount;\\n    }\\n\\n    function isNativeToken(IERC20 token) private pure returns (bool) {\\n        return (address(token) == _ZERO_ADDRESS);\\n    }\\n\\n}\"\r\n    },\r\n    \"/contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @title TransferHelper\\n * @dev Wrappers around ERC20 operations that returns the value received by recipent and the actual allowance of approval.\\n * To use this library you can add a `using TransferHelper for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary TransferHelper {\\n    function safeTransfer(\\n        IERC20 _token,\\n        address _to,\\n        uint256 _amount\\n    ) internal returns (uint256 amountReceived) {\\n        if (_amount > 0) {\\n            bool success;\\n            uint256 balanceBefore = _token.balanceOf(_to);\\n            (success, ) = address(_token).call(abi.encodeWithSelector(_token.transfer.selector, _to, _amount));\\n            require(success, \\\"TF\\\");\\n            uint256 balanceAfter = _token.balanceOf(_to);\\n            require(balanceAfter > balanceBefore, \\\"TF\\\");\\n            amountReceived = balanceAfter - balanceBefore;\\n        }\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 _token,\\n        address _from,\\n        address _to,\\n        uint256 _amount\\n    ) internal returns (uint256 amountReceived) {\\n        if (_amount > 0) {\\n            bool success;\\n            uint256 balanceBefore = _token.balanceOf(_to);\\n            (success, ) = address(_token).call(abi.encodeWithSelector(_token.transferFrom.selector, _from, _to, _amount));\\n            require(success, \\\"TFF\\\");\\n            uint256 balanceAfter = _token.balanceOf(_to);\\n            require(balanceAfter > balanceBefore, \\\"TFF\\\");\\n            amountReceived = balanceAfter - balanceBefore;\\n        }\\n    }\\n\\n    function safeApprove(\\n        IERC20 _token,\\n        address _spender,\\n        uint256 _amount\\n    ) internal returns (uint256) {\\n        bool success;\\n        if (_token.allowance(address(this), _spender) != 0) {\\n            (success, ) = address(_token).call(abi.encodeWithSelector(_token.approve.selector, _spender, 0));\\n            require(success, \\\"AF\\\");\\n        }\\n        (success, ) = address(_token).call(abi.encodeWithSelector(_token.approve.selector, _spender, _amount));\\n        require(success, \\\"AF\\\");\\n\\n        return _token.allowance(address(this), _spender);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/common/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.17;\\n\\ncontract ReentrancyGuard {\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    modifier nonReentrant() {\\n        check();\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    function check() private view {\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/common/Adminable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.17;\\n\\nabstract contract Adminable {\\n    address payable public admin;\\n    address payable public pendingAdmin;\\n    address payable public developer;\\n\\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\\n\\n    event NewAdmin(address oldAdmin, address newAdmin);\\n\\n    constructor() {\\n        developer = payable(msg.sender);\\n    }\\n\\n    modifier onlyAdmin() {\\n        checkAdmin();\\n        _;\\n    }\\n    modifier onlyAdminOrDeveloper() {\\n        require(msg.sender == admin || msg.sender == developer, \\\"Only admin or dev\\\");\\n        _;\\n    }\\n\\n    function setPendingAdmin(address payable newPendingAdmin) external virtual onlyAdmin {\\n        // Save current value, if any, for inclusion in log\\n        address oldPendingAdmin = pendingAdmin;\\n        // Store pendingAdmin with value newPendingAdmin\\n        pendingAdmin = newPendingAdmin;\\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\\n    }\\n\\n    function acceptAdmin() external virtual {\\n        require(msg.sender == pendingAdmin, \\\"Only pendingAdmin\\\");\\n        // Save current values for inclusion in log\\n        address oldAdmin = admin;\\n        address oldPendingAdmin = pendingAdmin;\\n        // Store admin with value pendingAdmin\\n        admin = pendingAdmin;\\n        // Clear the pending value\\n        pendingAdmin = payable(0);\\n        emit NewAdmin(oldAdmin, admin);\\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\\n    }\\n\\n    function checkAdmin() private view {\\n        require(msg.sender == admin, \\\"caller must be admin\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.2) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The tree and the proofs can be generated using our\\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\n * You will find a quickstart guide in the readme.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the merkle tree could be reinterpreted as a leaf value.\\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\\n * against this attack out of the box.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {verify}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processProof}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {multiProofVerify}\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\n     * respectively.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofLen = proof.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proofLen - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            require(proofPos == proofLen, \\\"MerkleProof: invalid multiproof\\\");\\n            unchecked {\\n                return hashes[totalHashes - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofLen = proof.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proofLen - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            require(proofPos == proofLen, \\\"MerkleProof: invalid multiproof\\\");\\n            unchecked {\\n                return hashes[totalHashes - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_admin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_distributor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_trancheIdx\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_defaultExpireDuration\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"NewAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldPendingAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"NewPendingAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tranchId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"share\",\"type\":\"uint256\"}],\"name\":\"RewardClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tranchId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"share\",\"type\":\"uint256\"}],\"name\":\"RewardsRecycled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"share\",\"type\":\"uint256\"}],\"name\":\"TaxFundWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tranchId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"startTime\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"endTime\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"expireTime\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"ruleFlag\",\"type\":\"uint128\"}],\"name\":\"TrancheAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tranchId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unDistribute\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"distribute\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tax\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"}],\"name\":\"TrancheTreeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tranchId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"startTime\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"endTime\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"expireTime\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"add\",\"type\":\"uint256\"}],\"name\":\"TrancheUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_trancheId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_share\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_trancheIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_shares\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[][]\",\"name\":\"_merkleProofs\",\"type\":\"bytes32[][]\"}],\"name\":\"claims\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultExpireDuration\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"developer\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"startTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"endTime\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"ruleFlag\",\"type\":\"uint128\"}],\"name\":\"newTranche\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_trancheId\",\"type\":\"uint256\"}],\"name\":\"recyclingReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_trancheIds\",\"type\":\"uint256[]\"}],\"name\":\"recyclingRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_distributor\",\"type\":\"address\"}],\"name\":\"setDistributor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_defaultExpireDuration\",\"type\":\"uint64\"}],\"name\":\"setExpireDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"setPendingAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_trancheId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_undistributed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_distributed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tax\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"}],\"name\":\"setTrancheTree\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"taxFund\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"trancheIdx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tranches\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"startTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"endTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"expireTime\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unDistribute\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"recycled\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimed\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_trancheId\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"startTime\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"endTime\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"add\",\"type\":\"uint256\"}],\"name\":\"updateTranche\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_trancheId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_share\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"verifyClaim\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"withdrawTaxFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"address payable\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"withdrawTaxFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "RewardVault", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000004f1f6828c42891620f6734c52774b0b0966c459400000000000000000000000059558b7d604675a4cc9eb36c67f159550f73bf9a0000000000000000000000000000000000000000000000000000000000000011000000000000000000000000000000000000000000000000000000000076a700", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}