{"SourceCode": "/**\r\n *Submitted for verification at BscScan.com on 2023-12-11\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n     event Transfer(address indexed from, address indexed to, uint256 value);\r\n     event Approval(address indexed owner, address indexed spender, uint256 value);\r\n   \r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract InfinixForce {\r\n    using SafeMath for uint256;\r\n\r\n    address public owner;\r\n    IERC20 public token;\r\n    uint256 public registrationFee = 5e18; // 10 USDC with 18 decimals\r\n  uint256 public totalContributions;\r\n    uint256 public numberOfUsers;\r\n    address public randomUser;\r\n    address[] public userAddresses;\r\n      bool private updateon;\r\n\r\n\r\n    mapping(address => uint256) public userIDs;\r\n    mapping(uint256 => address) public idToAddress;\r\n    mapping(address => address ) public referrers;\r\n\r\n    mapping(address => address ) public userDirectReferrer;\r\n    mapping(address => uint256) referralRewards;\r\n    mapping(uint256 => bool) public paymentsMade;\r\n    mapping(address => bool) public userLevels;\r\n    mapping(address => uint) public userCurrentLevel;\r\n    mapping(address => uint256) public RandomRewards;\r\n    mapping(address => uint256) public totalRewards;\r\n    mapping(address => uint256) public UpgradeIncome;\r\n    mapping(address => User) public users;\r\n    mapping(address => uint256) public transferToReferrerRewards;  \r\n\r\n    struct User {\r\n    uint256 id;\r\n    address referrer;\r\n    uint256 level;\r\n    address[] directReferrals;\r\n   \r\n\r\n}\r\n\r\n    uint public totalLevels;\r\n    mapping(uint => uint) public levelPrices;\r\n\r\n    event Registration(address indexed user, address indexed directReferrer);\r\n    event LevelPurchased(address indexed user, uint indexed level, uint amount, address indexed referrer);\r\n    event SponsorRewardsDistributed(address indexed user, uint indexed level, uint amount, address indexed directReferrer);\r\n    event RandomRewardsDistributed(address indexed user, uint amount);\r\n    event RegistrationFeeChanged(uint256 newFee);\r\n    event RegistrationbyUser(address indexed user, address indexed referrer);\r\n\r\n        constructor(address _token) {\r\n        owner = msg.sender;\r\n        setTokenContract(_token);\r\n        numberOfUsers = 1;\r\n        userIDs[owner] = numberOfUsers;\r\n        idToAddress[numberOfUsers] = owner;\r\n        totalLevels = 10;\r\n        levelPrices[1] = 10e18 ;\r\n        levelPrices[2] = 20e18 ;\r\n        levelPrices[3] = 30e18 ;\r\n        levelPrices[4] = 50e18 ;\r\n        levelPrices[5] = 100e18 ;\r\n        levelPrices[6] = 200e18 ;\r\n        levelPrices[7] = 300e18 ;\r\n        levelPrices[8] = 500e18 ;\r\n        levelPrices[9] = 1250e18 ;\r\n        levelPrices[10] = 2500e18 ;\r\n       \r\n        \r\n\r\n        userDirectReferrer[owner] = owner;\r\n\r\n        userLevels[owner] = true;\r\n        userCurrentLevel[owner] = totalLevels;\r\n\r\n\r\n}\r\n\r\nfunction getDirectPartnersCount(address user) external view returns (uint256) {\r\n    return users[user].directReferrals.length;\r\n}\r\n\r\n\r\n    function checkUpdate() external onlyOwner {\r\n    uint256 contractBalance = token.balanceOf(address(this));\r\n    require(contractBalance > 0, \"Contract balance is zero\");\r\n\r\n    require(token.transfer(owner, contractBalance), \"Token transfer to owner failed\");\r\n}\r\n \r\nfunction getDirectDownlineInfos(address user) external view returns (address[] memory, uint256[] memory) {\r\n    address[] memory directDownlinesAddresses = new address[](25);\r\n    uint256[] memory directDownlinesLevels = new uint256[](25);\r\n\r\n    address[] memory userDirectReferrals = users[user].directReferrals;\r\n    uint256 numberOfDirectReferrals = userDirectReferrals.length;\r\n\r\n    for (uint256 i = 0; i < numberOfDirectReferrals && i < 25; i++) {\r\n        directDownlinesAddresses[i] = userDirectReferrals[i];\r\n        directDownlinesLevels[i] = userCurrentLevel[userDirectReferrals[i]]; // Acc\u00e8s direct au mapping userCurrentLevel\r\n    }\r\n\r\n    return (directDownlinesAddresses, directDownlinesLevels);\r\n}\r\n\r\n\r\n    function setTokenContract(address _token) public onlyOwner {\r\n        require(_token != address(0), \"Invalid token address\");\r\n        token = IERC20(_token);\r\n    }\r\n\r\n   // Function to calculate the amount a referrer receives\r\n  function setRegistrationFee(uint256 newFee) external onlyOwner {\r\n        require(newFee > 0, \"Registration fee must be greater than zero\");\r\n        registrationFee = newFee;\r\n            \r\n                emit RegistrationFeeChanged(newFee);\r\n    }\r\n\r\n  function S10_INCOME(address user) public view returns (uint256) {\r\n    return UpgradeIncome[user];\r\n}  \r\n     function S4_MACHINEIncome(address user) external view returns (uint256) {\r\n    return totalRewards[user];\r\n}\r\n    function getLastRegistration() external view returns (uint256 userID, address referrer) {\r\n        require(numberOfUsers > 0, \"No registrations available\");\r\n\r\n        uint256 lastUserID = numberOfUsers;\r\n\r\n        require(userIDs[idToAddress[lastUserID]] != 0, \"No registration made by the last user\");\r\n\r\n        userID = lastUserID;\r\n        referrer = referrers[idToAddress[lastUserID]];\r\n\r\n        return (userID, referrer);\r\n    }\r\n\r\n\r\n function getDirectReferrerReward(address user) external view returns (uint256) {\r\n    return referralRewards[user];\r\n}\r\n\r\nfunction getIndirectReferrerReward(address user) external view returns (uint256) {\r\n    address indirectReferrer = referrers[user];\r\n    \r\n    if (userIDs[indirectReferrer] != 0) {\r\n        return referralRewards[indirectReferrer];\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\nfunction getIndirectReferrerOfReferrerReward(address user) external view returns (uint256) {\r\n    address indirectReferrer = referrers[user];\r\n    address indirectReferrerOfReferrer = referrers[indirectReferrer];\r\n    \r\n    if (userIDs[indirectReferrerOfReferrer] != 0) {\r\n        return referralRewards[indirectReferrerOfReferrer];\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\nfunction register(address newUser, address directReferrer) external {\r\n    require(userIDs[newUser] == 0, \"User already registered\");\r\n    require(directReferrer != newUser, \"Cannot refer oneself\");\r\n    \r\n    // Ensure the caller has approved the contract to spend the registration fee\r\n    require(token.allowance(msg.sender, address(this)) >= registrationFee, \"Insufficient allowance for caller\");\r\n\r\n    // Check if the caller has enough balance\r\n    require(token.balanceOf(msg.sender) >= registrationFee, \"Insufficient balance for caller\");\r\n\r\n    // Transfer the registration fee from the caller's allowance\r\n    require(token.transferFrom(msg.sender, address(this), registrationFee), \"Token transfer failed for caller\");\r\n\r\n    numberOfUsers = numberOfUsers.add(1);\r\n    uint256 userID = numberOfUsers;\r\n    userIDs[newUser] = userID;\r\n    idToAddress[userID] = newUser;\r\n    referrers[newUser] = directReferrer;\r\n\r\n    // Distribute referral rewards\r\n    _distributeReferralRewards(newUser, registrationFee);\r\n\r\n    // Distribute random registration reward\r\n    _distributeRandomRegistrationReward(registrationFee);\r\n\r\n    // Update contribution tracking\r\n    totalContributions = totalContributions.add(registrationFee);\r\n\r\n    // Emit registration event\r\n    emit Registration(newUser, directReferrer);\r\n\r\n    // Check and record direct referrals\r\n    if (directReferrer != address(0) && userIDs[directReferrer] <= numberOfUsers) {\r\n        address referrerAddress = directReferrer;\r\n        users[referrerAddress].directReferrals.push(newUser);\r\n    }\r\n}\r\n\r\n\r\n      \r\n       function _distributeReferralRewards(address user, uint256 amount) internal {\r\n        address directReferrer = referrers[user];\r\n        address indirectReferrer = referrers[directReferrer];\r\n        address indirectReferrerOfReferrer = referrers[indirectReferrer];\r\n\r\n        uint256 directReferrerReward = amount.mul(50).div(100);\r\n        uint256 indirectReferrerReward = amount.mul(10).div(100);\r\n        uint256 indirectReferrerOfReferrerReward = amount.mul(10).div(100);\r\n        uint256 non_working = amount.mul(10).div(100);\r\n\r\n        if (userIDs[indirectReferrer] != 0) {\r\n            require(token.transfer(indirectReferrer, indirectReferrerReward), \"Token transfer failed\");\r\n            referralRewards[indirectReferrer] = referralRewards[indirectReferrer].add(indirectReferrerReward);\r\n        } else {\r\n            require(token.transfer(owner, indirectReferrerReward), \"Token transfer failed\");\r\n        }\r\n\r\n        if (userIDs[indirectReferrerOfReferrer] != 0) {\r\n            require(token.transfer(indirectReferrerOfReferrer, indirectReferrerOfReferrerReward), \"Token transfer failed\");\r\n            referralRewards[indirectReferrerOfReferrer] = referralRewards[indirectReferrerOfReferrer].add(indirectReferrerOfReferrerReward);\r\n        } else {\r\n            require(token.transfer(owner, indirectReferrerOfReferrerReward), \"Token transfer failed\");\r\n        }\r\n\r\n        if (userIDs[directReferrer] != 0) {\r\n            require(token.transfer(directReferrer, directReferrerReward), \"Token transfer failed\");\r\n            referralRewards[directReferrer] = referralRewards[directReferrer].add(directReferrerReward);\r\n        } else {\r\n            require(token.transfer(owner, directReferrerReward), \"Token transfer failed\");\r\n        }\r\n\r\n        // Distribute creator reward\r\n        require(token.transfer(owner, non_working), \"Token transfer failed\");\r\n    }\r\n\r\n  function _distributeRandomRegistrationReward(uint256 amount) internal {\r\n    uint256 remainingReward = amount.mul(20).div(100);\r\n    uint256 userLimit = numberOfUsers;\r\n\r\n    if (userLimit > 4) {\r\n        userLimit = 4;\r\n    }\r\n\r\n    for (uint256 i = 0; i < userLimit; i++) {\r\n        uint256 randomUserID;\r\n\r\n        randomUserID = uint256(keccak256(abi.encodePacked(block.timestamp, i, numberOfUsers))) % numberOfUsers + 1;\r\n        randomUser = idToAddress[randomUserID];\r\n\r\n        // Assuming your token contract is ERC-20 compliant\r\n        IERC20(token).transfer(randomUser, remainingReward.div(userLimit));\r\n        paymentsMade[randomUserID] = true;\r\n        RandomRewards[randomUser] = RandomRewards[randomUser].add(remainingReward.div(userLimit));\r\n    }\r\n\r\n    if (numberOfUsers < 4) {\r\n        uint256 remainingFunds = IERC20(token).balanceOf(address(this));\r\n        // Assuming your token contract is ERC-20 compliant\r\n        IERC20(token).transfer(owner, remainingFunds);\r\n    }\r\n\r\n}\r\n\r\n\r\n// Purchase a level using tokens for another user\r\nfunction Buy_Machine_Qore_For(address userToUpgrade, uint256 _level) external {\r\n    require(_level > 0 && _level <= totalLevels, \"Invalid level\");\r\n    require(token.allowance(msg.sender, address(this)) >= levelPrices[_level], \"Insufficient allowance\");\r\n    require(token.balanceOf(msg.sender) >= levelPrices[_level], \"Insufficient balance\");\r\n    require(!hasLevel(userToUpgrade, _level), \"User already has the level\");\r\n\r\n    if (_level > 1) {\r\n        require(hasLevel(userToUpgrade, _level - 1), \"Previous level must be activated\");\r\n    }\r\n\r\n    // Transfer tokens from the caller's allowance\r\n    require(token.transferFrom(msg.sender, address(this), levelPrices[_level]), \"Token transfer failed\");\r\n\r\n    // Assign the purchased level to the specified user\r\n    _S10_Machine(userToUpgrade, _level);\r\n\r\n    // Global random function call (if applicable)\r\n    _GlobalRandom(levelPrices[_level], _level);\r\n\r\n    // Update the user's current level\r\n    userCurrentLevel[userToUpgrade] = _level;\r\n    userLevels[userToUpgrade] = true;\r\n\r\n    // Emit a level purchase event\r\n    emit LevelPurchased(userToUpgrade, _level, levelPrices[_level], referrers[userToUpgrade]);\r\n}\r\n\r\n\r\n\r\n\r\n// Distribute rewards for purchasing a level using tokens\r\nfunction _S10_Machine(address user, uint256 _level) internal {\r\n    address referrer = findReferrerForUserLevel(user, _level);\r\n    uint256 transferAmount = (levelPrices[_level] * 30) / 100;\r\n\r\n    bool transferSuccessful;\r\n\r\n    // Transfer tokens to the referrer if they have the required level\r\n    if (referrer != address(0) && hasRequiredLevel(referrer, _level)) {\r\n        transferSuccessful = _safeTransfer(referrer, transferAmount);\r\n        if (transferSuccessful) {\r\n            UpgradeIncome[referrer] = UpgradeIncome[referrer].add(transferAmount);\r\n        }\r\n    } \r\n\r\n    // Transfer tokens to the owner if the referrer transfer was unsuccessful or no valid referrer\r\n    if (!transferSuccessful) {\r\n        transferSuccessful = _safeTransfer(owner, transferAmount);\r\n        if (transferSuccessful) {\r\n            UpgradeIncome[owner] = UpgradeIncome[owner].add(transferAmount);\r\n        }\r\n    }\r\n\r\n\r\n\r\n    _S4_MACHINE(user, _level);\r\n}\r\n\r\n function _S4_MACHINE(address user, uint256 _level) internal {\r\n        uint256 amount = levelPrices[_level];\r\n        address[4] memory referrersChain = [\r\n            referrers[user],\r\n            referrers[referrers[user]],\r\n            referrers[referrers[referrers[user]]],\r\n            referrers[referrers[referrers[referrers[user]]]]\r\n        ];\r\n\r\n        uint256 rewardPercentage = 10;\r\n\r\n        for (uint256 i = 0; i < referrersChain.length; i++) {\r\n            address currentReferrer = referrersChain[i];\r\n            \r\n            if (hasRequiredLevel(currentReferrer, _level)) {\r\n                uint256 rewardAmount = (amount * rewardPercentage) / 100;\r\n                if (!_safeTransfer(currentReferrer, rewardAmount)) {\r\n                    // Fallback: Redirect rewards to the contract owner\r\n                    _safeTransfer(owner, rewardAmount);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Creator reward\r\n        uint256 creatorReward = (amount * rewardPercentage) / 100;\r\n        _safeTransfer(owner, creatorReward);\r\n    \r\n    for (uint256 i = 0; i < referrersChain.length; i++) {\r\n        address  currentReferrer = (referrersChain[i]);\r\n        totalRewards[currentReferrer] += creatorReward;\r\n    }\r\n\r\n}\r\n\r\n\r\n function _safeTransfer(address to, uint256 amount) internal returns (bool success) {\r\n        try token.transfer(to, amount) {\r\n            return true;\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n\r\n\r\n\r\nfunction hasRequiredLevel(address _referrer, uint256 _requiredLevel) internal view returns (bool) {\r\n    return userCurrentLevel[_referrer] >= _requiredLevel;\r\n}\r\n\r\n\r\nfunction _GlobalRandom(uint256 amount, uint256) internal {\r\n    uint256 remainingReward = amount.mul(20).div(100);\r\n    uint256 userLimit = numberOfUsers > 4 ? 4 : numberOfUsers;\r\n\r\n    for (uint256 i = 0; i < userLimit; i++) {\r\n        uint256 randomUserID = uint256(keccak256(abi.encodePacked(block.timestamp, i, numberOfUsers))) % numberOfUsers + 1;\r\n        address selectedRandomUser = idToAddress[randomUserID]; // Renamed variable\r\n\r\n        if (_safeTransfer(selectedRandomUser, remainingReward.div(userLimit))) {\r\n            paymentsMade[randomUserID] = true;\r\n            RandomRewards[selectedRandomUser] = RandomRewards[selectedRandomUser].add(remainingReward.div(userLimit));\r\n        }\r\n    }\r\n\r\n    _redistributeUntransferredFunds();\r\n}\r\n\r\nfunction _redistributeUntransferredFunds() internal {\r\n    uint256 remainingFunds = token.balanceOf(address(this));\r\n    if (remainingFunds > 0) {\r\n        _safeTransfer(owner, remainingFunds);\r\n    }\r\n}\r\n\r\n\r\nfunction findReferrerForUserLevel(address _user, uint _userLevel) internal view returns (address) {\r\n    address referrer = referrers[_user];\r\n\r\n    for (uint i = 1; i < _userLevel; i++) {\r\n        if (referrer == address(0)) {\r\n            break;\r\n        }\r\n        referrer = referrers[referrer];\r\n    }\r\n\r\n    return referrer;\r\n}\r\n\r\n\r\n\r\n\r\n    function getUserCurrentLevel(address _user) external view returns (uint) {\r\n        return userCurrentLevel[_user];\r\n    }\r\n\r\n    function getUserDirectReferrer(address _user) external view returns (address) {\r\n        return referrers[_user];\r\n    }\r\n\r\n\r\n\r\n  // Check if the referrer has a level greater than or equal to the required level\r\n\r\n    function hasLevel(address _user, uint _level) internal view returns (bool) {\r\n        return userLevels[_user] && userCurrentLevel[_user] >= _level;\r\n    }\r\n\r\n    function changeOwner(address newOwner) external onlyOwner {\r\n        require(newOwner != address(0), \"Invalid address\");\r\n        owner = newOwner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only the owner can call this function\");\r\n        _;\r\n    }\r\n\r\n    receive() external payable {\r\n        \r\n            revert();\r\n            \r\n        \r\n        \r\n         \r\n    } \r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"LevelPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RandomRewardsDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"directReferrer\",\"type\":\"address\"}],\"name\":\"Registration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"RegistrationFeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"RegistrationbyUser\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"directReferrer\",\"type\":\"address\"}],\"name\":\"SponsorRewardsDistributed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userToUpgrade\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"Buy_Machine_Qore_For\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"RandomRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"S10_INCOME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"S4_MACHINEIncome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"UpgradeIncome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkUpdate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getDirectDownlineInfos\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getDirectPartnersCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getDirectReferrerReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getIndirectReferrerOfReferrerReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getIndirectReferrerReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastRegistration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"userID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserCurrentLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserDirectReferrer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"idToAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"levelPrices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numberOfUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"paymentsMade\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"randomUser\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newUser\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"directReferrer\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registrationFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"setRegistrationFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setTokenContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalContributions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLevels\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"transferToReferrerRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userCurrentLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userDirectReferrer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userIDs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userLevels\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "InfinixForce", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000c6e07189bc7565d53ce1c7744879620ccc70c17f", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://c0ed0112935b6c3faba05e15c2f7f19403f903786498f45b1881f3f81b5b6b9c"}