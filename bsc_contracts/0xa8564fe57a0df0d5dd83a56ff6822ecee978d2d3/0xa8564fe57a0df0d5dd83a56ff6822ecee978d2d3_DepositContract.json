{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/DepositContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport {EnumerableSet} from \\\"./EnumerableSet.sol\\\";\\nimport {Ownable2Step} from \\\"./Ownable2Step.sol\\\";\\nimport {Pausable} from \\\"./Pausable.sol\\\";\\nimport {IDepositContract} from \\\"./IDepositContract.sol\\\";\\nimport {CheckContractAddress} from \\\"./CheckContractAddress.sol\\\";\\n\\ncontract DepositContract is\\nOwnable2Step,\\nPausable,\\nIDepositContract,\\nCheckContractAddress\\n{\\n    uint256 constant SUBSCRIPTION_DURATION = 180 days;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    // Whitelisting\\n    EnumerableSet.AddressSet private whitelist;\\n    mapping(address => EnumerableSet.AddressSet) private contractWhitelisted;\\n\\n    // Subscriptions\\n    mapping(address => Subscription) private subscriptionPeriod;\\n\\n    struct Subscription {\\n        uint256 startDate;\\n        uint256 endDate;\\n        bool isSnap;\\n    }\\n\\n    // Funds management\\n    mapping(address => uint256) private minBalanceLimitClient;\\n    mapping(address => uint256) private clientFund;\\n    uint256 private supraFund;\\n    uint256 private minBalanceLimitSupra;\\n\\n    // Miscellaneous\\n    address public generator;\\n    address public router;\\n    address public coldWallet;\\n    address public _tempWallet;\\n    address public approver;\\n    address public developer;\\n    bool public adminFeelsOK;\\n\\n    /// @dev Emitted when a client is whitelisted.\\n    /// @param _clientAddress Address of the client that has been whitelisted.\\n    /// @param _startTime The timestamp representing the start time of the subscription period.\\n    /// @param _endTime The timestamp representing the end time of the subscription period.\\n    /// @param _isSnap A boolean flag indicating if the client is a part of the SNAP program or not.\\n    event ClientWhitelisted(\\n        address _clientAddress,\\n        uint256 _startTime,\\n        uint256 _endTime,\\n        bool _isSnap\\n    );\\n\\n    /// @dev Emitted when a client is removed from the whitelist.\\n    /// @param _clientAddress Address of the client that has been removed from the whitelist.\\n    /// @param _removedTime The timestamp representing the time at which the client was removed.\\n    event ClientRemovedFromWhitelist(\\n        address _clientAddress,\\n        uint256 _removedTime\\n    );\\n\\n    /// @dev Emitted when contracts are removed from the whitelist for a client\\n    /// @param _clientAddress The address of the client whose contracts were removed\\n    /// @param _removedTime The timestamp when the contracts were removed\\n    event ContractsDeletedFromWhitelist(\\n        address _clientAddress,\\n        uint256 _removedTime\\n    );\\n\\n    /// @dev Emitted when a contract is whitelisted for a client.\\n    /// @param _clientAddress Address of the client whose contract has been whitelisted.\\n    /// @param _contractAddress Address of the contract that has been whitelisted.\\n    /// @param _timeStamp The timestamp representing the time at which the contract was whitelisted.\\n    event ContractWhitelisted(\\n        address _clientAddress,\\n        address _contractAddress,\\n        uint256 _timeStamp\\n    );\\n\\n    /// @dev Emitted when a client deposits funds into their account.\\n    /// @param _depositer The address of the client who deposited funds.\\n    /// @param amount The amount of funds that were deposited.\\n    event ClientDeposited(address _depositer, uint256 amount);\\n\\n    /// @dev Emitted when a client withdraws funds from their account.\\n    /// @param _withdrawer The address of the client who withdrew funds.\\n    /// @param amount The amount of funds that were withdrawn.\\n    event ClientWithdrwal(address _withdrawer, uint256 amount);\\n\\n    /// @dev Emitted when Supra collects funds from a client's account.\\n    /// @param _fromClient The address of the client from whom funds were collected.\\n    /// @param amount The amount of funds that were collected.\\n    event SupraCollected(address _fromClient, uint256 amount);\\n\\n    /// @dev Emitted when Supra refunds funds to a client's account.\\n    /// @param _toClient The address of the client to whom funds were refunded.\\n    /// @param amount The amount of funds that were refunded.\\n    event SupraRefunded(address _toClient, uint256 amount);\\n\\n    /// @dev Emitted when the approver confirms the new cold wallet address\\n    /// @param _coldWalletAddress The new address of the cold wallet\\n    event ColdWalletConfirmed(address _coldWalletAddress);\\n\\n    /// @dev Emitted when the client set the minimum balance limit to hold in wallet\\n    /// @param  _clientAddress The client wallet address through which and for which the limit is to be set\\n    /// @param limit The value which client wants to be a minimum limit for the specified wallet\\n    event MinBalanceClientSet(address _clientAddress, uint256 limit);\\n\\n    /// @dev Constructor to initialize contract with provided parameters.\\n    /// @param _approver Address of the approver who will approve changes.\\n    /// @param _developer Address of the developer who will manage the contract.\\n    /// @param _newGenerator Address of the new generator contract.\\n    /// @param _newRouter Address of the new router contract.\\n    /// @param _minBalanceLimitSupra Minimum balance limit to execute supra transactions.\\n    /// The value must be greater than or equal to zero.\\n    constructor(\\n        address _approver,\\n        address _developer,\\n        address _newGenerator,\\n        address _newRouter,\\n        uint256 _minBalanceLimitSupra\\n    ) {\\n        require(_approver != msg.sender, \\\"Admin cannot be the approver\\\");\\n        require(\\n            _developer != address(0) &&\\n            _approver != address(0) &&\\n            _newGenerator != address(0) &&\\n            _newRouter != address(0),\\n            \\\"Address cannot be a zero address\\\"\\n        );\\n        require(_minBalanceLimitSupra != 0, \\\"Invalid Minimum balance limit\\\");\\n\\n        developer = _developer;\\n        approver = _approver;\\n        generator = _newGenerator;\\n        router = _newRouter;\\n        minBalanceLimitSupra = _minBalanceLimitSupra;\\n    }\\n\\n    modifier checkClientWhitelisted(address _clientAddress) {\\n        require(\\n            isClientWhitelisted(_clientAddress),\\n            \\\"Client address not whitelisted\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n        #######################################################################################\\n            :::::::::::::::::::::::: SUPRA ADMIN OPERATIONS ::::::::::::::::::::::::::::::\\n        #######################################################################################\\n    */\\n\\n    /// @dev Allows SupraAdmin to add a client to the whitelist.\\n    /// @param _clientAddress The address of the client being added.\\n    /// @param _isSnap A boolean value indicating whether the client is a Snap user or not.\\n    function addClientToWhitelist(address _clientAddress, bool _isSnap)\\n    external\\n    onlyOwner\\n    {\\n        require(\\n            !isClientWhitelisted(_clientAddress),\\n            \\\"Client is already whitelisted\\\"\\n        );\\n        whitelist.add(_clientAddress);\\n        addSubscriptionInfoByClient(\\n            _clientAddress,\\n            block.timestamp,\\n            block.timestamp + SUBSCRIPTION_DURATION,\\n            _isSnap\\n        );\\n        emit ClientWhitelisted(\\n            _clientAddress,\\n            block.timestamp,\\n            block.timestamp + SUBSCRIPTION_DURATION,\\n            _isSnap\\n        );\\n    }\\n\\n    /// @dev Update the end time of a client's subscription\\n    /// @param _clientAddress The address of the client\\n    /// @param _newEndTime The new end time for the subscription\\n    /// - require The client is whitelisted\\n    /// - require The new end time is in the future\\n    function updateSubscription(address _clientAddress, uint256 _newEndTime)\\n    external\\n    onlyOwner\\n    checkClientWhitelisted(_clientAddress)\\n    {\\n        require(_newEndTime > block.timestamp + 2 days, \\\"Invalid End Time\\\");\\n        subscriptionPeriod[_clientAddress].endDate = _newEndTime;\\n    }\\n\\n    /// @dev Remove a client from the whitelist\\n    /// @param _clientAddress The address of the client to remove\\n    function removeClientFromWhitelist(address _clientAddress)\\n    external\\n    onlyOwner\\n    checkClientWhitelisted(_clientAddress)\\n    {\\n        uint256 _amount = checkClientFund(_clientAddress);\\n        (bool sent, bytes memory data) = payable(_clientAddress).call{\\n                value: _amount\\n            }(\\\"\\\");\\n        require(sent, \\\"Cannot transfer client funds\\\");\\n        bool result = whitelist.remove(_clientAddress);\\n        require(result, \\\"Client not whitelisted or already removed\\\");\\n        emit ClientRemovedFromWhitelist(_clientAddress, block.timestamp);\\n    }\\n\\n    /// @dev Remove all contracts associated with a client\\n    /// @param _clientAddress The address of the client\\n    function removeAllContractOfClient(address _clientAddress)\\n    external\\n    onlyOwner\\n    {\\n        uint256 _totalCount = contractWhitelisted[_clientAddress].length();\\n        require(\\n            _totalCount != 0,\\n            \\\"Contracts not whitelisted or already removed\\\"\\n        );\\n        contractWhitelisted[_clientAddress].clear();\\n    }\\n\\n    /// @dev Allows the owner to claim free node expenses.\\n    /// Only the owner can do this.\\n    /// @param _amount The amount to be claimed to coldwallet.\\n    function claimFreeNodeExpenses(uint256 _amount) external onlyOwner {\\n        require(\\n            coldWallet != address(0),\\n            \\\"Invalid Address: Address cannot be a zero address\\\"\\n        );\\n        require(\\n            _amount <= supraFund,\\n            \\\"Insufficient Funds: Claiming free node expenses\\\"\\n        );\\n        supraFund -= _amount;\\n        (bool sent, bytes memory data) = payable(coldWallet).call{\\n                value: _amount\\n            }(\\\"\\\");\\n        require(sent, \\\"Cannot claim free node expenses\\\");\\n    }\\n\\n    /// @dev Execute a refund from the supra fund to a client\\n    /// @param _fundReceiver The address of the client receiving the refund\\n    /// @param _amount The amount to be refunded\\n    /// - require The client is whitelisted\\n    /// - require The refund amount is less than or equal to the supra fund\\n    function executeRefund(address _fundReceiver, uint256 _amount)\\n    external\\n    onlyOwner\\n    checkClientWhitelisted(_fundReceiver)\\n    {\\n        require(_amount <= supraFund, \\\"Insufficient funds: executing refund\\\");\\n        supraFund -= _amount;\\n        clientFund[_fundReceiver] = clientFund[_fundReceiver] + _amount;\\n        emit SupraRefunded(_fundReceiver, _amount);\\n    }\\n\\n    /// @dev Updates the address of the developer.\\n    /// Only the owner is authorized to perform this action.\\n    /// @param _newDeveloper The address of the new developer to be set.\\n    function updateDeveloper(address _newDeveloper) external onlyOwner {\\n        require(\\n            _newDeveloper != address(0),\\n            \\\"Developer address cannot be a zero address\\\"\\n        );\\n        developer = _newDeveloper;\\n    }\\n\\n    /// @dev Sets the minimum balance limit for SupraAdmin.\\n    /// @param _limit The new minimum balance limit for SupraAdmin.\\n    function updateMinBalanceSupra(uint256 _limit) external onlyOwner {\\n        minBalanceLimitSupra = _limit;\\n    }\\n\\n    /// @dev Deposits ETH into the SupraFund contract.\\n    function depositSupraFund() external payable onlyOwner {\\n        supraFund += msg.value;\\n    }\\n\\n    /// @dev Pauses withdrawals for the contract.\\n    /// Only the owner is authorized to perform this action.\\n    /// Emits a {Paused} event.\\n    function pauseWithdrawal() external onlyOwner {\\n        _pause();\\n    }\\n\\n    /// @dev Resumes withdrawals for the contract.\\n    /// Only the owner is authorized to perform this action.\\n    /// Emits an {Unpaused} event.\\n    function unpauseWithdrawal() external onlyOwner {\\n        _unpause();\\n    }\\n\\n    /// @dev Sets the generator contract address.\\n    /// Only the owner can do this.\\n    /// @param _newGenerator The new generator contract address.\\n    /// @param _newRouter The new router contract address\\n    function updateGeneratorRouter(address _newGenerator, address _newRouter)\\n    external\\n    onlyOwner\\n    {\\n        require(\\n            isContract(_newGenerator) && isContract(_newRouter),\\n            \\\"Address cannot be a wallet address\\\"\\n        );\\n        require(\\n            _newGenerator != address(0) && _newRouter != address(0),\\n            \\\"Contract address cannot be a zero address\\\"\\n        );\\n        generator = _newGenerator;\\n        router = _newRouter;\\n    }\\n\\n    /**\\n        #######################################################################################\\n            :::::::::::::::::::::: WHITELISTED CLIENT OPERATIONS ::::::::::::::::::::::::\\n        #######################################################################################\\n    */\\n\\n    /// @dev Allows a client to add a contract to their whitelist.\\n    /// @param _contractAddress The address of the contract being added.\\n    function addContractToWhitelist(address _contractAddress)\\n    external\\n    checkClientWhitelisted(msg.sender)\\n    {\\n        require(isContract(_contractAddress), \\\"Address cannot be EOA\\\");\\n        bool result = contractWhitelisted[msg.sender].add(_contractAddress);\\n        require(result, \\\"Contract is Already whitelisted\\\");\\n        emit ContractWhitelisted(msg.sender, _contractAddress, block.timestamp);\\n    }\\n\\n    /// @dev Removes a contract from a client's whitelist.\\n    /// Only the client who added the contract can remove it.\\n    /// @param _contractAddress The address of the contract to remove.\\n    function removeContractFromWhitelist(address _contractAddress) external {\\n        bool result = contractWhitelisted[msg.sender].remove(_contractAddress);\\n        require(result, \\\"Contract is not whitelisted or already removed\\\");\\n        emit ContractsDeletedFromWhitelist(_contractAddress, block.timestamp);\\n    }\\n\\n    /// @dev Allows a client to deposit funds into their account.\\n    function depositFundClient()\\n    external\\n    payable\\n    checkClientWhitelisted(msg.sender)\\n    {\\n        clientFund[msg.sender] = clientFund[msg.sender] + msg.value;\\n        emit ClientDeposited(msg.sender, msg.value);\\n    }\\n\\n    ///  @dev Sets the minimum balance limit for the calling client.\\n    ///  @param _limit The new minimum balance limit for the calling client.\\n    function setMinBalanceClient(uint256 _limit)\\n    external\\n    checkClientWhitelisted(msg.sender)\\n    {\\n        require(\\n            _limit >= minBalanceLimitSupra,\\n            \\\"Cannot set a lower limit than the limit set by the deployer\\\"\\n        );\\n        minBalanceLimitClient[msg.sender] = _limit;\\n        emit MinBalanceClientSet(msg.sender, _limit);\\n    }\\n\\n    /// @dev Allows a client to withdraw their funds.\\n    /// @param _amount The amount to be withdrawn.\\n    /// Emits a ClientWithdrawal event.\\n    function withdrawFundClient(uint256 _amount) external whenNotPaused {\\n        require(\\n            _amount <= checkClientFund(msg.sender),\\n            \\\"Insufficient Funds: Fund withdrawing by user\\\"\\n        );\\n        clientFund[msg.sender] = checkClientFund(msg.sender) - _amount;\\n        (bool sent, bytes memory data) = payable(msg.sender).call{\\n                value: _amount\\n            }(\\\"\\\");\\n        require(sent, \\\"Cannot withdraw client funds\\\");\\n        emit ClientWithdrwal(msg.sender, _amount);\\n    }\\n\\n    /**\\n        #######################################################################################\\n            ::::::::::::::::::::::::: GENERATOR RELATED FUNCTIONS ::::::::::::::::::::::::\\n        #######################################################################################\\n    */\\n\\n    /// @dev Allows the generator contract to collect funds from a client's balance.\\n    /// @param _clientAddress The address of the client whose funds are being collected.\\n    /// @param _amount The amount of funds to be collected.\\n    function collectFund(address _clientAddress, uint256 _amount)\\n    external\\n    override\\n    {\\n        require(\\n            msg.sender == generator,\\n            \\\"Caller is not the owner: Only Generator can collect funds\\\"\\n        );\\n        require(\\n            _amount <= checkClientFund(_clientAddress),\\n            \\\"Insufficient Funds: Collecting funds by generator\\\"\\n        );\\n        clientFund[_clientAddress] = clientFund[_clientAddress] - _amount;\\n        supraFund = supraFund + _amount;\\n        emit SupraCollected(_clientAddress, _amount);\\n    }\\n\\n    /// @dev Returns the fund balance of the specified client address.\\n    /// Only authorized callers, including the whitelisted client, developer, owner, and generator, can perform this action.\\n    /// @param _clientAddress The address of the client whose fund balance is to be checked.\\n    /// @return The fund balance of the specified client address.\\n    function checkClientFund(address _clientAddress)\\n    public\\n    view\\n    override\\n    checkClientWhitelisted(_clientAddress)\\n    returns (uint256)\\n    {\\n        address s = msg.sender;\\n        require(\\n            s == _clientAddress ||\\n            s == developer ||\\n            s == owner() ||\\n            s == generator ||\\n            s == router,\\n            \\\"Unauthorized Access: Address not allowed to check funds\\\"\\n        );\\n        return clientFund[_clientAddress];\\n    }\\n\\n    /**\\n        #######################################################################################\\n            :::::::::::::::::::::: ROUTER RELATED FUNCTIONS ::::::::::::::::::::::::\\n        #######################################################################################\\n    */\\n\\n    /// @dev Returns a boolean indicating whether the given client and contract addresses are eligible for interaction.\\n    /// @param _clientAddress The address of the client.\\n    /// @param _contractAddress The address of the contract.\\n    /// @return A boolean indicating whether the given client and contract addresses are eligible for interaction.\\n    function isContractEligible(\\n        address _clientAddress,\\n        address _contractAddress\\n    )\\n    public\\n    view\\n    override\\n    checkClientWhitelisted(_clientAddress)\\n    returns (bool)\\n    {\\n        return (isContractWhitelisted(_clientAddress, _contractAddress));\\n    }\\n\\n    /// @dev Checks whether the minimum balance for a given client address has been reached.\\n    /// @param _clientAddress The client address to check.\\n    /// @return A boolean indicating whether the minimum balance for the given client address has been reached.\\n    function isMinimumBalanceReached(address _clientAddress)\\n    public\\n    view\\n    override\\n    checkClientWhitelisted(_clientAddress)\\n    returns (bool)\\n    {\\n        address s = msg.sender;\\n        require(\\n            s == _clientAddress ||\\n            s == developer ||\\n            s == owner() ||\\n            s == generator ||\\n            s == router,\\n            \\\"Unauthorized Access: Address cannot check minimum balance\\\"\\n        );\\n        return (checkClientFund(_clientAddress) <=\\n        checkMinBalance(_clientAddress));\\n    }\\n\\n    /**\\n        #######################################################################################\\n            :::::::::::::::::::::: ADMIN + APPROVER OPERATIONS ::::::::::::::::::::::::\\n        #######################################################################################\\n    */\\n\\n    /// @dev Propose a new cold wallet address\\n    /// @param _newColdWallet The address of the new cold wallet\\n    function proposeColdWallet(address _newColdWallet) external onlyOwner {\\n        _tempWallet = _newColdWallet;\\n        adminFeelsOK = true;\\n    }\\n\\n    /// @dev Confirm a proposed cold wallet address\\n    /// @notice This function can only be executed by the approver\\n    /// @notice The proposal must be confirmed by the owner before the cold wallet can be updated\\n    /// - require The proposal is ready to be confirmed\\n    function confirmColdWallet() external {\\n        require(\\n            msg.sender == approver,\\n            \\\"Unauthorized Access: Only Approver can confirm\\\"\\n        );\\n        require(adminFeelsOK, \\\"Cold wallet propose not ready\\\");\\n        coldWallet = _tempWallet;\\n        adminFeelsOK = false;\\n        emit ColdWalletConfirmed(coldWallet);\\n    }\\n\\n    /**\\n        #######################################################################################\\n            :::::::::::::::::::::: CRON AND SCRIPT RELATED FUNCTIONS ::::::::::::::::::::::::\\n        #######################################################################################\\n    */\\n\\n    /// @dev Returns an array of whitelisted client addresses along with their respective fund balances and minimum balance requirements.\\n    /// @return A tuple of three arrays: (1) an array of whitelisted client addresses, (2) an array of their fund balances, and (3) an array of their minimum balance requirements.\\n    function checkBalanceAllWhitelisted()\\n    external\\n    view\\n    returns (\\n        address[] memory,\\n        uint256[] memory,\\n        uint256[] memory\\n    )\\n    {\\n        address s = msg.sender;\\n        require(\\n            s == developer || s == owner(),\\n            \\\"Unauthorized Access: Only developer or deployer can check the balance\\\"\\n        );\\n        uint256 count = countTotalWhitelistedClient();\\n        address[] memory _clients = listAllWhitelistedClient();\\n\\n        uint256[] memory _funds = new uint256[](count);\\n        uint256[] memory _minBalance = new uint256[](count);\\n\\n        for (uint256 loop = 0; loop < count; loop++) {\\n            address client = _clients[loop];\\n            _funds[loop] = clientFund[client];\\n            _minBalance[loop] = checkMinBalance(client);\\n        }\\n\\n        return (_clients, _funds, _minBalance);\\n    }\\n\\n    /// @dev Returns the minimum balance limit for the SupraAdmin.\\n    /// @return The minimum balance limit for the SupraAdmin.\\n    function checkMinBalanceSupra() public view returns (uint256) {\\n        return minBalanceLimitSupra;\\n    }\\n\\n    /// @dev Returns the total number of whitelisted clients.\\n    /// @return The total number of whitelisted clients.\\n    function countTotalWhitelistedClient() public view returns (uint256) {\\n        return whitelist.length();\\n    }\\n\\n    /**\\n        #######################################################################################\\n            ::::::::::::::::::::::::: RESTRICTED VIEW FUNCTIONS ::::::::::::::::::::::::\\n        #######################################################################################\\n    */\\n\\n    /// @dev Returns the effective balance for a given client address.\\n    /// @param _clientAddress The client address to check.\\n    /// @return The effective balance for the given client address.\\n    function checkEffectiveBalance(address _clientAddress)\\n    public\\n    view\\n    checkClientWhitelisted(_clientAddress)\\n    returns (uint256)\\n    {\\n        address s = msg.sender;\\n        require(\\n            s == _clientAddress || s == developer || s == owner(),\\n            \\\"Unauthorized Access: Cannot check effective balance\\\"\\n        );\\n        uint256 balance;\\n        if (checkClientFund(_clientAddress) > checkMinBalance(_clientAddress)) {\\n            balance =\\n            checkClientFund(_clientAddress) -\\n            checkMinBalance(_clientAddress);\\n        }\\n        return balance;\\n    }\\n\\n    /// @dev Returns the number of contracts whitelisted by a client.\\n    /// @param _clientAddress The client address to check.\\n    /// @return The number of contracts whitelisted by the client.\\n    function countTotalWhitelistedContractByClient(address _clientAddress)\\n    public\\n    view\\n    checkClientWhitelisted(_clientAddress)\\n    returns (uint256)\\n    {\\n        address s = msg.sender;\\n        require(\\n            s == _clientAddress ||\\n            s == developer ||\\n            s == owner() ||\\n            s == generator,\\n            \\\"Unauthorized Access: Cannot check the total count\\\"\\n        );\\n        return contractWhitelisted[_clientAddress].length();\\n    }\\n\\n    /// @dev Get subscription information for a client.\\n    /// @param _clientAddress The client's address.\\n    /// @return A tuple containing the start timestamp and the end timestamp of the subscription period.\\n    function getSubscriptionInfoByClient(address _clientAddress)\\n    external\\n    view\\n    checkClientWhitelisted(_clientAddress)\\n    returns (\\n        uint256,\\n        uint256,\\n        bool\\n    )\\n    {\\n        address s = msg.sender;\\n        require(\\n            s == _clientAddress ||\\n            s == developer ||\\n            s == owner() ||\\n            s == generator,\\n            \\\"Unauthorized Access: Cannot check the subscription info\\\"\\n        );\\n        Subscription memory subscription = subscriptionPeriod[_clientAddress];\\n        return (\\n        subscription.startDate,\\n        subscription.endDate,\\n        subscription.isSnap\\n        );\\n    }\\n\\n    /// @dev Check if a contract is whitelisted for a client\\n    /// @param _clientAddress The address of the client\\n    /// @param _contractAddress The address of the contract to check\\n    /// @return A boolean indicating whether the contract is whitelisted\\n    function isContractWhitelisted(\\n        address _clientAddress,\\n        address _contractAddress\\n    ) public view checkClientWhitelisted(_clientAddress) returns (bool) {\\n        address s = msg.sender;\\n        require(\\n            s == _clientAddress ||\\n            s == developer ||\\n            s == owner() ||\\n            s == generator ||\\n            s == router,\\n            \\\"Unauthorized Access: Cannot check for the whitelisted contract\\\"\\n        );\\n        return contractWhitelisted[_clientAddress].contains(_contractAddress);\\n    }\\n\\n    /// @dev Returns an array of all whitelisted contracts for a specified client address.\\n    /// Only authorized callers, including the whitelisted client, developer, and owner, can perform this action.\\n    /// @param _clientAddress The address of the client whose whitelisted contracts are to be listed.\\n    /// @return An array of all whitelisted contracts for the specified client address.\\n    function listAllWhitelistedContractByClient(address _clientAddress)\\n    external\\n    view\\n    checkClientWhitelisted(_clientAddress)\\n    returns (address[] memory)\\n    {\\n        address s = msg.sender;\\n        require(\\n            s == _clientAddress || s == developer || s == owner(),\\n            \\\"Unauthorized Access: Cannot check the list of whitelisted contracts\\\"\\n        );\\n        require(_clientAddress != address(0), \\\"User address cannot be zero\\\");\\n        uint256 totalContracts = contractWhitelisted[_clientAddress].length();\\n\\n        address[] memory contracts = new address[](totalContracts);\\n        uint256 count = 0;\\n        for (count; count < totalContracts; count++) {\\n            address contractAddress = contractWhitelisted[_clientAddress].at(\\n                count\\n            );\\n            contracts[count] = contractAddress;\\n        }\\n        if (count == 0) {\\n            return new address[](0);\\n        }\\n        return contracts;\\n    }\\n\\n    /// @dev Returns an array of all whitelisted clients.\\n    /// @return An array of all whitelisted client addresses.\\n    function listAllWhitelistedClient() public view returns (address[] memory) {\\n        address s = msg.sender;\\n        require(\\n            s == developer || s == owner(),\\n            \\\"Unauthorized Access: Cannot list whitelisted clients\\\"\\n        );\\n        address[] memory clients = new address[](whitelist.length());\\n        for (uint256 i = 0; i < whitelist.length(); i++) {\\n            address value = whitelist.at(i);\\n            clients[i] = value;\\n        }\\n        return clients;\\n    }\\n\\n    /// @dev Returns the current balance of the SupraFund contract.\\n    /// @return The current balance of the SupraFund contract.\\n    function checkSupraFund() external view returns (uint256) {\\n        require(\\n            msg.sender == owner() || msg.sender == developer,\\n            \\\"Unauthorized Access: Cannot check supra funds\\\"\\n        );\\n        return supraFund;\\n    }\\n\\n    /**\\n        #######################################################################################\\n               :::::::::::::::::::::::::: PUBLIC FUNCTIONS :::::::::::::::::::::::::\\n        #######################################################################################\\n    */\\n\\n    /// @dev Checks if a client is whitelisted.\\n    /// @param _clientAddress The client address to check.\\n    /// @return True if the client is whitelisted, false otherwise.\\n    function isClientWhitelisted(address _clientAddress)\\n    public\\n    view\\n    returns (bool)\\n    {\\n        return whitelist.contains(_clientAddress);\\n    }\\n\\n    /// @dev Returns the minimum balance limit for a given client address.\\n    /// @param _clientAddress The client address to check.\\n    /// @return The minimum balance limit for the given client address.\\n    function checkMinBalance(address _clientAddress)\\n    public\\n    view\\n    override\\n    returns (uint256)\\n    {\\n        uint256 limit;\\n        if (checkMinBalanceClient(_clientAddress) > checkMinBalanceSupra()) {\\n            limit = checkMinBalanceClient(_clientAddress);\\n        } else {\\n            limit = checkMinBalanceSupra();\\n        }\\n        return limit;\\n    }\\n\\n    /**\\n        #######################################################################################\\n               :::::::::::::::::::::::: INETRNAL FUNCTIONS ::::::::::::::::::::::::\\n        #######################################################################################\\n    */\\n    /// @dev Returns the minimum balance limit for a given client address.\\n    /// @param _clientAddress The client address to check.\\n    /// @return The minimum balance limit for the given client address.\\n    function checkMinBalanceClient(address _clientAddress)\\n    internal\\n    view\\n    returns (uint256)\\n    {\\n        return minBalanceLimitClient[_clientAddress];\\n    }\\n\\n    /// @dev Add subscription information for a client\\n    /// @param _clientAddress The address of the client\\n    /// @param _start The start timestamp of the subscription\\n    /// @param _end The end timestamp of the subscription\\n    /// @param _isSnap A flag indicating whether the subscription is a snapshot subscription\\n    function addSubscriptionInfoByClient(\\n        address _clientAddress,\\n        uint256 _start,\\n        uint256 _end,\\n        bool _isSnap\\n    ) internal {\\n        subscriptionPeriod[_clientAddress] = Subscription(\\n            _start,\\n            _end,\\n            _isSnap\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"src/EnumerableSet.sol\": {\r\n      \"content\": \"/**\\n    ###############################################################\\n        this is not exact replica of OpenZepplin implementation\\n    ###############################################################\\n*/\\n\\n// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity 0.8.19;\\n\\nlibrary EnumerableSet {\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n        ###################################################################################\\n            :::: this is the new method added on top of openzepplin implementation ::::\\n        ###################################################################################\\n    */\\n    function _clear(Set storage set) private returns (bool) {\\n        for (uint256 i = 0; i < set._values.length; i++) {\\n            delete set._indexes[set._values[i]];\\n        }\\n        delete set._values;\\n        return true;\\n    }\\n\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value)\\n    private\\n    view\\n    returns (bool)\\n    {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    function _at(Set storage set, uint256 index)\\n    private\\n    view\\n    returns (bytes32)\\n    {\\n        return set._values[index];\\n    }\\n\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    function add(Bytes32Set storage set, bytes32 value)\\n    internal\\n    returns (bool)\\n    {\\n        return _add(set._inner, value);\\n    }\\n\\n    function remove(Bytes32Set storage set, bytes32 value)\\n    internal\\n    returns (bool)\\n    {\\n        return _remove(set._inner, value);\\n    }\\n\\n    function contains(Bytes32Set storage set, bytes32 value)\\n    internal\\n    view\\n    returns (bool)\\n    {\\n        return _contains(set._inner, value);\\n    }\\n\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function at(Bytes32Set storage set, uint256 index)\\n    internal\\n    view\\n    returns (bytes32)\\n    {\\n        return _at(set._inner, index);\\n    }\\n\\n    function values(Bytes32Set storage set)\\n    internal\\n    view\\n    returns (bytes32[] memory)\\n    {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    function add(AddressSet storage set, address value)\\n    internal\\n    returns (bool)\\n    {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function clear(AddressSet storage set) internal returns (bool) {\\n        return _clear(set._inner);\\n    }\\n\\n    function remove(AddressSet storage set, address value)\\n    internal\\n    returns (bool)\\n    {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function contains(AddressSet storage set, address value)\\n    internal\\n    view\\n    returns (bool)\\n    {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function at(AddressSet storage set, uint256 index)\\n    internal\\n    view\\n    returns (address)\\n    {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    function values(AddressSet storage set)\\n    internal\\n    view\\n    returns (address[] memory)\\n    {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    function remove(UintSet storage set, uint256 value)\\n    internal\\n    returns (bool)\\n    {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    function contains(UintSet storage set, uint256 value)\\n    internal\\n    view\\n    returns (bool)\\n    {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function at(UintSet storage set, uint256 index)\\n    internal\\n    view\\n    returns (uint256)\\n    {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    function values(UintSet storage set)\\n    internal\\n    view\\n    returns (uint256[] memory)\\n    {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Ownable2Step.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (access/Ownable2Step.sol)\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\n *\\n * This module is used through inheritance. It will make available all functions\\n * from parent (Ownable).\\n */\\nabstract contract Ownable2Step is Ownable {\\n    address private _pendingOwner;\\n\\n    event OwnershipTransferStarted(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner)\\n    public\\n    virtual\\n    override\\n    onlyOwner\\n    {\\n        _pendingOwner = newOwner;\\n        emit OwnershipTransferStarted(owner(), newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual override {\\n        delete _pendingOwner;\\n        super._transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev The new owner accepts the ownership transfer.\\n     */\\n    function acceptOwnership() public virtual {\\n        address sender = _msgSender();\\n        require(\\n            pendingOwner() == sender,\\n            \\\"Ownable2Step: caller is not the new owner\\\"\\n        );\\n        _transferOwnership(sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"src/IDepositContract.sol\": {\r\n      \"content\": \"// INSTRUCTIONS : Contains methods that will be used by the ROUTER and GENERATOR contracts.\\n// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\ninterface IDepositContract {\\n    function isContractEligible(\\n        address _clientAddress,\\n        address _contractAddress\\n    ) external view returns (bool);\\n\\n    function isMinimumBalanceReached(address _clientAddress)\\n    external\\n    view\\n    returns (bool);\\n\\n    function checkMinBalance(address _clientAddress)\\n    external\\n    view\\n    returns (uint256);\\n\\n    function checkClientFund(address _clientAddress)\\n    external\\n    view\\n    returns (uint256);\\n\\n    function collectFund(address _clientAddress, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"src/CheckContractAddress.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\ncontract CheckContractAddress {\\n    /// @dev Returns a boolean indicating whether the given address is a contract or not.\\n    /// @param _addr The address to be checked.\\n    /// @return A boolean indicating whether the given address is a contract or not.\\n    function isContract(address _addr) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(_addr)\\n        }\\n        return size > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity 0.8.19;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(\\n            newOwner != address(0),\\n            \\\"Ownable: new owner is the zero address\\\"\\n        );\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity 0.8.19;\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\"\r\n    ],\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_approver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_developer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newGenerator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newRouter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minBalanceLimitSupra\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_depositer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClientDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_clientAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_removedTime\",\"type\":\"uint256\"}],\"name\":\"ClientRemovedFromWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_clientAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_endTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_isSnap\",\"type\":\"bool\"}],\"name\":\"ClientWhitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_withdrawer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClientWithdrwal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_coldWalletAddress\",\"type\":\"address\"}],\"name\":\"ColdWalletConfirmed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_clientAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timeStamp\",\"type\":\"uint256\"}],\"name\":\"ContractWhitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_clientAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_removedTime\",\"type\":\"uint256\"}],\"name\":\"ContractsDeletedFromWhitelist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_clientAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"MinBalanceClientSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_fromClient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SupraCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_toClient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SupraRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_tempWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_clientAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isSnap\",\"type\":\"bool\"}],\"name\":\"addClientToWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"}],\"name\":\"addContractToWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminFeelsOK\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"approver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkBalanceAllWhitelisted\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_clientAddress\",\"type\":\"address\"}],\"name\":\"checkClientFund\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_clientAddress\",\"type\":\"address\"}],\"name\":\"checkEffectiveBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_clientAddress\",\"type\":\"address\"}],\"name\":\"checkMinBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkMinBalanceSupra\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkSupraFund\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"claimFreeNodeExpenses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coldWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_clientAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"collectFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"confirmColdWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"countTotalWhitelistedClient\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_clientAddress\",\"type\":\"address\"}],\"name\":\"countTotalWhitelistedContractByClient\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositFundClient\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositSupraFund\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"developer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fundReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"executeRefund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"generator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_clientAddress\",\"type\":\"address\"}],\"name\":\"getSubscriptionInfoByClient\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_clientAddress\",\"type\":\"address\"}],\"name\":\"isClientWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_clientAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"}],\"name\":\"isContractEligible\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_clientAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"}],\"name\":\"isContractWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_clientAddress\",\"type\":\"address\"}],\"name\":\"isMinimumBalanceReached\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"listAllWhitelistedClient\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_clientAddress\",\"type\":\"address\"}],\"name\":\"listAllWhitelistedContractByClient\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseWithdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newColdWallet\",\"type\":\"address\"}],\"name\":\"proposeColdWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_clientAddress\",\"type\":\"address\"}],\"name\":\"removeAllContractOfClient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_clientAddress\",\"type\":\"address\"}],\"name\":\"removeClientFromWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"}],\"name\":\"removeContractFromWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"setMinBalanceClient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpauseWithdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newDeveloper\",\"type\":\"address\"}],\"name\":\"updateDeveloper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newGenerator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newRouter\",\"type\":\"address\"}],\"name\":\"updateGeneratorRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"updateMinBalanceSupra\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_clientAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_newEndTime\",\"type\":\"uint256\"}],\"name\":\"updateSubscription\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFundClient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DepositContract", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000003e8bd1b597ad9d222d4c4dea7e8cd2124cb6571e00000000000000000000000090092d2cff47ed01785bc0cebb9c689207866c0800000000000000000000000044c26a6a709e02725d7d09d398b5637ad6ee43d900000000000000000000000049572e73d4001a922d3a574b3bcdf666a1167743000000000000000000000000000000000000000000000000002386f26fc10000", "EVMVersion": "paris", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f1b42394d674f5a993cb41126de3c56a76bad92292236c07bcbf72b0a5d66ad6"}