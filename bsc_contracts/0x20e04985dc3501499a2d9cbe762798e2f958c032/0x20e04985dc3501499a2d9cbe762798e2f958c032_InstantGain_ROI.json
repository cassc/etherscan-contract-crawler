{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.19;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address account) external view returns (uint);\r\n    function transfer(address recipient, uint amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function approve(address spender, uint amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ninterface IInstantGain{\r\n    function users(address userAddress) external view returns (\r\n        uint256 id,\r\n        uint256 joinDate,\r\n        uint256 checkpoint,\r\n        uint256 originReferrer,\r\n        uint256 mainReferrer,\r\n        uint256 available,\r\n        uint256 downlineCount,\r\n        uint256 totalDirectCommission,\r\n        uint256 missedDirectCommission,\r\n        uint256 currentSearchIndex,\r\n        uint256 reactivateCount,\r\n        uint256 paidCommission\r\n    );\r\n    function userReactiveStatus(address userAddress) external view returns (bool);\r\n}\r\n\r\nlibrary SafeERC20 {\r\n\r\n    function safeTransfer(IERC20 token, address to, uint value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint value) internal {\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        require(isContract(address(token)), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n\r\n\tfunction isContract(address addr) internal view returns (bool) {\r\n        uint size;\r\n        assembly { size := extcodesize(addr) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n\r\nabstract contract ReentrancyGuard {\r\n    bool internal locked;\r\n\r\n    modifier noReentrant() {\r\n        require(!locked, \"No re-entrancy\");\r\n        locked = true;\r\n        _;  \r\n        locked = false;\r\n    }\r\n}\r\ncontract InstantGain_ROI is ReentrancyGuard {\r\n\tusing SafeERC20 for IERC20;\r\n\r\n\taddress private tokenAddr = address(0x55d398326f99059fF775485246999027B3197955);\r\n    address private mainContact = address(0x520d0516bd176D8f3C1d0Ca328E24C2c9dd4A6C5);\r\n    address public ownerWallet;\r\n    IERC20 public token;\r\n\r\n\tuint256 constant private PERCENTS_DIVIDER = 1000;\r\n    uint256 constant private ACTIVATE_PRICE = 50 ether;\r\n    uint256 constant private ROI_PROFIT = 1 ether;\r\n    uint256 constant private PROFIT_LIMIT = 50 ether;\r\n    uint256 constant private TIME_STEP = 1 days;\r\n\r\n    struct UserStruct {\r\n        uint256 roiCheckpoint;\r\n        uint256 claimed;\r\n\t}\r\n\r\n\tmapping (address => UserStruct) public usersRoi;\r\n\r\n\tuint256 public totalClaimed;\r\n    uint256 public startRoi;\r\n\r\n\r\n\tevent ClaimROI(address userAddress, uint256 timestamp);\r\n\r\n\tconstructor() {\r\n\t\ttoken = IERC20(tokenAddr);\r\n        ownerWallet = address(0x0Fb85ae76698c198Ca4d765Cdd2510a3F71616eA);\r\n        startRoi = block.timestamp - TIME_STEP;\r\n\t}\r\n\r\n    function claimProfit() public noReentrant {\r\n        (,\r\n            uint256 joinDate,\r\n            uint256 checkpoint,\r\n            ,,,,,,,,\r\n            uint256 paidCommission\r\n        ) = IInstantGain(mainContact).users(msg.sender);\r\n\r\n        require(checkpoint >= startRoi, \"Roi not started for this user\");\r\n        require(joinDate > 0, \"User is not active in the main contract\");\r\n        require(usersRoi[msg.sender].claimed < PROFIT_LIMIT, \"Total ROI claim should be less than 50 USDT\");\r\n        require(paidCommission < PROFIT_LIMIT, \"Total Commission claim should be less than 50 USDT in the main contract\");\r\n        require(checkpoint + TIME_STEP <= block.timestamp, \"Not time to claim in main contract\");\r\n        require(usersRoi[msg.sender].roiCheckpoint < checkpoint, \"Claim only once per day\");\r\n\r\n        usersRoi[msg.sender].claimed += ROI_PROFIT;\r\n        usersRoi[msg.sender].roiCheckpoint = block.timestamp;\r\n        totalClaimed += ROI_PROFIT;\r\n\r\n        token.safeTransfer(msg.sender, ROI_PROFIT);\r\n        emit ClaimROI(msg.sender, block.timestamp);\r\n    }\r\n\r\n\r\n    function getUserDividends(address userAddress) public view returns (uint256) {\r\n        (,\r\n            uint256 joinDate,\r\n            uint256 checkpoint,\r\n            ,,,,,,,,\r\n            uint256 paidCommission\r\n        ) = IInstantGain(mainContact).users(userAddress);\r\n\r\n        if(checkpoint < startRoi || joinDate == 0 || usersRoi[userAddress].roiCheckpoint > checkpoint || \r\n            usersRoi[userAddress].claimed >= PROFIT_LIMIT || paidCommission >= PROFIT_LIMIT){\r\n            return 0;\r\n        }\r\n\t\tuint256 totalAmount;\r\n        \r\n        uint256 share = ACTIVATE_PRICE + ROI_PROFIT;\r\n        uint256 from = checkpoint;\r\n        uint256 to =  block.timestamp;\r\n        if (from < to) {\r\n            uint256 duration = to - from > TIME_STEP ? TIME_STEP : to - from;\r\n            totalAmount = share * duration / TIME_STEP;\r\n        }\r\n\t\treturn totalAmount;\r\n\t}\r\n\r\n    function roiStatus(address userAddress) public view returns (bool) {\r\n        (,\r\n            uint256 joinDate,\r\n            uint256 checkpoint,\r\n            ,,,,,,,,\r\n            uint256 paidCommission\r\n        ) = IInstantGain(mainContact).users(userAddress);\r\n\r\n        if(checkpoint >= startRoi && joinDate > 0 && usersRoi[userAddress].claimed < PROFIT_LIMIT && paidCommission < PROFIT_LIMIT && \r\n            checkpoint + TIME_STEP > block.timestamp){\r\n            return true;\r\n        } else{\r\n            return false;\r\n        }\r\n\t}\r\n\r\n    function isClaimed(address userAddress) public view returns (bool) {\r\n        (,\r\n            uint256 joinDate,\r\n            uint256 checkpoint,\r\n            ,,,,,,,,\r\n        ) = IInstantGain(mainContact).users(userAddress);\r\n        if(checkpoint < startRoi){\r\n            return true;\r\n        }\r\n        if(joinDate > 0 && checkpoint + TIME_STEP <= block.timestamp && usersRoi[userAddress].roiCheckpoint > checkpoint){\r\n            return true;\r\n        } else{\r\n            return false;\r\n        }\r\n\t}\r\n\r\n    function Refund(uint256 amount) public {\r\n        require(msg.sender == ownerWallet, \"Only onwer\");\r\n        uint256 finalAmount = amount == 0 || amount >= token.balanceOf(address(this)) ? token.balanceOf(address(this)) : amount;\r\n        token.safeTransfer(msg.sender, finalAmount);\r\n\t}\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"ClaimROI\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimProfit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserDividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"isClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"roiStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startRoi\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"usersRoi\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"roiCheckpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "InstantGain_ROI", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b1a9a8962a2b9823ec45fa892eb299fcea653943baf687728f42e4c7c58a04fa"}