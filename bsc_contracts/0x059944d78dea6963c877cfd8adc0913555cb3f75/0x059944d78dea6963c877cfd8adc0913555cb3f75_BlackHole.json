{"SourceCode": "/**\r\n *Submitted for verification at BscScan.com on 2023-11-12\r\n*/\r\n// 0x3Df75c76062292d31d342ee73eB626A9A0eFa9e6\r\n// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.18;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant NOT_ENTERED = 1;\r\n    uint256 private constant ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    /**\r\n     * @dev Unauthorized reentrant call.\r\n     */\r\n    error ReentrancyGuardReentrantCall();\r\n\r\n    constructor() {\r\n        _status = NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\r\n        if (_status == ENTERED) {\r\n            revert ReentrancyGuardReentrantCall();\r\n        }\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\r\n     * `nonReentrant` function in the call stack.\r\n     */\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _status == ENTERED;\r\n    }\r\n}\r\n\r\nlibrary DateTime {\r\n    /*\r\n     *  Date and Time utilities for ethereum contracts\r\n     *\r\n     */\r\n\r\n    function getNowDateTime() public view returns (uint32) {\r\n        uint256 ts = block.timestamp + 8 hours;\r\n        return uint32(ts / 1 days);\r\n    }\r\n\r\n    function tsToDateTime(uint256 ts) public pure returns (uint32) {\r\n        return uint32((ts + 8 hours) / 1 days);\r\n    }\r\n}\r\n\r\ninterface IPancakeFactory {\r\n    function getPair(\r\n        address tokenA,\r\n        address tokenB\r\n    ) external view returns (address pair);\r\n}\r\n\r\ninterface IERC20 {\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function mint(uint256 amount) external returns (uint256);\r\n\r\n    function destroy(uint256 amount) external returns (uint256);\r\n\r\n    function getPrice() external view returns (uint256);\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n}\r\n\r\ninterface ISwapRouter {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n\r\n    function getAmountsOut(\r\n        uint amountIn,\r\n        address[] calldata path\r\n    ) external view returns (uint[] memory amounts);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n}\r\n\r\nabstract contract Ownable {\r\n    address internal _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() {\r\n        address msgSender = msg.sender;\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"!o\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"n0\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract PublicReward {\r\n    constructor(address USDT, address HD) {\r\n        IERC20(USDT).approve(msg.sender, ~uint256(0));\r\n        IERC20(HD).approve(msg.sender, ~uint256(0));\r\n    }\r\n}\r\n\r\ncontract BlackHole is Ownable, ReentrancyGuard {\r\n\r\n\r\n    PublicReward public publicReward;\r\n    ISwapRouter router;\r\n    IUniswapV2Pair pair;\r\n    mapping(uint256 => mapping(uint256 => address)) public floorUsers;\r\n    mapping(address => User) users;\r\n    mapping(bytes32 => bool) verifiedMessage;\r\n    uint256 public  Lprice;\r\n    // \u6bcf\u4e00\u7ea7\u6240\u9700\u8981\u7684\u6295\u8d44\u989d\r\n    uint256[] public levelPrice = [\r\n        20,\r\n        50,\r\n        100,\r\n        200,\r\n        500\r\n    ];\r\n\r\n\r\n\r\n    IERC20 USDT;\r\n    IERC20 HD;\r\n\r\n\r\n\r\n    address deadAddress = 0x000000000000000000000000000000000000dEaD;\r\n\r\n    // after\r\n    event Buy(address indexed user, uint256 amount);\r\n    event Sell(address indexed user, uint256 amount);\r\n    event Upgrade(address indexed user, address indexed leader, uint256 level);\r\n     constructor(\r\n        // address _usdt,\r\n        // address _hdToken,\r\n        // address _router,\r\n        // address _factory\r\n \r\n    ) {\r\n        USDT = IERC20(0xA99f47Eacf07833147ee2ccbFc7b7c54184956fC);\r\n        HD = IERC20(0xf85F09B93Cb2688cB2664Ad56660A799553Bce7F);\r\n        router = ISwapRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n        pair = IUniswapV2Pair(\r\n            IPancakeFactory(0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73).getPair(0xA99f47Eacf07833147ee2ccbFc7b7c54184956fC, 0x4c5d122CF8da182b9EfFcCBa746aF66D346Ec3be)\r\n        );\r\n        publicReward = new PublicReward(address(USDT), address(HD));\r\n        Team storage topUser = users[deadAddress].team;\r\n        topUser.floor = 1;\r\n        topUser.index = 1;\r\n        topUser.add = deadAddress;\r\n        floorUsers[1][1] = deadAddress;\r\n\r\n      \r\n    }\r\n\r\n\r\n\r\n    modifier noContract() {\r\n        require(tx.origin == msg.sender, \"contract not allowed\");\r\n        uint256 size;\r\n        address addr = msg.sender;\r\n        assembly {\r\n            size := extcodesize(addr)\r\n        }\r\n\r\n        require(!(size > 0), \"contract not allowed\");\r\n        _;\r\n    }\r\n\r\n\r\n    function _invite(address add, address _leader) private {\r\n        inviteProxy(add,_leader);\r\n   \r\n    }\r\n     function getVIPprice() public view  returns(uint256,uint256,uint256,uint256,uint256){\r\n        return (levelPrice[0],levelPrice[1],levelPrice[2],levelPrice[3],levelPrice[4]);\r\n     }\r\n\r\n   \r\n    function buy(\r\n        uint256 amount\r\n  \r\n    )\r\n        external\r\n        nonReentrant\r\n        noContract\r\n        \r\n    {\r\n  \r\n        if (USDT.balanceOf(msg.sender) < amount) {\r\n            amount = USDT.balanceOf(msg.sender);\r\n        }\r\n        _buy(amount);\r\n\r\n        emit Buy(msg.sender, amount);\r\n    }\r\n\r\n    function sell(\r\n        uint256 amount\r\n\r\n    )\r\n        external\r\n        nonReentrant\r\n        noContract\r\n        \r\n    {\r\n        if (HD.balanceOf(msg.sender) < amount) {\r\n            amount = HD.balanceOf(msg.sender);\r\n        }\r\n            _sell(amount);\r\n        emit Sell(msg.sender, amount);\r\n    }\r\n\r\n    // \u5347\u7ea7\r\n    function upgrade(\r\n        address _leader\r\n    )\r\n        external\r\n        nonReentrant\r\n        noContract\r\n        \r\n    {\r\n        User storage user = users[msg.sender];\r\n        if (user.team.initTime == 0) {\r\n            _invite(msg.sender, _leader);\r\n        }\r\n         upgrade();\r\n    \r\n        emit Upgrade(msg.sender, user.team.leader, user.level);\r\n    }\r\n// invite\u9080\u8bf7\r\n    function invite(\r\n        address _leader\r\n    ) external  nonReentrant noContract  {\r\n        _invite(msg.sender, _leader);\r\n    }\r\n\r\n    function topInvite(\r\n        address _leader,\r\n        address[] memory adds\r\n    ) external onlyOwner nonReentrant noContract {\r\n        uint len = adds.length;\r\n        for (uint i = 0; i < len; i++) {\r\n            _invite(adds[i], _leader);\r\n        }\r\n    }\r\n\r\n\r\n    function approveing() external onlyOwner   {\r\n        HD.approve(address(router), ~uint256(0));\r\n        USDT.approve(address(router), ~uint256(0));\r\n        pair.approve(address(router), ~uint256(0));\r\n    }\r\n\r\n    function setaddress(address add,uint256  ty)  external onlyOwner   {\r\n        if(ty == 1){\r\n            PTAddress = add;\r\n        }\r\n           if(ty == 2){\r\n            LPfenhong = add;\r\n        }\r\n           if(ty == 3){\r\n            PTUAddress = add;\r\n        }\r\n \r\n    }\r\n\r\n \r\n\r\n\r\n    struct _Team {\r\n        address add;\r\n        uint256 initTime; // \u521d\u59cb\u5316\u65f6\u95f4\r\n        address left; // \u5de6\u8282\u70b9\r\n        address right; //  \u53f3\u8282\u70b9\r\n        address middle; //  \u4e2d\u95f4\u8282\u70b9\r\n        uint256 nextCount; // \u76f4\u63a5\u5b50\u8282\u70b9\u6570\r\n        address top; // \u7236\u8282\u70b9\r\n        address leader; // \u9886\u5bfc\r\n        uint256 childCount; // \u5b50\u8282\u70b9\u6570\r\n        uint256 floor; // \u6240\u5728\u5c42\r\n        uint256 index; // \u6240\u5728\u5c42\u7684\u5e8f\u53f7\r\n        uint256 reachFloor; // \u6700\u4e0b\u9762\u6ee1\u5c42\u7684\u8be5\u5c42\u5c42\u6570\r\n        uint256 latestIndex; // \u4e0a\u6b21\u6ed1\u843d\u6240\u5728\u7236\u8282\u70b9\u5e8f\u53f7\r\n        uint8 level; // \u7b49\u7ea7\r\n        bool effective; // \u6709\u6548\u7528\u6237\r\n        uint256 bourtUSDT; // \u53ef\u8d2d\u4e70USDT\u6570\r\n \r\n   \r\n    }\r\n\r\n    function getUsers(address _user) public view returns (_Team memory team) {\r\n        team.add = users[_user].team.add;\r\n        team.initTime = users[_user].team.initTime;\r\n        team.left = users[_user].team.left;\r\n        team.right = users[_user].team.right;\r\n        team.middle = users[_user].team.middle;\r\n        team.nextCount = users[_user].team.nextCount;\r\n        team.top = users[_user].team.top;\r\n        team.leader = users[_user].team.leader;\r\n        team.childCount = users[_user].team.childCount;\r\n        team.floor = users[_user].team.floor;\r\n        team.index = users[_user].team.index;\r\n        team.reachFloor = users[_user].team.reachFloor;\r\n        team.latestIndex = users[_user].team.latestIndex;\r\n        team.level = users[_user].level;\r\n        team.bourtUSDT = users[_user].bourtUSDT;           \r\n    }\r\n\r\n    function getTokenPrice() public view returns (uint256) {\r\n        return HD.getPrice();\r\n    }\r\n\r\n    function getlprice()public  onlyOwner{\r\n        Lprice = getTokenPrice();\r\n    }\r\n    function MOLPlprice()public  onlyOwner{\r\n       uint256 Nprice = getTokenPrice();\r\n       if(Nprice<Lprice*102/100){\r\n        uint256 lpTotalSupply = pair.totalSupply();\r\n        (uint256 USDTAmount, ) = _removeLiquidity(lpTotalSupply/50);\r\n         uint256 HDAmount = _buyHD(USDTAmount);//\u8fdb\u5165\u5206\u7ea2\u6c60\r\n        require(HD.transfer(deadAddress, HDAmount), \"dead error\");\r\n\r\n       }\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n    function inviteProxy(address add, address _leader) private {\r\n        if (_leader == address(0)) {\r\n            _leader = floorUsers[1][1];\r\n        }\r\n        Team storage user = users[add].team;\r\n        Team storage leader = users[_leader].team;\r\n        require(leader.initTime > 0, \"leader not exist\");\r\n        require(user.initTime == 0, \"user exist\");\r\n\r\n        leader.redirects.push(add);\r\n        user.leader = _leader;\r\n        user.initTime = uint64(block.timestamp);\r\n        user.add = add;\r\n        if (leader.nextCount < 3) {\r\n            uint16 lmr;\r\n            ++leader.childCount;\r\n            if (leader.left == address(0)) {\r\n                leader.left = add;\r\n                user.index = (leader.index - 1) * 3 + 1;\r\n            } else if (leader.middle == address(0)) {\r\n                lmr = 1;\r\n                leader.middle = add;\r\n                user.index = (leader.index - 1) * 3 + 2;\r\n            } else {\r\n                leader.right = add;\r\n                lmr = 2;\r\n                user.index = (leader.index - 1) * 3 + 3;\r\n                leader.reachFloor = leader.floor + 1;\r\n            }\r\n            ++leader.nextCount;\r\n            user.top = _leader;\r\n            user.floor = leader.floor + 1;\r\n            floorUsers[user.floor][user.index] = add;\r\n            // leader.floorChildcount[user.floor] += 1;\r\n            leader.floorChildInfo[user.floor][0] += 1;\r\n            _updateTop(_leader, lmr, user.floor, leader.floor, 0);\r\n        } else {\r\n            uint32 startIndex = uint32(\r\n                (leader.index - 1) *\r\n                    (3 ** (leader.reachFloor - leader.floor)) +\r\n                    1\r\n            );\r\n            uint32 endIndex = uint32(\r\n                startIndex + 3 ** (leader.reachFloor - leader.floor) - 1\r\n            );\r\n            if (leader.latestIndex > startIndex) {\r\n                startIndex = leader.latestIndex;\r\n            }\r\n            if (leader.floorChildInfo[leader.reachFloor][0] > 0) {\r\n                _updateUser(add, _leader, startIndex, endIndex, 0);\r\n            } else if (leader.floorChildInfo[leader.reachFloor][1] > 0) {\r\n                _updateUser(add, _leader, startIndex, endIndex, 1);\r\n            } else {\r\n                _updateUser(add, _leader, startIndex, endIndex, 2);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _updateTop(\r\n        address top,\r\n        uint16 lmr,\r\n        uint16 userFloor,\r\n        uint leaderFloor,\r\n        uint32 latestIndex\r\n    ) private {\r\n        uint i = 0;\r\n        Team storage topUser = users[top].team;\r\n        while (topUser.top != address(0)) {\r\n            topUser = users[topUser.top].team;\r\n            ++topUser.childCount;\r\n            \r\n            if (i < 10) {\r\n                topUser.floorChildInfo[userFloor][0] += 1;\r\n                topUser.floorChildInfo[userFloor - 1][lmr] -= 1;\r\n                topUser.floorChildInfo[userFloor - 1][lmr + 1] += 1;\r\n                if (latestIndex != 0 && topUser.floor >= leaderFloor) {\r\n                    topUser.latestIndex = latestIndex;\r\n                }\r\n                if (lmr == 2) {\r\n                    uint256 count = topUser.floorChildInfo[userFloor][0] +\r\n                        topUser.floorChildInfo[userFloor][1] +\r\n                        topUser.floorChildInfo[userFloor][2] +\r\n                        topUser.floorChildInfo[userFloor][3];\r\n                    if (count == 3 ** (userFloor - topUser.floor)) {\r\n                        topUser.reachFloor = userFloor;\r\n                        topUser.latestIndex = 1;\r\n                    }\r\n                }\r\n            }\r\n            ++i;\r\n        }\r\n    }\r\n\r\n    function _updateUser(\r\n        address _user,\r\n        address leader,\r\n        uint32 startIndex,\r\n        uint32 endIndex,\r\n        uint16 lmr\r\n    ) private {\r\n        Team storage user = users[_user].team;\r\n        for (uint32 i = startIndex; i <= endIndex; i++) {\r\n            if (\r\n                users[floorUsers[users[leader].team.reachFloor][i]]\r\n                    .team\r\n                    .nextCount == lmr\r\n            ) {\r\n                Team storage topUser = users[\r\n                    floorUsers[users[leader].team.reachFloor][i]\r\n                ].team;\r\n                user.top = topUser.add;\r\n                user.floor = users[leader].team.reachFloor + 1;\r\n                user.index = (i - 1) * 3 + 1 + lmr;\r\n                floorUsers[user.floor][user.index] = _user;\r\n                if (lmr == 0) {\r\n                    topUser.left = _user;\r\n                } else if (lmr == 1) {\r\n                    topUser.middle = _user;\r\n                } else {\r\n                    topUser.right = _user;\r\n                    topUser.reachFloor = user.floor;\r\n                }\r\n\r\n                ++topUser.nextCount;\r\n                ++topUser.childCount;\r\n                topUser.floorChildInfo[user.floor][0] += 1;\r\n                if (i == endIndex) {\r\n                    i = 1;\r\n                }\r\n                _updateTop(topUser.add, lmr, user.floor, topUser.floor, i);\r\n\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n    struct User {\r\n        Team team;\r\n        uint8 level; // \u7b49\u7ea7\r\n        bool effective; // \u6709\u6548\u7528\u6237\r\n        uint256 bourtUSDT; // \u53ef\u8d2d\u4e70USDT\u6570\r\n \r\n    }\r\n\r\n    struct Team {\r\n        address add;\r\n        address[] redirects; // \u76f4\u63a8\r\n        address left; // \u5de6\u8282\u70b9\r\n        address right; //  \u53f3\u8282\u70b9\r\n        address middle; //  \u4e2d\u95f4\u8282\u70b9\r\n        address top; // \u7236\u8282\u70b9\r\n        address leader; // \u9886\u5bfc\r\n        uint16 floor; // \u6240\u5728\u5c42\r\n        uint16 reachFloor; // \u6700\u4e0b\u9762\u6ee1\u5c42\u7684\u8be5\u5c42\u5c42\u6570\r\n        uint32 nextCount; // \u76f4\u63a5\u5b50\u8282\u70b9\u6570\r\n        uint32 childCount; // \u5b50\u8282\u70b9\u6570\r\n        uint32 index; // \u6240\u5728\u5c42\u7684\u5e8f\u53f7\r\n        uint32 latestIndex; // \u4e0a\u6b21\u6ed1\u843d\u6240\u5728\u7236\u8282\u70b9\u5e8f\u53f7\r\n        uint64 initTime; // \u521d\u59cb\u5316\u65f6\u95f4\r\n        mapping(uint32 => mapping(uint16 => uint32)) floorChildInfo; // \u4e0b\u9762\u6bcf\u5c42\u7684\u76f4\u63a5\u5b50\u8282\u4fe1\u606f\r\n    }\r\n\r\n\r\n\r\n\r\n    uint256[] public limitUSDT;\r\n\r\n\r\n    uint256[] public levelUSDTLimit;\r\n\r\n    uint256 latestdailyTotalLevelPowerTs;\r\n    uint256 latestdailyTotalLPPowerTs;\r\n\r\n\r\n\r\n\r\n    address private LPfenhong = 0x152F27414Eca702676A4169a01388B2fa648794f;\r\n    address private PTAddress= 0x152F27414Eca702676A4169a01388B2fa648794f;\r\n    address private PTUAddress= 0x152F27414Eca702676A4169a01388B2fa648794f;\r\n\r\n\r\n   \r\n\r\n   \r\n   \r\n \r\n\r\n \r\n    function _buyHD(uint256 amount) private returns (uint256) {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(USDT);\r\n        path[1] = address(HD);\r\n        uint256 HDBalance = HD.balanceOf(address(this));\r\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            amount,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        return HD.balanceOf(address(this)) - HDBalance;\r\n    }\r\n\r\n    function _getUSDTOut(uint256 HDAmount) private view returns (uint256) {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(HD);\r\n        path[1] = address(USDT);\r\n        uint256[] memory amounts = router.getAmountsOut(HDAmount, path);\r\n        return amounts[1];\r\n    }\r\n\r\n    function _getHDOut(uint256 USDTAmount) private view returns (uint256) {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(USDT);\r\n        path[1] = address(HD);\r\n        uint256[] memory amounts = router.getAmountsOut(USDTAmount, path);\r\n        return amounts[1];\r\n    }\r\n\r\n    function _addLiquidity(uint256 USDTAmount) private {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(USDT);\r\n        path[1] = address(HD);\r\n        uint256 HDAmount = _getHDOut(USDTAmount) * 2;\r\n        HD.mint(HDAmount);\r\n        (, uint256 b, ) = router.addLiquidity(\r\n            address(USDT),\r\n            address(HD),\r\n            USDTAmount,\r\n            ~uint256(0),\r\n            0,\r\n            0,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        if (b < HDAmount) HD.destroy(HDAmount - b);\r\n    }\r\n\r\n    function _removeLiquidity(uint256 liquidity) private returns (uint, uint) {\r\n        (uint a, uint b) = router.removeLiquidity(\r\n            address(USDT),\r\n            address(HD),\r\n            liquidity,\r\n            0,\r\n            0,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        HD.destroy(b);\r\n        return (a, b);\r\n    }\r\n\r\n \r\n   \r\n    function _getTs() private view returns (uint64) {\r\n        return uint64(block.timestamp);\r\n    }\r\n\r\n   \r\n \r\n\r\n  \r\n    function _calculateLPAmount(\r\n        uint256 HDamount\r\n    ) private view returns (uint256, uint256) {\r\n        uint256 expectedUSDTAmount = _getUSDTOut(HDamount);\r\n        uint256 lpTotalSupply = pair.totalSupply();\r\n        (uint256 USDTTotalBalance, ) = _getPairTokenAmount();\r\n        uint256 LPAmount = (lpTotalSupply * expectedUSDTAmount) /\r\n            USDTTotalBalance;\r\n        return (LPAmount, expectedUSDTAmount);\r\n    }\r\n\r\n    function _getPairTokenAmount()\r\n        private\r\n        view\r\n        returns (uint256 USDTTotalBalance, uint256 HDTotalBalance)\r\n    {\r\n        (uint256 amount0, uint256 amount1, ) = pair.getReserves();\r\n        address token0 = pair.token0();\r\n        if (token0 == address(USDT)) {\r\n            USDTTotalBalance = amount0;\r\n            HDTotalBalance = amount1;\r\n        } else {\r\n            USDTTotalBalance = amount1;\r\n            HDTotalBalance = amount0;\r\n        }\r\n    }\r\n\r\n    function _calculateLPPowerValue() private view returns (uint256) {\r\n        return _getUSDTOut(1 * 1e18) / 2;\r\n    }\r\n\r\n   \r\n    function _buy(uint256 amount) private {\r\n        User storage user = users[msg.sender];\r\n        uint256 userLevel = user.level;\r\n\r\n        require(user.bourtUSDT >= amount, \"level error\");\r\n        uint256 usdtBalance = USDT.balanceOf(msg.sender);\r\n        require(usdtBalance >= amount, \"balance error\");\r\n        require(\r\n            USDT.transferFrom(msg.sender, address(this), amount),\r\n            \"transfer error\"\r\n        );\r\n        user.bourtUSDT -= amount;\r\n\r\n        require(\r\n            user.bourtUSDT <= levelUSDTLimit[userLevel] * 10 ** USDT.decimals(),\r\n            \"bourtUSDT error\"\r\n        );\r\n        uint256 addLPAmount = (amount * 64) / 100;\r\n        _addLiquidity(addLPAmount);\r\n        uint256 buyAmount = (amount * 32) / 100;\r\n        uint256 HDAmount = _buyHD(buyAmount);\r\n        require(HD.transfer(msg.sender, HDAmount*30/32), \"transfer error\");\r\n        require(\r\n            HD.transfer(LPfenhong, (amount * 2) / 32),\r\n            \"transfer error\"\r\n        );\r\n\r\n           require(\r\n            USDT.transfer(PTUAddress, (amount * 4) / 100),\r\n            \"transfer error\"\r\n        );\r\n    }\r\n\r\n    function _sell(uint256 amount) private returns (uint256) {\r\n        uint256 HDBalance = HD.balanceOf(msg.sender);\r\n        require(HDBalance >= amount, \"balance error\");\r\n\r\n        require(\r\n            HD.transferFrom(msg.sender, address(this), amount),\r\n            \"transfer error\"\r\n        );\r\n        HD.destroy(amount);\r\n        (uint256 LPAmount, uint256 expectedUSDTAmount) = _calculateLPAmount(\r\n            amount\r\n        );\r\n        (uint256 USDTAmount, ) = _removeLiquidity(LPAmount);\r\n        if (USDTAmount > expectedUSDTAmount) {\r\n            USDTAmount = expectedUSDTAmount;\r\n        }\r\n        uint256 USDTToUserAmount = (USDTAmount * 90) / 100;\r\n        require(USDT.transfer(msg.sender, USDTToUserAmount), \"transfer error\");\r\n        uint256 USDTToBuy = (USDTAmount - USDTToUserAmount)/2;\r\n        uint256 HDAmount = _buyHD(USDTToBuy);//\u8fdb\u5165\u5206\u7ea2\u6c60\r\n\r\n        HD.transfer(LPfenhong, HDAmount);//\u8fdb\u5165\u5206\u7ea2\u6c60\r\n        USDT.transfer(PTUAddress, USDTToBuy) ;//\u8fdb\u5165\u5e73\u53f0\r\n        \r\n        return USDTToUserAmount;\r\n    }\r\n\r\n \r\n    // \u5347\u7ea7\r\n    function upgrade() private {\r\n        User storage user = users[msg.sender];\r\n        require(user.level < 5, \"level error\");\r\n\r\n        uint256 usdtBalance = USDT.balanceOf(msg.sender);\r\n        uint256 price = levelPrice[user.level + 1] * 10 ** USDT.decimals();\r\n        require(usdtBalance >= price, \"balance error\");\r\n        require(\r\n            USDT.transferFrom(msg.sender, address(this), price),\r\n            \"transfer error\"\r\n        );\r\n\r\n\r\n\r\n// 60\u6dfb\u52a0\u6d41\u52a8\u6027\r\n         uint256 addLPAmount = (price * 60) / 100;\r\n        _addLiquidity(addLPAmount);\r\n\r\n// 30%\u4e70\u5e01\r\n        uint256 HDAmount = _buyHD(price*30/100);//\u8fdb\u5165\u5206\u7ea2\u6c60\r\n\r\n\r\n\r\n// \u76f4\u63a5\u4e0a\u7ea720%\r\n        require(\r\n        HD.transfer( user.team.leader, HDAmount*2/3),\r\n            \"transfer error\"\r\n        );\r\n\r\n            require(\r\n        HD.transfer( PTAddress, HDAmount/3),\r\n            \"transfer error\"\r\n        );\r\n\r\n\r\n        require(\r\n            USDT.transfer(PTUAddress,  price/10),\r\n            \"transfer error\"\r\n        );\r\n        user.level += 1;\r\n        user.effective = true; \r\n        user.bourtUSDT  += limitUSDT[user.level] * 10 ** USDT.decimals();\r\n        uint256 userLevel = user.level;\r\n\r\n        uint i;\r\n        while (user.team.top != address(0) && i < 10) {\r\n            user = users[user.team.top];\r\n            if (user.level >= userLevel) {\r\n\r\n               uint256  USDTB   = levelPrice[userLevel]  ** USDT.decimals();\r\n                uint256 HDAmoun = _getHDOut(USDTB);\r\n\r\n                HD.transferFrom(PTAddress, user.team.top, HDAmoun/200);\r\n\r\n                 \r\n            }else\r\n            {\r\n                uint256 HDAmoun = _getHDOut(price);\r\n                HD.transferFrom(PTAddress, user.team.top, HDAmoun/200);\r\n            }\r\n            ++i;\r\n        }\r\n\r\n     \r\n    }\r\n\r\n\r\n \r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Sell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"leader\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"Upgrade\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"Lprice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MOLPlprice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"approveing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"floorUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUsers\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"add\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"initTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"left\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"right\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"middle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nextCount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"top\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"leader\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"childCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"floor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reachFloor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"latestIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"effective\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"bourtUSDT\",\"type\":\"uint256\"}],\"internalType\":\"struct BlackHole._Team\",\"name\":\"team\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVIPprice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getlprice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_leader\",\"type\":\"address\"}],\"name\":\"invite\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"levelPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"levelUSDTLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"limitUSDT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicReward\",\"outputs\":[{\"internalType\":\"contract PublicReward\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"add\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ty\",\"type\":\"uint256\"}],\"name\":\"setaddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_leader\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"adds\",\"type\":\"address[]\"}],\"name\":\"topInvite\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_leader\",\"type\":\"address\"}],\"name\":\"upgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BlackHole", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://917fb9ad123541b9deeb72cd5922d5ef8581532667fe57685e4b1d9cfb04fdc9"}