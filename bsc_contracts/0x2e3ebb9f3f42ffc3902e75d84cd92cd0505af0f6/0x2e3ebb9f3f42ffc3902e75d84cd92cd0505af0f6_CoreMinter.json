{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"CoreIncentives.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n\\nimport \\\"Ownable.sol\\\";\\nimport \\\"IDddToken.sol\\\";\\nimport \\\"ITokenLocker.sol\\\";\\n\\n\\ncontract CoreMinter is Ownable {\\n\\n    IDddToken public DDD;\\n    ITokenLocker public dddLocker;\\n\\n    mapping (address => uint) public allocPoints;\\n    mapping (address => uint) public claimed;\\n\\n    uint256 public minted;\\n    uint256 public totalAllocPoints;\\n    uint256 public immutable MINT_PCT;\\n    uint256 public immutable MAX_DAILY_MINT;\\n    uint256 public immutable LOCK_WEEKS;\\n\\n    // this contract has no concept of weekly periods\\n    uint256 public startTime;\\n\\n    constructor(\\n        uint256 _coreMintPct,\\n        uint256 _maxDaily,\\n        uint256 _lockWeeks,\\n        address[] memory _receivers,\\n        uint[] memory _allocPoints\\n    ) public {\\n        MINT_PCT = _coreMintPct;\\n        MAX_DAILY_MINT = _maxDaily;\\n        LOCK_WEEKS = _lockWeeks;\\n        for (uint i = 0; i < _receivers.length; i++) {\\n            require(allocPoints[_receivers[i]] == 0);\\n            allocPoints[_receivers[i]] = _allocPoints[i];\\n            totalAllocPoints += _allocPoints[i];\\n        }\\n    }\\n\\n    function setAddresses(\\n        IDddToken _DDD,\\n        ITokenLocker _dddLocker\\n    ) external onlyOwner {\\n        DDD = _DDD;\\n        dddLocker = _dddLocker;\\n\\n        _DDD.approve(address(_dddLocker), type(uint256).max);\\n\\n        startTime = _dddLocker.startTime();\\n\\n        renounceOwnership();\\n    }\\n\\n    function supplyMintLimit() public view returns (uint256) {\\n        uint256 supply = DDD.totalSupply() - minted;\\n        return supply * 100 / (100 - MINT_PCT) - supply;\\n    }\\n\\n    function timeMintLimit() public view returns (uint256) {\\n        uint256 day = (block.timestamp - startTime) / 86400;\\n        return MAX_DAILY_MINT * day;\\n    }\\n\\n    function claimable(address _user) public view returns (uint256) {\\n        uint256 supplyLimit = supplyMintLimit();\\n        uint256 timeLimit = timeMintLimit();\\n\\n        uint256 limit = supplyLimit < timeLimit ? supplyLimit : timeLimit;\\n        uint256 amount = limit * allocPoints[_user] / totalAllocPoints;\\n\\n        return amount - claimed[_user];\\n    }\\n\\n    function claim(address _receiver, uint _amount, uint _lock_weeks) external {\\n        uint claimable = claimable(msg.sender);\\n        require(claimable > 0, \\\"Nothing claimable\\\");\\n        if (_amount == 0) {\\n            _amount = claimable;\\n        } else {\\n            require(_amount <= claimable, \\\"Exceeds claimable amount\\\");\\n        }\\n        require(_lock_weeks >= LOCK_WEEKS, \\\"Must lock at least LOCK_WEEKS\\\");\\n\\n        claimed[msg.sender] += _amount;\\n        minted += _amount;\\n        DDD.mint(address(this), _amount);\\n        dddLocker.lock(_receiver, _amount, _lock_weeks);\\n    }\\n\\n    function transferAlloc(address _newOwner, uint256 _ap) external {\\n        uint256 alloc = allocPoints[msg.sender];\\n        require(alloc > 0, \\\"No alloc\\\");\\n        require(_ap <= alloc, \\\"Insufficient allocPoint\\\");\\n        uint256 amount = claimed[msg.sender] * _ap / alloc;\\n\\n        allocPoints[msg.sender] -= _ap;\\n        claimed[msg.sender] -= amount;\\n\\n        allocPoints[_newOwner] += _ap;\\n        claimed[_newOwner] += amount;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable {\\n    address public owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = owner;\\n        owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"IDddToken.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n\\nimport \\\"IERC20.sol\\\";\\n\\ninterface IDddToken is IERC20 {\\n    function mint(address _to, uint256 _value) external returns (bool);\\n}\"\r\n    },\r\n    \"IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.12;\\n\\n/**\\n * Based on the OpenZeppelin IER20 interface:\\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\\n *\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"ITokenLocker.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n\\n\\ninterface ITokenLocker {\\n\\n    function MAX_LOCK_WEEKS() external view returns (uint256);\\n    function getWeek() external view returns (uint256);\\n    function userWeight(address _user) external view returns (uint256);\\n    function totalWeight() external view returns (uint256);\\n    function weeklyWeight(address _user, uint256 _week) external view returns (uint256, uint256);\\n    function startTime() external view returns (uint256);\\n    function weeklyTotalWeight(uint256 week) external view returns (uint256);\\n    function weeklyWeightOf(address user, uint256 week) external view returns (uint256);\\n\\n    /**\\n        @notice Get data on a user's active token locks\\n        @param _user Address to query data for\\n        @return lockData dynamic array of [weeks until expiration, balance of lock]\\n     */\\n    function getActiveUserLocks(address _user) external view returns (uint256[2][] memory lockData);\\n\\n    /**\\n        @notice Allow or block third-party calls to deposit, withdraw\\n                or claim rewards on behalf of the caller\\n     */\\n    function setBlockThirdPartyActions(bool _block) external;\\n\\n    /**\\n        @notice Deposit tokens into the contract to create a new lock.\\n        @param _user Address to create a new lock for (does not have to be the caller)\\n        @param _amount Amount of tokens to lock. This balance transfered from the caller.\\n        @param _weeks The number of weeks for the lock.\\n     */\\n    function lock(\\n        address _user,\\n        uint256 _amount,\\n        uint256 _weeks\\n    ) external returns (bool);\\n\\n    /**\\n        @notice Extend the length of an existing lock.\\n        @param _amount Amount of tokens to extend the lock for.\\n        @param _weeks The number of weeks for the lock that is being extended.\\n        @param _newWeeks The number of weeks to extend the lock until.\\n     */\\n    function extendLock(\\n        uint256 _amount,\\n        uint256 _weeks,\\n        uint256 _newWeeks\\n    ) external returns (bool);\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {\r\n      \"CoreIncentives.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_coreMintPct\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxDaily\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lockWeeks\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_receivers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_allocPoints\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DDD\",\"outputs\":[{\"internalType\":\"contract IDddToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LOCK_WEEKS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_DAILY_MINT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINT_PCT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allocPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lock_weeks\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"claimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dddLocker\",\"outputs\":[{\"internalType\":\"contract ITokenLocker\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IDddToken\",\"name\":\"_DDD\",\"type\":\"address\"},{\"internalType\":\"contract ITokenLocker\",\"name\":\"_dddLocker\",\"type\":\"address\"}],\"name\":\"setAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supplyMintLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeMintLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAllocPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_ap\",\"type\":\"uint256\"}],\"name\":\"transferAlloc\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CoreMinter", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000034f086f3b33b68400000000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000220000000000000000000000000000000000000000000000000000000000000000b0000000000000000000000007305aa6b02ecbc1bbc1c3042d5a6a0fdf020ad94000000000000000000000000b7fa14c01f899b587126c138e752b10a9bebebdd000000000000000000000000b5a6c4458e1a2c689d1ab356ba6dfca8f39ea96d00000000000000000000000057256b14c16688fb949730d20f1f576ba8ae3a230000000000000000000000007019a438c573634e918b6a477399edf34ef57063000000000000000000000000dcf908312c8a5cd9e42003eae23a7c3e82b952c90000000000000000000000007a31a5fdccc13924b529594844dee24e96e4ce7a000000000000000000000000367fca293149ff5e489d63c68bdcc600dea6cfa400000000000000000000000046e297bb22772608bd69de0cc9b8d1baab45805400000000000000000000000053bb2b243c33955e7bb2fa263c19562b26a6b7ad00000000000000000000000042e770e13dfce7fd377dbc81915f4991d418499a000000000000000000000000000000000000000000000000000000000000000b000000000000000000000000000000000000000000000000000000000000a60400000000000000000000000000000000000000000000000000000000000088b800000000000000000000000000000000000000000000000000000000000061a800000000000000000000000000000000000000000000000000000000000061a800000000000000000000000000000000000000000000000000000000000061a80000000000000000000000000000000000000000000000000000000000003a980000000000000000000000000000000000000000000000000000000000001d4c0000000000000000000000000000000000000000000000000000000000001d4c0000000000000000000000000000000000000000000000000000000000001d4c0000000000000000000000000000000000000000000000000000000000001d4c00000000000000000000000000000000000000000000000000000000000009c4", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}