{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"MultiFeeDistribution.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"IChefIncentivesController.sol\\\";\\nimport \\\"IMultiFeeDistribution.sol\\\";\\nimport \\\"IERC20.sol\\\";\\nimport \\\"SafeERC20.sol\\\";\\nimport \\\"SafeMath.sol\\\";\\nimport \\\"Ownable.sol\\\";\\n\\n\\ninterface IStakingToken is IERC20 {\\n    function mint(address _receiver, uint256 _amount) external returns (bool);\\n    function setMinter(address _minter) external returns (bool);\\n    function burn(uint256 _value) external returns (bool);\\n}\\n\\ninterface IBurnableToken is IERC20 {\\n    function burn(uint256 amount) external;\\n}\\n\\n// Based on Ellipsis EPS Staker\\n// https://github.com/ellipsis-finance/ellipsis/blob/master/contracts/EpsStaker.sol\\ncontract MultiFeeDistribution is IMultiFeeDistribution, Ownable {\\n\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n    using SafeERC20 for IStakingToken;\\n\\n    uint256 private constant QUART =  25000; //  25%\\n    uint256 private constant HALF  =  50000; //  50%\\n    uint256 private constant WHOLE = 100000; // 100%\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    struct Reward {\\n        uint256 periodFinish;\\n        uint256 rewardRate;\\n        uint256 lastUpdateTime;\\n        uint256 rewardPerTokenStored;\\n        // tracks already-added balances to handle accrued interest in aToken rewards\\n        // for the stakingToken this value is unused and will always be 0\\n        uint256 balance;\\n    }\\n    struct Balances {\\n        uint256 total;\\n        uint256 unlocked;\\n        uint256 locked;\\n        uint256 earned;\\n    }\\n    struct LockedBalance {\\n        uint256 amount;\\n        uint256 unlockTime;\\n    }\\n    struct RewardData {\\n        address token;\\n        uint256 amount;\\n    }\\n\\n    IChefIncentivesController public incentivesController;\\n    IStakingToken public immutable stakingToken;\\n    address[] public rewardTokens;\\n    mapping(address => Reward) public rewardData;\\n\\n    // Duration that rewards are streamed over\\n    uint256 public constant rewardsDuration = 86400 * 7;\\n\\n    // Duration of lock/earned penalty period\\n    uint256 public constant lockDuration = rewardsDuration * 13;\\n\\n    // Addresses approved to call mint\\n    mapping(address => bool) public minters;\\n    bool public mintersAreSet;\\n\\n    // user -> reward token -> amount\\n    mapping(address => mapping(address => uint256)) public userRewardPerTokenPaid;\\n    mapping(address => mapping(address => uint256)) public rewards;\\n\\n    uint256 public totalSupply;\\n    uint256 public lockedSupply;\\n    uint256 public burnedSupply;\\n\\n    // Private mappings for balance data\\n    mapping(address => Balances) private balances;\\n    mapping(address => LockedBalance[]) private userLocks;\\n    mapping(address => LockedBalance[]) private userEarnings;\\n\\n    /* ========== CONSTRUCTOR ========== */\\n\\n    constructor(address _stakingToken) Ownable() {\\n        stakingToken = IStakingToken(_stakingToken);\\n        IStakingToken(_stakingToken).setMinter(address(this));\\n        // First reward MUST be the staking token or things will break\\n        // related to the penalty and distribution to locked balances\\n        rewardTokens.push(_stakingToken);\\n        rewardData[_stakingToken].lastUpdateTime = block.timestamp;\\n    }\\n\\n    /* ========== ADMIN CONFIGURATION ========== */\\n\\n    function setMinters(address[] memory _minters) external onlyOwner {\\n        require(!mintersAreSet);\\n        for (uint i; i < _minters.length; i++) {\\n            minters[_minters[i]] = true;\\n        }\\n        mintersAreSet = true;\\n    }\\n\\n    function setIncentivesController(IChefIncentivesController _controller) external onlyOwner {\\n        incentivesController = _controller;\\n    }\\n\\n    // Add a new reward token to be distributed to stakers\\n    function addReward(address _rewardsToken) external override onlyOwner {\\n        require(rewardData[_rewardsToken].lastUpdateTime == 0);\\n        rewardTokens.push(_rewardsToken);\\n        rewardData[_rewardsToken].lastUpdateTime = block.timestamp;\\n        rewardData[_rewardsToken].periodFinish = block.timestamp;\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function _rewardPerToken(address _rewardsToken, uint256 _supply) internal view returns (uint256) {\\n        if (_supply == 0) {\\n            return rewardData[_rewardsToken].rewardPerTokenStored;\\n        }\\n        return\\n            rewardData[_rewardsToken].rewardPerTokenStored.add(\\n                lastTimeRewardApplicable(_rewardsToken).sub(\\n                    rewardData[_rewardsToken].lastUpdateTime).mul(\\n                        rewardData[_rewardsToken].rewardRate).mul(1e18).div(_supply)\\n            );\\n    }\\n\\n    function _earned(\\n        address _user,\\n        address _rewardsToken,\\n        uint256 _balance,\\n        uint256 _currentRewardPerToken\\n    ) internal view returns (uint256) {\\n        return _balance.mul(\\n            _currentRewardPerToken.sub(userRewardPerTokenPaid[_user][_rewardsToken])\\n        ).div(1e18).add(rewards[_user][_rewardsToken]);\\n    }\\n\\n    function lastTimeRewardApplicable(address _rewardsToken) public view returns (uint256) {\\n        uint periodFinish = rewardData[_rewardsToken].periodFinish;\\n        return block.timestamp < periodFinish ? block.timestamp : periodFinish;\\n    }\\n\\n    function rewardPerToken(address _rewardsToken) external view returns (uint256) {\\n        uint256 supply = _rewardsToken == address(stakingToken) ? lockedSupply : totalSupply;\\n        return _rewardPerToken(_rewardsToken, supply);\\n\\n    }\\n\\n    function getRewardForDuration(address _rewardsToken) external view returns (uint256) {\\n        return rewardData[_rewardsToken].rewardRate.mul(rewardsDuration).div(1e12);\\n    }\\n\\n    // Address and claimable amount of all reward tokens for the given account\\n    function claimableRewards(address account) external view returns (RewardData[] memory rewards) {\\n        rewards = new RewardData[](rewardTokens.length);\\n        for (uint256 i = 0; i < rewards.length; i++) {\\n            // If i == 0 this is the stakingReward, distribution is based on locked balances\\n            uint256 balance = i == 0 ? balances[account].locked : balances[account].total;\\n            uint256 supply = i == 0 ? lockedSupply : totalSupply;\\n            rewards[i].token = rewardTokens[i];\\n            rewards[i].amount = _earned(account, rewards[i].token, balance, _rewardPerToken(rewardTokens[i], supply)).div(1e12);\\n        }\\n        return rewards;\\n    }\\n\\n    // Total balance of an account, including unlocked, locked and earned tokens\\n    function totalBalance(address user) view external returns (uint256 amount) {\\n        return balances[user].total;\\n    }\\n\\n    // Total withdrawable balance for an account to which no penalty is applied\\n    function unlockedBalance(address user) view external returns (uint256 amount) {\\n        amount = balances[user].unlocked;\\n        LockedBalance[] storage earnings = userEarnings[msg.sender];\\n        for (uint i = 0; i < earnings.length; i++) {\\n            if (earnings[i].unlockTime > block.timestamp) {\\n                break;\\n            }\\n            amount = amount.add(earnings[i].amount);\\n        }\\n        return amount;\\n    }\\n\\n    // Information on the \\\"earned\\\" balances of a user\\n    // Earned balances may be withdrawn immediately for a penalty\\n    function earnedBalances(\\n        address user\\n    ) view external returns (\\n        uint256 total,\\n        LockedBalance[] memory earningsData\\n    ) {\\n        LockedBalance[] storage earnings = userEarnings[user];\\n        uint256 idx;\\n        for (uint i = 0; i < earnings.length; i++) {\\n            if (earnings[i].unlockTime > block.timestamp) {\\n                if (idx == 0) {\\n                    earningsData = new LockedBalance[](earnings.length - i);\\n                }\\n                earningsData[idx] = earnings[i];\\n                idx++;\\n                total = total.add(earnings[i].amount);\\n            }\\n        }\\n        return (total, earningsData);\\n    }\\n\\n    // Information on a user's locked balances\\n    function lockedBalances(\\n        address user\\n    ) view external returns (\\n        uint256 total,\\n        uint256 unlockable,\\n        uint256 locked,\\n        LockedBalance[] memory lockData\\n    ) {\\n        LockedBalance[] storage locks = userLocks[user];\\n        uint256 idx;\\n        for (uint i = 0; i < locks.length; i++) {\\n            if (locks[i].unlockTime > block.timestamp) {\\n                if (idx == 0) {\\n                    lockData = new LockedBalance[](locks.length - i);\\n                }\\n                lockData[idx] = locks[i];\\n                idx++;\\n                locked = locked.add(locks[i].amount);\\n            } else {\\n                unlockable = unlockable.add(locks[i].amount);\\n            }\\n        }\\n        return (balances[user].locked, unlockable, locked, lockData);\\n    }\\n\\n    // Final balance received and penalty balance paid by user upon calling exit\\n    function withdrawableBalance(\\n        address user\\n    ) view public returns (\\n        uint256 amount,\\n        uint256 penaltyAmount,\\n        uint256 burnAmount\\n    ) {\\n        Balances storage bal = balances[user];\\n        uint256 earned = bal.earned;\\n        if (earned > 0) {\\n            uint256 length = userEarnings[user].length;\\n            for (uint i = 0; i < length; i++) {\\n                uint256 earnedAmount = userEarnings[user][i].amount;\\n                if (earnedAmount == 0) continue;\\n                uint256 unlockTime = userEarnings[user][i].unlockTime;\\n\\n                uint256 penaltyFactor;\\n                if (unlockTime > block.timestamp) {\\n                    penaltyFactor = unlockTime.sub(block.timestamp).mul(HALF).div(lockDuration).add(QUART); // 25% + timeLeft/lockDuration * 50%\\n                }\\n                uint256 burnFactor;\\n                if (penaltyFactor > HALF) {\\n                    burnFactor = penaltyFactor.sub(HALF);\\n                    penaltyFactor = HALF;\\n                }\\n                amount = amount.add(earnedAmount);\\n                penaltyAmount = penaltyAmount.add(earnedAmount.mul(penaltyFactor).div(WHOLE));\\n                burnAmount = burnAmount.add(earnedAmount.mul(burnFactor).div(WHOLE));\\n            }\\n        }\\n        amount = bal.unlocked.add(earned).sub(penaltyAmount).sub(burnAmount);\\n        return (amount, penaltyAmount, burnAmount);\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    // Stake tokens to receive rewards\\n    // Locked tokens cannot be withdrawn for lockDuration and are eligible to receive stakingReward rewards\\n    function stake(uint256 amount, bool lock) external {\\n        require(amount > 0, \\\"Cannot stake 0\\\");\\n        _updateReward(msg.sender);\\n        totalSupply = totalSupply.add(amount);\\n        Balances storage bal = balances[msg.sender];\\n        bal.total = bal.total.add(amount);\\n        if (lock) {\\n            lockedSupply = lockedSupply.add(amount);\\n            bal.locked = bal.locked.add(amount);\\n            uint256 unlockTime = block.timestamp.div(rewardsDuration).mul(rewardsDuration).add(lockDuration);\\n            uint256 idx = userLocks[msg.sender].length;\\n            if (idx == 0 || userLocks[msg.sender][idx-1].unlockTime < unlockTime) {\\n                userLocks[msg.sender].push(LockedBalance({amount: amount, unlockTime: unlockTime}));\\n            } else {\\n                userLocks[msg.sender][idx-1].amount = userLocks[msg.sender][idx-1].amount.add(amount);\\n            }\\n        } else {\\n            bal.unlocked = bal.unlocked.add(amount);\\n        }\\n        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\\n        emit Staked(msg.sender, amount, lock);\\n    }\\n\\n    // Mint new tokens\\n    // Minted tokens receive rewards normally but incur a penalty when\\n    // withdrawn before lockDuration has passed.\\n    function mint(address user, uint256 amount, bool withPenalty) external override {\\n        require(minters[msg.sender]);\\n        if (amount == 0) return;\\n        _updateReward(user);\\n        stakingToken.mint(address(this), amount);\\n        if (user == address(this)) {\\n            // minting to this contract adds the new tokens as incentives for lockers\\n            _notifyReward(address(stakingToken), amount);\\n            return;\\n        }\\n        totalSupply = totalSupply.add(amount);\\n        Balances storage bal = balances[user];\\n        bal.total = bal.total.add(amount);\\n        if (withPenalty) {\\n            bal.earned = bal.earned.add(amount);\\n            uint256 unlockTime = block.timestamp.div(rewardsDuration).mul(rewardsDuration).add(lockDuration);\\n            LockedBalance[] storage earnings = userEarnings[user];\\n            uint256 idx = earnings.length;\\n            if (idx == 0 || earnings[idx-1].unlockTime < unlockTime) {\\n                earnings.push(LockedBalance({amount: amount, unlockTime: unlockTime}));\\n            } else {\\n                earnings[idx-1].amount = earnings[idx-1].amount.add(amount);\\n            }\\n        } else {\\n            bal.unlocked = bal.unlocked.add(amount);\\n        }\\n        emit Staked(user, amount, false);\\n    }\\n\\n    // Withdraw staked tokens\\n    // First withdraws unlocked tokens, then earned tokens. Withdrawing earned tokens\\n    // incurs a penalty which is distributed based on locked balances.\\n    function withdraw(uint256 amount) public {\\n        require(amount > 0, \\\"Cannot withdraw 0\\\");\\n        _updateReward(msg.sender);\\n        Balances storage bal = balances[msg.sender];\\n        uint256 penaltyAmount;\\n        uint256 burnAmount;\\n\\n        if (amount <= bal.unlocked) {\\n            bal.unlocked = bal.unlocked.sub(amount);\\n        } else {\\n            uint256 remaining = amount.sub(bal.unlocked);\\n            require(bal.earned >= remaining, \\\"Insufficient unlocked balance\\\");\\n            bal.unlocked = 0;\\n            uint256 sumEarned = bal.earned;\\n            for (uint i = 0; ; i++) {\\n                uint256 earnedAmount = userEarnings[msg.sender][i].amount;\\n                if (earnedAmount == 0) continue;\\n                uint256 unlockTime = userEarnings[msg.sender][i].unlockTime;\\n                \\n                uint256 penaltyFactor;\\n                if (unlockTime > block.timestamp) {\\n                    penaltyFactor = unlockTime.sub(block.timestamp).mul(HALF).div(lockDuration).add(QUART); // 25% + timeLeft/lockDuration * 50%\\n                }\\n                \\n                // Amount required from this lock, taking into account the penalty\\n                uint256 requiredAmount = remaining.mul(WHOLE).div(WHOLE.sub(penaltyFactor));\\n                if (requiredAmount >= earnedAmount) {\\n                    requiredAmount = earnedAmount;\\n                    delete userEarnings[msg.sender][i];\\n                    remaining = remaining.sub(earnedAmount.mul(WHOLE.sub(penaltyFactor)).div(WHOLE)); // remaining -= earned * (1 - pentaltyFactor)\\n                }\\n                else {\\n                    userEarnings[msg.sender][i].amount = earnedAmount.sub(requiredAmount);\\n                    remaining = 0;\\n                }\\n                sumEarned = sumEarned.sub(requiredAmount);\\n\\n                uint256 burnFactor;\\n                if (penaltyFactor > HALF) {\\n                    burnFactor = penaltyFactor.sub(HALF);\\n                    penaltyFactor = HALF;\\n                }\\n                penaltyAmount = penaltyAmount.add(requiredAmount.mul(penaltyFactor).div(WHOLE)); // penalty += amount * penaltyFactor\\n                burnAmount = burnAmount.add(requiredAmount.mul(burnFactor).div(WHOLE)); // burn += amount * burnFactor\\n\\n                if (remaining == 0) {\\n                    break;\\n                }\\n                else {\\n                    require(sumEarned > 0, \\\"Insufficient balance\\\");\\n                }\\n            }\\n            bal.earned = sumEarned;\\n        }\\n\\n        uint256 adjustedAmount = amount.add(penaltyAmount).add(burnAmount);\\n        bal.total = bal.total.sub(adjustedAmount);\\n        totalSupply = totalSupply.sub(adjustedAmount);\\n        stakingToken.safeTransfer(msg.sender, amount);\\n        if (penaltyAmount > 0) {\\n            incentivesController.claim(address(this), new address[](0));\\n            _notifyReward(address(stakingToken), penaltyAmount);\\n        }\\n        if (burnAmount > 0) {\\n            stakingToken.burn(burnAmount);\\n            burnedSupply = burnedSupply.add(burnAmount);\\n        }\\n        emit Withdrawn(msg.sender, amount, penaltyAmount, burnAmount);\\n    }\\n\\n    function _getReward(address[] memory _rewardTokens) internal {\\n        uint256 length = _rewardTokens.length;\\n        for (uint i; i < length; i++) {\\n            address token = _rewardTokens[i];\\n            uint256 reward = rewards[msg.sender][token].div(1e12);\\n            if (token != address(stakingToken)) {\\n                // for rewards other than stakingToken, every 24 hours we check if new\\n                // rewards were sent to the contract or accrued via aToken interest\\n                Reward storage r = rewardData[token];\\n                uint256 periodFinish = r.periodFinish;\\n                require(periodFinish > 0, \\\"Unknown reward token\\\");\\n                uint256 balance = r.balance;\\n                if (periodFinish < block.timestamp.add(rewardsDuration - 86400)) {\\n                    uint256 unseen = IERC20(token).balanceOf(address(this)).sub(balance);\\n                    if (unseen > 0) {\\n                        _notifyReward(token, unseen);\\n                        balance = balance.add(unseen);\\n                    }\\n                }\\n                r.balance = balance.sub(reward);\\n            }\\n            if (reward == 0) continue;\\n            rewards[msg.sender][token] = 0;\\n            IERC20(token).safeTransfer(msg.sender, reward);\\n            emit RewardPaid(msg.sender, token, reward);\\n        }\\n    }\\n\\n    // Claim all pending staking rewards\\n    function getReward(address[] memory _rewardTokens) public {\\n        _updateReward(msg.sender);\\n        _getReward(_rewardTokens);\\n    }\\n\\n    // Withdraw full unlocked balance and optionally claim pending rewards\\n    function exit(bool claimRewards) external {\\n        _updateReward(msg.sender);\\n        (uint256 amount, uint256 penaltyAmount, uint256 burnAmount) = withdrawableBalance(msg.sender);\\n        delete userEarnings[msg.sender];\\n        Balances storage bal = balances[msg.sender];\\n        bal.total = bal.total.sub(bal.unlocked).sub(bal.earned);\\n        bal.unlocked = 0;\\n        bal.earned = 0;\\n\\n        totalSupply = totalSupply.sub(amount.add(penaltyAmount).add(burnAmount));\\n        stakingToken.safeTransfer(msg.sender, amount);\\n        if (penaltyAmount > 0) {\\n            incentivesController.claim(address(this), new address[](0));\\n            _notifyReward(address(stakingToken), penaltyAmount);\\n        }\\n        if (burnAmount > 0) {\\n            stakingToken.burn(burnAmount);\\n            burnedSupply = burnedSupply.add(burnAmount);\\n        }\\n        if (claimRewards) {\\n            _getReward(rewardTokens);\\n        }\\n        emit Withdrawn(msg.sender, amount, penaltyAmount, burnAmount);\\n    }\\n\\n    // Withdraw all currently locked tokens where the unlock time has passed\\n    function withdrawExpiredLocks() external {\\n        _updateReward(msg.sender);\\n        LockedBalance[] storage locks = userLocks[msg.sender];\\n        Balances storage bal = balances[msg.sender];\\n        uint256 amount;\\n        uint256 length = locks.length;\\n        if (locks[length-1].unlockTime <= block.timestamp) {\\n            amount = bal.locked;\\n            delete userLocks[msg.sender];\\n        } else {\\n            for (uint i = 0; i < length; i++) {\\n                if (locks[i].unlockTime > block.timestamp) break;\\n                amount = amount.add(locks[i].amount);\\n                delete locks[i];\\n            }\\n        }\\n        bal.locked = bal.locked.sub(amount);\\n        bal.total = bal.total.sub(amount);\\n        totalSupply = totalSupply.sub(amount);\\n        lockedSupply = lockedSupply.sub(amount);\\n        stakingToken.safeTransfer(msg.sender, amount);\\n        emit Withdrawn(msg.sender, amount, 0, 0);\\n    }\\n\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    function _notifyReward(address _rewardsToken, uint256 reward) internal {\\n        Reward storage r = rewardData[_rewardsToken];\\n        if (block.timestamp >= r.periodFinish) {\\n            r.rewardRate = reward.mul(1e12).div(rewardsDuration);\\n        } else {\\n            uint256 remaining = r.periodFinish.sub(block.timestamp);\\n            uint256 leftover = remaining.mul(r.rewardRate).div(1e12);\\n            r.rewardRate = reward.add(leftover).mul(1e12).div(rewardsDuration);\\n        }\\n\\n        r.lastUpdateTime = block.timestamp;\\n        r.periodFinish = block.timestamp.add(rewardsDuration);\\n\\n    }\\n\\n    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\\n        require(tokenAddress != address(stakingToken), \\\"Cannot withdraw staking token\\\");\\n        require(rewardData[tokenAddress].lastUpdateTime == 0, \\\"Cannot withdraw reward token\\\");\\n        IERC20(tokenAddress).safeTransfer(owner(), tokenAmount);\\n        emit Recovered(tokenAddress, tokenAmount);\\n    }\\n\\n    function _updateReward(address account) internal {\\n        address token = address(stakingToken);\\n        uint256 balance;\\n        Reward storage r = rewardData[token];\\n        uint256 rpt = _rewardPerToken(token, lockedSupply);\\n        r.rewardPerTokenStored = rpt;\\n        r.lastUpdateTime = lastTimeRewardApplicable(token);\\n        if (account != address(this)) {\\n            // Special case, use the locked balances and supply for stakingReward rewards\\n            rewards[account][token] = _earned(account, token, balances[account].locked, rpt);\\n            userRewardPerTokenPaid[account][token] = rpt;\\n            balance = balances[account].total;\\n        }\\n\\n        uint256 supply = totalSupply;\\n        uint256 length = rewardTokens.length;\\n        for (uint i = 1; i < length; i++) {\\n            token = rewardTokens[i];\\n            r = rewardData[token];\\n            rpt = _rewardPerToken(token, supply);\\n            r.rewardPerTokenStored = rpt;\\n            r.lastUpdateTime = lastTimeRewardApplicable(token);\\n            if (account != address(this)) {\\n                rewards[account][token] = _earned(account, token, balance, rpt);\\n                userRewardPerTokenPaid[account][token] = rpt;\\n            }\\n        }\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event RewardAdded(uint256 reward);\\n    event Staked(address indexed user, uint256 amount, bool locked);\\n    event Withdrawn(address indexed user, uint256 receivedAmount, uint256 penaltyPaid, uint256 burned);\\n    event RewardPaid(address indexed user, address indexed rewardsToken, uint256 reward);\\n    event RewardsDurationUpdated(address token, uint256 newDuration);\\n    event Recovered(address token, uint256 amount);\\n}\\n\"\r\n    },\r\n    \"IChefIncentivesController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.6;\\npragma experimental ABIEncoderV2;\\n\\ninterface IChefIncentivesController {\\n\\n  /**\\n   * @dev Called by the corresponding asset on any update that affects the rewards distribution\\n   * @param user The address of the user\\n   * @param userBalance The balance of the user of the asset in the lending pool\\n   * @param totalSupply The total supply of the asset in the lending pool\\n   **/\\n  function handleAction(\\n    address user,\\n    uint256 userBalance,\\n    uint256 totalSupply\\n  ) external;\\n\\n    function addPool(address _token, uint256 _allocPoint) external;\\n\\n    function claim(address _user, address[] calldata _tokens) external;\\n\\n    function setClaimReceiver(address _user, address _receiver) external;\\n\\n}\\n\"\r\n    },\r\n    \"IMultiFeeDistribution.sol\": {\r\n      \"content\": \"pragma solidity 0.7.6;\\n\\ninterface IMultiFeeDistribution {\\n\\n    function addReward(address rewardsToken) external;\\n    function mint(address user, uint256 amount, bool withPenalty) external;\\n\\n}\\n\"\r\n    },\r\n    \"IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.6;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\nimport {IERC20} from \\\"IERC20.sol\\\";\\nimport {SafeMath} from \\\"SafeMath.sol\\\";\\nimport {Address} from \\\"Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n  using SafeMath for uint256;\\n  using Address for address;\\n\\n  function safeTransfer(\\n    IERC20 token,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n  }\\n\\n  function safeTransferFrom(\\n    IERC20 token,\\n    address from,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n  }\\n\\n  function safeApprove(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    require(\\n      (value == 0) || (token.allowance(address(this), spender) == 0),\\n      'SafeERC20: approve from non-zero to non-zero allowance'\\n    );\\n    callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n  }\\n\\n  function callOptionalReturn(IERC20 token, bytes memory data) private {\\n    require(address(token).isContract(), 'SafeERC20: call to non-contract');\\n\\n    // solhint-disable-next-line avoid-low-level-calls\\n    (bool success, bytes memory returndata) = address(token).call(data);\\n    require(success, 'SafeERC20: low-level call failed');\\n\\n    if (returndata.length > 0) {\\n      // Return data is optional\\n      // solhint-disable-next-line max-line-length\\n      require(abi.decode(returndata, (bool)), 'SafeERC20: ERC20 operation did not succeed');\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.6;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n  /**\\n   * @dev Returns the addition of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity's `+` operator.\\n   *\\n   * Requirements:\\n   * - Addition cannot overflow.\\n   */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a, 'SafeMath: addition overflow');\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, reverting on\\n   * overflow (when the result is negative).\\n   *\\n   * Counterpart to Solidity's `-` operator.\\n   *\\n   * Requirements:\\n   * - Subtraction cannot overflow.\\n   */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return sub(a, b, 'SafeMath: subtraction overflow');\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n   * overflow (when the result is negative).\\n   *\\n   * Counterpart to Solidity's `-` operator.\\n   *\\n   * Requirements:\\n   * - Subtraction cannot overflow.\\n   */\\n  function sub(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b <= a, errorMessage);\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the multiplication of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity's `*` operator.\\n   *\\n   * Requirements:\\n   * - Multiplication cannot overflow.\\n   */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b, 'SafeMath: multiplication overflow');\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the integer division of two unsigned integers. Reverts on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return div(a, b, 'SafeMath: division by zero');\\n  }\\n\\n  /**\\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function div(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    // Solidity only automatically asserts when dividing by 0\\n    require(b > 0, errorMessage);\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n   * Reverts when dividing by zero.\\n   *\\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\n   * invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return mod(a, b, 'SafeMath: modulo by zero');\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n   * Reverts with custom message when dividing by zero.\\n   *\\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\n   * invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function mod(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b != 0, errorMessage);\\n    return a % b;\\n  }\\n}\\n\"\r\n    },\r\n    \"Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.7.6;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n  /**\\n   * @dev Returns true if `account` is a contract.\\n   *\\n   * [IMPORTANT]\\n   * ====\\n   * It is unsafe to assume that an address for which this function returns\\n   * false is an externally-owned account (EOA) and not a contract.\\n   *\\n   * Among others, `isContract` will return false for the following\\n   * types of addresses:\\n   *\\n   *  - an externally-owned account\\n   *  - a contract in construction\\n   *  - an address where a contract will be created\\n   *  - an address where a contract lived, but was destroyed\\n   * ====\\n   */\\n  function isContract(address account) internal view returns (bool) {\\n    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n    // for accounts without code, i.e. `keccak256('')`\\n    bytes32 codehash;\\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      codehash := extcodehash(account)\\n    }\\n    return (codehash != accountHash && codehash != 0x0);\\n  }\\n\\n  /**\\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n   * `recipient`, forwarding all available gas and reverting on errors.\\n   *\\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n   * imposed by `transfer`, making them unable to receive funds via\\n   * `transfer`. {sendValue} removes this limitation.\\n   *\\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n   *\\n   * IMPORTANT: because control is transferred to `recipient`, care must be\\n   * taken to not create reentrancy vulnerabilities. Consider using\\n   * {ReentrancyGuard} or the\\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n   */\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance >= amount, 'Address: insufficient balance');\\n\\n    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n    (bool success, ) = recipient.call{value: amount}('');\\n    require(success, 'Address: unable to send value, recipient may have reverted');\\n  }\\n}\\n\"\r\n    },\r\n    \"Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n  address private _owner;\\n\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n  /**\\n   * @dev Initializes the contract setting the deployer as the initial owner.\\n   */\\n  constructor() {\\n    address msgSender = _msgSender();\\n    _owner = msgSender;\\n    emit OwnershipTransferred(address(0), msgSender);\\n  }\\n\\n  /**\\n   * @dev Returns the address of the current owner.\\n   */\\n  function owner() public view returns (address) {\\n    return _owner;\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    require(_owner == _msgSender(), 'Ownable: caller is not the owner');\\n    _;\\n  }\\n\\n  /**\\n   * @dev Leaves the contract without owner. It will not be possible to call\\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\\n   *\\n   * NOTE: Renouncing ownership will leave the contract without an owner,\\n   * thereby removing any functionality that is only available to the owner.\\n   */\\n  function renounceOwnership() public virtual onlyOwner {\\n    emit OwnershipTransferred(_owner, address(0));\\n    _owner = address(0);\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Can only be called by the current owner.\\n   */\\n  function transferOwnership(address newOwner) public virtual onlyOwner {\\n    require(newOwner != address(0), 'Ownable: new owner is the zero address');\\n    emit OwnershipTransferred(_owner, newOwner);\\n    _owner = newOwner;\\n  }\\n}\\n\"\r\n    },\r\n    \"Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.7.6;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n  function _msgSender() internal view virtual returns (address payable) {\\n    return msg.sender;\\n  }\\n\\n  function _msgData() internal view virtual returns (bytes memory) {\\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n    return msg.data;\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {\r\n      \"MultiFeeDistribution.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakingToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Recovered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"rewardsToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDuration\",\"type\":\"uint256\"}],\"name\":\"RewardsDurationUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"locked\",\"type\":\"bool\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"receivedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"penaltyPaid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burned\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardsToken\",\"type\":\"address\"}],\"name\":\"addReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnedSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"claimableRewards\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct MultiFeeDistribution.RewardData[]\",\"name\":\"rewards\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"earnedBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"}],\"internalType\":\"struct MultiFeeDistribution.LockedBalance[]\",\"name\":\"earningsData\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"claimRewards\",\"type\":\"bool\"}],\"name\":\"exit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_rewardTokens\",\"type\":\"address[]\"}],\"name\":\"getReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardsToken\",\"type\":\"address\"}],\"name\":\"getRewardForDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"incentivesController\",\"outputs\":[{\"internalType\":\"contract IChefIncentivesController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardsToken\",\"type\":\"address\"}],\"name\":\"lastTimeRewardApplicable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"lockedBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"locked\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"}],\"internalType\":\"struct MultiFeeDistribution.LockedBalance[]\",\"name\":\"lockData\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockedSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withPenalty\",\"type\":\"bool\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"minters\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintersAreSet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"recoverERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"periodFinish\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdateTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerTokenStored\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardsToken\",\"type\":\"address\"}],\"name\":\"rewardPerToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IChefIncentivesController\",\"name\":\"_controller\",\"type\":\"address\"}],\"name\":\"setIncentivesController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_minters\",\"type\":\"address[]\"}],\"name\":\"setMinters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"lock\",\"type\":\"bool\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingToken\",\"outputs\":[{\"internalType\":\"contract IStakingToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"totalBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"unlockedBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userRewardPerTokenPaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawExpiredLocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"withdrawableBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"penaltyAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burnAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MultiFeeDistribution", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000b1ebdd56729940089ecc3ad0bbeeb12b6842ea6f", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}