{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.8.16;\r\n\r\ninterface IERC20 {\r\n\tevent Approval(address indexed owner, address indexed spender, uint value);\r\n\tevent Transfer(address indexed from, address indexed to, uint value);\r\n\r\n\tfunction name() external view returns (string memory);\r\n\r\n\tfunction symbol() external view returns (string memory);\r\n\r\n\tfunction decimals() external view returns (uint8);\r\n\r\n\tfunction totalSupply() external view returns (uint);\r\n\r\n\tfunction balanceOf(address owner) external view returns (uint);\r\n\r\n\tfunction allowance(address owner, address spender) external view returns (uint);\r\n\r\n\tfunction approve(address spender, uint value) external returns (bool);\r\n\r\n\tfunction transfer(address to, uint value) external returns (bool);\r\n\r\n\tfunction transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n\tevent Approval(address indexed owner, address indexed spender, uint value);\r\n\tevent Transfer(address indexed from, address indexed to, uint value);\r\n\r\n\tfunction name() external pure returns (string memory);\r\n\r\n\tfunction symbol() external pure returns (string memory);\r\n\r\n\tfunction decimals() external pure returns (uint8);\r\n\r\n\tfunction totalSupply() external view returns (uint);\r\n\r\n\tfunction balanceOf(address owner) external view returns (uint);\r\n\r\n\tfunction allowance(address owner, address spender) external view returns (uint);\r\n\r\n\tfunction approve(address spender, uint value) external returns (bool);\r\n\r\n\tfunction transfer(address to, uint value) external returns (bool);\r\n\r\n\tfunction transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n\tfunction PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\r\n\tfunction nonces(address owner) external view returns (uint);\r\n\r\n\tfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n\tevent Mint(address indexed sender, uint amount0, uint amount1);\r\n\tevent Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n\tevent Swap(\r\n\t\taddress indexed sender,\r\n\t\tuint amount0In,\r\n\t\tuint amount1In,\r\n\t\tuint amount0Out,\r\n\t\tuint amount1Out,\r\n\t\taddress indexed to\r\n\t);\r\n\tevent Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n\tfunction MINIMUM_LIQUIDITY() external pure returns (uint);\r\n\r\n\tfunction factory() external view returns (address);\r\n\r\n\tfunction token0() external view returns (address);\r\n\r\n\tfunction token1() external view returns (address);\r\n\r\n\tfunction getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n\r\n\tfunction price0CumulativeLast() external view returns (uint);\r\n\r\n\tfunction price1CumulativeLast() external view returns (uint);\r\n\r\n\tfunction kLast() external view returns (uint);\r\n\r\n\tfunction mint(address to) external returns (uint liquidity);\r\n\r\n\tfunction burn(address to) external returns (uint amount0, uint amount1);\r\n\r\n\tfunction swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n\r\n\tfunction skim(address to) external;\r\n\r\n\tfunction sync() external;\r\n\r\n\tfunction initialize(address, address) external;\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n\t// Booleans are more expensive than uint256 or any type that takes up a full\r\n\t// word because each write operation emits an extra SLOAD to first read the\r\n\t// slot's contents, replace the bits taken up by the boolean, and then write\r\n\t// back. This is the compiler's defense against contract upgrades and\r\n\t// pointer aliasing, and it cannot be disabled.\r\n\r\n\t// The values being non-zero value makes deployment a bit more expensive,\r\n\t// but in exchange the refund on every call to nonReentrant will be lower in\r\n\t// amount. Since refunds are capped to a percentage of the total\r\n\t// transaction's gas, it is best to keep them low in cases like this one, to\r\n\t// increase the likelihood of the full refund coming into effect.\r\n\tuint256 private constant _NOT_ENTERED = 1;\r\n\tuint256 private constant _ENTERED = 2;\r\n\r\n\tuint256 private _status;\r\n\r\n\tconstructor() {\r\n\t\t_status = _NOT_ENTERED;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Prevents a contract from calling itself, directly or indirectly.\r\n\t * Calling a `nonReentrant` function from another `nonReentrant`\r\n\t * function is not supported. It is possible to prevent this from happening\r\n\t * by making the `nonReentrant` function external, and making it call a\r\n\t * `private` function that does the actual work.\r\n\t */\r\n\tmodifier nonReentrant() {\r\n\t\t_nonReentrantBefore();\r\n\t\t_;\r\n\t\t_nonReentrantAfter();\r\n\t}\r\n\r\n\tfunction _nonReentrantBefore() private {\r\n\t\t// On the first call to nonReentrant, _status will be _NOT_ENTERED\r\n\t\trequire(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n\t\t// Any calls to nonReentrant after this point will fail\r\n\t\t_status = _ENTERED;\r\n\t}\r\n\r\n\tfunction _nonReentrantAfter() private {\r\n\t\t// By storing the original value once again, a refund is triggered (see\r\n\t\t// https://eips.ethereum.org/EIPS/eip-2200)\r\n\t\t_status = _NOT_ENTERED;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\r\n\t * `nonReentrant` function in the call stack.\r\n\t */\r\n\tfunction _reentrancyGuardEntered() internal view returns (bool) {\r\n\t\treturn _status == _ENTERED;\r\n\t}\r\n}\r\n\r\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\r\n\r\n/**\r\n * @dev External interface of AccessControl declared to support ERC165 detection.\r\n */\r\ninterface IAccessControl {\r\n\t/**\r\n\t * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\r\n\t *\r\n\t * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\r\n\t * {RoleAdminChanged} not being emitted signaling this.\r\n\t *\r\n\t * _Available since v3.1._\r\n\t */\r\n\tevent RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\r\n\r\n\t/**\r\n\t * @dev Emitted when `account` is granted `role`.\r\n\t *\r\n\t * `sender` is the account that originated the contract call, an admin role\r\n\t * bearer except when using {AccessControl-_setupRole}.\r\n\t */\r\n\tevent RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\r\n\r\n\t/**\r\n\t * @dev Emitted when `account` is revoked `role`.\r\n\t *\r\n\t * `sender` is the account that originated the contract call:\r\n\t *   - if using `revokeRole`, it is the admin role bearer\r\n\t *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\r\n\t */\r\n\tevent RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\r\n\r\n\t/**\r\n\t * @dev Returns `true` if `account` has been granted `role`.\r\n\t */\r\n\tfunction hasRole(bytes32 role, address account) external view returns (bool);\r\n\r\n\t/**\r\n\t * @dev Returns the admin role that controls `role`. See {grantRole} and\r\n\t * {revokeRole}.\r\n\t *\r\n\t * To change a role's admin, use {AccessControl-_setRoleAdmin}.\r\n\t */\r\n\tfunction getRoleAdmin(bytes32 role) external view returns (bytes32);\r\n\r\n\t/**\r\n\t * @dev Grants `role` to `account`.\r\n\t *\r\n\t * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n\t * event.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - the caller must have ``role``'s admin role.\r\n\t */\r\n\tfunction grantRole(bytes32 role, address account) external;\r\n\r\n\t/**\r\n\t * @dev Revokes `role` from `account`.\r\n\t *\r\n\t * If `account` had been granted `role`, emits a {RoleRevoked} event.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - the caller must have ``role``'s admin role.\r\n\t */\r\n\tfunction revokeRole(bytes32 role, address account) external;\r\n\r\n\t/**\r\n\t * @dev Revokes `role` from the calling account.\r\n\t *\r\n\t * Roles are often managed via {grantRole} and {revokeRole}: this function's\r\n\t * purpose is to provide a mechanism for accounts to lose their privileges\r\n\t * if they are compromised (such as when a trusted device is misplaced).\r\n\t *\r\n\t * If the calling account had been granted `role`, emits a {RoleRevoked}\r\n\t * event.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - the caller must be `account`.\r\n\t */\r\n\tfunction renounceRole(bytes32 role, address account) external;\r\n}\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n\tfunction _msgSender() internal view virtual returns (address) {\r\n\t\treturn msg.sender;\r\n\t}\r\n\r\n\tfunction _msgData() internal view virtual returns (bytes calldata) {\r\n\t\treturn msg.data;\r\n\t}\r\n}\r\n\r\nlibrary Math {\r\n\tenum Rounding {\r\n\t\tDown, // Toward negative infinity\r\n\t\tUp, // Toward infinity\r\n\t\tZero // Toward zero\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the largest of two numbers.\r\n\t */\r\n\t// function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t//     return a > b ? a : b;\r\n\t// }\r\n\r\n\t/**\r\n\t * @dev Returns the smallest of two numbers.\r\n\t */\r\n\tfunction min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn a < b ? a : b;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the average of two numbers. The result is rounded towards\r\n\t * zero.\r\n\t */\r\n\t// function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t//     // (a + b) / 2 can overflow.\r\n\t//     return (a & b) + (a ^ b) / 2;\r\n\t// }\r\n\r\n\t/**\r\n\t * @dev Returns the ceiling of the division of two numbers.\r\n\t *\r\n\t * This differs from standard division with `/` in that it rounds up instead\r\n\t * of rounding down.\r\n\t */\r\n\t// function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t//     // (a + b - 1) / b can overflow on addition, so we distribute.\r\n\t//     return a == 0 ? 0 : (a - 1) / b + 1;\r\n\t// }\r\n\r\n\t/**\r\n\t * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\r\n\t *\r\n\t * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\r\n\t */\r\n\t// function sqrt(uint256 a) internal pure returns (uint256) {\r\n\t//     if (a == 0) {\r\n\t//         return 0;\r\n\t//     }\r\n\r\n\t//     // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\r\n\t//     //\r\n\t//     // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\r\n\t//     // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\r\n\t//     //\r\n\t//     // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\r\n\t//     // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\r\n\t//     // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\r\n\t//     //\r\n\t//     // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\r\n\t//     uint256 result = 1 << (log2(a) >> 1);\r\n\r\n\t//     // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\r\n\t//     // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\r\n\t//     // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\r\n\t//     // into the expected uint128 result.\r\n\t//     unchecked {\r\n\t//         result = (result + a / result) >> 1;\r\n\t//         result = (result + a / result) >> 1;\r\n\t//         result = (result + a / result) >> 1;\r\n\t//         result = (result + a / result) >> 1;\r\n\t//         result = (result + a / result) >> 1;\r\n\t//         result = (result + a / result) >> 1;\r\n\t//         result = (result + a / result) >> 1;\r\n\t//         return min(result, a / result);\r\n\t//     }\r\n\t// }\r\n\r\n\t/**\r\n\t * @notice Calculates sqrt(a), following the selected rounding direction.\r\n\t */\r\n\t// function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\r\n\t//     unchecked {\r\n\t//         uint256 result = sqrt(a);\r\n\t//         return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\r\n\t//     }\r\n\t// }\r\n\r\n\t/**\r\n\t * @dev Return the log in base 2, rounded down, of a positive value.\r\n\t * Returns 0 if given 0.\r\n\t */\r\n\tfunction log2(uint256 value) internal pure returns (uint256) {\r\n\t\tuint256 result = 0;\r\n\t\tunchecked {\r\n\t\t\tif (value >> 128 > 0) {\r\n\t\t\t\tvalue >>= 128;\r\n\t\t\t\tresult += 128;\r\n\t\t\t}\r\n\t\t\tif (value >> 64 > 0) {\r\n\t\t\t\tvalue >>= 64;\r\n\t\t\t\tresult += 64;\r\n\t\t\t}\r\n\t\t\tif (value >> 32 > 0) {\r\n\t\t\t\tvalue >>= 32;\r\n\t\t\t\tresult += 32;\r\n\t\t\t}\r\n\t\t\tif (value >> 16 > 0) {\r\n\t\t\t\tvalue >>= 16;\r\n\t\t\t\tresult += 16;\r\n\t\t\t}\r\n\t\t\tif (value >> 8 > 0) {\r\n\t\t\t\tvalue >>= 8;\r\n\t\t\t\tresult += 8;\r\n\t\t\t}\r\n\t\t\tif (value >> 4 > 0) {\r\n\t\t\t\tvalue >>= 4;\r\n\t\t\t\tresult += 4;\r\n\t\t\t}\r\n\t\t\tif (value >> 2 > 0) {\r\n\t\t\t\tvalue >>= 2;\r\n\t\t\t\tresult += 2;\r\n\t\t\t}\r\n\t\t\tif (value >> 1 > 0) {\r\n\t\t\t\tresult += 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\r\n\t * Returns 0 if given 0.\r\n\t */\r\n\t// function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n\t//     unchecked {\r\n\t//         uint256 result = log2(value);\r\n\t//         return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\r\n\t//     }\r\n\t// }\r\n\r\n\t/**\r\n\t * @dev Return the log in base 10, rounded down, of a positive value.\r\n\t * Returns 0 if given 0.\r\n\t */\r\n\tfunction log10(uint256 value) internal pure returns (uint256) {\r\n\t\tuint256 result = 0;\r\n\t\tunchecked {\r\n\t\t\tif (value >= 10 ** 64) {\r\n\t\t\t\tvalue /= 10 ** 64;\r\n\t\t\t\tresult += 64;\r\n\t\t\t}\r\n\t\t\tif (value >= 10 ** 32) {\r\n\t\t\t\tvalue /= 10 ** 32;\r\n\t\t\t\tresult += 32;\r\n\t\t\t}\r\n\t\t\tif (value >= 10 ** 16) {\r\n\t\t\t\tvalue /= 10 ** 16;\r\n\t\t\t\tresult += 16;\r\n\t\t\t}\r\n\t\t\tif (value >= 10 ** 8) {\r\n\t\t\t\tvalue /= 10 ** 8;\r\n\t\t\t\tresult += 8;\r\n\t\t\t}\r\n\t\t\tif (value >= 10 ** 4) {\r\n\t\t\t\tvalue /= 10 ** 4;\r\n\t\t\t\tresult += 4;\r\n\t\t\t}\r\n\t\t\tif (value >= 10 ** 2) {\r\n\t\t\t\tvalue /= 10 ** 2;\r\n\t\t\t\tresult += 2;\r\n\t\t\t}\r\n\t\t\tif (value >= 10 ** 1) {\r\n\t\t\t\tresult += 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\r\n\t * Returns 0 if given 0.\r\n\t */\r\n\t// function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n\t//     unchecked {\r\n\t//         uint256 result = log10(value);\r\n\t//         return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\r\n\t//     }\r\n\t// }\r\n\r\n\t/**\r\n\t * @dev Return the log in base 256, rounded down, of a positive value.\r\n\t * Returns 0 if given 0.\r\n\t *\r\n\t * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\r\n\t */\r\n\tfunction log256(uint256 value) internal pure returns (uint256) {\r\n\t\tuint256 result = 0;\r\n\t\tunchecked {\r\n\t\t\tif (value >> 128 > 0) {\r\n\t\t\t\tvalue >>= 128;\r\n\t\t\t\tresult += 16;\r\n\t\t\t}\r\n\t\t\tif (value >> 64 > 0) {\r\n\t\t\t\tvalue >>= 64;\r\n\t\t\t\tresult += 8;\r\n\t\t\t}\r\n\t\t\tif (value >> 32 > 0) {\r\n\t\t\t\tvalue >>= 32;\r\n\t\t\t\tresult += 4;\r\n\t\t\t}\r\n\t\t\tif (value >> 16 > 0) {\r\n\t\t\t\tvalue >>= 16;\r\n\t\t\t\tresult += 2;\r\n\t\t\t}\r\n\t\t\tif (value >> 8 > 0) {\r\n\t\t\t\tresult += 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\r\n\t * Returns 0 if given 0.\r\n\t */\r\n\t// function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n\t//     unchecked {\r\n\t//         uint256 result = log256(value);\r\n\t//         return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\r\n\t//     }\r\n\t// }\r\n}\r\n\r\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\r\n\r\n/**\r\n * @dev Standard signed math utilities missing in the Solidity language.\r\n */\r\nlibrary SignedMath {\r\n\t/**\r\n\t * @dev Returns the absolute unsigned value of a signed value.\r\n\t */\r\n\tfunction abs(int256 n) internal pure returns (uint256) {\r\n\t\tunchecked {\r\n\t\t\t// must be unchecked in order to support `n = type(int256).min`\r\n\t\t\treturn uint256(n >= 0 ? n : -n);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n\tbytes16 private constant _SYMBOLS = \"0123456789abcdef\";\r\n\tuint8 private constant _ADDRESS_LENGTH = 20;\r\n\r\n\t/**\r\n\t * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n\t */\r\n\tfunction toString(uint256 value) internal pure returns (string memory) {\r\n\t\tunchecked {\r\n\t\t\tuint256 length = Math.log10(value) + 1;\r\n\t\t\tstring memory buffer = new string(length);\r\n\t\t\tuint256 ptr;\r\n\t\t\t/// @solidity memory-safe-assembly\r\n\t\t\tassembly {\r\n\t\t\t\tptr := add(buffer, add(32, length))\r\n\t\t\t}\r\n\t\t\twhile (true) {\r\n\t\t\t\tptr--;\r\n\t\t\t\t/// @solidity memory-safe-assembly\r\n\t\t\t\tassembly {\r\n\t\t\t\t\tmstore8(ptr, byte(mod(value, 10), _SYMBOLS))\r\n\t\t\t\t}\r\n\t\t\t\tvalue /= 10;\r\n\t\t\t\tif (value == 0) break;\r\n\t\t\t}\r\n\t\t\treturn buffer;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Converts a `int256` to its ASCII `string` decimal representation.\r\n\t */\r\n\t// function toString(int256 value) internal pure returns (string memory) {\r\n\t//     return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\r\n\t// }\r\n\r\n\t/**\r\n\t * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n\t */\r\n\t// function toHexString(uint256 value) internal pure returns (string memory) {\r\n\t//     unchecked {\r\n\t//         return toHexString(value, Math.log256(value) + 1);\r\n\t//     }\r\n\t// }\r\n\r\n\t/**\r\n\t * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n\t */\r\n\tfunction toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n\t\tbytes memory buffer = new bytes(2 * length + 2);\r\n\t\tbuffer[0] = \"0\";\r\n\t\tbuffer[1] = \"x\";\r\n\t\tfor (uint256 i = 2 * length + 1; i > 1; --i) {\r\n\t\t\tbuffer[i] = _SYMBOLS[value & 0xf];\r\n\t\t\tvalue >>= 4;\r\n\t\t}\r\n\t\trequire(value == 0, \"Strings: hex length insufficient\");\r\n\t\treturn string(buffer);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\r\n\t */\r\n\tfunction toHexString(address addr) internal pure returns (string memory) {\r\n\t\treturn toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns true if the two strings are equal.\r\n\t */\r\n\t// function equal(string memory a, string memory b) internal pure returns (bool) {\r\n\t//     return keccak256(bytes(a)) == keccak256(bytes(b));\r\n\t// }\r\n}\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n\t/**\r\n\t * @dev Returns true if this contract implements the interface defined by\r\n\t * `interfaceId`. See the corresponding\r\n\t * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n\t * to learn more about how these ids are created.\r\n\t *\r\n\t * This function call must use less than 30 000 gas.\r\n\t */\r\n\tfunction supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n\t/**\r\n\t * @dev See {IERC165-supportsInterface}.\r\n\t */\r\n\tfunction supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n\t\treturn interfaceId == type(IERC165).interfaceId;\r\n\t}\r\n}\r\n\r\n/**\r\n * @dev Contract module that allows children to implement role-based access\r\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\r\n * members except through off-chain means by accessing the contract event logs. Some\r\n * applications may benefit from on-chain enumerability, for those cases see\r\n * {AccessControlEnumerable}.\r\n *\r\n * Roles are referred to by their `bytes32` identifier. These should be exposed\r\n * in the external API and be unique. The best way to achieve this is by\r\n * using `public constant` hash digests:\r\n *\r\n * ```solidity\r\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\r\n * ```\r\n *\r\n * Roles can be used to represent a set of permissions. To restrict access to a\r\n * function call, use {hasRole}:\r\n *\r\n * ```solidity\r\n * function foo() public {\r\n *     require(hasRole(MY_ROLE, msg.sender));\r\n *     ...\r\n * }\r\n * ```\r\n *\r\n * Roles can be granted and revoked dynamically via the {grantRole} and\r\n * {revokeRole} functions. Each role has an associated admin role, and only\r\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\r\n *\r\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\r\n * that only accounts with this role will be able to grant or revoke other\r\n * roles. More complex role relationships can be created by using\r\n * {_setRoleAdmin}.\r\n *\r\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\r\n * grant and revoke this role. Extra precautions should be taken to secure\r\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\r\n * to enforce additional security measures for this role.\r\n */\r\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\r\n\tstruct RoleData {\r\n\t\tmapping(address => bool) members;\r\n\t\tbytes32 adminRole;\r\n\t}\r\n\r\n\tmapping(bytes32 => RoleData) private _roles;\r\n\r\n\tbytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\r\n\r\n\t/**\r\n\t * @dev Modifier that checks that an account has a specific role. Reverts\r\n\t * with a standardized message including the required role.\r\n\t *\r\n\t * The format of the revert reason is given by the following regular expression:\r\n\t *\r\n\t *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\r\n\t *\r\n\t * _Available since v4.1._\r\n\t */\r\n\tmodifier onlyRole(bytes32 role) {\r\n\t\t_checkRole(role);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IERC165-supportsInterface}.\r\n\t */\r\n\tfunction supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n\t\treturn interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns `true` if `account` has been granted `role`.\r\n\t */\r\n\tfunction hasRole(bytes32 role, address account) public view virtual override returns (bool) {\r\n\t\treturn _roles[role].members[account];\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Revert with a standard message if `_msgSender()` is missing `role`.\r\n\t * Overriding this function changes the behavior of the {onlyRole} modifier.\r\n\t *\r\n\t * Format of the revert message is described in {_checkRole}.\r\n\t *\r\n\t * _Available since v4.6._\r\n\t */\r\n\tfunction _checkRole(bytes32 role) internal view virtual {\r\n\t\t_checkRole(role, _msgSender());\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Revert with a standard message if `account` is missing `role`.\r\n\t *\r\n\t * The format of the revert reason is given by the following regular expression:\r\n\t *\r\n\t *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\r\n\t */\r\n\tfunction _checkRole(bytes32 role, address account) internal view virtual {\r\n\t\tif (!hasRole(role, account)) {\r\n\t\t\trevert(\r\n\t\t\t\tstring(\r\n\t\t\t\t\tabi.encodePacked(\r\n\t\t\t\t\t\t\"AccessControl: account \",\r\n\t\t\t\t\t\tStrings.toHexString(account),\r\n\t\t\t\t\t\t\" is missing role \",\r\n\t\t\t\t\t\tStrings.toHexString(uint256(role), 32)\r\n\t\t\t\t\t)\r\n\t\t\t\t)\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the admin role that controls `role`. See {grantRole} and\r\n\t * {revokeRole}.\r\n\t *\r\n\t * To change a role's admin, use {_setRoleAdmin}.\r\n\t */\r\n\tfunction getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\r\n\t\treturn _roles[role].adminRole;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Grants `role` to `account`.\r\n\t *\r\n\t * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n\t * event.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - the caller must have ``role``'s admin role.\r\n\t *\r\n\t * May emit a {RoleGranted} event.\r\n\t */\r\n\tfunction grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\r\n\t\t_grantRole(role, account);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Revokes `role` from `account`.\r\n\t *\r\n\t * If `account` had been granted `role`, emits a {RoleRevoked} event.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - the caller must have ``role``'s admin role.\r\n\t *\r\n\t * May emit a {RoleRevoked} event.\r\n\t */\r\n\tfunction revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\r\n\t\t_revokeRole(role, account);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Revokes `role` from the calling account.\r\n\t *\r\n\t * Roles are often managed via {grantRole} and {revokeRole}: this function's\r\n\t * purpose is to provide a mechanism for accounts to lose their privileges\r\n\t * if they are compromised (such as when a trusted device is misplaced).\r\n\t *\r\n\t * If the calling account had been revoked `role`, emits a {RoleRevoked}\r\n\t * event.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - the caller must be `account`.\r\n\t *\r\n\t * May emit a {RoleRevoked} event.\r\n\t */\r\n\tfunction renounceRole(bytes32 role, address account) public virtual override {\r\n\t\trequire(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\r\n\r\n\t\t_revokeRole(role, account);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Grants `role` to `account`.\r\n\t *\r\n\t * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n\t * event. Note that unlike {grantRole}, this function doesn't perform any\r\n\t * checks on the calling account.\r\n\t *\r\n\t * May emit a {RoleGranted} event.\r\n\t *\r\n\t * [WARNING]\r\n\t * ====\r\n\t * This function should only be called from the constructor when setting\r\n\t * up the initial roles for the system.\r\n\t *\r\n\t * Using this function in any other way is effectively circumventing the admin\r\n\t * system imposed by {AccessControl}.\r\n\t * ====\r\n\t *\r\n\t * NOTE: This function is deprecated in favor of {_grantRole}.\r\n\t */\r\n\tfunction _setupRole(bytes32 role, address account) internal virtual {\r\n\t\t_grantRole(role, account);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Sets `adminRole` as ``role``'s admin role.\r\n\t *\r\n\t * Emits a {RoleAdminChanged} event.\r\n\t */\r\n\tfunction _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\r\n\t\tbytes32 previousAdminRole = getRoleAdmin(role);\r\n\t\t_roles[role].adminRole = adminRole;\r\n\t\temit RoleAdminChanged(role, previousAdminRole, adminRole);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Grants `role` to `account`.\r\n\t *\r\n\t * Internal function without access restriction.\r\n\t *\r\n\t * May emit a {RoleGranted} event.\r\n\t */\r\n\tfunction _grantRole(bytes32 role, address account) internal virtual {\r\n\t\tif (!hasRole(role, account)) {\r\n\t\t\t_roles[role].members[account] = true;\r\n\t\t\temit RoleGranted(role, account, _msgSender());\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Revokes `role` from `account`.\r\n\t *\r\n\t * Internal function without access restriction.\r\n\t *\r\n\t * May emit a {RoleRevoked} event.\r\n\t */\r\n\tfunction _revokeRole(bytes32 role, address account) internal virtual {\r\n\t\tif (hasRole(role, account)) {\r\n\t\t\t_roles[role].members[account] = false;\r\n\t\t\temit RoleRevoked(role, account, _msgSender());\r\n\t\t}\r\n\t}\r\n}\r\n\r\nlibrary TransferHelper {\r\n\tfunction safeApprove(address token, address to, uint value) internal {\r\n\t\t// bytes4(keccak256(bytes('approve(address,uint256)')));\r\n\t\t(bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n\t\trequire(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper: APPROVE_FAILED\");\r\n\t}\r\n\r\n\tfunction safeTransfer(address token, address to, uint value) internal {\r\n\t\t// bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n\t\t(bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n\t\trequire(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper: TRANSFER_FAILED\");\r\n\t}\r\n\r\n\tfunction safeTransferFrom(address token, address from, address to, uint value) internal {\r\n\t\t// bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n\t\t(bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n\t\trequire(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper: TRANSFER_FROM_FAILED\");\r\n\t}\r\n\r\n\tfunction safeTransferETH(address to, uint value) internal {\r\n\t\t(bool success, ) = to.call{ value: value }(new bytes(0));\r\n\t\trequire(success, \"TransferHelper: ETH_TRANSFER_FAILED\");\r\n\t}\r\n}\r\n\r\nlibrary UniSwapV2Library {\r\n\t// returns sorted token addresses, used to handle return values from pairs sorted in this order\r\n\tfunction sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\r\n\t\trequire(tokenA != tokenB, \"UniSwapV2Library: IDENTICAL_ADDRESSES\");\r\n\t\t(token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n\t\trequire(token0 != address(0), \"UniSwapV2Library: ZERO_ADDRESS\");\r\n\t}\r\n\r\n\t// calculates the CREATE2 address for a pair without making any external calls\r\n\tfunction pairFor(\r\n\t\taddress factory,\r\n\t\taddress tokenA,\r\n\t\taddress tokenB,\r\n\t\tbytes32 creationCode\r\n\t) internal pure returns (address pair) {\r\n\t\t(address token0, address token1) = sortTokens(tokenA, tokenB);\r\n\t\tpair = address(\r\n\t\t\tuint160(\r\n\t\t\t\tuint(\r\n\t\t\t\t\tkeccak256(\r\n\t\t\t\t\t\tabi.encodePacked(\r\n\t\t\t\t\t\t\thex\"ff\",\r\n\t\t\t\t\t\t\tfactory,\r\n\t\t\t\t\t\t\tkeccak256(abi.encodePacked(token0, token1)),\r\n\t\t\t\t\t\t\tcreationCode // init code hash (creationCode of factory)\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t)\r\n\t\t\t\t)\r\n\t\t\t)\r\n\t\t);\r\n\t}\r\n\r\n\t// fetches and sorts the reserves for a pair\r\n\tfunction getReserves(\r\n\t\taddress factory,\r\n\t\taddress tokenA,\r\n\t\taddress tokenB,\r\n\t\tbytes32 creationCode\r\n\t) internal view returns (uint reserveA, uint reserveB) {\r\n\t\t(address token0, ) = sortTokens(tokenA, tokenB);\r\n\t\tpairFor(factory, tokenA, tokenB, creationCode);\r\n\t\t(uint reserve0, uint reserve1, ) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB, creationCode)).getReserves();\r\n\t\t(reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n\t}\r\n\r\n\t// given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\r\n\tfunction quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\r\n\t\trequire(amountA > 0, \"UniSwapV2Library: INSUFFICIENT_AMOUNT\");\r\n\t\trequire(reserveA > 0 && reserveB > 0, \"UniSwapV2Library: INSUFFICIENT_LIQUIDITY\");\r\n\t\tamountB = amountA * reserveB / reserveA;\r\n\t}\r\n\r\n\t// given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\r\n\tfunction getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\r\n\t\trequire(amountIn > 0, \"UniSwapV2Library: INSUFFICIENT_INPUT_AMOUNT\");\r\n\t\trequire(reserveIn > 0 && reserveOut > 0, \"UniSwapV2Library: INSUFFICIENT_LIQUIDITY\");\r\n\t\tuint amountInWithFee = amountIn * 9975;\r\n\t\tuint numerator = amountInWithFee * reserveOut;\r\n\t\tuint denominator = reserveIn * 10000 + amountInWithFee;\r\n\t\tamountOut = numerator / denominator;\r\n\t}\r\n\r\n\t// given an output amount of an asset and pair reserves, returns a required input amount of the other asset\r\n\tfunction getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\r\n\t\trequire(amountOut > 0, \"UniSwapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\");\r\n\t\trequire(reserveIn > 0 && reserveOut > 0, \"UniSwapV2Library: INSUFFICIENT_LIQUIDITY\");\r\n\t\tuint numerator = reserveIn * amountOut * 10000;\r\n\t\tuint denominator = (reserveOut - amountOut) * 9975;\r\n\t\tamountIn = (numerator / denominator) + 1;\r\n\t}\r\n\r\n\t// performs chained getAmountOut calculations on any number of pairs\r\n\tfunction getAmountsOut(\r\n\t\taddress factory,\r\n\t\tuint amountIn,\r\n\t\taddress[] memory path,\r\n\t\tbytes32 creationCode\r\n\t) internal view returns (uint[] memory amounts) {\r\n\t\trequire(path.length >= 2, \"UniSwapV2Library: INVALID_PATH\");\r\n\t\tamounts = new uint[](path.length);\r\n\t\tamounts[0] = amountIn;\r\n\t\tfor (uint i; i < path.length - 1; i++) {\r\n\t\t\t(uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1], creationCode);\r\n\t\t\tamounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\r\n\t\t}\r\n\t}\r\n\r\n\t// performs chained getAmountIn calculations on any number of pairs\r\n\tfunction getAmountsIn(\r\n\t\taddress factory,\r\n\t\tuint amountOut,\r\n\t\taddress[] memory path,\r\n\t\tbytes32 creationCode\r\n\t) internal view returns (uint[] memory amounts) {\r\n\t\trequire(path.length >= 2, \"UniSwapV2Library: INVALID_PATH\");\r\n\t\tamounts = new uint[](path.length);\r\n\t\tamounts[amounts.length - 1] = amountOut;\r\n\t\tfor (uint i = path.length - 1; i > 0; i--) {\r\n\t\t\t(uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i], creationCode);\r\n\t\t\tamounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nabstract contract SwapUtils is ReentrancyGuard, AccessControl {\r\n\tenum SWAPTYPE {\r\n\t\tU2BNB,\r\n\t\tU2ETH,\r\n\t\tU2BTC,\r\n\t\tBNB2U,\r\n\t\tETH2U,\r\n\t\tBTC2U\r\n\t}\r\n\r\n\taddress public immutable usdtToken;\r\n\taddress public immutable bnbToken;\r\n\taddress public immutable ethToken;\r\n\taddress public immutable btcToken;\r\n\taddress public factory;\r\n\tbytes32 public creationCode;\r\n\tuint256 public immutable slippage;\r\n\tuint256 public immutable u2TokenMax;\r\n\tuint256 public immutable bnb2UMax;\r\n\tuint256 public immutable eth2UMax;\r\n\tuint256 public immutable btc2UMax;\r\n\r\n\tconstructor() {\r\n\t\tfactory = 0x858E3312ed3A876947EA49d572A7C42DE08af7EE;\r\n\t\tcreationCode = 0xfea293c909d87cd4153593f077b76bb7e94340200f4ee84211ae8e4f9bd7ffdf;\r\n\t\tusdtToken = 0x55d398326f99059fF775485246999027B3197955;\r\n\t\tbnbToken = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\r\n\t\tethToken = 0x2170Ed0880ac9A755fd29B2688956BD959F933F8;\r\n\t\tbtcToken = 0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c;\r\n\t\tslippage = 10; // 10/1000\r\n\t\tu2TokenMax = 5000 * 1e18;\r\n\t\tbnb2UMax = 20 * 1e18;\r\n\t\teth2UMax = 2 * 1e18;\r\n\t\tbtc2UMax = (2 * 1e18) / 10;\r\n\t}\r\n\r\n\tfunction _swapData(\r\n\t\tSWAPTYPE _type\r\n\t) internal view returns (uint256 amountIn, address inputToken, address outputToken) {\r\n\t\tif (_type == SWAPTYPE.U2BNB) {\r\n\t\t\tamountIn = Math.min(IERC20(usdtToken).balanceOf(address(this)), u2TokenMax);\r\n\t\t\tinputToken = usdtToken;\r\n\t\t\toutputToken = bnbToken;\r\n\t\t} else if (_type == SWAPTYPE.U2ETH) {\r\n\t\t\tamountIn = Math.min(IERC20(usdtToken).balanceOf(address(this)), u2TokenMax);\r\n\t\t\tinputToken = usdtToken;\r\n\t\t\toutputToken = ethToken;\r\n\t\t} else if (_type == SWAPTYPE.U2BTC) {\r\n\t\t\tamountIn = Math.min(IERC20(usdtToken).balanceOf(address(this)), u2TokenMax);\r\n\t\t\tinputToken = usdtToken;\r\n\t\t\toutputToken = btcToken;\r\n\t\t} else if (_type == SWAPTYPE.BNB2U) {\r\n\t\t\tamountIn = Math.min(IERC20(bnbToken).balanceOf(address(this)), bnb2UMax);\r\n\t\t\tinputToken = bnbToken;\r\n\t\t\toutputToken = usdtToken;\r\n\t\t} else if (_type == SWAPTYPE.ETH2U) {\r\n\t\t\tamountIn = Math.min(IERC20(ethToken).balanceOf(address(this)), eth2UMax);\r\n\t\t\tinputToken = ethToken;\r\n\t\t\toutputToken = usdtToken;\r\n\t\t} else if (_type == SWAPTYPE.BTC2U) {\r\n\t\t\tamountIn = Math.min(IERC20(btcToken).balanceOf(address(this)), btc2UMax);\r\n\t\t\tinputToken = btcToken;\r\n\t\t\toutputToken = usdtToken;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _swapExactTokensForTokens(\r\n\t\tuint256 amountIn,\r\n\t\taddress[] memory path,\r\n\t\taddress to\r\n\t) internal virtual returns (uint256[] memory amounts) {\r\n\t\tamounts = UniSwapV2Library.getAmountsOut(factory, amountIn, path, creationCode);\r\n\t\taddress pair = UniSwapV2Library.pairFor(factory, path[0], path[1], creationCode);\r\n\t\tif (pair == address(0)) revert(\"zero address\");\r\n\t\tTransferHelper.safeTransfer(\r\n\t\t\tpath[0],\r\n\t\t\tpair,\r\n\t\t\tamountIn\r\n\t\t);\r\n\r\n\t\t_swap(amounts, path, to);\r\n\t}\r\n\r\n\tfunction _swap(uint256[] memory amounts, address[] memory path, address _to) private {\r\n\t\tfor (uint256 i; i < path.length - 1; i++) {\r\n\t\t\t(address input, address output) = (path[i], path[i + 1]);\r\n\t\t\t(address token0, ) = UniSwapV2Library.sortTokens(input, output);\r\n\t\t\tuint256 amountOut = amounts[i + 1];\r\n\t\t\t(uint256 amount0Out, uint256 amount1Out) = input == token0\r\n\t\t\t\t? (uint256(0), amountOut)\r\n\t\t\t\t: (amountOut, uint256(0));\r\n\t\t\taddress to = i < path.length - 2\r\n\t\t\t\t? UniSwapV2Library.pairFor(factory, output, path[i + 2], creationCode)\r\n\t\t\t\t: _to;\r\n\t\t\tIUniswapV2Pair(UniSwapV2Library.pairFor(factory, input, output, creationCode)).swap(\r\n\t\t\t\tamount0Out,\r\n\t\t\t\tamount1Out,\r\n\t\t\t\tto,\r\n\t\t\t\tnew bytes(0)\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _swapTo(address[] memory path, address to, uint256 amountIn) internal virtual returns (uint256) {\r\n\t\tuint256[] memory amounts = _swapExactTokensForTokens(amountIn, path, to);\r\n\t\taddress[] memory path_1 = new address[](2);\r\n\t\tpath_1[0] = path[1];\r\n\t\tpath_1[1] = path[0];\r\n\t\tuint256[] memory amounts1 = UniSwapV2Library.getAmountsOut(factory, amounts[1], path_1, creationCode);\r\n\t\trequire(amounts1[1] >= (amountIn - ((amountIn * slippage) / 1000)), \"swap amount error\");\r\n\t\treturn amounts[1];\r\n\t}\r\n\r\n\tfunction _setFactory(address _factory, bytes32 _creationCode) internal virtual {\r\n\t\tfactory = _factory;\r\n\t\tcreationCode = _creationCode;\r\n\t}\r\n}\r\n\r\ncontract FeeFund is SwapUtils {\r\n\tbytes32 public constant CALL_AUTH_ROLE = keccak256(\"CALL_AUTH_ROLE\");\r\n\tbytes32 public constant SWAP_AUTH_ROLE = keccak256(\"SWAP_AUTH_ROLE\");\r\n\tbytes32 public constant SET_RATE_ROLE = keccak256(\"SET_RATE_ROLE\");\r\n\r\n\taddress public immutable fundTo;\r\n\tuint256 public rate;\r\n\r\n\tconstructor(address _fundTo, address _rateAuth, address _swapAuth, address _callAuth) {\r\n\t\tif (_fundTo == address(0)) revert(\"zero address\");\r\n\t\t_grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\r\n\t\t_grantRole(CALL_AUTH_ROLE, _callAuth);\r\n\t\t_grantRole(SET_RATE_ROLE, _rateAuth);\r\n\t\t_grantRole(SWAP_AUTH_ROLE, _swapAuth);\r\n\r\n\t\tfundTo = _fundTo;\r\n\r\n\t\trate = 50000; // 5 * 10000\r\n\t}\r\n\r\n\tfunction release() external onlyRole(CALL_AUTH_ROLE) {\r\n\t\tuint _balance = IERC20(usdtToken).balanceOf(address(this));\r\n\t\tuint _amount = (_balance * rate) / (100 * 10000);\r\n\t\tif (_amount > 0) TransferHelper.safeTransfer(usdtToken, fundTo, _amount);\r\n\t}\r\n\r\n\tfunction setRate(uint256 _rate) external onlyRole(SET_RATE_ROLE) {\r\n\t\trate = _rate;\r\n\t}\r\n\r\n\tfunction dexSwapWithType(SWAPTYPE _type) external nonReentrant onlyRole(SWAP_AUTH_ROLE) {\r\n\t\taddress[] memory path = new address[](2);\r\n\t\t(uint256 amountIn, address inputToken, address outputToken) = _swapData(_type);\r\n\t\tpath[0] = inputToken;\r\n\t\tpath[1] = outputToken;\r\n\t\t_swapTo(path, address(this), amountIn);\r\n\t}\r\n\r\n\tfunction customDexSwap(\r\n\t\taddress _factory,\r\n\t\tuint256 _amountIn,\r\n\t\taddress[] calldata _path\r\n\t) external nonReentrant onlyRole(SWAP_AUTH_ROLE) {\r\n\t\tif (_factory == 0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73) {\r\n\t\t\t// pancake\r\n\t\t\taddress factory_ = factory;\r\n\t\t\tbytes32 creationCode_ = creationCode;\r\n\t\t\t_setFactory(_factory, hex'00fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5');\r\n\t\t\t_swapTo(_path, address(this), Math.min(_amountIn, IERC20(_path[0]).balanceOf(address(this))));\r\n\t\t\t_setFactory(factory_, creationCode_);\r\n\t\t} else if (_factory == factory) {\r\n\t\t\t// Biswap\r\n\t\t\t_swapTo(_path, address(this), Math.min(_amountIn, IERC20(_path[0]).balanceOf(address(this))));\r\n\t\t} else {\r\n\t\t\trevert(\"not swap\");\r\n\t\t}\r\n\t}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fundTo\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rateAuth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_swapAuth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_callAuth\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CALL_AUTH_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SET_RATE_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SWAP_AUTH_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bnb2UMax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bnbToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"btc2UMax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"btcToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"creationCode\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_path\",\"type\":\"address[]\"}],\"name\":\"customDexSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum SwapUtils.SWAPTYPE\",\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"dexSwapWithType\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eth2UMax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"release\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"slippage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"u2TokenMax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdtToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "FeeFund", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000611ff4b5f1fe52187949055b916fe20c2f5d11ee000000000000000000000000aeb8e724adfc5bc7d745202c6889026083627a51000000000000000000000000b891396dc573e189b6437de19c92384fbc17267c00000000000000000000000023b561191f8f1e3daa318275bc842de3c9e55940", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a6b28f3223427729403f4e99765d9ae25824612ac334c76647fab3833400be06"}