{"SourceCode": "// Sources flattened with hardhat v2.18.1 https://hardhat.org\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\n// File contracts/interfaces/IERC20.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\npragma solidity 0.8.19;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n\r\n// File contracts/interfaces/IERC20Metadata.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\npragma solidity 0.8.19;\r\n\r\ninterface IERC20Metadata is IERC20 {\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n\r\n// File contracts/utils/Context.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\npragma solidity 0.8.19;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/libraries/ERC20.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\npragma solidity 0.8.19;\r\n\r\n\r\n\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    function name() external view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() external view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() external view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(\r\n        address account\r\n    ) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(\r\n        address recipient,\r\n        uint256 amount\r\n    ) external virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(\r\n        address spender,\r\n        uint256 amount\r\n    ) external virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external virtual override returns (bool) {\r\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(\r\n                currentAllowance >= amount,\r\n                \"ERC20Stake: transfer amount exceeds allowance\"\r\n            );\r\n            unchecked {\r\n                _approve(sender, _msgSender(), currentAllowance - amount);\r\n            }\r\n        }\r\n\r\n        _transfer(sender, recipient, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(\r\n        address spender,\r\n        uint256 addedValue\r\n    ) external virtual returns (bool) {\r\n        _approve(\r\n            _msgSender(),\r\n            spender,\r\n            _allowances[_msgSender()][spender] + addedValue\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(\r\n        address spender,\r\n        uint256 subtractedValue\r\n    ) external virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\r\n        require(\r\n            currentAllowance >= subtractedValue,\r\n            \"ERC20Stake: decreased allowance below zero\"\r\n        );\r\n        unchecked {\r\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function _transfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(sender != address(0), \"ERC20Stake: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20Stake: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        uint256 senderBalance = _balances[sender];\r\n        require(\r\n            senderBalance >= amount,\r\n            \"ERC20Stake: transfer amount exceeds balance\"\r\n        );\r\n        unchecked {\r\n            _balances[sender] = senderBalance - amount;\r\n        }\r\n        _balances[recipient] += amount;\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n\r\n        _afterTokenTransfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20Stake: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20Stake: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20Stake: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n        }\r\n        _totalSupply -= amount;\r\n\r\n        emit Transfer(account, address(0), amount);\r\n\r\n        _afterTokenTransfer(account, address(0), amount);\r\n    }\r\n\r\n    function burn(uint256 amount) external virtual {\r\n        require(_msgSender() != address(0), \"ERC20Stake: burn from the zero address\");\r\n        require(amount > 0, \"ERC20Stake: burn amount exceeds balance\");\r\n        require(_balances[_msgSender()] >= amount, \"ERC20Stake: burn amount exceeds balance\");\r\n        _burn(_msgSender(), amount);\r\n    }\r\n\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20Stake: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20Stake: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n}\r\n\r\n\r\n// File contracts/projects/SakaiDAO/interfaces/IEpoch.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\npragma solidity 0.8.19;\r\n\r\ninterface IEpoch {\r\n    function getCurrentEpoch() external view returns(uint256);\r\n}\r\n\r\n\r\n// File contracts/projects/SakaiDAO/interfaces/ITokenVote.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\npragma solidity 0.8.19;\r\n\r\ninterface ITokenVote is IEpoch {\r\n    function isCanVote(address account, uint256 _currentEpoch) external view returns(bool);\r\n    function isCanCreateProposal(address account) external view returns(bool);\r\n}\r\n\r\n\r\n// File contracts/utils/Ownable.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\npragma solidity 0.8.19;\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"OwnableStake: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"OwnableStake: new owner is the zero address\"\r\n        );\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/utils/ReentrancyGuard.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\npragma solidity 0.8.19;\r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\r\n        require(_status != _ENTERED, \"ReentrancyGuardStake: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\r\n     * `nonReentrant` function in the call stack.\r\n     */\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _status == _ENTERED;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/projects/SakaiDAO/SakaiDAO.sol\r\n\r\n// Original license: SPDX_License_Identifier: MIT\r\npragma solidity 0.8.19;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n* This contract is part of SakaiDAO system.\r\n* purpose of this contract is for staking and get reward\r\n* user can stake and get reward from this contract\r\n* with this token, user can vote, create proposal, and get reward with specific condition\r\n*/\r\ncontract SakaiDAO is ITokenVote, ERC20, Ownable, ReentrancyGuard {\r\n    address public tokenAddress;\r\n    uint256 public currentEpoch;\r\n    uint256 public lastResetEpochAt;\r\n    uint256 public resetEpochEvery;\r\n    uint256 public pendingCalculateReward;\r\n    address public voteAddress;\r\n\r\n    struct Share {\r\n        uint256 amount;\r\n        uint256 totalExcluded;\r\n        uint256 totalClaimed;\r\n        bool isReceiveReward;\r\n        uint256 lastDepositTimestamp;\r\n        uint256 lastWithdrawnTimestamp;\r\n        uint256 lastDepositEpoch;\r\n        uint256 lastEpochNumberWhenDeposit;\r\n    }\r\n\r\n    address[] public shareholders;\r\n    mapping (address => uint256) public shareholderIndexes;\r\n    mapping (address => uint256) public shareholderClaims;\r\n    mapping (address => bool) public isCanSetShares;\r\n    mapping (address => Share) public shares;\r\n\r\n    // mapping account -> referrer\r\n    mapping(address => address) public referrers;\r\n\r\n    // mapping referrer accumulation\r\n    mapping(address => uint256) public rewardsFromReferrer;\r\n\r\n    // mapping referrer pending amount\r\n    mapping(address => uint256) public referrerPendingAmount;\r\n\r\n    // total claimed referrer amount\r\n    mapping(address => uint256) public referrerTotalClaimedAmount;\r\n\r\n    mapping(address => mapping(address => uint256)) public referrerTotalAmountByAccount;\r\n\r\n    // total accumulate referrer amount\r\n    uint256 public totalAccumulateReferrerAmount;\r\n\r\n    // total pending referrer amount\r\n    uint256 public totalPendingReferrerAmount;\r\n\r\n    uint256 public minimumStakeForVote;\r\n    uint256 public minimumStakeForCreateProposal;\r\n    uint256 public minimumStakeForGetReward;\r\n    uint256 public minimumStake;\r\n\r\n    uint256 public percentTaxForStakingPool;\r\n    uint256 public percentTaxForVaultCapital;\r\n\r\n    uint256 public percentDistributionForReferrerLayer1;\r\n    uint256 public percentDistributionForReferrerLayer2;\r\n    uint256 public percentDistributionForReferrerLayer3;\r\n\r\n    uint256 public constant percentDenominator = 1000;\r\n\r\n    uint256 public percentTaxClaimReferrer;\r\n\r\n    uint256 public totalShares;\r\n    uint256 public totalDividends;\r\n    uint256 public totalDistributed;\r\n    uint256 public dividendsPerShare;\r\n    uint256 public constant dividendsPerShareAccuracyFactor = 10**36;\r\n    uint256 public accumulateAmount;\r\n\r\n    address public addressStakingPool;\r\n    address public addressVaultCapital;\r\n    address public treasuryAddress;\r\n\r\n    event Stake(address account, uint256 amount);\r\n    event UnStake(address account, uint256 amount);\r\n    event ReceiveReward(uint256 amount, uint256 epoch);\r\n  event ReceiveRewardReferrer(address account, uint256 amount, uint256 claimedAmount, uint256 epoch);\r\n    event ClaimReward(address account, uint256 amount);\r\n    event UpdateMinimumStakeForVote(uint256 minimumStakeForVote);\r\n    event UpdateMinimumStakeForCreateProposal(uint256 minimumStakeForCreateProposal);\r\n    event UpdateMinimumStakeForGetReward(uint256 minimumStakeForGetReward);\r\n    event UpdatePercentDistributionReferrer(uint256 percentDistributionForReferrerLayer1, uint256 percentDistributionForReferrerLayer2, uint256 percentDistributionForReferrerLayer3);\r\n    event UpdatePercentTax(uint256 percentTaxForStakingPool, uint256 percentTaxForVaultCapital);\r\n    event UpdateVaultCapital(address addressVaultCapital);\r\n    event UpdateStakingPool(address addressStakingPool);\r\n    event UpdateResetEpochEvery(uint256 resetEpochEvery);\r\n    event UpdateVoteAddress(address voteAddress);\r\n    event UpdateTreasuryAddress(address treasuryAddress);\r\n    event UpdatePercentTaxReferer(uint256 percentTaxClaimReferrer);\r\n    event UpdateMinimumStake(uint256 minimumStake);\r\n\r\n    constructor(address _tokenAddress) ERC20(\"SakaiDAO\", \"Sakai-DAO\") {\r\n        require(_tokenAddress != address(0), \"SakaiDAO: token address is the zero address\");\r\n        tokenAddress = _tokenAddress;\r\n\r\n        minimumStakeForVote = 5_000 * 10 ** 18;\r\n        minimumStakeForCreateProposal = 25_000 * 10 ** 18;\r\n        minimumStakeForGetReward = 1_000 * 10 ** 18;\r\n        minimumStake = 1_000 * 10 ** 18;\r\n\r\n\r\n        percentTaxForStakingPool = 20;\r\n        percentTaxForVaultCapital = 30;\r\n        percentTaxClaimReferrer = 50;\r\n\r\n        percentDistributionForReferrerLayer1 = 30;\r\n        percentDistributionForReferrerLayer2 = 20;\r\n        percentDistributionForReferrerLayer3 = 10;\r\n\r\n        addressStakingPool = _msgSender();\r\n        addressVaultCapital = _msgSender();\r\n        treasuryAddress = _msgSender();\r\n\r\n       resetEpochEvery = 1 days;\r\n    \r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    // Region Internal Function\r\n\r\n    function _addShareholder(address shareholder) internal {\r\n        /** this function for add shareholders*/\r\n        shareholderIndexes[shareholder] = shareholders.length;\r\n        shareholders.push(shareholder);\r\n    }\r\n\r\n    function _calculateReward(uint256 rewardAmount) internal {\r\n        /** this function for calculate reward and count dividendsPerShare */\r\n        pendingCalculateReward += rewardAmount;\r\n\r\n        if(totalShares > 0 && (lastResetEpochAt + resetEpochEvery <= block.timestamp)){\r\n            uint256 amount = pendingCalculateReward;\r\n            totalDividends += amount;\r\n            dividendsPerShare += (dividendsPerShareAccuracyFactor * amount / totalShares);\r\n\r\n            currentEpoch++;\r\n            lastResetEpochAt = block.timestamp;\r\n            pendingCalculateReward = 0;\r\n        } else {\r\n            pendingCalculateReward += rewardAmount;\r\n        }\r\n    }\r\n\r\n    function _claimReward(address account) internal {\r\n        /** this function for claim reward */\r\n        require(account != address(0), \"SakaiDAO: account is the zero address\");\r\n        require(shares[account].amount > 0, \"SakaiDAO: account is not stake\");\r\n        uint256 originalAmount = dividendOf(account);\r\n        uint256 amount = _deductTaxClaimReward(originalAmount);\r\n        if(IERC20(tokenAddress).balanceOf(address(this)) >= amount){\r\n            IERC20(tokenAddress).transfer(account, amount);\r\n            _setClaimed(account, originalAmount);\r\n        }\r\n    }\r\n\r\n    function _claimRewardReferrer(address account) internal {\r\n        /** this function for claim reward referrer */\r\n        require(account != address(0), \"SakaiDAO: account is the zero address\");\r\n        uint256 amount = referrerPendingAmount[account];\r\n        referrerPendingAmount[account] = 0;\r\n        totalPendingReferrerAmount -= amount;\r\n        referrerTotalClaimedAmount[account] += amount;\r\n        uint256 amountAfterTax = amount * percentTaxClaimReferrer / percentDenominator;\r\n        uint256 amountForReferrer = amount - amountAfterTax;\r\n        IERC20(tokenAddress).transfer(account, amountForReferrer);\r\n        _distributeTaxClaimReward(amountAfterTax);\r\n        emit ReceiveRewardReferrer(account, amountAfterTax, amountForReferrer, currentEpoch);\r\n    }\r\n\r\n    function _deductTaxUnstake(address account, uint256 amount ) internal returns(uint256){\r\n        /** this function for deduct tax if user unstake early */\r\n        uint256 amountAfterTax = amount;\r\n        uint256 tax = _estimateTaxPercentEarlyUnstake(account);\r\n        if(tax > 0){\r\n            uint256 taxAmount = amount * tax / percentDenominator;\r\n            amountAfterTax = amount - taxAmount;\r\n\r\n            //distribute to dao user\r\n            _calculateReward(taxAmount);\r\n        }\r\n        return amountAfterTax;\r\n    }\r\n\r\n    function _deductTaxClaimReward(uint256 amount ) internal returns(uint256){\r\n        /** this function for deduct tax if user claim reward and distribute tax */\r\n        uint256 amountAfterTax = amount;\r\n        uint256 totalTax = percentTaxForStakingPool + percentTaxForVaultCapital;\r\n        if(totalTax > 0){\r\n            uint256 taxAmount = amount * totalTax / percentDenominator;\r\n            amountAfterTax = amount - taxAmount;\r\n            _distributeTaxClaimReward(taxAmount);\r\n        }\r\n        return amountAfterTax;\r\n    }\r\n\r\n    function _distributeTaxClaimReward(uint256 taxAmount) internal {\r\n        /**\r\n         * 1. Distribute tax to staking pool\r\n         * 2. Distribute tax to vault capital\r\n        */\r\n        uint256 totalTax = percentTaxForStakingPool + percentTaxForVaultCapital;\r\n\r\n        uint256 amountForStakingPool = taxAmount * percentTaxForStakingPool / totalTax;\r\n        IERC20(tokenAddress).transfer(addressStakingPool, amountForStakingPool);\r\n\r\n        uint256 amountForVaultCapital = taxAmount * percentTaxForVaultCapital / totalTax;\r\n        IERC20(tokenAddress).transfer(addressVaultCapital, amountForVaultCapital);\r\n    }\r\n\r\n    function _estimateTaxPercentEarlyUnstake(address account) internal view returns(uint256) {\r\n        /** this function for estimate tax if user unstake early */\r\n\r\n        uint256 lastDepositTimestamp = shares[account].lastDepositTimestamp;\r\n        uint256 totalDaysStake = (block.timestamp - lastDepositTimestamp) / 86400;\r\n        uint256 tax = 0;\r\n\r\n        if(totalDaysStake >=0 && totalDaysStake <= 90) tax = 250;\r\n        else if(totalDaysStake > 90 && totalDaysStake <= 120) tax = 223;\r\n        else if(totalDaysStake > 120 && totalDaysStake <= 150) tax = 196;\r\n        else if(totalDaysStake > 150 && totalDaysStake <= 180) tax = 169;\r\n        else if(totalDaysStake > 180 && totalDaysStake <= 210) tax = 142;\r\n        else if(totalDaysStake > 210 && totalDaysStake <= 240) tax = 115;\r\n        else if(totalDaysStake > 240 && totalDaysStake <= 270) tax = 88;\r\n        else if(totalDaysStake > 270 && totalDaysStake <= 300) tax = 61;\r\n        else if(totalDaysStake > 300 && totalDaysStake <= 330) tax = 34;\r\n        else if(totalDaysStake > 330 && totalDaysStake <= 365) tax = 7;\r\n\r\n        return tax;\r\n    }\r\n\r\n    function _getCumulativeDividend(uint256 share) internal view returns (uint256) {\r\n        /** this function for calculate cumulative dividend */\r\n        return share * dividendsPerShare / dividendsPerShareAccuracyFactor;\r\n    }\r\n\r\n    function _getReferrerOfAccount(address account) internal view returns(address, address, address) {\r\n        /** this function for get referrer of account */\r\n        address referrerLayer1 = referrers[account];\r\n        address referrerLayer2 = referrers[referrerLayer1];\r\n        address referrerLayer3 = referrers[referrerLayer2];\r\n        return (referrerLayer1, referrerLayer2, referrerLayer3);\r\n    }\r\n\r\n    function _isContract(address account) internal view returns (bool) {\r\n        /** this function for check is contract or not */\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    function _removeShareholder(address shareholder) internal {\r\n        /** this function for remove shareholder */\r\n        shareholders[shareholderIndexes[shareholder]] = shareholders[shareholders.length-1];\r\n        shareholderIndexes[shareholders[shareholders.length-1]] = shareholderIndexes[shareholder];\r\n        shareholders.pop();\r\n    }\r\n\r\n    function _setClaimed(address account, uint256 amount) internal {\r\n        /** this function for set claimed reward */\r\n        shareholderClaims[account] = block.timestamp;\r\n        shares[account].totalClaimed = shares[account].totalClaimed + (amount);\r\n        shares[account].totalExcluded = _getCumulativeDividend(shares[account].amount);\r\n        shares[account].lastWithdrawnTimestamp = block.timestamp;\r\n        totalDistributed = totalDistributed + (amount);\r\n        emit ClaimReward(account, amount);\r\n    }\r\n\r\n    function _setShare(address account, uint256 amount) internal {\r\n        /** this function for set shares balance */\r\n\r\n        if(amount > 0 && shares[account].amount == 0){\r\n            // if amount > 0 then add shareholder\r\n            _addShareholder(account);\r\n        } else if(amount == 0 && shares[account].amount > 0){\r\n            // if amount = 0 then remove shareholder\r\n            _removeShareholder(account);\r\n        }\r\n\r\n        /** Update shares balance */\r\n        totalShares = totalShares - shares[account].amount + amount;\r\n        shares[account].amount = amount;\r\n        shares[account].totalExcluded = _getCumulativeDividend(shares[account].amount);\r\n        shares[account].lastDepositTimestamp = block.timestamp;\r\n        shares[account].lastDepositEpoch = currentEpoch;\r\n\r\n        // get current epoch from vote contract for prevent user voting on running epoch\r\n        shares[account].lastEpochNumberWhenDeposit = voteAddress != address(0) ? ITokenVote(voteAddress).getCurrentEpoch() : 0;\r\n\r\n        if(shares[account].amount >= minimumStakeForGetReward){\r\n            shares[account].isReceiveReward = true;\r\n        } else {\r\n            shares[account].isReceiveReward = false;\r\n            totalShares = totalShares - shares[account].amount;\r\n        }\r\n    }\r\n\r\n    function _stake(uint256 amount, address referrerAddress) internal {\r\n        /** this function for stake */\r\n        address account = _msgSender();\r\n        address referrerLayer1 = referrerAddress;\r\n        /** Transfer tokens to contract */\r\n        IERC20(tokenAddress).transferFrom(_msgSender(), address(this), amount);\r\n\r\n        /** Mint shares to user*/\r\n        _mint(account,amount);\r\n\r\n        /** Set shares balance*/\r\n        _setShare(account, balanceOf(account));\r\n\r\n        // get user upline of account if exists\r\n        address userUpline = referrers[account];\r\n\r\n        // if user upline is zero address, combine with user input from API\r\n        if(userUpline == address(0) && referrerLayer1 != address(0)){\r\n            referrers[account] = referrerLayer1;\r\n            userUpline = referrerLayer1;\r\n        }\r\n        /** Set referrer */\r\n        if(userUpline != address(0)){\r\n            referrerLayer1 = userUpline;\r\n\r\n            /** count first layer of referrer**/\r\n            uint256 amountLayer1 = amount * percentDistributionForReferrerLayer1 / percentDenominator;\r\n            rewardsFromReferrer[referrerLayer1] += amountLayer1;\r\n            referrerPendingAmount[referrerLayer1] += amountLayer1;\r\n            referrerTotalAmountByAccount[account][referrerLayer1] += amountLayer1;\r\n            totalAccumulateReferrerAmount += amountLayer1;\r\n            totalPendingReferrerAmount += amountLayer1;\r\n\r\n            /** layer 2 referrer */\r\n            address referrerLayer2 = referrers[referrerLayer1];\r\n            if(referrerLayer2 != address(0)){\r\n                uint256 amountLayer2 = amount * percentDistributionForReferrerLayer2 / percentDenominator;\r\n                rewardsFromReferrer[referrerLayer2] += amountLayer1;\r\n                referrerPendingAmount[referrerLayer2] += amountLayer2;\r\n                referrerTotalAmountByAccount[account][referrerLayer2] += amountLayer2;\r\n                totalAccumulateReferrerAmount += amountLayer2;\r\n                totalPendingReferrerAmount += amountLayer2;\r\n            }\r\n\r\n            /** layer 3 referrer */\r\n            address referrerLayer3 = referrers[referrerLayer2];\r\n            if(referrerLayer3 != address(0)){\r\n                uint256 amountLayer3 = amount * percentDistributionForReferrerLayer3 / percentDenominator;\r\n                rewardsFromReferrer[referrerLayer3] += amountLayer3;\r\n                referrerPendingAmount[referrerLayer3] += amountLayer3;\r\n                referrerTotalAmountByAccount[referrerLayer3][account] += amountLayer3;\r\n                totalAccumulateReferrerAmount += amountLayer3;\r\n                totalPendingReferrerAmount += amountLayer3;\r\n            }\r\n\r\n        }\r\n\r\n\r\n        emit Stake(account,amount);\r\n    }\r\n\r\n    function _unstake(uint256 amount) internal {\r\n        /** this function for unstake */\r\n        _burn(_msgSender(),amount);\r\n        uint256 amountAfterTax = _deductTaxUnstake(_msgSender(), amount);\r\n        IERC20(tokenAddress).transfer(_msgSender(), amountAfterTax);\r\n        _setShare(_msgSender(), balanceOf(_msgSender()));\r\n        emit UnStake(_msgSender(),amount);\r\n    }\r\n\r\n    function _transfer(address from, address to, uint256 amount) internal override {\r\n        // Prevent user for transfering token\r\n    }\r\n\r\n    // End Region Internal Function\r\n\r\n    // Region Public / External Function\r\n\r\n    function estimateTaxPercentEarlyUnstake(address account) external view returns(uint256, uint256){\r\n        return (_estimateTaxPercentEarlyUnstake(account), percentDenominator);\r\n    }\r\n\r\n    function claimReward() external nonReentrant {\r\n        _claimReward(_msgSender());\r\n    }\r\n\r\n    function claimRewardReferrer() external nonReentrant {\r\n        _claimRewardReferrer(_msgSender());\r\n    }\r\n\r\n    function claimRewardForAccount(address account) external nonReentrant onlyOwner {\r\n        _claimReward(account);\r\n    }\r\n\r\n    function claimStuckBNB() external nonReentrant onlyOwner {\r\n        require(address(this).balance > 0, \"SakaiDAO: No stuck BNB\");\r\n        payable(msg.sender).transfer(address(this).balance);\r\n    }\r\n\r\n    function claimStuckTokens(address token) external nonReentrant onlyOwner {\r\n        require(token != tokenAddress, \"Owner cannot claim native tokens\");\r\n        IERC20(token).transfer(msg.sender, IERC20(token).balanceOf(address(this)));\r\n    }\r\n\r\n    function dividendOf(address account) public view returns (uint256) {\r\n\r\n        if(shares[account].amount == 0){ return 0; }\r\n        if(shares[account].isReceiveReward == false){ return 0; }\r\n\r\n        uint256 shareholderTotalDividends = _getCumulativeDividend(shares[account].amount);\r\n        uint256 shareholderTotalExcluded = shares[account].totalExcluded;\r\n\r\n        if(shareholderTotalDividends <= shareholderTotalExcluded){ return 0; }\r\n\r\n        return shareholderTotalDividends - shareholderTotalExcluded;\r\n    }\r\n\r\n    function diffAmount() public view returns (uint256) {\r\n        if(!isValidBalance()){\r\n            return totalSupply() - IERC20(tokenAddress).balanceOf(address(this));\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /** Get referrer rewards */\r\n    function dividendOfReferrer(address account) public view returns (uint256) {\r\n        return referrerPendingAmount[account];\r\n    }\r\n\r\n    function getReferrerOfAccount(address account) external view returns(address, address, address) {\r\n        return _getReferrerOfAccount(account);\r\n    }\r\n\r\n    function getTotalDaysStake(address account) external view returns(uint256){\r\n        uint256 lastDepositTimestamp = shares[account].lastDepositTimestamp;\r\n        uint256 totalDaysStake = (block.timestamp - lastDepositTimestamp) / 86400;\r\n        return totalDaysStake;\r\n    }\r\n\r\n    function getNextResetEpochAt() external view returns(uint256){\r\n        return lastResetEpochAt + resetEpochEvery;\r\n    }\r\n\r\n    function getCurrentEpoch() external view returns(uint256) {\r\n        return currentEpoch;\r\n    }\r\n\r\n    function isCanVote(address account, uint256 _currentEpoch) external view returns(bool){\r\n        return shares[account].amount >= minimumStakeForVote &&\r\n            shares[account].lastEpochNumberWhenDeposit < _currentEpoch;\r\n    }\r\n\r\n    function isCanCreateProposal(address account) external view returns(bool) {\r\n        return shares[account].amount >= minimumStakeForCreateProposal;\r\n    }\r\n\r\n    function isValidBalance() public view returns(bool) {\r\n        return IERC20(tokenAddress).balanceOf(address(this)) >= totalSupply();\r\n    }\r\n\r\n    function sendReward(uint256 rewardAmount) external returns(bool) {\r\n        // Sending and calculate reward\r\n        require(IERC20(tokenAddress).allowance(_msgSender(),address(this)) >= rewardAmount,\"SakaiDAO: Insufficient Allowance\");\r\n        require(IERC20(tokenAddress).balanceOf(_msgSender()) >= rewardAmount,\"SakaiDAO: Insufficient Balance\");\r\n        if(rewardAmount > 0){\r\n            IERC20(tokenAddress).transferFrom(_msgSender(), address(this), rewardAmount);\r\n            _calculateReward(rewardAmount);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function stake(uint256 amount, address referrer) external nonReentrant {\r\n        require(amount > 0,\"SakaiDAO: Invalid Amount\");\r\n        require(IERC20(tokenAddress).allowance(_msgSender(),address(this)) >= amount,\"SakaiDAO: Insufficient Allowance\");\r\n        require(IERC20(tokenAddress).balanceOf(_msgSender()) >= amount,\"SakaiDAO: Insufficient Balance\");\r\n        require(amount >= minimumStake, \"SakaiDAO: Invalid amount, should more than minimum stake\");\r\n        require(referrer != _msgSender(), \"SakaiDAO: Invalid referrer\");\r\n        _stake(amount, referrer);\r\n    }\r\n\r\n    function unstake(uint256 amount) external nonReentrant {\r\n        require(amount > 0,\"SakaiDAO: Invalid Amount\");\r\n        require(balanceOf(_msgSender()) >= amount, \"SakaiDAO: Insufficient Amount\");\r\n        _unstake(amount);\r\n    }\r\n\r\n    function updateMinimumStakeForVote(uint256 _amountInWei) external onlyOwner {\r\n        minimumStakeForVote = _amountInWei;\r\n        emit UpdateMinimumStakeForVote(_amountInWei);\r\n    }\r\n\r\n    function updateMinimumStakeForCreateProposal(uint256 _amountInWei) external onlyOwner {\r\n        minimumStakeForCreateProposal = _amountInWei;\r\n        emit UpdateMinimumStakeForCreateProposal(_amountInWei);\r\n    }\r\n\r\n    function updateMinimumStakeForGetReward(uint256 _amountInWei) external onlyOwner {\r\n        minimumStakeForGetReward = _amountInWei;\r\n        emit UpdateMinimumStakeForGetReward(_amountInWei);\r\n    }\r\n\r\n    function updateMinimumStake(uint256 _amountInWei) external onlyOwner {\r\n        minimumStake = _amountInWei;\r\n        emit UpdateMinimumStake(_amountInWei);\r\n    }\r\n\r\n    function updatePercentTaxClaimReferrer(uint256 _percentTaxClaimReferrer) external onlyOwner {\r\n        percentTaxClaimReferrer = _percentTaxClaimReferrer;\r\n        emit UpdatePercentTaxReferer(_percentTaxClaimReferrer);\r\n    }\r\n\r\n    function updatePercentDistributionForReferrer(uint256 _layer1, uint256 _layer2, uint256 _layer3) external onlyOwner {\r\n        require(_layer1 + _layer2 + _layer3 == percentDenominator, \"SakaiDAO: Maximum Referrer should 100%\");\r\n        percentDistributionForReferrerLayer1 = _layer1;\r\n        percentDistributionForReferrerLayer2 = _layer2;\r\n        percentDistributionForReferrerLayer3 = _layer3;\r\n        emit UpdatePercentDistributionReferrer(_layer1, _layer2, _layer3);\r\n    }\r\n\r\n    function updatePercentTax(uint256 _percentTaxForStakingPool, uint256 _percentTaxForVaultCapital) external onlyOwner {\r\n        require(_percentTaxForStakingPool + _percentTaxForVaultCapital <= 100, \"SakaiDAO: Maximum tax is 10%\");\r\n        percentTaxForStakingPool = _percentTaxForStakingPool;\r\n        percentTaxForVaultCapital = _percentTaxForVaultCapital;\r\n        emit UpdatePercentTax(_percentTaxForStakingPool, _percentTaxForVaultCapital);\r\n    }\r\n\r\n    function updateVaultCapital(address _addressVaultCapital) external onlyOwner {\r\n        require(_addressVaultCapital != address(0), \"SakaiDAO: Invalid address\");\r\n        require(addressVaultCapital != _addressVaultCapital, \"SakaiDAO: Vault Capital address is already that address\");\r\n        addressVaultCapital = _addressVaultCapital;\r\n        emit UpdateVaultCapital(_addressVaultCapital);\r\n    }\r\n\r\n    function updateStakingPool(address _addressStakingPool) external onlyOwner {\r\n        require(_addressStakingPool != address(0), \"SakaiDAO: Invalid address\");\r\n        require(addressStakingPool != _addressStakingPool, \"SakaiDAO: Staking Pool address is already that address\");\r\n        addressStakingPool = _addressStakingPool;\r\n        emit UpdateStakingPool(_addressStakingPool);\r\n    }\r\n\r\n    function updateTreasuryAddress(address _treasuryAddress) external onlyOwner {\r\n        require(_treasuryAddress != address(0), \"SakaiDAO: Invalid address\");\r\n        require(treasuryAddress != _treasuryAddress, \"SakaiDAO: Treasury address is already that address\");\r\n        treasuryAddress = _treasuryAddress;\r\n        emit UpdateTreasuryAddress(_treasuryAddress);\r\n    }\r\n\r\n    function updateResetEpochEvery(uint256 _valueInDays) external onlyOwner {\r\n        require(_valueInDays >= 1 && _valueInDays <= 7, \"SakaiDAO: Invalid reset epoch 1-7 days\");\r\n        resetEpochEvery = _valueInDays * 1 days;\r\n        emit UpdateResetEpochEvery(_valueInDays);\r\n    }\r\n\r\n    function updateVoteAddress(address _voteAddress) external onlyOwner {\r\n        require(_voteAddress != address(0), \"SakaiDAO: Invalid address\");\r\n        require(voteAddress != _voteAddress, \"SakaiDAO: Vote address is already that address\");\r\n        voteAddress = _voteAddress;\r\n        emit UpdateVoteAddress(_voteAddress);\r\n    }\r\n    // Region Public Function\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClaimReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"ReceiveReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"ReceiveRewardReferrer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minimumStake\",\"type\":\"uint256\"}],\"name\":\"UpdateMinimumStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minimumStakeForCreateProposal\",\"type\":\"uint256\"}],\"name\":\"UpdateMinimumStakeForCreateProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minimumStakeForGetReward\",\"type\":\"uint256\"}],\"name\":\"UpdateMinimumStakeForGetReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minimumStakeForVote\",\"type\":\"uint256\"}],\"name\":\"UpdateMinimumStakeForVote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"percentDistributionForReferrerLayer1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"percentDistributionForReferrerLayer2\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"percentDistributionForReferrerLayer3\",\"type\":\"uint256\"}],\"name\":\"UpdatePercentDistributionReferrer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"percentTaxForStakingPool\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"percentTaxForVaultCapital\",\"type\":\"uint256\"}],\"name\":\"UpdatePercentTax\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"percentTaxClaimReferrer\",\"type\":\"uint256\"}],\"name\":\"UpdatePercentTaxReferer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"resetEpochEvery\",\"type\":\"uint256\"}],\"name\":\"UpdateResetEpochEvery\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addressStakingPool\",\"type\":\"address\"}],\"name\":\"UpdateStakingPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"treasuryAddress\",\"type\":\"address\"}],\"name\":\"UpdateTreasuryAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addressVaultCapital\",\"type\":\"address\"}],\"name\":\"UpdateVaultCapital\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"voteAddress\",\"type\":\"address\"}],\"name\":\"UpdateVoteAddress\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"accumulateAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addressStakingPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addressVaultCapital\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"claimRewardForAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRewardReferrer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimStuckBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"claimStuckTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"diffAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"dividendOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"dividendOfReferrer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendsPerShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendsPerShareAccuracyFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"estimateTaxPercentEarlyUnstake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNextResetEpochAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getReferrerOfAccount\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getTotalDaysStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isCanCreateProposal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isCanSetShares\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_currentEpoch\",\"type\":\"uint256\"}],\"name\":\"isCanVote\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isValidBalance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastResetEpochAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumStakeForCreateProposal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumStakeForGetReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumStakeForVote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingCalculateReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percentDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percentDistributionForReferrerLayer1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percentDistributionForReferrerLayer2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percentDistributionForReferrerLayer3\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percentTaxClaimReferrer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percentTaxForStakingPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percentTaxForVaultCapital\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrerPendingAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrerTotalAmountByAccount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrerTotalClaimedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resetEpochEvery\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardsFromReferrer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"name\":\"sendReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"shareholderClaims\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"shareholderIndexes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"shareholders\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"shares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalExcluded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalClaimed\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isReceiveReward\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"lastDepositTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastWithdrawnTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastDepositEpoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastEpochNumberWhenDeposit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAccumulateReferrerAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPendingReferrerAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountInWei\",\"type\":\"uint256\"}],\"name\":\"updateMinimumStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountInWei\",\"type\":\"uint256\"}],\"name\":\"updateMinimumStakeForCreateProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountInWei\",\"type\":\"uint256\"}],\"name\":\"updateMinimumStakeForGetReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountInWei\",\"type\":\"uint256\"}],\"name\":\"updateMinimumStakeForVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_layer1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_layer2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_layer3\",\"type\":\"uint256\"}],\"name\":\"updatePercentDistributionForReferrer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_percentTaxForStakingPool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_percentTaxForVaultCapital\",\"type\":\"uint256\"}],\"name\":\"updatePercentTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_percentTaxClaimReferrer\",\"type\":\"uint256\"}],\"name\":\"updatePercentTaxClaimReferrer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_valueInDays\",\"type\":\"uint256\"}],\"name\":\"updateResetEpochEvery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressStakingPool\",\"type\":\"address\"}],\"name\":\"updateStakingPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasuryAddress\",\"type\":\"address\"}],\"name\":\"updateTreasuryAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressVaultCapital\",\"type\":\"address\"}],\"name\":\"updateVaultCapital\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_voteAddress\",\"type\":\"address\"}],\"name\":\"updateVoteAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"voteAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SakaiDAO", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000043b35e89d15b91162dea1c51133c4c93bdd1c4af", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a6e569b8c5a205742ed14efcce6547118acf0662aec4eda8a027fba8d8ee2ab0"}