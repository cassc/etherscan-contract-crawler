{"SourceCode": "{\"Context.sol\":{\"content\":\"//SPDX-License-Identifier: KK\\npragma solidity ^0.8.3;\\n \\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return payable(msg.sender);\\n    }\\n \\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\"},\"ERC20.sol\":{\"content\":\"//SPDX-License-Identifier: KK\\npragma solidity ^0.8.3;\\nimport \\\"./Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n \\n    mapping (address =\\u003e uint256) private _balances;\\n \\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\n \\n    uint256 private _totalSupply;\\n \\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n \\n    constructor (string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = 9;\\n    }\\n \\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n \\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n \\n    function decimals() public view virtual returns (uint8) {\\n        return _decimals;\\n    }\\n \\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n \\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n \\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n \\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n \\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n \\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n \\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n \\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n \\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n \\n        _beforeTokenTransfer(sender, recipient, amount);\\n \\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n \\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n \\n        _beforeTokenTransfer(address(0), account, amount);\\n \\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n \\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n \\n        _beforeTokenTransfer(account, address(0), amount);\\n \\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n \\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n \\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n \\n    function _setupDecimals(uint8 decimals_) internal virtual {\\n        _decimals = decimals_;\\n    }\\n \\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\"},\"IERC20.sol\":{\"content\":\"//SPDX-License-Identifier: KK\\npragma solidity ^0.8.3;\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n \\n    function balanceOf(address account) external view returns (uint256);\\n \\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n \\n    function allowance(address owner, address spender) external view returns (uint256);\\n \\n    function approve(address spender, uint256 amount) external returns (bool);\\n \\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n \\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n \\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"},\"insanity_Wolf.sol\":{\"content\":\"//SPDX-License-Identifier: KK\\n/* __\\n                            .d$$b\\n                          .\\u0027 TO$;\\\\\\n                         /  : TP._;\\n                        / _.;  :Tb|\\n                       /   /   ;j$j\\n                   _.-\\\"       d$$$$\\n                 .\\u0027 ..       d$$$$;\\n                /  /P\\u0027      d$$$$P. |\\\\         \\n               /   \\\"      .d$$$P\\u0027 |\\\\^\\\"l\\n             .\\u0027           `T$P^\\\"\\\"\\\"\\\"\\\"  :\\n         ._.\\u0027      _.\\u0027                ;\\n      `-.-\\\".-\\u0027-\\u0027 ._.       _.-\\\"    .-\\\"\\n    `.-\\\" _____  ._              .-\\\"\\n   -(.g$$$$$$$b.              .\\u0027\\n     \\\"\\\"^^T$$$P^)            .(:\\n       _/  -\\\"  /.\\u0027         /:/;\\n    ._.\\u0027-\\u0027`-\\u0027  \\\")/         /;/;\\n `-.-\\\"..--\\\"\\\"   \\\" /         /  ;\\n.-\\\" ..--\\\"\\\"        -\\u0027          :\\n..--\\\"\\\"--.-\\\"         (\\\\      .-(\\\\\\n  ..--\\\"\\\"              `-\\\\(\\\\/;`\\n    _.                      :\\n                            ;`-\\n                           :\\\\\\n                           ; \\n\u2588\u2588\u2557\u2588\u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557   \u2588\u2588\u2557    \u2588\u2588\u2557    \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\\n\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d    \u2588\u2588\u2551    \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\\n\u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551    \u255a\u2588\u2588\u2588\u2588\u2554\u255d     \u2588\u2588\u2551 \u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2557  \\n\u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551     \u255a\u2588\u2588\u2554\u255d      \u2588\u2588\u2551\u2588\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u255d  \\n\u2588\u2588\u2551\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551      \u2588\u2588\u2551       \u255a\u2588\u2588\u2588\u2554\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551     \\n\u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d\u255a\u2550\u255d   \u255a\u2550\u255d      \u255a\u2550\u255d        \u255a\u2550\u2550\u255d\u255a\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d                                                                                                       \\n\\\"Be Sure, With CheeSure\\\" - Cheebs\\n*/\\n\\nimport \\\"./Context.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./SafeMathInt.sol\\\";\\nimport \\\"./SafeMathUint.sol\\\";\\nimport \\\"./IterableMapping.sol\\\";\\n \\n\\npragma solidity ^0.8.3;\\ninterface IDividendPayingToken {\\n  function dividendOf(address _owner) external view returns(uint256);\\n \\n  function withdrawDividend() external;\\n \\n  event DividendsDistributed(\\n    address indexed from,\\n    uint256 weiAmount\\n  );\\n \\n  event DividendWithdrawn(\\n    address indexed to,\\n    uint256 weiAmount\\n  );\\n}\\n \\ninterface IDividendPayingTokenOptional {\\n  function withdrawableDividendOf(address _owner) external view returns(uint256);\\n \\n  function withdrawnDividendOf(address _owner) external view returns(uint256);\\n \\n  function accumulativeDividendOf(address _owner) external view returns(uint256);\\n}\\n \\ncontract DividendPayingToken is ERC20, IDividendPayingToken, IDividendPayingTokenOptional, Ownable {\\n  using SafeMath for uint256;\\n  using SafeMathUint for uint256;\\n  using SafeMathInt for int256;\\n \\n  uint256 constant internal magnitude = 2**128;\\n \\n  uint256 internal magnifiedDividendPerShare;\\n  uint256 internal lastAmount;\\n \\n  address public dividendToken;\\n \\n \\n  mapping(address =\\u003e int256) internal magnifiedDividendCorrections;\\n  mapping(address =\\u003e uint256) internal withdrawnDividends;\\n  mapping(address =\\u003e bool) _isAuth;\\n \\n  uint256 public totalDividendsDistributed;\\n \\n  modifier onlyAuth() {\\n    require(_isAuth[msg.sender], \\\"Auth: caller is not the authorized\\\");\\n    _;\\n  }\\n \\n  constructor(string memory _name, string memory _symbol, address _token) ERC20(_name, _symbol) {\\n    dividendToken = _token;\\n    _isAuth[msg.sender] = true;\\n  }\\n \\n  function setAuth(address account) external onlyOwner{\\n      _isAuth[account] = true;\\n  }\\n \\n \\n  function distributeDividends(uint256 amount) public onlyOwner{\\n    require(totalSupply() \\u003e 0);\\n \\n    if (amount \\u003e 0) {\\n      magnifiedDividendPerShare = magnifiedDividendPerShare.add(\\n        (amount).mul(magnitude) / totalSupply()\\n      );\\n      emit DividendsDistributed(msg.sender, amount);\\n \\n      totalDividendsDistributed = totalDividendsDistributed.add(amount);\\n    }\\n  }\\n \\n  function withdrawDividend() public virtual override {\\n    _withdrawDividendOfUser(payable(msg.sender));\\n  }\\n \\n  function setDividendTokenAddress(address newToken) external virtual onlyOwner{\\n      dividendToken = newToken;\\n  }\\n \\n  function _withdrawDividendOfUser(address payable user) internal returns (uint256) {\\n    uint256 _withdrawableDividend = withdrawableDividendOf(user);\\n    if (_withdrawableDividend \\u003e 0) {\\n      withdrawnDividends[user] = withdrawnDividends[user].add(_withdrawableDividend);\\n      emit DividendWithdrawn(user, _withdrawableDividend);\\n      bool success = IERC20(dividendToken).transfer(user, _withdrawableDividend);\\n \\n      if(!success) {\\n        withdrawnDividends[user] = withdrawnDividends[user].sub(_withdrawableDividend);\\n        return 0;\\n      }\\n \\n      return _withdrawableDividend;\\n    }\\n \\n    return 0;\\n  }\\n \\n \\n  function dividendOf(address _owner) public view override returns(uint256) {\\n    return withdrawableDividendOf(_owner);\\n  }\\n \\n  function withdrawableDividendOf(address _owner) public view override returns(uint256) {\\n    return accumulativeDividendOf(_owner).sub(withdrawnDividends[_owner]);\\n  }\\n \\n  function withdrawnDividendOf(address _owner) public view override returns(uint256) {\\n    return withdrawnDividends[_owner];\\n  }\\n \\n \\n  function accumulativeDividendOf(address _owner) public view override returns(uint256) {\\n    return magnifiedDividendPerShare.mul(balanceOf(_owner)).toInt256Safe()\\n      .add(magnifiedDividendCorrections[_owner]).toUint256Safe() / magnitude;\\n  }\\n \\n  function _transfer(address from, address to, uint256 value) internal virtual override {\\n    require(false);\\n \\n    int256 _magCorrection = magnifiedDividendPerShare.mul(value).toInt256Safe();\\n    magnifiedDividendCorrections[from] = magnifiedDividendCorrections[from].add(_magCorrection);\\n    magnifiedDividendCorrections[to] = magnifiedDividendCorrections[to].sub(_magCorrection);\\n  }\\n \\n  function _mint(address account, uint256 value) internal override {\\n    super._mint(account, value);\\n \\n    magnifiedDividendCorrections[account] = magnifiedDividendCorrections[account]\\n      .sub( (magnifiedDividendPerShare.mul(value)).toInt256Safe() );\\n  }\\n \\n  function _burn(address account, uint256 value) internal override {\\n    super._burn(account, value);\\n \\n    magnifiedDividendCorrections[account] = magnifiedDividendCorrections[account]\\n      .add( (magnifiedDividendPerShare.mul(value)).toInt256Safe() );\\n  }\\n \\n  function _setBalance(address account, uint256 newBalance) internal {\\n    uint256 currentBalance = balanceOf(account);\\n \\n    if(newBalance \\u003e currentBalance) {\\n      uint256 mintAmount = newBalance.sub(currentBalance);\\n      _mint(account, mintAmount);\\n    } else if(newBalance \\u003c currentBalance) {\\n      uint256 burnAmount = currentBalance.sub(newBalance);\\n      _burn(account, burnAmount);\\n    }\\n  }\\n}\\n \\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n \\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n \\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n \\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n \\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n \\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n \\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n \\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n \\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n \\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n \\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n \\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n \\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n \\n    function initialize(address, address) external;\\n}\\n \\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n    function swapExactTokensForTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external returns (uint[] memory amounts); \\n    function swapTokensForExactTokens( uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline ) external returns (uint[] memory amounts); \\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts); \\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts); \\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts); \\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\\n}\\n \\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline ) external returns (uint amountETH); \\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s ) external returns (uint amountETH); \\n    \\n    \\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external; \\n    function swapExactETHForTokensSupportingFeeOnTransferTokens( uint amountOutMin, address[] calldata path, address to, uint deadline ) external payable; \\n    function swapExactTokensForETHSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline ) external; \\n \\n}\\n \\n\\n\\ncontract Insanity_WolfDividendTracker is DividendPayingToken  {\\n    using SafeMath for uint256;\\n    using SafeMathInt for int256;\\n    using IterableMapping for IterableMapping.Map;\\n \\n    IterableMapping.Map private tokenHoldersMap;\\n    uint256 public lastProcessedIndex;\\n    address public addressNft;\\n    address public addressToken;\\n \\n    mapping (address =\\u003e bool) public excludedFromDividends;\\n \\n    mapping (address =\\u003e uint256) public lastClaimTimes;\\n \\n    uint256 public claimWait;\\n    uint256 public minimumTokenBalanceForDividends;\\n \\n    event ExcludeFromDividends(address indexed account);\\n    event ClaimWaitUpdated(uint256 indexed newValue, uint256 indexed oldValue);\\n \\n    event Claim(address indexed account, uint256 amount, bool indexed automatic);\\n \\n    constructor(address _dividentToken) DividendPayingToken(\\\"InsanityWolf_Tracker\\\", \\\"InsanityWolf_Tracker\\\",_dividentToken) {\\n    \\tclaimWait = 1800;\\n        minimumTokenBalanceForDividends = 1000 * (10**9);\\n    }\\n\\n    modifier onlyContracts {\\n        require(msg.sender == addressToken || msg.sender == addressNft);\\n        _;\\n    }\\n \\n    function _transfer(address, address, uint256) pure internal override {\\n        require(false, \\\"InsanityWolf_Tracker: No transfers allowed\\\");\\n    }\\n \\n    function withdrawDividend() pure public override {\\n        require(false, \\\"InsanityWolf_Tracker: withdrawDividend disabled. Use the \\u0027claim\\u0027 function on the main InsanityWolf contract.\\\");\\n    }\\n \\n    function setDividendTokenAddress(address newToken) external override onlyOwner {\\n      dividendToken = newToken;\\n    }\\n\\n    function setAddresses(address nft, address tokenz) external onlyOwner {\\n        addressToken = tokenz;\\n        addressNft = nft;\\n    }\\n \\n    function updateMinimumTokenBalanceForDividends(uint256 _newMinimumBalance) external onlyOwner {\\n        require(_newMinimumBalance != minimumTokenBalanceForDividends, \\\"New mimimum balance for dividend cannot be same as current minimum balance\\\");\\n        minimumTokenBalanceForDividends = _newMinimumBalance * (10**9);\\n    }\\n\\n    function isExcludedFromDividend(address adr) external view returns(bool){\\n        return excludedFromDividends[adr];\\n    }\\n \\n    function excludeFromDividends(address account) external onlyOwner {\\n    \\trequire(!excludedFromDividends[account]);\\n    \\texcludedFromDividends[account] = true;\\n \\n    \\t_setBalance(account, 0);\\n    \\ttokenHoldersMap.remove(account);\\n \\n    \\temit ExcludeFromDividends(account);\\n    }\\n    \\n    function int_excludeFromDividends(address account) public onlyContracts {\\n    \\texcludedFromDividends[account] = true;\\n    \\t_setBalance(account, 0);\\n    \\ttokenHoldersMap.remove(account);\\n\\n    \\t//emit ExcludeFromDividends(account);\\n    }\\n\\n    function int_includeInDividends(address payable account, uint256 newBalance) external onlyContracts { /// poi cambia public\\n    \\tif(newBalance \\u003e= minimumTokenBalanceForDividends) {\\n            _setBalance(account, newBalance);\\n    \\t\\ttokenHoldersMap.set(account, newBalance);\\n            excludedFromDividends[account] = false;\\n    \\t}\\n    \\telse {\\n            _setBalance(account, 0);\\n    \\t\\ttokenHoldersMap.remove(account);\\n    \\t}\\n\\n    \\tprocessAccount(account, true);\\n    }\\n \\n    function updateClaimWait(uint256 newClaimWait) external onlyOwner {\\n        require(newClaimWait \\u003e= 1800 \\u0026\\u0026 newClaimWait \\u003c= 86400, \\\"InsanityWolf_Tracker: claimWait must be updated to between 1 and 24 hours\\\");\\n        require(newClaimWait != claimWait, \\\"InsanityWolf_Tracker: Cannot update claimWait to same value\\\");\\n        emit ClaimWaitUpdated(newClaimWait, claimWait);\\n        claimWait = newClaimWait;\\n    }\\n \\n    function getLastProcessedIndex() external view returns(uint256) {\\n    \\treturn lastProcessedIndex;\\n    }\\n \\n    function getNumberOfTokenHolders() external view returns(uint256) {\\n        return tokenHoldersMap.keys.length;\\n    }\\n \\n \\n    function getAccount(address _account)\\n        public view returns (\\n            address account,\\n            int256 index,\\n            int256 iterationsUntilProcessed,\\n            uint256 withdrawableDividends,\\n            uint256 totalDividends,\\n            uint256 lastClaimTime,\\n            uint256 nextClaimTime,\\n            uint256 secondsUntilAutoClaimAvailable) {\\n        account = _account;\\n \\n        index = tokenHoldersMap.getIndexOfKey(account);\\n \\n        iterationsUntilProcessed = -1;\\n \\n        if(index \\u003e= 0) {\\n            if(uint256(index) \\u003e lastProcessedIndex) {\\n                iterationsUntilProcessed = index.sub(int256(lastProcessedIndex));\\n            }\\n            else {\\n                uint256 processesUntilEndOfArray = tokenHoldersMap.keys.length \\u003e lastProcessedIndex ?\\n                                                        tokenHoldersMap.keys.length.sub(lastProcessedIndex) :\\n                                                        0;\\n \\n \\n                iterationsUntilProcessed = index.add(int256(processesUntilEndOfArray));\\n            }\\n        }\\n \\n \\n        withdrawableDividends = withdrawableDividendOf(account);\\n        totalDividends = accumulativeDividendOf(account);\\n \\n        lastClaimTime = lastClaimTimes[account];\\n \\n        nextClaimTime = lastClaimTime \\u003e 0 ?\\n                                    lastClaimTime.add(claimWait) :\\n                                    0;\\n \\n        secondsUntilAutoClaimAvailable = nextClaimTime \\u003e block.timestamp ?\\n                                                    nextClaimTime.sub(block.timestamp) :\\n                                                    0;\\n    }\\n \\n    function getAccountAtIndex(uint256 index)\\n        public view returns (\\n            address,\\n            int256,\\n            int256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256) {\\n    \\tif(index \\u003e= tokenHoldersMap.size()) {\\n            return (0x0000000000000000000000000000000000000000, -1, -1, 0, 0, 0, 0, 0);\\n        }\\n \\n        address account = tokenHoldersMap.getKeyAtIndex(index);\\n \\n        return getAccount(account);\\n    }\\n \\n    function canAutoClaim(uint256 lastClaimTime) private view returns (bool) {\\n    \\tif(lastClaimTime \\u003e block.timestamp)  {\\n    \\t\\treturn false;\\n    \\t}\\n \\n    \\treturn block.timestamp.sub(lastClaimTime) \\u003e= claimWait;\\n    }\\n \\n    function setBalance(address payable account, uint256 newBalance) external onlyOwner {\\n    \\tif(excludedFromDividends[account]) {\\n    \\t\\treturn;\\n    \\t}\\n \\n    \\tif(newBalance \\u003e= minimumTokenBalanceForDividends) {\\n            _setBalance(account, newBalance);\\n    \\t\\ttokenHoldersMap.set(account, newBalance);\\n    \\t}\\n    \\telse {\\n            _setBalance(account, 0);\\n    \\t\\ttokenHoldersMap.remove(account);\\n    \\t}\\n \\n    \\tprocessAccount(account, true);\\n    }\\n \\n    function process(uint256 gas) public returns (uint256, uint256, uint256) {\\n    \\tuint256 numberOfTokenHolders = tokenHoldersMap.keys.length;\\n \\n    \\tif(numberOfTokenHolders == 0) {\\n    \\t\\treturn (0, 0, lastProcessedIndex);\\n    \\t}\\n \\n    \\tuint256 _lastProcessedIndex = lastProcessedIndex;\\n \\n    \\tuint256 gasUsed = 0;\\n \\n    \\tuint256 gasLeft = gasleft();\\n \\n    \\tuint256 iterations = 0;\\n    \\tuint256 claims = 0;\\n \\n    \\twhile(gasUsed \\u003c gas \\u0026\\u0026 iterations \\u003c numberOfTokenHolders) {\\n    \\t\\t_lastProcessedIndex++;\\n \\n    \\t\\tif(_lastProcessedIndex \\u003e= tokenHoldersMap.keys.length) {\\n    \\t\\t\\t_lastProcessedIndex = 0;\\n    \\t\\t}\\n \\n    \\t\\taddress account = tokenHoldersMap.keys[_lastProcessedIndex];\\n \\n    \\t\\tif(canAutoClaim(lastClaimTimes[account])) {\\n    \\t\\t\\tif(processAccount(payable(account), true)) {\\n    \\t\\t\\t\\tclaims++;\\n    \\t\\t\\t}\\n    \\t\\t}\\n \\n    \\t\\titerations++;\\n \\n    \\t\\tuint256 newGasLeft = gasleft();\\n \\n    \\t\\tif(gasLeft \\u003e newGasLeft) {\\n    \\t\\t\\tgasUsed = gasUsed.add(gasLeft.sub(newGasLeft));\\n    \\t\\t}\\n \\n    \\t\\tgasLeft = newGasLeft;\\n    \\t}\\n \\n    \\tlastProcessedIndex = _lastProcessedIndex;\\n \\n    \\treturn (iterations, claims, lastProcessedIndex);\\n    }\\n \\n    function processAccount(address payable account, bool automatic) public onlyOwner returns (bool) {\\n        uint256 amount = _withdrawDividendOfUser(account);\\n \\n    \\tif(amount \\u003e 0) {\\n    \\t\\tlastClaimTimes[account] = block.timestamp;\\n            emit Claim(account, amount, automatic);\\n    \\t\\treturn true;\\n    \\t}\\n \\n    \\treturn false;\\n    }\\n}\\ninterface IERC165 {\\n\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\ninterface IERC721 is IERC165 {\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    function approve(address to, uint256 tokenId) external;\\n\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\ncontract insanity_Wolf is ERC20, Ownable {\\n//library\\n    using SafeMath for uint256;\\n //custom\\n    IUniswapV2Router02 public uniswapV2Router;\\n    Insanity_WolfDividendTracker public insanitywolfDividendTracker;\\n//address\\n    address public uniswapV2Pair;\\n    address public marketingWallet = 0xea0a11Ce9326c73e78550285f437BB767ba9f7C9;\\n    address public teamWallet = 0x488E6edfC26Df25Cc850347b352f59fBf65C385A;\\n    address public buyBackWallet = 0x1A4612ea32627b1f6135386065c8196196A67060; \\n    address public insanitywolfDividendToken;\\n    address public deadWallet = 0x000000000000000000000000000000000000dEaD;\\n    IERC721 nftContract;\\n //bool\\n    bool public marketingSwapSendActive = true;\\n    bool public teamSwapSendActive = true;\\n    bool public LiqSwapSendActive = true;\\n    bool public swapAndLiquifyEnabled = true;\\n    bool public ProcessDividendStatus = true;\\n    bool public insanitywolfDividendEnabled = true;\\n    bool public marketActive =  false;\\n    bool public blockMultiBuys = true;\\n    bool public limitSells = true;\\n    bool public limitBuys = true;\\n    bool public feeStatus = true;\\n    bool public buyFeeStatus = true;\\n    bool public sellFeeStatus = true;\\n    bool private isInternalTransaction = false;\\n\\n //uint\\n    uint256 public buySecondsLimit = 5;\\n    uint256 public minimumWeiForTokenomics = 1 * 10**17; // 0.1 bnb\\n    uint256 public maxBuyTxAmount; // 1.5% tot supply (constructor)\\n    uint256 public maxSellTxAmount;// 1% tot supply (constructor)\\n    uint256 public minimumTokensBeforeSwap = 20000 *10**9;\\n    uint256 public TokensToSwap = minimumTokensBeforeSwap;\\n    uint256 public intervalSecondsForSwap = 120;\\n    uint256 public INSARewardsBuyFee = 2;\\n    uint256 public INSARewardsSellFee = 2;\\n    uint256 public teamBuyFee = 2;\\n    uint256 public teamSellFee = 2;\\n    uint256 public marketingBuyFee = 4;\\n    uint256 public marketingSellFee = 6;\\n    uint256 public buyBackBuyFee = 2;\\n    uint256 public buyBackSellFee = 2;\\n    uint256 public totalBuyFees = INSARewardsBuyFee.add(teamBuyFee).add(marketingBuyFee).add(buyBackBuyFee);\\n    uint256 public totalSellFees = INSARewardsSellFee.add(teamSellFee).add(marketingSellFee).add(buyBackSellFee);\\n    uint256 public gasForProcessing = 300000;\\n    uint256 public maxWallet = 3000000 * (10**9); // 3%\\n    uint256 private startTimeForSwap;\\n    uint256 private MarketActiveAt;\\n    \\n//struct\\n    struct userData {\\n        uint lastBuyTime;\\n    }\\n\\n //mapping\\n    mapping (address =\\u003e bool) public premarketUser;\\n    mapping (address =\\u003e bool) public excludedFromFees;\\n    mapping (address =\\u003e bool) public automatedMarketMakerPairs;\\n    mapping (address =\\u003e userData) public userLastTradeData;\\n //event\\n    event UpdateinsanitywolfDividendTracker(address indexed newAddress, address indexed oldAddress);\\n    \\n    event UpdateUniswapV2Router(address indexed newAddress, address indexed oldAddress);\\n \\n    event SwapAndLiquifyEnabledUpdated(bool enabled);\\n    event MarketingEnabledUpdated(bool enabled);\\n    event insanityWolfDividendEnabledUpdated(bool enabled);\\n    \\n \\n    event ExcludeFromFees(address indexed account, bool isExcluded);\\n    event ExcludeMultipleAccountsFromFees(address[] accounts, bool isExcluded);\\n \\n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\\n \\n    event MarketingWalletUpdated(address indexed newMarketingWallet, address indexed oldMarketingWallet);\\n \\n    event GasForProcessingUpdated(uint256 indexed newValue, uint256 indexed oldValue);\\n \\n    event SwapAndLiquify(\\n        uint256 tokensSwapped,\\n        uint256 bnbReceived,\\n        uint256 tokensIntoLiqudity\\n    );\\n \\n    event SendDividends(\\n    \\tuint256 amount\\n    );\\n \\n    event ProcessedinsanitywolfDividendTracker(\\n    \\tuint256 iterations,\\n    \\tuint256 claims,\\n        uint256 lastProcessedIndex,\\n    \\tbool indexed automatic,\\n    \\tuint256 gas,\\n    \\taddress indexed processor\\n    );\\n \\n    \\n \\n    constructor() ERC20(\\\"INSANITY WOLF\\\", \\\"INSA\\\") {\\n        uint256 _total_supply = 100000000 * (10**9);\\n    \\tinsanitywolfDividendToken = 0xE6c78F31e481b144df5e6e35dF8Be83F58769670; \\n\\n        insanitywolfDividendTracker = new Insanity_WolfDividendTracker(insanitywolfDividendToken);\\n    \\tIUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E); \\n         // Create a uniswap pair for this new token\\n        address _uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\\n            .createPair(address(this), _uniswapV2Router.WETH());\\n \\n        uniswapV2Router = _uniswapV2Router;\\n        uniswapV2Pair = _uniswapV2Pair;\\n \\n        _setAutomatedMarketMakerPair(_uniswapV2Pair, true);\\n \\n        excludeFromDividend(address(insanitywolfDividendTracker));\\n        excludeFromDividend(address(this));\\n        excludeFromDividend(address(_uniswapV2Router));\\n        excludeFromDividend(deadWallet);\\n \\n        // exclude from paying fees or having max transaction amount\\n        excludeFromFees(marketingWallet, true);\\n        excludeFromFees(teamWallet, true);\\n        excludeFromFees(buyBackWallet, true);\\n        excludeFromFees(address(this), true);\\n        excludeFromFees(deadWallet, true);\\n        excludeFromFees(owner(), true);\\n        premarketUser[owner()] = true;\\n \\n        setAuthOnDividends(owner());\\n \\n        /*\\n            _mint is an internal function in ERC20.sol that is only called here,\\n            and CANNOT be called ever again\\n        */\\n        _mint(owner(), _total_supply);\\n        maxSellTxAmount =  500000 * (10**9); // 0.5%\\n        maxBuyTxAmount =  1000000 * (10**9); // 1%\\n    }\\n \\n    receive() external payable {\\n \\n  \\t}\\n\\n    function setProcessDividendStatus(bool _active) external onlyOwner {\\n        ProcessDividendStatus = _active;\\n    }\\n\\n    function setSwapAndLiquify(bool _state, uint _intervalSecondsForSwap, uint _minimumTokensBeforeSwap, uint tkToswp) external onlyOwner {\\n        require(tkToswp \\u003c 1000000);\\n        swapAndLiquifyEnabled = _state;\\n        intervalSecondsForSwap = _intervalSecondsForSwap;\\n        minimumTokensBeforeSwap = _minimumTokensBeforeSwap*10**decimals();\\n        TokensToSwap = tkToswp*10**decimals();\\n    }\\n    function setSwapSend(bool _marketing, bool _team, bool _buyBack) external onlyOwner {\\n        marketingSwapSendActive = _marketing;\\n        teamSwapSendActive = _team;\\n        LiqSwapSendActive = _buyBack;\\n    }\\n    function setMultiBlock(bool _state) external onlyOwner {\\n        blockMultiBuys = _state;\\n    }\\n    function setFeesDetails(bool _feeStatus, bool _buyFeeStatus, bool _sellFeeStatus) external onlyOwner {\\n        feeStatus = _feeStatus;\\n        buyFeeStatus = _buyFeeStatus;\\n        sellFeeStatus = _sellFeeStatus;\\n    }\\n    function setMaxTxAmount(uint _buy, uint _sell) external onlyOwner {\\n        require(_buy \\u003e 100000 \\u0026\\u0026 _sell \\u003e 100000);\\n        maxBuyTxAmount = _buy*10**decimals();\\n        maxSellTxAmount = _sell*10**decimals();\\n    }\\n    function setBuySecondLimits(uint buy) external onlyOwner {\\n        buySecondsLimit = buy;\\n    }\\n    function setNftContract(address adr) public onlyOwner {\\n        nftContract = IERC721(adr);\\n    }\\n    function activateMarket(bool active) external onlyOwner {\\n        marketActive = active;\\n        if (marketActive) {\\n            MarketActiveAt = block.timestamp;\\n        }\\n    }\\n    function editLimits(bool buy, bool sell) external onlyOwner {\\n        limitSells = sell;\\n        limitBuys = buy;\\n    }\\n    function setMinimumWeiForTokenomics(uint _value) external onlyOwner {\\n        minimumWeiForTokenomics = _value;\\n    }\\n\\n    function editPreMarketUser(address _address, bool active) external onlyOwner {\\n        premarketUser[_address] = active;\\n    }\\n    \\n    function transferForeignToken(address _token, address _to, uint256 _value) external onlyOwner returns(bool _sent){\\n        if(_value == 0) {\\n            _value = IERC20(_token).balanceOf(address(this));\\n        }\\n        _sent = IERC20(_token).transfer(_to, _value);\\n    }\\n   \\n    function Sweep() external onlyOwner {\\n        uint256 balance = address(this).balance;\\n        payable(owner()).transfer(balance);\\n    }\\n    function edit_excludeFromFees(address account, bool excluded) public onlyOwner {\\n        excludedFromFees[account] = excluded;\\n\\n        emit ExcludeFromFees(account, excluded);\\n    }\\n\\n    function excludeMultipleAccountsFromFees(address[] calldata accounts, bool excluded) public onlyOwner {\\n        for(uint256 i = 0; i \\u003c accounts.length; i++) {\\n            excludedFromFees[accounts[i]] = excluded;\\n        }\\n\\n        emit ExcludeMultipleAccountsFromFees(accounts, excluded);\\n    }\\n\\n    function setMarketingWallet(address payable wallet) external onlyOwner{\\n        marketingWallet = wallet;\\n    }\\n\\n    function setMaxWallet(uint max) public onlyOwner {\\n        require(max\\u003e1000000*10**decimals());\\n        maxWallet = max*10**decimals();\\n    }\\n\\n    function setTeamWallet(address newWallet) external onlyOwner{\\n        teamWallet = newWallet;\\n    }\\n    function setbuyBackWallet(address newWallet) external onlyOwner{\\n        buyBackWallet = newWallet;\\n    }\\n\\n    function setFees(uint256 _reward_buy, uint256 _buyBack_buy, uint256 _marketing_buy,\\n        uint256 _reward_sell,uint256 _buyBack_sell,uint256 _marketing_sell, uint256 _teamBuy, uint256 _teamSell) external onlyOwner {\\n        bool totBFees = _reward_buy+_buyBack_buy+_marketing_buy+_teamBuy \\u003c 40;\\n        bool totSfee = _reward_sell+_buyBack_sell+_marketing_sell+_teamSell \\u003c 40;\\n        require(totBFees \\u0026\\u0026 totSfee);\\n        INSARewardsBuyFee = _reward_buy;\\n        INSARewardsSellFee = _reward_sell;\\n        teamBuyFee = _teamBuy;\\n        teamSellFee = _teamSell;\\n        buyBackBuyFee  = _buyBack_buy;\\n        buyBackSellFee  = _buyBack_sell;\\n        marketingBuyFee = _marketing_buy;\\n        marketingSellFee = _marketing_sell;\\n        totalBuyFees = INSARewardsBuyFee.add(teamBuyFee).add(marketingBuyFee).add(buyBackBuyFee);\\n        totalSellFees = INSARewardsSellFee.add(teamSellFee).add(marketingSellFee).add(buyBackSellFee);\\n    }\\n    function KKairdrop(address[] memory _address, uint256[] memory _amount) external onlyOwner {\\n        require(_address.length == _amount.length);\\n        for(uint i=0; i\\u003c _amount.length; i++){\\n            address adr = _address[i];\\n            uint amnt = _amount[i] *10**decimals();\\n            super._transfer(owner(), adr, amnt);\\n            try insanitywolfDividendTracker.setBalance(payable(adr), balanceOf(adr)) {} catch {}\\n        } \\n    }\\n\\n    function swapTokens(uint256 minTknBfSwap) private {\\n        isInternalTransaction = true;\\n        uint256 INSABalance = minTknBfSwap * INSARewardsSellFee / 100;     \\n        uint256 swapBalance = minTknBfSwap - INSABalance;               \\n        swapTokensForBNB(swapBalance);\\n    if(ProcessDividendStatus){\\n        swapTokensForDividendToken(INSABalance, address(this), insanitywolfDividendToken);\\n        uint256 insaDividends = IERC20(insanitywolfDividendToken).balanceOf(address(this));\\n        transferDividends(insanitywolfDividendToken, address(insanitywolfDividendTracker), insanitywolfDividendTracker, insaDividends);\\n        }\\n        isInternalTransaction = false;\\n    } \\n\\n  \\tfunction prepareForPartherOrExchangeListing(address _partnerOrExchangeAddress) external onlyOwner {\\n  \\t    insanitywolfDividendTracker.excludeFromDividends(_partnerOrExchangeAddress);\\n        excludeFromFees(_partnerOrExchangeAddress, true);\\n  \\t}\\n \\n\\n \\n  \\tfunction updateMarketingWallet(address _newWallet) external onlyOwner {\\n  \\t    require(_newWallet != marketingWallet, \\\"InsanityWolf: The marketing wallet is already this address\\\");\\n        excludeFromFees(_newWallet, true);\\n        emit MarketingWalletUpdated(marketingWallet, _newWallet);\\n  \\t    marketingWallet = _newWallet;\\n  \\t}\\n    function updateTeamWallet(address _newWallet) external onlyOwner {\\n  \\t    require(_newWallet != teamWallet, \\\"InsanityWolf: The team Wallet is already this address\\\");\\n        excludeFromFees(_newWallet, true);\\n  \\t    teamWallet = _newWallet;\\n  \\t}\\n    function updateBBWallet(address _newWallet) external onlyOwner {\\n  \\t    require(_newWallet != buyBackWallet, \\\"InsanityWolf: The buyBack Wallet is already this address\\\");\\n        excludeFromFees(_newWallet, true);\\n  \\t    buyBackWallet = _newWallet;\\n  \\t}\\n \\n    function setAuthOnDividends(address account) public onlyOwner {\\n        insanitywolfDividendTracker.setAuth(account);\\n    }\\n \\n    function setinsanityWolfDividendEnabled(bool _enabled) external onlyOwner {\\n        insanitywolfDividendEnabled = _enabled;\\n    } \\n \\n    function updateinsanitywolfDividendTracker(address newAddress) external onlyOwner {\\n        require(newAddress != address(insanitywolfDividendTracker), \\\"InsanityWolf: The dividend tracker already has that address\\\");\\n \\n        Insanity_WolfDividendTracker newinsanitywolfDividendTracker = Insanity_WolfDividendTracker(payable(newAddress));\\n \\n        require(newinsanitywolfDividendTracker.owner() == address(this), \\\"InsanityWolf: The new dividend tracker must be owned by the InsanityWolf token contract\\\");\\n \\n        newinsanitywolfDividendTracker.excludeFromDividends(address(newinsanitywolfDividendTracker));\\n        newinsanitywolfDividendTracker.excludeFromDividends(address(this));\\n        newinsanitywolfDividendTracker.excludeFromDividends(address(uniswapV2Router));\\n        newinsanitywolfDividendTracker.excludeFromDividends(address(deadWallet));\\n \\n        emit UpdateinsanitywolfDividendTracker(newAddress, address(insanitywolfDividendTracker));\\n \\n        insanitywolfDividendTracker = newinsanitywolfDividendTracker;\\n    }\\n\\n    function checkNFT(address adrs) private {\\n        if(adrs == address(uniswapV2Pair) || adrs == address(uniswapV2Router) || adrs == address(owner()) || adrs == address(this)){return;}\\n        else{\\n            if(!insanitywolfDividendTracker.isExcludedFromDividend(adrs)){ //se escluso == false\\n                if(nftContract.balanceOf(adrs) \\u003e 0){\\n                    return;\\n                }else{\\n                    insanitywolfDividendTracker.int_excludeFromDividends(adrs);\\n                    return;\\n                }\\n            }\\n            else{ //se escluso == true\\n                if(nftContract.balanceOf(adrs) == 0){\\n                    return;\\n                }else{\\n                    //includi\\n                    uint bal = balanceOf(adrs);\\n                    insanitywolfDividendTracker.int_includeInDividends(payable(adrs), bal);\\n                    return;\\n                }\\n            }\\n        }\\n    }\\n    function updateYourReflectionStatus() public { //not sure se serve \\n        checkNFT(msg.sender);\\n    }\\n    function updateReflectionStatus(address adrs) external {\\n        checkNFT(adrs);\\n    }\\n\\n    function betterTransferOwnership(address newowner) public onlyOwner {\\n        require(newowner != owner());\\n        excludedFromFees[owner()] = false;\\n        premarketUser[owner()] = false;\\n        transferOwnership(newowner);\\n        excludedFromFees[newowner] = true;\\n        premarketUser[newowner] = true;\\n    }\\n \\n    function updateUniswapV2Router(address newAddress) external onlyOwner {\\n        require(newAddress != address(uniswapV2Router), \\\"InsanityWolf: The router already has that address\\\");\\n        emit UpdateUniswapV2Router(newAddress, address(uniswapV2Router));\\n        uniswapV2Router = IUniswapV2Router02(newAddress);\\n    }\\n \\n    function excludeFromFees(address account, bool excluded) public onlyOwner {\\n        excludedFromFees[account] = excluded;\\n        emit ExcludeFromFees(account, excluded);\\n    }\\n \\n    function excludeFromDividend(address account) public onlyOwner {\\n        insanitywolfDividendTracker.excludeFromDividends(address(account));\\n    }\\n\\n    function isExcludedFromDividendz(address adrs) public view returns(bool){\\n        return insanitywolfDividendTracker.isExcludedFromDividend(adrs);\\n    }\\n \\n    function setAutomatedMarketMakerPair(address pair, bool value) public onlyOwner {\\n        require(pair != uniswapV2Pair, \\\"InsanityWolf: The PancakeSwap pair cannot be removed from automatedMarketMakerPairs\\\");\\n \\n        _setAutomatedMarketMakerPair(pair, value);\\n    }\\n \\n    function _setAutomatedMarketMakerPair(address pair, bool value) private onlyOwner {\\n        require(automatedMarketMakerPairs[pair] != value, \\\"InsanityWolf: Automated market maker pair is already set to that value\\\");\\n        automatedMarketMakerPairs[pair] = value;\\n \\n        if(value) {\\n            insanitywolfDividendTracker.excludeFromDividends(pair);\\n          \\n        }\\n \\n        emit SetAutomatedMarketMakerPair(pair, value);\\n    }\\n \\n    function updateGasForProcessing(uint256 newValue) external onlyOwner {\\n        require(newValue != gasForProcessing, \\\"InsanityWolf: Cannot update gasForProcessing to same value\\\");\\n        gasForProcessing = newValue;\\n        emit GasForProcessingUpdated(newValue, gasForProcessing);\\n    }\\n \\n    function updateMinimumBalanceForDividends(uint256 newMinimumBalance) external onlyOwner {\\n        insanitywolfDividendTracker.updateMinimumTokenBalanceForDividends(newMinimumBalance);\\n    }\\n \\n    function updateClaimWait(uint256 claimWait) external onlyOwner {\\n        insanitywolfDividendTracker.updateClaimWait(claimWait);\\n\\n    }\\n \\n    function getINSAClaimWait() external view returns(uint256) {\\n        return insanitywolfDividendTracker.claimWait();\\n    }\\n \\n  \\n \\n    function getTotalinsanityWolfDividendsDistributed() external view returns (uint256) {\\n        return insanitywolfDividendTracker.totalDividendsDistributed();\\n    }\\n \\n    function withdrawableinsanityWolfDividendOf(address account) external view returns(uint256) {\\n    \\treturn insanitywolfDividendTracker.withdrawableDividendOf(account);\\n  \\t}\\n \\n  \\t\\n \\n\\tfunction insanitywolfDividendTokenBalanceOf(address account) external view returns (uint256) {\\n\\t\\treturn insanitywolfDividendTracker.balanceOf(account);\\n\\t}\\n \\n\\t\\n \\n    function getAccountinsanityWolfDividendsInfo(address account)\\n        external view returns (\\n            address,\\n            int256,\\n            int256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256) {\\n        return insanitywolfDividendTracker.getAccount(account);\\n    }\\n \\n \\n\\tfunction getAccountinsanityWolfDividendsInfoAtIndex(uint256 index)\\n        external view returns (\\n            address,\\n            int256,\\n            int256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256) {\\n    \\treturn insanitywolfDividendTracker.getAccountAtIndex(index);\\n    }\\n \\n    \\n\\tfunction processDividendTracker(uint256 gas) public onlyOwner {\\n\\t\\t(uint256 insaIterations, uint256 insaClaims, uint256 insaLastProcessedIndex) = insanitywolfDividendTracker.process(gas);\\n\\t\\temit ProcessedinsanitywolfDividendTracker(insaIterations, insaClaims, insaLastProcessedIndex, false, gas, tx.origin);\\n\\t\\n    }\\n  \\tfunction updateinsanityWolfDividendToken(address _newContract, uint gas) external onlyOwner {\\n        insanitywolfDividendTracker.process(gas); //test\\n  \\t    insanitywolfDividendToken = _newContract;\\n  \\t    insanitywolfDividendTracker.setDividendTokenAddress(_newContract);\\n  \\t}\\n \\n    function claim() external {\\n\\t\\tinsanitywolfDividendTracker.processAccount(payable(msg.sender), false);\\n\\t\\t\\n    }\\n    function getLastinsanityWolfDividendProcessedIndex() external view returns(uint256) {\\n    \\treturn insanitywolfDividendTracker.getLastProcessedIndex();\\n    }\\n \\n    function setAddressOnlyContract_dividend(address adrTK, address nf) public onlyOwner {\\n        insanitywolfDividendTracker.setAddresses(adrTK, nf);\\n    }\\n \\n    function getNumberOfinsanityWolfDividendTokenHolders() external view returns(uint256) {\\n        return insanitywolfDividendTracker.getNumberOfTokenHolders();\\n    }\\n \\n \\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal override {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n    //tx utility vars\\n        //uint\\n        uint256 trade_type = 0;\\n\\t\\tuint256 contractTokenBalance = balanceOf(address(this));\\n       \\n\\t\\t//bool\\n        bool overMinimumTokenBalance = contractTokenBalance \\u003e= minimumTokensBeforeSwap;\\n    // market status flag\\n        if(!marketActive) {\\n            require(premarketUser[from],\\\"cannot trade before the market opening\\\");\\n        }\\n    // normal transaction\\n        checkNFT(from);\\n        checkNFT(to);\\n        if(!isInternalTransaction) {\\n        // tx limits \\u0026 tokenomics\\n            //buy\\n            if(automatedMarketMakerPairs[from]) {\\n                trade_type = 1;\\n                // limits\\n                if(!excludedFromFees[to]) {\\n                    // tx limit\\n                    if(limitBuys) {\\n                        uint256 senderBalance = balanceOf(to);\\n                        require(amount \\u003c= maxBuyTxAmount, \\\"maxBuyTxAmount Limit Exceeded\\\");\\n                        require(amount+senderBalance \\u003c= maxWallet, \\\"maxWallet Limit Exceeded\\\");\\n                    }\\n                    // multi-buy limit\\n                    if(blockMultiBuys) {\\n                        require(MarketActiveAt + 4 \\u003c block.timestamp,\\\"You cannot buy that fast at launch.\\\");\\n                        require(userLastTradeData[to].lastBuyTime + buySecondsLimit \\u003c= block.timestamp,\\\"You cannot do multi-buy orders.\\\");\\n                        userLastTradeData[to].lastBuyTime = block.timestamp;\\n                    }\\n                }\\n            }\\n            //sell\\n            else if(automatedMarketMakerPairs[to]) {\\n                trade_type = 2;\\n                // liquidity generator for tokenomics\\n                if (swapAndLiquifyEnabled \\u0026\\u0026 balanceOf(uniswapV2Pair) \\u003e 0) {\\n                    if (overMinimumTokenBalance \\u0026\\u0026 startTimeForSwap + intervalSecondsForSwap \\u003c= block.timestamp) {\\n                        startTimeForSwap = block.timestamp;\\n                        // sell to bnb\\n                        swapTokens(TokensToSwap);\\n                    }\\n                }\\n                // limits\\n                if(!excludedFromFees[from]) {\\n                    // tx limit\\n                    if(limitSells) {\\n                        require(amount \\u003c= maxSellTxAmount, \\\"maxSellTxAmount Limit Exceeded\\\");\\n                    }\\n                }\\n            }\\n            // tokenomics\\n            if(address(this).balance \\u003e minimumWeiForTokenomics) {\\n                //marketing\\n                if(marketingSwapSendActive) {\\n                    uint256 marketingTokens = minimumWeiForTokenomics.mul(marketingSellFee).div(totalSellFees);\\n                    (bool success,) = address(marketingWallet).call{value: marketingTokens}(\\\"\\\");\\n                }\\n                //team\\n                if(teamSwapSendActive) {\\n                    uint256 teamTokens = minimumWeiForTokenomics.mul(teamSellFee).div(totalSellFees);\\n                    (bool success,) = address(teamWallet).call{value: teamTokens}(\\\"\\\");\\n                }\\n                //buy back\\n                if(LiqSwapSendActive) {\\n                    uint256 bBackTokens = minimumWeiForTokenomics.mul(buyBackSellFee).div(totalSellFees);\\n                    (bool success,) = address(buyBackWallet).call{value: bBackTokens}(\\\"\\\");\\n                }\\n            }\\n        // fees management\\n            if(feeStatus) {\\n                // no wallet to wallet tax\\n                // buy\\n                if(trade_type == 1 \\u0026\\u0026 buyFeeStatus \\u0026\\u0026 !excludedFromFees[to]) {\\n                \\tuint txFees = amount * totalBuyFees / 100;\\n                \\tamount -= txFees;\\n                    super._transfer(from, address(this), txFees);\\n                }\\n                //sell\\n                else if(trade_type == 2 \\u0026\\u0026 sellFeeStatus \\u0026\\u0026 !excludedFromFees[from]) {\\n                \\tuint txFees = amount * totalSellFees / 100;\\n                \\tamount -= txFees;\\n                    super._transfer(from, address(this), txFees);\\n                }\\n            }\\n        }\\n        // transfer tokens\\n        super._transfer(from, to, amount);\\n        //set dividends\\n        if(!insanitywolfDividendTracker.isExcludedFromDividend(to) || !insanitywolfDividendTracker.isExcludedFromDividend(from) ){\\n            try insanitywolfDividendTracker.setBalance(payable(from), balanceOf(from)) {} catch {}\\n            try insanitywolfDividendTracker.setBalance(payable(to), balanceOf(to)) {} catch {}\\n            // auto-claims one time per transaction\\n             }\\n        if(!isInternalTransaction \\u0026\\u0026 ProcessDividendStatus) {\\n            uint256 gas = gasForProcessing;\\n            try insanitywolfDividendTracker.process(gas) returns (uint256 iterations, uint256 claims, uint256 lastProcessedIndex) {\\n                emit ProcessedinsanitywolfDividendTracker(iterations, claims, lastProcessedIndex, true, gas, tx.origin);\\n            } catch {}\\n        }\\n       \\n    }\\n\\n \\n    function swapTokensForBNB(uint256 tokenAmount) private {\\n        // generate the uniswap pair path of token -\\u003e weth\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = uniswapV2Router.WETH();\\n \\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\\n \\n        // make the swap\\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            tokenAmount,\\n            0, // accept any amount of ETH\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n \\n    }\\n \\n    function swapTokensForDividendToken(uint256 _tokenAmount, address _recipient, address _dividendAddress) private {\\n        address[] memory path = new address[](3);\\n        path[0] = address(this);\\n        path[1] = uniswapV2Router.WETH();\\n        path[2] = _dividendAddress;\\n \\n        _approve(address(this), address(uniswapV2Router), _tokenAmount);\\n \\n        // make the swap\\n        uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n            _tokenAmount,\\n            0, // accept any amount of dividend token\\n            path,\\n            _recipient,\\n            block.timestamp\\n        );\\n    }\\n\\n    function transferDividends(address dividendToken, address dividendTracker, DividendPayingToken dividendPayingTracker, uint256 amount) private {\\n        bool success = IERC20(dividendToken).transfer(dividendTracker, amount);\\n \\n        if (success) {\\n            dividendPayingTracker.distributeDividends(amount);\\n            emit SendDividends(amount);\\n        }\\n    }\\n\\n    function isThisFrom_KKteam() public pure returns(bool) {\\n        //heheboi.gif\\n        return true;\\n    }\\n}\"},\"IterableMapping.sol\":{\"content\":\"//SPDX-License-Identifier: KK\\npragma solidity ^0.8.3;\\nlibrary IterableMapping {\\n    // Iterable mapping from address to uint;\\n    struct Map {\\n        address[] keys;\\n        mapping(address =\\u003e uint) values;\\n        mapping(address =\\u003e uint) indexOf;\\n        mapping(address =\\u003e bool) inserted;\\n    }\\n \\n    function get(Map storage map, address key) public view returns (uint) {\\n        return map.values[key];\\n    }\\n \\n    function getIndexOfKey(Map storage map, address key) public view returns (int) {\\n        if(!map.inserted[key]) {\\n            return -1;\\n        }\\n        return int(map.indexOf[key]);\\n    }\\n \\n    function getKeyAtIndex(Map storage map, uint index) public view returns (address) {\\n        return map.keys[index];\\n    }\\n \\n \\n \\n    function size(Map storage map) public view returns (uint) {\\n        return map.keys.length;\\n    }\\n \\n    function set(Map storage map, address key, uint val) public {\\n        if (map.inserted[key]) {\\n            map.values[key] = val;\\n        } else {\\n            map.inserted[key] = true;\\n            map.values[key] = val;\\n            map.indexOf[key] = map.keys.length;\\n            map.keys.push(key);\\n        }\\n    }\\n \\n    function remove(Map storage map, address key) public {\\n        if (!map.inserted[key]) {\\n            return;\\n        }\\n \\n        delete map.inserted[key];\\n        delete map.values[key];\\n \\n        uint index = map.indexOf[key];\\n        uint lastIndex = map.keys.length - 1;\\n        address lastKey = map.keys[lastIndex];\\n \\n        map.indexOf[lastKey] = index;\\n        delete map.indexOf[key];\\n \\n        map.keys[index] = lastKey;\\n        map.keys.pop();\\n    }\\n}\"},\"Ownable.sol\":{\"content\":\"//SPDX-License-Identifier: KK\\npragma solidity ^0.8.3;\\nimport \\\"./Context.sol\\\";\\nabstract contract Ownable is Context {\\n    address private _owner;\\n \\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n \\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n \\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n \\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n \\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n \\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\"},\"SafeMath.sol\":{\"content\":\"//SPDX-License-Identifier: KK\\npragma solidity ^0.8.3;\\nlibrary SafeMath {\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c \\u003c a) return (false, 0);\\n        return (true, c);\\n    }\\n \\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b \\u003e a) return (false, 0);\\n        return (true, a - b);\\n    }\\n \\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n \\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n \\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n \\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n \\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003c= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n \\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n \\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003e 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n \\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b \\u003e 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n \\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        return a - b;\\n    }\\n \\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        return a / b;\\n    }\\n \\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        return a % b;\\n    }\\n}\"},\"SafeMathInt.sol\":{\"content\":\"//SPDX-License-Identifier: KK\\npragma solidity ^0.8.3;\\nlibrary SafeMathInt {\\n  function mul(int256 a, int256 b) internal pure returns (int256) {\\n    // Prevent overflow when multiplying INT256_MIN with -1\\n    // https://github.com/RequestNetwork/requestNetwork/issues/43\\n    require(!(a == - 2**255 \\u0026\\u0026 b == -1) \\u0026\\u0026 !(b == - 2**255 \\u0026\\u0026 a == -1));\\n \\n    int256 c = a * b;\\n    require((b == 0) || (c / b == a));\\n    return c;\\n  }\\n \\n  function div(int256 a, int256 b) internal pure returns (int256) {\\n    // Prevent overflow when dividing INT256_MIN by -1\\n    // https://github.com/RequestNetwork/requestNetwork/issues/43\\n    require(!(a == - 2**255 \\u0026\\u0026 b == -1) \\u0026\\u0026 (b \\u003e 0));\\n \\n    return a / b;\\n  }\\n \\n  function sub(int256 a, int256 b) internal pure returns (int256) {\\n    require((b \\u003e= 0 \\u0026\\u0026 a - b \\u003c= a) || (b \\u003c 0 \\u0026\\u0026 a - b \\u003e a));\\n \\n    return a - b;\\n  }\\n \\n  function add(int256 a, int256 b) internal pure returns (int256) {\\n    int256 c = a + b;\\n    require((b \\u003e= 0 \\u0026\\u0026 c \\u003e= a) || (b \\u003c 0 \\u0026\\u0026 c \\u003c a));\\n    return c;\\n  }\\n \\n  function toUint256Safe(int256 a) internal pure returns (uint256) {\\n    require(a \\u003e= 0);\\n    return uint256(a);\\n  }\\n}\"},\"SafeMathUint.sol\":{\"content\":\"//SPDX-License-Identifier: KK\\npragma solidity ^0.8.3;\\nlibrary SafeMathUint {\\n  function toInt256Safe(uint256 a) internal pure returns (int256) {\\n    int256 b = int256(a);\\n    require(b \\u003e= 0);\\n    return b;\\n  }\\n}\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeFromFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeMultipleAccountsFromFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"}],\"name\":\"GasForProcessingUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"MarketingEnabledUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newMarketingWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldMarketingWallet\",\"type\":\"address\"}],\"name\":\"MarketingWalletUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"iterations\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claims\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastProcessedIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"automatic\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"processor\",\"type\":\"address\"}],\"name\":\"ProcessedinsanitywolfDividendTracker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SendDividends\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetAutomatedMarketMakerPair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bnbReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiqudity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"SwapAndLiquifyEnabledUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"}],\"name\":\"UpdateUniswapV2Router\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"}],\"name\":\"UpdateinsanitywolfDividendTracker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"insanityWolfDividendEnabledUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"INSARewardsBuyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INSARewardsSellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_address\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amount\",\"type\":\"uint256[]\"}],\"name\":\"KKairdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LiqSwapSendActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ProcessDividendStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Sweep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TokensToSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"activateMarket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"automatedMarketMakerPairs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newowner\",\"type\":\"address\"}],\"name\":\"betterTransferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blockMultiBuys\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyBackBuyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyBackSellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyBackWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyFeeStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buySecondsLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deadWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"buy\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"sell\",\"type\":\"bool\"}],\"name\":\"editLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"editPreMarketUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"edit_excludeFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromDividend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeMultipleAccountsFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"excludedFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasForProcessing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAccountinsanityWolfDividendsInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getAccountinsanityWolfDividendsInfoAtIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getINSAClaimWait\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastinsanityWolfDividendProcessedIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumberOfinsanityWolfDividendTokenHolders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalinsanityWolfDividendsDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"insanitywolfDividendEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"insanitywolfDividendToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"insanitywolfDividendTokenBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"insanitywolfDividendTracker\",\"outputs\":[{\"internalType\":\"contract Insanity_WolfDividendTracker\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"intervalSecondsForSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adrs\",\"type\":\"address\"}],\"name\":\"isExcludedFromDividendz\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isThisFrom_KKteam\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"limitBuys\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"limitSells\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingBuyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingSellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingSwapSendActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBuyTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSellTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumTokensBeforeSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumWeiForTokenomics\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"premarketUser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_partnerOrExchangeAddress\",\"type\":\"address\"}],\"name\":\"prepareForPartherOrExchangeListing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"}],\"name\":\"processDividendTracker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellFeeStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adrTK\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nf\",\"type\":\"address\"}],\"name\":\"setAddressOnlyContract_dividend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"setAuthOnDividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setAutomatedMarketMakerPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"buy\",\"type\":\"uint256\"}],\"name\":\"setBuySecondLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reward_buy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_buyBack_buy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketing_buy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reward_sell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_buyBack_sell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_marketing_sell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_teamBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_teamSell\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_feeStatus\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_buyFeeStatus\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_sellFeeStatus\",\"type\":\"bool\"}],\"name\":\"setFeesDetails\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"setMarketingWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_buy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sell\",\"type\":\"uint256\"}],\"name\":\"setMaxTxAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"setMaxWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setMinimumWeiForTokenomics\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_state\",\"type\":\"bool\"}],\"name\":\"setMultiBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"setNftContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_active\",\"type\":\"bool\"}],\"name\":\"setProcessDividendStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_state\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_intervalSecondsForSwap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minimumTokensBeforeSwap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tkToswp\",\"type\":\"uint256\"}],\"name\":\"setSwapAndLiquify\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_marketing\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_team\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_buyBack\",\"type\":\"bool\"}],\"name\":\"setSwapSend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"setTeamWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"setbuyBackWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setinsanityWolfDividendEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapAndLiquifyEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamBuyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamSellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamSwapSendActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBuyFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSellFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferForeignToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_sent\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newWallet\",\"type\":\"address\"}],\"name\":\"updateBBWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"claimWait\",\"type\":\"uint256\"}],\"name\":\"updateClaimWait\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"updateGasForProcessing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newWallet\",\"type\":\"address\"}],\"name\":\"updateMarketingWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMinimumBalance\",\"type\":\"uint256\"}],\"name\":\"updateMinimumBalanceForDividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adrs\",\"type\":\"address\"}],\"name\":\"updateReflectionStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newWallet\",\"type\":\"address\"}],\"name\":\"updateTeamWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"updateUniswapV2Router\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateYourReflectionStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"}],\"name\":\"updateinsanityWolfDividendToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"updateinsanitywolfDividendTracker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userLastTradeData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lastBuyTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"withdrawableinsanityWolfDividendOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "insanity_Wolf", "CompilerVersion": "v0.8.3+commit.8d00100c", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "IterableMapping:96e6369d046704e4985df7152c0a658b0c348d6c", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://93bddb1fdb898aa73f06859aa22abb53d49bc6c1898c151e2fb2f98b31102892"}