{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\ninterface OwnableInterface {\r\n  function owner() external returns (address);\r\n\r\n  function transferOwnership(address recipient) external;\r\n\r\n  function acceptOwnership() external;\r\n}\r\n\r\n/**\r\n * @title The ConfirmedOwner contract\r\n * @notice A contract with helpers for basic contract ownership.\r\n */\r\ncontract ConfirmedOwnerWithProposal is OwnableInterface {\r\n  address private s_owner;\r\n  address private s_pendingOwner;\r\n\r\n  event OwnershipTransferRequested(address indexed from, address indexed to);\r\n  event OwnershipTransferred(address indexed from, address indexed to);\r\n\r\n  constructor(address newOwner, address pendingOwner) {\r\n    require(newOwner != address(0), \"Cannot set owner to zero\");\r\n\r\n    s_owner = newOwner;\r\n    if (pendingOwner != address(0)) {\r\n      _transferOwnership(pendingOwner);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Allows an owner to begin transferring ownership to a new address,\r\n   * pending.\r\n   */\r\n  function transferOwnership(address to) public override onlyOwner {\r\n    _transferOwnership(to);\r\n  }\r\n\r\n  /**\r\n   * @notice Allows an ownership transfer to be completed by the recipient.\r\n   */\r\n  function acceptOwnership() external override {\r\n    require(msg.sender == s_pendingOwner, \"Must be proposed owner\");\r\n\r\n    address oldOwner = s_owner;\r\n    s_owner = msg.sender;\r\n    s_pendingOwner = address(0);\r\n\r\n    emit OwnershipTransferred(oldOwner, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @notice Get the current owner\r\n   */\r\n  function owner() public view override returns (address) {\r\n    return s_owner;\r\n  }\r\n\r\n  /**\r\n   * @notice validate, transfer ownership, and emit relevant events\r\n   */\r\n  function _transferOwnership(address to) private {\r\n    require(to != msg.sender, \"Cannot transfer to self\");\r\n\r\n    s_pendingOwner = to;\r\n\r\n    emit OwnershipTransferRequested(s_owner, to);\r\n  }\r\n\r\n  /**\r\n   * @notice validate access\r\n   */\r\n  function _validateOwnership() internal view {\r\n    require(msg.sender == s_owner, \"Only callable by owner\");\r\n  }\r\n\r\n  /**\r\n   * @notice Reverts if called by anyone other than the contract owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    _validateOwnership();\r\n    _;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title The ConfirmedOwner contract\r\n * @notice A contract with helpers for basic contract ownership.\r\n */\r\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\r\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\r\n}\r\n\r\ninterface IERC20 {\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function balanceOf(address holder) external view returns (uint256);\r\n}\r\n\r\ncontract Lottery is ConfirmedOwner {\r\n    enum LotteryStatus {\r\n        OPEN,\r\n        CLOSED\r\n    }\r\n\r\n    uint256 public lotteryDuration; // in number of days\r\n    IERC20 public token; // token to buy lottery ticket\r\n    uint256 public ticketPrice; // ticket price per token in tokens in wei\r\n    uint256 public maxTicketsPerWallet; // Max number of tickets that can be bought by a wallet\r\n\r\n    uint256 public progressivePoolValue;\r\n\r\n    bool initialized;\r\n    bool locked;\r\n    bool paused;\r\n\r\n    struct LotteryData {\r\n        LotteryStatus status;\r\n        uint256 startTime;\r\n        uint256 endTime;\r\n        uint256 prizePot;\r\n        address[] participants;\r\n        address[3] winners;\r\n    }\r\n\r\n    struct WinnerShare {\r\n        uint256 firstPlace;\r\n        uint256 secondPlace;\r\n        uint256 thirdPlace;\r\n        uint256 burn;\r\n    }\r\n\r\n    mapping(uint256 => bool) public refundStatus;\r\n    mapping(uint256 => mapping(address => bool)) public userRefunded;\r\n\r\n    WinnerShare public share = WinnerShare(35, 25, 15, 25);\r\n\r\n    uint256 public currentLotteryId = 0;\r\n\r\n    mapping(uint256 => LotteryData) private lotteries;\r\n    mapping(uint256 => mapping(address => uint256)) public ticketsBought;\r\n    mapping(uint256 => bool) private numberUsed;\r\n\r\n    event LotteryOpened(uint256 id);\r\n    event LotteryClosed(uint256 id);\r\n    event ParticipantJoined(uint256 lotteryId, address participant);\r\n    event WinnersPicked(\r\n        uint256 lotteryId,\r\n        address first,\r\n        address second,\r\n        address third\r\n    );\r\n    event WinnersPickedManually(\r\n        uint256 lotteryId,\r\n        address first,\r\n        address second,\r\n        address third\r\n    );\r\n    event WinnerSharesUpdated(\r\n        uint256 firstPlace,\r\n        uint256 secondPlace,\r\n        uint256 thirdPlace,\r\n        uint256 burn\r\n    );\r\n\r\n    constructor() ConfirmedOwner(msg.sender) {\r\n    }\r\n\r\n    function initialize(\r\n        uint256 _duration,\r\n        IERC20 _token,\r\n        uint256 _ticketPrice,\r\n        uint8 _decimals,\r\n        uint256 _maxTicketsPerWallet\r\n    ) public onlyOwner {\r\n        require(!initialized, \"Error: Contract is already initialized\");\r\n        require(_duration > 0 && _maxTicketsPerWallet > 0 && _decimals > 0, \"Error: Can't set to zero value\");\r\n        require(\r\n            _token != IERC20(address(0)),\r\n            \"Error: Can't set to zero address\"\r\n        );\r\n\r\n        lotteryDuration = _duration * 1 days;\r\n        token = _token;\r\n        ticketPrice = _ticketPrice * 10**_decimals; // change to wei\r\n        maxTicketsPerWallet = _maxTicketsPerWallet;\r\n\r\n        initialized = true;\r\n    }\r\n\r\n    function togglePause(bool status) external onlyOwner {\r\n        require(initialized, \"Error: Not initialized yet\");\r\n        require(paused != status, \"Error: Already set to that value\");\r\n\r\n        paused = status;\r\n    }\r\n\r\n    function lockValues() external onlyOwner {\r\n        require(initialized, \"Error: Contract is not yet initialized\");\r\n        require(!locked, \"Error: Already locked\");\r\n\r\n        locked = true;\r\n    }\r\n\r\n    function fetchLotteryData(uint256 lotteryId)\r\n        external\r\n        view\r\n        returns (\r\n            LotteryStatus status,\r\n            uint256 startTime,\r\n            uint256 endTime,\r\n            uint256 prizePot,\r\n            address[] memory participants,\r\n            address[3] memory winners\r\n        )\r\n    {\r\n        require(lotteryId <= currentLotteryId, \"Lottery does not exist\");\r\n        LotteryData storage lottery = lotteries[lotteryId];\r\n        return (\r\n            lottery.status,\r\n            lottery.startTime,\r\n            lottery.endTime,\r\n            lottery.prizePot,\r\n            lottery.participants,\r\n            lottery.winners\r\n        );\r\n    }\r\n\r\n    function participate(uint256 _tickets) external {\r\n        require(_tickets > 0, \"Error: Buy at least 1 ticket\");\r\n        require(initialized && !paused, \"Error: Not open!\");\r\n        require(\r\n            block.timestamp < lotteries[currentLotteryId].endTime,\r\n            \"Error: Lottery has ended\"\r\n        );\r\n        require(\r\n            ticketsBought[currentLotteryId][msg.sender] + _tickets <=\r\n                maxTicketsPerWallet,\r\n            \"Error: Can't buy more tickets than max allowed per wallet\"\r\n        );\r\n        require(\r\n            lotteries[currentLotteryId].status == LotteryStatus.OPEN,\r\n            \"Error: Lottery is not open\"\r\n        );\r\n        require(\r\n            token.balanceOf(msg.sender) >= ticketPrice * _tickets,\r\n            \"Error: Must have enough balance to buy tickets\"\r\n        );\r\n        require(\r\n            token.transferFrom(\r\n                msg.sender,\r\n                address(this),\r\n                ticketPrice * _tickets\r\n            ),\r\n            \"Error: Transfer failed\"\r\n        );\r\n\r\n        // Add user address based on number of tickets\r\n        for (uint256 i = 0; i < _tickets; i++) {\r\n            lotteries[currentLotteryId].participants.push(msg.sender);\r\n        }\r\n\r\n        ticketsBought[currentLotteryId][msg.sender] += _tickets;\r\n        lotteries[currentLotteryId].prizePot += ticketPrice * _tickets;\r\n\r\n        progressivePoolValue += ticketPrice * _tickets;\r\n\r\n        emit ParticipantJoined(currentLotteryId, msg.sender);\r\n    }\r\n\r\n    function closeLottery() internal {\r\n        require(\r\n            lotteries[currentLotteryId].status == LotteryStatus.OPEN,\r\n            \"Error: Lottery already closed\"\r\n        );\r\n        require(\r\n            block.timestamp >= lotteries[currentLotteryId].endTime,\r\n            \"Error: Wait for lottery to end\"\r\n        );\r\n\r\n        lotteries[currentLotteryId].status = LotteryStatus.CLOSED;\r\n\r\n        emit LotteryClosed(currentLotteryId);\r\n    }\r\n\r\n    function _distributePrizes(uint256 randomWord1, uint256 randomWord2)\r\n        internal\r\n    {\r\n        address[] storage participants = lotteries[currentLotteryId]\r\n            .participants;\r\n\r\n        uint256[] memory indices = new uint256[](participants.length);\r\n        for (uint256 i = 0; i < participants.length; i++) {\r\n            indices[i] = i;\r\n        }\r\n\r\n        uint256 randomness = randomWord1 ^ randomWord2;\r\n\r\n        for (uint256 i = 0; i < 3; i++) {\r\n            uint256 randomIndex = randomness % indices.length;\r\n            randomness /= indices.length;\r\n\r\n            address winnerAddress = participants[indices[randomIndex]];\r\n            lotteries[currentLotteryId].winners[i] = winnerAddress;\r\n\r\n            // Remove all instances of the winnerAddress from the indices\r\n            uint256 lastUnprocessedIndex = indices.length - 1;\r\n            for (uint256 j = 0; j <= lastUnprocessedIndex; ) {\r\n                if (participants[indices[j]] == winnerAddress) {\r\n                    indices[j] = indices[lastUnprocessedIndex];\r\n                    lastUnprocessedIndex--;\r\n                } else {\r\n                    j++;\r\n                }\r\n            }\r\n            assembly {\r\n                mstore(indices, lastUnprocessedIndex)\r\n            }\r\n        }\r\n\r\n        uint256 tokenBalance = token.balanceOf(address(this));\r\n        uint256 firstPrizeAmount = (tokenBalance * share.firstPlace) / 100;\r\n        uint256 secondPrizeAmount = (tokenBalance * share.secondPlace) / 100;\r\n        uint256 thirdPrizeAmount = (tokenBalance * share.thirdPlace) / 100;\r\n        uint256 burnAmount = (tokenBalance * share.burn) / 100;\r\n\r\n        token.transfer(\r\n            lotteries[currentLotteryId].winners[0],\r\n            firstPrizeAmount\r\n        );\r\n        token.transfer(\r\n            lotteries[currentLotteryId].winners[1],\r\n            secondPrizeAmount\r\n        );\r\n        token.transfer(\r\n            lotteries[currentLotteryId].winners[2],\r\n            thirdPrizeAmount\r\n        );\r\n        if (burnAmount > 0) {\r\n            token.transfer(address(0xdead), burnAmount);\r\n        }\r\n    }\r\n\r\n    function updateLotteryParameters(uint256 _lotteryDuration, uint256 _ticketPrice, uint256 _maxPerWallet) external onlyOwner{\r\n        require(!locked, \"Error: Contract is already locked\");\r\n        require(_lotteryDuration > 0 && _maxPerWallet > 0, \"Error: Can't set to zero value\");\r\n        lotteryDuration = _lotteryDuration;\r\n        ticketPrice = _ticketPrice;\r\n        maxTicketsPerWallet = _maxPerWallet;\r\n    }\r\n\r\n    function _startNewLottery() internal {\r\n        require(initialized, \"Error: Contract hasn't been initialized yet\");\r\n\r\n        currentLotteryId++;\r\n        lotteries[currentLotteryId].startTime = block.timestamp;\r\n        lotteries[currentLotteryId].endTime = block.timestamp + lotteryDuration;\r\n        lotteries[currentLotteryId].prizePot = 0;\r\n        lotteries[currentLotteryId].status = LotteryStatus.OPEN;\r\n        emit LotteryOpened(currentLotteryId);\r\n    }\r\n\r\n    function startLottery() external onlyOwner {\r\n        _startNewLottery();\r\n    }\r\n\r\n    function setWinnerShares(\r\n        uint256 _firstPlace,\r\n        uint256 _secondPlace,\r\n        uint256 _thirdPlace,\r\n        uint256 _burn\r\n    ) external onlyOwner {\r\n        require(!locked, \"Error: Contract is already locked\");\r\n        uint256 combinedShare = _firstPlace +\r\n            _secondPlace +\r\n            _thirdPlace +\r\n            _burn;\r\n        require(combinedShare == 100, \"Error: Total should be 100%\");\r\n        share.firstPlace = _firstPlace;\r\n        share.secondPlace = _secondPlace;\r\n        share.thirdPlace = _thirdPlace;\r\n        share.burn = _burn;\r\n\r\n        emit WinnerSharesUpdated(_firstPlace, _secondPlace, _thirdPlace, _burn);\r\n    }\r\n\r\n    function claimRefund() external {\r\n        require(refundStatus[currentLotteryId], \"Error: not in refund mode.\");\r\n        require(\r\n            !userRefunded[currentLotteryId][msg.sender],\r\n            \"Error: already refunded\"\r\n        );\r\n\r\n        if (ticketsBought[currentLotteryId][msg.sender] > 0) {\r\n            userRefunded[currentLotteryId][msg.sender] = true;\r\n            uint256 refundAmount = ticketsBought[currentLotteryId][msg.sender] *\r\n                ticketPrice;\r\n            token.transfer(msg.sender, refundAmount);\r\n        } else {\r\n            revert(\"No refund to claim\");\r\n        }\r\n    }\r\n\r\n    function pickWinnersWithContract(\r\n        uint256 _firstNumber,\r\n        uint256 _secondNumber\r\n    ) external onlyOwner {\r\n        require(\r\n            _firstNumber != _secondNumber,\r\n            \"Error: both numbers can't be same\"\r\n        );\r\n        require(\r\n            !numberUsed[_firstNumber] && !numberUsed[_secondNumber],\r\n            \"Error: numbers already used\"\r\n        );\r\n\r\n        closeLottery();\r\n\r\n        uint256 num1 = block.timestamp + _firstNumber;\r\n        uint256 num2 = block.timestamp + _secondNumber;\r\n\r\n        uint256 randomNum1 = uint256(\r\n            keccak256(abi.encodePacked(num1, _firstNumber))\r\n        ) % 1e12;\r\n        uint256 randomNum2 = uint256(\r\n            keccak256(abi.encodePacked(num2, _secondNumber))\r\n        ) % 1e12;\r\n\r\n        if (\r\n            lotteries[currentLotteryId].participants.length >=\r\n            maxTicketsPerWallet * 3\r\n        ) {\r\n            numberUsed[_firstNumber] = true;\r\n            numberUsed[_secondNumber] = true;\r\n            _distributePrizes(randomNum1, randomNum2);\r\n            emit WinnersPickedManually(\r\n                currentLotteryId,\r\n                lotteries[currentLotteryId].winners[0],\r\n                lotteries[currentLotteryId].winners[1],\r\n                lotteries[currentLotteryId].winners[2]\r\n            );\r\n        } else {\r\n            refundStatus[currentLotteryId] = true;\r\n        }\r\n        _startNewLottery();\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"LotteryClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"LotteryOpened\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lotteryId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"participant\",\"type\":\"address\"}],\"name\":\"ParticipantJoined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"firstPlace\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"secondPlace\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"thirdPlace\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burn\",\"type\":\"uint256\"}],\"name\":\"WinnerSharesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lotteryId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"first\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"second\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"third\",\"type\":\"address\"}],\"name\":\"WinnersPicked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lotteryId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"first\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"second\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"third\",\"type\":\"address\"}],\"name\":\"WinnersPickedManually\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRefund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentLotteryId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lotteryId\",\"type\":\"uint256\"}],\"name\":\"fetchLotteryData\",\"outputs\":[{\"internalType\":\"enum Lottery.LotteryStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prizePot\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"participants\",\"type\":\"address[]\"},{\"internalType\":\"address[3]\",\"name\":\"winners\",\"type\":\"address[3]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_ticketPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_maxTicketsPerWallet\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockValues\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lotteryDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTicketsPerWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tickets\",\"type\":\"uint256\"}],\"name\":\"participate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_firstNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_secondNumber\",\"type\":\"uint256\"}],\"name\":\"pickWinnersWithContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"progressivePoolValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"refundStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_firstPlace\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_secondPlace\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_thirdPlace\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_burn\",\"type\":\"uint256\"}],\"name\":\"setWinnerShares\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"share\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"firstPlace\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"secondPlace\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"thirdPlace\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"burn\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startLottery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ticketPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ticketsBought\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"togglePause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lotteryDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_ticketPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxPerWallet\",\"type\":\"uint256\"}],\"name\":\"updateLotteryParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userRefunded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Lottery", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a873c6a0ad0fc6642342090582c63e92b709a0422451f7725bcc87e18e326614"}