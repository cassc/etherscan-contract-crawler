{"SourceCode": "// \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588    \u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588      \u2588\u2588    \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588    \u2588\u2588                   \r\n// \u2588\u2588   \u2588\u2588 \u2588\u2588      \u2588\u2588    \u2588\u2588 \u2588\u2588    \u2588\u2588 \u2588\u2588      \u2588\u2588    \u2588\u2588     \u2588\u2588  \u2588\u2588 \u2588\u2588    \u2588\u2588 \u2588\u2588\u2588\u2588   \u2588\u2588                  \r\n// \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588   \u2588\u2588    \u2588\u2588 \u2588\u2588    \u2588\u2588 \u2588\u2588      \u2588\u2588    \u2588\u2588   \u2588\u2588    \u2588\u2588 \u2588\u2588    \u2588\u2588 \u2588\u2588 \u2588\u2588  \u2588\u2588                   \r\n// \u2588\u2588   \u2588\u2588 \u2588\u2588       \u2588\u2588  \u2588\u2588  \u2588\u2588    \u2588\u2588 \u2588\u2588      \u2588\u2588    \u2588\u2588  \u2588\u2588     \u2588\u2588 \u2588\u2588    \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588                   \r\n// \u2588\u2588   \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588    \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588   \u2588\u2588\u2588\u2588     \r\n\r\n// CONTRACT DEVELOPED BY REVOLUZION\r\n\r\n//Revoluzion Ecosystem\r\n//WEB: https://revoluzion.io\r\n//DAPP: https://revoluzion.app\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.18;\r\n\r\n/********************************************************************************************\r\n  INTERFACE\r\n********************************************************************************************/\r\n\r\ninterface IERC20 {\r\n    \r\n    // EVENT \r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    \r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    // FUNCTION\r\n\r\n    function name() external view returns (string memory);\r\n    \r\n    function symbol() external view returns (string memory);\r\n    \r\n    function decimals() external view returns (uint8);\r\n    \r\n    function totalSupply() external view returns (uint256);\r\n    \r\n    function balanceOf(address account) external view returns (uint256);\r\n    \r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    \r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    \r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    \r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IRouter {\r\n\r\n    // FUNCTION\r\n\r\n    function WETH() external pure returns (address);\r\n        \r\n    function factory() external pure returns (address);\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external;\r\n    \r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external payable;\r\n\r\n    function addLiquidityETH(address token, uint256 amountTokenDesired, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline) external payable returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\r\n}\r\n\r\ninterface IAuthError {\r\n\r\n    // ERROR\r\n\r\n    error InvalidOwner(address account);\r\n\r\n    error UnauthorizedAccount(address account);\r\n\r\n    error InvalidAuthorizedAccount(address account);\r\n\r\n    error CurrentAuthorizedState(address account, bool state);\r\n}\r\n\r\ninterface ICommonError {\r\n\r\n    // ERROR\r\n\r\n    error CannotUseCurrentAddress(address current);\r\n\r\n    error CannotUseCurrentValue(uint256 current);\r\n\r\n    error CannotUseCurrentState(bool current);\r\n\r\n    error InvalidAddress(address invalid);\r\n\r\n    error InvalidValue(uint256 invalid);\r\n}\r\n\r\ninterface IStaking {\r\n\r\n    // DATA\r\n\r\n    struct Leaderboard {\r\n        uint256 stakeAmount;\r\n        address user;\r\n    }\r\n\r\n    // FUNCTION\r\n\r\n    function isWDYMStaking() external pure returns (bool);\r\n\r\n    function stake(uint256 amount, uint256 stakeTypeId) external;\r\n\r\n    function unstake(uint256 amount, uint256 stakeId) external;\r\n\r\n    function userTotalStakes(address user) external returns (uint256);\r\n\r\n    function getStakeTypeRewardMaxRatio() external view returns (uint256);\r\n    \r\n    function getLeaderboard() external view returns (Leaderboard[] memory);\r\n    \r\n    function deposit() external payable;\r\n\r\n    function depositStuckedBNB() external;\r\n\r\n    function depositBUSD(uint256 amount) external;\r\n\r\n    function depositStuckedBUSD(uint256 amount) external;\r\n}\r\n\r\ninterface IWDYM is IERC20 {\r\n\r\n    // FUNCTION\r\n\r\n    function isWDYM() external pure returns (bool);\r\n}\r\n\r\n/********************************************************************************************\r\n  ACCESS\r\n********************************************************************************************/\r\n\r\nabstract contract Auth is IAuthError{\r\n    \r\n    // DATA\r\n\r\n    address private _owner;\r\n\r\n    // MAPPING\r\n\r\n    mapping(address => bool) public authorization;\r\n\r\n    // MODIFIER\r\n\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    modifier authorized() {\r\n        _checkAuthorized();\r\n        _;\r\n    }\r\n\r\n    // CONSTRUCCTOR\r\n\r\n    constructor(address initialOwner) {\r\n        _transferOwnership(initialOwner);\r\n        authorize(initialOwner);\r\n        if (initialOwner != msg.sender) {\r\n            authorize(msg.sender);\r\n        }\r\n    }\r\n\r\n    // EVENT\r\n    \r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    event UpdateAuthorizedAccount(address authorizedAccount, address caller, bool state, uint256 timestamp);\r\n\r\n    // FUNCTION\r\n    \r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function _checkOwner() internal view virtual {\r\n        if (owner() != msg.sender) {\r\n            revert UnauthorizedAccount(msg.sender);\r\n        }\r\n    }\r\n\r\n    function _checkAuthorized() internal view virtual {\r\n        if (!authorization[msg.sender]) {\r\n            revert UnauthorizedAccount(msg.sender);\r\n        }\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        if (newOwner == address(0)) {\r\n            revert InvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function authorize(address account) public virtual onlyOwner {\r\n        if (account == address(0) || account == address(0xdead)) {\r\n            revert InvalidAuthorizedAccount(account);\r\n        }\r\n        _authorization(account, msg.sender, true);\r\n    }\r\n\r\n    function unauthorize(address account) public virtual onlyOwner {\r\n        if (account == address(0) || account == address(0xdead)) {\r\n            revert InvalidAuthorizedAccount(account);\r\n        }\r\n        _authorization(account, msg.sender, false);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n\r\n    function _authorization(address account, address caller, bool state) internal virtual {\r\n        if (authorization[account] == state) {\r\n            revert CurrentAuthorizedState(account, state);\r\n        }\r\n        authorization[account] = state;\r\n        emit UpdateAuthorizedAccount(account, caller, state, block.timestamp);\r\n    }\r\n}\r\n\r\n/********************************************************************************************\r\n  SECURITY\r\n********************************************************************************************/\r\n\r\nabstract contract Pausable {\r\n\r\n    // DATA\r\n\r\n    bool private _paused;\r\n\r\n    // ERROR\r\n\r\n    error EnforcedPause();\r\n\r\n    error ExpectedPause();\r\n\r\n    // MODIFIER\r\n\r\n    modifier whenNotPaused() {\r\n        _requireNotPaused();\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused() {\r\n        _requirePaused();\r\n        _;\r\n    }\r\n\r\n    // CONSTRUCTOR\r\n\r\n    constructor() {\r\n        _paused = false;\r\n    }\r\n\r\n    // EVENT\r\n    \r\n    event Paused(address account);\r\n\r\n    event Unpaused(address account);\r\n\r\n    // FUNCTION\r\n\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    function pause() external virtual whenNotPaused {\r\n        _pause();\r\n    }\r\n\r\n    function unpause() external virtual whenPaused {\r\n        _unpause();\r\n    }\r\n\r\n    function _requireNotPaused() internal view virtual {\r\n        if (paused()) {\r\n            revert EnforcedPause();\r\n        }\r\n    }\r\n\r\n    function _requirePaused() internal view virtual {\r\n        if (!paused()) {\r\n            revert ExpectedPause();\r\n        }\r\n    }\r\n\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(msg.sender);\r\n    }\r\n\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(msg.sender);\r\n    }\r\n}\r\n\r\n/********************************************************************************************\r\n  STAKING\r\n********************************************************************************************/\r\n\r\ncontract WhatDoYouMemeStaking is Auth, Pausable, ICommonError, IStaking {\r\n\r\n    // DATA\r\n\r\n    struct RewardPool {\r\n        uint256 id;\r\n        uint256 amountAdded;\r\n        uint256 amountClaimed;\r\n        uint256 rewardsPerStake;\r\n        uint256 timestamp;\r\n    }\r\n\r\n    struct Stake {\r\n        uint256 stakeType;\r\n        uint256 amount;\r\n        uint256 timestamp;\r\n        uint256 startPoolIndex;\r\n        uint256 totalExcluded;\r\n        uint256 totalRealised;\r\n    }\r\n\r\n    IRouter public router;\r\n\r\n    IERC20 public constant REWARD = IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\r\n    IWDYM public constant TOKEN = IWDYM(0x769c6F0C5c2BcD1B76638BD58e5350f5c94128F3);\r\n\r\n    RewardPool[] public rewardPools;\r\n\r\n    uint256 public constant DENOMINATOR = 10_000;\r\n\r\n    uint256 public immutable rewardsPerStakeAccuracyFactor;\r\n\r\n    uint256 public amountToRedistribute = 0;\r\n    uint256 public penaltyPercentage = 0;\r\n    uint256 public totalStaked = 0;\r\n    uint256 public totalRewards = 0;\r\n    uint256 public totalDistributed = 0;\r\n    uint256 public rewardsPerStake = 0;\r\n    uint256 public currentPoolIndex = 0;\r\n    uint256 public stakeType = 3;\r\n\r\n    uint256[] public rewardRatio = [100, 150, 300];\r\n\r\n    address private constant DEAD = address(0xdead);\r\n    address private constant ZERO = address(0);\r\n\r\n    address public penaltyReceiver;\r\n\r\n    address[] public stakers;\r\n\r\n    bool private constant ISWDYM_STAKING = true;\r\n\r\n    bool public takePenalty = false;\r\n    bool public emergencyWithdraw = false;\r\n\r\n    // MAPPING\r\n        \r\n    mapping(uint256 => uint256) public stakeTypeToDuration;\r\n    mapping(address => uint256) public stakerIndexes;\r\n    mapping(address => uint256) public userTotalStakes;\r\n    mapping(address => uint256) public userStaking;\r\n    mapping(address => uint256) public userActiveStaking;\r\n    mapping(address => uint256) public userInactiveStaking;\r\n    mapping(address => mapping(uint256 => Stake)) public userStakes;\r\n\r\n    // ERROR\r\n\r\n    error InvalidRewardPoolId();\r\n\r\n    error InvalidStakeId();\r\n\r\n    error EmergencyWithdrawDisabled();\r\n\r\n    error NoStakingRewards();\r\n\r\n    error NotTimeToUnstake(uint256 unstakeTime, uint256 timeNow);\r\n\r\n    error ExceedUserStakeId(uint256 maxIdValue);\r\n\r\n    error ExceedStakeBalance(uint256 balance);\r\n\r\n    error ExceedStakeTypeRange(uint256 maxRange);\r\n\r\n    error ExceedStuckedBalance(uint256 balance);\r\n\r\n    // CONSTRUCTOR\r\n\r\n    constructor(\r\n        address routerAddress,\r\n        address penaltyReceiverAddress\r\n    ) Auth(msg.sender) {\r\n        if (penaltyReceiverAddress == ZERO || penaltyReceiverAddress == DEAD) { revert InvalidAddress(penaltyReceiverAddress); }\r\n        router = IRouter(routerAddress);\r\n        penaltyReceiver = penaltyReceiverAddress;\r\n        rewardsPerStakeAccuracyFactor = 1 ether * 1 ether;\r\n        stakeTypeToDuration[1] = 90 days;\r\n        stakeTypeToDuration[2] = 180 days;\r\n        stakeTypeToDuration[3] = 365 days;\r\n    }\r\n\r\n    // EVENT\r\n\r\n    event UpdateRouter(IRouter oldRouter, IRouter newRouter, address sender, uint256 timestamp);\r\n\r\n    event UpdatePenaltyReceiver(address oldReceiver, address newReceiver, address sender, uint256 timestamp);\r\n\r\n    event UpdatePenalty(uint256 oldPenalty, uint256 newPenalty, address sender, uint256 timestamp);\r\n    \r\n    event UpdateTakePenalty(bool oldState, bool newState, address sender, uint256 timestamp);\r\n\r\n    event UpdateEmergencyWithdraw(bool oldState, bool newState, address sender, uint256 timestamp);\r\n\r\n    event RewardDistribution(uint256 balance, uint256 distributed, address sender, uint256 timestamp);\r\n\r\n    event RewardRescued(uint256 balance, uint256 distributed, address sender, uint256 timestamp);\r\n\r\n    event Staked(address indexed staker, uint256 amount);\r\n\r\n    event Unstaked(address indexed staker, uint256 amount);\r\n\r\n    // FUNCTION\r\n\r\n    /* General */\r\n\r\n    receive() external payable {}\r\n\r\n    function isWDYMStaking() external pure returns (bool) {\r\n        return ISWDYM_STAKING;\r\n    }\r\n\r\n    /* Update */\r\n\r\n    function addStakeType(uint256 duration, uint256 ratio) external authorized {\r\n        if (duration <= 0) { revert InvalidValue(duration); }\r\n        stakeType += 1;\r\n        stakeTypeToDuration[stakeType] = duration;\r\n        rewardRatio.push(ratio);\r\n    }\r\n\r\n    function removeStakeType(uint256 amount) external authorized {\r\n        if (amount <= 0) { revert InvalidValue(amount); }\r\n        if (amount > stakeType) { revert ExceedStakeTypeRange(stakeType); }\r\n        for (uint256 i = stakeType; i > stakeType - amount; i--) {\r\n            stakeTypeToDuration[i] = 0;\r\n            rewardRatio.pop();\r\n        }\r\n        stakeType -= amount;\r\n    }\r\n\r\n    function modifyStakeType(uint256 index, uint256 duration, uint256 ratio) external authorized {\r\n        if (duration <= 0) { revert InvalidValue(duration); }\r\n        if (index <= 0) { revert InvalidValue(index); }\r\n        if (index > stakeType) { revert ExceedStakeTypeRange(stakeType); }\r\n        stakeTypeToDuration[index] = duration;\r\n        rewardRatio[index - 1] = ratio;\r\n    }\r\n\r\n    function updateRouter(IRouter newRouter) external authorized {\r\n        if (newRouter == router) { revert CannotUseCurrentAddress(address(newRouter)); }\r\n        IRouter oldRouter = router;\r\n        router = newRouter;\r\n        emit UpdateRouter(oldRouter, newRouter, msg.sender, block.timestamp);\r\n    }\r\n\r\n    function updatePenaltyReceiver(address newReceiver) external authorized {\r\n        if (newReceiver == penaltyReceiver) { revert CannotUseCurrentAddress(newReceiver); }\r\n        if (newReceiver == ZERO || newReceiver == DEAD) { revert InvalidAddress(newReceiver); }\r\n        address oldReceiver = penaltyReceiver;\r\n        penaltyReceiver = newReceiver;\r\n        emit UpdatePenaltyReceiver(oldReceiver, newReceiver, msg.sender, block.timestamp);\r\n    }\r\n\r\n    function updatePenalty(uint256 newPenalty) external authorized {\r\n        if (newPenalty == penaltyPercentage) { revert CannotUseCurrentValue(newPenalty); }\r\n        if (penaltyPercentage > 2_000) { revert InvalidValue(newPenalty); }\r\n        uint256 oldPenalty = penaltyPercentage;\r\n        penaltyPercentage = newPenalty;\r\n        emit UpdatePenalty(oldPenalty, newPenalty, msg.sender, block.timestamp);\r\n    }\r\n\r\n    function updateTakePenalty(bool newState) external authorized {\r\n        if (newState == takePenalty) { revert CannotUseCurrentState(newState); }\r\n        bool oldState = takePenalty;\r\n        takePenalty = newState;\r\n        emit UpdateTakePenalty(oldState, newState, msg.sender, block.timestamp);\r\n    }\r\n\r\n    function updateEmergencyWithdraw(bool newState) external authorized {\r\n        if (newState == emergencyWithdraw) { revert CannotUseCurrentState(newState); }\r\n        bool oldState = emergencyWithdraw;\r\n        emergencyWithdraw = newState;\r\n        emit UpdateEmergencyWithdraw(oldState, newState, msg.sender, block.timestamp);\r\n    }\r\n\r\n    /* Check */\r\n\r\n    function getStakeTypeRewardMaxRatio() public override view returns (uint256) {\r\n        uint256 maxRatio = 0;\r\n        for (uint256 i = 0; i < rewardRatio.length; i++) {\r\n            if (maxRatio < rewardRatio[i]) {\r\n                maxRatio = rewardRatio[i];\r\n            }\r\n        }\r\n        return maxRatio;\r\n    }\r\n\r\n    function getLeaderboard() external override view returns (Leaderboard[] memory) {\r\n        Leaderboard[] memory board = new Leaderboard[](stakers.length);\r\n        for (uint256 i = 0; i < stakers.length; i++) {\r\n            address user = stakers[i];\r\n            Leaderboard memory item = Leaderboard({\r\n                stakeAmount: userTotalStakes[user],\r\n                user: user\r\n            });\r\n            board[i]= item;\r\n        }\r\n\r\n        for (uint256 i = 0; i < board.length - 1; i++) {\r\n            for (uint256 j = 0; j < board.length - i - 1; j++) {\r\n                if (board[j].stakeAmount <= board[j + 1].stakeAmount) {\r\n                    Leaderboard memory temp = board[j];\r\n                    board[j] = board[j + 1];\r\n                    board[j + 1] = temp;\r\n                }\r\n            }\r\n        }\r\n        return board;\r\n    }\r\n\r\n    function getCumulativeRewards(uint256 amount, uint256 poolId) public view returns (uint256) {\r\n        _verifyPoolID(poolId);\r\n        return amount * rewardPools[poolId - 1].rewardsPerStake / rewardsPerStakeAccuracyFactor;\r\n    }\r\n    \r\n    function getUnpaidEarnings(address staker, uint256 stakeId, uint256 poolId) public view returns (uint256) {\r\n        _verifyPoolID(poolId);\r\n        _verifyStakeID(staker, stakeId);\r\n        \r\n        if (userTotalStakes[staker] == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 stakerTotalRewards = getCumulativeRewards(userStakes[staker][stakeId].amount, poolId);\r\n        uint256 stakerTotalExcluded = userStakes[staker][stakeId].totalExcluded;\r\n\r\n        if (stakerTotalRewards <= stakerTotalExcluded) {\r\n            return 0;\r\n        }\r\n\r\n        return stakerTotalRewards - stakerTotalExcluded;\r\n    }\r\n    \r\n    function getStakeTypeSpecificUnpaidEarnings(address staker, uint256 stakeId, uint256 poolId) public view returns (uint256) {\r\n        return getUnpaidEarnings(staker, stakeId, poolId) * rewardRatio[userStakes[msg.sender][stakeId].stakeType - 1] / getStakeTypeRewardMaxRatio();\r\n    }\r\n    \r\n    function getUserTotalUnpaidEarnings(address staker) public view returns (uint256) {\r\n        uint256 unpaidEarning = 0;\r\n        uint256 totalUserStakes = userStaking[staker];\r\n\r\n        if (userStaking[staker] > 0 && rewardPools.length > 0) {\r\n            for (uint256 i = 1; i <= totalUserStakes; i++) {\r\n                for (uint256 j = 1; j <= rewardPools.length; j++) {\r\n                    if (\r\n                        userStakes[staker][i].amount > 0 &&\r\n                        userStakes[staker][i].startPoolIndex <= j &&\r\n                        rewardPools[j - 1].amountAdded > rewardPools[j - 1].amountClaimed\r\n                    ) {\r\n                        unpaidEarning += getStakeTypeSpecificUnpaidEarnings(staker, i, j);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return unpaidEarning;\r\n    }\r\n\r\n    /* Staking */\r\n\r\n    function stake(uint256 amount, uint256 stakeTypeId) external override whenNotPaused {\r\n        if (stakeTypeId <= 0 || stakeTypeId > stakeType) { revert InvalidValue(stakeTypeId); }\r\n        if (userTotalStakes[msg.sender] == 0) {\r\n            _addStaker(msg.sender);\r\n        }\r\n\r\n        uint256 unpaidEarning = _handleDistribution(msg.sender);\r\n\r\n        uint256 index = userStaking[msg.sender];\r\n        uint256 excluded = 0;\r\n\r\n        if (rewardPools.length > 0) {\r\n            excluded = getCumulativeRewards(amount, rewardPools.length);\r\n        }\r\n\r\n        Stake memory newStake = Stake ({\r\n            stakeType: stakeTypeId,\r\n            amount: amount,\r\n            timestamp: block.timestamp,\r\n            startPoolIndex: rewardPools.length + 1,\r\n            totalExcluded: excluded,\r\n            totalRealised: 0\r\n        });\r\n\r\n        userActiveStaking[msg.sender] += 1;\r\n        userStaking[msg.sender] = index + 1;\r\n        userStakes[msg.sender][index + 1] = newStake;\r\n        userTotalStakes[msg.sender] += amount;\r\n        totalStaked += amount;\r\n\r\n        emit Staked(msg.sender, amount);\r\n        \r\n        if (unpaidEarning > 0) {\r\n            totalDistributed += unpaidEarning;\r\n            require(REWARD.transfer(msg.sender, unpaidEarning), \"Stake: There's something wrong with the transfer.\");\r\n        }\r\n\r\n        require(TOKEN.transferFrom(msg.sender, address(this), amount), \"Stake: There's something wrong with the transfer.\");\r\n    }\r\n\r\n    function unstake(uint256 amount, uint256 stakeId) external override whenNotPaused {\r\n        uint256 unstakeTime = userStakes[msg.sender][stakeId].timestamp + stakeTypeToDuration[userStakes[msg.sender][stakeId].stakeType];\r\n        if (\r\n            unstakeTime > block.timestamp\r\n        ) { revert NotTimeToUnstake(unstakeTime, block.timestamp); }\r\n        _unstake(amount, stakeId, false);\r\n    }\r\n\r\n    function emergencyWithdrawStaking(uint256 amount, uint256 index) external {\r\n        if (!emergencyWithdraw) { revert EmergencyWithdrawDisabled(); }\r\n        _unstake(amount, index, takePenalty);\r\n    }\r\n\r\n    function _unstake(uint256 amount, uint256 stakeId, bool penalty) internal {\r\n        _verifyStakeID(msg.sender, stakeId);\r\n        if (amount <= 0) { revert InvalidValue(amount); }\r\n        if (userStakes[msg.sender][stakeId].amount < amount) { revert ExceedStakeBalance(userStakes[msg.sender][stakeId].amount); }\r\n\r\n        if (rewardPools.length > 0) {\r\n            for (uint256 i = 1; i <= rewardPools.length; i++) {\r\n                if (getUnpaidEarnings(msg.sender, stakeId, i) > 0) {\r\n                    claimRewards(stakeId, i);\r\n                }\r\n            }\r\n        }\r\n\r\n        userStakes[msg.sender][stakeId].amount -= amount;\r\n        userTotalStakes[msg.sender] -= amount;            \r\n        totalStaked -= amount;\r\n\r\n        if (userStakes[msg.sender][stakeId].amount == 0) {\r\n            userActiveStaking[msg.sender] -= 1;\r\n            userInactiveStaking[msg.sender] += 1;\r\n        }\r\n\r\n        if (userTotalStakes[msg.sender] == 0) {\r\n            _removeStaker(msg.sender);\r\n        }\r\n\r\n        emit Unstaked(msg.sender, amount);\r\n        \r\n        uint256 penaltyAmount = 0;\r\n\r\n        if (penaltyPercentage > 0) {\r\n            penaltyAmount = amount * penaltyPercentage / DENOMINATOR;\r\n        }\r\n\r\n        if (penalty) {\r\n            require(TOKEN.transfer(msg.sender, amount - penaltyAmount), \"Unstake: There's something wrong with the transfer.\");\r\n            require(TOKEN.transfer(penaltyReceiver, penaltyAmount), \"Unstake: There's something wrong with the penalty transfer.\");\r\n        } else {\r\n            require(TOKEN.transfer(msg.sender, amount), \"Unstake: There's something wrong with the transfer.\");\r\n        }\r\n    }\r\n\r\n    /* Claim */\r\n\r\n    function claimRewards(uint256 stakeId, uint256 poolId) public {\r\n        _verifyPoolID(poolId);\r\n        _verifyStakeID(msg.sender, stakeId);\r\n        if (userTotalStakes[msg.sender] <= 0) { revert NoStakingRewards(); }\r\n        \r\n        \r\n        uint256 unpaidEarning = 0;\r\n\r\n        if (userStakes[msg.sender][stakeId].amount > 0 && rewardPools[poolId - 1].amountAdded != rewardPools[poolId - 1].amountClaimed) {\r\n            unpaidEarning = _calculateEarnings(msg.sender, stakeId, poolId);\r\n        }\r\n\r\n        if (unpaidEarning > 0) {\r\n            totalDistributed += unpaidEarning;\r\n            require(REWARD.transfer(msg.sender, unpaidEarning), \"Claim Rewards: There's something wrong with the transfer.\");\r\n        } else {\r\n            revert NoStakingRewards();\r\n        }\r\n    }\r\n\r\n    function claimAllRewards() external {\r\n        if (userStaking[msg.sender] > 0 && rewardPools.length > 0) {\r\n            for (uint256 i = 1; i <= userStaking[msg.sender]; i++) {\r\n                for (uint256 j = 1; j <= rewardPools.length; j++) {\r\n                    if (getUnpaidEarnings(msg.sender, i, j) > 0) {\r\n                        claimRewards(i, j);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            revert NoStakingRewards();\r\n        }\r\n    }\r\n\r\n    /* Deposit */\r\n\r\n    function deposit() external override payable whenNotPaused {\r\n        _handleDeposits(msg.value);\r\n    }\r\n    \r\n    function depositStuckedBNB() external override whenNotPaused {\r\n        uint256 amount = address(this).balance;\r\n        _handleDeposits(amount);\r\n    }\r\n    \r\n    function depositBUSD(uint256 amount) external override whenNotPaused {\r\n        uint256 initialRewardBalance = REWARD.balanceOf(address(this));\r\n        \r\n        require(REWARD.transferFrom(msg.sender, address(this), amount), \"Deposit BUSD: There's something wrong with the transfer.\");\r\n\r\n        uint256 added = REWARD.balanceOf(address(this)) - initialRewardBalance;\r\n        _updateRewardInfo(added);\r\n    }\r\n\r\n    function depositStuckedBUSD(uint256 amount) external override whenNotPaused {\r\n        if (amount > amountToRedistribute) { revert ExceedStuckedBalance(amountToRedistribute); }\r\n        if (amountToRedistribute <= 0) { revert InvalidValue(amountToRedistribute); }\r\n        if (amount <= 0) { revert InvalidValue(amount); }\r\n        _updateRewardInfo(amount);\r\n        amountToRedistribute -= amount;\r\n        emit RewardDistribution(amountToRedistribute, amountToRedistribute - amount, msg.sender, block.timestamp);\r\n    }\r\n\r\n    /* Rescue */\r\n\r\n    function wTokens(uint256 amount, address tokenAddress) external onlyOwner {\r\n        uint256 wAmount = amount;\r\n\r\n        if (tokenAddress == ZERO) {\r\n            if (amount == 0) {\r\n                wAmount = address(this).balance;\r\n            }\r\n            require(wAmount <= address(this).balance, \"WithdrawTokens: Insufficient balance.\");\r\n            payable(msg.sender).transfer(wAmount);\r\n            return;\r\n        }\r\n\r\n        if (amount == 0) {\r\n            if (IERC20(tokenAddress) == REWARD) {\r\n                wAmount = amountToRedistribute;\r\n            } else {\r\n                wAmount = IERC20(tokenAddress).balanceOf(address(this));\r\n            }\r\n        }\r\n\r\n        if (IERC20(tokenAddress) == REWARD) {\r\n            require(wAmount <= amountToRedistribute, \"WithdrawTokens: Insufficient balance to redistribute.\");\r\n            amountToRedistribute -= wAmount;\r\n            emit RewardRescued(amountToRedistribute, wAmount, msg.sender, block.timestamp);\r\n        }\r\n        require(wAmount <= IERC20(tokenAddress).balanceOf(address(this)), \"WithdrawTokens: Insufficient balance.\");\r\n        \r\n        require(\r\n            IERC20(tokenAddress).transfer(\r\n                msg.sender,\r\n                wAmount\r\n            ),\r\n            \"WithdrawTokens: Transfer transaction might fail.\"\r\n        );\r\n    }\r\n\r\n    /* Internal */\r\n\r\n    function _handleDistribution(address staker) internal returns (uint256) {\r\n        uint256 unpaidEarning = 0;\r\n        uint256 totalUserStakes = userStaking[staker];\r\n\r\n        if (userStaking[staker] > 0 && rewardPools.length > 0) {\r\n            for (uint256 i = 1; i <= totalUserStakes; i++) {\r\n                for (uint256 j = 1; j <= rewardPools.length; j++) {\r\n                    if (\r\n                        userStakes[staker][i].amount > 0 &&\r\n                        userStakes[staker][i].startPoolIndex <= j &&\r\n                        rewardPools[j - 1].amountAdded > rewardPools[j - 1].amountClaimed\r\n                    ) {\r\n                        unpaidEarning += _calculateEarnings(staker, i, j);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return unpaidEarning;\r\n    }\r\n\r\n    function _calculateEarnings(address staker, uint256 stakeId, uint256 poolId) internal returns (uint256) {\r\n        uint256 unpaidEarningRaw = getUnpaidEarnings(staker, stakeId, poolId);\r\n        uint256 unpaid = getStakeTypeSpecificUnpaidEarnings(staker, stakeId, poolId);\r\n        uint256 unpaidEarningRedistribute = unpaidEarningRaw - unpaid;\r\n        amountToRedistribute += unpaidEarningRedistribute;\r\n        userStakes[staker][stakeId].totalRealised += unpaid;\r\n        userStakes[staker][stakeId].totalExcluded = getCumulativeRewards(userStakes[staker][stakeId].amount, poolId);\r\n        rewardPools[poolId - 1].amountClaimed += unpaid;\r\n        return unpaid;\r\n    }\r\n\r\n    function _handleDeposits(uint256 amount) internal {\r\n        address[] memory path = new address[](2);\r\n        path[0] = router.WETH();\r\n        path[1] = address(REWARD);\r\n\r\n        uint256 initialRewardBalance = REWARD.balanceOf(address(this));\r\n        \r\n        router.swapExactETHForTokensSupportingFeeOnTransferTokens {\r\n            value: amount\r\n        } (0, path, address(this), block.timestamp);\r\n        \r\n        uint256 added = REWARD.balanceOf(address(this)) - initialRewardBalance;\r\n        _updateRewardInfo(added);\r\n    }\r\n\r\n    function _updateRewardInfo(uint256 added) internal {\r\n        if (added > 0) {\r\n            totalRewards += added;\r\n            rewardsPerStake += rewardsPerStakeAccuracyFactor * added / totalStaked;\r\n            currentPoolIndex += 1;\r\n            RewardPool memory newPool = RewardPool({\r\n                id: currentPoolIndex,\r\n                amountAdded: added,\r\n                amountClaimed: 0,\r\n                rewardsPerStake: rewardsPerStake,\r\n                timestamp: block.timestamp\r\n            });\r\n            rewardPools.push(newPool);\r\n        }\r\n    }\r\n\r\n    function _addStaker(address staker) internal {\r\n        stakerIndexes[staker] = stakers.length;\r\n        stakers.push(staker);\r\n    }\r\n    \r\n    function _removeStaker(address staker) internal {\r\n        if (stakers.length > 1) {\r\n            stakers[stakerIndexes[staker]] = stakers[stakers.length - 1];\r\n            stakerIndexes[stakers[stakers.length - 1]] = stakerIndexes[staker];\r\n        }\r\n        stakers.pop();\r\n    }\r\n\r\n    function _verifyPoolID(uint256 poolId) internal view {\r\n        if (poolId <= 0) { revert InvalidValue(poolId); }\r\n        if (poolId > rewardPools.length) { revert InvalidRewardPoolId(); }\r\n    }\r\n\r\n    function _verifyStakeID(address staker, uint256 stakeId) internal view {\r\n        if (stakeId <= 0) { revert InvalidValue(stakeId); }\r\n        if (stakeId > userStaking[staker]) { revert ExceedUserStakeId(userStaking[staker]); }\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"routerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"penaltyReceiverAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"current\",\"type\":\"address\"}],\"name\":\"CannotUseCurrentAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"current\",\"type\":\"bool\"}],\"name\":\"CannotUseCurrentState\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"current\",\"type\":\"uint256\"}],\"name\":\"CannotUseCurrentValue\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"CurrentAuthorizedState\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EmergencyWithdrawDisabled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EnforcedPause\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"ExceedStakeBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxRange\",\"type\":\"uint256\"}],\"name\":\"ExceedStakeTypeRange\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"ExceedStuckedBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxIdValue\",\"type\":\"uint256\"}],\"name\":\"ExceedUserStakeId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExpectedPause\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"invalid\",\"type\":\"address\"}],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"InvalidAuthorizedAccount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"InvalidOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRewardPoolId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidStakeId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"invalid\",\"type\":\"uint256\"}],\"name\":\"InvalidValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoStakingRewards\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"unstakeTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeNow\",\"type\":\"uint256\"}],\"name\":\"NotTimeToUnstake\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"UnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"distributed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"RewardDistribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"distributed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"RewardRescued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"authorizedAccount\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"UpdateAuthorizedAccount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"oldState\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"newState\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"UpdateEmergencyWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldPenalty\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPenalty\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"UpdatePenalty\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldReceiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newReceiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"UpdatePenaltyReceiver\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IRouter\",\"name\":\"oldRouter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract IRouter\",\"name\":\"newRouter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"UpdateRouter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"oldState\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"newState\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"UpdateTakePenalty\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DENOMINATOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REWARD\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN\",\"outputs\":[{\"internalType\":\"contract IWDYM\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"name\":\"addStakeType\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amountToRedistribute\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorization\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAllRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentPoolIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositBUSD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositStuckedBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositStuckedBUSD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"emergencyWithdrawStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"getCumulativeRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLeaderboard\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"internalType\":\"struct IStaking.Leaderboard[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakeTypeRewardMaxRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"getStakeTypeSpecificUnpaidEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"getUnpaidEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getUserTotalUnpaidEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isWDYMStaking\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"name\":\"modifyStakeType\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"penaltyPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"penaltyReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"removeStakeType\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardPools\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAdded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountClaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardsPerStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsPerStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsPerStakeAccuracyFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeTypeId\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakeTypeToDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakerIndexes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"takePenalty\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"unauthorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeId\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"newState\",\"type\":\"bool\"}],\"name\":\"updateEmergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPenalty\",\"type\":\"uint256\"}],\"name\":\"updatePenalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newReceiver\",\"type\":\"address\"}],\"name\":\"updatePenaltyReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IRouter\",\"name\":\"newRouter\",\"type\":\"address\"}],\"name\":\"updateRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"newState\",\"type\":\"bool\"}],\"name\":\"updateTakePenalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userActiveStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInactiveStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userStakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startPoolIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalExcluded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRealised\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userTotalStakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"wTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "WhatDoYouMemeStaking", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "9999", "ConstructorArguments": "00000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e0000000000000000000000000603ac447682a1a3537d2c396d7eb86d0b3e225b", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://34c13e5141bdf15b8a0f6f3583be181cbc86b721e3b3777c6e1824cf188a1728"}