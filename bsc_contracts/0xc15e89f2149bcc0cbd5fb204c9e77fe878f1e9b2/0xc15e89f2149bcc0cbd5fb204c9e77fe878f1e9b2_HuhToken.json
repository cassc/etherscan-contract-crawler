{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.4;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _setOwner(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// CAUTION\r\n// This version of SafeMath should only be used with Solidity 0.8 or later,\r\n// because it relies on the compiler's built in overflow checks.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface of the BEP20 standard as defined in the EIP.\r\n */\r\ninterface IBEP20 {\r\n    function name() external pure returns (string memory);\r\n\r\n    function symbol() external pure returns (string memory);\r\n\r\n    function decimals() external pure returns (uint8);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IRewardDistributor {\r\n    function addRewardHolderShare(address rewardRecipient, uint256 amount) external;\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\n\r\ncontract HuhToken is Context, IBEP20, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    string private constant _NAME = \"HUH_Token\";\r\n    string private constant _SYMBOL = \"HUH\";\r\n    uint8 private constant _DECIMALS = 9;\r\n\r\n    uint256 private constant _MAX = ~uint256(0);\r\n    uint256 private constant _tTotal = 888 * 10 ** 9 * ( 10** _DECIMALS); // 888 Billion HuhToken\r\n    uint256 private _rTotal = (_MAX - (_MAX % _tTotal));\r\n    uint256 private _tFeeTotal;\r\n\r\n    uint8 public referralReward = 10;\r\n\r\n    uint8 public liquidityFeeOnBuy = 5;\r\n    uint8 public marketingFeeOnBuy = 5;\r\n    uint8 public HuHdistributionFeeOnBuy = 5;\r\n    // Total of 15%\r\n\r\n    uint8 public liquidityFeeOnWhiteListedBuy = 0;\r\n    uint8 public marketingFeeOnBuyWhiteListed = 5;\r\n    uint8 public HuHdistributionFeeOnBuyWhiteListed = 0;\r\n    // Total of 15% (taking in referralReward)\r\n\r\n    uint8 public liquidityFeeOnSell = 10;\r\n    uint8 public marketingFeeOnSell = 5;\r\n    uint8 public HuHdistributionFeeOnSell = 5;\r\n    // Total of 20%\r\n\r\n    uint8 public liquidityFeeOnWhiteListedSell = 25; // In the power of 1000 => 2.5%\r\n    uint8 public marketingFeeOnWhiteListedSell = 50; // In the power of 1000 => 5%\r\n    uint8 public HuHdistributionFeeOnWhiteListedSell = 25; // In the power of 1000 => 2.5%\r\n    // Total of 10%\r\n\r\n    uint256 public launchedAt;\r\n\r\n    // State data for statistical purposes ONLY\r\n    uint256 private referralCount;\r\n    uint256 private totalReferralReward;\r\n    mapping(address => uint256) private userReferralCount;\r\n    mapping(address => uint256) private userReferralReward;\r\n\r\n    address public referralCodeRegistrator;  // Address who allowed to register code for users (will be used later)\r\n    address public marketingWallet;\r\n    address private constant _DEAD_ADDRESS = 0x000000000000000000000000000000000000dEaD;\r\n\r\n    mapping(address => uint256) private _rOwned;\r\n    mapping(address => uint256) private _tOwned;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    mapping(address => bool) private _isExcludedFromFee;\r\n    mapping(address => bool) private _isExcluded;\r\n    address[] private _excluded;\r\n\r\n    mapping(address => bytes) public referCodeForUser;\r\n    mapping(bytes => address) public referUserForCode;\r\n    mapping(address => address) public referParent;\r\n    mapping(address => address[]) public referralList;\r\n    mapping(address => bool) public isWhitelisted;\r\n    mapping(address => bool) public isFirstBuy;\r\n\r\n    IUniswapV2Router02 public pcsV2Router;\r\n    address public pcsV2Pair;\r\n\r\n    IRewardDistributor public rewardDistributor;\r\n\r\n    uint256 public maxTxAmount = _tTotal.mul(1).div(10**2); // 1% of total supply\r\n    uint256 public amountOfTokensToAddToLiquidityThreshold = maxTxAmount.mul(10).div(10**2); // 10% of max transaction amount\r\n\r\n    bool public swapAndLiquifyEnabled = true;\r\n    bool private _inSwap;\r\n    modifier swapping() {\r\n        _inSwap = true;\r\n        _;\r\n        _inSwap = false;\r\n    }\r\n\r\n    event UserWhitelisted(address indexed account, address indexed referee);\r\n    event RegisterCode(address indexed account, bytes indexed code);\r\n    event SwapAndLiquify(uint256 indexed ethReceived, uint256 indexed tokensIntoLiqudity);\r\n    event UpdatePancakeSwapRouter(address indexed pcsV2Router);\r\n    event UpdateRewardDistributor(address indexed newRewardDistributor);\r\n    event UpdateSwapAndLiquifyEnabled(bool indexed swapAndLiquifyEnabled);\r\n    event ExcludeFromReflection(address indexed account);\r\n    event IncludeInReflection(address indexed account);\r\n    event SetIsExcludedFromFee(address indexed account, bool indexed flag);\r\n    event ChangeFeesForNormalBuy(uint8 indexed liquidityFeeOnBuy, uint8 indexed marketingFeeOnBuy, uint8 indexed HuHdistributionFeeOnBuy);\r\n    event ChangeFeesForWhiteListedBuy(uint8 indexed liquidityFeeOnBuy, uint8 indexed marketingFeeOnBuy, uint8 indexed HuHdistributionFeeOnBuy);\r\n    event ChangeFeesForNormalSell(uint8 indexed liquidityFeeOnSell, uint8 indexed marketingFeeOnSell, uint8 indexed HuHdistributionFeeOnSell);\r\n    event ChangeFeesForWhitelistedSell(uint8 indexed liquidityFeeOnSell, uint8 indexed marketingFeeOnSell, uint8 indexed HuHdistributionFeeOnSell);\r\n    event ChangeReferralReward(uint8 indexed referralReward);\r\n    event UpdateMarketingWallet(address indexed marketingWallet);\r\n    event SetReferralCodeRegistrator(address indexed referralCodeRegistrator);\r\n    event UpdateAmountOfTokensToAddToLiquidityThreshold(uint256 indexed amountOfTokensToAddToLiquidityThreshold);\r\n    event SetMaxTxPercent(uint256 indexed maxTxPercent);\r\n\r\n    constructor() {\r\n        IUniswapV2Router02 _pancakeswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n\r\n        pcsV2Pair = IUniswapV2Factory(_pancakeswapV2Router.factory()).createPair(address(this), _pancakeswapV2Router.WETH());\r\n        pcsV2Router = _pancakeswapV2Router;\r\n        _allowances[address(this)][address(pcsV2Router)] = _MAX;\r\n\r\n        rewardDistributor = IRewardDistributor(0x1529B357C8559Da530c6f26e80fB3Ae16258c1eb);\r\n        _allowances[address(this)][address(rewardDistributor)] = _MAX;\r\n        _allowances[address(rewardDistributor)][address(pcsV2Router)] = _MAX;\r\n\r\n        marketingWallet = 0x783f51eF9Ac932B323dDb26701aD7897315a2cD5;\r\n\r\n        _rOwned[msg.sender] = _rTotal;\r\n        _isExcludedFromFee[msg.sender] = true;\r\n        _isExcludedFromFee[address(this)] = true;\r\n        _isExcludedFromFee[address(rewardDistributor)] = true;\r\n        _isExcludedFromFee[marketingWallet] = true;\r\n        _excludeFromReflection(address(rewardDistributor));\r\n        _excludeFromReflection(marketingWallet);\r\n\r\n        emit Transfer(address(0), msg.sender, _tTotal);\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    fallback() external payable {}\r\n\r\n    // Back-Up withdraw, in case BNB gets sent in here\r\n    // NOTE: This function is to be called if and only if BNB gets sent into this contract. \r\n    // On no other occurence should this function be called. \r\n    function withdrawEthInWei(address payable recipient, uint256 amount) external onlyOwner {\r\n        require(recipient != address(0), 'Invalid Recipient!');\r\n        require(amount > 0, 'Invalid Amount!');\r\n        recipient.transfer(amount);\r\n    }\r\n\r\n    // Withdraw BEP20 tokens sent to this contract\r\n    // NOTE: This function is to be called if and only if BEP20 tokens gets sent into this contract. \r\n    // On no other occurence should this function be called. \r\n    function withdrawTokens(address token, address recipient) external onlyOwner {\r\n        require(token != address(0), 'Invalid Token!');\r\n        require(recipient != address(0), 'Invalid Recipient!');\r\n\r\n        uint256 balance = IBEP20(token).balanceOf(address(this));\r\n        if (balance > 0) {\r\n            require(IBEP20(token).transfer(recipient, balance), \"Transfer Failed\");\r\n        }\r\n    }\r\n\r\n    //  -----------------------------\r\n    //  SETTERS (PROTECTED)\r\n    //  -----------------------------\r\n    function excludeFromReflection(address account) external onlyOwner {\r\n        _excludeFromReflection(account);\r\n        emit ExcludeFromReflection(account);\r\n    }\r\n\r\n    function includeInReflection(address account) external onlyOwner {\r\n        _includeInReflection(account);\r\n        emit IncludeInReflection(account);\r\n    }\r\n\r\n    function setIsExcludedFromFee(address account, bool flag) external onlyOwner {\r\n        _setIsExcludedFromFee(account, flag);\r\n        emit SetIsExcludedFromFee(account, flag);\r\n    }\r\n\r\n    function changeFeesForNormalBuy(uint8 _liquidityFeeOnBuy, uint8 _marketingFeeOnBuy, uint8 _HuHdistributionFeeOnBuy) external onlyOwner {\r\n        require(_liquidityFeeOnBuy < 100, \"Fee should be less than 100!\");\r\n        require(_marketingFeeOnBuy < 100, \"Fee should be less than 100!\");\r\n        require(_HuHdistributionFeeOnBuy < 100, \"Fee should be less than 100!\");\r\n        liquidityFeeOnBuy = _liquidityFeeOnBuy;\r\n        marketingFeeOnBuy = _marketingFeeOnBuy;\r\n        HuHdistributionFeeOnBuy = _HuHdistributionFeeOnBuy;\r\n        emit ChangeFeesForNormalBuy(_liquidityFeeOnBuy, _marketingFeeOnBuy, _HuHdistributionFeeOnBuy);\r\n    }\r\n\r\n    function changeFeesForWhiteListedBuy(uint8 _liquidityFeeOnBuy, uint8 _marketingFeeOnBuy, uint8 _HuHdistributionFeeOnBuy) external onlyOwner {\r\n        require(_liquidityFeeOnBuy < 100, \"Fee should be less than 100!\");\r\n        require(_marketingFeeOnBuy < 100, \"Fee should be less than 100!\");\r\n        require(_HuHdistributionFeeOnBuy < 100, \"Fee should be less than 100!\");\r\n        liquidityFeeOnWhiteListedBuy = _liquidityFeeOnBuy;\r\n        marketingFeeOnBuyWhiteListed = _marketingFeeOnBuy;\r\n        HuHdistributionFeeOnBuyWhiteListed = _HuHdistributionFeeOnBuy;\r\n        emit ChangeFeesForWhiteListedBuy(_liquidityFeeOnBuy, _marketingFeeOnBuy, _HuHdistributionFeeOnBuy);\r\n    }\r\n\r\n    function changeFeesForNormalSell(uint8 _liquidityFeeOnSell, uint8 _marketingFeeOnSell, uint8 _HuHdistributionFeeOnSell) external onlyOwner {\r\n        require(_liquidityFeeOnSell < 100, \"Fee should be less than 100!\");\r\n        require(_marketingFeeOnSell < 100, \"Fee should be less than 100!\");\r\n        require(_HuHdistributionFeeOnSell < 100, \"Fee should be less than 100!\");\r\n        liquidityFeeOnSell = _liquidityFeeOnSell;\r\n        marketingFeeOnSell = _marketingFeeOnSell;\r\n        HuHdistributionFeeOnSell = _HuHdistributionFeeOnSell;\r\n        emit ChangeFeesForNormalSell(_liquidityFeeOnSell, _marketingFeeOnSell, _HuHdistributionFeeOnSell);\r\n    }\r\n\r\n\r\n    // NOTE: The values should always be in the power of 1000. So if the required percentage if 6%, the value will be 60, etc...\r\n    function changeFeesForWhitelistedSell(uint8 _liquidityFeeOnSell, uint8 _marketingFeeOnSell, uint8 _HuHdistributionFeeOnSell) external onlyOwner {\r\n        require(_liquidityFeeOnSell < 1000, \"Fee should be less than 100!\");\r\n        require(_marketingFeeOnSell < 1000, \"Fee should be less than 100!\");\r\n        require(_HuHdistributionFeeOnSell < 1000, \"Fee should be less than 100!\");\r\n        liquidityFeeOnWhiteListedSell = _liquidityFeeOnSell;\r\n        marketingFeeOnWhiteListedSell = _marketingFeeOnSell;\r\n        HuHdistributionFeeOnWhiteListedSell = _HuHdistributionFeeOnSell;\r\n        emit ChangeFeesForWhitelistedSell(_liquidityFeeOnSell, _marketingFeeOnSell, _HuHdistributionFeeOnSell);\r\n    }\r\n\r\n    function changeReferralReward(uint8 _referralReward) external onlyOwner {\r\n        referralReward = _referralReward;\r\n        emit ChangeReferralReward(_referralReward);\r\n    }\r\n\r\n    function updateMarketingWallet(address _marketingWallet) external onlyOwner {\r\n        require(_marketingWallet != address(0), \"Zero address not allowed!\");\r\n        _isExcludedFromFee[marketingWallet] = false;\r\n        marketingWallet = _marketingWallet;\r\n        _isExcludedFromFee[marketingWallet] = true;\r\n        _excludeFromReflection(marketingWallet);\r\n        emit UpdateMarketingWallet(_marketingWallet);\r\n    }\r\n\r\n    function setReferralCodeRegistrator(address _referralCodeRegistrator) external onlyOwner {\r\n        require(_referralCodeRegistrator != address(0), \"setReferralCodeRegistrator: Zero address not allowed!\");\r\n        referralCodeRegistrator = _referralCodeRegistrator;\r\n        emit SetReferralCodeRegistrator(_referralCodeRegistrator);\r\n    }\r\n\r\n    function updateAmountOfTokensToAddToLiquidityThreshold(uint256 _amountOfTokensToAddToLiquidityThreshold) external onlyOwner {\r\n        amountOfTokensToAddToLiquidityThreshold = _amountOfTokensToAddToLiquidityThreshold * (10 ** _DECIMALS);\r\n        emit UpdateAmountOfTokensToAddToLiquidityThreshold(_amountOfTokensToAddToLiquidityThreshold);\r\n    }\r\n\r\n    function updatePancakeSwapRouter(address _pcsV2Router) external onlyOwner {\r\n        require(_pcsV2Router != address(0), 'PancakeSwap Router Invalid!');\r\n        require(address(pcsV2Router) != _pcsV2Router, 'PancakeSwap Router already exists!');\r\n        _allowances[address(this)][address(pcsV2Router)] = 0; // Set Allowance to 0\r\n        _allowances[address(rewardDistributor)][address(pcsV2Router)] = 0; // Set Allowance to 0\r\n        pcsV2Router = IUniswapV2Router02(_pcsV2Router);\r\n        pcsV2Pair = IUniswapV2Factory(pcsV2Router.factory()).createPair(address(this), pcsV2Router.WETH());\r\n        _allowances[address(this)][address(pcsV2Router)] = _MAX;\r\n        _allowances[address(rewardDistributor)][address(pcsV2Router)] = _MAX;\r\n        emit UpdatePancakeSwapRouter(_pcsV2Router);\r\n    }\r\n\r\n    function updateRewardDistributor(address _rewardDistributor) external onlyOwner {\r\n        require(address(rewardDistributor) != _rewardDistributor, 'Reward Distributor already exists!');\r\n        _isExcludedFromFee[address(rewardDistributor)] = false;\r\n        _allowances[address(this)][address(rewardDistributor)] = 0; // Set Allowance to 0\r\n        _allowances[address(rewardDistributor)][address(pcsV2Router)] = 0; // Set Allowance to 0\r\n        rewardDistributor = IRewardDistributor(_rewardDistributor);\r\n        _allowances[address(this)][address(rewardDistributor)] = _MAX;\r\n        _allowances[address(rewardDistributor)][address(pcsV2Router)] = _MAX;\r\n        _isExcludedFromFee[address(rewardDistributor)] = true;\r\n        _excludeFromReflection(address(rewardDistributor));\r\n        emit UpdateRewardDistributor(_rewardDistributor);\r\n    }\r\n\r\n    function updateSwapAndLiquifyEnabled(bool _swapAndLiquifyEnabled) external onlyOwner {\r\n        require(swapAndLiquifyEnabled != _swapAndLiquifyEnabled, 'Value already exists!');\r\n        swapAndLiquifyEnabled = _swapAndLiquifyEnabled;\r\n        emit UpdateSwapAndLiquifyEnabled(_swapAndLiquifyEnabled);\r\n    }\r\n\r\n    function setMaxTxPercent(uint256 maxTxPercent) external onlyOwner {\r\n        maxTxAmount = _tTotal.mul(maxTxPercent).div(10**2);\r\n        emit SetMaxTxPercent(maxTxPercent);\r\n    }\r\n\r\n    function registerCodeForOwner(address account, string memory code) external {\r\n        require(msg.sender == referralCodeRegistrator || msg.sender == owner(), \"Not autorized!\");\r\n\r\n        bytes memory code_ = bytes(code);\r\n        require(code_.length > 0, \"Invalid code!\");\r\n        require(referUserForCode[code_] == address(0), \"Code already used!\");\r\n        require(referCodeForUser[account].length == 0, \"User already generated code!\");\r\n\r\n        _registerCode(account, code_);\r\n    }\r\n\r\n    function registerCode(string memory code) external {\r\n        bytes memory code_ = bytes(code);\r\n        require(code_.length > 0, \"Invalid code!\");\r\n        require(referUserForCode[code_] == address(0), \"Code already used!\");\r\n        require(referCodeForUser[msg.sender].length == 0, \"User already generated code!\");\r\n\r\n        _registerCode(msg.sender, code_);\r\n    }\r\n\r\n    //  -----------------------------\r\n    //  SETTERS\r\n    //  -----------------------------\r\n    function whitelist(string memory refCode) external {\r\n        bytes memory refCode_ = bytes(refCode);\r\n        require(refCode_.length > 0, \"Invalid code!\");\r\n        require(!isWhitelisted[msg.sender], \"Already whitelisted!\");\r\n        require(referUserForCode[refCode_] != address(0), \"Non used code!\");\r\n        require(referUserForCode[refCode_] != msg.sender, \"Invalid code, A -> A refer!\");\r\n        require(referParent[referUserForCode[refCode_]] != msg.sender, \"Invalid code, A -> B -> A refer!\");\r\n\r\n        _whitelistWithRef(msg.sender, referUserForCode[refCode_]);\r\n        referralCount = referralCount.add(1);\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) external override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(\r\n            sender,\r\n            _msgSender(),\r\n            _allowances[sender][_msgSender()].sub(amount, \"BEP20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) external virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual returns (bool) {\r\n        _approve(\r\n            _msgSender(),\r\n            spender,\r\n            _allowances[_msgSender()][spender].sub(subtractedValue, \"BEP20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    //  -----------------------------\r\n    //  GETTERS\r\n    //  -----------------------------\r\n    function name() external pure override returns (string memory) {\r\n        return _NAME;\r\n    }\r\n\r\n    function symbol() external pure override returns (string memory) {\r\n        return _SYMBOL;\r\n    }\r\n\r\n    function decimals() external pure override returns (uint8) {\r\n        return _DECIMALS;\r\n    }\r\n\r\n    function totalSupply() external pure override returns (uint256) {\r\n        return _tTotal;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        if (_isExcluded[account]) return _tOwned[account];\r\n        return tokenFromReflection(_rOwned[account]);\r\n    }\r\n\r\n    function allowance(address owner, address spender) external view override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function isExcludedFromReflection(address account) external view returns (bool) {\r\n        return _isExcluded[account];\r\n    }\r\n\r\n    function totalFees() external view returns (uint256) {\r\n        return _tFeeTotal;\r\n    }\r\n\r\n    function reflectionFromToken(uint256 tAmount) public view returns (uint256) {\r\n        uint256 rAmount = tAmount.mul(_getRate());\r\n        return rAmount;\r\n    }\r\n\r\n    function tokenFromReflection(uint256 rAmount) public view returns (uint256) {\r\n        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\r\n        uint256 currentRate = _getRate();\r\n        return rAmount.div(currentRate);\r\n    }\r\n\r\n    function getTotalCommunityReflection() external view returns (uint256) {\r\n        return _tFeeTotal;\r\n    }\r\n\r\n    function getTotalNumberOfCommunityReferral() external view returns (uint256) {\r\n        return referralCount;\r\n    }\r\n\r\n    function getTotalCommunityReferralReward() external view returns (uint256) {\r\n        return totalReferralReward;\r\n    }\r\n\r\n    function getReferralList(address account) external view returns (address[] memory) {\r\n        return referralList[account];\r\n    }\r\n\r\n    function getTotalNumberOfUserReferral(address account) external view returns (uint256) {\r\n        return userReferralCount[account];\r\n    }\r\n\r\n    function getTotalUserReferralReward(address account) external view returns (uint256) {\r\n        return userReferralReward[account];\r\n    }\r\n\r\n\r\n    //  -----------------------------\r\n    //  INTERNAL\r\n    //  -----------------------------\r\n    function _getRate() private view returns (uint256) {\r\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\r\n        return rSupply.div(tSupply);\r\n    }\r\n\r\n    function _getCurrentSupply() private view returns (uint256, uint256) {\r\n        uint256 rSupply = _rTotal;\r\n        uint256 tSupply = _tTotal;\r\n        for (uint256 i = 0; i < _excluded.length; i++) {\r\n            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply)\r\n                return (_rTotal, _tTotal);\r\n\r\n            rSupply = rSupply.sub(_rOwned[_excluded[i]]);\r\n            tSupply = tSupply.sub(_tOwned[_excluded[i]]);\r\n        }\r\n\r\n        if (rSupply < _rTotal.div(_tTotal)) {\r\n            return (_rTotal, _tTotal);\r\n        }\r\n\r\n        return (rSupply, tSupply);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) private {\r\n        require(owner != address(0), \"BEP20: approve from the zero address\");\r\n        require(spender != address(0), \"BEP20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) private {\r\n        require(sender != address(0), \"BEP20: transfer from the zero address\");\r\n        require(recipient != address(0), \"BEP20: transfer to the zero address\");\r\n        require(amount > 0, \"BEP20: Transfer amount must be greater than zero\");\r\n\r\n        if(sender != owner() && recipient != owner())\r\n            require(amount <= maxTxAmount, \"Transfer amount exceeds the maxTxAmount\");\r\n\r\n        if (_inSwap) {\r\n            _basicTransfer(sender, recipient, amount);\r\n            return;\r\n        }\r\n\r\n        if (_shouldSwapBack())\r\n            _swapAndAddToLiquidity();\r\n\r\n        if (_isExcludedFromFee[sender] || _isExcludedFromFee[recipient]) {\r\n            _basicTransfer(sender, recipient, amount);\r\n        } else {\r\n            if (recipient == pcsV2Pair) {\r\n                if (isWhitelisted[sender]) {\r\n                    _whitelistedSell(sender, recipient, amount);\r\n                } else {\r\n                    _normalSell(sender, recipient, amount);\r\n                }\r\n            } else if (sender == pcsV2Pair) {\r\n                if (isWhitelisted[recipient] && isFirstBuy[recipient]) {\r\n                    _whitelistedBuy(sender, recipient, amount);\r\n                    isFirstBuy[recipient] = false;\r\n                } else {\r\n                    _normalBuy(sender, recipient, amount);\r\n                }\r\n            } else {\r\n                _basicTransfer(sender, recipient, amount);\r\n            }\r\n        }\r\n\r\n        if (launchedAt == 0 && recipient == pcsV2Pair) {\r\n            launchedAt = block.number;\r\n        }\r\n    }\r\n\r\n    function _basicTransfer(address sender, address recipient, uint256 amount) private {\r\n        uint256 rAmount = reflectionFromToken(amount);\r\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n        _rOwned[recipient] = _rOwned[recipient].add(rAmount);\r\n        if (_isExcluded[sender]) _tOwned[sender] = _tOwned[sender].sub(amount);\r\n        if (_isExcluded[recipient]) _tOwned[recipient] = _tOwned[recipient].add(amount);\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _normalBuy(address sender, address recipient, uint256 amount) private {\r\n        uint256 currentRate = _getRate();\r\n        uint256 rAmount = amount.mul(currentRate);\r\n        uint256 rLiquidityFee = amount.mul(liquidityFeeOnBuy).mul(currentRate).div(100);\r\n        uint256 rHuhdistributionFee = amount.mul(HuHdistributionFeeOnBuy).mul(currentRate).div(100);\r\n        uint256 rMarketingFee = amount.mul(marketingFeeOnBuy).mul(currentRate).div(100);\r\n        uint256 rTransferAmount = rAmount.sub(rLiquidityFee).sub(rHuhdistributionFee).sub(rMarketingFee);\r\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\r\n        _rOwned[address(this)] = _rOwned[address(this)].add(rLiquidityFee);\r\n        if (_isExcluded[sender]) _tOwned[sender] = _tOwned[sender].sub(amount);\r\n        if (_isExcluded[recipient]) _tOwned[recipient] = _tOwned[recipient].add(rTransferAmount.div(currentRate));\r\n        if (_isExcluded[address(this)]) _tOwned[address(this)] = _tOwned[address(this)].add(rLiquidityFee.div(currentRate));\r\n\r\n        emit Transfer(sender, recipient, rTransferAmount.div(currentRate));\r\n        emit Transfer(sender, address(this), (rLiquidityFee).div(currentRate));\r\n\r\n        _sendToMarketingWallet(sender, rMarketingFee.div(currentRate), rMarketingFee);\r\n        _reflectFee(rHuhdistributionFee, rHuhdistributionFee.div(currentRate));\r\n    }\r\n\r\n    function _whitelistedBuy(address sender, address recipient, uint256 amount) private {\r\n        uint256 currentRate = _getRate();\r\n        uint256 rAmount = amount.mul(currentRate);\r\n        uint256 tReferralRewardAmount = amount.mul(referralReward).div(100);\r\n        uint256 rReferralRewardAmount = tReferralRewardAmount.mul(currentRate);\r\n        uint256 rLiquidityFee = amount.mul(liquidityFeeOnWhiteListedBuy).mul(currentRate).div(100);\r\n        uint256 rHuhdistributionFee = amount.mul(HuHdistributionFeeOnBuyWhiteListed).mul(currentRate).div(100);\r\n        uint256 rMarketingFee = amount.mul(marketingFeeOnBuyWhiteListed).mul(currentRate).div(100);\r\n        uint256 rTransferAmount = rAmount.sub(rReferralRewardAmount).sub(rLiquidityFee).sub(rHuhdistributionFee).sub(rMarketingFee);\r\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\r\n        _rOwned[address(this)] = _rOwned[address(this)].add(rLiquidityFee);\r\n\r\n        if (_isExcluded[sender]) _tOwned[sender] = _tOwned[sender].sub(amount);\r\n        if (_isExcluded[recipient]) _tOwned[recipient] = _tOwned[recipient].add(rTransferAmount.div(currentRate));\r\n        if (_isExcluded[address(this)]) _tOwned[address(this)] = _tOwned[address(this)].add(rLiquidityFee.div(currentRate));\r\n\r\n        emit Transfer(sender, recipient, rTransferAmount.div(currentRate));\r\n        emit Transfer(sender, address(this), rLiquidityFee.div(currentRate));\r\n        \r\n        _sendToRewardDistributor(sender, referParent[recipient], tReferralRewardAmount, rReferralRewardAmount);\r\n        _sendToMarketingWallet(sender, rMarketingFee.div(currentRate), rMarketingFee);\r\n        _reflectFee(rHuhdistributionFee, rHuhdistributionFee.div(currentRate));\r\n    }\r\n\r\n    function _normalSell(address sender, address recipient, uint256 amount) private {\r\n        uint256 currentRate = _getRate();\r\n        uint256 rAmount = amount.mul(currentRate);\r\n        uint256 rLiquidityFee = amount.mul(liquidityFeeOnSell).mul(currentRate).div(100);\r\n        uint256 rHuhdistributionFee = amount.mul(HuHdistributionFeeOnSell).mul(currentRate).div(100);\r\n        uint256 rMarketingFee = amount.mul(marketingFeeOnSell).mul(currentRate).div(100);\r\n        uint256 rTransferAmount = rAmount.sub(rLiquidityFee).sub(rHuhdistributionFee).sub(rMarketingFee);\r\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\r\n        _rOwned[address(this)] = _rOwned[address(this)].add(rLiquidityFee);\r\n        if (_isExcluded[sender]) _tOwned[sender] = _tOwned[sender].sub(amount);\r\n        if (_isExcluded[recipient]) _tOwned[recipient] = _tOwned[recipient].add(rTransferAmount.div(currentRate));\r\n        if (_isExcluded[address(this)]) _tOwned[address(this)] = _tOwned[address(this)].add(rLiquidityFee.div(currentRate));\r\n\r\n        emit Transfer(sender, recipient, rTransferAmount.div(currentRate));\r\n        emit Transfer(sender, address(this), rLiquidityFee.div(currentRate));\r\n\r\n        _sendToMarketingWallet(sender, rMarketingFee.div(currentRate), rMarketingFee);\r\n        _reflectFee(rHuhdistributionFee, rHuhdistributionFee.div(currentRate));\r\n    }\r\n\r\n    function _whitelistedSell(address sender, address recipient, uint256 amount) private {\r\n        uint256 currentRate = _getRate();\r\n        uint256 rAmount = amount.mul(currentRate);\r\n        uint256 rLiquidityFee = amount.mul(liquidityFeeOnWhiteListedSell).mul(currentRate).div(1000);\r\n        uint256 rHuhdistributionFee = amount.mul(HuHdistributionFeeOnWhiteListedSell).mul(currentRate).div(1000);\r\n        uint256 rMarketingFee = amount.mul(marketingFeeOnWhiteListedSell).mul(currentRate).div(1000);\r\n        uint256 rTransferAmount = rAmount.sub(rLiquidityFee).sub(rHuhdistributionFee).sub(rMarketingFee);\r\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\r\n        _rOwned[address(this)] = _rOwned[address(this)].add(rLiquidityFee);\r\n        if (_isExcluded[sender]) _tOwned[sender] = _tOwned[sender].sub(amount);\r\n        if (_isExcluded[recipient]) _tOwned[recipient] = _tOwned[recipient].add(rTransferAmount.div(currentRate));\r\n        if (_isExcluded[address(this)]) _tOwned[address(this)] = _tOwned[address(this)].add(rLiquidityFee.div(currentRate));\r\n\r\n        emit Transfer(sender, recipient, rTransferAmount.div(currentRate));\r\n        emit Transfer(sender, address(this), rLiquidityFee.div(currentRate));\r\n\r\n        _sendToMarketingWallet(sender, rMarketingFee.div(currentRate), rMarketingFee);\r\n        _reflectFee(rHuhdistributionFee, rHuhdistributionFee.div(currentRate));\r\n    }\r\n\r\n    function _sendToRewardDistributor(address sender, address rewardRecipient, uint256 tAmount, uint256 rAmount) private {\r\n        _rOwned[address(rewardDistributor)] = _rOwned[address(rewardDistributor)].add(rAmount);\r\n        if (_isExcluded[address(rewardDistributor)]) _tOwned[address(rewardDistributor)] = _tOwned[address(rewardDistributor)].add(tAmount);\r\n\r\n        emit Transfer(sender, address(rewardDistributor), tAmount);\r\n        rewardDistributor.addRewardHolderShare(rewardRecipient, tAmount);\r\n        userReferralReward[rewardRecipient] = userReferralReward[rewardRecipient].add(tAmount);\r\n        totalReferralReward = totalReferralReward.add(tAmount);\r\n    }\r\n\r\n    function _sendToMarketingWallet(address sender, uint256 tMarketingFee, uint256 rMarketingFee) private {\r\n        _rOwned[marketingWallet] = _rOwned[marketingWallet].add(rMarketingFee);\r\n        if (_isExcluded[marketingWallet]) _tOwned[marketingWallet] = _tOwned[marketingWallet].add(tMarketingFee);\r\n        emit Transfer(sender, marketingWallet, tMarketingFee);\r\n    }\r\n\r\n    function _shouldSwapBack() private view returns (bool) {\r\n        return msg.sender != pcsV2Pair\r\n            && launchedAt > 0\r\n            && !_inSwap\r\n            && swapAndLiquifyEnabled\r\n            && balanceOf(address(this)) >= amountOfTokensToAddToLiquidityThreshold;\r\n    }\r\n\r\n    function _swapAndAddToLiquidity() private swapping {\r\n        uint256 tokenAmountForLiquidity = amountOfTokensToAddToLiquidityThreshold;\r\n        uint256 amountToSwap = tokenAmountForLiquidity.div(2);\r\n        uint256 amountAnotherHalf = tokenAmountForLiquidity.sub(amountToSwap);\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = pcsV2Router.WETH();\r\n\r\n        uint256 balanceBefore = address(this).balance;\r\n\r\n        pcsV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            amountToSwap,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp.add(30)\r\n        );\r\n\r\n        uint256 differenceBnb = address(this).balance.sub(balanceBefore);\r\n\r\n        pcsV2Router.addLiquidityETH{value: differenceBnb} (\r\n            address(this),\r\n            amountAnotherHalf,\r\n            0,\r\n            0,\r\n            _DEAD_ADDRESS,\r\n            block.timestamp.add(30)\r\n        );\r\n\r\n        emit SwapAndLiquify(differenceBnb, amountToSwap);\r\n    }\r\n\r\n    function _reflectFee(uint256 rFee, uint256 tFee) private {\r\n        _rTotal = _rTotal.sub(rFee);\r\n        _tFeeTotal = _tFeeTotal.add(tFee);\r\n    }\r\n\r\n    function _excludeFromReflection(address account) private {\r\n        // require(account !=  0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D, 'We can not exclude PancakeSwap router.');\r\n        require(!_isExcluded[account], \"Account is already excluded\");\r\n\r\n        if (_rOwned[account] > 0) {\r\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\r\n        }\r\n        _isExcluded[account] = true;\r\n        _excluded.push(account);\r\n    }\r\n\r\n    function _includeInReflection(address account) private {\r\n        require(_isExcluded[account], \"Account is already included\");\r\n        for (uint256 i = 0; i < _excluded.length; i++) {\r\n            if (_excluded[i] == account) {\r\n                _excluded[i] = _excluded[_excluded.length - 1];\r\n                _rOwned[account] = reflectionFromToken(_tOwned[account]);\r\n                _isExcluded[account] = false;\r\n                _excluded.pop();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _setIsExcludedFromFee(address account, bool flag) private {\r\n        _isExcludedFromFee[account] = flag;\r\n    }\r\n\r\n    function _whitelistWithRef(address account, address referee) private {\r\n        isFirstBuy[account] = true;\r\n        isWhitelisted[msg.sender] = true;\r\n        referParent[msg.sender] = referee;\r\n        referralList[referee].push(account);\r\n        userReferralCount[referee] = userReferralCount[referee].add(1);\r\n        emit UserWhitelisted(account, referee);\r\n    }\r\n\r\n    function _registerCode(address account, bytes memory code) private {\r\n        referUserForCode[code] = account;\r\n        referCodeForUser[account] = code;\r\n        emit RegisterCode(account, code);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"liquidityFeeOnBuy\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"marketingFeeOnBuy\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"HuHdistributionFeeOnBuy\",\"type\":\"uint8\"}],\"name\":\"ChangeFeesForNormalBuy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"liquidityFeeOnSell\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"marketingFeeOnSell\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"HuHdistributionFeeOnSell\",\"type\":\"uint8\"}],\"name\":\"ChangeFeesForNormalSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"liquidityFeeOnBuy\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"marketingFeeOnBuy\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"HuHdistributionFeeOnBuy\",\"type\":\"uint8\"}],\"name\":\"ChangeFeesForWhiteListedBuy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"liquidityFeeOnSell\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"marketingFeeOnSell\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"HuHdistributionFeeOnSell\",\"type\":\"uint8\"}],\"name\":\"ChangeFeesForWhitelistedSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"referralReward\",\"type\":\"uint8\"}],\"name\":\"ChangeReferralReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ExcludeFromReflection\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"IncludeInReflection\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes\",\"name\":\"code\",\"type\":\"bytes\"}],\"name\":\"RegisterCode\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"flag\",\"type\":\"bool\"}],\"name\":\"SetIsExcludedFromFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"maxTxPercent\",\"type\":\"uint256\"}],\"name\":\"SetMaxTxPercent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referralCodeRegistrator\",\"type\":\"address\"}],\"name\":\"SetReferralCodeRegistrator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiqudity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amountOfTokensToAddToLiquidityThreshold\",\"type\":\"uint256\"}],\"name\":\"UpdateAmountOfTokensToAddToLiquidityThreshold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"marketingWallet\",\"type\":\"address\"}],\"name\":\"UpdateMarketingWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pcsV2Router\",\"type\":\"address\"}],\"name\":\"UpdatePancakeSwapRouter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newRewardDistributor\",\"type\":\"address\"}],\"name\":\"UpdateRewardDistributor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"swapAndLiquifyEnabled\",\"type\":\"bool\"}],\"name\":\"UpdateSwapAndLiquifyEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referee\",\"type\":\"address\"}],\"name\":\"UserWhitelisted\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"HuHdistributionFeeOnBuy\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HuHdistributionFeeOnBuyWhiteListed\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HuHdistributionFeeOnSell\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HuHdistributionFeeOnWhiteListedSell\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amountOfTokensToAddToLiquidityThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_liquidityFeeOnBuy\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_marketingFeeOnBuy\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_HuHdistributionFeeOnBuy\",\"type\":\"uint8\"}],\"name\":\"changeFeesForNormalBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_liquidityFeeOnSell\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_marketingFeeOnSell\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_HuHdistributionFeeOnSell\",\"type\":\"uint8\"}],\"name\":\"changeFeesForNormalSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_liquidityFeeOnBuy\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_marketingFeeOnBuy\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_HuHdistributionFeeOnBuy\",\"type\":\"uint8\"}],\"name\":\"changeFeesForWhiteListedBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_liquidityFeeOnSell\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_marketingFeeOnSell\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_HuHdistributionFeeOnSell\",\"type\":\"uint8\"}],\"name\":\"changeFeesForWhitelistedSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_referralReward\",\"type\":\"uint8\"}],\"name\":\"changeReferralReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromReflection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getReferralList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalCommunityReferralReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalCommunityReflection\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalNumberOfCommunityReferral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getTotalNumberOfUserReferral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getTotalUserReferralReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInReflection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromReflection\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isFirstBuy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityFeeOnBuy\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityFeeOnSell\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityFeeOnWhiteListedBuy\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityFeeOnWhiteListedSell\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingFeeOnBuy\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingFeeOnBuyWhiteListed\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingFeeOnSell\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingFeeOnWhiteListedSell\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pcsV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pcsV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referCodeForUser\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referParent\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"referUserForCode\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralCodeRegistrator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"referralList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralReward\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tAmount\",\"type\":\"uint256\"}],\"name\":\"reflectionFromToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"code\",\"type\":\"string\"}],\"name\":\"registerCode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"code\",\"type\":\"string\"}],\"name\":\"registerCodeForOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardDistributor\",\"outputs\":[{\"internalType\":\"contract IRewardDistributor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"flag\",\"type\":\"bool\"}],\"name\":\"setIsExcludedFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxTxPercent\",\"type\":\"uint256\"}],\"name\":\"setMaxTxPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referralCodeRegistrator\",\"type\":\"address\"}],\"name\":\"setReferralCodeRegistrator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapAndLiquifyEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rAmount\",\"type\":\"uint256\"}],\"name\":\"tokenFromReflection\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountOfTokensToAddToLiquidityThreshold\",\"type\":\"uint256\"}],\"name\":\"updateAmountOfTokensToAddToLiquidityThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_marketingWallet\",\"type\":\"address\"}],\"name\":\"updateMarketingWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pcsV2Router\",\"type\":\"address\"}],\"name\":\"updatePancakeSwapRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardDistributor\",\"type\":\"address\"}],\"name\":\"updateRewardDistributor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_swapAndLiquifyEnabled\",\"type\":\"bool\"}],\"name\":\"updateSwapAndLiquifyEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"refCode\",\"type\":\"string\"}],\"name\":\"whitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEthInWei\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "HuhToken", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6aefcb368ec3392f33c36962752c2d365aa3184be9c1c80ea88534342711be59"}