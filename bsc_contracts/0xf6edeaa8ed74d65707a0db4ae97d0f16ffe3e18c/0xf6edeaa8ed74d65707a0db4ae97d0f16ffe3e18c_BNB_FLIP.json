{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Contract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\n\\ninterface IERC20 {\\n    \\n    function totalSupply() external view returns (uint256);\\n\\n    \\n    function balanceOf(address account) external view returns (uint256);\\n\\n    \\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    \\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    \\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    \\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    \\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    \\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\nlibrary Address {\\n    \\n    function isContract(address account) internal view returns (bool) {\\n        \\n        \\n        \\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    \\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    \\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    \\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    \\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    \\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    \\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    \\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    \\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    \\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    \\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            \\n            if (returndata.length > 0) {\\n                \\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    \\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        \\n        \\n        \\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    \\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        \\n        \\n        \\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            \\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\\nstruct Tarif {\\n  uint256 life_days;\\n  uint256 percent;\\n}\\n\\nstruct Deposit {\\n  uint256 tarif;\\n  uint256 amount;\\n  uint40 time;\\n}\\n\\nstruct Player {\\n  address upline;\\n  uint256 dividends;\\n  uint256 match_bonus;\\n  uint40 last_payout;\\n  uint256 total_invested;\\n  uint256 total_withdrawn;\\n  uint256 total_match_bonus;\\n  Deposit[] deposits;\\n  uint256[5] structure; \\n}\\n\\ncontract BNB_FLIP {\\n    using SafeERC20 for IERC20;\\n\\n    address public owner;\\n\\n    uint256 public invested;\\n    uint256 public withdrawn;\\n    uint256 public match_bonus;\\n    \\n    uint8 constant BONUS_LINES_COUNT = 5;\\n    uint16 constant PERCENT_DIVIDER = 1000; \\n    uint8[BONUS_LINES_COUNT] public ref_bonuses = [50, 30, 20, 10, 5]; \\n\\n    IERC20 public WBNB;\\n\\n    mapping(uint256 => Tarif) public tarifs;\\n    mapping(address => Player) public players;\\n\\n    event Upline(address indexed addr, address indexed upline, uint256 bonus);\\n    event NewDeposit(address indexed addr, uint256 amount, uint256 tarif);\\n    event MatchPayout(address indexed addr, address indexed from, uint256 amount);\\n    event Withdraw(address indexed addr, uint256 amount);\\n\\n    constructor() {\\n        owner = msg.sender;\\n\\n        uint256 tarifPercent = 130;\\n        for (uint256 tarifDuration = 30; tarifDuration <= 60; tarifDuration++) {\\n            tarifs[tarifDuration] = Tarif(tarifDuration, tarifPercent);\\n            tarifPercent+= 5;\\n        }\\n\\n        WBNB = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\\n    }\\n\\n    function _payout(address _addr) private {\\n        uint256 payout = this.payoutOf(_addr);\\n\\n        if(payout > 0) {\\n            players[_addr].last_payout = uint40(block.timestamp);\\n            players[_addr].dividends += payout;\\n        }\\n    }\\n\\n    function _refPayout(address _addr, uint256 _amount) private {\\n        address up = players[_addr].upline;\\n\\n        for(uint8 i = 0; i < ref_bonuses.length; i++) {\\n            if(up == address(0)) break;\\n            \\n            uint256 bonus = _amount * ref_bonuses[i] / PERCENT_DIVIDER;\\n            \\n            players[up].match_bonus += bonus;\\n            players[up].total_match_bonus += bonus;\\n\\n            match_bonus += bonus;\\n\\n            emit MatchPayout(up, _addr, bonus);\\n\\n            up = players[up].upline;\\n        }\\n    }\\n\\n    function _setUpline(address _addr, address _upline, uint256 _amount) private {\\n        if(players[_addr].upline == address(0) && _addr != owner) {\\n            if(players[_upline].deposits.length == 0) {\\n                _upline = owner;\\n            }\\n\\n            players[_addr].upline = _upline;\\n\\n            emit Upline(_addr, _upline, _amount / 100);\\n            \\n            for(uint8 i = 0; i < BONUS_LINES_COUNT; i++) {\\n                players[_upline].structure[i]++;\\n\\n                _upline = players[_upline].upline;\\n\\n                if(_upline == address(0)) break;\\n            }\\n        }\\n    }\\n    \\n    function deposit(uint256 _tarif, address _upline, uint256 amount) external {\\n        require(tarifs[_tarif].life_days > 0, \\\"Tarif not found\\\");\\n        require(amount >= 50000, \\\"Minimum deposit amount is 0.05 WBNB\\\");\\n\\n        WBNB.safeTransferFrom(msg.sender, address(this), amount);\\n\\n        Player storage player = players[msg.sender];\\n\\n        require(player.deposits.length < 100, \\\"Max 100 deposits per address\\\");\\n\\n        _setUpline(msg.sender, _upline, amount);\\n\\n        player.deposits.push(Deposit({\\n            tarif: _tarif,\\n            amount: amount,\\n            time: uint40(block.timestamp)\\n        }));\\n\\n        player.total_invested+= amount;\\n        invested+= amount;\\n\\n        _refPayout(msg.sender, amount);\\n\\n        WBNB.safeTransfer(owner, amount / 10);\\n        \\n        emit NewDeposit(msg.sender, amount, _tarif);\\n    }\\n    \\n    function withdraw() external {\\n        Player storage player = players[msg.sender];\\n\\n        _payout(msg.sender);\\n\\n        require(player.dividends > 0 || player.match_bonus > 0, \\\"Zero amount\\\");\\n\\n        uint256 amount = player.dividends + player.match_bonus;\\n\\n        player.dividends = 0;\\n        player.match_bonus = 0;\\n        player.total_withdrawn += amount;\\n        withdrawn += amount;\\n\\n        WBNB.safeTransfer(msg.sender, amount);\\n        \\n        emit Withdraw(msg.sender, amount);\\n    }\\n\\n    function payoutOf(address _addr) view external returns(uint256 value) {\\n        Player storage player = players[_addr];\\n\\n        for(uint256 i = 0; i < player.deposits.length; i++) {\\n            Deposit storage dep = player.deposits[i];\\n            Tarif storage tarif = tarifs[dep.tarif];\\n\\n            uint256 time_end = dep.time + tarif.life_days * 86400;\\n            uint256 from = player.last_payout > dep.time ? player.last_payout : dep.time;\\n            uint256 to = block.timestamp > time_end ? time_end : uint256(block.timestamp);\\n\\n            if(from < to) {\\n                value += dep.amount * (to - from) * tarif.percent / tarif.life_days / 8640000;\\n            }\\n        }\\n\\n        return value;\\n    }\\n\\n\\n    \\n    function userInfo(address _addr) view external returns(uint256 for_withdraw, uint256 total_invested, uint256 total_withdrawn, uint256 total_match_bonus, uint256[BONUS_LINES_COUNT] memory structure) {\\n        Player storage player = players[_addr];\\n\\n        uint256 payout = this.payoutOf(_addr);\\n\\n        for(uint8 i = 0; i < ref_bonuses.length; i++) {\\n            structure[i] = player.structure[i];\\n        }\\n\\n        return (\\n            payout + player.dividends + player.match_bonus,\\n            player.total_invested,\\n            player.total_withdrawn,\\n            player.total_match_bonus,\\n            structure\\n        );\\n    }\\n\\n    function contractInfo() view external returns(uint256 _invested, uint256 _withdrawn, uint256 _match_bonus) {\\n        return (invested, withdrawn, match_bonus);\\n    }\\n\\nfunction getUserDeposits(address user) external view returns (Deposit[] memory) {\\n    return players[user].deposits;\\n}  \\n\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MatchPayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tarif\",\"type\":\"uint256\"}],\"name\":\"NewDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"upline\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"}],\"name\":\"Upline\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"WBNB\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_invested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_match_bonus\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tarif\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_upline\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserDeposits\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tarif\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"time\",\"type\":\"uint40\"}],\"internalType\":\"struct Deposit[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"invested\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"match_bonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"payoutOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"players\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"upline\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"dividends\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"match_bonus\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"last_payout\",\"type\":\"uint40\"},{\"internalType\":\"uint256\",\"name\":\"total_invested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_withdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_match_bonus\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ref_bonuses\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tarifs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"life_days\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"for_withdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_invested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_withdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_match_bonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256[5]\",\"name\":\"structure\",\"type\":\"uint256[5]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "BNB_FLIP", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}