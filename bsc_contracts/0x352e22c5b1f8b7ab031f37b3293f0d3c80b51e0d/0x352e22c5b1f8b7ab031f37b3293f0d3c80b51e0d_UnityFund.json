{"SourceCode": "// File: @openzeppelin/contracts/math/SafeMath.sol\r\npragma solidity ^0.6.0;\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: contracts/libs/IBEP20.sol\r\n\r\npragma solidity >=0.6.4;\r\n\r\ninterface IBEP20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the token decimals.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Returns the token symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token name.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the bep token owner.\r\n     */\r\n    function getOwner() external view returns (address);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(\r\n        address _owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\npragma solidity ^0.6.2;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(\r\n            address(this).balance >= amount,\r\n            \"Address: insufficient balance\"\r\n        );\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(\r\n            success,\r\n            \"Address: unable to send value, recipient may have reverted\"\r\n        );\r\n    }\r\n\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data\r\n    ) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return\r\n            functionCallWithValue(\r\n                target,\r\n                data,\r\n                value,\r\n                \"Address: low-level call with value failed\"\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(\r\n            address(this).balance >= value,\r\n            \"Address: insufficient balance for call\"\r\n        );\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 weiValue,\r\n        string memory errorMessage\r\n    ) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(\r\n            data\r\n        );\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/libs/SafeBEP20.sol\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\nlibrary SafeBEP20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IBEP20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transfer.selector, to, value)\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IBEP20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IBEP20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(\r\n        IBEP20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeBEP20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.approve.selector, spender, value)\r\n        );\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IBEP20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(\r\n            value\r\n        );\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(\r\n                token.approve.selector,\r\n                spender,\r\n                newAllowance\r\n            )\r\n        );\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IBEP20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(\r\n            value,\r\n            \"SafeBEP20: decreased allowance below zero\"\r\n        );\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(\r\n                token.approve.selector,\r\n                spender,\r\n                newAllowance\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IBEP20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(\r\n            data,\r\n            \"SafeBEP20: low-level call failed\"\r\n        );\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(\r\n                abi.decode(returndata, (bool)),\r\n                \"SafeBEP20: BEP20 operation did not succeed\"\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() internal {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/GSN/Context.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\npragma solidity ^0.6.0;\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/libs/BEP20.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.4.0;\r\n\r\ncontract BEP20 is Context, IBEP20, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    constructor(string memory name, string memory symbol) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = 18;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the bep token owner.\r\n     */\r\n    function getOwner() external view override returns (address) {\r\n        return owner();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     */\r\n    function decimals() public view override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev See {BEP20-totalSupply}.\r\n     */\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {BEP20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {BEP20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(\r\n        address recipient,\r\n        uint256 amount\r\n    ) public override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {BEP20-allowance}.\r\n     */\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) public view override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {BEP20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(\r\n        address spender,\r\n        uint256 amount\r\n    ) public override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(\r\n            sender,\r\n            _msgSender(),\r\n            _allowances[sender][_msgSender()].sub(\r\n                amount,\r\n                \"BEP20: transfer amount exceeds allowance\"\r\n            )\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(\r\n        address spender,\r\n        uint256 addedValue\r\n    ) public returns (bool) {\r\n        _approve(\r\n            _msgSender(),\r\n            spender,\r\n            _allowances[_msgSender()][spender].add(addedValue)\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(\r\n        address spender,\r\n        uint256 subtractedValue\r\n    ) public returns (bool) {\r\n        _approve(\r\n            _msgSender(),\r\n            spender,\r\n            _allowances[_msgSender()][spender].sub(\r\n                subtractedValue,\r\n                \"BEP20: decreased allowance below zero\"\r\n            )\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Creates `amount` tokens and assigns them to `msg.sender`, increasing\r\n     * the total supply.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `msg.sender` must be the token owner\r\n     */\r\n    function mint(uint256 amount) public onlyOwner returns (bool) {\r\n        _mint(_msgSender(), amount);\r\n        return true;\r\n    }\r\n\r\n    function _transfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal {\r\n        require(sender != address(0), \"BEP20: transfer from the zero address\");\r\n        require(recipient != address(0), \"BEP20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(\r\n            amount,\r\n            \"BEP20: transfer amount exceeds balance\"\r\n        );\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"BEP20: mint to the zero address\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0), \"BEP20: burn from the zero address\");\r\n\r\n        _balances[account] = _balances[account].sub(\r\n            amount,\r\n            \"BEP20: burn amount exceeds balance\"\r\n        );\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0), \"BEP20: approve from the zero address\");\r\n        require(spender != address(0), \"BEP20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\r\n     * from the caller's allowance.\r\n     *\r\n     * See {_burn} and {_approve}.\r\n     */\r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _burn(account, amount);\r\n        _approve(\r\n            account,\r\n            _msgSender(),\r\n            _allowances[account][_msgSender()].sub(\r\n                amount,\r\n                \"BEP20: burn amount exceeds allowance\"\r\n            )\r\n        );\r\n    }\r\n}\r\n\r\nabstract contract Initializable {\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     */\r\n    bool private _initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private _initializing;\r\n\r\n    /**\r\n     * @dev Modifier to protect an initializer function from being invoked twice.\r\n     */\r\n    modifier initializer() {\r\n        require(\r\n            _initializing || !_initialized,\r\n            \"Initializable: contract is already initialized\"\r\n        );\r\n\r\n        bool isTopLevelCall = !_initializing;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n            _initialized = true;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n        }\r\n    }\r\n}\r\n\r\nabstract contract ContextUpgradeable is Initializable {\r\n    function __Context_init() internal initializer {\r\n        __Context_init_unchained();\r\n    }\r\n\r\n    function __Context_init_unchained() internal initializer {}\r\n\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal pure virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n\r\n    uint256[50] private __gap;\r\n}\r\n\r\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\r\n    address public _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    function __Ownable_init() internal initializer {\r\n        __Context_init_unchained();\r\n        __Ownable_init_unchained();\r\n    }\r\n\r\n    function __Ownable_init_unchained() internal initializer {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n\r\n    uint256[49] private __gap;\r\n}\r\n\r\ncontract UnityFund is Initializable, OwnableUpgradeable {\r\n  using SafeBEP20 for IBEP20;\r\n  using SafeMath for uint256;\r\n    event regLevelEvent(\r\n        address indexed _user,\r\n        address indexed _referrer,\r\n        address  originalRefer,\r\n        uint256 _amount,\r\n        uint256 _time\r\n    );\r\n\r\n    event reTopupLevelEvent(\r\n        address indexed _user,\r\n        uint256 _time\r\n    );\r\n\r\n    event roiDirectEvent(\r\n        address indexed _user,\r\n        uint256 _amount,\r\n        uint256 _time\r\n    );\r\n\r\n    event levelIncomeEvent(\r\n        address indexed _user,\r\n        uint256 _amount,\r\n        uint256 _time\r\n    );\r\n\r\n    uint256 REFERRER_1_LEVEL_LIMIT;\r\n    struct UserStruct {\r\n      bool isExist;\r\n      uint256 id;\r\n      uint256 referrerID;\r\n      uint256 directIncome;\r\n      address[] referral;\r\n      address[] allDirect;\r\n      uint256 generationIncome;\r\n      uint256 earnedAmount;\r\n      address parentAddress;\r\n      uint256 teamCount;\r\n      uint256 roiFrom;\r\n      uint256 roiTo;\r\n      uint256 retopupTimes;\r\n      uint256 withdrawAmount;\r\n      uint256 missedIncome;\r\n    }\r\n\r\n    mapping(address => UserStruct) public users;\r\n    mapping(uint256 => address) public userList;\r\n    uint256 public currUserID;\r\n    uint256 public totalUsers;\r\n    uint256 public totalPayouts;\r\n    address public ownerWallet;\r\n    uint256 public joinAmount;\r\n    uint256 public referAmount;\r\n    uint256 public adminAmount;\r\n    uint256 public generationAmount;\r\n    uint256 public persecondreward;\r\n    address[] public joinedAddress;\r\n    IBEP20 public USDTAddress;\r\n    UnityFund public oldUnityFund;\r\n    mapping(address => uint256) public userJoinTimestamps;\r\n    mapping(address => uint256[4]) public generationIncomePerLevel;\r\n    address public migrateOwner;\r\n    mapping(address => bool) public isRetopup;\r\n    mapping(address => uint256) public tenCycleTopup;\r\n    uint256 public totalInvested;\r\n    bool public regLock;\r\n    bool public claimROILock;\r\n    bool public claimLevelLock;\r\n\r\n    function initialize(\r\n        address _owner\r\n    ) public initializer {\r\n        __Ownable_init();\r\n\r\n        ownerWallet = _owner;\r\n        REFERRER_1_LEVEL_LIMIT = 3;\r\n        currUserID = 1;\r\n        totalUsers = 1;\r\n        joinAmount = 60 * 1e18;\r\n        referAmount = 10 * 1e18;\r\n        adminAmount = 10 * 1e18;\r\n        generationAmount = 10 * 1e18;\r\n\r\n      //mainnet\r\n\r\n        USDTAddress = IBEP20(0x55d398326f99059fF775485246999027B3197955);\r\n        oldUnityFund = UnityFund(0x4F0CBeAb4093dD8bBC5D8D6616B64186C7F47528);\r\n\r\n        UserStruct memory userStruct;\r\n        userStruct = UserStruct({\r\n            isExist: true,\r\n            id: currUserID,\r\n            referrerID: 0,\r\n            directIncome : 0,\r\n            referral: new address[](0),\r\n            allDirect : new address[](0),\r\n            generationIncome : 0,\r\n            earnedAmount : 0,\r\n            teamCount : 0,\r\n            parentAddress : address(0),\r\n            roiFrom : 0,\r\n            roiTo : block.timestamp + 3666 days,\r\n            retopupTimes : 0,\r\n            withdrawAmount : 0,\r\n            missedIncome: 0\r\n        });\r\n\r\n        users[ownerWallet] = userStruct;\r\n        userList[currUserID] = ownerWallet;\r\n        generationIncomePerLevel[ownerWallet] = [0,0,0,0];\r\n        userJoinTimestamps[ownerWallet] = block.timestamp;\r\n        persecondreward = 81018518518518;\r\n        totalInvested = 391180 * 1e18;\r\n\r\n        regLock = false;\r\n        claimROILock = false;\r\n        claimLevelLock = false;\r\n        totalPayouts = oldUnityFund.totalPayouts();\r\n        totalUsers = oldUnityFund.totalUsers();\r\n        currUserID = oldUnityFund.currUserID();\r\n    }\r\n\r\n    function oldUnityFundSync(uint256 oldId, uint limit) public {\r\n        require(msg.sender == ownerWallet, \"Access denied\");\r\n        for (uint i = 0; i < limit; i++) {\r\n            UserStruct memory olduser;\r\n            address oldusers = oldUnityFund.userList(oldId);\r\n            (\r\n                olduser.isExist,\r\n                olduser.id,\r\n                olduser.referrerID,\r\n                olduser.directIncome,\r\n                olduser.generationIncome,\r\n                olduser.earnedAmount,\r\n                ,\r\n                olduser.teamCount,\r\n                ,\r\n                ,\r\n                ,\r\n                ,\r\n\r\n            ) = oldUnityFund.users(oldusers);\r\n\r\n            (\r\n                ,\r\n                ,\r\n                ,\r\n                ,\r\n                ,\r\n                ,\r\n                olduser.parentAddress,\r\n                ,\r\n                olduser.roiFrom,\r\n                olduser.roiTo,\r\n                olduser.retopupTimes,\r\n                olduser.withdrawAmount,\r\n                olduser.missedIncome\r\n\r\n            ) = oldUnityFund.users(oldusers);\r\n\r\n            if (olduser.isExist) {\r\n               users[oldusers].isExist = olduser.isExist;\r\n               (uint256 gen1,uint256 gen2,uint256 gen3,uint256 gen4) = oldUnityFund.viewallgenerationIncome(oldusers);\r\n               generationIncomePerLevel[oldusers] = [gen1,gen2,gen3,gen4];\r\n               users[oldusers].id = olduser.id;\r\n               users[oldusers].referrerID  = olduser.referrerID;\r\n               users[oldusers].directIncome  = olduser.directIncome;\r\n               users[oldusers].earnedAmount  =  olduser.earnedAmount;\r\n               users[oldusers].parentAddress = olduser.parentAddress;\r\n               users[oldusers].teamCount  =  olduser.teamCount;\r\n               userList[oldId] = oldusers;\r\n               joinedAddress.push(oldusers);\r\n               users[oldusers].roiTo = olduser.roiTo;\r\n               users[oldusers].roiFrom = olduser.roiFrom;\r\n               users[oldusers].retopupTimes = olduser.retopupTimes;\r\n               users[oldusers].withdrawAmount = olduser.withdrawAmount;\r\n               users[oldusers].missedIncome = olduser.missedIncome;\r\n               users[oldusers].allDirect = oldUnityFund.viewallDirectUserReferral(oldusers);\r\n               users[oldusers].referral = oldUnityFund.viewUserReferral(oldusers);\r\n               users[oldusers].generationIncome  =  olduser.generationIncome;\r\n            }\r\n            oldId++;\r\n        }\r\n    }\r\n\r\n    function oldUnityFundCommonData() public {\r\n        require(msg.sender == ownerWallet, \"Access denied\");\r\n        totalPayouts = oldUnityFund.totalPayouts();\r\n        totalUsers = oldUnityFund.totalUsers();\r\n        currUserID = oldUnityFund.currUserID();\r\n    }\r\n\r\n\r\n    function regUser(address _referrer, uint256 _amount) public  {\r\n        require(!regLock);\r\n        regLock = true;\r\n        require(!users[msg.sender].isExist, \"User exist\");\r\n        require(users[_referrer].isExist, \"Invalid referal\");\r\n        require(_amount == joinAmount,\"Invalid amount\");\r\n\r\n        uint256 _referrerID = users[_referrer].id;\r\n        if (users[userList[_referrerID]].referral.length >= REFERRER_1_LEVEL_LIMIT) {\r\n            _referrerID = users[findFreeReferrer(userList[_referrerID])].id;\r\n        }\r\n        currUserID++;\r\n        totalUsers++;\r\n        UserStruct memory userStruct;\r\n\r\n        userStruct = UserStruct({\r\n            isExist: true,\r\n            id: currUserID,\r\n            referrerID: _referrerID,\r\n            directIncome : 0,\r\n            referral: new address[](0),\r\n            allDirect : new address[](0),\r\n            generationIncome : 0,\r\n            earnedAmount : 0,\r\n            teamCount : 0,\r\n            parentAddress : _referrer,\r\n            roiFrom : block.timestamp,\r\n            roiTo : block.timestamp + 10 days,\r\n            retopupTimes : 0,\r\n            withdrawAmount : 0,\r\n            missedIncome:0\r\n        });\r\n\r\n        users[msg.sender] = userStruct;\r\n        userList[currUserID] = msg.sender;\r\n        address _upliner = userList[_referrerID];\r\n        USDTAddress.safeTransferFrom(msg.sender,address(this),_amount);\r\n        users[_upliner].referral.push(msg.sender);\r\n        generationIncomePerLevel[msg.sender] = [0,0,0,0];\r\n        address parent = userList[_referrerID];\r\n        updateTeamCount(parent);\r\n        USDTAddress.safeTransfer(ownerWallet, adminAmount);\r\n        users[_referrer].directIncome += referAmount;\r\n        USDTAddress.safeTransfer(_referrer, referAmount);\r\n        //users[_referrer].earnedAmount += referAmount;\r\n        users[_referrer].withdrawAmount += referAmount;\r\n        totalPayouts += adminAmount;\r\n        payForReferral(parent);\r\n        joinedAddress.push(msg.sender);\r\n        users[_referrer].allDirect.push(msg.sender);\r\n        userJoinTimestamps[msg.sender] = block.timestamp;\r\n        isRetopup[msg.sender] = true;\r\n        totalInvested += _amount;\r\n        regLock = false;\r\n        emit regLevelEvent(msg.sender, userList[_referrerID], _referrer, _amount, block.timestamp);\r\n    }\r\n\r\n    function autoRejoin(address _user,bool isFull,uint256 _amount) internal {\r\n        if(!isFull && _amount > 0){\r\n          USDTAddress.safeTransferFrom(msg.sender,address(this),_amount);\r\n        }\r\n        users[_user].retopupTimes++;\r\n        users[_user].roiFrom = block.timestamp;\r\n        users[_user].roiTo = block.timestamp + 10 days;\r\n        payForReferral(userList[users[msg.sender].referrerID]);\r\n        emit reTopupLevelEvent(\r\n            msg.sender,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function retopUpremainingAmount(address _user) public view returns(uint256) {\r\n        uint256 _checkRoi = checkRoi(_user);\r\n        uint takenAmount = 0;\r\n        if(_checkRoi > 0){\r\n            if(_checkRoi >= joinAmount){\r\n                if(users[_user].retopupTimes == 10){\r\n                    takenAmount = joinAmount;\r\n                }else{\r\n                    takenAmount = 0;\r\n                }\r\n            }else {\r\n                 takenAmount = joinAmount - _checkRoi;\r\n            }\r\n           }else{\r\n            takenAmount = joinAmount;\r\n        }\r\n        return takenAmount;\r\n    }\r\n\r\n    function cliamRoiDirectReward() public   {\r\n      require(!claimROILock);\r\n      claimROILock = true;\r\n        require(users[msg.sender].isExist, \"User Not exist\");\r\n        require(block.timestamp >= users[msg.sender].roiTo,\"Withdraw will be available 10 days from joining\");\r\n        updateRoi();\r\n        // require(users[msg.sender].earnedAmount > 0, \"No Balance\");\r\n        uint256 remainingAmount = 0;\r\n        if(users[msg.sender].earnedAmount > 0){\r\n            if(users[msg.sender].earnedAmount >= joinAmount){\r\n                if(users[msg.sender].retopupTimes == 10){\r\n                    users[msg.sender].retopupTimes = 0;\r\n                    tenCycleTopup[msg.sender]++;\r\n                    autoRejoin(msg.sender,false,joinAmount);\r\n                    totalInvested += joinAmount;\r\n                }else{\r\n                    autoRejoin(msg.sender,true,0);\r\n                }\r\n                remainingAmount = users[msg.sender].earnedAmount - joinAmount;\r\n            }else {\r\n                uint256 takenAmount = joinAmount - users[msg.sender].earnedAmount;\r\n                autoRejoin(msg.sender,false,takenAmount);\r\n                totalInvested += takenAmount;\r\n            }\r\n\r\n\r\n\r\n            if(remainingAmount > 0){\r\n              USDTAddress.safeTransfer(msg.sender, remainingAmount);\r\n            }\r\n\r\n            totalPayouts += remainingAmount;\r\n            users[msg.sender].withdrawAmount += users[msg.sender].earnedAmount;\r\n            uint256 withdrawAmount = users[msg.sender].earnedAmount;\r\n            users[msg.sender].earnedAmount = 0 ;\r\n            emit roiDirectEvent(\r\n                msg.sender,\r\n                withdrawAmount,\r\n                block.timestamp\r\n            );\r\n        }else{\r\n            autoRejoin(msg.sender, false, joinAmount);\r\n            totalInvested += joinAmount;\r\n        }\r\n        claimROILock = false;\r\n\r\n    }\r\n\r\n    function cliamLevelReward() public {\r\n      require(!claimLevelLock);\r\n      claimLevelLock = true;\r\n        require(users[msg.sender].allDirect.length >= 4, \"Not reached Limit\");\r\n        require(users[msg.sender].generationIncome > 0 ,\"No Balance\");\r\n        uint256 fee  =  (users[msg.sender].generationIncome * 15 ) / 100;\r\n        USDTAddress.safeTransfer(ownerWallet, fee);\r\n        uint256 remainingAmount = users[msg.sender].generationIncome - fee;\r\n        USDTAddress.safeTransfer(msg.sender , remainingAmount);\r\n        totalPayouts += users[msg.sender].generationIncome;\r\n        users[msg.sender].withdrawAmount += users[msg.sender].generationIncome;\r\n        uint256 withdrawAmount = users[msg.sender].generationIncome;\r\n        users[msg.sender].generationIncome = 0;\r\n        claimLevelLock = false;\r\n         emit levelIncomeEvent(\r\n            msg.sender,\r\n            withdrawAmount,\r\n            block.timestamp\r\n        );\r\n\r\n    }\r\n\r\n     function updateRoi() internal {\r\n        if(users[msg.sender].roiFrom != 0){\r\n            if(users[msg.sender].roiTo > users[msg.sender].roiFrom) {\r\n                uint256 totime  = users[msg.sender].roiTo;\r\n                if(block.timestamp < users[msg.sender].roiTo) {\r\n                    totime  = block.timestamp;\r\n                }\r\n                uint256 percenatge = persecondreward * (totime - users[msg.sender].roiFrom) ;\r\n                uint256 amount = percenatge;  // we multiply 1e18 for percentage the why divide 1e20 instead of 1e2\r\n                users[msg.sender].roiFrom = totime;\r\n                users[msg.sender].earnedAmount += amount;\r\n            }\r\n        }\r\n    }\r\n\r\n    function checkRoi(address _user) public view returns(uint256) {\r\n        if((users[_user].roiTo - users[_user].roiFrom) != 0 && users[_user].roiFrom != 0) {\r\n            uint256 totime  =users[_user].roiTo;\r\n            if(block.timestamp < users[_user].roiTo) {\r\n                 totime  = block.timestamp;\r\n            }\r\n            uint256 percenatge = persecondreward * (totime - users[_user].roiFrom) ;\r\n            uint256 amount =  percenatge;\r\n           return amount;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function checkROIClaimenable(address _user) public view returns(bool){\r\n        bool isClaim =  false;\r\n         if(block.timestamp >= users[_user].roiTo) {\r\n            isClaim  = true;\r\n         }\r\n        return isClaim;\r\n    }\r\n\r\n    function updateTeamCount(address _parent) internal {\r\n       if(_parent != address(0)){\r\n         users[_parent].teamCount++;\r\n         address referer = userList[users[_parent].referrerID];\r\n         updateTeamCount(referer);\r\n       }\r\n    }\r\n\r\n    function payForReferral(address _parent) internal {\r\n        address nextParent = _parent;\r\n        uint256 genAmount = generationAmount;\r\n        for (uint i = 0; i < 4; i++) {\r\n        if(nextParent != address(0) && users[nextParent].roiTo >= block.timestamp && users[nextParent].allDirect.length >= 4){\r\n                users[nextParent].generationIncome += genAmount;\r\n                generationIncomePerLevel[nextParent][i] += genAmount;\r\n        } else {\r\n            users[nextParent].missedIncome += genAmount;\r\n        }\r\n            nextParent =  userList[users[nextParent].referrerID];\r\n        }\r\n    }\r\n\r\n    function findFreeReferrer(address _user) public view returns (address) {\r\n        if (users[_user].referral.length < REFERRER_1_LEVEL_LIMIT) {\r\n            return _user;\r\n        }\r\n        address[] memory referrals = new address[](600);\r\n        referrals[0] = users[_user].referral[0];\r\n        referrals[1] = users[_user].referral[1];\r\n        referrals[2] = users[_user].referral[2];\r\n        address freeReferrer;\r\n        bool noFreeReferrer = true;\r\n        for (uint256 i = 0; i < 600; i++) {\r\n            if (users[referrals[i]].referral.length == REFERRER_1_LEVEL_LIMIT) {\r\n                if (i < 120) {\r\n                    referrals[(i + 1) * 3] = users[referrals[i]].referral[0];\r\n                    referrals[(i + 1) * 3 + 1] = users[referrals[i]].referral[1];\r\n                    referrals[(i + 1) * 3 + 2] = users[referrals[i]].referral[2];\r\n                }\r\n            } else {\r\n                noFreeReferrer = false;\r\n                freeReferrer = referrals[i];\r\n                break;\r\n            }\r\n        }\r\n        require(!noFreeReferrer, \"No Free Referrer\");\r\n        return freeReferrer;\r\n    }\r\n\r\n    function viewUserReferral(\r\n        address _user\r\n    ) public view returns (address[] memory) {\r\n        return users[_user].referral;\r\n    }\r\n\r\n    function viewallDirectUserReferral(\r\n        address _user\r\n    ) public view returns (address[] memory) {\r\n        return users[_user].allDirect;\r\n    }\r\n\r\n    function viewallgenerationIncome(\r\n        address _user\r\n    ) public view returns (uint256,uint256,uint256,uint256) {\r\n        return (generationIncomePerLevel[_user][0],generationIncomePerLevel[_user][1],generationIncomePerLevel[_user][2],generationIncomePerLevel[_user][3]);\r\n    }\r\n\r\n    function getUsersJoinedLast24Hours() external view returns (uint256) {\r\n        uint256 count = 0;\r\n        for (uint256 i = 0; i < totalUsers; i++) {\r\n            address userAddress = userList[i];\r\n            if (\r\n                userJoinTimestamps[userAddress] != 0 &&\r\n                block.timestamp - userJoinTimestamps[userAddress] <= 86400\r\n            ) {\r\n                count++;\r\n            }\r\n        }\r\n        return count;\r\n    }\r\n\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"levelIncomeEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"reTopupLevelEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"originalRefer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"regLevelEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"roiDirectEvent\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"USDTAddress\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"checkROIClaimenable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"checkRoi\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimLevelLock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimROILock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cliamLevelReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cliamRoiDirectReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currUserID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"findFreeReferrer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"generationAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"generationIncomePerLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUsersJoinedLast24Hours\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isRetopup\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"joinAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"joinedAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrateOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oldUnityFund\",\"outputs\":[{\"internalType\":\"contract UnityFund\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oldUnityFundCommonData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"oldId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"oldUnityFundSync\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"persecondreward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"regLock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"regUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"retopUpremainingAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tenCycleTopup\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalInvested\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPayouts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userJoinTimestamps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isExist\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referrerID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"generationIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"earnedAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"parentAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"teamCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roiFrom\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roiTo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"retopupTimes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"missedIncome\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"viewUserReferral\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"viewallDirectUserReferral\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"viewallgenerationIncome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "UnityFund", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://76cacf3ed00d2bc53a792d8c9c438275ee966c7204306d9de55855f139dac784"}