{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/BridgePlus.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\ninterface IERC20 {\\r\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n  function totalSupply() external view returns (uint256);\\r\\n  function balanceOf(address account) external view returns (uint256);\\r\\n  function transfer(address to, uint256 amount) external returns (bool);\\r\\n  function allowance(address owner, address spender) external view returns (uint256);\\r\\n  function approve(address spender, uint256 amount) external returns (bool);\\r\\n  function transferFrom(\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 amount\\r\\n  ) external returns (bool);\\r\\n}\\r\\n\\r\\ninterface IWETH is IERC20 {\\r\\n  function deposit() external payable;\\r\\n  function withdraw(uint amount) external;\\r\\n}\\r\\n\\r\\nabstract contract Context {\\r\\n  function _msgSender() internal view virtual returns (address) {\\r\\n    return msg.sender;\\r\\n  }\\r\\n  function _msgData() internal view virtual returns (bytes calldata) {\\r\\n    return msg.data;\\r\\n  }\\r\\n}\\r\\n\\r\\nabstract contract Ownable is Context {\\r\\n  address private _owner;\\r\\n\\r\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n  constructor() {\\r\\n    _transferOwnership(_msgSender());\\r\\n  }\\r\\n\\r\\n  modifier onlyOwner() {\\r\\n    _checkOwner();\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  function owner() public view virtual returns (address) {\\r\\n    return _owner;\\r\\n  }\\r\\n\\r\\n  function _checkOwner() internal view virtual {\\r\\n    require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n  }\\r\\n\\r\\n  function renounceOwnership() public virtual onlyOwner {\\r\\n    _transferOwnership(address(0));\\r\\n  }\\r\\n\\r\\n  function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n    require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n    _transferOwnership(newOwner);\\r\\n  }\\r\\n\\r\\n  function _transferOwnership(address newOwner) internal virtual {\\r\\n    address oldOwner = _owner;\\r\\n    _owner = newOwner;\\r\\n    emit OwnershipTransferred(oldOwner, newOwner);\\r\\n  }\\r\\n}\\r\\n\\r\\nlibrary Address {\\r\\n  function isContract(address account) internal view returns (bool) {\\r\\n    return account.code.length > 0;\\r\\n  }\\r\\n\\r\\n  function sendValue(address payable recipient, uint256 amount) internal {\\r\\n    require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n    (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n    require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n  }\\r\\n\\r\\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n      return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\r\\n  }\\r\\n\\r\\n  function functionCall(\\r\\n      address target,\\r\\n      bytes memory data,\\r\\n      string memory errorMessage\\r\\n  ) internal returns (bytes memory) {\\r\\n      return functionCallWithValue(target, data, 0, errorMessage);\\r\\n  }\\r\\n\\r\\n  function functionCallWithValue(\\r\\n      address target,\\r\\n      bytes memory data,\\r\\n      uint256 value\\r\\n  ) internal returns (bytes memory) {\\r\\n    return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n  }\\r\\n\\r\\n  function functionCallWithValue(\\r\\n    address target,\\r\\n    bytes memory data,\\r\\n    uint256 value,\\r\\n    string memory errorMessage\\r\\n  ) internal returns (bytes memory) {\\r\\n    require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\r\\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\\r\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n  }\\r\\n\\r\\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n    return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n  }\\r\\n\\r\\n  function functionStaticCall(\\r\\n    address target,\\r\\n    bytes memory data,\\r\\n    string memory errorMessage\\r\\n  ) internal view returns (bytes memory) {\\r\\n    (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n  }\\r\\n\\r\\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n    return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n  }\\r\\n\\r\\n  function functionDelegateCall(\\r\\n    address target,\\r\\n    bytes memory data,\\r\\n    string memory errorMessage\\r\\n  ) internal returns (bytes memory) {\\r\\n    (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n  }\\r\\n\\r\\n  function verifyCallResultFromTarget(\\r\\n    address target,\\r\\n    bool success,\\r\\n    bytes memory returndata,\\r\\n    string memory errorMessage\\r\\n  ) internal view returns (bytes memory) {\\r\\n    if (success) {\\r\\n      if (returndata.length == 0) {\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n      }\\r\\n      return returndata;\\r\\n    } else {\\r\\n      _revert(returndata, errorMessage);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function verifyCallResult(\\r\\n    bool success,\\r\\n    bytes memory returndata,\\r\\n    string memory errorMessage\\r\\n  ) internal pure returns (bytes memory) {\\r\\n    if (success) {\\r\\n      return returndata;\\r\\n    } else {\\r\\n      _revert(returndata, errorMessage);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function _revert(bytes memory returndata, string memory errorMessage) private pure {\\r\\n    if (returndata.length > 0) {\\r\\n      assembly {\\r\\n        let returndata_size := mload(returndata)\\r\\n        revert(add(32, returndata), returndata_size)\\r\\n      }\\r\\n    } else {\\r\\n      revert(errorMessage);\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\ninterface IERC20Permit {\\r\\n  function permit(\\r\\n    address owner,\\r\\n    address spender,\\r\\n    uint256 value,\\r\\n    uint256 deadline,\\r\\n    uint8 v,\\r\\n    bytes32 r,\\r\\n    bytes32 s\\r\\n  ) external;\\r\\n  function nonces(address owner) external view returns (uint256);\\r\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n}\\r\\n\\r\\nlibrary SafeERC20 {\\r\\n  using Address for address;\\r\\n\\r\\n  function safeTransfer(\\r\\n    IERC20 token,\\r\\n    address to,\\r\\n    uint256 value\\r\\n  ) internal {\\r\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n  }\\r\\n\\r\\n  function safeTransferFrom(\\r\\n    IERC20 token,\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 value\\r\\n  ) internal {\\r\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n  }\\r\\n\\r\\n  function safeApprove(\\r\\n    IERC20 token,\\r\\n    address spender,\\r\\n    uint256 value\\r\\n  ) internal {\\r\\n    require(\\r\\n      (value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n      \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n    );\\r\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n  }\\r\\n\\r\\n  function safeIncreaseAllowance(\\r\\n    IERC20 token,\\r\\n    address spender,\\r\\n    uint256 value\\r\\n  ) internal {\\r\\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\\r\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n  }\\r\\n\\r\\n  function safeDecreaseAllowance(\\r\\n    IERC20 token,\\r\\n    address spender,\\r\\n    uint256 value\\r\\n  ) internal {\\r\\n    unchecked {\\r\\n      uint256 oldAllowance = token.allowance(address(this), spender);\\r\\n      require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\r\\n      uint256 newAllowance = oldAllowance - value;\\r\\n      _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function safePermit(\\r\\n    IERC20Permit token,\\r\\n    address owner,\\r\\n    address spender,\\r\\n    uint256 value,\\r\\n    uint256 deadline,\\r\\n    uint8 v,\\r\\n    bytes32 r,\\r\\n    bytes32 s\\r\\n  ) internal {\\r\\n    uint256 nonceBefore = token.nonces(owner);\\r\\n    token.permit(owner, spender, value, deadline, v, r, s);\\r\\n    uint256 nonceAfter = token.nonces(owner);\\r\\n    require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\r\\n  }\\r\\n\\r\\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n    bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\r\\n    if (returndata.length > 0) {\\r\\n      require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nabstract contract ReentrancyGuard {\\r\\n  uint256 private constant _NOT_ENTERED = 1;\\r\\n  uint256 private constant _ENTERED = 2;\\r\\n\\r\\n  uint256 private _status;\\r\\n\\r\\n  constructor () {\\r\\n    _status = _NOT_ENTERED;\\r\\n  }\\r\\n  \\r\\n  modifier nonReentrant() {\\r\\n    require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\r\\n    _status = _ENTERED;\\r\\n    _;\\r\\n    _status = _NOT_ENTERED;\\r\\n  }\\r\\n}\\r\\n\\r\\ninterface ISwapPlusv1 {\\r\\n  struct swapRouter {\\r\\n    string platform;\\r\\n    address tokenIn;\\r\\n    address tokenOut;\\r\\n    uint256 amountOutMin;\\r\\n    uint256 meta; // fee, flag(stable), 0=v2\\r\\n    uint256 percent;\\r\\n  }\\r\\n  struct swapLine {\\r\\n    swapRouter[] swaps;\\r\\n  }\\r\\n  struct swapBlock {\\r\\n    swapLine[] lines;\\r\\n  }\\r\\n\\r\\n  function swap(address tokenIn, uint256 amount, address tokenOut, address recipient, swapBlock[] calldata swBlocks) external payable returns(uint256, uint256);\\r\\n}\\r\\n\\r\\ninterface ILCBridgev2 {\\r\\n  function swap(address _to, address _refund, uint256 _outChainID) external payable returns(uint256);\\r\\n  function redeem(address account, uint256 amount, uint256 srcChainId, uint256 _swapIndex, uint256 operatorFee) external returns(uint256);\\r\\n  function refund(uint256 _index, uint256 _fee) external returns(uint256);\\r\\n}\\r\\n\\r\\ninterface ILCBridgev2Token {\\r\\n  function swap(address _to, uint256 _amount, address _refund, uint256 _outChainID) external payable returns(uint256);\\r\\n  function redeem(address account, uint256 amount, uint256 srcChainId, uint256 _swapIndex, uint256 operatorFee) external returns(uint256);\\r\\n  function refund(uint256 _index) external returns(uint256);\\r\\n}\\r\\n\\r\\ninterface IBridge {\\r\\n  function addNativeLiquidity(uint256 _amount)\\r\\n    external payable;\\r\\n  \\r\\n  function send(\\r\\n    address _receiver,\\r\\n    address _token,\\r\\n    uint256 _amount,\\r\\n    uint64 _dstChainId,\\r\\n    uint64 _nonce,\\r\\n    uint32 _maxSlippage // slippage * 1M, eg. 0.5% -> 5000\\r\\n  ) external;\\r\\n\\r\\n  function sendNative(\\r\\n    address _receiver,\\r\\n    uint256 _amount,\\r\\n    uint64 _dstChainId,\\r\\n    uint64 _nonce,\\r\\n    uint32 _maxSlippage\\r\\n  ) external payable;\\r\\n\\r\\n  function withdraw(\\r\\n    bytes calldata _wdmsg,\\r\\n    bytes[] calldata _sigs,\\r\\n    address[] calldata _signers,\\r\\n    uint256[] calldata _powers\\r\\n  ) external;\\r\\n}\\r\\n\\r\\ninterface IStargateRouter {\\r\\n  struct lzTxObj {\\r\\n    uint256 dstGasForCall;\\r\\n    uint256 dstNativeAmount;\\r\\n    bytes dstNativeAddr;\\r\\n  }\\r\\n\\r\\n  function addLiquidity(uint256 _poolId, uint256 _amountLD, address to) external payable;\\r\\n  function instantRedeemLocal(uint16 _srcPoolId, uint256 _amountLD, address to) external payable;\\r\\n\\r\\n  function swap(\\r\\n    uint16 _dstChainId,\\r\\n    uint256 _srcPoolId,\\r\\n    uint256 _dstPoolId,\\r\\n    address payable _refundAddress,\\r\\n    uint256 _amountLD,\\r\\n    uint256 _minAmountLD,\\r\\n    lzTxObj memory _lzTxParams,\\r\\n    bytes calldata _to,\\r\\n    bytes calldata _payload\\r\\n  ) external payable;\\r\\n\\r\\n  function quoteLayerZeroFee(\\r\\n    uint16 _dstChainId,\\r\\n    uint8 _functionType,\\r\\n    bytes calldata _toAddress,\\r\\n    bytes calldata _transferAndCallPayload,\\r\\n    lzTxObj memory _lzTxParams\\r\\n  ) external view returns (uint256, uint256);\\r\\n}\\r\\n\\r\\ncontract BridgePlus is Ownable, ReentrancyGuard {\\r\\n  using SafeERC20 for IERC20;\\r\\n\\r\\n  uint256 public chainId;\\r\\n  address public WETH;\\r\\n  address public treasury;\\r\\n  address public swapRouter;\\r\\n  address public debridgeRouter;\\r\\n  uint256 public swapFee = 3000;\\r\\n  uint256 public coreDecimal = 1000000;\\r\\n  uint256 public stargateSwapFeeMultipler = 1400000;\\r\\n  uint256 public stargateSwapFeeDivider = 1000000;\\r\\n\\r\\n  mapping (address => bool) public noFeeWallets;\\r\\n  mapping (address => bool) public managers;\\r\\n  mapping (address => bool) public operators;\\r\\n  mapping (address => bool) public whiteListContracts;\\r\\n\\r\\n  struct Operator {\\r\\n    address bridge;\\r\\n    address inToken;\\r\\n    address token;\\r\\n    uint256 amount;\\r\\n    address dstAddress;\\r\\n    address receiver;\\r\\n    address refund;\\r\\n    uint256 desChainId;\\r\\n    address dstToken;\\r\\n    address receiveToken;\\r\\n    uint256 bridgeType;\\r\\n    uint256 basketId;\\r\\n    bytes param;\\r\\n  }\\r\\n\\r\\n  struct swapPath {\\r\\n    ISwapPlusv1.swapBlock[] path;\\r\\n  }\\r\\n\\r\\n  error DelegatecallFailed();\\r\\n  event BridgePlusFee(address token, uint256 fee, address treasury);\\r\\n  event BridgePlusSwap(address dstAddress, address receiver, uint256 srcChainId, address srcToken, uint256 amount, uint256 dstChainId, address dstToken, address receiveToken, uint256 bridgeType, uint256 basketId);\\r\\n\\r\\n  constructor(\\r\\n    uint256 _chainId,\\r\\n    address _swapRouter,\\r\\n    address _WETH,\\r\\n    address _treasury\\r\\n  ) {\\r\\n    require(_swapRouter != address(0), \\\"BridgePlus: swap router\\\");\\r\\n    require(_WETH != address(0), \\\"BridgePlus: WETH\\\");\\r\\n    require(_treasury != address(0), \\\"BridgePlus: Treasury\\\");\\r\\n\\r\\n    chainId = _chainId;\\r\\n    swapRouter = _swapRouter;\\r\\n    WETH = _WETH;\\r\\n    treasury = _treasury;\\r\\n    whiteListContracts[0xeF4fB24aD0916217251F553c0596F8Edc630EB66] = true;\\r\\n    whiteListContracts[0x663DC15D3C1aC63ff12E45Ab68FeA3F0a883C251] = true;\\r\\n    managers[msg.sender] = true;\\r\\n  }\\r\\n\\r\\n  modifier onlyManager() {\\r\\n    require(managers[msg.sender], \\\"BridgePlus: !manager\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  modifier onlyOperator() {\\r\\n    require(operators[msg.sender], \\\"BridgePlus: !operator\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  receive() external payable {\\r\\n  }\\r\\n\\r\\n  function swap(Operator calldata info, swapPath calldata paths, uint256[] calldata metadata) public payable nonReentrant {\\r\\n    uint256 amount = info.amount;\\r\\n    if (info.inToken != address(0)) {\\r\\n      amount = IERC20(info.inToken).balanceOf(address(this));\\r\\n      IERC20(info.inToken).safeTransferFrom(msg.sender, address(this), info.amount);\\r\\n      amount = IERC20(info.inToken).balanceOf(address(this)) - amount;\\r\\n    }\\r\\n    else if (info.bridgeType == 2) {\\r\\n      uint256 fee = getStgSwapFee(info.bridge, uint16(info.desChainId));\\r\\n      amount -= fee;\\r\\n    }\\r\\n    if (noFeeWallets[msg.sender] == false && info.bridgeType != 0 && info.bridgeType != 4) {\\r\\n      amount = _cutFee(info.inToken, amount);\\r\\n    }\\r\\n    \\r\\n    if (paths.path.length > 0) {\\r\\n      address tokenI = info.inToken;\\r\\n      address tokenO = info.token == address(0) ? WETH : info.token;\\r\\n      if (tokenI == address(0)) {\\r\\n        tokenI = WETH;\\r\\n        IWETH(WETH).deposit{value: amount}();\\r\\n      }\\r\\n      _approveTokenIfNeeded(tokenI, swapRouter, amount);\\r\\n      (, amount) = ISwapPlusv1(swapRouter).swap(tokenI, amount, tokenO, address(this), paths.path);\\r\\n\\r\\n      if (info.token == address(0)) {\\r\\n        IWETH(WETH).withdraw(amount);\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (info.bridgeType == 0) { // LC bridge\\r\\n      if (info.token != address(0)) {\\r\\n        IWETH(WETH).withdraw(amount);\\r\\n      }\\r\\n      ILCBridgev2(info.bridge).swap{value: amount}(info.dstAddress, info.refund, info.desChainId);\\r\\n    }\\r\\n    else {\\r\\n      _approveTokenIfNeeded(info.token, info.bridge, amount);\\r\\n      if (info.bridgeType == 1) { // CBridge\\r\\n        uint64 nonce = uint64(block.timestamp);\\r\\n        IBridge(info.bridge).send(info.dstAddress, info.token, amount, uint64(info.desChainId), nonce, 1000000);\\r\\n      }\\r\\n      else if (info.bridgeType == 2) { // Stargate\\r\\n        uint256 fee = getStgSwapFee(info.bridge, uint16(info.desChainId));\\r\\n        IStargateRouter(info.bridge).swap{value: fee}(\\r\\n          uint16(info.desChainId),\\r\\n          metadata[0],\\r\\n          metadata[1],\\r\\n          payable(msg.sender),\\r\\n          amount,\\r\\n          0,\\r\\n          IStargateRouter.lzTxObj(0, 0, \\\"0x\\\"),\\r\\n          abi.encodePacked(info.dstAddress),\\r\\n          bytes(\\\"\\\")\\r\\n        );\\r\\n      }\\r\\n      else if (info.bridgeType == 4) {\\r\\n        ILCBridgev2Token(info.bridge).swap{value: 0}(info.dstAddress, amount, info.refund, info.desChainId);\\r\\n      }\\r\\n      else if (info.bridgeType == 5 && whiteListContracts[info.bridge]) {\\r\\n        (bool ok, ) = address(info.bridge).call{value: metadata[0]}(info.param);\\r\\n        if (!ok) {\\r\\n          revert DelegatecallFailed();\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n\\r\\n    emit BridgePlusSwap(info.dstAddress, info.receiver, chainId, info.token, amount, info.desChainId, info.dstToken, info.receiveToken, info.bridgeType, info.basketId);\\r\\n  }\\r\\n\\r\\n  function redeem(address bridge, address receiver, address tokenO, address tokenR, uint256 amount, uint256 bridgeType, swapPath[2] calldata paths, uint256[] memory metadata) public payable onlyOperator nonReentrant returns(uint256) {\\r\\n    if (bridgeType == 0 || bridgeType == 4) { // LC bridge\\r\\n      amount = ILCBridgev2(bridge).redeem(address(this), amount, metadata[0], metadata[1], metadata[2]);\\r\\n      if (metadata[2] > 0) {\\r\\n        (bool success, ) = payable(msg.sender).call{value: metadata[2]}(\\\"\\\");\\r\\n        require(success, \\\"BridgePlus: Failed refund oeprator fee\\\");\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (metadata[3] > 0) { // operator fee\\r\\n      amount -= metadata[3];\\r\\n      if (paths[1].path.length > 0) {\\r\\n        _approveTokenIfNeeded(tokenO, swapRouter, metadata[3]);\\r\\n        (, metadata[3]) = ISwapPlusv1(swapRouter).swap(tokenO, metadata[3], WETH, address(this), paths[1].path);\\r\\n      }\\r\\n      if (tokenO != address(0)) {\\r\\n        IWETH(WETH).withdraw(metadata[3]);\\r\\n      }\\r\\n      (bool success, ) = payable(msg.sender).call{value: metadata[3]}(\\\"\\\");\\r\\n      require(success, \\\"BridgePlus: Failed operator fee\\\");\\r\\n    }\\r\\n\\r\\n    if (paths[0].path.length > 0) {\\r\\n      address tokenI = tokenO;\\r\\n      address tokenSO = tokenR == address(0) ? WETH : tokenR;\\r\\n      if (tokenI == address(0)) {\\r\\n        tokenI = WETH;\\r\\n        IWETH(WETH).deposit{value: amount}();\\r\\n      }\\r\\n      _approveTokenIfNeeded(tokenI, swapRouter, amount);\\r\\n      (, amount) = ISwapPlusv1(swapRouter).swap(tokenI, amount, tokenSO, address(this), paths[0].path);\\r\\n    }\\r\\n\\r\\n    if (tokenR == address(0)) {\\r\\n      if (tokenO != address(0)) {\\r\\n        IWETH(WETH).withdraw(amount);\\r\\n      }\\r\\n      (bool success, ) = payable(receiver).call{value: amount}(\\\"\\\");\\r\\n      require(success, \\\"BridgePlus: Failed redeem\\\");\\r\\n    }\\r\\n    else {\\r\\n      IERC20(tokenR).safeTransfer(receiver, amount);\\r\\n    }\\r\\n    return amount;\\r\\n  }\\r\\n\\r\\n  function refundCbridge(\\r\\n    address cbridge,\\r\\n    bytes calldata _wdmsg,\\r\\n    bytes[] calldata _sigs,\\r\\n    address[] calldata _signers,\\r\\n    uint256[] calldata _powers,\\r\\n    address account,\\r\\n    address _token\\r\\n  ) public nonReentrant {\\r\\n    IBridge(cbridge).withdraw(_wdmsg, _sigs, _signers, _powers);\\r\\n\\r\\n    if (_token == address(0)) {\\r\\n      (bool success, ) = payable(account).call{value: address(this).balance}(\\\"\\\");\\r\\n      require(success, \\\"BridgePlus: refund cbrdige\\\");\\r\\n    }\\r\\n    else {\\r\\n      IERC20(_token).safeTransfer(account, IERC20(_token).balanceOf(address(this)));\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function getStgSwapFee(address bridge, uint16 _desChain) public view returns(uint256) {\\r\\n    (uint256 swFee, ) = IStargateRouter(bridge).quoteLayerZeroFee(\\r\\n      _desChain,\\r\\n      1,\\r\\n      bytes(\\\"0x\\\"),\\r\\n      bytes(\\\"0x\\\"),\\r\\n      IStargateRouter.lzTxObj(0, 0, \\\"0x\\\")\\r\\n    );\\r\\n    return swFee * stargateSwapFeeMultipler / stargateSwapFeeDivider;\\r\\n  }\\r\\n\\r\\n  function setManager(address account, bool access) public onlyOwner {\\r\\n    managers[account] = access;\\r\\n  }\\r\\n\\r\\n  function setOperator(address account, bool access) public onlyOwner {\\r\\n    operators[account] = access;\\r\\n  }\\r\\n\\r\\n  function setSwapRouter(address _swapRouter) public onlyOwner {\\r\\n    swapRouter = _swapRouter;\\r\\n  }\\r\\n\\r\\n  function setDebridgeRouter(address _debridgeRouter) public onlyOwner {\\r\\n    debridgeRouter = _debridgeRouter;\\r\\n  }\\r\\n\\r\\n  function setNoFeeWallets(address account, bool access) public onlyManager {\\r\\n    noFeeWallets[account] = access;\\r\\n  }\\r\\n\\r\\n  function setWhiteListContracts(address account, bool access) public onlyManager {\\r\\n    whiteListContracts[account] = access;\\r\\n  }\\r\\n\\r\\n  function setSwapFee(uint256 _swapFee) public onlyManager {\\r\\n    swapFee = _swapFee;\\r\\n  }\\r\\n\\r\\n  function setTreasury(address _treasury) public onlyManager {\\r\\n    treasury = _treasury;\\r\\n  }\\r\\n\\r\\n  function _approveTokenIfNeeded(address token, address spender, uint256 amount) private {\\r\\n    if (token != address(0)) {\\r\\n      uint256 oldAllowance = IERC20(token).allowance(address(this), spender);\\r\\n      if (oldAllowance < amount) {\\r\\n        if (oldAllowance > 0) {\\r\\n          IERC20(token).safeApprove(spender, 0);\\r\\n        }\\r\\n        IERC20(token).safeApprove(spender, amount);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function _cutFee(address _token, uint256 _amount) internal returns(uint256) {\\r\\n    if (_amount > 0) {\\r\\n      uint256 fee = _amount * swapFee / coreDecimal;\\r\\n      if (fee > 0) {\\r\\n        if (_token == address(0)) {\\r\\n          (bool success, ) = payable(treasury).call{value: fee}(\\\"\\\");\\r\\n          require(success, \\\"BridgePlus: Failed cut fee\\\");\\r\\n        }\\r\\n        else {\\r\\n          IERC20(_token).safeTransfer(treasury, fee);\\r\\n        }\\r\\n        emit BridgePlusFee(_token, fee, treasury);\\r\\n      }\\r\\n      return _amount - fee;\\r\\n    }\\r\\n    return 0;\\r\\n  }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_swapRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_WETH\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"DelegatecallFailed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"treasury\",\"type\":\"address\"}],\"name\":\"BridgePlusFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dstAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dstToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiveToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bridgeType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"basketId\",\"type\":\"uint256\"}],\"name\":\"BridgePlusSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coreDecimal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"debridgeRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bridge\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_desChain\",\"type\":\"uint16\"}],\"name\":\"getStgSwapFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"managers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"noFeeWallets\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"operators\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bridge\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenO\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenR\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bridgeType\",\"type\":\"uint256\"},{\"components\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"platform\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"meta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"internalType\":\"struct ISwapPlusv1.swapRouter[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ISwapPlusv1.swapLine[]\",\"name\":\"lines\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ISwapPlusv1.swapBlock[]\",\"name\":\"path\",\"type\":\"tuple[]\"}],\"internalType\":\"struct BridgePlus.swapPath[2]\",\"name\":\"paths\",\"type\":\"tuple[2]\"},{\"internalType\":\"uint256[]\",\"name\":\"metadata\",\"type\":\"uint256[]\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cbridge\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_wdmsg\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"_sigs\",\"type\":\"bytes[]\"},{\"internalType\":\"address[]\",\"name\":\"_signers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_powers\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"refundCbridge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_debridgeRouter\",\"type\":\"address\"}],\"name\":\"setDebridgeRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"access\",\"type\":\"bool\"}],\"name\":\"setManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"access\",\"type\":\"bool\"}],\"name\":\"setNoFeeWallets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"access\",\"type\":\"bool\"}],\"name\":\"setOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_swapFee\",\"type\":\"uint256\"}],\"name\":\"setSwapFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_swapRouter\",\"type\":\"address\"}],\"name\":\"setSwapRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"name\":\"setTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"access\",\"type\":\"bool\"}],\"name\":\"setWhiteListContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stargateSwapFeeDivider\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stargateSwapFeeMultipler\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"bridge\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"dstAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"refund\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"desChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"dstToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiveToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bridgeType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"basketId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"param\",\"type\":\"bytes\"}],\"internalType\":\"struct BridgePlus.Operator\",\"name\":\"info\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"platform\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"meta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"internalType\":\"struct ISwapPlusv1.swapRouter[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ISwapPlusv1.swapLine[]\",\"name\":\"lines\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ISwapPlusv1.swapBlock[]\",\"name\":\"path\",\"type\":\"tuple[]\"}],\"internalType\":\"struct BridgePlus.swapPath\",\"name\":\"paths\",\"type\":\"tuple\"},{\"internalType\":\"uint256[]\",\"name\":\"metadata\",\"type\":\"uint256[]\"}],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whiteListContracts\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "BridgePlus", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000380000000000000000000000004444457406b815253080bc38b084aa1a14faadbf000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c000000000000000000000000b65f101f856b9036ec5e0521501d4d0c5146eaf4", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}