{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n    function decimals() external view returns (uint8);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    error OwnableUnauthorizedAccount(address account);\r\n    error OwnableInvalidOwner(address owner);\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        _transferOwnership(msg.sender);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function _checkOwner() internal view virtual {\r\n        if (owner() != msg.sender) {\r\n            revert OwnableUnauthorizedAccount(msg.sender);\r\n        }\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        if (newOwner == address(0)) {\r\n            revert OwnableInvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ncontract StackingContract is Ownable {\r\n    struct Tier {\r\n        uint256 apy;\r\n        uint256 minAmount;\r\n    }\r\n\r\n    Tier[] public tiers;\r\n\r\n    struct Stake {\r\n        uint256 amount;\r\n        Tier[] tiers;\r\n        uint256 tierDuration;\r\n        uint256 stakedAt;\r\n    }\r\n\r\n    mapping(address => Stake) public stakes;\r\n\r\n    bool public started;\r\n    IERC20 public token;\r\n    uint256 public tierDuration;\r\n    uint256 public maxStakingAmount;\r\n    uint256 public totalStackingAmount;\r\n    uint256 public totalRewardsAmount;\r\n\r\n\r\n    constructor(address token_, uint256 tiersCount) {\r\n        token = IERC20(token_);\r\n        for (uint256 i = 0; i < tiersCount; i++) {\r\n            tiers.push(Tier({apy: 0, minAmount: 0}));\r\n        }\r\n    }\r\n\r\n    function configure(uint256 tierDuration_, Tier[] memory tiers_, uint256 maxStakingAmount_) external onlyOwner {\r\n        require(tiers.length == tiers_.length);\r\n        tierDuration = tierDuration_;\r\n        for (uint256 i = 0; i < tiers.length; i++) {\r\n            tiers[i] = tiers_[i];\r\n        }\r\n        maxStakingAmount = maxStakingAmount_;\r\n    }\r\n\r\n    function start() external onlyOwner {\r\n        started = true;\r\n    }\r\n\r\n    function stake(uint256 amount) external returns (bool) {\r\n        require(started, \"Stacking has not started yet\");\r\n        require(stakes[msg.sender].stakedAt == 0, \"The address is already participating in staking\");\r\n        require(amount >= tiers[tiers.length - 1].minAmount, \"The amount is less than the minimum amount for participation\");\r\n        require(amount + totalStackingAmount <= maxStakingAmount, \"The amount is greater than the maximum total amount for stacking\");\r\n        if (token.transferFrom(msg.sender, address(this), amount)) {\r\n            Stake storage s = stakes[msg.sender];\r\n            s.amount = amount;\r\n            s.tiers = tiers;\r\n            s.tierDuration = tierDuration;\r\n            s.stakedAt = block.timestamp;\r\n            totalStackingAmount += amount;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function rewardIndex(address staker) public view returns (uint) {\r\n        uint indx = (block.timestamp - stakes[staker].stakedAt) / 60 / 60 / 24 / stakes[staker].tierDuration;\r\n        return indx;\r\n    }\r\n\r\n    function reward(address staker) public view returns (uint) {\r\n        if (!started) return 0;\r\n        Stake memory s = stakes[staker];\r\n        if (s.stakedAt > 0) {\r\n            uint indx = (block.timestamp - s.stakedAt) / 60 / 60 / 24 / s.tierDuration;\r\n            if (indx == 0) return 0;\r\n            if (indx > tiers.length) {\r\n                indx = tiers.length;\r\n            }\r\n            uint r;\r\n            for (uint i = tiers.length; i > tiers.length - indx; i--) {\r\n                Tier memory tier = s.tiers[i - 1];\r\n                if (s.amount < tier.minAmount) break;\r\n                r += s.amount * tier.apy * s.tierDuration / 36500;\r\n            }\r\n            return r;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function unstake() external {\r\n        require(stakes[msg.sender].stakedAt > 0, \"The address is not participating in staking\");\r\n        uint r = reward(msg.sender);\r\n        totalStackingAmount -= stakes[msg.sender].amount;\r\n        totalRewardsAmount += r;\r\n        stakes[msg.sender].stakedAt = 0;\r\n        token.transfer(msg.sender, stakes[msg.sender].amount + r);\r\n    }\r\n\r\n    function withdraw(IERC20 token_) external onlyOwner {\r\n        uint amount = token_.balanceOf(address(this));\r\n        if (token == token_) {\r\n            amount -= totalStackingAmount;\r\n            started = false;\r\n        }\r\n        token_.transfer(owner(), amount);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tiersCount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tierDuration_\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"apy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct StackingContract.Tier[]\",\"name\":\"tiers_\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"maxStakingAmount_\",\"type\":\"uint256\"}],\"name\":\"configure\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxStakingAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"reward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"rewardIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tierDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakedAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"started\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tierDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tiers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"apy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRewardsAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStackingAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token_\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "StackingContract", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "500", "ConstructorArguments": "0000000000000000000000002ffdfe146994670ee6668e2d8473c85d06a6c6ba0000000000000000000000000000000000000000000000000000000000000009", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://92e034e665c08136ef1b494a7fe6067f8ca41d8832b29605a44425bfe8e22a04"}