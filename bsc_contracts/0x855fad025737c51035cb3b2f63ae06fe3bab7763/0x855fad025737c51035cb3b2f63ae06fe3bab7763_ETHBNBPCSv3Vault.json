{"SourceCode": "//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.16;\r\n\r\ninterface INonfungiblePositionManager {\r\n    struct DecreaseLiquidityParams {\r\n        uint256 tokenId;\r\n        uint128 liquidity;\r\n        uint256 amount0Min;\r\n        uint256 amount1Min;\r\n        uint256 deadline;\r\n    }\r\n\r\n    struct CollectParams {\r\n        uint256 tokenId;\r\n        address recipient;\r\n        uint128 amount0Max;\r\n        uint128 amount1Max;\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function decreaseLiquidity(\r\n        DecreaseLiquidityParams calldata params\r\n    ) external returns (uint256 amount0, uint256 amount1);\r\n\r\n    function collect(\r\n        CollectParams calldata params\r\n    ) external payable returns (uint256 amount0, uint256 amount1);\r\n\r\n    function positions(\r\n        uint256 tokenId\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint96 nonce,\r\n            address operator,\r\n            address token0,\r\n            address token1,\r\n            uint24 fee,\r\n            int24 tickLower,\r\n            int24 tickUpper,\r\n            uint128 liquidity,\r\n            uint256 feeGrowthInside0LastX128,\r\n            uint256 feeGrowthInside1LastX128,\r\n            uint128 tokensOwed0,\r\n            uint128 tokensOwed1\r\n        );\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function mint(address account, uint amount) external;\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\ninterface IMasterChefV3 {\r\n    function harvest(\r\n        uint256 _tokenId,\r\n        address _to\r\n    ) external returns (uint256 reward);\r\n\r\n    function withdraw(\r\n        uint256 _tokenId,\r\n        address _to\r\n    ) external returns (uint256 reward);\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 indexed tokenId\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed approved,\r\n        uint256 indexed tokenId\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(\r\n        address indexed owner,\r\n        address indexed operator,\r\n        bool approved\r\n    );\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(\r\n        uint256 tokenId\r\n    ) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(\r\n        address owner,\r\n        address operator\r\n    ) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/GSN/Context.sol\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor() {}\r\n\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _owner = _msgSender();\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract ETHBNBPCSv3Vault is IERC721Receiver, Ownable {\r\n    using SafeMath for uint256;\r\n    INonfungiblePositionManager manager = INonfungiblePositionManager(0x46A15B0b27311cedF172AB29E4f4766fbE7F4364);\r\n    IERC721 public nftToken = IERC721(0x46A15B0b27311cedF172AB29E4f4766fbE7F4364);\r\n    IERC20 public ethToken = IERC20(0x2170Ed0880ac9A755fd29B2688956BD959F933F8);\r\n    IERC20 public wbnbToken = IERC20(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\r\n    IERC20 public carboncc = IERC20(0xD03811a88bf40db9C246E7BD20f0E6c50eE95B38);\r\n    IERC20 public cakeToken = IERC20(0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82);\r\n    address public masterchef = 0x556B9306565093C855AEA9AE92A594704c2Cd59e;\r\n    address public eth = 0x2170Ed0880ac9A755fd29B2688956BD959F933F8;\r\n    address public wbnb = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\r\n    mapping(uint256 => address) public stakedNFTs;\r\n\r\n    uint256 public initreward = 0;\r\n    uint256 public starttime = 0;\r\n    uint256 public periodFinish = block.timestamp;\r\n    uint256 public rewardRate = 0;\r\n    uint256 public lastUpdateTime;\r\n    uint256 public rewardPerTokenStored;\r\n    bool public started;\r\n    mapping(address => uint256) public userRewardPerTokenPaid;\r\n    mapping(address => uint256) public rewards;\r\n    uint128 public liquiditytax = 10;\r\n    uint public taxdenominator = 100;\r\n    uint public sponsorTax = 80;\r\n    address public sponsorRewardAddress1 = 0xD95E5777C4d1B16Dbb5411D4d3B590fAf03c8880;\r\n    address public sponsorRewardAddress2 = 0x49ADeb725deBF26968E523Bf95bd175b2E9d28f1;\r\n    uint public lpFeeTax = 20;\r\n    address public lpFeeAddress = 0xFBC44E6a83b057848dE43118551dF47036326D36;\r\n    uint256 private _totalSupply;\r\n    address public treasuryAddress = 0xFBC44E6a83b057848dE43118551dF47036326D36;\r\n    address public rewardProgramAddress = 0xD53595e54A4E3656D8dca2c978979a12d0154f07;\r\n    address public rewardHoldingWalletAddress = 0x9741d69945c2c9276958d11964BB1403F7Ef7152;\r\n    mapping(address => uint256) public pendingRewards;\r\n    uint256 public distributedReward = 0;\r\n\r\n    mapping(address => uint256) private _balances;\r\n\r\n    event NFTStaked(address indexed staker, uint256 indexed tokenId);\r\n    event NFTUnstaked(address indexed staker, uint256 indexed tokenId);\r\n    event Harvested(address indexed staker, uint256 reward);\r\n    event RewardAdded(uint256 reward);\r\n    event TotalPaid(address indexed _address, uint indexed _amount);\r\n    event TressuryPaid(address indexed _address, uint indexed _amount);\r\n    event RewardPaid(address indexed _address, uint indexed _amount);\r\n    event VaultFarmHarvestFee(address indexed _address, uint indexed _amount);\r\n    event sponsorReward1(address indexed _address, uint indexed _amount);\r\n    event sponsorReward2(address indexed _address, uint indexed _amount);\r\n    event lpFeeAdd1(address indexed _address, uint indexed _amount);\r\n    event lpFeeAdd2(address indexed _address, uint indexed _amount);\r\n    event treasuryAdd(address indexed _address, uint256 amount);\r\n    event rewardProgram(address indexed _address, uint256 amount);\r\n    event rewardHoldingWalletAdd(address indexed _address, uint256 amount);\r\n\r\n    constructor() {}\r\n\r\n    function stake(uint256 _tokenId) public checkStart {\r\n        //Verify Token\r\n        (address a, address b) = getTokenAB(_tokenId);\r\n        require(a == eth, \"Token does not match\");\r\n        require(b == wbnb, \"Token does not match\");\r\n        // Transfer NFT token to the contract\r\n        nftToken.safeTransferFrom(msg.sender, address(this), _tokenId);\r\n        decreaseLiquidity(_tokenId);\r\n        collect();\r\n        // Update the staked NFTs mapping\r\n        stakedNFTs[_tokenId] = msg.sender;\r\n        stakeToMasterChef(_tokenId);\r\n        addStakeLP(_tokenId);\r\n        emit NFTStaked(msg.sender, _tokenId);\r\n    }\r\n\r\n    function stakeTokens(uint256[] calldata tokenIds) external {\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            stake(tokenIds[i]);\r\n        }\r\n    }\r\n\r\n    function decreaseLiquidity(uint _tokenId) public {\r\n        uint128 tax = (getLiquidity(_tokenId) * (liquiditytax)) / 100;\r\n        INonfungiblePositionManager.DecreaseLiquidityParams\r\n            memory params = INonfungiblePositionManager\r\n                .DecreaseLiquidityParams({\r\n                    tokenId: _tokenId,\r\n                    liquidity: tax,\r\n                    amount0Min: 0,\r\n                    amount1Min: 0,\r\n                    deadline: block.timestamp + 1800\r\n                });\r\n        (uint amt1, uint amt2) = manager.decreaseLiquidity(params);\r\n        INonfungiblePositionManager.CollectParams\r\n            memory params2 = INonfungiblePositionManager.CollectParams({\r\n                tokenId: _tokenId,\r\n                recipient: address(this),\r\n                amount0Max: uint128(amt1),\r\n                amount1Max: uint128(amt2)\r\n            });\r\n        manager.collect(params2);\r\n    }\r\n\r\n    function collect() public {\r\n        _collectTokens1(ethToken);\r\n        _collectTokens2(wbnbToken);\r\n    }\r\n\r\n    function _collectTokens1(IERC20 token) internal {\r\n        uint256 balance = token.balanceOf(address(this));\r\n        if (balance > 0) {\r\n            uint256 sponsorAmount = (balance * sponsorTax) / taxdenominator;\r\n            uint256 lpFeeAmount = (balance * lpFeeTax) / taxdenominator;\r\n\r\n            token.transfer(sponsorRewardAddress1, sponsorAmount);\r\n            token.transfer(lpFeeAddress, lpFeeAmount);\r\n\r\n            emit sponsorReward1(msg.sender, sponsorAmount + lpFeeAmount);\r\n            emit lpFeeAdd1(lpFeeAddress, lpFeeAmount);\r\n        }\r\n    }\r\n\r\n    function _collectTokens2(IERC20 token) internal {\r\n        uint256 balance = token.balanceOf(address(this));\r\n        if (balance > 0) {\r\n            uint256 sponsorAmount = (balance * sponsorTax) / taxdenominator;\r\n            uint256 lpFeeAmount = (balance * lpFeeTax) / taxdenominator;\r\n\r\n            token.transfer(sponsorRewardAddress2, sponsorAmount);\r\n            token.transfer(lpFeeAddress, lpFeeAmount);\r\n\r\n            emit sponsorReward2(msg.sender, sponsorAmount + lpFeeAmount);\r\n            emit lpFeeAdd2(lpFeeAddress, lpFeeAmount);\r\n        }\r\n    }\r\n\r\n    function stakeToMasterChef(uint256 _tokenId) internal {\r\n        // Transfer NFT token to the contract\r\n        nftToken.approve(masterchef, _tokenId);\r\n        nftToken.safeTransferFrom(address(this), masterchef, _tokenId);\r\n\r\n        // Update the staked NFTs mapping\r\n        stakedNFTs[_tokenId] = msg.sender;\r\n        emit NFTStaked(msg.sender, _tokenId);\r\n    }\r\n\r\n    function harvest(uint _tokenId) public {\r\n        uint256 reward = IMasterChefV3(masterchef).harvest(\r\n            _tokenId,\r\n            treasuryAddress\r\n        );\r\n        emit Harvested(treasuryAddress, reward);\r\n    }\r\n\r\n    function harvestTokens(uint256[] calldata tokenIds) external {\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            harvest(tokenIds[i]);\r\n        }\r\n    }\r\n\r\n    function calTax(uint _amount, uint _fee) public view returns (uint, uint) {\r\n        uint taxamount = _amount.mul(_fee).div(taxdenominator);\r\n        uint stakeamount = _amount.sub(taxamount);\r\n        return (taxamount, stakeamount);\r\n    }\r\n\r\n    function unstakeFromMasterChef(uint256 _tokenId) internal {\r\n        IMasterChefV3(masterchef).withdraw(_tokenId, address(this));\r\n    }\r\n\r\n    function unstake(uint256 _tokenId) public {\r\n        require(\r\n            stakedNFTs[_tokenId] == msg.sender,\r\n            \"Token does not belongs to caller\"\r\n        );\r\n\r\n        unstakeFromMasterChef(_tokenId);\r\n\r\n        // Transfer NFT token back to the staker\r\n        nftToken.safeTransferFrom(address(this), msg.sender, _tokenId);\r\n\r\n        // Update the staked NFTs mapping\r\n        stakedNFTs[_tokenId] = address(0);\r\n        if (earned(msg.sender) > 0) {\r\n            Claim();\r\n        }\r\n        removeStakeLP(_tokenId);\r\n\r\n        if (cakeToken.balanceOf(address(this)) > 0) {\r\n            emit Harvested(treasuryAddress, cakeToken.balanceOf(address(this)));\r\n            cakeToken.transfer(treasuryAddress, cakeToken.balanceOf(address(this)));\r\n        }\r\n        emit NFTUnstaked(msg.sender, _tokenId);\r\n    }\r\n\r\n    function unstakeTokens(uint256[] calldata tokenIds) external {\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            unstake(tokenIds[i]);\r\n        }\r\n    }\r\n\r\n    // Implement onERC721Received function from IERC721Receiver interface\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external override returns (bytes4) {\r\n        return this.onERC721Received.selector;\r\n    }\r\n\r\n    function getLiquidity(uint256 tokenId) public view returns (uint128) {\r\n        (, , , , , , , uint128 liquidity, , , , ) = manager.positions(tokenId);\r\n        return liquidity;\r\n    }\r\n\r\n    function getTokenAB(\r\n        uint256 tokenId\r\n    ) public view returns (address, address) {\r\n        (, , address tokenA, address tokenB, , , , , , , , ) = manager\r\n            .positions(tokenId);\r\n        return (tokenA, tokenB);\r\n    }\r\n\r\n    function addStakeLP(uint _tokenId) internal updateReward(msg.sender) {\r\n        //Check lp in token\r\n        if (_totalSupply == 0) {\r\n            lastUpdateTime = block.timestamp;\r\n        }\r\n        uint amount = getLiquidity(_tokenId);\r\n        require(amount > 0, \"Amount 0\");\r\n        _balances[msg.sender] = _balances[msg.sender] + amount;\r\n        _totalSupply = _totalSupply.add(amount);\r\n    }\r\n\r\n    function removeStakeLP(uint _tokenId) internal updateReward(msg.sender) {\r\n        //Check lp in token\r\n        uint amount = getLiquidity(_tokenId);\r\n        require(amount > 0, \"Amount 0\");\r\n        _balances[msg.sender] = _balances[msg.sender] - amount;\r\n        _totalSupply = _totalSupply - amount;\r\n    }\r\n\r\n    modifier checkStart() {\r\n        require(started == true, \"not start\");\r\n        _;\r\n    }\r\n\r\n    function Claim() public updateReward(msg.sender) checkStart {\r\n        uint256 reward = earned(msg.sender);\r\n        uint256 pendingReward = pendingRewards[msg.sender];\r\n        if (reward > 0 || pendingReward > 0) {\r\n            rewards[msg.sender] = 0;\r\n            if (pendingRewards[msg.sender] > 0) {\r\n                reward += pendingRewards[msg.sender];\r\n                pendingRewards[msg.sender] = 0;\r\n            }\r\n\r\n            // Take 20% tax\r\n            uint256 taxAmount = (reward * 20) / 100;\r\n            uint256 remainingReward = reward - taxAmount;\r\n\r\n            uint256 splitTaxAmount = taxAmount / 2;\r\n\r\n            carboncc.transfer(treasuryAddress, splitTaxAmount);\r\n            emit treasuryAdd(msg.sender, splitTaxAmount);\r\n\r\n            uint256 rewardHoldingWalletAmount = (splitTaxAmount * 10) / 100;\r\n            uint256 remainingRewardProgramAmount = splitTaxAmount -\r\n                rewardHoldingWalletAmount;\r\n\r\n            carboncc.transfer(\r\n                rewardHoldingWalletAddress,\r\n                rewardHoldingWalletAmount\r\n            );\r\n            emit rewardHoldingWalletAdd(msg.sender, rewardHoldingWalletAmount);\r\n\r\n            carboncc.transfer(\r\n                rewardProgramAddress,\r\n                remainingRewardProgramAmount\r\n            );\r\n            emit rewardProgram(msg.sender, remainingRewardProgramAmount);\r\n\r\n            carboncc.transfer(msg.sender, remainingReward);\r\n\r\n            emit RewardPaid(msg.sender, remainingReward);\r\n            distributedReward += reward;\r\n        }\r\n    }\r\n\r\n    function distributePrevCycleReward(\r\n        address[] memory addresses\r\n    ) public checkStart onlyOwner {\r\n        for (uint256 i = 0; i < addresses.length; i++) {\r\n            address currentAddress = addresses[i];\r\n            uint256 reward = earned(currentAddress);\r\n            if (reward > 0) {\r\n                rewardPerTokenStored = rewardPerToken();\r\n                lastUpdateTime = lastTimeRewardApplicable();\r\n                rewards[currentAddress] = earned(currentAddress);\r\n                userRewardPerTokenPaid[currentAddress] = rewardPerTokenStored;\r\n                rewards[currentAddress] = 0;\r\n                pendingRewards[currentAddress] += reward;\r\n                distributedReward += reward;\r\n            }\r\n        }\r\n    }\r\n\r\n    function setReward(\r\n        uint256 initamount,\r\n        uint256 duration,\r\n        bool force\r\n    ) public updateReward(address(0)) onlyOwner returns (uint) {\r\n        if (!force) {\r\n            require(distributedReward == initreward, \"Not All Distributed\");\r\n        }\r\n        require(block.timestamp >= periodFinish, \"Not End\");\r\n        initreward = initamount;\r\n        rewardRate = initamount.div(duration);\r\n        periodFinish = periodFinish + duration;\r\n        emit RewardAdded(initamount);\r\n        distributedReward = 0;\r\n        return periodFinish;\r\n    }\r\n\r\n    function notifyStartTime(\r\n        uint256 StartTime\r\n    ) external onlyOwner updateReward(address(0)) {\r\n        //Start\r\n        require(started == false, \"Already started\");\r\n        started = true;\r\n        lastUpdateTime = StartTime;\r\n        periodFinish = StartTime;\r\n    }\r\n\r\n    function setAddress(\r\n        address _CCC,\r\n        address _nftToken,\r\n        address _lpFeeAddress,\r\n        address _sponsorRewardAddress1,\r\n        address _sponsorRewardAddress2,\r\n        address _treasuryAddress,\r\n        address _rewardProgramAddress,\r\n        address _rewardHoldingWalletAddress\r\n    ) external onlyOwner {\r\n        carboncc = IERC20(_CCC);\r\n        nftToken = IERC721(_nftToken);\r\n        lpFeeAddress = _lpFeeAddress;\r\n        sponsorRewardAddress1 = _sponsorRewardAddress1;\r\n        sponsorRewardAddress2 = _sponsorRewardAddress2;\r\n        treasuryAddress = _treasuryAddress;\r\n        rewardProgramAddress = _rewardProgramAddress;\r\n        rewardHoldingWalletAddress = _rewardHoldingWalletAddress;\r\n    }\r\n\r\n    modifier updateReward(address account) {\r\n        rewardPerTokenStored = rewardPerToken();\r\n        lastUpdateTime = lastTimeRewardApplicable();\r\n        if (account != address(0)) {\r\n            rewards[account] = earned(account);\r\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\r\n        }\r\n        _;\r\n    }\r\n\r\n    function lastTimeRewardApplicable() public view returns (uint256) {\r\n        return Math.min(block.timestamp, periodFinish);\r\n    }\r\n\r\n    function rewardPerToken() public view returns (uint256) {\r\n        if (totalSupply() == 0) {\r\n            return rewardPerTokenStored;\r\n        }\r\n        return\r\n            rewardPerTokenStored.add(\r\n                lastTimeRewardApplicable()\r\n                    .sub(lastUpdateTime)\r\n                    .mul(rewardRate)\r\n                    .mul(1e18)\r\n                    .div(totalSupply())\r\n            );\r\n    }\r\n\r\n    function earned(address account) public view returns (uint256) {\r\n        return\r\n            balanceOf(account)\r\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\r\n                .div(1e18)\r\n                .add(rewards[account]);\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    //trigger when detected exploit happening\r\n    function emergencyWithdrawalnft(\r\n        uint[] calldata tokenIds\r\n    ) external onlyOwner {\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            uint _tokenId = tokenIds[i];\r\n            unstakeFromMasterChef(_tokenId);\r\n\r\n            // Transfer NFT token back to the staker\r\n            nftToken.safeTransferFrom(\r\n                address(this),\r\n                stakedNFTs[_tokenId],\r\n                _tokenId\r\n            );\r\n\r\n            // Update the staked NFTs mapping\r\n            stakedNFTs[_tokenId] = address(0);\r\n            if (earned(msg.sender) > 0) {\r\n                Claim();\r\n            }\r\n            removeStakeLP(_tokenId);\r\n            emit NFTUnstaked(msg.sender, _tokenId);\r\n        }\r\n    }\r\n\r\n    //trigger when detected exploit happening\r\n    function emergencywithdrawaltoken(\r\n        IERC20 token,\r\n        uint256 amount\r\n    ) external onlyOwner {\r\n        token.transfer(msg.sender, amount);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"Harvested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"NFTStaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"NFTUnstaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"RewardPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TotalPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TressuryPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"VaultFarmHarvestFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"lpFeeAdd1\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"lpFeeAdd2\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rewardHoldingWalletAdd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rewardProgram\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sponsorReward1\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sponsorReward2\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"treasuryAdd\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"Claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cakeToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"calTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"carboncc\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collect\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"decreaseLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"distributePrevCycleReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributedReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"earned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"emergencyWithdrawalnft\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"emergencywithdrawaltoken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"eth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getLiquidity\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenAB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"harvestTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initreward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastTimeRewardApplicable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastUpdateTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquiditytax\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpFeeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpFeeTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"masterchef\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftToken\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"StartTime\",\"type\":\"uint256\"}],\"name\":\"notifyStartTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pendingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"periodFinish\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardHoldingWalletAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerTokenStored\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardProgramAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_CCC\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nftToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_lpFeeAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sponsorRewardAddress1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sponsorRewardAddress2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasuryAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardProgramAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardHoldingWalletAddress\",\"type\":\"address\"}],\"name\":\"setAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"initamount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"force\",\"type\":\"bool\"}],\"name\":\"setReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sponsorRewardAddress1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sponsorRewardAddress2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sponsorTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"stakeTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakedNFTs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"started\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"starttime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxdenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"unstakeTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userRewardPerTokenPaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wbnb\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wbnbToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ETHBNBPCSv3Vault", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://78ee30dc40cb97cf693b73ae8588d2956353c473b0482b1a73d0fa7dd02f11b2"}