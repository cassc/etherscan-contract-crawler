{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/CipherCore_BNB_T.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport \\\"./MerkleTreeWithHistory.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\n\\ninterface IVerifier {\\n    function verifyProof(\\n        uint[2] memory a,\\n        uint[2][2] memory b,\\n        uint[2] memory c,\\n        uint[5] memory input\\n    ) external pure returns (bool r);\\n}\\n\\ncontract CipherCore_BNB_T is MerkleTreeWithHistory, ReentrancyGuard {\\n    \\n    mapping(bytes32 => bool) public nullifiers;\\n    mapping(bytes32 => bool) public commitments;\\n\\n    IVerifier public immutable verifier;\\n    uint public denomination = 0.1 ether;\\n    uint public platFormFee = 0.0005 ether;   // 0.5%\\n    address payable public platFormAddress;  \\n\\n    event Deposit(\\n        bytes32 indexed commitment,\\n        uint32 leafIndex,\\n        uint256 timestamp \\n    );\\n    \\n    event Withdrawal(address to, bytes32 _nullifier, address relayer, uint256 fee);\\n    event Check(bytes32 _root);\\n\\n    constructor(\\n        uint32 _levels,\\n        IHasher _hasher,\\n        IVerifier _verifier\\n    ) MerkleTreeWithHistory(_levels, _hasher) {\\n        verifier = _verifier; \\n    }\\n\\n\\n    function deposit(uint256 _commitment) external payable nonReentrant  {\\n        require(!commitments[bytes32(_commitment)], \\\"commitment already submitted\\\");\\n        require(denomination == msg.value, \\\"invalid deposit amount\\\");\\n        commitments[bytes32(_commitment)] = true;\\n        uint32 insertedIndex = _insert(bytes32(_commitment));\\n        emit Deposit(bytes32(_commitment), insertedIndex, block.timestamp);\\n    }\\n\\n    function withdraw(uint256 _nullifier,\\n        uint256 _root,\\n        uint[2] memory _proof_a,\\n        uint[2][2] memory _proof_b,\\n        uint[2] memory _proof_c,\\n        uint256 _relayerFee,\\n        address payable _relayer,\\n        address payable _recipient) external nonReentrant {   \\n\\n        _nullify(bytes32(_nullifier),bytes32(_root),_proof_a,_proof_b,_proof_c, _relayerFee, _relayer, _recipient);\\n        require(_relayerFee <= denomination / 2, \\\"Fee too high\\\");\\n        \\n        (bool success, ) = _recipient.call{ value: denomination - _relayerFee - platFormFee }(\\\"\\\");\\n        require(success, \\\"payment to recipient failed\\\");\\n\\n        if (_relayerFee > 0) {\\n            (success, ) = _relayer.call{ value: _relayerFee }(\\\"\\\");\\n            require(success, \\\"payment to relayer failed\\\");\\n        }\\n\\n        if (platFormFee > 0) {\\n            (success, ) = platFormAddress.call{ value: platFormFee }(\\\"\\\");\\n            require(success, \\\"payment to feeAddress failed\\\");\\n        }\\n\\n        emit Check(bytes32(_root));\\n        emit Withdrawal(_recipient, bytes32(_nullifier), _relayer, _relayerFee);\\n    }\\n\\n    function _nullify(\\n        bytes32 _nullifier,\\n        bytes32 _root,\\n        uint[2] memory _proof_a,\\n        uint[2][2] memory _proof_b,\\n        uint[2] memory _proof_c,\\n        uint256 _relayerFee,\\n        address _relayer,\\n        address _recipient\\n    ) internal {\\n        require(!nullifiers[_nullifier], \\\"nullifier already submitted\\\");\\n        require(isKnownRoot(_root), \\\"cant't find your merkle root\\\");\\n        require(\\n            verifier.verifyProof(\\n                _proof_a,\\n                _proof_b,\\n                _proof_c,\\n                [uint256(_nullifier), uint256(_root), uint256(_recipient), uint256(_relayer), uint256(_relayerFee)]\\n            ),\\n            \\\"Invalid proof\\\"\\n        );\\n\\n        nullifiers[_nullifier] = true;        \\n    }\\n\\n    function isSpent(bytes32 _nullifierHash) public view returns (bool) {\\n        return nullifiers[_nullifierHash];\\n    }\\n\\n    function setPlatformParamas(address payable _platformAddress, uint _platformFee) external {\\n        require(_platformFee <= denomination / 2 , \\\"fee too high\\\");\\n        if (platFormAddress != address(0)) {\\n            require(msg.sender == platFormAddress, \\\"Unauthorized!\\\");\\n        }\\n        platFormAddress = _platformAddress;\\n        platFormFee = _platformFee;\\n    }\\n\\n\\n}\\n\"\r\n    },\r\n    \"contracts/MerkleTreeWithHistory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\n\\ninterface IHasher {\\n    function MiMCSponge(\\n        uint256 in_xL,\\n        uint256 in_xR,\\n        uint256 k\\n    ) external pure returns (uint256 xL, uint256 xR);\\n}\\n\\ncontract MerkleTreeWithHistory {\\n    uint256 public constant FIELD_SIZE =\\n        21888242871839275222246405745257275088548364400416034343698204186575808495617;\\n    uint256 public constant ZERO_VALUE =\\n        21663839004416932945382355908790599225266501822907911457504978515578255421292; \\n    IHasher public immutable hasher;\\n\\n    uint32 public levels;\\n\\n    // the following variables are made public for easier testing and debugging and\\n    // are not supposed to be accessed in regular code\\n\\n    // filledSubtrees and roots could be bytes32[size], but using mappings makes it cheaper because\\n    // it removes index range check on every interaction\\n    mapping(uint256 => bytes32) public filledSubtrees;\\n    mapping(uint256 => bytes32) public roots;\\n    uint32 public constant ROOT_HISTORY_SIZE = 30;\\n    uint32 public currentRootIndex = 0;\\n    uint32 public nextIndex = 0;\\n\\n    constructor(uint32 _levels, IHasher _hasher) {\\n        require(_levels > 0, \\\"_levels should be greater than zero\\\");\\n        require(_levels < 32, \\\"_levels should be less than 32\\\");\\n        levels = _levels;\\n        hasher = _hasher;\\n\\n        for (uint32 i = 0; i < _levels; i++) {\\n            filledSubtrees[i] = zeros(i);\\n        }\\n\\n        roots[0] = zeros(_levels - 1);\\n    }\\n\\n    /**\\n    @dev Hash 2 tree leaves, returns MiMC(_left, _right)\\n    */\\n    function hashLeftRight(\\n        uint256 _left,\\n        uint256 _right\\n    ) public view returns (bytes32) {\\n        require(\\n            _left < FIELD_SIZE,\\n            \\\"_left should be inside the field\\\"\\n        );\\n        require(\\n            _right < FIELD_SIZE,\\n            \\\"_right should be inside the field\\\"\\n        );\\n        uint256 R = _left;\\n        uint256 C = 0;\\n        (R, C) = hasher.MiMCSponge(R, C, 0);\\n        R = addmod(R, _right, FIELD_SIZE);\\n        (R, C) = hasher.MiMCSponge(R, C, 0);\\n        return bytes32(R);\\n    }\\n\\n    function _insert(bytes32 _leaf) internal returns (uint32 index) {\\n        uint32 _nextIndex = nextIndex;\\n        require(\\n            _nextIndex != uint32(2) ** levels,\\n            \\\"Merkle tree is full. No more leaves can be added\\\"\\n        );\\n        uint32 currentIndex = _nextIndex;\\n        bytes32 currentLevelHash = _leaf;\\n        bytes32 left;\\n        bytes32 right;\\n\\n        for (uint32 i = 0; i < levels; i++) {\\n            if (currentIndex % 2 == 0) {\\n                left = currentLevelHash;\\n                right = zeros(i);\\n                filledSubtrees[i] = currentLevelHash;\\n            } else {\\n                left = filledSubtrees[i];\\n                right = currentLevelHash;\\n            }\\n            currentLevelHash = hashLeftRight(uint256(left), uint256(right));\\n            currentIndex /= 2;\\n        }\\n\\n        uint32 newRootIndex = (currentRootIndex + 1) % ROOT_HISTORY_SIZE;\\n        currentRootIndex = newRootIndex;\\n        roots[newRootIndex] = currentLevelHash;\\n        nextIndex = _nextIndex + 1;\\n        return _nextIndex;\\n    }\\n\\n    /**\\n    @dev Whether the root is present in the root history\\n    */\\n    function isKnownRoot(bytes32 _root) public view returns (bool) {\\n        if (_root == 0) {\\n            return false;\\n        }\\n        uint32 _currentRootIndex = currentRootIndex;\\n        uint32 i = _currentRootIndex;\\n        do {\\n            if (_root == roots[i]) {\\n                return true;\\n            }\\n            if (i == 0) {\\n                i = ROOT_HISTORY_SIZE;\\n            }\\n            i--;\\n        } while (i != _currentRootIndex);\\n        return false;\\n    }\\n\\n    /**\\n    @dev Returns the last root\\n    */\\n    function getLastRoot() public view returns (bytes32) {\\n        return roots[currentRootIndex];\\n    }\\n\\n    /// @dev provides Zero (Empty) elements for a MiMC MerkleTree. Up to 32 levels\\n    function zeros(uint256 i) public pure returns (bytes32) {\\n        if (i == 0)\\n            return\\n                bytes32(\\n                    0x2fe54c60d3acabf3343a35b6eba15db4821b340f76e741e2249685ed4899af6c\\n                );\\n        else if (i == 1)\\n            return\\n                bytes32(\\n                    0x256a6135777eee2fd26f54b8b7037a25439d5235caee224154186d2b8a52e31d\\n                );\\n        else if (i == 2)\\n            return\\n                bytes32(\\n                    0x1151949895e82ab19924de92c40a3d6f7bcb60d92b00504b8199613683f0c200\\n                );\\n        else if (i == 3)\\n            return\\n                bytes32(\\n                    0x20121ee811489ff8d61f09fb89e313f14959a0f28bb428a20dba6b0b068b3bdb\\n                );\\n        else if (i == 4)\\n            return\\n                bytes32(\\n                    0x0a89ca6ffa14cc462cfedb842c30ed221a50a3d6bf022a6a57dc82ab24c157c9\\n                );\\n        else if (i == 5)\\n            return\\n                bytes32(\\n                    0x24ca05c2b5cd42e890d6be94c68d0689f4f21c9cec9c0f13fe41d566dfb54959\\n                );\\n        else if (i == 6)\\n            return\\n                bytes32(\\n                    0x1ccb97c932565a92c60156bdba2d08f3bf1377464e025cee765679e604a7315c\\n                );\\n        else if (i == 7)\\n            return\\n                bytes32(\\n                    0x19156fbd7d1a8bf5cba8909367de1b624534ebab4f0f79e003bccdd1b182bdb4\\n                );\\n        else if (i == 8)\\n            return\\n                bytes32(\\n                    0x261af8c1f0912e465744641409f622d466c3920ac6e5ff37e36604cb11dfff80\\n                );\\n        else if (i == 9)\\n            return\\n                bytes32(\\n                    0x0058459724ff6ca5a1652fcbc3e82b93895cf08e975b19beab3f54c217d1c007\\n                );\\n        else if (i == 10)\\n            return\\n                bytes32(\\n                    0x1f04ef20dee48d39984d8eabe768a70eafa6310ad20849d4573c3c40c2ad1e30\\n                );\\n        else if (i == 11)\\n            return\\n                bytes32(\\n                    0x1bea3dec5dab51567ce7e200a30f7ba6d4276aeaa53e2686f962a46c66d511e5\\n                );\\n        else if (i == 12)\\n            return\\n                bytes32(\\n                    0x0ee0f941e2da4b9e31c3ca97a40d8fa9ce68d97c084177071b3cb46cd3372f0f\\n                );\\n        else if (i == 13)\\n            return\\n                bytes32(\\n                    0x1ca9503e8935884501bbaf20be14eb4c46b89772c97b96e3b2ebf3a36a948bbd\\n                );\\n        else if (i == 14)\\n            return\\n                bytes32(\\n                    0x133a80e30697cd55d8f7d4b0965b7be24057ba5dc3da898ee2187232446cb108\\n                );\\n        else if (i == 15)\\n            return\\n                bytes32(\\n                    0x13e6d8fc88839ed76e182c2a779af5b2c0da9dd18c90427a644f7e148a6253b6\\n                );\\n        else if (i == 16)\\n            return\\n                bytes32(\\n                    0x1eb16b057a477f4bc8f572ea6bee39561098f78f15bfb3699dcbb7bd8db61854\\n                );\\n        else if (i == 17)\\n            return\\n                bytes32(\\n                    0x0da2cb16a1ceaabf1c16b838f7a9e3f2a3a3088d9e0a6debaa748114620696ea\\n                );\\n        else if (i == 18)\\n            return\\n                bytes32(\\n                    0x24a3b3d822420b14b5d8cb6c28a574f01e98ea9e940551d2ebd75cee12649f9d\\n                );\\n        else if (i == 19)\\n            return\\n                bytes32(\\n                    0x198622acbd783d1b0d9064105b1fc8e4d8889de95c4c519b3f635809fe6afc05\\n                );\\n        else if (i == 20)\\n            return\\n                bytes32(\\n                    0x29d7ed391256ccc3ea596c86e933b89ff339d25ea8ddced975ae2fe30b5296d4\\n                );\\n        else if (i == 21)\\n            return\\n                bytes32(\\n                    0x19be59f2f0413ce78c0c3703a3a5451b1d7f39629fa33abd11548a76065b2967\\n                );\\n        else if (i == 22)\\n            return\\n                bytes32(\\n                    0x1ff3f61797e538b70e619310d33f2a063e7eb59104e112e95738da1254dc3453\\n                );\\n        else if (i == 23)\\n            return\\n                bytes32(\\n                    0x10c16ae9959cf8358980d9dd9616e48228737310a10e2b6b731c1a548f036c48\\n                );\\n        else if (i == 24)\\n            return\\n                bytes32(\\n                    0x0ba433a63174a90ac20992e75e3095496812b652685b5e1a2eae0b1bf4e8fcd1\\n                );\\n        else if (i == 25)\\n            return\\n                bytes32(\\n                    0x019ddb9df2bc98d987d0dfeca9d2b643deafab8f7036562e627c3667266a044c\\n                );\\n        else if (i == 26)\\n            return\\n                bytes32(\\n                    0x2d3c88b23175c5a5565db928414c66d1912b11acf974b2e644caaac04739ce99\\n                );\\n        else if (i == 27)\\n            return\\n                bytes32(\\n                    0x2eab55f6ae4e66e32c5189eed5c470840863445760f5ed7e7b69b2a62600f354\\n                );\\n        else if (i == 28)\\n            return\\n                bytes32(\\n                    0x002df37a2642621802383cf952bf4dd1f32e05433beeb1fd41031fb7eace979d\\n                );\\n        else if (i == 29)\\n            return\\n                bytes32(\\n                    0x104aeb41435db66c3e62feccc1d6f5d98d0a0ed75d1374db457cf462e3a1f427\\n                );\\n        else if (i == 30)\\n            return\\n                bytes32(\\n                    0x1f3c6fd858e9a7d4b0d1f38e256a09d81d5a5e3c963987e2d4b814cfab7c6ebb\\n                );\\n        else if (i == 31)\\n            return\\n                bytes32(\\n                    0x2c7a07d20dff79d01fecedc1134284a8d08436606c93693b67e333f671bf69cc\\n                );\\n        else revert(\\\"Index out of bounds\\\");\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_levels\",\"type\":\"uint32\"},{\"internalType\":\"contract IHasher\",\"name\":\"_hasher\",\"type\":\"address\"},{\"internalType\":\"contract IVerifier\",\"name\":\"_verifier\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_root\",\"type\":\"bytes32\"}],\"name\":\"Check\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"leafIndex\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_nullifier\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FIELD_SIZE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROOT_HISTORY_SIZE\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ZERO_VALUE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"commitments\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentRootIndex\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"denomination\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_commitment\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"filledSubtrees\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_left\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_right\",\"type\":\"uint256\"}],\"name\":\"hashLeftRight\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hasher\",\"outputs\":[{\"internalType\":\"contract IHasher\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_root\",\"type\":\"bytes32\"}],\"name\":\"isKnownRoot\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_nullifierHash\",\"type\":\"bytes32\"}],\"name\":\"isSpent\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"levels\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextIndex\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"nullifiers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"platFormAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"platFormFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"roots\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_platformAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_platformFee\",\"type\":\"uint256\"}],\"name\":\"setPlatformParamas\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"verifier\",\"outputs\":[{\"internalType\":\"contract IVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nullifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_root\",\"type\":\"uint256\"},{\"internalType\":\"uint256[2]\",\"name\":\"_proof_a\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"_proof_b\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"_proof_c\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256\",\"name\":\"_relayerFee\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_relayer\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"zeros\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "CipherCore_BNB_T", "CompilerVersion": "v0.7.0+commit.9e61f92b", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000014000000000000000000000000cc8fdebc3a1097320227b7a0b659aa0936a3abe600000000000000000000000063eac0e6fcd3292ffd9a9d73344cea40f7cca34e", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}