{"SourceCode": "// SPDX-License-Identifier: MIT\r\n/*\r\n * ABDK Math 64.64 Smart Contract Library.  Copyright \u00a9 2019 by ABDK Consulting.\r\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\r\n */\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * Smart contract library of mathematical functions operating with signed\r\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\r\n * basically a simple fraction whose numerator is signed 128-bit integer and\r\n * denominator is 2^64.  As long as denominator is always the same, there is no\r\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\r\n * represented by int128 type holding only the numerator.\r\n */\r\nlibrary ABDKMath64x64 {\r\n    /*\r\n   * Minimum value signed 64.64-bit fixed point number may have. \r\n   */\r\n    int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\r\n\r\n    /*\r\n   * Maximum value signed 64.64-bit fixed point number may have. \r\n   */\r\n    int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n    /**\r\n     * Convert signed 256-bit integer number into signed 64.64-bit fixed point\r\n     * number.  Revert on overflow.\r\n     *\r\n     * @param x signed 256-bit integer number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function fromInt(int256 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\r\n            return int128(x << 64);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert signed 64.64 fixed point number into signed 64-bit integer number\r\n     * rounding down.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return signed 64-bit integer number\r\n     */\r\n    function toInt(int128 x) internal pure returns (int64) {\r\n        unchecked {\r\n            return int64(x >> 64);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\r\n     * number.  Revert on overflow.\r\n     *\r\n     * @param x unsigned 256-bit integer number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function fromUInt(uint256 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x <= 0x7FFFFFFFFFFFFFFF);\r\n            return int128(int256(x << 64));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert signed 64.64 fixed point number into unsigned 64-bit integer\r\n     * number rounding down.  Revert on underflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return unsigned 64-bit integer number\r\n     */\r\n    function toUInt(int128 x) internal pure returns (uint64) {\r\n        unchecked {\r\n            require(x >= 0);\r\n            return uint64(uint128(x >> 64));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\r\n     * number rounding down.  Revert on overflow.\r\n     *\r\n     * @param x signed 128.128-bin fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function from128x128(int256 x) internal pure returns (int128) {\r\n        unchecked {\r\n            int256 result = x >> 64;\r\n            require(result >= MIN_64x64 && result <= MAX_64x64);\r\n            return int128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert signed 64.64 fixed point number into signed 128.128 fixed point\r\n     * number.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return signed 128.128 fixed point number\r\n     */\r\n    function to128x128(int128 x) internal pure returns (int256) {\r\n        unchecked {\r\n            return int256(x) << 64;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate x + y.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @param y signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function add(int128 x, int128 y) internal pure returns (int128) {\r\n        unchecked {\r\n            int256 result = int256(x) + y;\r\n            require(result >= MIN_64x64 && result <= MAX_64x64);\r\n            return int128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate x - y.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @param y signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function sub(int128 x, int128 y) internal pure returns (int128) {\r\n        unchecked {\r\n            int256 result = int256(x) - y;\r\n            require(result >= MIN_64x64 && result <= MAX_64x64);\r\n            return int128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate x * y rounding down.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @param y signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function mul(int128 x, int128 y) internal pure returns (int128) {\r\n        unchecked {\r\n            int256 result = int256(x) * y >> 64;\r\n            require(result >= MIN_64x64 && result <= MAX_64x64);\r\n            return int128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\r\n     * number and y is signed 256-bit integer number.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64 fixed point number\r\n     * @param y signed 256-bit integer number\r\n     * @return signed 256-bit integer number\r\n     */\r\n    function muli(int128 x, int256 y) internal pure returns (int256) {\r\n        unchecked {\r\n            if (x == MIN_64x64) {\r\n                require(\r\n                    y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\r\n                        && y <= 0x1000000000000000000000000000000000000000000000000\r\n                );\r\n                return -y << 63;\r\n            } else {\r\n                bool negativeResult = false;\r\n                if (x < 0) {\r\n                    x = -x;\r\n                    negativeResult = true;\r\n                }\r\n                if (y < 0) {\r\n                    y = -y; // We rely on overflow behavior here\r\n                    negativeResult = !negativeResult;\r\n                }\r\n                uint256 absoluteResult = mulu(x, uint256(y));\r\n                if (negativeResult) {\r\n                    require(absoluteResult <= 0x8000000000000000000000000000000000000000000000000000000000000000);\r\n                    return -int256(absoluteResult); // We rely on overflow behavior here\r\n                } else {\r\n                    require(absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n                    return int256(absoluteResult);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate x * y rounding down, where x is signed 64.64 fixed point number\r\n     * and y is unsigned 256-bit integer number.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64 fixed point number\r\n     * @param y unsigned 256-bit integer number\r\n     * @return unsigned 256-bit integer number\r\n     */\r\n    function mulu(int128 x, uint256 y) internal pure returns (uint256) {\r\n        unchecked {\r\n            if (y == 0) return 0;\r\n\r\n            require(x >= 0);\r\n\r\n            uint256 lo = (uint256(int256(x)) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\r\n            uint256 hi = uint256(int256(x)) * (y >> 128);\r\n\r\n            require(hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n            hi <<= 64;\r\n\r\n            require(hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\r\n            return hi + lo;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate x / y rounding towards zero.  Revert on overflow or when y is\r\n     * zero.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @param y signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function div(int128 x, int128 y) internal pure returns (int128) {\r\n        unchecked {\r\n            require(y != 0);\r\n            int256 result = (int256(x) << 64) / y;\r\n            require(result >= MIN_64x64 && result <= MAX_64x64);\r\n            return int128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate x / y rounding towards zero, where x and y are signed 256-bit\r\n     * integer numbers.  Revert on overflow or when y is zero.\r\n     *\r\n     * @param x signed 256-bit integer number\r\n     * @param y signed 256-bit integer number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function divi(int256 x, int256 y) internal pure returns (int128) {\r\n        unchecked {\r\n            require(y != 0);\r\n\r\n            bool negativeResult = false;\r\n            if (x < 0) {\r\n                x = -x; // We rely on overflow behavior here\r\n                negativeResult = true;\r\n            }\r\n            if (y < 0) {\r\n                y = -y; // We rely on overflow behavior here\r\n                negativeResult = !negativeResult;\r\n            }\r\n            uint128 absoluteResult = divuu(uint256(x), uint256(y));\r\n            if (negativeResult) {\r\n                require(absoluteResult <= 0x80000000000000000000000000000000);\r\n                return -int128(absoluteResult); // We rely on overflow behavior here\r\n            } else {\r\n                require(absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n                return int128(absoluteResult); // We rely on overflow behavior here\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\r\n     * integer numbers.  Revert on overflow or when y is zero.\r\n     *\r\n     * @param x unsigned 256-bit integer number\r\n     * @param y unsigned 256-bit integer number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function divu(uint256 x, uint256 y) internal pure returns (int128) {\r\n        unchecked {\r\n            require(y != 0);\r\n            uint128 result = divuu(x, y);\r\n            require(result <= uint128(MAX_64x64));\r\n            return int128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate -x.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function neg(int128 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x != MIN_64x64);\r\n            return -x;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate |x|.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function abs(int128 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x != MIN_64x64);\r\n            return x < 0 ? -x : x;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\r\n     * zero.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function inv(int128 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x != 0);\r\n            int256 result = int256(0x100000000000000000000000000000000) / x;\r\n            require(result >= MIN_64x64 && result <= MAX_64x64);\r\n            return int128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @param y signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function avg(int128 x, int128 y) internal pure returns (int128) {\r\n        unchecked {\r\n            return int128((int256(x) + int256(y)) >> 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\r\n     * Revert on overflow or in case x * y is negative.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @param y signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function gavg(int128 x, int128 y) internal pure returns (int128) {\r\n        unchecked {\r\n            int256 m = int256(x) * int256(y);\r\n            require(m >= 0);\r\n            require(m < 0x4000000000000000000000000000000000000000000000000000000000000000);\r\n            return int128(sqrtu(uint256(m)));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\r\n     * and y is unsigned 256-bit integer number.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @param y uint256 value\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function pow(int128 x, uint256 y) internal pure returns (int128) {\r\n        unchecked {\r\n            bool negative = x < 0 && y & 1 == 1;\r\n\r\n            uint256 absX = uint128(x < 0 ? -x : x);\r\n            uint256 absResult;\r\n            absResult = 0x100000000000000000000000000000000;\r\n\r\n            if (absX <= 0x10000000000000000) {\r\n                absX <<= 63;\r\n                while (y != 0) {\r\n                    if (y & 0x1 != 0) {\r\n                        absResult = absResult * absX >> 127;\r\n                    }\r\n                    absX = absX * absX >> 127;\r\n\r\n                    if (y & 0x2 != 0) {\r\n                        absResult = absResult * absX >> 127;\r\n                    }\r\n                    absX = absX * absX >> 127;\r\n\r\n                    if (y & 0x4 != 0) {\r\n                        absResult = absResult * absX >> 127;\r\n                    }\r\n                    absX = absX * absX >> 127;\r\n\r\n                    if (y & 0x8 != 0) {\r\n                        absResult = absResult * absX >> 127;\r\n                    }\r\n                    absX = absX * absX >> 127;\r\n\r\n                    y >>= 4;\r\n                }\r\n\r\n                absResult >>= 64;\r\n            } else {\r\n                uint256 absXShift = 63;\r\n                if (absX < 0x1000000000000000000000000) {\r\n                    absX <<= 32;\r\n                    absXShift -= 32;\r\n                }\r\n                if (absX < 0x10000000000000000000000000000) {\r\n                    absX <<= 16;\r\n                    absXShift -= 16;\r\n                }\r\n                if (absX < 0x1000000000000000000000000000000) {\r\n                    absX <<= 8;\r\n                    absXShift -= 8;\r\n                }\r\n                if (absX < 0x10000000000000000000000000000000) {\r\n                    absX <<= 4;\r\n                    absXShift -= 4;\r\n                }\r\n                if (absX < 0x40000000000000000000000000000000) {\r\n                    absX <<= 2;\r\n                    absXShift -= 2;\r\n                }\r\n                if (absX < 0x80000000000000000000000000000000) {\r\n                    absX <<= 1;\r\n                    absXShift -= 1;\r\n                }\r\n\r\n                uint256 resultShift = 0;\r\n                while (y != 0) {\r\n                    require(absXShift < 64);\r\n\r\n                    if (y & 0x1 != 0) {\r\n                        absResult = absResult * absX >> 127;\r\n                        resultShift += absXShift;\r\n                        if (absResult > 0x100000000000000000000000000000000) {\r\n                            absResult >>= 1;\r\n                            resultShift += 1;\r\n                        }\r\n                    }\r\n                    absX = absX * absX >> 127;\r\n                    absXShift <<= 1;\r\n                    if (absX >= 0x100000000000000000000000000000000) {\r\n                        absX >>= 1;\r\n                        absXShift += 1;\r\n                    }\r\n\r\n                    y >>= 1;\r\n                }\r\n\r\n                require(resultShift < 64);\r\n                absResult >>= 64 - resultShift;\r\n            }\r\n            int256 result = negative ? -int256(absResult) : int256(absResult);\r\n            require(result >= MIN_64x64 && result <= MAX_64x64);\r\n            return int128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate sqrt (x) rounding down.  Revert if x < 0.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function sqrt(int128 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x >= 0);\r\n            return int128(sqrtu(uint256(int256(x)) << 64));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate binary logarithm of x.  Revert if x <= 0.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function log_2(int128 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x > 0);\r\n\r\n            int256 msb = 0;\r\n            int256 xc = x;\r\n            if (xc >= 0x10000000000000000) {\r\n                xc >>= 64;\r\n                msb += 64;\r\n            }\r\n            if (xc >= 0x100000000) {\r\n                xc >>= 32;\r\n                msb += 32;\r\n            }\r\n            if (xc >= 0x10000) {\r\n                xc >>= 16;\r\n                msb += 16;\r\n            }\r\n            if (xc >= 0x100) {\r\n                xc >>= 8;\r\n                msb += 8;\r\n            }\r\n            if (xc >= 0x10) {\r\n                xc >>= 4;\r\n                msb += 4;\r\n            }\r\n            if (xc >= 0x4) {\r\n                xc >>= 2;\r\n                msb += 2;\r\n            }\r\n            if (xc >= 0x2) msb += 1; // No need to shift xc anymore\r\n\r\n            int256 result = msb - 64 << 64;\r\n            uint256 ux = uint256(int256(x)) << uint256(127 - msb);\r\n            for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\r\n                ux *= ux;\r\n                uint256 b = ux >> 255;\r\n                ux >>= 127 + b;\r\n                result += bit * int256(b);\r\n            }\r\n\r\n            return int128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate natural logarithm of x.  Revert if x <= 0.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function ln(int128 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x > 0);\r\n\r\n            return int128(int256(uint256(int256(log_2(x))) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF >> 128));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate binary exponent of x.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function exp_2(int128 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x < 0x400000000000000000); // Overflow\r\n\r\n            if (x < -0x400000000000000000) return 0; // Underflow\r\n\r\n            uint256 result = 0x80000000000000000000000000000000;\r\n\r\n            if (x & 0x8000000000000000 > 0) {\r\n                result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\r\n            }\r\n            if (x & 0x4000000000000000 > 0) {\r\n                result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\r\n            }\r\n            if (x & 0x2000000000000000 > 0) {\r\n                result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\r\n            }\r\n            if (x & 0x1000000000000000 > 0) {\r\n                result = result * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\r\n            }\r\n            if (x & 0x800000000000000 > 0) {\r\n                result = result * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\r\n            }\r\n            if (x & 0x400000000000000 > 0) {\r\n                result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\r\n            }\r\n            if (x & 0x200000000000000 > 0) {\r\n                result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\r\n            }\r\n            if (x & 0x100000000000000 > 0) {\r\n                result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\r\n            }\r\n            if (x & 0x80000000000000 > 0) {\r\n                result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\r\n            }\r\n            if (x & 0x40000000000000 > 0) {\r\n                result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\r\n            }\r\n            if (x & 0x20000000000000 > 0) {\r\n                result = result * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\r\n            }\r\n            if (x & 0x10000000000000 > 0) {\r\n                result = result * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\r\n            }\r\n            if (x & 0x8000000000000 > 0) {\r\n                result = result * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\r\n            }\r\n            if (x & 0x4000000000000 > 0) {\r\n                result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\r\n            }\r\n            if (x & 0x2000000000000 > 0) {\r\n                result = result * 0x1000162E525EE054754457D5995292026 >> 128;\r\n            }\r\n            if (x & 0x1000000000000 > 0) {\r\n                result = result * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\r\n            }\r\n            if (x & 0x800000000000 > 0) {\r\n                result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\r\n            }\r\n            if (x & 0x400000000000 > 0) {\r\n                result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\r\n            }\r\n            if (x & 0x200000000000 > 0) {\r\n                result = result * 0x10000162E43F4F831060E02D839A9D16D >> 128;\r\n            }\r\n            if (x & 0x100000000000 > 0) {\r\n                result = result * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\r\n            }\r\n            if (x & 0x80000000000 > 0) {\r\n                result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\r\n            }\r\n            if (x & 0x40000000000 > 0) {\r\n                result = result * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\r\n            }\r\n            if (x & 0x20000000000 > 0) {\r\n                result = result * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\r\n            }\r\n            if (x & 0x10000000000 > 0) {\r\n                result = result * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\r\n            }\r\n            if (x & 0x8000000000 > 0) {\r\n                result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\r\n            }\r\n            if (x & 0x4000000000 > 0) {\r\n                result = result * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\r\n            }\r\n            if (x & 0x2000000000 > 0) {\r\n                result = result * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\r\n            }\r\n            if (x & 0x1000000000 > 0) {\r\n                result = result * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\r\n            }\r\n            if (x & 0x800000000 > 0) {\r\n                result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\r\n            }\r\n            if (x & 0x400000000 > 0) {\r\n                result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\r\n            }\r\n            if (x & 0x200000000 > 0) {\r\n                result = result * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\r\n            }\r\n            if (x & 0x100000000 > 0) {\r\n                result = result * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\r\n            }\r\n            if (x & 0x80000000 > 0) {\r\n                result = result * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\r\n            }\r\n            if (x & 0x40000000 > 0) {\r\n                result = result * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\r\n            }\r\n            if (x & 0x20000000 > 0) {\r\n                result = result * 0x100000000162E42FEFB2FED257559BDAA >> 128;\r\n            }\r\n            if (x & 0x10000000 > 0) {\r\n                result = result * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\r\n            }\r\n            if (x & 0x8000000 > 0) {\r\n                result = result * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\r\n            }\r\n            if (x & 0x4000000 > 0) {\r\n                result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\r\n            }\r\n            if (x & 0x2000000 > 0) {\r\n                result = result * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\r\n            }\r\n            if (x & 0x1000000 > 0) {\r\n                result = result * 0x10000000000B17217F7D20CF927C8E94C >> 128;\r\n            }\r\n            if (x & 0x800000 > 0) {\r\n                result = result * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\r\n            }\r\n            if (x & 0x400000 > 0) {\r\n                result = result * 0x100000000002C5C85FDF477B662B26945 >> 128;\r\n            }\r\n            if (x & 0x200000 > 0) {\r\n                result = result * 0x10000000000162E42FEFA3AE53369388C >> 128;\r\n            }\r\n            if (x & 0x100000 > 0) {\r\n                result = result * 0x100000000000B17217F7D1D351A389D40 >> 128;\r\n            }\r\n            if (x & 0x80000 > 0) {\r\n                result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\r\n            }\r\n            if (x & 0x40000 > 0) {\r\n                result = result * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\r\n            }\r\n            if (x & 0x20000 > 0) {\r\n                result = result * 0x100000000000162E42FEFA39FE95583C2 >> 128;\r\n            }\r\n            if (x & 0x10000 > 0) {\r\n                result = result * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\r\n            }\r\n            if (x & 0x8000 > 0) {\r\n                result = result * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\r\n            }\r\n            if (x & 0x4000 > 0) {\r\n                result = result * 0x10000000000002C5C85FDF473E242EA38 >> 128;\r\n            }\r\n            if (x & 0x2000 > 0) {\r\n                result = result * 0x1000000000000162E42FEFA39F02B772C >> 128;\r\n            }\r\n            if (x & 0x1000 > 0) {\r\n                result = result * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\r\n            }\r\n            if (x & 0x800 > 0) {\r\n                result = result * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\r\n            }\r\n            if (x & 0x400 > 0) {\r\n                result = result * 0x100000000000002C5C85FDF473DEA871F >> 128;\r\n            }\r\n            if (x & 0x200 > 0) {\r\n                result = result * 0x10000000000000162E42FEFA39EF44D91 >> 128;\r\n            }\r\n            if (x & 0x100 > 0) {\r\n                result = result * 0x100000000000000B17217F7D1CF79E949 >> 128;\r\n            }\r\n            if (x & 0x80 > 0) {\r\n                result = result * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\r\n            }\r\n            if (x & 0x40 > 0) {\r\n                result = result * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\r\n            }\r\n            if (x & 0x20 > 0) {\r\n                result = result * 0x100000000000000162E42FEFA39EF366F >> 128;\r\n            }\r\n            if (x & 0x10 > 0) {\r\n                result = result * 0x1000000000000000B17217F7D1CF79AFA >> 128;\r\n            }\r\n            if (x & 0x8 > 0) {\r\n                result = result * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\r\n            }\r\n            if (x & 0x4 > 0) {\r\n                result = result * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\r\n            }\r\n            if (x & 0x2 > 0) {\r\n                result = result * 0x1000000000000000162E42FEFA39EF358 >> 128;\r\n            }\r\n            if (x & 0x1 > 0) {\r\n                result = result * 0x10000000000000000B17217F7D1CF79AB >> 128;\r\n            }\r\n\r\n            result >>= uint256(int256(63 - (x >> 64)));\r\n            require(result <= uint256(int256(MAX_64x64)));\r\n\r\n            return int128(int256(result));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate natural exponent of x.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function exp(int128 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x < 0x400000000000000000); // Overflow\r\n\r\n            if (x < -0x400000000000000000) return 0; // Underflow\r\n\r\n            return exp_2(int128(int256(x) * 0x171547652B82FE1777D0FFDA0D23A7D12 >> 128));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\r\n     * integer numbers.  Revert on overflow or when y is zero.\r\n     *\r\n     * @param x unsigned 256-bit integer number\r\n     * @param y unsigned 256-bit integer number\r\n     * @return unsigned 64.64-bit fixed point number\r\n     */\r\n    function divuu(uint256 x, uint256 y) private pure returns (uint128) {\r\n        unchecked {\r\n            require(y != 0);\r\n\r\n            uint256 result;\r\n\r\n            if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\r\n                result = (x << 64) / y;\r\n            } else {\r\n                uint256 msb = 192;\r\n                uint256 xc = x >> 192;\r\n                if (xc >= 0x100000000) {\r\n                    xc >>= 32;\r\n                    msb += 32;\r\n                }\r\n                if (xc >= 0x10000) {\r\n                    xc >>= 16;\r\n                    msb += 16;\r\n                }\r\n                if (xc >= 0x100) {\r\n                    xc >>= 8;\r\n                    msb += 8;\r\n                }\r\n                if (xc >= 0x10) {\r\n                    xc >>= 4;\r\n                    msb += 4;\r\n                }\r\n                if (xc >= 0x4) {\r\n                    xc >>= 2;\r\n                    msb += 2;\r\n                }\r\n                if (xc >= 0x2) msb += 1; // No need to shift xc anymore\r\n\r\n                result = (x << 255 - msb) / ((y - 1 >> msb - 191) + 1);\r\n                require(result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\r\n                uint256 hi = result * (y >> 128);\r\n                uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\r\n                uint256 xh = x >> 192;\r\n                uint256 xl = x << 64;\r\n\r\n                if (xl < lo) xh -= 1;\r\n                xl -= lo; // We rely on overflow behavior here\r\n                lo = hi << 128;\r\n                if (xl < lo) xh -= 1;\r\n                xl -= lo; // We rely on overflow behavior here\r\n\r\n                result += xh == hi >> 128 ? xl / y : 1;\r\n            }\r\n\r\n            require(result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n            return uint128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\r\n     * number.\r\n     *\r\n     * @param x unsigned 256-bit integer number\r\n     * @return unsigned 128-bit integer number\r\n     */\r\n    function sqrtu(uint256 x) private pure returns (uint128) {\r\n        unchecked {\r\n            if (x == 0) {\r\n                return 0;\r\n            } else {\r\n                uint256 xx = x;\r\n                uint256 r = 1;\r\n                if (xx >= 0x100000000000000000000000000000000) {\r\n                    xx >>= 128;\r\n                    r <<= 64;\r\n                }\r\n                if (xx >= 0x10000000000000000) {\r\n                    xx >>= 64;\r\n                    r <<= 32;\r\n                }\r\n                if (xx >= 0x100000000) {\r\n                    xx >>= 32;\r\n                    r <<= 16;\r\n                }\r\n                if (xx >= 0x10000) {\r\n                    xx >>= 16;\r\n                    r <<= 8;\r\n                }\r\n                if (xx >= 0x100) {\r\n                    xx >>= 8;\r\n                    r <<= 4;\r\n                }\r\n                if (xx >= 0x10) {\r\n                    xx >>= 4;\r\n                    r <<= 2;\r\n                }\r\n                if (xx >= 0x4) r <<= 1;\r\n                r = (r + x / r) >> 1;\r\n                r = (r + x / r) >> 1;\r\n                r = (r + x / r) >> 1;\r\n                r = (r + x / r) >> 1;\r\n                r = (r + x / r) >> 1;\r\n                r = (r + x / r) >> 1;\r\n                r = (r + x / r) >> 1; // Seven iterations should be enough\r\n                uint256 r1 = x / r;\r\n                return uint128(r < r1 ? r : r1);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: src/lib/IUniswapV2Pair.sol\r\n\r\npragma solidity ^0.8.9;\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    function name() external pure returns (string memory);\r\n\r\n    function symbol() external pure returns (string memory);\r\n\r\n    function decimals() external pure returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\r\n        external;\r\n\r\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\r\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint256 amount0In,\r\n        uint256 amount1In,\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\r\n\r\n    function factory() external view returns (address);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n\r\n    function price0CumulativeLast() external view returns (uint256);\r\n\r\n    function price1CumulativeLast() external view returns (uint256);\r\n\r\n    function kLast() external view returns (uint256);\r\n\r\n    function mint(address to) external returns (uint256 liquidity);\r\n\r\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\r\n\r\n    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;\r\n\r\n    function skim(address to) external;\r\n\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n// File: src/lib/IUniswapV2Router01.sol\r\n\r\npragma solidity ^0.8.9;\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 liquidity,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountA, uint256 amountB);\r\n\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountToken, uint256 amountETH);\r\n\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 liquidity,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint256 amountA, uint256 amountB);\r\n\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint256 amountToken, uint256 amountETH);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapTokensForExactTokens(\r\n        uint256 amountOut,\r\n        uint256 amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapExactETHForTokens(uint256 amountOutMin, address[] calldata path, address to, uint256 deadline)\r\n        external\r\n        payable\r\n        returns (uint256[] memory amounts);\r\n\r\n    function swapTokensForExactETH(\r\n        uint256 amountOut,\r\n        uint256 amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapExactTokensForETH(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory amounts);\r\n\r\n    function swapETHForExactTokens(uint256 amountOut, address[] calldata path, address to, uint256 deadline)\r\n        external\r\n        payable\r\n        returns (uint256[] memory amounts);\r\n\r\n    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) external pure returns (uint256 amountB);\r\n\r\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)\r\n        external\r\n        pure\r\n        returns (uint256 amountOut);\r\n\r\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)\r\n        external\r\n        pure\r\n        returns (uint256 amountIn);\r\n\r\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\r\n        external\r\n        view\r\n        returns (uint256[] memory amounts);\r\n\r\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\r\n        external\r\n        view\r\n        returns (uint256[] memory amounts);\r\n}\r\n\r\n// File: src/lib/IUniswapV2Router02.sol\r\n\r\npragma solidity ^0.8.9;\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external returns (uint256 amountETH);\r\n\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint256 liquidity,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline,\r\n        bool approveMax,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external returns (uint256 amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n}\r\n\r\n// File: src/lib/IUniswapV2Factory.sol\r\n\r\npragma solidity ^0.8.9;\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\r\n\r\n    function feeTo() external view returns (address);\r\n\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n\r\n    function allPairs(uint256) external view returns (address pair);\r\n\r\n    function allPairsLength() external view returns (uint256);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\n// File: src/Compound.sol\r\n\r\npragma solidity ^0.8.7;\r\n\r\ncontract Compound {\r\n    //0.0001551017406% per 15 minutes\r\n    uint256 public rate = 1551017406 * 10 ** 5;\r\n    uint256 public rewardSettlementDuration = 15 * 60;\r\n    uint256 public totalSupply = 24_000_000_000 * 10 ** 18;\r\n    IUniswapV2Pair public uniswapV2Pair;\r\n    IUniswapV2Router02 public uniswapV2Router02;\r\n    IERC20 public token;\r\n    IERC20 public usdt;\r\n    address[] public topUsers = new address[](100);\r\n    uint256[] public topUsersLpAmount = new uint256[](100);\r\n    mapping(address => UserInfo) public userInfoMap;\r\n\r\n    event Deposit(address user, uint256 amount);\r\n    event WithdrawReward(address user, uint256 amount);\r\n    event WithdrawLP(address user, uint256 amount);\r\n\r\n    struct UserInfo {\r\n        uint256 depositedLPAmount;\r\n        uint256 lastSettlementTime;\r\n        uint256 rewardBalance;\r\n        bool exist;\r\n    }\r\n\r\n    constructor(IUniswapV2Pair uniswapV2Pair_, IUniswapV2Router02 uniswapV2Router02_, IERC20 token_, IERC20 usdt_) {\r\n        uniswapV2Pair = uniswapV2Pair_;\r\n        uniswapV2Router02 = uniswapV2Router02_;\r\n        token = token_;\r\n        usdt = usdt_;\r\n    }\r\n\r\n    function deposit(uint256 amount) public {\r\n        address user = msg.sender;\r\n        require(\r\n            uniswapV2Pair.transferFrom(user, address(this), amount),\r\n            \"Compound: transfer LP from user to contract failed\"\r\n        );\r\n        UserInfo memory userInfo = userInfoMap[user];\r\n        uint256 oldLPAmount = userInfo.depositedLPAmount;\r\n        if (userInfo.exist) {\r\n            userInfo = settlement(user);\r\n            userInfo.depositedLPAmount += amount;\r\n            userInfoMap[user] = userInfo;\r\n        } else {\r\n            userInfo.depositedLPAmount = amount;\r\n            userInfo.lastSettlementTime = block.timestamp;\r\n            userInfo.exist = true;\r\n            userInfoMap[user] = userInfo;\r\n        }\r\n        uint256 newLPAmount = userInfo.depositedLPAmount;\r\n        uint256 minLpAmount = topUsersLpAmount[topUsers.length - 1];\r\n\r\n        if (newLPAmount > minLpAmount) {\r\n            //already in top\r\n            if (oldLPAmount >= minLpAmount && oldLPAmount != 0) {\r\n                for (uint256 i = 0; i < topUsers.length; i++) {\r\n                    if (topUsers[i] == user) {\r\n                        topUsersLpAmount[i] = newLPAmount;\r\n                        break;\r\n                    }\r\n                }\r\n            } else {\r\n                // new in top\r\n                topUsers[topUsers.length - 1] = user;\r\n                topUsersLpAmount[topUsers.length - 1] = newLPAmount;\r\n            }\r\n            (topUsersLpAmount, topUsers) = intertionSort(topUsersLpAmount, topUsers);\r\n        }\r\n        emit Deposit(user, amount);\r\n    }\r\n\r\n    function withdrawReward(uint256 amount) public {\r\n        address user = msg.sender;\r\n        UserInfo memory userInfo = userInfoMap[user];\r\n        require(userInfo.exist, \"Compound: user not exist\");\r\n        userInfo = settlement(user);\r\n        require(userInfo.rewardBalance >= amount, \"Compound: Not sufficient funds\");\r\n        userInfo.rewardBalance -= amount;\r\n        userInfoMap[user] = userInfo;\r\n        require(token.transfer(user, amount), \"Compound: Transfer token to user failed\");\r\n        emit WithdrawReward(user, amount);\r\n    }\r\n\r\n    function withdrawLP(uint256 amount) public {\r\n        address user = msg.sender;\r\n        UserInfo memory userInfo = userInfoMap[user];\r\n        require(userInfo.exist, \"Compound: user not exist\");\r\n        userInfo = settlement(user);\r\n        uint256 lpAmount = userInfo.depositedLPAmount;\r\n        require(lpAmount >= amount, \"Compound: Not sufficient funds\");\r\n        uint256 minLpAmount = topUsersLpAmount[topUsers.length - 1];\r\n        uint256 leftLpAmount = lpAmount - amount;\r\n        // in top\r\n        if (lpAmount >= minLpAmount) {\r\n            //out top\r\n            if (leftLpAmount < minLpAmount) {\r\n                for (uint256 i = 0; i < topUsers.length; i++) {\r\n                    if (topUsers[i] == user) {\r\n                        topUsers[i] = address(0);\r\n                        topUsersLpAmount[i] = 0;\r\n                        break;\r\n                    }\r\n                }\r\n            } else {\r\n                //still in top\r\n                for (uint256 i = 0; i < topUsers.length; i++) {\r\n                    if (topUsers[i] == user) {\r\n                        topUsersLpAmount[i] = leftLpAmount;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            (topUsersLpAmount, topUsers) = intertionSort(topUsersLpAmount, topUsers);\r\n        }\r\n        userInfo.depositedLPAmount = leftLpAmount;\r\n        if (userInfo.depositedLPAmount == 0) {\r\n            delete userInfoMap[user];\r\n            require(token.transfer(user, userInfo.rewardBalance), \"Compound: Transfer token to user failed\");\r\n            emit WithdrawReward(user, userInfo.rewardBalance);\r\n        } else {\r\n            require(uniswapV2Pair.transfer(user, amount), \"Compound: Transfer LP to user failed\");\r\n            userInfoMap[user] = userInfo;\r\n        }\r\n        emit WithdrawLP(user, amount);\r\n    }\r\n\r\n    function settlement(address user) private returns (UserInfo memory) {\r\n        UserInfo memory userInfo = userInfoMap[user];\r\n        uint256 reward = getUserLatestCompoundReward(user);\r\n        userInfo.rewardBalance += reward;\r\n        userInfo.lastSettlementTime = block.timestamp;\r\n        totalSupply -= reward;\r\n        return userInfo;\r\n    }\r\n\r\n    function getUserLatestCompoundReward(address user) private view returns (uint256) {\r\n        UserInfo memory userInfo = userInfoMap[user];\r\n        if (!userInfo.exist) {\r\n            return 0;\r\n        }\r\n        (uint256 r0, uint256 r1,) = uniswapV2Pair.getReserves();\r\n        uint256 r;\r\n        if (address(usdt) < address(token)) {\r\n            r = r1;\r\n        } else {\r\n            r = r0;\r\n        }\r\n        uint256 compoundTimes = (block.timestamp - userInfo.lastSettlementTime) / rewardSettlementDuration;\r\n        if (compoundTimes == 0) {\r\n            return 0;\r\n        }\r\n        uint256 principal = r * userInfo.depositedLPAmount / uniswapV2Pair.totalSupply();\r\n        uint256 reward = compound(principal, rate, compoundTimes) - principal;\r\n        if (reward > totalSupply) {\r\n            return totalSupply;\r\n        }\r\n        return reward;\r\n    }\r\n\r\n    function viewUserInfo(address user) public view returns (UserInfo memory) {\r\n        UserInfo memory userInfo = userInfoMap[user];\r\n        if (userInfo.exist) {\r\n            userInfo.rewardBalance += getUserLatestCompoundReward(user);\r\n        }\r\n        return userInfo;\r\n    }\r\n\r\n    function pow(int128 x, uint256 n) private pure returns (int128 r) {\r\n        r = ABDKMath64x64.fromUInt(1);\r\n        while (n > 0) {\r\n            if (n % 2 == 1) {\r\n                r = ABDKMath64x64.mul(r, x);\r\n                n -= 1;\r\n            } else {\r\n                x = ABDKMath64x64.mul(x, x);\r\n                n /= 2;\r\n            }\r\n        }\r\n    }\r\n\r\n    function compound(uint256 principal, uint256 ratio, uint256 n) public pure returns (uint256) {\r\n        return ABDKMath64x64.mulu(\r\n            pow(ABDKMath64x64.add(ABDKMath64x64.fromUInt(1), ABDKMath64x64.divu(ratio, 10 ** 18)), n), principal\r\n        );\r\n    }\r\n\r\n    function intertionSort(uint256[] memory lpAmounts, address[] memory users)\r\n        private\r\n        pure\r\n        returns (uint256[] memory, address[] memory)\r\n    {\r\n        for (uint256 i = 1; i < lpAmounts.length; i++) {\r\n            uint256 tempLPAmount = lpAmounts[i];\r\n            address tempUser = users[i];\r\n            uint256 j = i;\r\n            while ((j >= 1) && (tempLPAmount > lpAmounts[j - 1])) {\r\n                lpAmounts[j] = lpAmounts[j - 1];\r\n                users[j] = users[j - 1];\r\n                j--;\r\n            }\r\n            lpAmounts[j] = tempLPAmount;\r\n            users[j] = tempUser;\r\n        }\r\n        return (lpAmounts, users);\r\n    }\r\n\r\n    function getLPTopUsers(uint256 number) public view returns (address[] memory) {\r\n        address[] memory addrs = new address[](number);\r\n        for (uint256 i = 0; i < number; i++) {\r\n            addrs[i] = topUsers[i];\r\n        }\r\n        return addrs;\r\n    }\r\n}\r\n\r\n// File: src/DividendDistributor.sol\r\n\r\npragma solidity ^0.8.9;\r\n\r\ncontract DividendDistributor {\r\n    address owner;\r\n\r\n    constructor(address[] memory tokens) {\r\n        owner = msg.sender;\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            IERC20(tokens[i]).approve(msg.sender, uint256(~uint256(0)));\r\n        }\r\n    }\r\n\r\n    function withdraw(address token, uint256 amount) public {\r\n        require(msg.sender == owner, \"DividendDistributor: not owner\");\r\n        IERC20(token).transfer(msg.sender, amount);\r\n    }\r\n}\r\n\r\n// File: src/TokenDistributor.sol\r\n\r\npragma solidity ^0.8.9;\r\n\r\ncontract TokenDistributor {\r\n    constructor(address token) {\r\n        IERC20(token).approve(msg.sender, uint256(~uint256(0)));\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n *\r\n * _Available since v4.1._\r\n */\r\ninterface IERC20Metadata is IERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/ERC20.sol\r\n\r\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\r\n * instead returning `false` on failure. This behavior is nonetheless\r\n * conventional and does not conflict with the expectations of ERC20\r\n * applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}.\r\n     *\r\n     * The default value of {decimals} is 18. To select a different value for\r\n     * {decimals} you should overload it.\r\n     *\r\n     * All two of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n     * overridden;\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\r\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * NOTE: Does not update the allowance if the current allowance\r\n     * is the maximum `uint256`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` and `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``from``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        unchecked {\r\n            _approve(owner, spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves `amount` of tokens from `from` to `to`.\r\n     *\r\n     * This internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address from, address to, uint256 amount) internal virtual {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, amount);\r\n\r\n        uint256 fromBalance = _balances[from];\r\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        unchecked {\r\n            _balances[from] = fromBalance - amount;\r\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\r\n            // decrementing then incrementing.\r\n            _balances[to] += amount;\r\n        }\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        _afterTokenTransfer(from, to, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        unchecked {\r\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\r\n            _balances[account] += amount;\r\n        }\r\n        emit Transfer(address(0), account, amount);\r\n\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\r\n            _totalSupply -= amount;\r\n        }\r\n\r\n        emit Transfer(account, address(0), amount);\r\n\r\n        _afterTokenTransfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\r\n     *\r\n     * Does not update the allowance amount in case of infinite allowance.\r\n     * Revert if not enough allowance is available.\r\n     *\r\n     * Might emit an {Approval} event.\r\n     */\r\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\r\n            unchecked {\r\n                _approve(owner, spender, currentAllowance - amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * has been transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\r\n}\r\n\r\n// File: src/BELE.sol\r\n\r\npragma solidity ^0.8.9;\r\n\r\ncontract BELE is ERC20, Ownable {\r\n    IUniswapV2Router02 public uniswapV2Router;\r\n    address public uniswapV2Pair;\r\n    TokenDistributor public tokenDistributor;\r\n    DividendDistributor public buyDividendDistributor;\r\n    DividendDistributor public sellDividendDistributor;\r\n    uint256 public buyDividendUserNumber = 50;\r\n    uint256 public sellDividendUserNumber = 25;\r\n    Compound public compound;\r\n\r\n    address public usdt;\r\n    address public destroyAddress = address(0x000000000000000000000000000000000000dEaD);\r\n    address public developerAdress;\r\n    address public marketAddress;\r\n    address public platformAdress;\r\n    address public nftfiVaultAddress;\r\n    address public corsairAndFleetVaultAddress;\r\n    address public compoundInviteVaultAddress;\r\n    address public addLiquidityAddress;\r\n\r\n    uint256 private _buyBurnFee = 1;\r\n    uint256 private _buyAndLiquifyfee = 2;\r\n    uint256 private _buyFundfee = 3;\r\n    uint256 private _sellBurnFee = 1;\r\n    uint256 private _sellDeveloperFee = 1;\r\n    uint256 private _sellMarketFee = 1;\r\n    uint256 private _sellFundfee = 3;\r\n    uint256 private _transferBurnFee = 6;\r\n\r\n    uint256 public platfromLockAmount = 1000000000 * 10 ** super.decimals();\r\n    uint256 public platfromLockDuration = 180 days;\r\n    uint256 public platfromLastReleaseTime = block.timestamp;\r\n    uint256 public platfromCurrentReleasedAmount;\r\n\r\n    uint256 public numTokensSellToAddToLiquidity = 1000000 * 10 ** super.decimals();\r\n    uint256 public numTokensSellToDividend = 200000 * 10 ** super.decimals();\r\n    uint256 public priceStartTime;\r\n    uint256 public dividendStartTime;\r\n    uint256 private _openSwapTime;\r\n\r\n    bool public inSwapAndLiquify;\r\n    bool public inDividend;\r\n    bool public inDividendSell;\r\n\r\n    mapping(address => bool) public inWhitelist;\r\n    mapping(address => bool) public isExcludedFromTransferFee;\r\n    mapping(uint256 => uint256) public priceMap;\r\n    mapping(uint256 => bool) public dividendMap;\r\n\r\n    modifier lockTheSwap() {\r\n        require(!inSwapAndLiquify, \"BELEProtocol: inSwapAndLiquify locked\");\r\n        inSwapAndLiquify = true;\r\n        _;\r\n        inSwapAndLiquify = false;\r\n    }\r\n\r\n    modifier lockTheDividend() {\r\n        require(!inDividend, \"BELEProtocol: Dividend locked\");\r\n        inDividend = true;\r\n        _;\r\n        inDividend = false;\r\n    }\r\n\r\n    modifier lockTheDividendSell() {\r\n        require(!inDividendSell, \"BELEProtocol: Dividend sell locked\");\r\n        inDividendSell = true;\r\n        _;\r\n        inDividendSell = false;\r\n    }\r\n\r\n    constructor(\r\n        string memory name_,\r\n        string memory symbol_,\r\n        address nftfiVaultAddress_,\r\n        address corsairAndFleetVaultAddress_,\r\n        address compoundInviteVaultAddress_,\r\n        address addLiquidityAddress_,\r\n        address router_,\r\n        address usdt_,\r\n        uint256 openSwapTime_\r\n    ) ERC20(name_, symbol_) {\r\n        nftfiVaultAddress = nftfiVaultAddress_;\r\n        corsairAndFleetVaultAddress = corsairAndFleetVaultAddress_;\r\n        compoundInviteVaultAddress = compoundInviteVaultAddress_;\r\n        addLiquidityAddress = addLiquidityAddress_;\r\n        usdt = usdt_;\r\n        _openSwapTime = openSwapTime_;\r\n        priceStartTime = block.timestamp;\r\n        dividendStartTime = block.timestamp;\r\n\r\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(router_);\r\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), usdt);\r\n        uniswapV2Router = _uniswapV2Router;\r\n\r\n        compound = new Compound(IUniswapV2Pair(uniswapV2Pair),uniswapV2Router,IERC20(address(this)),IERC20(usdt));\r\n\r\n        _mint(nftfiVaultAddress, 20000000000 * 10 ** decimals());\r\n        _mint(corsairAndFleetVaultAddress, 37000000000 * 10 ** decimals());\r\n        _mint(compoundInviteVaultAddress, 16000000000 * 10 ** decimals());\r\n        _mint(address(compound), 24000000000 * 10 ** decimals());\r\n        _mint(addLiquidityAddress, 2000000000 * 10 ** decimals());\r\n\r\n        isExcludedFromTransferFee[address(this)] = true;\r\n        isExcludedFromTransferFee[nftfiVaultAddress] = true;\r\n        isExcludedFromTransferFee[corsairAndFleetVaultAddress] = true;\r\n        isExcludedFromTransferFee[compoundInviteVaultAddress] = true;\r\n        isExcludedFromTransferFee[addLiquidityAddress] = true;\r\n        isExcludedFromTransferFee[address(compound)] = true;\r\n\r\n        inWhitelist[address(this)] = true;\r\n        inWhitelist[addLiquidityAddress] = true;\r\n    }\r\n\r\n    function initDistributosr() public onlyOwner {\r\n        address[] memory dividendDistributorTokens = new address[](2);\r\n        dividendDistributorTokens[0] = usdt;\r\n        dividendDistributorTokens[1] = address(this);\r\n        buyDividendDistributor = new DividendDistributor(dividendDistributorTokens);\r\n        sellDividendDistributor = new DividendDistributor(dividendDistributorTokens);\r\n        tokenDistributor = new TokenDistributor(usdt);\r\n    }\r\n\r\n    function _transfer(address from, address to, uint256 amount) internal override {\r\n        if (from != uniswapV2Pair) {\r\n            if (balanceOf(address(this)) >= numTokensSellToAddToLiquidity && !inSwapAndLiquify) {\r\n                swapAndERC20Liquify(numTokensSellToAddToLiquidity);\r\n            }\r\n            if (balanceOf(address(buyDividendDistributor)) >= numTokensSellToDividend && !inDividendSell) {\r\n                _takeBuyDivedendSellToUSDT();\r\n            }\r\n            if (balanceOf(address(sellDividendDistributor)) >= numTokensSellToDividend && !inDividendSell) {\r\n                _takeSellDivedendSellToUSDT();\r\n            }\r\n\r\n            uint256 dividendIntervalDays = getDividendIntervalDays();\r\n            if (dividendIntervalDays > 0 && !dividendMap[dividendIntervalDays] && !inDividend) {\r\n                _takeBuyDividend();\r\n                _takeSellDividend();\r\n                dividendMap[dividendIntervalDays] = true;\r\n            }\r\n        }\r\n\r\n        bool buy = false;\r\n        bool sell = false;\r\n        bool transferToken = false;\r\n        bool takeFee = true;\r\n        if (from == uniswapV2Pair) {\r\n            if (_isRemoveLiquidity()) {\r\n                takeFee = false;\r\n            } else {\r\n                //buy\r\n                require(block.timestamp >= _openSwapTime || inWhitelist[to], \"BELE: Can not swap\");\r\n                if (inWhitelist[to]) {\r\n                    takeFee = false;\r\n                }\r\n                buy = true;\r\n            }\r\n        } else if (to == uniswapV2Pair) {\r\n            if (_isAddLiquidity()) {\r\n                takeFee = false;\r\n            } else {\r\n                //sell\r\n                require(block.timestamp >= _openSwapTime || inWhitelist[from], \"BELE: Can not swap\");\r\n                if (inWhitelist[from]) {\r\n                    takeFee = false;\r\n                }\r\n                sell = true;\r\n            }\r\n        } else if (isExcludedFromTransferFee[from] || isExcludedFromTransferFee[to]) {\r\n            takeFee = false;\r\n        } else {\r\n            transferToken = true;\r\n        }\r\n\r\n        if (takeFee) {\r\n            if (buy) {\r\n                _tokenBuy(from, to, amount);\r\n            }\r\n            if (sell) {\r\n                if (amount == balanceOf(from)) {\r\n                    amount = (amount * 99) / 100;\r\n                }\r\n                uint256 sellBurnFee = _sellBurnFee;\r\n                if (getPriceDownRate() >= 5) {\r\n                    sellBurnFee += 10;\r\n                }\r\n                _tokenSell(from, to, amount, sellBurnFee);\r\n            }\r\n            if (transferToken) {\r\n                _tokenTransfer(from, to, amount);\r\n            }\r\n        } else {\r\n            super._transfer(from, to, amount);\r\n        }\r\n        if (buy || sell) {\r\n            setPrice();\r\n        }\r\n        releaseToPlatform();\r\n    }\r\n\r\n    function _tokenSell(address from, address to, uint256 amount, uint256 burnFee) private {\r\n        uint256 burnAmount = (amount * burnFee) / 100;\r\n        uint256 developerAmount = (amount * _sellDeveloperFee) / 100;\r\n        uint256 marketAmount = (amount * _sellMarketFee) / 100;\r\n        uint256 fundAmount = (amount * _sellFundfee) / 100;\r\n        super._transfer(from, destroyAddress, burnAmount);\r\n        super._transfer(from, developerAdress, developerAmount);\r\n        super._transfer(from, marketAddress, marketAmount);\r\n        super._transfer(from, address(sellDividendDistributor), fundAmount);\r\n        super._transfer(from, to, amount - burnAmount - developerAmount - marketAmount - fundAmount);\r\n    }\r\n\r\n    function _tokenBuy(address from, address to, uint256 amount) private {\r\n        uint256 burnAmount = (amount * _buyBurnFee) / 100;\r\n        uint256 fundAmount = (amount * _buyFundfee) / 100;\r\n        uint256 addLiquifyAmount = (amount * _buyAndLiquifyfee) / 100;\r\n        super._transfer(from, destroyAddress, burnAmount);\r\n        super._transfer(from, address(buyDividendDistributor), fundAmount);\r\n        super._transfer(from, address(this), addLiquifyAmount);\r\n        super._transfer(from, to, amount - burnAmount - fundAmount - addLiquifyAmount);\r\n    }\r\n\r\n    function _tokenTransfer(address from, address to, uint256 amount) private {\r\n        uint256 burnAmount = (amount * _transferBurnFee) / 100;\r\n        super._transfer(from, destroyAddress, burnAmount);\r\n        super._transfer(from, to, amount - burnAmount);\r\n    }\r\n\r\n    function releaseToPlatform() private {\r\n        uint256 nowTime = block.timestamp;\r\n        if (platfromCurrentReleasedAmount < platfromLockAmount && nowTime > platfromLastReleaseTime) {\r\n            uint256 releaseAmount = ((nowTime - platfromLastReleaseTime) * platfromLockAmount) / platfromLockDuration;\r\n            if (releaseAmount + platfromCurrentReleasedAmount > platfromLockAmount) {\r\n                releaseAmount = platfromLockAmount - platfromCurrentReleasedAmount;\r\n            }\r\n            platfromCurrentReleasedAmount += releaseAmount;\r\n            platfromLastReleaseTime = nowTime;\r\n            _mint(platformAdress, releaseAmount);\r\n        }\r\n    }\r\n\r\n    function swapAndERC20Liquify(uint256 contractTokenBalance) private lockTheSwap {\r\n        uint256 swapLpAmount = contractTokenBalance / 2;\r\n        uint256 addLpAmount = contractTokenBalance - swapLpAmount;\r\n        swapTokensForAnyERC20Token(swapLpAmount);\r\n        IERC20 USDT = IERC20(usdt);\r\n        uint256 usdtBalance = USDT.balanceOf(address(tokenDistributor));\r\n        if (usdtBalance > 0) {\r\n            USDT.transferFrom(address(tokenDistributor), address(this), usdtBalance);\r\n            addLiquidityERC20(addLpAmount, usdtBalance);\r\n        }\r\n    }\r\n\r\n    function swapTokensForAnyERC20Token(uint256 tokenAmount) private {\r\n        if (tokenAmount > 0) {\r\n            address[] memory path = new address[](2);\r\n            path[0] = address(this);\r\n            path[1] = usdt;\r\n\r\n            _approve(address(this), address(uniswapV2Router), totalSupply());\r\n\r\n            uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n                tokenAmount, 0, path, address(tokenDistributor), block.timestamp\r\n            );\r\n        }\r\n    }\r\n\r\n    function addLiquidityERC20(uint256 tokenAmount, uint256 usdtAmount) private {\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        IERC20(usdt).approve(address(uniswapV2Router), usdtAmount);\r\n\r\n        uniswapV2Router.addLiquidity(\r\n            address(this), usdt, tokenAmount, usdtAmount, 0, 0, destroyAddress, block.timestamp\r\n        );\r\n    }\r\n\r\n    function getCurrentPrice() public view returns (uint256 currentPrice) {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = usdt;\r\n        uint256[] memory amounts = uniswapV2Router.getAmountsOut(1e18, path);\r\n        return amounts[1];\r\n    }\r\n\r\n    function setDividendStartTime(uint256 _startTime) public onlyOwner {\r\n        dividendStartTime = _startTime;\r\n    }\r\n\r\n    function setPriceStartTime(uint256 _startTime) public onlyOwner {\r\n        priceStartTime = _startTime;\r\n    }\r\n\r\n    function _isAddLiquidity() internal view returns (bool isAdd) {\r\n        IUniswapV2Pair mainPair = IUniswapV2Pair(uniswapV2Pair);\r\n        (uint256 r0, uint256 r1,) = mainPair.getReserves();\r\n\r\n        address tokenOther = usdt;\r\n        uint256 r;\r\n        if (tokenOther < address(this)) {\r\n            r = r0;\r\n        } else {\r\n            r = r1;\r\n        }\r\n\r\n        uint256 bal = IERC20(tokenOther).balanceOf(address(uniswapV2Pair));\r\n        isAdd = bal > r;\r\n    }\r\n\r\n    function _isRemoveLiquidity() internal view returns (bool isRemove) {\r\n        IUniswapV2Pair mainPair = IUniswapV2Pair(uniswapV2Pair);\r\n        (uint256 r0, uint256 r1,) = mainPair.getReserves();\r\n\r\n        address tokenOther = usdt;\r\n        uint256 r;\r\n        if (tokenOther < address(this)) {\r\n            r = r0;\r\n        } else {\r\n            r = r1;\r\n        }\r\n\r\n        uint256 bal = IERC20(tokenOther).balanceOf(address(mainPair));\r\n        isRemove = r >= bal;\r\n    }\r\n\r\n    function excludedFromTransferFee(address addr) public onlyOwner returns (bool) {\r\n        isExcludedFromTransferFee[addr] = true;\r\n        return true;\r\n    }\r\n\r\n    function includedFromTransferFee(address addr) public onlyOwner returns (bool) {\r\n        isExcludedFromTransferFee[addr] = false;\r\n        return true;\r\n    }\r\n\r\n    function addWhitelist(address addr) public onlyOwner returns (bool) {\r\n        inWhitelist[addr] = true;\r\n        return true;\r\n    }\r\n\r\n    function removeWhitelist(address addr) public onlyOwner returns (bool) {\r\n        inWhitelist[addr] = false;\r\n        return true;\r\n    }\r\n\r\n    function withdrawERC20(address tokenAdress, address to) public onlyOwner returns (bool) {\r\n        IERC20 token = IERC20(tokenAdress);\r\n        return token.transfer(to, token.balanceOf(address(this)));\r\n    }\r\n\r\n    function totalSupply() public view override returns (uint256) {\r\n        return super.totalSupply() - super.balanceOf(destroyAddress);\r\n    }\r\n\r\n    function getPriceIntervalDays() public view returns (uint256) {\r\n        return (block.timestamp - priceStartTime) / 1 days;\r\n    }\r\n\r\n    function getDividendIntervalDays() public view returns (uint256) {\r\n        return (block.timestamp - dividendStartTime) / 1 days;\r\n    }\r\n\r\n    function setPrice() internal {\r\n        uint256 intervalDay = getPriceIntervalDays();\r\n        if (priceMap[intervalDay] == 0) {\r\n            priceMap[intervalDay] = getCurrentPrice();\r\n        }\r\n    }\r\n\r\n    function getStartPrice() public view returns (uint256) {\r\n        uint256 intervalDay = getPriceIntervalDays();\r\n        uint256 _startPrice = priceMap[intervalDay];\r\n        if (priceMap[intervalDay] == 0) {\r\n            _startPrice = getCurrentPrice();\r\n        }\r\n        return _startPrice;\r\n    }\r\n\r\n    function getPriceDownRate() public view returns (uint256) {\r\n        uint256 currentPrice = getCurrentPrice();\r\n        uint256 _startPrice = getStartPrice();\r\n        uint256 ze = 0;\r\n        if (currentPrice >= _startPrice) {\r\n            return ze;\r\n        }\r\n        uint256 downRate = ((_startPrice - currentPrice) * 100) / _startPrice;\r\n        return downRate;\r\n    }\r\n\r\n    function setDeveloperAdress(address addr) public onlyOwner {\r\n        developerAdress = addr;\r\n        isExcludedFromTransferFee[addr] = true;\r\n        inWhitelist[addr] = true;\r\n    }\r\n\r\n    function setMarketAddress(address addr) public onlyOwner {\r\n        marketAddress = addr;\r\n        isExcludedFromTransferFee[addr] = true;\r\n        inWhitelist[addr] = true;\r\n    }\r\n\r\n    function setPlatformAdress(address addr) public onlyOwner {\r\n        platformAdress = addr;\r\n        isExcludedFromTransferFee[addr] = true;\r\n        inWhitelist[addr] = true;\r\n    }\r\n\r\n    function _takeBuyDivedendSellToUSDT() private lockTheDividendSell {\r\n        buyDividendDistributor.withdraw(address(this), numTokensSellToDividend);\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = usdt;\r\n        _approve(address(this), address(uniswapV2Router), totalSupply());\r\n        uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            numTokensSellToDividend, 0, path, address(buyDividendDistributor), block.timestamp\r\n        );\r\n    }\r\n\r\n    function _takeSellDivedendSellToUSDT() private lockTheDividendSell {\r\n        sellDividendDistributor.withdraw(address(this), numTokensSellToDividend);\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = usdt;\r\n        _approve(address(this), address(uniswapV2Router), totalSupply());\r\n        uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            numTokensSellToDividend, 0, path, address(sellDividendDistributor), block.timestamp\r\n        );\r\n    }\r\n\r\n    function _takeBuyDividend() private lockTheDividend {\r\n        address[] memory users = compound.getLPTopUsers(buyDividendUserNumber);\r\n        uint256 userNumber;\r\n        for (uint256 i = 0; i < users.length; i++) {\r\n            if (users[i] != address(0)) {\r\n                userNumber++;\r\n            }\r\n        }\r\n        if (userNumber == 0) {\r\n            return;\r\n        }\r\n        IERC20 USDT = IERC20(usdt);\r\n        uint256 usdtBalance = USDT.balanceOf(address(buyDividendDistributor));\r\n        if (usdtBalance > 0) {\r\n            USDT.transferFrom(address(buyDividendDistributor), address(this), usdtBalance);\r\n            uint256 dividendAmount = usdtBalance / userNumber;\r\n            address user;\r\n            for (uint256 i = 0; i < users.length; i++) {\r\n                user = users[i];\r\n                if (user != address(0)) {\r\n                    USDT.transfer(user, dividendAmount);\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function _takeSellDividend() private lockTheDividend {\r\n        address[] memory users = compound.getLPTopUsers(sellDividendUserNumber);\r\n        uint256 userNumber;\r\n        for (uint256 i = 0; i < users.length; i++) {\r\n            if (users[i] != address(0)) {\r\n                userNumber++;\r\n            }\r\n        }\r\n        if (userNumber == 0) {\r\n            return;\r\n        }\r\n        IERC20 USDT = IERC20(usdt);\r\n        uint256 usdtBalance = USDT.balanceOf(address(sellDividendDistributor));\r\n        if (usdtBalance > 0) {\r\n            USDT.transferFrom(address(sellDividendDistributor), address(this), usdtBalance);\r\n            uint256 dividendAmount = usdtBalance / userNumber;\r\n            address user;\r\n            for (uint256 i = 0; i < users.length; i++) {\r\n                user = users[i];\r\n                if (user != address(0)) {\r\n                    USDT.transfer(user, dividendAmount);\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"nftfiVaultAddress_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"corsairAndFleetVaultAddress_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"compoundInviteVaultAddress_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addLiquidityAddress_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"router_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"usdt_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"openSwapTime_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"addLiquidityAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyDividendDistributor\",\"outputs\":[{\"internalType\":\"contract DividendDistributor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyDividendUserNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"compound\",\"outputs\":[{\"internalType\":\"contract Compound\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"compoundInviteVaultAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"corsairAndFleetVaultAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"destroyAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"developerAdress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dividendMap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"excludedFromTransferFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"currentPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDividendIntervalDays\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPriceDownRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPriceIntervalDays\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStartPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inDividend\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inDividendSell\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inSwapAndLiquify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"inWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"includedFromTransferFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initDistributosr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isExcludedFromTransferFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftfiVaultAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numTokensSellToAddToLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numTokensSellToDividend\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"platformAdress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"platfromCurrentReleasedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"platfromLastReleaseTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"platfromLockAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"platfromLockDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"priceMap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellDividendDistributor\",\"outputs\":[{\"internalType\":\"contract DividendDistributor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellDividendUserNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setDeveloperAdress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"setDividendStartTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setMarketAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setPlatformAdress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"setPriceStartTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenDistributor\",\"outputs\":[{\"internalType\":\"contract TokenDistributor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAdress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdrawERC20\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BELE", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000160000000000000000000000000288d73d03ea2c15202b4a9e1eb7e6c78b6ef1bde000000000000000000000000e01168b6c81bc865b82731c65d68c3e61f3aaa8d000000000000000000000000c9c9b26fc96d54103f4c71708687f2949ecbf5fb00000000000000000000000052e277e62a9dd372be31ebec4c079f1bef27bfa300000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e00000000000000000000000055d398326f99059ff775485246999027b31979550000000000000000000000000000000000000000000000000000000064229070000000000000000000000000000000000000000000000000000000000000000d42656c652050726f746f636f6c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000442454c4500000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e82079814ba0b9628fe7ca3176d5ab8093a461e0612df149044de48ab531acf5"}