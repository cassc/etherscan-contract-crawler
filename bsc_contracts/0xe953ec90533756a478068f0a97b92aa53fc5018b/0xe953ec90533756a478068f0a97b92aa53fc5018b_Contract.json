{"SourceCode": "// SPDX-License-Identifier: Unlicensed \r\n// This contract is not open source and can not be used/forked without permission\r\n// Created by https://TokensByGen.com/\r\n// Contract Code Pre-Verified on BSCScan using 'Similar Match Source Code'\r\n\r\n\r\npragma solidity 0.8.16;\r\n \r\ninterface IERC20 {\r\n    \r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;}\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;}\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;}\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;}\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {require(b <= a, errorMessage);\r\n            return a - b;}}\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {require(b > 0, errorMessage);\r\n            return a / b;}}\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        this; \r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\nlibrary Address {\r\n    \r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"insufficient balance\");\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"unable to send, recipient reverted\");\r\n    }\r\n    \r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"low-level call failed\");\r\n    }\r\n    \r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n    \r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"low-level call with value failed\");\r\n    }\r\n    \r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"insufficient balance for call\");\r\n        require(isContract(target), \"call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    \r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"low-level static call failed\");\r\n    }\r\n    \r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"static call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"low-level delegate call failed\");\r\n    }\r\n    \r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"delegate call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                 assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n    function initialize(address, address) external;\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract Contract is Context, IERC20 { \r\n\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    // Contract Wallets\r\n    address private _owner;                             // Contract Owner\r\n    address public Wallet_Liquidity;                    // LP Token Collection Wallet for Auto LP \r\n    address public Wallet_Tokens;                       // Token Fee Collection Wallet\r\n    address payable public Wallet_BNB;                  // BNB Fee Collection Wallet \r\n    address payable public Wallet_TBG_AFF;              // TokensByGEN Affiliate Wallet and Discount Code\r\n\r\n    // Contract fee (1% ongoing if applicable) is sent to fee collection contract \r\n    address payable public constant feeCollector = payable(0xde491C65E507d281B6a3688d11e8fC222eee0975); \r\n\r\n    // Token Info\r\n    string private  _name;\r\n    string private  _symbol;\r\n    uint256 private _decimals;\r\n    uint256 private _tTotal;\r\n\r\n    // Token social links will appear on BSCScan\r\n    string private _Website;\r\n    string private _Telegram;\r\n    string private _LP_Locker_URL;\r\n\r\n    // Wallet and transaction limits\r\n    uint256 private max_Hold;\r\n    uint256 private max_Tran;\r\n\r\n    // Fees - Set fees before opening trade\r\n    uint256 public _Fee__Buy_Burn;\r\n    uint256 public _Fee__Buy_Contract;\r\n    uint256 public _Fee__Buy_Liquidity;\r\n    uint256 public _Fee__Buy_BNB;\r\n    uint256 public _Fee__Buy_Reflection;\r\n    uint256 public _Fee__Buy_Tokens;\r\n\r\n    uint256 public _Fee__Sell_Burn;\r\n    uint256 public _Fee__Sell_Contract;\r\n    uint256 public _Fee__Sell_Liquidity;\r\n    uint256 public _Fee__Sell_BNB;\r\n    uint256 public _Fee__Sell_Reflection;\r\n    uint256 public _Fee__Sell_Tokens;\r\n\r\n    // Upper limit for fee processing trigger\r\n    uint256 private swap_Max;\r\n\r\n    // Total fees that are processed on buys and sells for swap and liquify calculations\r\n    uint256 private _SwapFeeTotal_Buy;\r\n    uint256 private _SwapFeeTotal_Sell;\r\n\r\n    // Track contract fee\r\n    uint256 private ContractFee;\r\n\r\n    // Supply Tracking for RFI\r\n    uint256 private _rTotal;\r\n    uint256 private _tFeeTotal;\r\n    uint256 private constant MAX = ~uint256(0);\r\n\r\n    // Launch Phase Settings\r\n    uint256 private max_Tran_Launch;\r\n    uint256 private Launch_Buy_Delay;\r\n    uint256 private Launch_Length;\r\n\r\n    // Affiliate Tracking\r\n    IERC20 GEN = IERC20(0x7d7a7f452e04C2a5df792645e8bfaF529aDcCEcf); // GEN - For tracking affiliate level\r\n    IERC20 AFT = IERC20(0x98A70E83A53544368D72940467b8bB05267632f4); // TokensByGEN Affiliate Tracker Token\r\n\r\n\r\n    uint256 private constant Tier_2 =  500000 * 10**9;\r\n    uint256 private constant Tier_3 = 1000000 * 10**9;\r\n\r\n\r\n    // Set factory\r\n    IUniswapV2Router02 public uniswapV2Router;\r\n    address public uniswapV2Pair;\r\n\r\n    constructor (string memory      _TokenName, \r\n                 string memory      _TokenSymbol,  \r\n                 uint256            _TotalSupply, \r\n                 uint256            _Decimals, \r\n                 address payable    _OwnerWallet,\r\n                 address payable    _DiscountCode, \r\n                 uint256            _ContractFee) {\r\n\r\n    // Set owner\r\n    _owner              = _OwnerWallet;\r\n\r\n    // Set basic token details\r\n    _name               = _TokenName;\r\n    _symbol             = _TokenSymbol;\r\n    _decimals           = _Decimals;\r\n    _tTotal             = _TotalSupply * 10**_decimals;\r\n    _rTotal             = (MAX - (MAX % _tTotal));\r\n    \r\n    // Wallet limits - Set limits after deploying\r\n    max_Hold            = _tTotal;\r\n    max_Tran            = _tTotal;\r\n\r\n    // Contract sell limit when processing fees\r\n    swap_Max            = _tTotal / 200;\r\n\r\n    // Launch Phase control\r\n    max_Tran_Launch     = _tTotal;\r\n    Launch_Buy_Delay    = 0;            \r\n    Launch_Length       = 5 * 60;\r\n\r\n    // Set BNB, tokens, and liquidity collection wallets to owner (can be updated later)\r\n    Wallet_BNB          = payable(_OwnerWallet);\r\n    Wallet_Liquidity    = _OwnerWallet;\r\n    Wallet_Tokens       = _OwnerWallet;\r\n\r\n    // Set contract fee \r\n    ContractFee         = _ContractFee;\r\n\r\n    // Transfer token supply to owner wallet\r\n    _rOwned[_owner]     = _rTotal;\r\n\r\n    // Set TokensByGEN affiliate from Discount Code\r\n    Wallet_TBG_AFF      = payable(_DiscountCode);\r\n\r\n    // Set PancakeSwap Router Address\r\n    IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n\r\n    // Create initial liquidity pair with BNB on PancakeSwap factory\r\n    uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\r\n    uniswapV2Router = _uniswapV2Router;\r\n\r\n    // Wallets that are excluded from holding limits\r\n    _isLimitExempt[_owner] = true;\r\n    _isLimitExempt[address(this)] = true;\r\n    _isLimitExempt[Wallet_Burn] = true;\r\n    _isLimitExempt[uniswapV2Pair] = true;\r\n    _isLimitExempt[Wallet_Tokens] = true;\r\n\r\n    // Wallets that are excluded from fees\r\n    _isExcludedFromFee[_owner] = true;\r\n    _isExcludedFromFee[address(this)] = true;\r\n    _isExcludedFromFee[Wallet_Burn] = true;\r\n\r\n    // Set the initial liquidity pair\r\n    _isPair[uniswapV2Pair] = true;    \r\n\r\n    // Exclude from Rewards\r\n    _isExcluded[Wallet_Burn] = true;\r\n    _isExcluded[uniswapV2Pair] = true;\r\n    _isExcluded[address(this)] = true;\r\n\r\n    // Push excluded wallets to array\r\n    _excluded.push(Wallet_Burn);\r\n    _excluded.push(uniswapV2Pair);\r\n    _excluded.push(address(this));\r\n\r\n    // Wallets granted access before trade is open\r\n    _isWhiteListed[_owner] = true;\r\n\r\n    // Emit Supply Transfer to Owner\r\n    emit Transfer(address(0), _owner, _tTotal);\r\n\r\n    // Emit ownership transfer\r\n    emit OwnershipTransferred(address(0), _owner);\r\n\r\n    }\r\n\r\n    \r\n    // Events\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event updated_Wallet_Limits(uint256 max_Tran, uint256 max_Hold);\r\n    event updated_Buy_fees(uint256 Marketing, uint256 Liquidity, uint256 Reflection, uint256 Burn, uint256 Tokens, uint256 Contract_Development_Fee);\r\n    event updated_Sell_fees(uint256 Marketing, uint256 Liquidity, uint256 Reflection, uint256 Burn, uint256 Tokens, uint256 Contract_Development_Fee);\r\n    event updated_SwapAndLiquify_Enabled(bool Swap_and_Liquify_Enabled);\r\n    event updated_trade_Open(bool TradeOpen);\r\n    event SwapAndLiquify(uint256 tokensSwapped, uint256 ethReceived, uint256 tokensIntoLiqudity);\r\n    event set_Contract_Fee(uint256 Contract_Development_Buy_Fee, uint256 Contract_Development_Sell_Fee);\r\n\r\n\r\n    // Restrict function to contract owner only \r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n\r\n    // Address mappings\r\n    mapping (address => uint256) private _tOwned;                               // Tokens Owned\r\n    mapping (address => uint256) private _rOwned;                               // Reflected balance\r\n    mapping (address => uint256) private _Last_Buy;                             // Timestamp of previous transaction\r\n    mapping (address => mapping (address => uint256)) private _allowances;      // Allowance to spend another wallets tokens\r\n    mapping (address => bool) public _isExcludedFromFee;                        // Wallets that do not pay fees\r\n    mapping (address => bool) public _isExcluded;                               // Excluded from RFI rewards\r\n    mapping (address => bool) public _isWhiteListed;                            // Wallets that have access before trade is open\r\n    mapping (address => bool) public _isLimitExempt;                            // Wallets that are excluded from HOLD and TRANSFER limits\r\n    mapping (address => bool) public _isPair;                                   // Address is liquidity pair\r\n    mapping (address => bool) public _isSnipe;                                  // Sniper!\r\n    mapping (address => bool) public _isBlacklisted;                            // Blacklist wallet - can only be added pre-launch!\r\n    address[] private _excluded;                                                // Array of wallets excluded from rewards\r\n\r\n\r\n    // Token information \r\n    function Token_Information() external view returns(string memory Token_Name,\r\n                                                       string memory Token_Symbol,\r\n                                                       uint256 Number_of_Decimals,\r\n                                                       address Owner_Wallet,\r\n                                                       uint256 Transaction_Limit,\r\n                                                       uint256 Max_Wallet,\r\n                                                       uint256 Fee_When_Buying,\r\n                                                       uint256 Fee_When_Selling,\r\n                                                       string memory Website,\r\n                                                       string memory Telegram,\r\n                                                       string memory Liquidity_Lock_URL,\r\n                                                       string memory Contract_Created_By) {\r\n\r\n                                                           \r\n        string memory Creator = \"https://tokensbygen.com/\";\r\n\r\n        uint256 Total_buy =  _Fee__Buy_Burn         +\r\n                             _Fee__Buy_Contract     +\r\n                             _Fee__Buy_Liquidity    +\r\n                             _Fee__Buy_BNB          +\r\n                             _Fee__Buy_Reflection   +\r\n                             _Fee__Buy_Tokens       ;\r\n\r\n        uint256 Total_sell = _Fee__Sell_Burn        +\r\n                             _Fee__Sell_Contract    +\r\n                             _Fee__Sell_Liquidity   +\r\n                             _Fee__Sell_BNB         +\r\n                             _Fee__Sell_Reflection  +\r\n                             _Fee__Sell_Tokens      ;\r\n\r\n\r\n        uint256 TranLimit = max_Tran / 10 ** _decimals;\r\n\r\n        \r\n            if (LaunchPhase && (max_Tran_Launch < max_Tran)){\r\n                TranLimit = max_Tran_Launch / 10 ** _decimals;\r\n            }\r\n\r\n\r\n        // Return Token Data\r\n        return (_name,\r\n                _symbol,\r\n                _decimals,\r\n                _owner,\r\n                TranLimit,\r\n                max_Hold / 10 ** _decimals,\r\n                Total_buy,\r\n                Total_sell,\r\n                _Website,\r\n                _Telegram,\r\n                _LP_Locker_URL,\r\n                Creator);\r\n\r\n    }\r\n    \r\n\r\n    // Burn (dead) address\r\n    address public constant Wallet_Burn = 0x000000000000000000000000000000000000dEaD; \r\n\r\n    // Swap triggers\r\n    uint256 private swapTrigger = 11;   \r\n    uint256 private swapCounter = 1;    \r\n    \r\n    // SwapAndLiquify - Automatically processing fees and adding liquidity                                   \r\n    bool public inSwapAndLiquify;\r\n    bool public swapAndLiquifyEnabled; \r\n\r\n    // Launch settings\r\n    bool public TradeOpen;\r\n    bool private LaunchPhase;\r\n    uint256 private LaunchTime;\r\n\r\n    // No fee on wallet-to-wallet transfers\r\n    bool noFeeW2W = true;\r\n\r\n    // Deflationary Burn - Tokens Sent to Burn are removed from total supply if set to true\r\n    bool public deflationaryBurn;\r\n\r\n    // Take fee tracker\r\n    bool private takeFee;\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /* \r\n\r\n    ------------------------------------\r\n    CONTRACT SET UP AND DEPLOYMENT GUIDE\r\n    ------------------------------------\r\n\r\n    */\r\n\r\n\r\n\r\n\r\n    /*\r\n    \r\n    ------------------------------------------\r\n    DECIDE IF BURN WALLET WILL BE DEFLATIONARY\r\n    ------------------------------------------\r\n\r\n    By default this is set to false\r\n    \r\n    If you change this to true, when tokens are sent to the burn wallet\r\n    (0x000000000000000000000000000000000000dEaD) they will instead be removed\r\n    from the senders balance and removed from the total supply.\r\n\r\n    When this is set to false, any tokens sent to the burn wallet will not\r\n    be removed from total supply and will be added to the burn wallet balance.\r\n    This is the default action on most contracts. \r\n\r\n    A truly deflationary burn can be confusing to some token tools and\r\n    listing platforms, so only set this to true if you understand the implications.\r\n\r\n    A deflationary burn will not instantly increase the value of other tokens, \r\n    but it will help with token stability over time.\r\n\r\n\r\n    */\r\n\r\n    function Contract_Options_01__Deflationary_Burn(bool true_or_false) external onlyOwner {\r\n        deflationaryBurn = true_or_false;\r\n    }\r\n\r\n\r\n    /*\r\n    \r\n    -----------------------------------------------------------\r\n    DECIDE IF WALLET TO WALLET TRANSFERS WILL BE FREE FROM FEES\r\n    -----------------------------------------------------------\r\n\r\n    Default = true\r\n\r\n    Having no fee on wallet-to-wallet transfers means that people can move tokens between wallets, \r\n    or send them to friends etc without incurring a fee. \r\n\r\n    This feature may be required if you plan to use your token in place of fiat as a form of payment. \r\n\r\n    However, in order for it to work, we must inform the contract of all liquidity pairs. So\r\n    if you (or anybody else) ever adds a new liquidity pair, you need to enter the address of the pair\r\n    into the \"Maintenance_02__Add_Liquidity_Pair\" function. \r\n\r\n    If you plan to renounce your contract, you will lose access to all functions. Which presents a\r\n    possible exploit where people can create a liquidity pair for your token and use it to buy and sell \r\n    without a fee. \r\n\r\n    For this reason, you can not renounce the contract and have no-fee on wallet-to-wallet transfers. \r\n\r\n    Decide which is better for your project. No fees when moving tokens between wallets, or renouncing\r\n    ownership. Having both is not an option!\r\n\r\n\r\n    */\r\n\r\n    function Contract_Options_02__No_Fee_Wallet_Transfers(bool true_or_false) public onlyOwner {\r\n        noFeeW2W = true_or_false;\r\n    }\r\n\r\n\r\n\r\n\r\n    /*\r\n    \r\n    ------------------------------\r\n    SET CONTRACT BUY AND SELL FEES\r\n    ------------------------------  \r\n\r\n    To protect investors, buy and sell fees have a hard-coded limit of 20% \r\n    If the contract development fee was set to 1% of transactions, this is included in the limit.\r\n\r\n    -------------\r\n    How Fees Work\r\n    -------------\r\n\r\n    Burn, Token, and Reflection fees are processed immediately during the transaction.\r\n\r\n    BNB and Liquidity fees are collected in tokens then added to the contract. \r\n    These fees accumulate (as tokens) on the contract until they are processed.\r\n\r\n    When fees are processed, the contract sells the accumulated tokens for BNB\r\n    (This shows as a sell on the chart).\r\n\r\n    This process can only happen when a holder sells tokens.\r\n\r\n    So when fees are processed, you will see 2 sells on the chart in the same\r\n    second, the holders sell, and the contract sell.\r\n\r\n    This process is triggered automatically on the next sell after 10 transactions.\r\n    \r\n    */\r\n\r\n\r\n\r\n    // Set Buy Fees\r\n    function Contract_SetUp_01__Fees_on_Buy(\r\n\r\n        uint256 BNB_on_BUY, \r\n        uint256 Liquidity_on_BUY, \r\n        uint256 Reflection_on_BUY, \r\n        uint256 Burn_on_BUY,  \r\n        uint256 Tokens_on_BUY\r\n\r\n        ) external onlyOwner {\r\n\r\n        _Fee__Buy_Contract = ContractFee;\r\n\r\n        // Buyer protection: max fee can not be set over 20% (including the 1% contract fee if applicable)\r\n        require (BNB_on_BUY          + \r\n                 Liquidity_on_BUY    + \r\n                 Reflection_on_BUY   + \r\n                 Burn_on_BUY         + \r\n                 Tokens_on_BUY       + \r\n                 _Fee__Buy_Contract <= 20, \"E02\"); \r\n\r\n        // Update fees\r\n        _Fee__Buy_BNB        = BNB_on_BUY;\r\n        _Fee__Buy_Liquidity  = Liquidity_on_BUY;\r\n        _Fee__Buy_Reflection = Reflection_on_BUY;\r\n        _Fee__Buy_Burn       = Burn_on_BUY;\r\n        _Fee__Buy_Tokens     = Tokens_on_BUY;\r\n\r\n        // Fees that will need to be processed during swap and liquify\r\n        _SwapFeeTotal_Buy    = _Fee__Buy_BNB + _Fee__Buy_Liquidity + _Fee__Buy_Contract;\r\n\r\n        emit updated_Buy_fees(_Fee__Buy_BNB, _Fee__Buy_Liquidity, _Fee__Buy_Reflection, _Fee__Buy_Burn, _Fee__Buy_Tokens, _Fee__Buy_Contract);\r\n    }\r\n\r\n    // Set Sell Fees\r\n    function Contract_SetUp_02__Fees_on_Sell(\r\n\r\n        uint256 BNB_on_SELL,\r\n        uint256 Liquidity_on_SELL, \r\n        uint256 Reflection_on_SELL, \r\n        uint256 Burn_on_SELL,\r\n        uint256 Tokens_on_SELL\r\n\r\n        ) external onlyOwner {\r\n\r\n        _Fee__Sell_Contract = ContractFee;\r\n\r\n        // Buyer protection: max fee can not be set over 20% (including the 1% contract fee if applicable)\r\n        require (BNB_on_SELL        + \r\n                 Liquidity_on_SELL  + \r\n                 Reflection_on_SELL + \r\n                 Burn_on_SELL       + \r\n                 Tokens_on_SELL     + \r\n                 _Fee__Sell_Contract <= 20, \"E03\"); \r\n\r\n        // Update fees\r\n        _Fee__Sell_BNB        = BNB_on_SELL;\r\n        _Fee__Sell_Liquidity  = Liquidity_on_SELL;\r\n        _Fee__Sell_Reflection = Reflection_on_SELL;\r\n        _Fee__Sell_Burn       = Burn_on_SELL;\r\n        _Fee__Sell_Tokens     = Tokens_on_SELL;\r\n\r\n        // Fees that will need to be processed during swap and liquify\r\n        _SwapFeeTotal_Sell   = _Fee__Sell_BNB + _Fee__Sell_Liquidity + _Fee__Sell_Contract;\r\n\r\n        emit updated_Sell_fees(_Fee__Sell_BNB, _Fee__Sell_Liquidity, _Fee__Sell_Reflection, _Fee__Sell_Burn, _Fee__Sell_Tokens, _Fee__Sell_Contract);\r\n    }\r\n\r\n\r\n\r\n    /*\r\n    \r\n    ------------------------------------------\r\n    SET MAX TRANSACTION AND MAX HOLDING LIMITS\r\n    ------------------------------------------\r\n\r\n    To protect buyers, these values must be set to a minimum of 0.1% of the total supply\r\n\r\n    Wallet limits are set as a number of tokens, not as a percent of supply!\r\n\r\n    If you want to limit people to 2% of supply and your supply is 1,000,000 tokens then you \r\n    will need to enter 20000 (as this is 2% of 1,000,000)\r\n\r\n    */\r\n\r\n    // Wallet Holding and Transaction Limits (Enter token amount, excluding decimals)\r\n    function Contract_SetUp_03__Wallet_Limits(\r\n\r\n        uint256 Max_Tokens_Per_Transaction,\r\n        uint256 Max_Total_Tokens_Per_Wallet \r\n\r\n        ) external onlyOwner {\r\n\r\n        // Buyer protection - Limits must be set to greater than 0.1% of total supply\r\n        require(Max_Tokens_Per_Transaction >= _tTotal / 1000 / 10**_decimals, \"E04\");\r\n        require(Max_Total_Tokens_Per_Wallet >= _tTotal / 1000 / 10**_decimals, \"E05\");\r\n        \r\n        max_Tran = Max_Tokens_Per_Transaction * 10**_decimals;\r\n        max_Hold = Max_Total_Tokens_Per_Wallet * 10**_decimals;\r\n\r\n        emit updated_Wallet_Limits(max_Tran, max_Hold);\r\n\r\n    }\r\n\r\n\r\n\r\n    /*\r\n\r\n    ----------------------\r\n    UPDATE PROJECT WALLETS\r\n    ----------------------\r\n\r\n    The contract can process fees in the native token or BNB. \r\n    Processed fees are sent to external wallets (Token_Fee_Wallet and BNB_Fee_Wallet).\r\n\r\n    Cake LP Tokens that are created when the contract makes Auto Liquidity are sent to the Liquidity_Collection_Wallet\r\n    Periodically, these tokens will need to be locked (or burned).\r\n\r\n    During deployment, all external wallets are set to the owner wallet by default, but can be updated here. \r\n\r\n    INVESTORS - Please check the project website for details of how fees are distributed. \r\n\r\n    */\r\n\r\n    function Contract_SetUp_04__Set_Wallets(\r\n\r\n        address Token_Fee_Wallet, \r\n        address payable BNB_Fee_Wallet, \r\n        address Liquidity_Collection_Wallet\r\n\r\n        ) external onlyOwner {\r\n\r\n        // Update Token Fee Wallet\r\n        require(Token_Fee_Wallet != address(0), \"E06\");\r\n        Wallet_Tokens = Token_Fee_Wallet;\r\n\r\n        // Make limit exempt\r\n        _isLimitExempt[Token_Fee_Wallet] = true;\r\n\r\n        // Update BNB Fee Wallet\r\n        require(BNB_Fee_Wallet != address(0), \"E07\");\r\n        Wallet_BNB = payable(BNB_Fee_Wallet);\r\n\r\n        // To send the auto liquidity tokens directly to burn update to 0x000000000000000000000000000000000000dEaD\r\n        Wallet_Liquidity = Liquidity_Collection_Wallet;\r\n\r\n    }\r\n\r\n    /*\r\n\r\n    -----------------\r\n    ADD PROJECT LINKS\r\n    -----------------\r\n\r\n    The information that you add here will appear on BSCScan, helping potential investors to find out more about your project.\r\n    Be sure to enter the complete URL as many websites will automatically detect this, and add links to your token listing.\r\n\r\n    If you are updating one link, you will also need to re-enter the other two links.\r\n\r\n    */\r\n\r\n    function Contract_SetUp_05__Update_Socials(\r\n\r\n        string memory Website_URL, \r\n        string memory Telegram_URL, \r\n        string memory Liquidity_Locker_URL\r\n\r\n        ) external onlyOwner{\r\n\r\n        _Website         = Website_URL;\r\n        _Telegram        = Telegram_URL;\r\n        _LP_Locker_URL   = Liquidity_Locker_URL;\r\n\r\n    }\r\n\r\n\r\n\r\n    /*\r\n    \r\n    --------------------------------\r\n    SET UP PRE-SALE CONTRACT ADDRESS\r\n    --------------------------------\r\n\r\n    If you are doing a pre-sale, the pre-sale company will give you an\r\n    address and tell you that it needs to be white-listed.\r\n\r\n    Enter it here and it will be granted the required privileges.\r\n\r\n    Do not continue with contract setup until the pre-sale has been finalized.\r\n\r\n    */ \r\n\r\n    function Contract_SetUp_06__PreSale_Wallet (address PreSale_Wallet_Address) external onlyOwner {\r\n\r\n        _isLimitExempt[PreSale_Wallet_Address]      = true;\r\n        _isExcludedFromFee[PreSale_Wallet_Address]  = true;\r\n        _isWhiteListed[PreSale_Wallet_Address]      = true;\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /* \r\n\r\n    ---------------------------------\r\n    BLACKLIST BOTS - PRE LAUNCH ONLY!\r\n    --------------------------------- \r\n\r\n    You have the ability to blacklist wallets prior to launch.\r\n    This should only be used for known bot users. \r\n\r\n    Check https://poocoin.app/sniper-watcher to see currently active bot users\r\n\r\n    To blacklist, enter a wallet address and set to true. \r\n    To remove blacklist, enter a wallet address and set to false.\r\n\r\n    To protect your investors (and improve your audit score) you can only blacklist\r\n    wallets before public launch. However, you will still be able to 'un-blacklist' \r\n    previously blacklisted wallets after launch. \r\n\r\n    */\r\n    \r\n\r\n    function Launch_Settings_01__Blacklist_Bots(\r\n\r\n        address Wallet,\r\n        bool true_or_false\r\n\r\n        ) external onlyOwner {\r\n        \r\n        // Buyer Protection - Blacklisting can only be done before launch\r\n        if (true_or_false){require(LaunchTime == 0, \"E08\");}\r\n        _isBlacklisted[Wallet] = true_or_false;\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    /* \r\n\r\n    -----------------------------\r\n    SET LAUNCH LIMIT RESTRICTIONS\r\n    -----------------------------\r\n    \r\n    During the launch phase, additional restrictions can help to spread the tokens more evenly over the initial buyers.\r\n    This helps to prevent whales accumulating a max wallet for almost nothing and prevent dumps.\r\n\r\n    Settings:\r\n        \r\n        Launch_Buy_Delay_Seconds = Number of seconds a buyer will have to wait before buying again\r\n        Launch_Transaction_Limit = Amount of TOKENS that can be purchased in one transaction\r\n        Launch_Phase_Length_Minutes = Time (in minutes) that launch phase restrictions will last\r\n\r\n\r\n    Important:\r\n\r\n        Remember that the transaction limit is in TOKENS not a percent of total supply! \r\n\r\n    Recommendations:\r\n\r\n        I'd suggest having a delay timer of 10 to 20 seconds,\r\n        a transaction limit of 50% of your standard transaction limit,\r\n        and a launch phase length of about 5 minutes\r\n\r\n\r\n    */\r\n\r\n    function Launch_Settings_02__Set_Launch_Limits(\r\n\r\n        uint256 Launch_Buy_Delay_Seconds,\r\n        uint256 Launch_Transaction_Limit_TOKENS, \r\n        uint256 Launch_Phase_Length_Minutes\r\n\r\n        ) external onlyOwner {\r\n\r\n        max_Tran_Launch  = Launch_Transaction_Limit_TOKENS * 10 ** _decimals;\r\n        Launch_Buy_Delay = Launch_Buy_Delay_Seconds;\r\n        Launch_Length    = Launch_Phase_Length_Minutes * 60;\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /*\r\n\r\n    -------------\r\n    ADD LIQUIDITY\r\n    -------------\r\n\r\n    If you have done a pre-sale, the pre-sale company will most likely add the liquidity\r\n    for you automatically. If you are not doing a pre-sale, but you plan to do a private sale,\r\n    you must add the liquidity now, but do not open trade until the private sale is complete.\r\n    \r\n\r\n    To add your liquidity go to\r\n    https://pancakeswap.finance/add/BNB \r\n    and enter your contract address into the 'Select' field.\r\n\r\n    -----------------\r\n    COMPLETE AIRDROPS\r\n    -----------------\r\n\r\n    If your project requires that you airdrop people tokens, you should do this after adding\r\n    liquidity. This will prevent any whitelisted token holders from adding liquidity before you\r\n    and thus setting the price of your token.\r\n\r\n    */\r\n\r\n\r\n\r\n\r\n\r\n    /*\r\n\r\n    ----------\r\n    OPEN TRADE\r\n    ----------\r\n\r\n    */\r\n\r\n\r\n    // Open trade: Buyer Protection - one way switch - trade can not be paused once opened\r\n    function Launch_Settings_03__OpenTrade() external onlyOwner {\r\n\r\n        // Can only use once!\r\n        require(!TradeOpen, \"E09\");\r\n        TradeOpen = true;\r\n        swapAndLiquifyEnabled = true;\r\n        LaunchPhase = true;\r\n        LaunchTime = block.timestamp;\r\n\r\n        emit updated_trade_Open(TradeOpen);\r\n        emit updated_SwapAndLiquify_Enabled(swapAndLiquifyEnabled);\r\n\r\n        // Set the contract fee if required\r\n        _Fee__Buy_Contract   = ContractFee;\r\n        _Fee__Sell_Contract  = ContractFee;\r\n        _SwapFeeTotal_Buy    = _Fee__Buy_Liquidity + _Fee__Buy_BNB + _Fee__Buy_Contract;\r\n        _SwapFeeTotal_Sell   = _Fee__Sell_Liquidity + _Fee__Sell_BNB + _Fee__Sell_Contract;\r\n\r\n        emit set_Contract_Fee(_Fee__Buy_Contract, _Fee__Sell_Contract);\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    /*\r\n\r\n    ------------------------------\r\n    CONTRACT MAINTENANCE FUNCTIONS\r\n    ------------------------------\r\n\r\n    */\r\n\r\n\r\n\r\n    /*\r\n\r\n    -------------------\r\n    REMOVE CONTRACT FEE\r\n    -------------------\r\n\r\n    Remove 1% Contract Fee for 2 BNB \r\n\r\n    If you opted for the 1% ongoing fee in your contract you can remove this at a cost of 2 BNB at any time.\r\n    To do this, enter the number 2 into the field.\r\n\r\n    WARNING - If you renounce the contract, you will lose access to this function!  \r\n\r\n    */\r\n\r\n    function Maintenance_01__Remove_Contract_Fee() external onlyOwner payable {\r\n\r\n        require(msg.value == 2*10**18, \"E10\"); \r\n\r\n            // Check Affiliate is genuine - (Holds the TokensByGEN Affiliate Token)\r\n            if(AFT.balanceOf(Wallet_TBG_AFF) > 0){\r\n\r\n                            uint256 AFF_2BNB = 0;\r\n                            uint256 TBG_2BNB = 0;\r\n\r\n                            // Calculate the affiliate percentage based on GEN holding\r\n                            if(GEN.balanceOf(Wallet_TBG_AFF) >= Tier_3){\r\n\r\n                                AFF_2BNB = 20;\r\n                                TBG_2BNB = 80;\r\n\r\n                            } else if (GEN.balanceOf(Wallet_TBG_AFF) >= Tier_2){\r\n\r\n                                AFF_2BNB = 15;\r\n                                TBG_2BNB = 85;\r\n\r\n                            } else {\r\n\r\n                                AFF_2BNB = 10;\r\n                                TBG_2BNB = 90;\r\n\r\n                            }\r\n\r\n                            // Send BNB to affiliate and TokensByGEN Contract Fee\r\n                            if (AFF_2BNB > 0){     \r\n\r\n                                send_BNB(Wallet_TBG_AFF, msg.value * AFF_2BNB / 100);\r\n                                send_BNB(feeCollector, msg.value * TBG_2BNB / 100);\r\n\r\n                            }\r\n\r\n            } else {\r\n\r\n                // Affiliate is not valid, send BNB to TokensByGEN contract Fee only\r\n                send_BNB(feeCollector, msg.value);\r\n\r\n            }\r\n\r\n        // Remove Contract Fee\r\n        ContractFee              = 0;\r\n        _Fee__Buy_Contract       = 0;\r\n        _Fee__Sell_Contract      = 0;\r\n\r\n        // Emit Contract Fee update\r\n        emit set_Contract_Fee(_Fee__Buy_Contract, _Fee__Sell_Contract);\r\n\r\n        // Update Swap Fees\r\n        _SwapFeeTotal_Buy   = _Fee__Buy_Liquidity + _Fee__Buy_BNB;\r\n        _SwapFeeTotal_Sell  = _Fee__Sell_Liquidity + _Fee__Sell_BNB;\r\n    }\r\n\r\n\r\n    /*\r\n    \r\n    ---------------------------\r\n    ADDING A NEW LIQUIDITY PAIR\r\n    ---------------------------\r\n    \r\n    The only way that your contract knows to apply a fee is when an address is set as true via this function. \r\n\r\n    This has already been done for your BNB pair, but if you add a new pair you need to enter the address of that \r\n    pair into this function and set it to true.\r\n\r\n    When you create a new liquidity pair on pancake swap they mint a new token (called Cake LP) with a unique \r\n    address that represents your token and the other token you used to create the pool.\r\n\r\n    Remember that anybody can create a new liquidity pair for any token. So if you renounce ownership, you will lose \r\n    the ability to update the contract with the new pair address.\r\n\r\n    If you have no-fee for wallet-to-wallet transfers (the default) then there is a potential exploit where the new liquidity\r\n    pair could be used to purchase tokens without paying a fee.\r\n\r\n    Therefore, if you plan to renounce, you must first deactivate the no fee option for wallet-to-wallet transfers.\r\n    You can do this using the \"Contract_Options_02__No_Fee_Wallet_Transfers\" function.\r\n\r\n    Obviously, this is something you need to be very transparent about. If you tell people your token has no fee for \r\n    wallet transfers and later change this, you could be responsible for people losing money. \r\n\r\n    It is best to decide from the very beginning if you plan to renounce in future. If you do, then immediately deactivate\r\n    the fee-free transfer option and do not promote it as a feature of your token. \r\n\r\n\r\n    */\r\n\r\n    // Setting an address as a liquidity pair\r\n    function Maintenance_02__Add_Liquidity_Pair(\r\n\r\n        address Wallet_Address,\r\n        bool true_or_false)\r\n\r\n         external onlyOwner {\r\n        _isPair[Wallet_Address] = true_or_false;\r\n        _isLimitExempt[Wallet_Address] = true_or_false;\r\n    } \r\n\r\n\r\n \r\n\r\n\r\n\r\n\r\n    /* \r\n\r\n    ----------------------------\r\n    CONTRACT OWNERSHIP FUNCTIONS\r\n    ----------------------------\r\n\r\n    */\r\n\r\n\r\n    // Transfer the contract to to a new owner\r\n    function Maintenance_03__Transfer_Ownership(address payable newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"E11\");\r\n\r\n        // Remove old owner status \r\n        _isLimitExempt[owner()]     = false;\r\n        _isExcludedFromFee[owner()] = false;\r\n        _isWhiteListed[owner()]     = false;\r\n\r\n\r\n        // Emit ownership transfer\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n\r\n        // Transfer owner\r\n        _owner = newOwner;\r\n\r\n    }\r\n\r\n    /*\r\n\r\n    Due to a potential exploit, it is not possible to renounce the contract while no-fee wallet-to-wallet \r\n    transfers are set to true. To deactivate this option, use the \"Contract_Options_02__No_Fee_Wallet_Transfers\"\r\n    function and set it as 'false' before renouncing. \r\n\r\n    */\r\n\r\n    // Renounce ownership of the contract \r\n    function Maintenance_04__Renounce_Ownership() public virtual onlyOwner {\r\n        // Renouncing is not compatible with no-fee wallet-to-wallet transfers\r\n        // (also prevents 'accidental' renounce... People like clicking buttons!)\r\n        require(!noFeeW2W, \"Can not renounce and have no-fee wallet transfers!\");\r\n        // Remove old owner status \r\n        _isLimitExempt[owner()]     = false;\r\n        _isExcludedFromFee[owner()] = false;\r\n        _isWhiteListed[owner()]     = false;\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /*\r\n\r\n    --------------\r\n    FEE PROCESSING\r\n    --------------\r\n\r\n    */\r\n\r\n\r\n    // Default is True. Contract will process fees into Marketing and Liquidity etc. automatically\r\n    function Processing_01__Auto_Process(bool true_or_false) external onlyOwner {\r\n        swapAndLiquifyEnabled = true_or_false;\r\n        emit updated_SwapAndLiquify_Enabled(true_or_false);\r\n    }\r\n\r\n\r\n    // Manually process fees\r\n    function Processing_02__Process_Now (uint256 Percent_of_Tokens_to_Process) external onlyOwner {\r\n        require(!inSwapAndLiquify, \"E12\"); \r\n        if (Percent_of_Tokens_to_Process > 100){Percent_of_Tokens_to_Process == 100;}\r\n        uint256 tokensOnContract = balanceOf(address(this));\r\n        uint256 sendTokens = tokensOnContract * Percent_of_Tokens_to_Process / 100;\r\n        swapAndLiquify(sendTokens);\r\n\r\n    }\r\n\r\n    // Update count for swap trigger - Number of transactions to wait before processing accumulated fees (default is 10)\r\n    function Processing_03__Update_Swap_Trigger_Count(uint256 Transaction_Count) external onlyOwner {\r\n        // Counter is reset to 1 (not 0) to save gas, so add one to swapTrigger\r\n        swapTrigger = Transaction_Count + 1;\r\n    }\r\n\r\n\r\n    // Remove random tokens from the contract\r\n    function Processing_04__Remove_Random_Tokens(\r\n\r\n        address random_Token_Address,\r\n        uint256 number_of_Tokens\r\n\r\n        ) external onlyOwner {\r\n            // Can not purge the native token!\r\n            require (random_Token_Address != address(this), \"E13\");\r\n            IERC20(random_Token_Address).transfer(msg.sender, number_of_Tokens);\r\n            \r\n    }\r\n\r\n\r\n    /*\r\n\r\n    ------------------\r\n    REFLECTION REWARDS\r\n    ------------------\r\n\r\n    The following functions are used to exclude or include a wallet in the reflection rewards.\r\n    By default, all wallets are included. \r\n\r\n    Wallets that are excluded:\r\n\r\n            The Burn address \r\n            The Liquidity Pair\r\n            The Contract Address\r\n\r\n    ----------------------------------------\r\n    *** WARNING - DoS 'OUT OF GAS' Risk! ***\r\n    ----------------------------------------\r\n\r\n    A reflections contract needs to loop through all excluded wallets to correctly process several functions. \r\n    This loop can break the contract if it runs out of gas before completion.\r\n\r\n    To prevent this, keep the number of wallets that are excluded from rewards to an absolute minimum. \r\n    In addition to the default excluded wallets, you may need to exclude the address of any locked tokens.\r\n\r\n    */\r\n\r\n\r\n    // Wallet will not get reflections\r\n    function Rewards_Exclude_Wallet(address account) public onlyOwner() {\r\n        require(!_isExcluded[account], \"Account is already excluded\");\r\n        if(_rOwned[account] > 0) {\r\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\r\n        }\r\n        _isExcluded[account] = true;\r\n        _excluded.push(account);\r\n    }\r\n\r\n\r\n    // Wallet will get reflections - DEFAULT\r\n    function Rewards_Include_Wallet(address account) external onlyOwner() {\r\n        require(_isExcluded[account], \"Account is already included\");\r\n        for (uint256 i = 0; i < _excluded.length; i++) {\r\n            if (_excluded[i] == account) {\r\n                _excluded[i] = _excluded[_excluded.length - 1];\r\n                _tOwned[account] = 0;\r\n                _isExcluded[account] = false;\r\n                _excluded.pop();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    \r\n\r\n\r\n   \r\n\r\n\r\n\r\n\r\n    /*\r\n\r\n    ---------------\r\n    WALLET SETTINGS\r\n    ---------------\r\n\r\n    */\r\n\r\n\r\n    // Grants access when trade is closed - Default false (true for contract owner)\r\n    function Wallet_Settings_01__PreLaunch_Access(\r\n\r\n        address Wallet_Address,\r\n        bool true_or_false\r\n\r\n        ) external onlyOwner {    \r\n        _isWhiteListed[Wallet_Address] = true_or_false;\r\n    }\r\n\r\n    // Excludes wallet from transaction and holding limits - Default false\r\n    function Wallet_Settings_02__Exempt_From_Limits(\r\n\r\n        address Wallet_Address,\r\n        bool true_or_false\r\n\r\n        ) external onlyOwner {  \r\n        _isLimitExempt[Wallet_Address] = true_or_false;\r\n    }\r\n\r\n    // Excludes wallet from fees - Default false\r\n    function Wallet_Settings_03__Exclude_From_Fees(\r\n\r\n        address Wallet_Address,\r\n        bool true_or_false\r\n\r\n        ) external onlyOwner {\r\n        _isExcludedFromFee[Wallet_Address] = true_or_false;\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /*\r\n\r\n    -----------------------------\r\n    BEP20 STANDARD AND COMPLIANCE\r\n    -----------------------------\r\n\r\n    */\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns (uint256) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _tTotal;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        if (_isExcluded[account]) return _tOwned[account];\r\n        return tokenFromReflection(_rOwned[account]);\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"Decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n    \r\n    function _approve(address owner, address spender, uint256 amount) private {\r\n        require(owner != address(0), \"BEP20: approve from the zero address\");\r\n        require(spender != address(0), \"BEP20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n   \r\n    function tokenFromReflection(uint256 _rAmount) internal view returns(uint256) {\r\n        require(_rAmount <= _rTotal, \"E14\");\r\n        uint256 currentRate =  _getRate();\r\n        return _rAmount / currentRate;\r\n    }\r\n\r\n    function _getRate() private view returns(uint256) {\r\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\r\n        return rSupply / tSupply;\r\n    }\r\n\r\n    function _getCurrentSupply() private view returns(uint256, uint256) {\r\n        uint256 rSupply = _rTotal;\r\n        uint256 tSupply = _tTotal;      \r\n        for (uint256 i = 0; i < _excluded.length; i++) {\r\n            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\r\n            rSupply = rSupply - _rOwned[_excluded[i]];\r\n            tSupply = tSupply - _tOwned[_excluded[i]];\r\n        }\r\n        if (rSupply < _rTotal / _tTotal) return (_rTotal, _tTotal);\r\n        return (rSupply, tSupply);\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"Allowance exceeded\"));\r\n        return true;\r\n    }\r\n\r\n    // Transfer BNB via call to reduce possibility of future 'out of gas' errors\r\n    function send_BNB(address _to, uint256 _amount) internal returns (bool SendSuccess) {\r\n                                \r\n        (SendSuccess,) = payable(_to).call{value: _amount}(\"\");\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /*\r\n\r\n    -----------------------\r\n    TOKEN TRANSFER HANDLING\r\n    -----------------------\r\n\r\n    */\r\n\r\n    // Main transfer checks and settings \r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n      ) private {\r\n\r\n\r\n        // Allows owner to add liquidity safely, eliminating the risk of someone maliciously setting the price \r\n        if (!TradeOpen){\r\n        require(_isWhiteListed[from] || _isWhiteListed[to], \"E15\");\r\n        }\r\n\r\n\r\n        // Launch Phase\r\n        if (LaunchPhase && to != address(this) && _isPair[from] && to != owner())\r\n            {\r\n\r\n            // Restrict max transaction during launch phase\r\n            require(amount <= max_Tran_Launch, \"E16\");\r\n\r\n            // Stop repeat buys with timer \r\n            require (block.timestamp >= _Last_Buy[to] + Launch_Buy_Delay, \"E17\");\r\n\r\n            // Stop snipers    \r\n            require(!_isSnipe[to], \"E18\");\r\n\r\n            // Detect and restrict snipers\r\n            if (block.timestamp <= LaunchTime + 5) {\r\n                require(amount <= _tTotal / 10000, \"E19\");\r\n                _isSnipe[to] = true;\r\n                }\r\n\r\n            // Record the transaction time for the buying wallet\r\n            _Last_Buy[to] = block.timestamp;\r\n\r\n            // End Launch Phase after Launch_Length (minutes)\r\n            if (block.timestamp > LaunchTime + Launch_Length){LaunchPhase = false;}\r\n\r\n        }\r\n\r\n\r\n\r\n        // No blacklisted wallets permitted! \r\n        require(!_isBlacklisted[to] && !_isBlacklisted[from],\"E20\");\r\n\r\n\r\n        // Wallet Limit\r\n        if (!_isLimitExempt[to] && from != owner())\r\n            {\r\n            uint256 heldTokens = balanceOf(to);\r\n            require((heldTokens + amount) <= max_Hold, \"E21\");\r\n            }\r\n\r\n\r\n        // Transaction limit - To send over the transaction limit the sender AND the recipient must be limit exempt\r\n        if (!_isLimitExempt[to] || !_isLimitExempt[from])\r\n            {\r\n            require(amount <= max_Tran, \"E22\");\r\n            }\r\n\r\n\r\n        // Compliance and safety checks\r\n        require(from != address(0), \"E23\");\r\n        require(to != address(0), \"E24\");\r\n        require(amount > 0, \"E25\");\r\n\r\n\r\n\r\n        // Check if fee processing is possible\r\n        if( _isPair[to] &&\r\n            !inSwapAndLiquify &&\r\n            swapAndLiquifyEnabled\r\n            )\r\n            {\r\n\r\n            // Check that enough transactions have passed since last swap\r\n            if(swapCounter >= swapTrigger){\r\n\r\n            // Check number of tokens on contract\r\n            uint256 contractTokens = balanceOf(address(this));\r\n\r\n            // Only trigger fee processing if there are tokens to swap!\r\n            if (contractTokens > 0){\r\n\r\n                // Limit number of tokens that can be swapped \r\n                if (contractTokens <= swap_Max){\r\n                    swapAndLiquify (contractTokens);\r\n                    } else {\r\n                    swapAndLiquify (swap_Max);\r\n                    }\r\n            }\r\n            }  \r\n            }\r\n\r\n\r\n        // Default: Only charge a fee on buys and sells, no fee for wallet transfers\r\n        takeFee = true;\r\n        if(_isExcludedFromFee[from] || _isExcludedFromFee[to] || (noFeeW2W && !_isPair[to] && !_isPair[from])){\r\n            takeFee = false;\r\n        }\r\n\r\n        _tokenTransfer(from, to, amount, takeFee);\r\n\r\n    }\r\n\r\n\r\n    /*\r\n    \r\n    ------------\r\n    PROCESS FEES\r\n    ------------\r\n\r\n    */\r\n\r\n    function swapAndLiquify(uint256 Tokens) private {\r\n\r\n        /*\r\n        \r\n        Fees are processed as an average of each buy/sell fee total      \r\n\r\n        */\r\n\r\n        // Lock swapAndLiquify function\r\n        inSwapAndLiquify        = true;  \r\n\r\n        uint256 _FeesTotal      = (_SwapFeeTotal_Buy + _SwapFeeTotal_Sell);\r\n        uint256 LP_Tokens       = Tokens * (_Fee__Buy_Liquidity + _Fee__Sell_Liquidity) / _FeesTotal / 2;\r\n        uint256 Swap_Tokens     = Tokens - LP_Tokens;\r\n\r\n        // Swap tokens for BNB\r\n        uint256 contract_BNB    = address(this).balance;\r\n        swapTokensForBNB(Swap_Tokens);\r\n        uint256 returned_BNB    = address(this).balance - contract_BNB;\r\n\r\n        // Double fees instead of halving LP fee to prevent rounding errors if fee is an odd number\r\n        uint256 fee_Split = _FeesTotal * 2 - (_Fee__Buy_Liquidity + _Fee__Sell_Liquidity);\r\n\r\n        // Calculate the BNB values for each fee (excluding BNB wallet)\r\n        uint256 BNB_Liquidity   = returned_BNB * (_Fee__Buy_Liquidity     + _Fee__Sell_Liquidity)       / fee_Split;\r\n        uint256 BNB_Contract    = returned_BNB * (_Fee__Buy_Contract      + _Fee__Sell_Contract)    * 2 / fee_Split;\r\n\r\n        // Add liquidity \r\n        if (LP_Tokens != 0){\r\n            addLiquidity(LP_Tokens, BNB_Liquidity);\r\n            emit SwapAndLiquify(LP_Tokens, BNB_Liquidity, LP_Tokens);\r\n        }\r\n   \r\n\r\n        // Take developer fee\r\n        if(BNB_Contract > 0){\r\n\r\n            // Check Affiliate is genuine - (Holds the TokensByGEN Affiliate Token)\r\n            if(AFT.balanceOf(Wallet_TBG_AFF) > 0){\r\n\r\n                    uint256 BNB_TBG = 0;\r\n                    uint256 BNB_DEV = 0;\r\n\r\n                    if(GEN.balanceOf(Wallet_TBG_AFF) >= Tier_3){\r\n\r\n                        BNB_TBG = BNB_Contract * 20 / 100;\r\n                        BNB_DEV = BNB_Contract * 70 / 100;\r\n\r\n                    } else if (GEN.balanceOf(Wallet_TBG_AFF) >= Tier_2){\r\n\r\n                        BNB_TBG = BNB_Contract * 15 / 100;\r\n                        BNB_DEV = BNB_Contract * 75 / 100;\r\n\r\n                    } else {\r\n\r\n                        BNB_TBG = BNB_Contract * 10 / 100;\r\n                        BNB_DEV = BNB_Contract * 80 / 100;\r\n\r\n                    }\r\n\r\n                    if (BNB_TBG != 0){\r\n\r\n                        // Send affiliate commission and TokensByGEN fee\r\n                        send_BNB(Wallet_TBG_AFF, BNB_TBG);\r\n                        send_BNB(feeCollector, BNB_DEV);\r\n\r\n                    }\r\n\r\n            } else {\r\n\r\n            // No affiliate (or not genuine) send total fee to TokensByGEN\r\n                    send_BNB(feeCollector, BNB_Contract);\r\n\r\n            }\r\n\r\n        }\r\n\r\n        \r\n        // Send remaining BNB to BNB wallet (includes 10% fee discount if applicable)\r\n        contract_BNB = address(this).balance;\r\n\r\n        if(contract_BNB > 0){\r\n\r\n            send_BNB(Wallet_BNB, contract_BNB);\r\n        }\r\n\r\n\r\n        // Reset transaction counter (reset to 1 not 0 to save gas)\r\n        swapCounter = 1;\r\n\r\n        // Unlock swapAndLiquify function\r\n        inSwapAndLiquify = false;\r\n    }\r\n\r\n\r\n\r\n    // Swap tokens for BNB\r\n    function swapTokensForBNB(uint256 tokenAmount) private {\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = uniswapV2Router.WETH();\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0, \r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n\r\n\r\n    // Add liquidity and send Cake LP tokens to liquidity collection wallet\r\n    function addLiquidity(uint256 tokenAmount, uint256 BNBAmount) private {\r\n\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        uniswapV2Router.addLiquidityETH{value: BNBAmount}(\r\n            address(this),\r\n            tokenAmount,\r\n            0, \r\n            0,\r\n            Wallet_Liquidity, \r\n            block.timestamp\r\n        );\r\n    } \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /*\r\n    \r\n    ----------------------------------\r\n    TRANSFER TOKENS AND CALCULATE FEES\r\n    ----------------------------------\r\n\r\n    */\r\n\r\n\r\n    uint256 private rAmount;\r\n\r\n    uint256 private tBurn;\r\n    uint256 private tTokens;\r\n    uint256 private tReflect;\r\n    uint256 private tSwapFeeTotal;\r\n\r\n    uint256 private rBurn;\r\n    uint256 private rReflect;\r\n    uint256 private rTokens;\r\n    uint256 private rSwapFeeTotal;\r\n    uint256 private tTransferAmount;\r\n    uint256 private rTransferAmount;\r\n\r\n    \r\n\r\n    // Transfer Tokens and Calculate Fees\r\n    function _tokenTransfer(address sender, address recipient, uint256 tAmount, bool Fee) private {\r\n\r\n        \r\n        if (Fee){\r\n\r\n            if(_isPair[recipient]){\r\n\r\n                // Sell fees\r\n                tBurn           = tAmount * _Fee__Sell_Burn       / 100;\r\n                tTokens         = tAmount * _Fee__Sell_Tokens     / 100;\r\n                tReflect        = tAmount * _Fee__Sell_Reflection / 100;\r\n                tSwapFeeTotal   = tAmount * _SwapFeeTotal_Sell    / 100;\r\n\r\n            } else {\r\n\r\n                // Buy fees\r\n                tBurn           = tAmount * _Fee__Buy_Burn        / 100;\r\n                tTokens         = tAmount * _Fee__Buy_Tokens      / 100;\r\n                tReflect        = tAmount * _Fee__Buy_Reflection  / 100;\r\n                tSwapFeeTotal   = tAmount * _SwapFeeTotal_Buy     / 100;\r\n\r\n            }\r\n\r\n        } else {\r\n\r\n                // No fee - wallet to wallet transfer or exempt wallet \r\n                tBurn           = 0;\r\n                tTokens         = 0;\r\n                tReflect        = 0;\r\n                tSwapFeeTotal   = 0;\r\n\r\n        }\r\n\r\n        // Calculate reflected fees for RFI\r\n        uint256 RFI     = _getRate(); \r\n\r\n        rAmount         = tAmount       * RFI;\r\n        rBurn           = tBurn         * RFI;\r\n        rTokens         = tTokens       * RFI;\r\n        rReflect        = tReflect      * RFI;\r\n        rSwapFeeTotal   = tSwapFeeTotal * RFI;\r\n\r\n        tTransferAmount = tAmount - (tBurn + tTokens + tReflect + tSwapFeeTotal);\r\n        rTransferAmount = rAmount - (rBurn + rTokens + rReflect + rSwapFeeTotal);\r\n\r\n        \r\n        // Swap tokens based on RFI status of sender and recipient\r\n        if (_isExcluded[sender] && !_isExcluded[recipient]) {\r\n\r\n            _tOwned[sender] -= tAmount;\r\n            _rOwned[sender] -= rAmount;\r\n\r\n                if (deflationaryBurn && recipient == Wallet_Burn) {\r\n\r\n                // Remove tokens from Total Supply \r\n                _tTotal -= tTransferAmount;\r\n                _rTotal -= rTransferAmount;\r\n\r\n                } else {\r\n\r\n                _rOwned[recipient] += rTransferAmount;\r\n\r\n                }\r\n\r\n            emit Transfer(sender, recipient, tTransferAmount);\r\n\r\n        } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\r\n\r\n            _rOwned[sender] -= rAmount;\r\n\r\n                if (deflationaryBurn && recipient == Wallet_Burn) {\r\n\r\n                // Remove tokens from Total Supply \r\n                _tTotal -= tTransferAmount;\r\n                _rTotal -= rTransferAmount;\r\n\r\n                } else {\r\n\r\n                _tOwned[recipient] += tTransferAmount;\r\n                _rOwned[recipient] += rTransferAmount;\r\n\r\n                }\r\n\r\n            emit Transfer(sender, recipient, tTransferAmount);\r\n\r\n        } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\r\n\r\n            _rOwned[sender] -= rAmount;\r\n\r\n                if (deflationaryBurn && recipient == Wallet_Burn) {\r\n\r\n                // Remove tokens from Total Supply \r\n                _tTotal -= tTransferAmount;\r\n                _rTotal -= rTransferAmount;\r\n\r\n                } else {\r\n\r\n                _rOwned[recipient] += rTransferAmount;\r\n\r\n                }\r\n\r\n            emit Transfer(sender, recipient, tTransferAmount);\r\n\r\n        } else if (_isExcluded[sender] && _isExcluded[recipient]) {\r\n\r\n            _tOwned[sender] -= tAmount;\r\n            _rOwned[sender] -= rAmount;\r\n\r\n                if (deflationaryBurn && recipient == Wallet_Burn) {\r\n\r\n                // Remove tokens from Total Supply \r\n                _tTotal -= tTransferAmount;\r\n                _rTotal -= rTransferAmount;\r\n\r\n                } else {\r\n\r\n                _tOwned[recipient] += tTransferAmount;\r\n                _rOwned[recipient] += rTransferAmount;\r\n\r\n                }\r\n\r\n            emit Transfer(sender, recipient, tTransferAmount);\r\n\r\n        } else {\r\n\r\n            _rOwned[sender] -= rAmount;\r\n\r\n                if (deflationaryBurn && recipient == Wallet_Burn) {\r\n\r\n                // Remove tokens from Total Supply \r\n                _tTotal -= tTransferAmount;\r\n                _rTotal -= rTransferAmount;\r\n\r\n                } else {\r\n\r\n                _rOwned[recipient] += rTransferAmount;\r\n\r\n                }\r\n\r\n            emit Transfer(sender, recipient, tTransferAmount);\r\n\r\n        }\r\n\r\n\r\n        // Take reflections\r\n        if(tReflect > 0){\r\n\r\n            _rTotal -= rReflect;\r\n            _tFeeTotal += tReflect;\r\n        }\r\n\r\n        // Take tokens\r\n        if(tTokens > 0){\r\n\r\n            _rOwned[Wallet_Tokens] += rTokens;\r\n            if(_isExcluded[Wallet_Tokens])\r\n            _tOwned[Wallet_Tokens] += tTokens;\r\n\r\n        }\r\n\r\n        // Take fees that require processing during swap and liquify\r\n        if(tSwapFeeTotal > 0){\r\n\r\n            _rOwned[address(this)] += rSwapFeeTotal;\r\n            if(_isExcluded[address(this)])\r\n            _tOwned[address(this)] += tSwapFeeTotal;\r\n\r\n            // Increase the transaction counter\r\n            swapCounter++;\r\n                \r\n        }\r\n\r\n        // Handle tokens for burn\r\n        if(tBurn != 0){\r\n\r\n            if (deflationaryBurn){\r\n\r\n                // Remove tokens from total supply\r\n                _tTotal = _tTotal - tBurn;\r\n                _rTotal = _rTotal - rBurn;\r\n\r\n            } else {\r\n\r\n                // Send Tokens to Burn Wallet\r\n                _rOwned[Wallet_Burn] += tBurn;\r\n                if(_isExcluded[Wallet_Burn])\r\n                _tOwned[Wallet_Burn] += rBurn;\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n   \r\n\r\n    // This function is required so that the contract can receive BNB during fee processing\r\n    receive() external payable {}\r\n\r\n\r\n\r\n\r\n}\r\n\r\n/*\r\n\r\n---------------------\r\n**** ERROR CODES ****\r\n---------------------\r\n\r\nThis contract was over the byte size limits permitted on BSC, in order for it to deploy correctly, \r\nsome code needed to be removed to reduce the size of the contract. This was done by removing error messages\r\nin require statements throughout the contract. They have been replaced by error codes which you can check here. \r\n\r\n    E01 - This function has been locked and can no longer be accessed\r\n    E02 - Buy fees are limited of 20% max to protect buyers (includes 1% dev fee if chosen)\r\n    E03 - Sell fees are limited of 20% max to protect buyers (includes 1% dev fee if chosen)\r\n    E04 - The max transaction limit must be set to more than 0.1% of total supply\r\n    E05 - The max wallet holding limit must be set to more than 0.1% of total supply\r\n    E06 - A valid BSC wallet must be entered when updating the token fee wallet \r\n    E07 - A valid BSC wallet must be entered when updating the BNB fee wallet \r\n    E08 - Blacklisting of wallets can only be applied before public launch\r\n    E09 - Trade is already open\r\n    E10 - A fee of 2 BNB is required, enter 2 into the field and try again\r\n    E11 - A valid BSC wallet must be entered when transferring ownership\r\n    E12 - Contract is currently processing fees, try later\r\n    E13 - Can not remove the native token\r\n    E14 - rAmount can not be greater than rTotal\r\n    E15 - Trade is not open, only whitelisted wallets can trade\r\n    E16 - Trying to buy over the launch phase max transaction limit\r\n    E17 - Buying too quickly, wait for delay timer during launch phase\r\n    E18 - Wallet was flagged as a snipe and can not purchase again during launch phase\r\n    E19 - Sniper bot max transaction limit exceeded\r\n    E20 - Wallet has been blacklisted, trade cancelled\r\n    E21 - Purchase would exceed max wallet holding limit, trade cancelled\r\n    E22 - Purchase would exceed max transaction limit, trade cancelled \r\n    E23 - Zero address error, please use a valid BSC address\r\n    E24 - Zero address error, please use a valid BSC address\r\n    E25 - Amount must be greater than 0\r\n\r\n*/\r\n\r\n\r\n// Contract Created by https://TokensByGEN.com\r\n// Not open source - Can not be used or forked without permission.\r\n// Reflections Contract with Snipe Protection and Launch Limits", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_TokenName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_TokenSymbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_TotalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_Decimals\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_OwnerWallet\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_DiscountCode\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_ContractFee\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiqudity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Contract_Development_Buy_Fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Contract_Development_Sell_Fee\",\"type\":\"uint256\"}],\"name\":\"set_Contract_Fee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Marketing\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Liquidity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Reflection\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Burn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Contract_Development_Fee\",\"type\":\"uint256\"}],\"name\":\"updated_Buy_fees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Marketing\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Liquidity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Reflection\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Burn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Contract_Development_Fee\",\"type\":\"uint256\"}],\"name\":\"updated_Sell_fees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"Swap_and_Liquify_Enabled\",\"type\":\"bool\"}],\"name\":\"updated_SwapAndLiquify_Enabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"max_Tran\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"max_Hold\",\"type\":\"uint256\"}],\"name\":\"updated_Wallet_Limits\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"TradeOpen\",\"type\":\"bool\"}],\"name\":\"updated_trade_Open\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"true_or_false\",\"type\":\"bool\"}],\"name\":\"Contract_Options_01__Deflationary_Burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"true_or_false\",\"type\":\"bool\"}],\"name\":\"Contract_Options_02__No_Fee_Wallet_Transfers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"BNB_on_BUY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Liquidity_on_BUY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Reflection_on_BUY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Burn_on_BUY\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Tokens_on_BUY\",\"type\":\"uint256\"}],\"name\":\"Contract_SetUp_01__Fees_on_Buy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"BNB_on_SELL\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Liquidity_on_SELL\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Reflection_on_SELL\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Burn_on_SELL\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Tokens_on_SELL\",\"type\":\"uint256\"}],\"name\":\"Contract_SetUp_02__Fees_on_Sell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"Max_Tokens_Per_Transaction\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Max_Total_Tokens_Per_Wallet\",\"type\":\"uint256\"}],\"name\":\"Contract_SetUp_03__Wallet_Limits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Token_Fee_Wallet\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"BNB_Fee_Wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"Liquidity_Collection_Wallet\",\"type\":\"address\"}],\"name\":\"Contract_SetUp_04__Set_Wallets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"Website_URL\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"Telegram_URL\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"Liquidity_Locker_URL\",\"type\":\"string\"}],\"name\":\"Contract_SetUp_05__Update_Socials\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"PreSale_Wallet_Address\",\"type\":\"address\"}],\"name\":\"Contract_SetUp_06__PreSale_Wallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Wallet\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"true_or_false\",\"type\":\"bool\"}],\"name\":\"Launch_Settings_01__Blacklist_Bots\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"Launch_Buy_Delay_Seconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Launch_Transaction_Limit_TOKENS\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Launch_Phase_Length_Minutes\",\"type\":\"uint256\"}],\"name\":\"Launch_Settings_02__Set_Launch_Limits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Launch_Settings_03__OpenTrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Maintenance_01__Remove_Contract_Fee\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Wallet_Address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"true_or_false\",\"type\":\"bool\"}],\"name\":\"Maintenance_02__Add_Liquidity_Pair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"Maintenance_03__Transfer_Ownership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Maintenance_04__Renounce_Ownership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"true_or_false\",\"type\":\"bool\"}],\"name\":\"Processing_01__Auto_Process\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"Percent_of_Tokens_to_Process\",\"type\":\"uint256\"}],\"name\":\"Processing_02__Process_Now\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"Transaction_Count\",\"type\":\"uint256\"}],\"name\":\"Processing_03__Update_Swap_Trigger_Count\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"random_Token_Address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"number_of_Tokens\",\"type\":\"uint256\"}],\"name\":\"Processing_04__Remove_Random_Tokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Rewards_Exclude_Wallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Rewards_Include_Wallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Token_Information\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"Token_Name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"Token_Symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"Number_of_Decimals\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"Owner_Wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"Transaction_Limit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Max_Wallet\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Fee_When_Buying\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Fee_When_Selling\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"Website\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"Telegram\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"Liquidity_Lock_URL\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"Contract_Created_By\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TradeOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Wallet_BNB\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Wallet_Burn\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Wallet_Liquidity\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Wallet_Address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"true_or_false\",\"type\":\"bool\"}],\"name\":\"Wallet_Settings_01__PreLaunch_Access\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Wallet_Address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"true_or_false\",\"type\":\"bool\"}],\"name\":\"Wallet_Settings_02__Exempt_From_Limits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Wallet_Address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"true_or_false\",\"type\":\"bool\"}],\"name\":\"Wallet_Settings_03__Exclude_From_Fees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Wallet_TBG_AFF\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Wallet_Tokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_Fee__Buy_BNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_Fee__Buy_Burn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_Fee__Buy_Contract\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_Fee__Buy_Liquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_Fee__Buy_Reflection\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_Fee__Buy_Tokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_Fee__Sell_BNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_Fee__Sell_Burn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_Fee__Sell_Contract\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_Fee__Sell_Liquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_Fee__Sell_Reflection\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_Fee__Sell_Tokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isBlacklisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isExcluded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isExcludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isLimitExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isPair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isSnipe\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isWhiteListed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deflationaryBurn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeCollector\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inSwapAndLiquify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapAndLiquifyEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Contract", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000f42400000000000000000000000000000000000000000000000000000000000000004000000000000000000000000d05895edf847e1712721cc9e0427aa26289a6bc5000000000000000000000000d05895edf847e1712721cc9e0427aa26289a6bc50000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c5442475f5265665f44656d6f000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000075442475f52454600000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://2d2a2282b8a8547b010ea4ecd38989712dc69b29ac12519152604cb4e8e8ffc3"}