{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/PotFighter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier:MIT\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\n\\r\\n//  >>>>>>>>>  Developed by anwarservices22@gmail.com <<<<<<<<<<<<\\r\\n//  >>>>>>>>>  Developed by zeeshanm.nawaz786@gmail.com <<<<<<<<<<\\r\\n//  >>>>>>>>>  Developed by mirzamuhammadbaig328@gmail.com <<<<<<<\\r\\n\\r\\ncontract PotFighter is Ownable {\\r\\n    uint256 public potFee = 1 ether;\\r\\n    uint256 public rewardPerSecondPercent = 3;\\r\\n    uint256 internal potId = 1; //RESPONSIBLE FOR ASSIGNING UNIQUE IDENTIFIER TO THE POT\\r\\n    address public reserveWallet = 0xBC117CD3705F41Ba09E2f1c5695FB1f3920f21CD;\\r\\n    address public devTeam = 0x259d0B10E7Ffc38F5736876B7Ebdc7CB5b3d0e32;\\r\\n    uint8[5] distribution = [40, 31, 18, 8, 3];\\r\\n    bool public potCreation;\\r\\n\\r\\n    event PotCreated(address from, uint256 fee, uint256 atTime);\\r\\n    event PotJoined(address joiner, uint256 againstAmount, uint256 atTime);\\r\\n\\r\\n    modifier potFreezed(uint256 _potId) {\\r\\n        require(freezedPot[_potId] == false, \\\"pot is freezed\\\");\\r\\n        _;\\r\\n    }\\r\\n    modifier userBlackListed() {\\r\\n        require(\\r\\n            blackListedUser[msg.sender] == false,\\r\\n            \\\"you are blackListed User\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    struct EarningsInfo {\\r\\n        address userAddress;\\r\\n        uint256 earnings;\\r\\n    }\\r\\n\\r\\n    struct participant {\\r\\n        address payable userAddress;\\r\\n        uint256 startedAt; //THE TIME PLAYER ENTERD THE POT\\r\\n        uint256 endedAt; //THE TIME PLAYER IS REPLACED AS A LAST PLAYER\\r\\n        uint256 durationPlayed; //TOTAL TIME DURATION IN SECOND'S THAT THE PLAYER HAD PLAYED\\r\\n        uint256 reward; //REWARD EARNED PER 0.001 OF POT BALANCE PER SECOND\\r\\n        bool rewardCollected; //MONITOR TO WHETHER USER HAS GET HIS REWARD YET OR NOT\\r\\n    }\\r\\n    struct Pot {\\r\\n        uint256 potID; //UNIQU POT ID\\r\\n        address creator; //POT OWNER\\r\\n        uint256 potBalance; //POT BALANCE OF ALL TIME\\r\\n        participant[] participants; //PLAYER'S IN THE POT\\r\\n        bool claimingActive; //REWARD CLAIMING WHEN POT BALNCE RUNS OUT\\r\\n        bool isEnded; //POT RUNNING STATUS WHETHER IT'S RUNNING OR NOT\\r\\n        uint256 participationFeee;\\r\\n        uint256 begining;\\r\\n        uint256 lifeTime; //DURATION OF THE POT\\r\\n        bool claimingFinished;\\r\\n    }\\r\\n\\r\\n    mapping(uint256 => Pot) public createdPots; //POTS CREATED OF ALL TIME BY ID\\r\\n    mapping(uint256 => bool) public freezedPot; //POT FREEZING MONITOR\\r\\n    mapping(address => bool) public blackListedUser; //RESTRICED\\r\\n\\r\\n    function createPot() external payable userBlackListed {\\r\\n        Pot storage pot = createdPots[potId];\\r\\n\\r\\n        require(msg.value == potFee, \\\"pay exact fee to create Pot\\\");\\r\\n        require(!potCreation, \\\"POT CREATION IS FREEZED\\\");\\r\\n\\r\\n        pot.creator = msg.sender;\\r\\n        pot.potBalance += msg.value; //ADD THE AMOUNT TO POT\\r\\n        pot.begining = block.timestamp;\\r\\n        pot.participationFeee = 20000000000000000;\\r\\n        //ORGANIZER IS ALSO SET AS A FIRST PLAYER\\r\\n        pot.participants.push(\\r\\n            participant({\\r\\n                userAddress: payable(msg.sender),\\r\\n                startedAt: block.number, // THE CURRENT TIME AT WHICH GAME IS STARTED\\r\\n                endedAt: 0, // OTHER VALUES WILL BE PASSED AS OF DEFAULT FOR NOW\\r\\n                durationPlayed: 0,\\r\\n                reward: 0,\\r\\n                rewardCollected: false\\r\\n            })\\r\\n        );\\r\\n        pot.lifeTime = (block.timestamp + 21600);\\r\\n        pot.potID = potId;\\r\\n        potId++; //this line make sure that each pot has unique id\\r\\n        emit PotCreated(msg.sender, msg.value, block.timestamp);\\r\\n        emit PotJoined(msg.sender, msg.value, block.timestamp);\\r\\n    }\\r\\n\\r\\n    function joinPot(\\r\\n        uint256 _potId\\r\\n    ) external payable potFreezed(_potId) userBlackListed {\\r\\n        Pot storage pot = createdPots[_potId];\\r\\n        require(\\r\\n            msg.value == pot.participationFeee,\\r\\n            \\\"Pay the exact participation fee to join the pot\\\"\\r\\n        );\\r\\n        require(block.timestamp < pot.lifeTime, \\\"life ended activate claiming\\\");\\r\\n        require(!pot.isEnded, \\\"pot ended\\\");\\r\\n        require(_potId != 0 && _potId <= potId, \\\"Invalid Pot Id\\\");\\r\\n        require(\\r\\n            pot.potBalance >= 0.001 ether,\\r\\n            \\\"Pot balance isn't valid to play further\\\"\\r\\n        );\\r\\n\\r\\n        uint256 currentSize = pot.participants.length;\\r\\n        participant storage previousParticipant = pot.participants[\\r\\n            currentSize - 1\\r\\n        ];\\r\\n        previousParticipant.endedAt = block.number;\\r\\n        uint256 blocksElapsed = previousParticipant.endedAt -\\r\\n            previousParticipant.startedAt;\\r\\n        previousParticipant.durationPlayed += blocksElapsed;\\r\\n        bool rewardMonitor;\\r\\n\\r\\n        for (uint256 i = 0; i < blocksElapsed; i++) {\\r\\n            uint256 percentPerSecond = (pot.potBalance *\\r\\n                rewardPerSecondPercent) / 10000;\\r\\n\\r\\n            // Check if the reward calculation exceeds the pot balance\\r\\n            if (percentPerSecond > pot.potBalance) {\\r\\n                rewardMonitor = true;\\r\\n                previousParticipant.reward += pot.potBalance;\\r\\n                break;\\r\\n            }\\r\\n\\r\\n            // Calculate reward for the current second\\r\\n            previousParticipant.reward += percentPerSecond;\\r\\n            pot.potBalance -= percentPerSecond;\\r\\n        }\\r\\n\\r\\n        if (rewardMonitor) {\\r\\n            payable(msg.sender).transfer(msg.value);\\r\\n            pot.claimingActive = true;\\r\\n        } else {\\r\\n            // Distribute the fees and adjust the pot balance\\r\\n            distributeFees(pot, currentSize, msg.value);\\r\\n            //below distribution for reward\\r\\n\\r\\n            uint256 startIndex;\\r\\n            uint256 lastIndex;\\r\\n\\r\\n            if (currentSize > 5) {\\r\\n                startIndex = currentSize - 5;\\r\\n                lastIndex = currentSize;\\r\\n                uint256 playerReward = pot.participants[startIndex].reward;\\r\\n\\r\\n                for (uint256 i = startIndex; i < lastIndex; i++) {\\r\\n                    uint256 toSend = (playerReward *\\r\\n                        distribution[i - startIndex]) / 100;\\r\\n\\r\\n                    payable(pot.participants[i].userAddress).transfer(toSend);\\r\\n                }\\r\\n                pot.participants[startIndex].rewardCollected = true;\\r\\n                pot.participants[startIndex].reward = 0;\\r\\n            } else if (currentSize == 5) {\\r\\n                startIndex = 0;\\r\\n                lastIndex = currentSize;\\r\\n                uint256 playerRewardFor = pot.participants[startIndex].reward;\\r\\n                for (uint256 i = startIndex; i < lastIndex; i++) {\\r\\n                    payable(pot.participants[i].userAddress).transfer(\\r\\n                        (playerRewardFor * distribution[i - startIndex]) / 100\\r\\n                    );\\r\\n                    playerRewardFor -=\\r\\n                        (playerRewardFor * distribution[i]) /\\r\\n                        100;\\r\\n                }\\r\\n                pot.participants[startIndex].rewardCollected = true;\\r\\n                pot.participants[startIndex].reward = 0;\\r\\n            }\\r\\n\\r\\n            // Create a new participant\\r\\n            pot.participants.push(\\r\\n                participant({\\r\\n                    userAddress: payable(msg.sender),\\r\\n                    startedAt: block.number,\\r\\n                    endedAt: 0,\\r\\n                    durationPlayed: 0,\\r\\n                    reward: 0,\\r\\n                    rewardCollected: false\\r\\n                })\\r\\n            );\\r\\n            uint256 increaseInFee = feePercent(pot);\\r\\n            pot.participationFeee += increaseInFee;\\r\\n            pot.lifeTime += 60;\\r\\n            emit PotJoined(msg.sender, msg.value, block.timestamp);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function distributeFees(\\r\\n        Pot storage pot,\\r\\n        uint256 currentSize,\\r\\n        uint256 totalFees\\r\\n    ) internal {\\r\\n        uint256 ownerCut = (totalFees * 50) / 100;\\r\\n        uint256 partnerCut = (totalFees * 5) / 100;\\r\\n        uint256 teamCut = (totalFees * 5) / 100;\\r\\n        uint256 previousPlayers = (totalFees * 20) / 100;\\r\\n        uint256 potBalanceSubmit = (totalFees * 20) / 100;\\r\\n\\r\\n        payable(pot.creator).transfer(ownerCut);\\r\\n        payable(reserveWallet).transfer(partnerCut);\\r\\n        payable(devTeam).transfer(teamCut);\\r\\n\\r\\n        if (currentSize == 1) {\\r\\n            payable(pot.participants[0].userAddress).transfer(previousPlayers);\\r\\n        } else if (currentSize > 1) {\\r\\n            uint256 divideAmong = previousPlayers / currentSize;\\r\\n            for (uint256 i = 0; i < currentSize; i++) {\\r\\n                payable(pot.participants[i].userAddress).transfer(divideAmong);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        pot.potBalance += potBalanceSubmit;\\r\\n    }\\r\\n\\r\\n    function activateClaiming(uint256 _potId) public {\\r\\n        Pot storage pot = createdPots[_potId]; // Change memory to storage\\r\\n        require(_potId != 0 && _potId <= potId, \\\"invalid Pot Id\\\");\\r\\n        require(block.timestamp > pot.lifeTime, \\\"pot isn't ended yet\\\");\\r\\n        require(!pot.claimingActive, \\\"claiming already activated\\\");\\r\\n        require(\\r\\n            msg.sender == pot.creator,\\r\\n            \\\"only pot owner can activate claiming\\\"\\r\\n        );\\r\\n\\r\\n        // rewardPerSecondPercent = 3;\\r\\n        participant storage lastPlayer = pot.participants[\\r\\n            pot.participants.length - 1\\r\\n        ];\\r\\n        lastPlayer.reward += pot.potBalance;\\r\\n        pot.potBalance = 0;\\r\\n        pot.claimingActive = true;\\r\\n        lastPlayer.endedAt = block.number;\\r\\n        pot.isEnded = true;\\r\\n        uint256 blocksElapsed = lastPlayer.endedAt - lastPlayer.startedAt;\\r\\n        lastPlayer.durationPlayed += blocksElapsed;\\r\\n    }\\r\\n\\r\\n    //FUNCTION TO INCREASE THE PARTICIPATION FEE\\r\\n\\r\\n    function feePercent(Pot storage pot) internal view returns (uint256) {\\r\\n        uint256 percent = (pot.participationFeee * 1) / 100;\\r\\n        return percent;\\r\\n    }\\r\\n\\r\\n    //FUNCTION TO EDIT DEV WALLET\\r\\n    function setDevWallet(address _newWallet) public onlyOwner {\\r\\n        require(_newWallet != address(0), \\\"invalid address\\\");\\r\\n        require(\\r\\n            _newWallet != devTeam,\\r\\n            \\\"address already declared as dev team wallet\\\"\\r\\n        );\\r\\n        devTeam = _newWallet;\\r\\n    }\\r\\n\\r\\n    //FUNCTION TO CLAIM REWARD\\r\\n    function claimReward(uint256 _potId) public {\\r\\n        Pot storage pot = createdPots[_potId];\\r\\n        require(_potId != 0 && _potId <= potId, \\\"invalid Pot Id\\\");\\r\\n        require(!pot.claimingFinished, \\\"Pot & claiming has been finished\\\");\\r\\n        require(pot.claimingActive, \\\"claiming isn't active\\\");\\r\\n        bool hasJoined;\\r\\n        uint256 size = pot.participants.length;\\r\\n        for (uint256 i = 0; i < size; i++) {\\r\\n            if (pot.participants[i].userAddress == msg.sender) {\\r\\n                hasJoined = true;\\r\\n                if (pot.participants[i].rewardCollected) {\\r\\n                    continue;\\r\\n                } else {\\r\\n                    payable(msg.sender).transfer(pot.participants[i].reward);\\r\\n                    pot.participants[i].reward = 0;\\r\\n                    pot.participants[i].rewardCollected = true;\\r\\n                    break;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        require(hasJoined, \\\"you haven't joined the pot\\\");\\r\\n        bool toSelect = allRewardClaimed(_potId);\\r\\n        if (toSelect) {\\r\\n            pot.claimingFinished = true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //FUNCTION TO SET RESERVE WALLET\\r\\n    function setReserveWallet(address _partner) public onlyOwner {\\r\\n        require(\\r\\n            _partner != reserveWallet,\\r\\n            \\\"already declared as reserve wallet\\\"\\r\\n        );\\r\\n        require(_partner != address(0), \\\"invalid address\\\");\\r\\n        reserveWallet = _partner;\\r\\n    }\\r\\n\\r\\n    //FUNCTION TO BLACKLIST USER\\r\\n    function blackListUser(address _user) public onlyOwner {\\r\\n        require(!blackListedUser[_user], \\\"user already blackListed\\\");\\r\\n        blackListedUser[_user] = true;\\r\\n    }\\r\\n\\r\\n    //FUNCTION TO WHITELIST USER\\r\\n    function UnBlackListUser(address _user) public onlyOwner {\\r\\n        require(blackListedUser[_user], \\\"user isn't blackListed\\\");\\r\\n        blackListedUser[_user] = false;\\r\\n    }\\r\\n\\r\\n    //FUNCTION TO FREZE POT CREATION\\r\\n    function freezePotCreation() public onlyOwner {\\r\\n        require(!potCreation, \\\"pot creation already freezed\\\");\\r\\n        potCreation = true;\\r\\n    }\\r\\n\\r\\n    //FUNCTION TO UNFREEZE POT CREATION\\r\\n    function unfreezePotCreation() public onlyOwner {\\r\\n        require(potCreation, \\\"pot creation already unfreezed\\\");\\r\\n        potCreation = false;\\r\\n    }\\r\\n\\r\\n    //FUNCTION TO WITHDRAW EXCESS FUNDS\\r\\n    function withdrawAccessFunds() external onlyOwner {\\r\\n        // Check if all pots have finished claiming\\r\\n        for (uint256 i = 1; i < potId; i++) {\\r\\n            if (!createdPots[i].claimingFinished) {\\r\\n                revert(\\\"Not all pots have finished claiming\\\");\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Transfer the remaining funds to the contract owner\\r\\n        uint256 remainingFunds = address(this).balance;\\r\\n        require(remainingFunds > 0, \\\"No funds to withdraw\\\");\\r\\n\\r\\n        payable(owner()).transfer(remainingFunds);\\r\\n        remainingFunds = 0;\\r\\n    }\\r\\n\\r\\n    //FUNCTION TO FREEZE POT\\r\\n    function freezePot(uint256 _potId) public onlyOwner {\\r\\n        require(_potId < potId, \\\"invalid potId\\\");\\r\\n        require(!freezedPot[_potId], \\\"pot already freezed\\\");\\r\\n        freezedPot[_potId] = true;\\r\\n    }\\r\\n\\r\\n    //FUNCTION TO UNFREEZE POT;\\r\\n    function unFreezePot(uint256 _potId) public onlyOwner {\\r\\n        require(_potId < potId, \\\"invalid potId\\\");\\r\\n        require(freezedPot[_potId], \\\"pot isn't freezed\\\");\\r\\n        freezedPot[_potId] = false;\\r\\n    }\\r\\n\\r\\n    //FUNCTION TO GET POT PARTICIPANTS\\r\\n    function getPotParticipants(\\r\\n        uint256 _potId\\r\\n    ) external view returns (participant[] memory) {\\r\\n        Pot storage pot = createdPots[_potId];\\r\\n        return pot.participants;\\r\\n    }\\r\\n\\r\\n    //FUNCTION TO GET POT BALANCE\\r\\n    function getPotBalance(uint256 _potId) public view returns (uint256) {\\r\\n        Pot storage pot = createdPots[_potId];\\r\\n        uint256 balance = pot.potBalance;\\r\\n        return balance;\\r\\n    }\\r\\n\\r\\n    //FUNCTION TO CHECK USER REWARD\\r\\n    function userReward(\\r\\n        uint256 potIdd,\\r\\n        uint256 userIndex\\r\\n    ) public view returns (uint256) {\\r\\n        Pot memory pot = createdPots[potIdd];\\r\\n        participant memory participantt = pot.participants[userIndex];\\r\\n        return participantt.reward;\\r\\n    }\\r\\n\\r\\n    //FUNCTION TO GET PLAYER EARNINGS\\r\\n    function getPlayerEarnings(\\r\\n        uint256 _potId\\r\\n    ) external view returns (EarningsInfo[6] memory) {\\r\\n        Pot storage pot = createdPots[_potId];\\r\\n        uint256 currentSize = pot.participants.length;\\r\\n\\r\\n        require(_potId > 0 && _potId <= potId, \\\"Invalid Pot Id\\\");\\r\\n        require(currentSize > 0, \\\"No participants in the pot\\\");\\r\\n\\r\\n        EarningsInfo[6] memory earningsInfo; // Array to store the earnings and user addresses\\r\\n\\r\\n        // Calculate the earnings and user addresses for the last 5 players\\r\\n        uint256 startIndex;\\r\\n        uint256 lastIndex;\\r\\n\\r\\n        if (currentSize > 5) {\\r\\n            startIndex = currentSize - 5;\\r\\n            lastIndex = currentSize;\\r\\n\\r\\n            for (uint256 i = startIndex; i < lastIndex; i++) {\\r\\n                earningsInfo[i - startIndex] = EarningsInfo({\\r\\n                    userAddress: pot.participants[i].userAddress,\\r\\n                    earnings: pot.participants[i].reward\\r\\n                });\\r\\n            }\\r\\n        } else {\\r\\n            startIndex = 0;\\r\\n            lastIndex = currentSize;\\r\\n\\r\\n            for (uint256 i = startIndex; i < lastIndex; i++) {\\r\\n                earningsInfo[i] = EarningsInfo({\\r\\n                    userAddress: pot.participants[i].userAddress,\\r\\n                    earnings: pot.participants[i].reward\\r\\n                });\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Calculate the earnings and user address for the caller (the player who executes the function)\\r\\n        for (uint256 i = 0; i < currentSize; i++) {\\r\\n            if (pot.participants[i].userAddress == msg.sender) {\\r\\n                earningsInfo[5] = EarningsInfo({\\r\\n                    userAddress: pot.participants[i].userAddress,\\r\\n                    earnings: pot.participants[i].reward\\r\\n                });\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return earningsInfo;\\r\\n    }\\r\\n\\r\\n    //ROUND STATISTICS\\r\\n\\r\\n    function getPotInfo(\\r\\n        uint256 _potId\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns (uint256 players, uint256 startTime, uint256 endTime)\\r\\n    {\\r\\n        Pot storage pot = createdPots[_potId];\\r\\n\\r\\n        require(_potId > 0 && _potId <= potId, \\\"Invalid Pot Id\\\");\\r\\n        require(pot.participants.length > 0, \\\"No participants in the pot\\\");\\r\\n\\r\\n        // Retrieve player addresses\\r\\n        players = pot.participants.length;\\r\\n\\r\\n        // Return the starting and ending times from events\\r\\n        startTime = pot.begining; // Starting time of the first player\\r\\n        endTime = pot.lifeTime; // Ending time based on the pot's lifetime\\r\\n\\r\\n        return (players, startTime, endTime);\\r\\n    }\\r\\n\\r\\n    function pushValue(\\r\\n        uint256[] memory array,\\r\\n        uint256 value\\r\\n    ) internal pure returns (uint256[] memory) {\\r\\n        uint256[] memory newArray = new uint256[](array.length + 1);\\r\\n        for (uint256 i = 0; i < array.length; i++) {\\r\\n            newArray[i] = array[i];\\r\\n        }\\r\\n        newArray[array.length] = value;\\r\\n        return newArray;\\r\\n    }\\r\\n\\r\\n    //FUNCTION TO CHECK IF ALL PLAYERS HAVE CLAIMED THERE REWARD\\r\\n    function allRewardClaimed(uint256 _potId) internal view returns (bool) {\\r\\n        Pot storage pot = createdPots[_potId];\\r\\n        require(_potId > 0 && _potId <= potId, \\\"Invalid Pot Id\\\");\\r\\n\\r\\n        uint256 currentSize = pot.participants.length;\\r\\n\\r\\n        for (uint256 i = 0; i < currentSize; i++) {\\r\\n            if (!pot.participants[i].rewardCollected) {\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function readParticipationFee(uint8 _potId) public view returns (uint256) {\\r\\n        return createdPots[_potId].participationFeee;\\r\\n    }\\r\\n\\r\\n    //FUNCTION TO CHECK IF POT HAS CLAIMING ACTIVATED\\r\\n    function isClaimingActive(uint8 _potId) public view returns (bool) {\\r\\n        return createdPots[_potId].claimingActive;\\r\\n    }\\r\\n\\r\\n    //FUNCTION TO CHECK POT LIFE\\r\\n    function isPotLifeEnded(uint8 _potId) public view returns (bool) {\\r\\n        bool condition = block.timestamp > createdPots[_potId].lifeTime\\r\\n            ? true\\r\\n            : false;\\r\\n        return condition;\\r\\n    }\\r\\n\\r\\n    //FUNCTION TO RETURN POT CREATOR\\r\\n    function isPotCreator(uint8 _potId) public view returns (address) {\\r\\n        return createdPots[_potId].creator;\\r\\n    }\\r\\n\\r\\n    //FUNCTION TO GET ALL POTS\\r\\n    function getAllPots() public view returns (Pot[] memory) {\\r\\n        // Initialize the length of the result array with potId - 1\\r\\n        Pot[] memory allPots = new Pot[](potId > 0 ? potId - 1 : 0);\\r\\n        for (uint256 i = 1; i < potId; i++) {\\r\\n            allPots[i - 1] = createdPots[i];\\r\\n        }\\r\\n        return allPots;\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"atTime\",\"type\":\"uint256\"}],\"name\":\"PotCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"joiner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"againstAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"atTime\",\"type\":\"uint256\"}],\"name\":\"PotJoined\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"UnBlackListUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_potId\",\"type\":\"uint256\"}],\"name\":\"activateClaiming\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"blackListUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"blackListedUser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_potId\",\"type\":\"uint256\"}],\"name\":\"claimReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createPot\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"createdPots\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"potID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"potBalance\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"claimingActive\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isEnded\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"participationFeee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"begining\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lifeTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"claimingFinished\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devTeam\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_potId\",\"type\":\"uint256\"}],\"name\":\"freezePot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"freezePotCreation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"freezedPot\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllPots\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"potID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"potBalance\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address payable\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"durationPlayed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"rewardCollected\",\"type\":\"bool\"}],\"internalType\":\"struct PotFighter.participant[]\",\"name\":\"participants\",\"type\":\"tuple[]\"},{\"internalType\":\"bool\",\"name\":\"claimingActive\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isEnded\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"participationFeee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"begining\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lifeTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"claimingFinished\",\"type\":\"bool\"}],\"internalType\":\"struct PotFighter.Pot[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_potId\",\"type\":\"uint256\"}],\"name\":\"getPlayerEarnings\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"earnings\",\"type\":\"uint256\"}],\"internalType\":\"struct PotFighter.EarningsInfo[6]\",\"name\":\"\",\"type\":\"tuple[6]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_potId\",\"type\":\"uint256\"}],\"name\":\"getPotBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_potId\",\"type\":\"uint256\"}],\"name\":\"getPotInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"players\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_potId\",\"type\":\"uint256\"}],\"name\":\"getPotParticipants\",\"outputs\":[{\"components\":[{\"internalType\":\"address payable\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"durationPlayed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"rewardCollected\",\"type\":\"bool\"}],\"internalType\":\"struct PotFighter.participant[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_potId\",\"type\":\"uint8\"}],\"name\":\"isClaimingActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_potId\",\"type\":\"uint8\"}],\"name\":\"isPotCreator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_potId\",\"type\":\"uint8\"}],\"name\":\"isPotLifeEnded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_potId\",\"type\":\"uint256\"}],\"name\":\"joinPot\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"potCreation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"potFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_potId\",\"type\":\"uint8\"}],\"name\":\"readParticipationFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerSecondPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newWallet\",\"type\":\"address\"}],\"name\":\"setDevWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_partner\",\"type\":\"address\"}],\"name\":\"setReserveWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_potId\",\"type\":\"uint256\"}],\"name\":\"unFreezePot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unfreezePotCreation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"potIdd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userIndex\",\"type\":\"uint256\"}],\"name\":\"userReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAccessFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PotFighter", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}