{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/src/contracts/AI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport \\\"./Auth.sol\\\";\\nimport \\\"./IBEP20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./IERC721Enumerable.sol\\\";\\n\\ninterface INeuralPepe is IERC721Enumerable {\\n    function isMintedBeforeReveal(uint256 index) external view returns (bool);\\n}\\n\\ninterface IAiRouter {\\n  function distributeTax(uint256 taxAmount) external;\\n  function isInSwap() external view returns (bool);\\n  function supportsDistribureFunction() external pure returns (bool);\\n  function authorize(address adr) external;\\n  function liquifyBack() external;\\n}\\n\\ncontract AI is IBEP20, Auth {\\n  using SafeMath for uint256;\\n\\n\\tstring constant _name = \\\"Neural Frens\\\";\\n  string constant _symbol = \\\"AI\\\";\\n  uint8 constant _decimals = 18;\\n\\n  // Constants\\n  uint256 public constant SECONDS_IN_A_DAY = 86400;\\n  uint256 public constant emissionEnd = 1933606800;\\n  uint256 public constant aiSnapshot = 1636021821;\\n\\n  // Public variables\\n  uint256 public emissionPerDay = 2300000000000000000;\\n  uint256 private MAX_EMISSION_PER_DAY = 10000000000000000000;\\n  uint256 private _totalSupply;\\n\\n\\tmapping (address => uint256) _balances;\\n  mapping (address => mapping (address => uint256)) _allowances;\\n  mapping (address => bool) isFeeExempt;\\n  mapping(uint256 => uint256) private _lastClaim;\\n  mapping (address => address) private _taxAddresses;\\n  mapping (address => uint256) private _taxAmount;\\n  mapping (address => bool) private _isLaunched;\\n\\n  // Fees. Some may be completely inactive at all times.\\n  uint256 feeDenominator = 1000;\\n\\n  address private _pepeAddress;\\n  address[] private pairs; \\n  INeuralPepe private PEPE = INeuralPepe(_pepeAddress);\\n  string public constant _description = \\\"Neural Frens (AI) is the improved version of the original AI token which was airdropped as a replacement for all AI holders based on a public snapshot\\\";\\n  \\n  bool public swapEnabled = true;\\n  bool public distributionCompleted = false;\\n\\n  event TaxCollectionEnabled(bool enabledOrNot);\\n\\n\\tconstructor() Auth(msg.sender) {\\n    isFeeExempt[msg.sender] = true;\\n    isFeeExempt[address(this)] = true;\\n\\t}\\n\\n\\treceive() external payable {}\\n\\n  function totalSupply() external view override returns (uint256) { return _totalSupply; }\\n  function decimals() external pure override returns (uint8) { return _decimals; }\\n  function symbol() external pure override returns (string memory) { return _symbol; }\\n  function name() external pure override returns (string memory) { return _name; }\\n  function getOwner() external view override returns (address) { return owner; }\\n  function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }\\n  function burn(uint256 burnQuantity) public override returns (bool) {\\n      _balances[msg.sender] = _balances[msg.sender].sub(burnQuantity);\\n      _totalSupply = _totalSupply.sub(burnQuantity);\\n      emit Transfer(msg.sender, address(0), burnQuantity);\\n      return true;\\n  }\\n  function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n  function _mint(address account, uint256 amount) internal virtual {\\n    require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n    _beforeTokenTransfer(address(0), account, amount);\\n\\n    _totalSupply = _totalSupply.add(amount);\\n    _balances[account] = _balances[account].add(amount);\\n    emit Transfer(address(0), account, amount);\\n    }\\n  function allowance(address holder, address spender) external view override returns (uint256) { return _allowances[holder][spender]; }\\n  function approve(address spender, uint256 amount) public override returns (bool) {\\n      _allowances[msg.sender][spender] = amount;\\n      emit Approval(msg.sender, spender, amount);\\n      return true;\\n  }\\n  function approveMax(address spender) external returns (bool) { return approve(spender, type(uint256).max); }\\n  function transfer(address recipient, uint256 amount) external override returns (bool) { return _transferFrom(msg.sender, recipient, amount); }\\n\\tfunction transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\\n    if (_allowances[sender][msg.sender] != type(uint256).max) {\\n      require(_allowances[sender][msg.sender] >= amount, \\\"Insufficient Allowance\\\");\\n      _allowances[sender][msg.sender] -= amount;\\n    }\\n    return _transferFrom(sender, recipient, amount);\\n  }\\n\\tfunction _basicTransfer(address sender, address recipient, uint256 amount) internal  returns (bool) {\\n\\t\\trequire(amount <= _balances[sender], \\\"Insufficient Balance\\\");\\n        _balances[sender] -= amount;\\n        _balances[recipient] += amount;\\n        emit Transfer(sender, recipient, amount);\\n        return true;\\n  }\\n\\n\\tfunction _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\\n\\t\\trequire(amount > 0);\\n    address tradeAddress = returnTradeAddress(sender, recipient);\\n    bool isInSwap = tradeAddress != address(0) ? IAiRouter(_taxAddresses[tradeAddress]).isInSwap() : true;\\n\\n    if (isInSwap || tradeAddress == address(0)) {\\n      return _basicTransfer(sender, recipient, amount);\\n    }\\n\\n    // activates the liquidity on DEX\\n    if (!_isLaunched[tradeAddress] && recipient == tradeAddress && tradeAddress != address(0)) {\\n        require(_balances[sender] > 0);\\n        require(sender == owner, \\\"Only the owner can be the first to add liquidity.\\\");\\n        _isLaunched[tradeAddress] = !_isLaunched[tradeAddress];\\n        \\n        return _basicTransfer(sender, recipient, amount);\\n    }\\n\\n    require(amount <= _balances[sender], \\\"Insufficient Balance\\\");\\n    _balances[sender] -= amount;\\n\\n    // checks whether it needs to take a fee and takes it before transferring to the \\n    uint256 amountReceived = shouldTakeFee(sender, recipient, tradeAddress) ? takeFee(sender, amount, tradeAddress) : amount;\\n    uint256 tax = amount.sub(amountReceived);\\n\\n    if (shouldSwapBack(tradeAddress) && !isInSwap && tax > 0) {\\n      try IAiRouter(_taxAddresses[tradeAddress]).liquifyBack() {} catch {}\\n    }\\n\\n    _balances[recipient] += amountReceived;\\n    emit Transfer(sender, recipient, amountReceived);\\n    return true;\\n  }\\n  \\n  // returns taxable pair if sender or recepient is in pairs array\\n  function returnTradeAddress(address sender, address recipient) internal view returns (address) {\\n    address[] memory liqPairs = pairs;\\n    for (uint256 i = 0; i < liqPairs.length; i++) {\\n      if (sender == liqPairs[i] || recipient == liqPairs[i]) {\\n        return liqPairs[i];\\n      }\\n    }\\n    return address(0);\\n  }\\n\\n\\t// Decides whether this trade should take a fee.\\n\\t// Trades with pairs are always taxed, unless sender or receiver is exempted.\\n\\t// Non trades, like wallet to wallet, are configured, untaxed by default.\\n\\tfunction shouldTakeFee(address sender, address recipient, address tradeAddress) internal view returns (bool) {\\n    if (isFeeExempt[sender] || isFeeExempt[recipient] || !_isLaunched[tradeAddress] || !swapEnabled) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n    address[] memory liqPairs = pairs;\\n    for (uint256 i = 0; i < liqPairs.length; i++) {\\n        if (sender == liqPairs[i] || recipient == liqPairs[i]) {\\n        return true;\\n      }\\n    }\\n\\n    return false;\\n    }\\n\\n  // Takes fee and triggers router function to re-balance fee for different wallets.\\n\\tfunction takeFee(address sender, uint256 amount, address tradeAddress) internal returns (uint256) {\\n\\t\\tif (!_isLaunched[tradeAddress]) { return amount; }\\n\\n\\t\\tuint256 liqFee = 0;\\n    \\n    // If there is a liquidity tax active for autoliq, the contract keeps it.\\n    if (_taxAmount[tradeAddress] > 0) {\\n      liqFee = amount.mul(_taxAmount[tradeAddress]).div(feeDenominator);\\n      _balances[_taxAddresses[tradeAddress]] += liqFee;\\n      emit Transfer(sender, _taxAddresses[tradeAddress], liqFee);\\n\\n      try IAiRouter(_taxAddresses[tradeAddress]).distributeTax(liqFee) {} catch {}\\n    }\\n\\n    return amount - liqFee;\\n  }\\n\\n  // Checks whether it should buy back and add liquidity\\n  function shouldSwapBack(address tradeAddress) internal view returns (bool) {\\n      return _isLaunched[tradeAddress]\\n          && msg.sender != tradeAddress\\n          && swapEnabled\\n          && _balances[_taxAddresses[tradeAddress]] > 0;\\n  }\\n\\n  // activates taxse\\n\\tfunction setSwapEnabled(bool set) external authorized {\\n\\t\\tswapEnabled = set;\\n\\t\\temit TaxCollectionEnabled(set);\\n\\t}\\n\\n  // Sets a wallet address to be taxable or not\\n  function setIsFeeExempt(address holder, bool exempt) external authorized {\\n    isFeeExempt[holder] = exempt;\\n  }\\n\\n\\t// Recover any BNB sent to the contract by mistake.\\n\\tfunction rescue() external {\\n    payable(owner).transfer(address(this).balance);\\n  }\\n\\n  // Adds trading pair along with the tax address (where we should route tax) and tax amount\\n\\tfunction addPair(address pair, address taxAddress, uint256 _newTaxAmount) external authorized {\\n    pairs.push(pair);\\n    _taxAddresses[pair] = taxAddress;\\n    _taxAmount[pair] = _newTaxAmount;\\n  }\\n  \\n  // removed the latest added pair\\n  function removeLastPair() external authorized {\\n      pairs.pop();\\n  }\\n  \\n  function _getAddressIndex(address tradeAddress) private view returns (uint) {\\n    for(uint i = 0; i < pairs.length; i++) {\\n      if (pairs[i] == tradeAddress) {\\n        return i.add(1);\\n      }\\n    }\\n    return 0;\\n  }\\n  /**\\n    * @dev Only owner can call this function. Remove taxable address.\\n  */\\n  function removePair(address pairAddressToRemove) public onlyOwner {\\n    require(_isTradeAddressExists(pairAddressToRemove), 'The address you try to remove doesnt exist');\\n    uint addressIndex = _getAddressIndex(pairAddressToRemove).sub(1);\\n\\n    for (uint i = addressIndex; i < pairs.length - 1; i++) {\\n      pairs[i] = pairs[pairs.length - 1];\\n    }\\n    pairs.pop();\\n  }\\n\\n    /**\\n    * @dev Internal functions.\\n    */\\n  function _isTradeAddressExists(address tradeAddress) private view returns (bool) {\\n    if (pairs.length == 0) { return false; }\\n    for(uint i = 0; i < pairs.length; i++) {\\n      if (pairs[i] == tradeAddress) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n\\n\\n  /**\\n  * @dev When accumulated AIs have last been claimed for a Neural Pepe index\\n  */\\n  function lastClaim(uint256 tokenIndex) public view returns (uint256) {\\n      require(PEPE.ownerOf(tokenIndex) != address(0), \\\"Owner cannot be 0 address\\\");\\n      \\n      uint256 lastClaimed = uint256(_lastClaim[tokenIndex]) != 0 ? uint256(_lastClaim[tokenIndex]) : aiSnapshot;\\n      return lastClaimed;\\n  }\\n\\n  /**\\n    * @dev Accumulated AI tokens for a Neural Pepe token index.\\n    */\\n  function accumulated(uint256 tokenIndex) public view returns (uint256) {\\n      require(PEPE.ownerOf(tokenIndex) != address(0), \\\"Owner cannot be 0 address\\\");\\n      require(tokenIndex < PEPE.totalSupply(), \\\"AI at index has not been minted yet\\\");\\n\\n      uint256 lastClaimed = lastClaim(tokenIndex);\\n\\n      // Sanity check if last claim was on or after emission end\\n      if (lastClaimed >= emissionEnd) return 0;\\n\\n      uint256 accumulationPeriod = block.timestamp < emissionEnd ? block.timestamp : emissionEnd; // Getting the min value of both\\n      uint256 totalAccumulated = accumulationPeriod.sub(lastClaimed).mul(emissionPerDay).div(SECONDS_IN_A_DAY);\\n\\n      return totalAccumulated;\\n  }\\n\\n  /**\\n    * @dev Claim mints AIs and supports multiple Neural Pepe token indices at once.\\n    */\\n  function claim(uint256[] memory tokenIndices) public override returns (uint256) {\\n      uint256 totalClaimQty = 0;\\n      for (uint i = 0; i < tokenIndices.length; i++) {\\n          // Sanity check for non-minted index\\n          require(tokenIndices[i] < PEPE.totalSupply(), \\\"AI at index has not been minted yet\\\");\\n          // Duplicate token index check\\n          for (uint j = i + 1; j < tokenIndices.length; j++) {\\n              require(tokenIndices[i] != tokenIndices[j], \\\"Duplicate token index\\\");\\n          }\\n\\n          uint tokenIndex = tokenIndices[i];\\n          require(PEPE.ownerOf(tokenIndex) == msg.sender, \\\"Sender is not the owner\\\");\\n\\n          uint256 claimQty = accumulated(tokenIndex);\\n          if (claimQty != 0) {\\n              totalClaimQty = totalClaimQty.add(claimQty);\\n              _lastClaim[tokenIndex] = block.timestamp;\\n          }\\n      }\\n\\n      require(totalClaimQty != 0, \\\"No accumulated AI\\\");\\n      _mint(msg.sender, totalClaimQty);\\n      return totalClaimQty;\\n  }\\n\\n  /**\\n    * @dev Only owner can call this function. Change AI emission per day.\\n  */\\n  function changeEmissionPerDay(uint256 _newEmissionPerDay) public onlyOwner {\\n    require(_newEmissionPerDay >= 0 || _newEmissionPerDay <= MAX_EMISSION_PER_DAY, 'invalid emission per day');\\n    emissionPerDay = _newEmissionPerDay;\\n  }\\n\\n  /**\\n  * @dev Only owner can call this function. Changes tax address and Tax amount for the pair, can be between 1 and 20.\\n  */\\n  function changeTaxAddressAndAmount(address tradeAddress, address taxAddress, uint256 _newTaxAmount) public onlyOwner {\\n    require(_newTaxAmount >= 0 && _newTaxAmount <= 200, 'Provide valid tax between 1 and 20');\\n    require(_taxAddresses[tradeAddress] != address(0), 'Trade address doesnt exist');\\n\\n    _taxAddresses[tradeAddress] = taxAddress;\\n    _taxAmount[tradeAddress] = _newTaxAmount;\\n  }\\n\\n  function changePepeAddress(address newPepeAddress) public onlyOwner {\\n    _pepeAddress = newPepeAddress;\\n    PEPE = INeuralPepe(_pepeAddress);\\n  }\\n\\n  function _distributeAI(address[] memory addresses, uint256[] memory amount) public onlyOwner {\\n    require(!distributionCompleted, 'AI has been distributed');\\n    require(addresses.length <= 40, 'wrong length of array');\\n    require(addresses.length == amount.length, 'wrong length of arrays');\\n\\n    for (uint256 i = 0; i < addresses.length; i++) {\\n      if (amount[i] >= 0) {\\n        _mint(addresses[i], amount[i]);\\n      }\\n    }\\n  }\\n\\n  function completeDistribution() public onlyOwner {\\n    require(!distributionCompleted, 'distribution already completed');\\n    distributionCompleted = true;\\n  }\\n}\"\r\n    },\r\n    \"/src/contracts/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\"\r\n    },\r\n    \"/src/contracts/IERC721Enumerable.sol\": {\r\n      \"content\": \"import \\\"./IERC721.sol\\\";\\n\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\"\r\n    },\r\n    \"/src/contracts/IERC721.sol\": {\r\n      \"content\": \"import \\\"./IERC165.sol\\\";\\n\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\\n      *\\n      * Requirements:\\n      *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n      * - `tokenId` token must exist and be owned by `from`.\\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n      *\\n      * Emits a {Transfer} event.\\n      */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\"\r\n    },\r\n    \"/src/contracts/IERC165.sol\": {\r\n      \"content\": \"/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"/src/contracts/IBEP20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.0 <0.9.0;\\n\\ninterface IBEP20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the token decimals.\\n   */\\n  function decimals() external view returns (uint8);\\n\\n  /**\\n   * @dev Returns the token symbol.\\n   */\\n  function symbol() external view returns (string memory);\\n\\n  /**\\n  * @dev Returns the token name.\\n  */\\n  function name() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the bep token owner.\\n   */\\n  function getOwner() external view returns (address);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address _owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  function burn(uint256 burnQuantity) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n\\n  function claim(uint256[] memory tokenIndices) external returns (uint256);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"/src/contracts/Auth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0 <0.9.0;\\n\\nabstract contract Auth {\\n    address internal owner;\\n    mapping (address => bool) internal authorizations;\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n        authorizations[_owner] = true;\\n    }\\n\\n    /**\\n     * Function modifier to require caller to be contract owner\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner(msg.sender), \\\"!OWNER\\\"); _;\\n    }\\n\\n    /**\\n     * Function modifier to require caller to be authorized\\n     */\\n    modifier authorized() {\\n        require(isAuthorized(msg.sender), \\\"!AUTHORIZED\\\"); _;\\n    }\\n\\n    /**\\n     * Authorize address. Owner only\\n     */\\n    function authorize(address adr) public onlyOwner {\\n        authorizations[adr] = true;\\n    }\\n\\n    /**\\n     * Remove address' authorization. Owner only\\n     */\\n    function unauthorize(address adr) public onlyOwner {\\n        authorizations[adr] = false;\\n    }\\n\\n    /**\\n     * Check if address is owner\\n     */\\n    function isOwner(address account) public view returns (bool) {\\n        return account == owner;\\n    }\\n\\n    /**\\n     * Return address' authorization status\\n     */\\n    function isAuthorized(address adr) public view returns (bool) {\\n        return authorizations[adr];\\n    }\\n\\n    /**\\n     * Transfer ownership to new address. Caller must be owner. Leaves old owner authorized\\n     */\\n    function transferOwnership(address payable adr) public onlyOwner {\\n        owner = adr;\\n        authorizations[adr] = true;\\n        emit OwnershipTransferred(adr);\\n    }\\n\\n    event OwnershipTransferred(address owner);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"petersburg\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabledOrNot\",\"type\":\"bool\"}],\"name\":\"TaxCollectionEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"SECONDS_IN_A_DAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_description\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amount\",\"type\":\"uint256[]\"}],\"name\":\"_distributeAI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenIndex\",\"type\":\"uint256\"}],\"name\":\"accumulated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"taxAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_newTaxAmount\",\"type\":\"uint256\"}],\"name\":\"addPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"aiSnapshot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"approveMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"burnQuantity\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newEmissionPerDay\",\"type\":\"uint256\"}],\"name\":\"changeEmissionPerDay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPepeAddress\",\"type\":\"address\"}],\"name\":\"changePepeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tradeAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"taxAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_newTaxAmount\",\"type\":\"uint256\"}],\"name\":\"changeTaxAddressAndAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIndices\",\"type\":\"uint256[]\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"completeDistribution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributionCompleted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emissionEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emissionPerDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenIndex\",\"type\":\"uint256\"}],\"name\":\"lastClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeLastPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pairAddressToRemove\",\"type\":\"address\"}],\"name\":\"removePair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rescue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsFeeExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"set\",\"type\":\"bool\"}],\"name\":\"setSwapEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"unauthorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "AI", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "petersburg", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}