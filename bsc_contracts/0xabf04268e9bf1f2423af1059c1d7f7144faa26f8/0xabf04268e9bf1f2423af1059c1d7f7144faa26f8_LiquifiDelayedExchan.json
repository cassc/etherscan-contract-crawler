{"SourceCode": "pragma solidity = 0.7.6;\r\n\r\n\r\ninterface ERC20 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint256 supply);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool success);\r\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\r\n\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function transfer(address to, uint256 value) external returns (bool success);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool success);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\nlibrary Liquifi {\r\n    enum Flag { \r\n        // padding 8 bits\r\n        PAD1, PAD2, PAD3, PAD4, PAD5, PAD6, PAD7, PAD8,\r\n        // transient flags\r\n        HASH_DIRTY, BALANCE_A_DIRTY, BALANCE_B_DIRTY, TOTALS_DIRTY, QUEUE_STOPLOSS_DIRTY, QUEUE_TIMEOUT_DIRTY, MUTEX, INVALID_STATE,\r\n        TOTAL_SUPPLY_DIRTY, SWAPS_INCOME_DIRTY, RESERVED1, RESERVED2,\r\n        // persistent flags set by governance\r\n        POOL_LOCKED, ARBITRAGEUR_FULL_FEE, GOVERNANCE_OVERRIDEN\r\n    }\r\n\r\n    struct PoolBalances { // optimized for storage\r\n        // saved on BALANCE_A_DIRTY in exit()\r\n        uint112 balanceALocked;\r\n        uint144 poolFlowSpeedA; // flow speed: (amountAIn * 2^32)/second\r\n\r\n        // saved on BALANCE_B_DIRTY in exit()\r\n        uint112 balanceBLocked;\r\n        uint144 poolFlowSpeedB; // flow speed: (amountBIn * 2^32)/second\r\n        \r\n        // saved on TOTALS_DIRTY in exit()\r\n        uint128 totalBalanceA;\r\n        uint128 totalBalanceB;\r\n\r\n        // saved on SWAPS_INCOME_DIRTY in exit()\r\n        // contains 128 bits of delayedSwapsIncomeA and 128 bits of delayedSwapsIncomeB\r\n        uint delayedSwapsIncome;\r\n        \r\n        // saved on TOTAL_SUPPLY_DIRTY in exit()\r\n        // contains 128 bits of rootKLast and 128 bits of totalSupply\r\n        // rootKLast = sqrt(availableBalanceA * availableBalanceB), as of immediately after the most recent liquidity event\r\n        uint rootKLastTotalSupply;\r\n    }\r\n\r\n    struct PoolState { // optimized for storage\r\n        // saved on HASH_DIRTY in exit()\r\n        bytes32 lastBreakHash;\r\n\r\n        // saved on QUEUE_STOPLOSS_DIRTY in exit()\r\n        uint64 firstByTokenAStopLoss; uint64 lastByTokenAStopLoss; // linked list of orders sorted by (amountAIn/stopLossAmount) ascending\r\n        uint64 firstByTokenBStopLoss; uint64 lastByTokenBStopLoss; // linked list of orders sorted by (amountBIn/stopLossAmount) ascending\r\n\r\n        // saved on QUEUE_TIMEOUT_DIRTY in exit()\r\n        uint64 firstByTimeout; uint64 lastByTimeout; // linked list of orders sorted by timeouts ascending\r\n        // this field contains\r\n        // 8 bits of instantSwapFee\r\n        // 8 bits of desiredOrdersFee\r\n        // 8 bits of protocolFee\r\n        // 32 bits of maxPeriod\r\n        // 16 bits of desiredMaxHistory\r\n        // 4 bits of persistent flags\r\n        // 12 bits of transient flags\r\n        // 8 bits of transient invalidStateReason (ErrorArg)\r\n        // Packing reduces stack depth and helps in governance\r\n        uint96 packed; // not saved in exit(), saved only by governance\r\n        uint16 notFee; // not saved in exit()\r\n\r\n        // This word is always saved in exit()\r\n        uint64 lastBalanceUpdateTime;\r\n        uint64 nextBreakTime;\r\n        uint32 maxHistory;\r\n        uint32 ordersToClaimCount;\r\n        uint64 breaksCount; // counter with increments of 2. 1st bit is used as mutex flag\r\n    }\r\n\r\n    enum OrderFlag { \r\n        NONE, IS_TOKEN_A, EXTRACT_ETH\r\n    }\r\n\r\n    struct Order { // optimized for storage, fits into 3 words\r\n        // Also closing hash is saved in this word on order close.\r\n        // Closing hash always has last bit = 1, I.e. prevByStopLoss & 1 == 1\r\n        uint64 nextByTimeout; uint64 prevByTimeout;\r\n        uint64 nextByStopLoss; uint64 prevByStopLoss;\r\n        \r\n        // mostly used together\r\n        uint112 stopLossAmount;\r\n        uint112 amountIn;\r\n        uint32 period;\r\n\r\n        address owner;\r\n        uint64 timeout;\r\n        uint8 flags;\r\n    }\r\n\r\n    struct OrderClaim { //in-memory only\r\n        uint amountOut;\r\n        uint orderFlowSpeed;\r\n        uint orderId;\r\n        uint flags;\r\n        uint closeReason;\r\n        uint previousAvailableBalance;\r\n        uint previousFlowSpeed;\r\n        uint previousOthers;\r\n    }\r\n\r\n    enum Error { \r\n        A_MUL_OVERFLOW, \r\n        B_ADD_OVERFLOW, \r\n        C_TOO_BIG_TIME_VALUE, \r\n        D_TOO_BIG_PERIOD_VALUE,\r\n        E_TOO_BIG_AMOUNT_VALUE,\r\n        F_ZERO_AMOUNT_VALUE,\r\n        G_ZERO_PERIOD_VALUE,\r\n        H_BALANCE_AFTER_BREAK,\r\n        I_BALANCE_OF_SAVED_UPD,\r\n        J_INVALID_POOL_STATE,\r\n        K_TOO_BIG_TOTAL_VALUE,\r\n        L_INSUFFICIENT_LIQUIDITY,\r\n        M_EMPTY_LIST,\r\n        N_BAD_LENGTH,\r\n        O_HASH_MISMATCH,\r\n        P_ORDER_NOT_CLOSED,\r\n        Q_ORDER_NOT_ADDED,\r\n        R_INCOMPLETE_HISTORY,\r\n        S_REENTRANCE_NOT_SUPPORTED,\r\n        T_INVALID_TOKENS_PAIR,\r\n        U_TOKEN_TRANSFER_FAILED,\r\n        V_ORDER_NOT_EXIST,\r\n        W_DIV_BY_ZERO,\r\n        X_ORDER_ALREADY_CLOSED,\r\n        Y_UNAUTHORIZED_SENDER,\r\n        Z_TOO_BIG_FLOW_SPEED_VALUE\r\n    }\r\n\r\n    enum ErrorArg {\r\n        A_NONE,\r\n        B_IN_AMOUNT,\r\n        C_OUT_AMOUNT,\r\n        D_STOP_LOSS_AMOUNT,\r\n        E_IN_ADD_ORDER,\r\n        F_IN_SWAP,\r\n        G_IN_COMPUTE_AVAILABLE_BALANCE,\r\n        H_IN_BREAKS_HISTORY,\r\n        I_USER_DATA,\r\n        J_IN_ORDER,\r\n        K_IN_MINT,\r\n        L_IN_BURN,\r\n        M_IN_CLAIM_ORDER,\r\n        N_IN_PROCESS_DELAYED_ORDERS,\r\n        O_TOKEN_A,\r\n        P_TOKEN_B,\r\n        Q_TOKEN_ETH,\r\n        R_IN_CLOSE_ORDER,\r\n        S_BY_GOVERNANCE,\r\n        T_FEE_CHANGED_WITH_ORDERS_OPEN,\r\n        U_BAD_EXCHANGE_RATE,\r\n        V_INSUFFICIENT_TOTAL_BALANCE,\r\n        W_POOL_LOCKED,\r\n        X_TOTAL_SUPPLY\r\n    }\r\n\r\n    // this methods allows to pass some information in 'require' calls without storing strings in contract bytecode \r\n    // messages will be like \"FAIL https://err.liquifi.org/XY\" where X and Y are error and errorArg from respective enums\r\n    function _require(bool condition, Error error, ErrorArg errorArg) internal pure {\r\n        if (condition) return;\r\n        { // new scope to not waste message memory if condition is satisfied \r\n            // FAIL https://err.liquifi.org/__\r\n            bytes memory message = \"\\x46\\x41\\x49\\x4c\\x20\\x68\\x74\\x74\\x70\\x73\\x3a\\x2f\\x2f\\x65\\x72\\x72\\x2e\\x6c\\x69\\x71\\x75\\x69\\x66\\x69\\x2e\\x6f\\x72\\x67\\x2f\\x5f\\x5f\";\r\n            \r\n            message[29] = bytes1(65 + uint8(error));\r\n            message[30] = bytes1(65 + uint8(errorArg));\r\n            require(false, string(message));\r\n        }\r\n    }\r\n\r\n    uint64 constant maxTime = ~uint64(0);\r\n\r\n    function trimTime(uint time) internal pure returns (uint64 trimmedTime) {\r\n        Liquifi._require(time <= maxTime, Liquifi.Error.C_TOO_BIG_TIME_VALUE, Liquifi.ErrorArg.A_NONE);\r\n        return uint64(time);\r\n    }\r\n\r\n    function trimPeriod(uint period, Liquifi.ErrorArg periodType) internal pure returns (uint32 trimmedPeriod) {\r\n        Liquifi._require(period <= ~uint32(0), Liquifi.Error.D_TOO_BIG_PERIOD_VALUE, periodType);\r\n        return uint32(period);\r\n    }\r\n\r\n    function trimAmount(uint amount, Liquifi.ErrorArg amountType) internal pure returns (uint112 trimmedAmount) {\r\n        Liquifi._require(amount <= ~uint112(0), Liquifi.Error.E_TOO_BIG_AMOUNT_VALUE, amountType);\r\n        return uint112(amount);\r\n    }\r\n\r\n\r\n    function trimTotal(uint amount, Liquifi.ErrorArg amountType) internal pure returns (uint128 trimmedAmount) {\r\n        Liquifi._require(amount <= ~uint128(0), Liquifi.Error.K_TOO_BIG_TOTAL_VALUE, amountType);\r\n        return uint128(amount);\r\n    }\r\n\r\n    function trimFlowSpeed(uint amount, Liquifi.ErrorArg amountType) internal pure returns (uint144 trimmedAmount) {\r\n        Liquifi._require(amount <= ~uint144(0), Liquifi.Error.Z_TOO_BIG_FLOW_SPEED_VALUE, amountType);\r\n        return uint144(amount);\r\n    }\r\n\r\n    function checkFlag(PoolState memory _state, Flag flag) internal pure returns(bool) {\r\n        return _state.packed & uint96(1 << uint(flag)) != 0;\r\n    }\r\n\r\n    function setFlag(PoolState memory _state, Flag flag) internal pure {\r\n        _state.packed = _state.packed | uint96(1 << uint(flag));\r\n    }\r\n\r\n    function clearFlag(PoolState memory _state, Flag flag) internal pure {\r\n        _state.packed = _state.packed & ~uint96(1 << uint(flag));\r\n    }\r\n\r\n    function unpackGovernance(PoolState memory _state) internal pure returns(\r\n        uint instantSwapFee, uint desiredOrdersFee, uint protocolFee, uint maxPeriod, uint desiredMaxHistory\r\n    ) {\r\n        desiredMaxHistory = uint16(_state.packed >> 24);\r\n        maxPeriod = uint32(_state.packed >> 40);\r\n        protocolFee = uint8(_state.packed >> 72);\r\n        desiredOrdersFee = uint8(_state.packed >> 80);\r\n        instantSwapFee = uint8(_state.packed >> 88);\r\n    }\r\n\r\n    function setInvalidState(PoolState memory _state, Liquifi.ErrorArg reason) internal pure {\r\n        setFlag(_state, Liquifi.Flag.INVALID_STATE);\r\n        uint oldReason = uint8(_state.packed);\r\n        if (uint(reason) > oldReason) {\r\n            _state.packed = _state.packed & ~uint96(~uint8(0)) | uint96(reason);\r\n        }\r\n    }\r\n\r\n    function checkInvalidState(PoolState memory _state) internal pure returns (Liquifi.ErrorArg reason) {\r\n        reason = Liquifi.ErrorArg.A_NONE;\r\n        if (checkFlag(_state, Liquifi.Flag.INVALID_STATE)) {\r\n            return Liquifi.ErrorArg(uint8(_state.packed));\r\n        }\r\n    }\r\n\r\n    function isTokenAIn(uint orderFlags) internal pure returns (bool) {\r\n        return orderFlags & uint(Liquifi.OrderFlag.IS_TOKEN_A) != 0;\r\n    }\r\n}\r\n\r\nlibrary Math {\r\n    \r\n    function max(uint256 x, uint256 y) internal pure returns (uint256 result) {\r\n        result = x > y ? x : y;\r\n    }\r\n\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256 result) {\r\n        result = x < y ? x : y;\r\n    }\r\n\r\n    function sqrt(uint x) internal pure returns (uint result) {\r\n        uint y = x;\r\n        result = (x + 1) / 2;\r\n        while (result < y) {\r\n            y = result;\r\n            result = (x / result + result) / 2;\r\n        }\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        Liquifi._require(y == 0 || (z = x * y) / y == x, Liquifi.Error.A_MUL_OVERFLOW, Liquifi.ErrorArg.A_NONE);\r\n    }\r\n\r\n    function mulWithClip(uint x, uint y, uint maxValue) internal pure returns (uint z) {\r\n        if (y != 0 && ((z = x * y) / y != x || z > maxValue)) {\r\n            z = maxValue;\r\n        }\r\n    }\r\n\r\n    function subWithClip(uint x, uint y) internal pure returns (uint z) {\r\n        if ((z = x - y) > x) {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        Liquifi._require((z = x + y) >= x, Liquifi.Error.B_ADD_OVERFLOW, Liquifi.ErrorArg.A_NONE);\r\n    }\r\n\r\n    function addWithClip(uint x, uint y, uint maxValue) internal pure returns (uint z) {\r\n        if ((z = x + y) < x || z > maxValue) {\r\n            z = maxValue;\r\n        }\r\n    }\r\n\r\n    // function div(uint x, uint y, Liquifi.ErrorArg scope) internal pure returns (uint z) {\r\n    //     Liquifi._require(y != 0, Liquifi.Error.R_DIV_BY_ZERO, scope);\r\n    //     z = x / y;\r\n    // }\r\n}\r\n\r\ninterface WETH is ERC20 {\r\n    function deposit() external payable;\r\n    function withdraw(uint) external;\r\n}\r\n\r\ninterface ActivityMeter {\r\n    event Deposit(address indexed user, address indexed pool, uint amount);\r\n    event Withdraw(address indexed user, address indexed pool, uint amount);\r\n\r\n    function actualizeUserPool(uint endPeriod, address user, address pool) external returns (uint ethLocked, uint mintedAmount) ;  \r\n    function deposit(address pool, uint128 amount) external returns (uint ethLocked, uint mintedAmount);\r\n    function withdraw(address pool, uint128 amount) external returns (uint ethLocked, uint mintedAmount);\r\n    function actualizeUserPools() external returns (uint ethLocked, uint mintedAmount);\r\n    function liquidityEthPriceChanged(uint effectiveTime, uint availableBalanceEth, uint totalSupply) external;\r\n    function effectivePeriod(uint effectiveTime) external view returns (uint periodNumber, uint quantaElapsed);\r\n    function governanceRouter() external view returns (GovernanceRouter);\r\n    function userEthLocked(address user) external view returns (uint ethLockedPeriod, uint ethLocked, uint totalEthLocked);\r\n    \r\n    function ethLockedHistory(uint period) external view returns (uint ethLockedTotal);\r\n\r\n    function poolsPriceHistory(uint period, address pool) external view returns (\r\n        uint cumulativeEthPrice,\r\n        uint240 lastEthPrice,\r\n        uint16 timeRef\r\n    );\r\n\r\n    function userPoolsSummaries(address user, address pool) external view returns (\r\n        uint144 cumulativeAmountLocked,\r\n        uint16 amountChangeQuantaElapsed,\r\n\r\n        uint128 lastAmountLocked,\r\n        uint16 firstPeriod,\r\n        uint16 lastPriceRecord,\r\n        uint16 earnedForPeriod\r\n    );\r\n\r\n    function userPools(address user, uint poolIndex) external view returns (address pool);\r\n    function userPoolsLength(address user) external view returns (uint length);\r\n\r\n    function userSummaries(address user) external view returns (\r\n        uint128 ethLocked,\r\n        uint16 ethLockedPeriod,\r\n        uint16 firstPeriod\r\n    );\r\n    \r\n    function poolSummaries(address pool) external view returns (\r\n        uint16 lastPriceRecord\r\n    );\r\n    \r\n    function users(uint userIndex) external view returns (address user);\r\n    function usersLength() external view returns (uint);\r\n}\r\n\r\ninterface Minter is ERC20 {\r\n    event Mint(address indexed to, uint256 value, uint indexed period, uint userEthLocked, uint totalEthLocked);\r\n\r\n    function governanceRouter() external view returns (GovernanceRouter);\r\n    function mint(address to, uint period, uint128 userEthLocked, uint totalEthLocked) external returns (uint amount);\r\n    function userTokensToClaim(address user) external view returns (uint amount);\r\n    function periodTokens(uint period) external pure returns (uint128);\r\n    function periodDecayK() external pure returns (uint decayK);\r\n    function initialPeriodTokens() external pure returns (uint128);\r\n}\r\n\r\ninterface PoolFactory {\r\n    event PoolCreatedEvent(address tokenA, address tokenB, bool aIsWETH, address indexed pool);\r\n\r\n    function getPool(address tokenA, address tokenB) external returns (address);\r\n    function findPool(address tokenA, address tokenB) external view returns (address);\r\n    function pools(uint poolIndex) external view returns (address pool);\r\n    function getPoolCount() external view returns (uint);\r\n}\r\n\r\ninterface GovernanceRouter {\r\n    event GovernanceApplied(uint packedGovernance);\r\n    event GovernorChanged(address covernor);\r\n    event ProtocolFeeReceiverChanged(address protocolFeeReceiver);\r\n    event PoolFactoryChanged(address poolFactory);\r\n\r\n    function schedule() external returns(uint timeZero, uint miningPeriod);\r\n    function creator() external returns(address);\r\n    function weth() external returns(WETH);\r\n\r\n    function activityMeter() external returns(ActivityMeter);\r\n    function setActivityMeter(ActivityMeter _activityMeter) external;\r\n\r\n    function minter() external returns(Minter);\r\n    function setMinter(Minter _minter) external;\r\n\r\n    function poolFactory() external returns(PoolFactory);\r\n    function setPoolFactory(PoolFactory _poolFactory) external;\r\n\r\n    function protocolFeeReceiver() external returns(address);\r\n    function setProtocolFeeReceiver(address _protocolFeeReceiver) external;\r\n\r\n    function governance() external view returns (address _governor, uint96 _defaultGovernancePacked);\r\n    function setGovernor(address _governor) external;\r\n    function applyGovernance(uint96 _defaultGovernancePacked) external;\r\n}\r\n\r\ninterface LiquidityPool is ERC20 {\r\n    enum MintReason { DEPOSIT, PROTOCOL_FEE, INITIAL_LIQUIDITY }\r\n    event Mint(address indexed to, uint256 value, MintReason reason);\r\n\r\n    // ORDER_CLOSED reasons are all odd, other reasons are even\r\n    // it allows to check ORDER_CLOSED reasons as (reason & ORDER_CLOSED) != 0\r\n    enum BreakReason { \r\n        NONE,        ORDER_CLOSED, \r\n        ORDER_ADDED, ORDER_CLOSED_BY_STOP_LOSS, \r\n        SWAP,        ORDER_CLOSED_BY_REQUEST,\r\n        MINT,        ORDER_CLOSED_BY_HISTORY_LIMIT,\r\n        BURN,        ORDER_CLOSED_BY_GOVERNOR\r\n    }\r\n\r\n    function poolBalances() external view returns (\r\n        uint balanceALocked,\r\n        uint poolFlowSpeedA, // flow speed: (amountAIn * 2^32)/second\r\n\r\n        uint balanceBLocked,\r\n        uint poolFlowSpeedB, // flow speed: (amountBIn * 2^32)/second\r\n\r\n        uint totalBalanceA,\r\n        uint totalBalanceB,\r\n\r\n        uint delayedSwapsIncome,\r\n        uint rootKLastTotalSupply\r\n    );\r\n\r\n    function governanceRouter() external returns (GovernanceRouter);\r\n    function minimumLiquidity() external returns (uint);\r\n    function aIsWETH() external returns (bool);\r\n\r\n    function mint(address to) external returns (uint liquidityOut);\r\n    function burn(address to, bool extractETH) external returns (uint amountAOut, uint amountBOut);\r\n    function swap(address to, bool extractETH, uint amountAOut, uint amountBOut, bytes calldata externalData) external returns (uint amountAIn, uint amountBIn);\r\n\r\n    function tokenA() external view returns (ERC20);\r\n    function tokenB() external view returns (ERC20);\r\n}\r\n\r\nabstract contract LiquifiToken is ERC20 {\r\n\r\n    function transfer(address to, uint256 value) public override returns (bool success) {\r\n        if (accountBalances[msg.sender] >= value && value > 0) {\r\n            accountBalances[msg.sender] -= value;\r\n            accountBalances[to] += value;\r\n            emit Transfer(msg.sender, to, value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 value) public override returns (bool success) {\r\n        if (accountBalances[from] >= value && allowed[from][msg.sender] >= value && value > 0) {\r\n            accountBalances[to] += value;\r\n            accountBalances[from] -= value;\r\n            allowed[from][msg.sender] -= value;\r\n            emit Transfer(from, to, value);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function balanceOf(address owner) public override view returns (uint256 balance) {\r\n        return accountBalances[owner];\r\n    }\r\n\r\n    function approve(address spender, uint256 value) external override returns (bool success) {\r\n        allowed[msg.sender][spender] = value;\r\n        emit Approval(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) external override view returns (uint256 remaining) {\r\n      return allowed[owner][spender];\r\n    }\r\n\r\n    mapping (address => uint256) internal accountBalances;\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n}\r\n\r\ninterface LiquifiCallee {\r\n    // availableBalance contains 128 bits of availableBalanceA and 128 bits of availableBalanceB\r\n    // delayedSwapsIncome contains 128 bits of delayedSwapsIncomeA and 128 bits of delayedSwapsIncomeB\r\n    function onLiquifiSwap(bytes calldata data, address sender, uint availableBalance, uint delayedSwapsIncome, uint instantNotFee) external;\r\n}\r\n\r\nabstract contract LiquifiLiquidityPool is LiquidityPool, LiquifiToken {\r\n    using Math for uint256;\r\n    \r\n    uint8 public override constant decimals = 18;\r\n    uint public override constant minimumLiquidity = 10**3;\r\n    string public override constant name = 'Liquifi Pool Token';\r\n    \r\n    ERC20 public override immutable tokenA;\r\n    ERC20 public override immutable tokenB;\r\n    bool public override immutable aIsWETH;\r\n    GovernanceRouter public override immutable governanceRouter;\r\n\r\n    Liquifi.PoolBalances internal savedBalances;\r\n    receive() external payable {\r\n        assert(msg.sender == address(tokenA) && aIsWETH);\r\n    }\r\n\r\n    constructor(address tokenAAddress, address tokenBAddress, bool _aIsWETH, address _governanceRouter) internal {\r\n        Liquifi._require(tokenAAddress != tokenBAddress && \r\n            tokenAAddress != address(0) &&\r\n            tokenBAddress != address(0), Liquifi.Error.T_INVALID_TOKENS_PAIR, Liquifi.ErrorArg.A_NONE);\r\n   \r\n        tokenA = ERC20(tokenAAddress);\r\n        tokenB = ERC20(tokenBAddress);\r\n        aIsWETH = _aIsWETH;\r\n        governanceRouter = GovernanceRouter(_governanceRouter);\r\n    }\r\n\r\n    function poolBalances() external override view returns (\r\n        uint balanceALocked,\r\n        uint poolFlowSpeedA, // flow speed: (amountAIn * 2^32)/second\r\n\r\n        uint balanceBLocked,\r\n        uint poolFlowSpeedB, // flow speed: (amountBIn * 2^32)/second\r\n\r\n        uint totalBalanceA,\r\n        uint totalBalanceB,\r\n\r\n        uint delayedSwapsIncome,\r\n        uint rootKLastTotalSupply\r\n    ) {\r\n        balanceALocked = savedBalances.balanceALocked;\r\n        poolFlowSpeedA = savedBalances.poolFlowSpeedA;\r\n\r\n        balanceBLocked = savedBalances.balanceBLocked;\r\n        poolFlowSpeedB = savedBalances.poolFlowSpeedB;\r\n\r\n        totalBalanceA = savedBalances.totalBalanceA;\r\n        totalBalanceB = savedBalances.totalBalanceB;\r\n\r\n        delayedSwapsIncome = savedBalances.delayedSwapsIncome;\r\n        rootKLastTotalSupply = savedBalances.rootKLastTotalSupply;\r\n    }\r\n\r\n    function actualizeBalances(Liquifi.ErrorArg location) internal virtual returns (Liquifi.PoolBalances memory _balances, Liquifi.PoolState memory _state, uint availableBalanceA, uint availableBalanceB);\r\n    function changedBalances(BreakReason reason, Liquifi.PoolBalances memory _balances, Liquifi.PoolState memory _state, uint orderId) internal virtual;\r\n\r\n    function smartTransfer(address token, address to, uint value, Liquifi.ErrorArg tokenType) internal {\r\n        bool success;\r\n        if (tokenType == Liquifi.ErrorArg.Q_TOKEN_ETH) {\r\n            WETH(token).withdraw(value);\r\n            (success,) = to.call{value:value}(new bytes(0)); // TransferETH\r\n        } else {\r\n            bytes memory data;\r\n            (success, data) = token.call(abi.encodeWithSelector(\r\n                0xa9059cbb // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n                , to, value));\r\n            success = success && (data.length == 0 || abi.decode(data, (bool)));\r\n        }\r\n\r\n        Liquifi._require(success, Liquifi.Error.U_TOKEN_TRANSFER_FAILED, tokenType);\r\n    }\r\n\r\n    function mintProtocolFee(\r\n        uint availableBalanceA, uint availableBalanceB, Liquifi.PoolBalances memory _balances, Liquifi.PoolState memory _state\r\n    ) private returns (uint _totalSupply, uint protocolFee) {\r\n        uint rootKLastTotalSupply = _balances.rootKLastTotalSupply;\r\n        _totalSupply = uint128(rootKLastTotalSupply);\r\n        uint _rootKLast = uint128(rootKLastTotalSupply >> 128);\r\n        Liquifi.setFlag(_state, Liquifi.Flag.TOTAL_SUPPLY_DIRTY);\r\n        (,,protocolFee,,) = Liquifi.unpackGovernance(_state);\r\n\r\n        if (protocolFee != 0) {\r\n            if (_rootKLast != 0) {\r\n                uint rootK = Math.sqrt(uint(availableBalanceA).mul(availableBalanceB));\r\n                if (rootK > _rootKLast) {\r\n                    uint numerator = _totalSupply.mul(rootK.subWithClip(_rootKLast));\r\n                    uint denominator = (rootK.mul(1000 - protocolFee) / protocolFee).add(_rootKLast);\r\n                    uint liquidity = numerator / denominator;\r\n\r\n                    if (liquidity > 0) {\r\n                        address protocolFeeReceiver = governanceRouter.protocolFeeReceiver();\r\n                        _totalSupply = _mint(protocolFeeReceiver, liquidity, _totalSupply, MintReason.PROTOCOL_FEE);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function _mint(address to, uint liquidity, uint _totalSupply, MintReason reason) private returns (uint) {\r\n        emit Mint(to, liquidity, reason);\r\n        accountBalances[to] += liquidity;\r\n        return _totalSupply.add(liquidity);\r\n    }\r\n\r\n    function updateTotalSupply(Liquifi.PoolBalances memory _balances, uint totalSupply, uint protocolFee) private pure {\r\n        uint availableBalanceA = Math.subWithClip(_balances.totalBalanceA, _balances.balanceALocked);\r\n        uint availableBalanceB = Math.subWithClip(_balances.totalBalanceB, _balances.balanceBLocked);\r\n        uint K = availableBalanceA.mul(availableBalanceB);\r\n\r\n        _balances.rootKLastTotalSupply = (\r\n            (protocolFee == 0 ? 0 : uint(uint128(Math.sqrt(K))) << 128) |\r\n            Liquifi.trimTotal(totalSupply, Liquifi.ErrorArg.X_TOTAL_SUPPLY)\r\n        );\r\n    }\r\n\r\n    function mint(address to) external override returns (uint liquidity) {\r\n        (Liquifi.PoolBalances memory _balances, Liquifi.PoolState memory _state, uint availableBalanceA, uint availableBalanceB) = actualizeBalances(Liquifi.ErrorArg.K_IN_MINT);\r\n        {\r\n            Liquifi.ErrorArg invalidState = Liquifi.checkInvalidState(_state);\r\n            Liquifi._require(\r\n                invalidState <= Liquifi.ErrorArg.T_FEE_CHANGED_WITH_ORDERS_OPEN\r\n            , Liquifi.Error.J_INVALID_POOL_STATE, invalidState);\r\n        }\r\n\r\n        (uint _totalSupply, uint protocolFee) = mintProtocolFee(availableBalanceA, availableBalanceB, _balances, _state);\r\n\r\n        uint amountA = tokenA.balanceOf(address(this)).subWithClip(_balances.totalBalanceA);\r\n        uint amountB = tokenB.balanceOf(address(this)).subWithClip(_balances.totalBalanceB);\r\n\r\n        liquidity = (_totalSupply == 0) \r\n            ? Math.sqrt(amountA.mul(amountB)).subWithClip(minimumLiquidity) \r\n            : Math.min((amountA.mul(_totalSupply)) / availableBalanceA, (amountB.mul(_totalSupply)) / availableBalanceB);\r\n\r\n        Liquifi._require(liquidity != 0, Liquifi.Error.L_INSUFFICIENT_LIQUIDITY, Liquifi.ErrorArg.C_OUT_AMOUNT);\r\n        if (_totalSupply == 0) {\r\n            _totalSupply = _mint(address(0), minimumLiquidity, _totalSupply, MintReason.INITIAL_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\r\n        }\r\n        \r\n        _totalSupply = _mint(to, liquidity, _totalSupply, MintReason.DEPOSIT);\r\n\r\n        _balances.totalBalanceA = Liquifi.trimTotal(amountA.add(_balances.totalBalanceA), Liquifi.ErrorArg.B_IN_AMOUNT);\r\n        _balances.totalBalanceB = Liquifi.trimTotal(amountB.add(_balances.totalBalanceB), Liquifi.ErrorArg.B_IN_AMOUNT);\r\n        Liquifi.setFlag(_state, Liquifi.Flag.TOTALS_DIRTY);\r\n\r\n        updateTotalSupply(_balances, _totalSupply, protocolFee);\r\n        changedBalances(BreakReason.MINT, _balances, _state, 0);\r\n    }\r\n\r\n    function burn(address to, bool extractETH) external override returns (uint amountA, uint amountB) {\r\n        (Liquifi.PoolBalances memory _balances, Liquifi.PoolState memory _state, uint availableBalanceA, uint availableBalanceB) \r\n            = actualizeBalances(Liquifi.ErrorArg.L_IN_BURN);\r\n        uint liquidity = Liquifi.trimAmount(balanceOf(address(this)), Liquifi.ErrorArg.B_IN_AMOUNT);\r\n\r\n        (uint _totalSupply, uint protocolFee) = mintProtocolFee(availableBalanceA, availableBalanceB, _balances, _state);\r\n\r\n        Liquifi._require(_totalSupply != 0, Liquifi.Error.L_INSUFFICIENT_LIQUIDITY, Liquifi.ErrorArg.L_IN_BURN);\r\n    \r\n        amountA = liquidity.mul(availableBalanceA) / _totalSupply;\r\n        amountB = liquidity.mul(availableBalanceB) / _totalSupply;\r\n\r\n        Liquifi._require(amountA * amountB != 0, Liquifi.Error.L_INSUFFICIENT_LIQUIDITY, Liquifi.ErrorArg.B_IN_AMOUNT);\r\n\r\n        ERC20 _tokenA = tokenA; // gas savings\r\n        ERC20 _tokenB = tokenB; // gas savings\r\n\r\n        accountBalances[address(this)] = 0;\r\n        _totalSupply = _totalSupply.subWithClip(liquidity);\r\n\r\n        smartTransfer(address(_tokenA), to, amountA, (extractETH && aIsWETH) ? Liquifi.ErrorArg.Q_TOKEN_ETH : Liquifi.ErrorArg.O_TOKEN_A);\r\n        smartTransfer(address(_tokenB), to, amountB, Liquifi.ErrorArg.P_TOKEN_B);\r\n\r\n        _balances.totalBalanceA = Liquifi.trimTotal(_tokenA.balanceOf(address(this)), Liquifi.ErrorArg.O_TOKEN_A);\r\n        _balances.totalBalanceB = Liquifi.trimTotal(_tokenB.balanceOf(address(this)), Liquifi.ErrorArg.P_TOKEN_B);\r\n        Liquifi.setFlag(_state, Liquifi.Flag.TOTALS_DIRTY);\r\n\r\n        updateTotalSupply(_balances, _totalSupply, protocolFee);\r\n        changedBalances(BreakReason.BURN, _balances, _state, 0);\r\n    }\r\n\r\n    function splitDelayedSwapsIncome(uint delayedSwapsIncome) internal pure returns (uint delayedSwapsIncomeA, uint delayedSwapsIncomeB){\r\n        delayedSwapsIncomeA = uint128(delayedSwapsIncome >> 128);\r\n        delayedSwapsIncomeB = uint128(delayedSwapsIncome);\r\n    }\r\n\r\n    function subDelayedSwapsIncome(Liquifi.PoolBalances memory _balances, Liquifi.PoolState memory _state, uint subA, uint subB) internal pure {\r\n        if (_balances.delayedSwapsIncome != 0) {\r\n            (uint delayedSwapsIncomeA, uint delayedSwapsIncomeB) = splitDelayedSwapsIncome(_balances.delayedSwapsIncome);\r\n            _balances.delayedSwapsIncome = \r\n                    Math.subWithClip(delayedSwapsIncomeA, subA) << 128 |\r\n                    Math.subWithClip(delayedSwapsIncomeB, subB);\r\n            Liquifi.setFlag(_state, Liquifi.Flag.SWAPS_INCOME_DIRTY);\r\n        }\r\n    }\r\n\r\n    function swap(\r\n        address to, bool extractETH, uint amountAOut, uint amountBOut, bytes calldata externalData\r\n    ) external override returns (uint amountAIn, uint amountBIn) {\r\n        uint availableBalanceA;\r\n        uint availableBalanceB;\r\n        Liquifi.PoolBalances memory _balances; \r\n        Liquifi.PoolState memory _state;\r\n        (_balances, _state, availableBalanceA, availableBalanceB) = actualizeBalances(Liquifi.ErrorArg.F_IN_SWAP);\r\n        {\r\n            Liquifi.ErrorArg invalidState = Liquifi.checkInvalidState(_state);\r\n            Liquifi._require(\r\n                invalidState <= Liquifi.ErrorArg.T_FEE_CHANGED_WITH_ORDERS_OPEN\r\n            , Liquifi.Error.J_INVALID_POOL_STATE, invalidState);\r\n        }\r\n        uint instantNotFee = 1000;\r\n        {\r\n            // set fee to zero if new order doesn't exceed current limits\r\n            (uint delayedSwapsIncomeA, uint delayedSwapsIncomeB) = splitDelayedSwapsIncome(_balances.delayedSwapsIncome);\r\n            uint exceedingAIncome = availableBalanceB == 0 ? 0 : delayedSwapsIncomeA.subWithClip(delayedSwapsIncomeB * availableBalanceA / availableBalanceB);\r\n            uint exceedingBIncome = availableBalanceA == 0 ? 0 : delayedSwapsIncomeB.subWithClip(delayedSwapsIncomeA * availableBalanceB / availableBalanceA);\r\n            \r\n            if (amountAOut > exceedingAIncome || amountBOut > exceedingBIncome) {\r\n                (uint instantFee,,,,) = Liquifi.unpackGovernance(_state);\r\n                instantNotFee -= instantFee;\r\n            }\r\n        }\r\n        \r\n        Liquifi._require(amountAOut | amountBOut != 0, Liquifi.Error.F_ZERO_AMOUNT_VALUE, Liquifi.ErrorArg.C_OUT_AMOUNT);\r\n        Liquifi._require(amountAOut < availableBalanceA && amountBOut < availableBalanceB, Liquifi.Error.E_TOO_BIG_AMOUNT_VALUE, Liquifi.ErrorArg.C_OUT_AMOUNT);\r\n        \r\n        { // localize variables to reduce stack depth\r\n            // optimistically transfer tokens\r\n            if (amountAOut > 0) {\r\n                smartTransfer(address(tokenA), to, amountAOut, (extractETH && aIsWETH) ? Liquifi.ErrorArg.Q_TOKEN_ETH : Liquifi.ErrorArg.O_TOKEN_A);\r\n                _balances.totalBalanceA = uint128(Math.subWithClip(_balances.totalBalanceA, amountAOut));\r\n            }\r\n            if (amountBOut > 0) {\r\n                smartTransfer(address(tokenB), to, amountBOut, Liquifi.ErrorArg.P_TOKEN_B);\r\n                _balances.totalBalanceB = uint128(Math.subWithClip(_balances.totalBalanceB, amountBOut));\r\n            }\r\n\r\n            if (externalData.length > 0) {\r\n                uint availableBalance = (availableBalanceA << 128) | availableBalanceB;\r\n                // flash swap, also allows to execute swap without pror call of processDelayedOrders\r\n                LiquifiCallee(to).onLiquifiSwap(externalData, msg.sender, availableBalance, _balances.delayedSwapsIncome, instantNotFee);\r\n            }\r\n            \r\n            {\r\n                // compute amountIn and update totalBalance\r\n                uint newTotalBalance;\r\n                newTotalBalance = tokenA.balanceOf(address(this));\r\n                amountAIn = Liquifi.trimAmount(newTotalBalance.subWithClip(_balances.totalBalanceA), Liquifi.ErrorArg.B_IN_AMOUNT);\r\n                _balances.totalBalanceA = Liquifi.trimTotal(newTotalBalance, Liquifi.ErrorArg.O_TOKEN_A);\r\n\r\n                newTotalBalance = tokenB.balanceOf(address(this));\r\n                amountBIn = Liquifi.trimAmount(newTotalBalance.subWithClip(_balances.totalBalanceB), Liquifi.ErrorArg.B_IN_AMOUNT);\r\n                _balances.totalBalanceB = Liquifi.trimTotal(newTotalBalance, Liquifi.ErrorArg.P_TOKEN_B);\r\n\r\n                Liquifi.setFlag(_state, Liquifi.Flag.TOTALS_DIRTY);\r\n            }\r\n        }\r\n\r\n        subDelayedSwapsIncome(_balances, _state, amountAOut, amountBOut);\r\n\r\n        Liquifi._require(amountAIn | amountBIn != 0, Liquifi.Error.F_ZERO_AMOUNT_VALUE, Liquifi.ErrorArg.B_IN_AMOUNT);\r\n        \r\n        { // check invariant\r\n            uint newBalanceA = availableBalanceA.subWithClip(amountAOut).mul(1000);\r\n            newBalanceA = newBalanceA.add(amountAIn * instantNotFee);\r\n            uint newBalanceB = availableBalanceB.subWithClip(amountBOut).mul(1000);\r\n            newBalanceB = newBalanceB.add(amountBIn * instantNotFee);\r\n            \r\n            Liquifi._require(\r\n                newBalanceA.mul(newBalanceB) >= availableBalanceA.mul(availableBalanceB).mul(1000**2), \r\n                Liquifi.Error.J_INVALID_POOL_STATE, Liquifi.ErrorArg.F_IN_SWAP);\r\n        }\r\n\r\n        changedBalances(BreakReason.SWAP, _balances, _state, 0);\r\n    }\r\n}\r\n\r\ninterface DelayedExchangePool is LiquidityPool {\r\n    event FlowBreakEvent( \r\n        address sender, \r\n        // total balance contains 128 bit of totalBalanceA and 128 bit of totalBalanceB\r\n        uint totalBalance, \r\n        // contains 128 bits of rootKLast and 128 bits of totalSupply\r\n        uint rootKLastTotalSupply, \r\n        uint indexed orderId,\r\n        // breakHash is computed over all fields below\r\n        \r\n        bytes32 lastBreakHash,\r\n        // availableBalance consists of 128 bits of availableBalanceA and 128 bits of availableBalanceB\r\n        uint availableBalance, \r\n        // flowSpeed consists of 144 bits of poolFlowSpeedA and 112 higher bits of poolFlowSpeedB\r\n        uint flowSpeed,\r\n        // others consists of 32 lower bits of poolFlowSpeedB, 16 bit of notFee, 64 bit of time, 64 bit of orderId, 76 higher bits of packed and 4 bit of reason (BreakReason)\r\n        uint others      \r\n    );\r\n\r\n    event OrderClaimedEvent(uint indexed orderId, address to);\r\n    event OperatingInInvalidState(uint location, uint invalidStateReason);\r\n    event GovernanceApplied(uint packedGovernance);\r\n    \r\n    function addOrder(\r\n        address owner, uint orderFlags, uint prevByStopLoss, uint prevByTimeout, \r\n        uint stopLossAmount, uint period\r\n    ) external returns (uint id);\r\n\r\n    // availableBalance contains 128 bits of availableBalanceA and 128 bits of availableBalanceB\r\n    // delayedSwapsIncome contains 128 bits of delayedSwapsIncomeA and 128 bits of delayedSwapsIncomeB\r\n    function processDelayedOrders() external returns (uint availableBalance, uint delayedSwapsIncome, uint packed);\r\n\r\n    function claimOrder (\r\n        bytes32 previousBreakHash,\r\n        // see LiquifyPoolRegister.claimOrder for breaks list details\r\n        uint[] calldata breaksHistory\r\n    ) external returns (address owner, uint amountAOut, uint amountBOut);\r\n\r\n    function applyGovernance(uint packedGovernanceFields) external;\r\n    function sync() external;\r\n    function closeOrder(uint id) external;\r\n\r\n    function poolQueue() external view returns (\r\n        uint firstByTokenAStopLoss, uint lastByTokenAStopLoss, // linked list of orders sorted by (amountAIn/stopLossAmount) ascending\r\n        uint firstByTokenBStopLoss, uint lastByTokenBStopLoss, // linked list of orders sorted by (amountBIn/stopLossAmount) ascending\r\n    \r\n        uint firstByTimeout, uint lastByTimeout // linked list of orders sorted by timeouts ascending\r\n    );\r\n\r\n    function lastBreakHash() external view returns (bytes32);\r\n\r\n    function poolState() external view returns (\r\n        bytes32 _prevBlockBreakHash,\r\n        uint packed, // see Liquifi.PoolState for details\r\n        uint notFee,\r\n\r\n        uint lastBalanceUpdateTime,\r\n        uint nextBreakTime,\r\n        uint maxHistory,\r\n        uint ordersToClaimCount,\r\n        uint breaksCount\r\n    );\r\n\r\n    function findOrder(uint orderId) external view returns (        \r\n        uint nextByTimeout, uint prevByTimeout,\r\n        uint nextByStopLoss, uint prevByStopLoss,\r\n        \r\n        uint stopLossAmount,\r\n        uint amountIn,\r\n        uint period,\r\n        \r\n        address owner,\r\n        uint timeout,\r\n        uint flags\r\n    );\r\n}\r\n\r\n// SPDX-License-Identifier: GPL-3.0\r\n//import { Debug } from \"./libraries/Debug.sol\";\r\ncontract LiquifiDelayedExchangePool is LiquifiLiquidityPool, DelayedExchangePool {\r\n    using Math for uint256;\r\n    ActivityMeter private immutable activityMeter;\r\n\r\n    mapping(uint => Liquifi.Order) private orders;\r\n    Liquifi.PoolState private savedState;\r\n    // BreakHash value computed last before current block\r\n    // This field is useful for price oracles: it allows to calculate average price for arbitrary period in past\r\n    // using FlowBreakEvent list provided by offchain code \r\n    //\r\n    // Also this field includes processing flag in the least valuable bit\r\n    // So, only highest 255 bits should be used for hash validation\r\n    // This word is always saved in enter()\r\n    bytes32 private prevBlockBreakHash;\r\n    uint private immutable poolIndex;\r\n\r\n    constructor(address tokenAAddress, address tokenBAddress, bool _aIsWETH, address _governanceRouter, uint _index) \r\n        LiquifiLiquidityPool(tokenAAddress, tokenBAddress, _aIsWETH, _governanceRouter) public {\r\n        savedState.nextBreakTime = Liquifi.maxTime;\r\n        poolIndex = _index;\r\n        activityMeter = GovernanceRouter(_governanceRouter).activityMeter();\r\n    }\r\n\r\n    // use LPTXXXXXX symbols where XXXXXX is index in the pool factory\r\n    // it takes much less bytecode than concatenation of tokens symbols\r\n    function symbol() external view override returns (string memory _symbol) {\r\n        bytes memory symbolBytes = \"\\x4c\\x50\\x54\\x30\\x30\\x30\\x30\\x30\\x30\"; // LPT\r\n        uint _index = poolIndex;\r\n        uint pos = 8;\r\n        while (pos > 2) {\r\n            symbolBytes[pos--] = bytes1(uint8(48 + _index % 10));\r\n            _index = _index / 10;\r\n        }\r\n        \r\n        _symbol = string(symbolBytes);\r\n    }\r\n\r\n    function poolTime(Liquifi.PoolState memory _state) private view returns (uint) {\r\n        return Liquifi.checkFlag(_state, Liquifi.Flag.POOL_LOCKED) ? _state.lastBalanceUpdateTime : Liquifi.trimTime(block.timestamp);\r\n    }\r\n\r\n    function poolQueue() external override view returns (\r\n        uint firstByTokenAStopLoss, uint lastByTokenAStopLoss, // linked list of orders sorted by (amountAIn/stopLossAmount) ascending\r\n        uint firstByTokenBStopLoss, uint lastByTokenBStopLoss, // linked list of orders sorted by (amountBIn/stopLossAmount) ascending\r\n    \r\n        uint firstByTimeout, uint lastByTimeout // linked list of orders sorted by timeouts ascending\r\n    ) {\r\n        firstByTokenAStopLoss = savedState.firstByTokenAStopLoss;\r\n        lastByTokenAStopLoss = savedState.lastByTokenAStopLoss;\r\n        firstByTokenBStopLoss = savedState.firstByTokenBStopLoss;\r\n        lastByTokenBStopLoss = savedState.lastByTokenBStopLoss;\r\n        \r\n        firstByTimeout = savedState.firstByTimeout;\r\n        lastByTimeout = savedState.lastByTimeout;\r\n    }\r\n\r\n    function lastBreakHash() external override view returns (bytes32) {\r\n        return savedState.lastBreakHash;\r\n    }\r\n\r\n    function poolState() external override view returns (\r\n        bytes32 _prevBlockBreakHash,\r\n        uint packed, // see Liquifi.PoolState for details\r\n        uint notFee,\r\n\r\n        uint lastBalanceUpdateTime,\r\n        uint nextBreakTime,\r\n        uint maxHistory,\r\n        uint ordersToClaimCount,\r\n        uint breaksCount\r\n    ) {\r\n        _prevBlockBreakHash = prevBlockBreakHash;\r\n\r\n        packed = savedState.packed;\r\n        notFee = savedState.notFee;\r\n\r\n        lastBalanceUpdateTime = savedState.lastBalanceUpdateTime;\r\n        nextBreakTime = savedState.nextBreakTime;\r\n        maxHistory = savedState.maxHistory;\r\n        ordersToClaimCount = savedState.ordersToClaimCount;\r\n        breaksCount = savedState.breaksCount;\r\n    }\r\n\r\n    function findOrder(uint orderId) external override view returns (        \r\n        uint nextByTimeout, uint prevByTimeout,\r\n        uint nextByStopLoss, uint prevByStopLoss,\r\n        \r\n        uint stopLossAmount,\r\n        uint amountIn,\r\n        uint period,\r\n        \r\n        address owner,\r\n        uint timeout,\r\n        uint flags\r\n    ) {\r\n        Liquifi.Order storage order = orders[uint64(orderId)];\r\n        nextByTimeout = order.nextByTimeout;\r\n        prevByTimeout = order.prevByTimeout;\r\n        nextByStopLoss = order.nextByStopLoss;\r\n        prevByStopLoss = order.prevByStopLoss;\r\n\r\n        stopLossAmount = order.stopLossAmount;\r\n        amountIn = order.amountIn;\r\n        period = order.period;\r\n\r\n        owner = order.owner;\r\n        timeout = order.timeout;\r\n        flags = order.flags;\r\n    }\r\n\r\n    function totalSupply() external override view returns (uint) {\r\n        return uint128(savedBalances.rootKLastTotalSupply);\r\n    }\r\n\r\n    function applyGovernance(uint packedGovernanceFields) external override {\r\n        (address governor, ) = governanceRouter.governance();\r\n        Liquifi._require(msg.sender == governor, Liquifi.Error.Y_UNAUTHORIZED_SENDER, Liquifi.ErrorArg.S_BY_GOVERNANCE);\r\n        savedState.packed = uint96(packedGovernanceFields);\r\n        emit GovernanceApplied(packedGovernanceFields);\r\n    }\r\n\r\n    function addOrder(\r\n        address owner, uint orderFlags, uint prevByStopLoss, uint prevByTimeout, \r\n        uint stopLossAmount, uint period\r\n    ) external override returns (uint id) {\r\n        (Liquifi.PoolBalances memory _balances, Liquifi.PoolState memory _state, ,) = actualizeBalances(Liquifi.ErrorArg.E_IN_ADD_ORDER);\r\n        {\r\n            Liquifi.ErrorArg invalidState = Liquifi.checkInvalidState(_state);\r\n            Liquifi._require(invalidState == Liquifi.ErrorArg.A_NONE, Liquifi.Error.J_INVALID_POOL_STATE, invalidState);\r\n        }\r\n\r\n        Liquifi._require(period > 0, Liquifi.Error.G_ZERO_PERIOD_VALUE, Liquifi.ErrorArg.E_IN_ADD_ORDER);\r\n        Liquifi._require(stopLossAmount > 0, Liquifi.Error.F_ZERO_AMOUNT_VALUE, Liquifi.ErrorArg.D_STOP_LOSS_AMOUNT);\r\n \r\n        uint amountIn;\r\n        bool isTokenAIn = Liquifi.isTokenAIn(orderFlags);\r\n        {  // localize variables to reduce stack depth\r\n            Liquifi.setFlag(_state, Liquifi.Flag.TOTALS_DIRTY);\r\n            uint _totalBalance = isTokenAIn ? _balances.totalBalanceA : _balances.totalBalanceB;\r\n            _balances.totalBalanceA = Liquifi.trimTotal(tokenA.balanceOf(address(this)), Liquifi.ErrorArg.O_TOKEN_A);\r\n            _balances.totalBalanceB = Liquifi.trimTotal(tokenB.balanceOf(address(this)), Liquifi.ErrorArg.P_TOKEN_B);\r\n            uint newTotalBalance = isTokenAIn ? _balances.totalBalanceA : _balances.totalBalanceB;\r\n\r\n            Liquifi._require(newTotalBalance > _totalBalance, Liquifi.Error.F_ZERO_AMOUNT_VALUE, Liquifi.ErrorArg.B_IN_AMOUNT);\r\n\r\n            amountIn = Liquifi.trimAmount(newTotalBalance.subWithClip(_totalBalance), Liquifi.ErrorArg.B_IN_AMOUNT);\r\n            Liquifi._require(amountIn > 0, Liquifi.Error.F_ZERO_AMOUNT_VALUE, Liquifi.ErrorArg.B_IN_AMOUNT);\r\n            \r\n            if (isTokenAIn) {\r\n                Liquifi.setFlag(_state, Liquifi.Flag.BALANCE_A_DIRTY);\r\n                _balances.balanceALocked = Liquifi.trimAmount(amountIn + _balances.balanceALocked, Liquifi.ErrorArg.O_TOKEN_A);\r\n                _balances.poolFlowSpeedA = Liquifi.trimFlowSpeed(_balances.poolFlowSpeedA + (amountIn << 32) / period, Liquifi.ErrorArg.O_TOKEN_A); // multiply to 2^32 to keep precision\r\n            } else {\r\n                Liquifi.setFlag(_state, Liquifi.Flag.BALANCE_B_DIRTY);\r\n                _balances.balanceBLocked = Liquifi.trimAmount(amountIn + _balances.balanceBLocked, Liquifi.ErrorArg.P_TOKEN_B);\r\n                _balances.poolFlowSpeedB = Liquifi.trimFlowSpeed(_balances.poolFlowSpeedB + (amountIn << 32) / period, Liquifi.ErrorArg.P_TOKEN_B); // multiply to 2^32 to keep precision\r\n            } \r\n        }\r\n\r\n        (,,,uint maxPeriod,) = Liquifi.unpackGovernance(_state);\r\n        Liquifi._require(period <= maxPeriod, Liquifi.Error.D_TOO_BIG_PERIOD_VALUE, Liquifi.ErrorArg.E_IN_ADD_ORDER);\r\n        Liquifi.trimAmount(stopLossAmount, Liquifi.ErrorArg.D_STOP_LOSS_AMOUNT); // check limits before usage\r\n\r\n        id = saveOrder(\r\n            _state,\r\n            period, \r\n            prevByTimeout, prevByStopLoss, // overflow only leads to position re-computing\r\n            amountIn, \r\n            stopLossAmount, \r\n            isTokenAIn);\r\n\r\n        {\r\n            Liquifi.Order storage order = orders[id];\r\n            (order.stopLossAmount, order.amountIn, order.period) = (uint112(stopLossAmount), uint112(amountIn), uint32(period)); //already trimmed  \r\n\r\n            uint64 timeout = Liquifi.trimTime(poolTime(_state) + period);\r\n            (order.owner, order.timeout, order.flags) = (owner, timeout, uint8(orderFlags));\r\n        }\r\n                                     \r\n        changedBalances(BreakReason.ORDER_ADDED, _balances, _state, id);\r\n    }\r\n\r\n    function processDelayedOrders() external override\r\n        returns (uint availableBalance, uint delayedSwapsIncome, uint packed) {\r\n        Liquifi.PoolBalances memory _balances; \r\n        Liquifi.PoolState memory _state;\r\n        uint availableBalanceA;\r\n        uint availableBalanceB;\r\n        (_balances, _state, availableBalanceA, availableBalanceB) = actualizeBalances(Liquifi.ErrorArg.N_IN_PROCESS_DELAYED_ORDERS);\r\n        availableBalance = (availableBalanceA << 128) | availableBalanceB;\r\n        delayedSwapsIncome = _balances.delayedSwapsIncome;\r\n        packed = _state.packed;\r\n        exit(_balances, _state);\r\n    }\r\n    \r\n    function claimOrder (\r\n        bytes32 previousBreakHash,\r\n        // availableBalance (0), flowSpeed (1), others (2)\r\n        // uint256 others = \r\n        //             (uint(_balances.poolFlowSpeedB) << 224) |\r\n        //             (uint(_state.notFee) << 208) | \r\n        //             (uint(time) << 144) | \r\n        //             (uint(orderId) << 80) | \r\n        //             (uint(_state.packed >> 20) << 4) |\r\n        //             uint(reason);\r\n        // uint availableBalance = (availableBalanceA << 128) | availableBalanceB;\r\n        // uint flowSpeed = (uint(_balances.poolFlowSpeedA) << 112) | (_balances.poolFlowSpeedB >> 32);\r\n        // see LiquifiPoolRegister.claimOrder for breaks list details\r\n        uint[] calldata breaksHistory\r\n    ) external override returns (address owner, uint amountAOut, uint amountBOut) {\r\n        (Liquifi.PoolBalances memory _balances, Liquifi.PoolState memory _state) = enter(Liquifi.ErrorArg.M_IN_CLAIM_ORDER);\r\n\r\n        uint lastIndex = breaksHistory.length;\r\n        Liquifi._require(lastIndex != 0, Liquifi.Error.M_EMPTY_LIST, Liquifi.ErrorArg.H_IN_BREAKS_HISTORY);\r\n        Liquifi._require(lastIndex % 3 == 0, Liquifi.Error.N_BAD_LENGTH, Liquifi.ErrorArg.H_IN_BREAKS_HISTORY);\r\n        \r\n        lastIndex = (lastIndex / 3) - 1;\r\n        \r\n        Liquifi.OrderClaim memory claim;\r\n        claim.orderId = getBreakOrderId(breaksHistory, 0);\r\n        bool partialHistory = getBreakOrderId(breaksHistory, lastIndex) != claim.orderId\r\n            || (uint8(getBreakReason(breaksHistory, lastIndex)) & uint8(BreakReason.ORDER_CLOSED) == 0); // check for any close reason\r\n        \r\n        // try to fail earlier if some more breaks happened after history collecting\r\n        Liquifi._require(!partialHistory || getBreakTime(breaksHistory, lastIndex) == _state.nextBreakTime,\r\n            Liquifi.Error.R_INCOMPLETE_HISTORY,  Liquifi.ErrorArg.H_IN_BREAKS_HISTORY);\r\n        \r\n        Liquifi._require(getBreakReason(breaksHistory, 0) == BreakReason.ORDER_ADDED, \r\n            Liquifi.Error.Q_ORDER_NOT_ADDED, Liquifi.ErrorArg.H_IN_BREAKS_HISTORY);\r\n\r\n        // All orders are closed before fee change applying, so it is safe to use old fee for partial history\r\n        // notFee is not saved on exit(), so it is safe to change it for current request only\r\n        _state.notFee = uint16(getBreakFee(breaksHistory, 0));\r\n        \r\n        uint amountIn;\r\n        {\r\n            uint orderPeriod;\r\n            Liquifi.Order storage order = orders[claim.orderId];\r\n    \r\n            (amountIn, orderPeriod) = (order.amountIn, order.period); // grouped read\r\n            (owner, claim.flags) = (order.owner, order.flags); // grouped read\r\n\r\n            Liquifi._require(orderPeriod > 0, // check a required property\r\n                Liquifi.Error.V_ORDER_NOT_EXIST, Liquifi.ErrorArg.M_IN_CLAIM_ORDER);\r\n\r\n            claim.orderFlowSpeed = (amountIn << 32) / orderPeriod; //= Sai' or = Sbi'            \r\n            claim.previousOthers = breaksHistory[2];\r\n        }\r\n        \r\n        {\r\n            uint index = 0;\r\n\r\n            while(index <= lastIndex) {\r\n                previousBreakHash = computeBreakHash(previousBreakHash, breaksHistory, index);\r\n                appendSegmentToClaim(\r\n                    breaksHistory[index * 3],\r\n                    breaksHistory[index * 3 + 1],\r\n                    breaksHistory[index * 3 + 2],\r\n                    _state.notFee,\r\n                    claim\r\n                );\r\n                index++;\r\n            }\r\n        }\r\n\r\n        {\r\n            bytes32 lashHash;\r\n            if (partialHistory) {\r\n                lashHash = _state.lastBreakHash;\r\n                processBreaks(_balances, _state, claim);\r\n                Liquifi._require(claim.closeReason != 0, Liquifi.Error.P_ORDER_NOT_CLOSED, Liquifi.ErrorArg.M_IN_CLAIM_ORDER);\r\n            } else {\r\n                claim.closeReason = uint(getBreakReason(breaksHistory, lastIndex));\r\n                Liquifi.Order storage order = orders[claim.orderId];\r\n                lashHash = bytes32(\r\n                    uint(order.nextByTimeout) << 192\r\n                    | (uint(order.prevByTimeout) << 128)\r\n                    | (uint(order.nextByStopLoss) << 64)\r\n                    | uint(order.prevByStopLoss)\r\n                );\r\n            }\r\n\r\n            // compare all except for the lowest bit\r\n            Liquifi._require(previousBreakHash >> 1 == lashHash >> 1,\r\n                        Liquifi.Error.O_HASH_MISMATCH, Liquifi.ErrorArg.H_IN_BREAKS_HISTORY);\r\n        }\r\n        \r\n        {\r\n            uint totalPeriod = extractBreakTime(claim.previousOthers) - getBreakTime(breaksHistory, 0);\r\n            amountIn = claim.closeReason == uint(BreakReason.ORDER_CLOSED) ? 0 : amountIn.subWithClip((claim.orderFlowSpeed * totalPeriod) >> 32);\r\n            (amountAOut, amountBOut) = Liquifi.isTokenAIn(claim.flags) ? (amountIn, claim.amountOut) : (claim.amountOut, amountIn);\r\n        }\r\n        \r\n        {\r\n            ERC20 token;\r\n            if (amountAOut > 0) {\r\n                token = tokenA;\r\n                smartTransfer(address(token), owner, amountAOut, ((claim.flags & uint(Liquifi.OrderFlag.EXTRACT_ETH) != 0) && aIsWETH) ? Liquifi.ErrorArg.Q_TOKEN_ETH : Liquifi.ErrorArg.O_TOKEN_A);\r\n                _balances.totalBalanceA = Liquifi.trimTotal(token.balanceOf(address(this)), Liquifi.ErrorArg.O_TOKEN_A);\r\n                _balances.balanceALocked = uint112(Math.subWithClip(_balances.balanceALocked, amountAOut));\r\n                Liquifi.setFlag(_state, Liquifi.Flag.BALANCE_A_DIRTY);\r\n            }\r\n            \r\n            if (amountBOut > 0) {\r\n                token = tokenB;\r\n                smartTransfer(address(token), owner, amountBOut, Liquifi.ErrorArg.P_TOKEN_B);\r\n                _balances.totalBalanceB = Liquifi.trimTotal(token.balanceOf(address(this)), Liquifi.ErrorArg.P_TOKEN_B);\r\n                _balances.balanceBLocked = uint112(Math.subWithClip(_balances.balanceBLocked, amountBOut));\r\n                Liquifi.setFlag(_state, Liquifi.Flag.BALANCE_B_DIRTY);\r\n            }\r\n\r\n            Liquifi.setFlag(_state, Liquifi.Flag.TOTALS_DIRTY);\r\n        }\r\n        \r\n        delete orders[claim.orderId];\r\n        emit OrderClaimedEvent(claim.orderId, owner);\r\n        _state.ordersToClaimCount -= 1; \r\n        exit(_balances, _state);\r\n    }\r\n\r\n    bytes32 private constant one = bytes32(uint(1));\r\n    \r\n    function enter(Liquifi.ErrorArg location) private returns (Liquifi.PoolBalances memory _balances, Liquifi.PoolState memory _state) {\r\n        _state = savedState;\r\n        _balances = savedBalances;\r\n        \r\n        bytes32 _prevBlockBreakHash = prevBlockBreakHash;\r\n        bool mutexFlag1 = _prevBlockBreakHash & one == one;\r\n        {\r\n            bool mutexFlag2 = _state.breaksCount & 1 != 0;\r\n            Liquifi._require(mutexFlag1 == mutexFlag2, Liquifi.Error.S_REENTRANCE_NOT_SUPPORTED, location);    \r\n        }\r\n        \r\n        if (!Liquifi.checkFlag(_state, Liquifi.Flag.GOVERNANCE_OVERRIDEN)) {\r\n            (, uint96 defaultGovernancePacked) = governanceRouter.governance();\r\n            _state.packed = defaultGovernancePacked;\r\n        }\r\n\r\n        _state.packed = ((_state.packed >> 20) << 20); // clear 20 transient bits\r\n\r\n        if (Liquifi.checkFlag(_state, Liquifi.Flag.POOL_LOCKED)) {\r\n            Liquifi.setInvalidState(_state, Liquifi.ErrorArg.W_POOL_LOCKED);\r\n        }\r\n\r\n        (,uint desiredOrdersFee,,,) = Liquifi.unpackGovernance(_state);\r\n        uint16 notFee = uint16(1000 - desiredOrdersFee);\r\n        if (notFee != _state.notFee) {\r\n            if (_state.firstByTimeout != 0) { \r\n                // queue is not empty\r\n                // no orders adding allowed\r\n                Liquifi.setInvalidState(_state, Liquifi.ErrorArg.T_FEE_CHANGED_WITH_ORDERS_OPEN);\r\n            } else {\r\n                savedState.notFee = notFee;\r\n                _state.notFee = notFee;\r\n            }\r\n        }\r\n\r\n        // save hash if it was calculated in past\r\n        if (_state.lastBalanceUpdateTime < poolTime(_state)) {\r\n            _prevBlockBreakHash = _state.lastBreakHash;\r\n        }\r\n        // negate mutex bit in _prevBlockBreakHash and temporarly save it in Flags.MUTEX\r\n        if (mutexFlag1) {\r\n            Liquifi.clearFlag(_state, Liquifi.Flag.MUTEX);\r\n            _prevBlockBreakHash = _prevBlockBreakHash & ~(one);\r\n        } else {\r\n            Liquifi.setFlag(_state, Liquifi.Flag.MUTEX);\r\n            _prevBlockBreakHash = _prevBlockBreakHash | one;\r\n        }\r\n        \r\n        prevBlockBreakHash = _prevBlockBreakHash;\r\n    }\r\n\r\n    function exit(Liquifi.PoolBalances memory _balances, Liquifi.PoolState memory _state) private {\r\n        if (Liquifi.checkFlag(_state, Liquifi.Flag.HASH_DIRTY)) {\r\n            savedState.lastBreakHash = _state.lastBreakHash;\r\n        }\r\n        \r\n        if (Liquifi.checkFlag(_state, Liquifi.Flag.BALANCE_A_DIRTY)) {\r\n            (savedBalances.balanceALocked, savedBalances.poolFlowSpeedA) = (_balances.balanceALocked, _balances.poolFlowSpeedA);\r\n        }\r\n\r\n        if (Liquifi.checkFlag(_state, Liquifi.Flag.BALANCE_B_DIRTY)) {\r\n            (savedBalances.balanceBLocked, savedBalances.poolFlowSpeedB) = (_balances.balanceBLocked, _balances.poolFlowSpeedB);\r\n        }\r\n\r\n        if (Liquifi.checkFlag(_state, Liquifi.Flag.TOTALS_DIRTY)) {\r\n            (savedBalances.totalBalanceA, savedBalances.totalBalanceB) = (_balances.totalBalanceA, _balances.totalBalanceB);\r\n        }\r\n\r\n        if (Liquifi.checkFlag(_state, Liquifi.Flag.SWAPS_INCOME_DIRTY)) {\r\n            (savedBalances.delayedSwapsIncome) = (_balances.delayedSwapsIncome);\r\n        }\r\n\r\n        if (Liquifi.checkFlag(_state, Liquifi.Flag.TOTAL_SUPPLY_DIRTY)) {\r\n            (savedBalances.rootKLastTotalSupply) = (_balances.rootKLastTotalSupply);\r\n        }\r\n\r\n        if (Liquifi.checkFlag(_state, Liquifi.Flag.QUEUE_STOPLOSS_DIRTY)) {\r\n            (savedState.firstByTokenAStopLoss, savedState.lastByTokenAStopLoss, savedState.firstByTokenBStopLoss, savedState.lastByTokenBStopLoss) = \r\n                (_state.firstByTokenAStopLoss, _state.lastByTokenAStopLoss, _state.firstByTokenBStopLoss, _state.lastByTokenBStopLoss);\r\n        }\r\n\r\n        if (Liquifi.checkFlag(_state, Liquifi.Flag.QUEUE_TIMEOUT_DIRTY)) {\r\n            (savedState.firstByTimeout, savedState.lastByTimeout) = (_state.firstByTimeout, _state.lastByTimeout);\r\n        }\r\n\r\n        // set mutex bit in breaksCount to same value as in prevBlockBreakHash\r\n        if (Liquifi.checkFlag(_state, Liquifi.Flag.MUTEX)) {\r\n            _state.breaksCount |= uint64(1);\r\n        } else {\r\n            _state.breaksCount &= ~uint64(1);\r\n        }\r\n\r\n        // last word of state is always saved\r\n        (savedState.lastBalanceUpdateTime, savedState.nextBreakTime, savedState.maxHistory, savedState.ordersToClaimCount, savedState.breaksCount) \r\n            = (_state.lastBalanceUpdateTime, _state.nextBreakTime, _state.maxHistory, _state.ordersToClaimCount, _state.breaksCount);\r\n    }\r\n\r\n    function actualizeBalances(Liquifi.ErrorArg location) internal override(LiquifiLiquidityPool) returns (\r\n        Liquifi.PoolBalances memory _balances, Liquifi.PoolState memory _state, uint availableBalanceA, uint availableBalanceB\r\n    ) {\r\n        (_balances, _state) = enter(location);\r\n        Liquifi.OrderClaim memory claim;\r\n        processBreaks(_balances, _state, claim);\r\n        (availableBalanceA, availableBalanceB) = updateBalanceLocked(poolTime(_state), _balances, _state);\r\n\r\n        Liquifi.ErrorArg invalidState = Liquifi.checkInvalidState(_state);\r\n        if (invalidState != Liquifi.ErrorArg.A_NONE) {\r\n            emit OperatingInInvalidState(uint(location), uint(invalidState));\r\n        }\r\n    }\r\n\r\n    function computeBreakHash(bytes32 previousBreakHash, uint[] calldata breaks, uint index) private pure returns (bytes32 breakHash) {\r\n        index = index * 3;\r\n        return keccak256(abi.encodePacked(\r\n            previousBreakHash,\r\n            uint(breaks[index + 0]), uint(breaks[index + 1]), uint(breaks[index + 2])\r\n        ));\r\n    } \r\n\r\n    function extractBreakTime(uint others) private pure returns (uint) { \r\n        return uint64(others >> 144);\r\n    }\r\n    function getBreakTime(uint[] calldata breaks, uint i) private pure returns (uint) { \r\n        return extractBreakTime(breaks[i * 3 + 2]);\r\n    }\r\n    function getBreakOrderId(uint[] calldata breaks, uint i) private pure returns (uint) { \r\n        return uint64(breaks[i * 3 + 2] >> 80); \r\n    }\r\n    function getBreakReason(uint[] calldata breaks, uint i) private pure returns (BreakReason) { \r\n        return BreakReason(uint8(breaks[i * 3 + 2]) & 15); \r\n    }\r\n    function getBreakFee(uint[] calldata breaks, uint i) private pure returns (uint notFee) { \r\n        return uint16(breaks[i * 3 + 2] >> 208); \r\n    }\r\n\r\n    function computeBreakRate(uint availableBalance, uint poolFlowSpeed, uint period, uint notFee) private pure returns (uint balance) {\r\n        return availableBalance + ((poolFlowSpeed * period) >> 32) * notFee / 1000;\r\n    }\r\n\r\n    function appendSegmentToClaim(\r\n        uint availableBalance, uint flowSpeed, uint others, uint notFee, Liquifi.OrderClaim memory claim    \r\n    ) private pure {\r\n        uint poolFlowSpeedA = uint144(claim.previousFlowSpeed >> 112);\r\n        uint poolFlowSpeedB = uint144(((claim.previousFlowSpeed << 144) >> 112) | (claim.previousOthers >> 224));\r\n        uint availableBalanceA = uint128(claim.previousAvailableBalance >> 128);\r\n        uint availableBalanceB = uint128(claim.previousAvailableBalance);\r\n        uint period = extractBreakTime(others) - extractBreakTime(claim.previousOthers);\r\n        claim.previousOthers = others;\r\n        claim.previousAvailableBalance = availableBalance;\r\n        claim.previousFlowSpeed = flowSpeed;\r\n\r\n        uint rateNumerator = computeBreakRate(availableBalanceA, poolFlowSpeedA, period, notFee); // = x0 + Sa' * t * gamma\r\n        uint rateDenominator = computeBreakRate(availableBalanceB, poolFlowSpeedB, period, notFee); // = y0 + Sb' * t * gamma\r\n        \r\n        if (rateNumerator != 0 && rateDenominator != 0) {\r\n            uint tmp = (claim.orderFlowSpeed * period) >> 32; //= Sai' * t or = Sbi' * t\r\n            tmp = tmp * notFee / 1000; // = (Sai' * t ) * gamma or = (Sbi' * t) * gamma\r\n            tmp = Liquifi.isTokenAIn(claim.flags)\r\n                ? tmp * rateDenominator / rateNumerator // = (Sai' * t ) * gamma * P\r\n                : tmp * rateNumerator / rateDenominator; // = (Sbi' * t) * gamma * P\r\n            claim.amountOut += tmp;\r\n        }\r\n    }\r\n\r\n    function processBreaks(\r\n        Liquifi.PoolBalances memory _balances, Liquifi.PoolState memory _state, Liquifi.OrderClaim memory claim\r\n    ) private {\r\n        if(_state.nextBreakTime > poolTime(_state)) { // also guarantees that there are some orders\r\n            return;\r\n        }\r\n\r\n        Liquifi.Order storage order;\r\n        uint64 _breakTime = _state.nextBreakTime;\r\n        while (_breakTime <= poolTime(_state) && claim.closeReason == 0) {\r\n            {\r\n                (uint availableBalanceA, uint availableBalanceB) = updateBalanceLocked(_breakTime, _balances, _state);\r\n                // below this line [rate] = x0/y0 = availableBalanceA/availableBalanceB because t = [period since last update] = 0.\r\n                order = orders[_state.firstByTimeout];\r\n                if (order.timeout <= _breakTime) {\r\n                    _closeOrder(_state.firstByTimeout, order, BreakReason.ORDER_CLOSED, _breakTime, _balances, _state, claim);\r\n                } else {\r\n                    order = orders[_state.firstByTokenAStopLoss];\r\n                    if (_state.firstByTokenAStopLoss != 0 && availableBalanceB > 0 &&\r\n                        (order.amountIn * _state.notFee / 1000) * availableBalanceB\r\n                            <= availableBalanceA * order.stopLossAmount) {\r\n                        _closeOrder(_state.firstByTokenAStopLoss, order, BreakReason.ORDER_CLOSED_BY_STOP_LOSS, \r\n                            _breakTime, _balances, _state, claim); \r\n                    } else {\r\n                        order = orders[_state.firstByTokenBStopLoss];\r\n                        if (_state.firstByTokenBStopLoss != 0 && availableBalanceA > 0 &&\r\n                            (order.amountIn * _state.notFee / 1000) * availableBalanceA\r\n                                <= availableBalanceB * order.stopLossAmount) {\r\n                            _closeOrder(_state.firstByTokenBStopLoss, order, BreakReason.ORDER_CLOSED_BY_STOP_LOSS, \r\n                                _breakTime, _balances, _state, claim);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            //update nextBreakTime\r\n            _breakTime = _state.firstByTimeout == 0 ? Liquifi.maxTime : orders[_state.firstByTimeout].timeout;\r\n            \r\n            if (_state.firstByTokenAStopLoss != 0) {\r\n                order = orders[_state.firstByTokenAStopLoss];\r\n                uint tokenAStopLoss = computeStopLossTimeout((order.amountIn * _state.notFee / 1000), order.stopLossAmount, _balances, _state);\r\n                if (tokenAStopLoss < _breakTime) {\r\n                    _breakTime = uint64(tokenAStopLoss);\r\n                }\r\n            }\r\n\r\n            if (_state.firstByTokenBStopLoss != 0) {\r\n                order = orders[_state.firstByTokenBStopLoss];\r\n                uint tokenBStopLoss = computeStopLossTimeout(order.stopLossAmount, (order.amountIn * _state.notFee / 1000), _balances, _state);\r\n                if (tokenBStopLoss < _breakTime) {\r\n                    _breakTime = uint64(tokenBStopLoss);\r\n                }\r\n            }\r\n\r\n            _state.nextBreakTime = _breakTime;\r\n        }\r\n    }\r\n\r\n    function computeStopLossTimeout(\r\n        uint stopLossRateNumerator, // guaranteed to !=0\r\n        uint stopLossRateDenominator, // guaranteed to !=0\r\n        Liquifi.PoolBalances memory _balances, Liquifi.PoolState memory _state\r\n    ) private pure returns (uint timeout) {\r\n        // P = (gamma * Sa' * t + x0) / (gamma * Sb' * t + y0)   =>\r\n        // => t = (x0 - y0 * P) / ((Sb' * P - Sa') * gamma)\r\n        uint availableBalanceA = Math.subWithClip(_balances.totalBalanceA, _balances.balanceALocked);\r\n        uint availableBalanceB = Math.subWithClip(_balances.totalBalanceB, _balances.balanceBLocked);\r\n\r\n        int numerator = int(availableBalanceA) - int(availableBalanceB * stopLossRateNumerator / stopLossRateDenominator); // = x0 - y0 * P\r\n        int denominator = (int((uint(_balances.poolFlowSpeedB) * stopLossRateNumerator / stopLossRateDenominator) >> 32 ) - int(_balances.poolFlowSpeedA >> 32)) * _state.notFee / 1000; // (Sb' * P - Sa') * gamma\r\n\r\n        int period = denominator != 0 ? numerator / denominator : Liquifi.maxTime;\r\n        return period >= 0 && period + _state.nextBreakTime + 1 <= Liquifi.maxTime \r\n                    ? uint(period + _state.nextBreakTime + 1) // add one second to tolerate precision losses \r\n                    : Liquifi.maxTime;\r\n    }\r\n\r\n    function computeAvailableBalance(\r\n        uint effectiveTime, \r\n        Liquifi.PoolBalances memory _balances, Liquifi.PoolState memory _state\r\n    ) private pure returns (uint availableBalanceA, uint availableBalanceB) {\r\n        if (_balances.totalBalanceA < _balances.balanceALocked || _balances.totalBalanceB < _balances.balanceBLocked) {\r\n            Liquifi.setInvalidState(_state, Liquifi.ErrorArg.V_INSUFFICIENT_TOTAL_BALANCE);\r\n        }\r\n        uint oldAvailableBalanceA = Math.subWithClip(_balances.totalBalanceA, _balances.balanceALocked); // = x0\r\n        uint oldAvailableBalanceB = Math.subWithClip(_balances.totalBalanceB, _balances.balanceBLocked); // = y0\r\n        Liquifi._require(effectiveTime <= _state.nextBreakTime, Liquifi.Error.H_BALANCE_AFTER_BREAK, Liquifi.ErrorArg.G_IN_COMPUTE_AVAILABLE_BALANCE);\r\n        Liquifi._require(effectiveTime >= _state.lastBalanceUpdateTime, Liquifi.Error.I_BALANCE_OF_SAVED_UPD, Liquifi.ErrorArg.G_IN_COMPUTE_AVAILABLE_BALANCE);\r\n        uint period = effectiveTime - _state.lastBalanceUpdateTime;\r\n        if (period == 0) {\r\n            return (oldAvailableBalanceA, oldAvailableBalanceB);\r\n        }\r\n        \r\n        uint amountInA = _balances.poolFlowSpeedA * period; // = Sa' * t (premultiplied to 2^32)\r\n        uint amountInB = _balances.poolFlowSpeedB * period; // = Sb' * t (premultiplied to 2^32)\r\n\r\n        uint amountInAAdjusted = (amountInA * _state.notFee / 1000) >> 32; // = gamma * Sa' * t\r\n        uint amountInBAdjusted = (amountInB * _state.notFee / 1000) >> 32; // = gamma * Sb' * t\r\n\r\n        uint balanceIncreasedA = oldAvailableBalanceA.add(amountInAAdjusted); // = x0 + gamma * Sa' * t\r\n        uint balanceIncreasedB = oldAvailableBalanceB.add(amountInBAdjusted); // = y0 + gamma * Sb' * t\r\n\r\n        availableBalanceA = balanceIncreasedB == 0 ? oldAvailableBalanceA : Liquifi.trimTotal(\r\n            balanceIncreasedA.subWithClip(amountInBAdjusted.mul(balanceIncreasedA) / balanceIncreasedB),\r\n            Liquifi.ErrorArg.O_TOKEN_A); // = x0 + gamma * Sa' * t - gamma * Sb' * t * P\r\n        availableBalanceB = balanceIncreasedA == 0 ? oldAvailableBalanceB : Liquifi.trimTotal(\r\n            balanceIncreasedB.subWithClip(amountInAAdjusted.mul(balanceIncreasedB) / balanceIncreasedA),\r\n            Liquifi.ErrorArg.P_TOKEN_B\r\n        ); // = y0 + gamma * Sb' * t - gamma * Sa' * t / P\r\n        \r\n        // Constant product check: \r\n        // (x0 + gamma * Sa' * t - gamma * Sb' * t * P)*(y0 + gamma * Sb' * t - gamma * Sa' * t / P) >= x0 * y0\r\n        if (availableBalanceA.mul(availableBalanceB) < oldAvailableBalanceA.mul(oldAvailableBalanceB)) {\r\n            Liquifi.setInvalidState(_state, Liquifi.ErrorArg.U_BAD_EXCHANGE_RATE);\r\n        }\r\n        \r\n        // And some additional check\r\n        if (_balances.totalBalanceA < availableBalanceA || _balances.totalBalanceB < availableBalanceB) {\r\n            Liquifi.setInvalidState(_state, Liquifi.ErrorArg.V_INSUFFICIENT_TOTAL_BALANCE);\r\n        }\r\n    }\r\n\r\n    function changedBalances(BreakReason reason, Liquifi.PoolBalances memory _balances, Liquifi.PoolState memory _state, uint orderId) internal override(LiquifiLiquidityPool) {\r\n        Liquifi.OrderClaim memory claim; \r\n        flowBroken(\r\n            _balances,\r\n            _state,\r\n            poolTime(_state),\r\n            orderId,\r\n            reason,\r\n            claim\r\n        );\r\n        exit(_balances, _state);\r\n    }\r\n    \r\n    function updateBalanceLocked(\r\n        uint effectiveTime, Liquifi.PoolBalances memory _balances, Liquifi.PoolState memory _state\r\n    ) private pure returns (uint availableBalanceA, uint availableBalanceB) {\r\n        (availableBalanceA, availableBalanceB) = computeAvailableBalance(effectiveTime, _balances, _state);\r\n        if (effectiveTime == _state.lastBalanceUpdateTime) {\r\n            return (availableBalanceA, availableBalanceB);\r\n        }  \r\n\r\n        if (!Liquifi.checkFlag(_state, Liquifi.Flag.ARBITRAGEUR_FULL_FEE)) {\r\n            uint period = effectiveTime - _state.lastBalanceUpdateTime;\r\n            (uint delayedSwapsIncomeA, uint delayedSwapsIncomeB) = splitDelayedSwapsIncome(_balances.delayedSwapsIncome);\r\n            _balances.delayedSwapsIncome = \r\n                uint(Liquifi.trimTotal(delayedSwapsIncomeA + ((_balances.poolFlowSpeedA * period) >> 32), Liquifi.ErrorArg.O_TOKEN_A)) << 128 |\r\n                uint(Liquifi.trimTotal(delayedSwapsIncomeB + ((_balances.poolFlowSpeedB * period) >> 32), Liquifi.ErrorArg.P_TOKEN_B));\r\n            Liquifi.setFlag(_state, Liquifi.Flag.SWAPS_INCOME_DIRTY);\r\n        }\r\n\r\n        _balances.balanceALocked = Liquifi.trimAmount(Math.subWithClip(_balances.totalBalanceA, availableBalanceA), Liquifi.ErrorArg.O_TOKEN_A);\r\n        _balances.balanceBLocked = Liquifi.trimAmount(Math.subWithClip(_balances.totalBalanceB, availableBalanceB), Liquifi.ErrorArg.P_TOKEN_B);\r\n\r\n        Liquifi.setFlag(_state, Liquifi.Flag.BALANCE_A_DIRTY);\r\n        Liquifi.setFlag(_state, Liquifi.Flag.BALANCE_B_DIRTY);\r\n        _state.lastBalanceUpdateTime = uint64(effectiveTime);\r\n    }\r\n\r\n    function flowBroken(\r\n        // params ordered to reduce stack depth\r\n        Liquifi.PoolBalances memory _balances, Liquifi.PoolState memory _state,\r\n        uint time, uint orderId, BreakReason reason, Liquifi.OrderClaim memory claim\r\n    ) private returns (bytes32 _lastBreakHash) {\r\n        {\r\n            uint availableBalance;\r\n            {               \r\n                (uint availableBalanceA, uint availableBalanceB) = computeAvailableBalance(time, _balances, _state);\r\n                availableBalance = (availableBalanceA << 128) | availableBalanceB;\r\n            }\r\n\r\n            {\r\n                uint256 others = \r\n                    (uint(_balances.poolFlowSpeedB) << 224) |\r\n                    (uint(_state.notFee) << 208) | \r\n                    (uint(time) << 144) | \r\n                    (uint(orderId) << 80) | \r\n                    (uint(_state.packed >> 20) << 4) |\r\n                    uint(reason);\r\n                uint256 _totalBalance = (uint(_balances.totalBalanceA) << 128) | uint(_balances.totalBalanceB);\r\n                uint flowSpeed = (uint(_balances.poolFlowSpeedA) << 112) | (_balances.poolFlowSpeedB >> 32);\r\n\r\n                emit FlowBreakEvent(\r\n                    msg.sender, _totalBalance, _balances.rootKLastTotalSupply, orderId,\r\n                    // breakHash is computed over all fields below\r\n                    _state.lastBreakHash,\r\n                    availableBalance, flowSpeed, others   \r\n                );\r\n\r\n                Liquifi.setFlag(_state, Liquifi.Flag.HASH_DIRTY);\r\n                _state.lastBreakHash = _lastBreakHash = keccak256(abi.encodePacked(\r\n                        _state.lastBreakHash, availableBalance, flowSpeed, others\r\n                ));\r\n\r\n                _state.nextBreakTime = (_balances.poolFlowSpeedA | _balances.poolFlowSpeedB == 0) ? Liquifi.maxTime : uint64(time);\r\n                _state.breaksCount += 2; // not likely to have overflow here, but it is ok\r\n            \r\n                if (claim.orderId != 0 && claim.closeReason == 0) {\r\n                    if (claim.orderId == orderId && (uint(reason) & uint(BreakReason.ORDER_CLOSED) != 0)) {\r\n                        claim.closeReason = uint(reason);\r\n                    }\r\n                    appendSegmentToClaim(\r\n                        availableBalance, \r\n                        flowSpeed,\r\n                        others, \r\n                        _state.notFee, \r\n                        claim);\r\n                }\r\n            }\r\n\r\n            if (aIsWETH) {\r\n                activityMeter.liquidityEthPriceChanged(time, uint128(availableBalance >> 128), uint128(_balances.rootKLastTotalSupply));\r\n            }\r\n        }\r\n        // prevent order breaks history growth over maxHistory\r\n        (,,,,uint desiredMaxHistory) = Liquifi.unpackGovernance(_state);\r\n        if (_state.maxHistory < desiredMaxHistory) {\r\n            _state.maxHistory = uint16(desiredMaxHistory);\r\n        }\r\n\r\n        while(reason != BreakReason.ORDER_CLOSED_BY_HISTORY_LIMIT) {\r\n            uint closingId = (_state.breaksCount & ~uint64(1)) - (_state.maxHistory * 2); // valid id is always even;\r\n            \r\n            Liquifi.Order storage order = orders[closingId];\r\n\r\n            if (orderId != closingId && // we're not changing this order right now\r\n                order.period != 0  // check order existance by required field 'period'\r\n                && order.prevByStopLoss & 1 == 0 // check that order is not closed: closed order has invalid id (odd) in prevByStopLoss\r\n            ) {\r\n                _closeOrder(closingId, order, BreakReason.ORDER_CLOSED_BY_HISTORY_LIMIT, time, _balances, _state, claim);\r\n                 _state.breaksCount -= 2; // don't count breaks produced by closing orders by history\r\n                break;\r\n            } \r\n\r\n            if (desiredMaxHistory == 0 || _state.maxHistory == desiredMaxHistory) {\r\n                break;\r\n            }\r\n            \r\n            _state.maxHistory--; // _state.maxHistory > desiredMaxHistory. Reduce it by one and try to close one more order\r\n            desiredMaxHistory = 0;\r\n        }\r\n    }\r\n\r\n    function closeOrder(uint id) external override {\r\n        (Liquifi.PoolBalances memory _balances, Liquifi.PoolState memory _state, ,) = actualizeBalances(Liquifi.ErrorArg.R_IN_CLOSE_ORDER);\r\n\r\n        Liquifi.Order memory order = orders[id];\r\n        // check order existance by required field 'period'\r\n        Liquifi._require(order.period > 0, Liquifi.Error.V_ORDER_NOT_EXIST, Liquifi.ErrorArg.R_IN_CLOSE_ORDER);\r\n        \r\n        BreakReason reason = BreakReason.ORDER_CLOSED_BY_REQUEST;\r\n        if (msg.sender != order.owner) {\r\n            (address governor, ) = governanceRouter.governance();\r\n            Liquifi._require(msg.sender == governor, Liquifi.Error.Y_UNAUTHORIZED_SENDER, Liquifi.ErrorArg.R_IN_CLOSE_ORDER);\r\n            reason = BreakReason.ORDER_CLOSED_BY_GOVERNOR;\r\n        }\r\n\r\n        // check that order is open: closed order has invalid id (odd) in prevByStopLoss\r\n        Liquifi._require(order.prevByStopLoss & 1 == 0, Liquifi.Error.X_ORDER_ALREADY_CLOSED, Liquifi.ErrorArg.R_IN_CLOSE_ORDER);\r\n        Liquifi.OrderClaim memory claim; \r\n       \r\n        _closeOrder(id, order, reason, poolTime(_state), _balances, _state, claim);\r\n\r\n        exit(_balances, _state);\r\n    }\r\n\r\n    function _closeOrder(uint id, Liquifi.Order memory order, BreakReason reason, uint effectiveTime, \r\n        Liquifi.PoolBalances memory _balances, Liquifi.PoolState memory _state, Liquifi.OrderClaim memory claim\r\n    ) private {\r\n        deleteOrderFromQueue(order, _state);\r\n        {\r\n            uint orderFlowSpeed = (uint(order.amountIn) << 32) / order.period; // multiply to 2^32 to keep precision\r\n            uint effectivePeriod = uint(effectiveTime).subWithClip(order.timeout - order.period);\r\n            uint orderIncome = orderFlowSpeed.mul(effectivePeriod);\r\n            uint orderFee = (orderIncome >> 32).mul(1000 - _state.notFee) / 1000; \r\n\r\n            if (Liquifi.isTokenAIn(order.flags)) {\r\n                Liquifi.setFlag(_state, Liquifi.Flag.BALANCE_A_DIRTY);\r\n                _balances.balanceALocked = uint112(Math.subWithClip(_balances.balanceALocked, orderFee)); \r\n                _balances.poolFlowSpeedA = uint144(Math.subWithClip(_balances.poolFlowSpeedA, orderFlowSpeed));\r\n                subDelayedSwapsIncome(_balances, _state, orderIncome, 0);\r\n            } else {\r\n                Liquifi.setFlag(_state, Liquifi.Flag.BALANCE_B_DIRTY);\r\n                \r\n                _balances.balanceBLocked = uint112(Math.subWithClip(_balances.balanceBLocked, orderFee)); \r\n                _balances.poolFlowSpeedB = uint144(Math.subWithClip(_balances.poolFlowSpeedB, orderFlowSpeed));\r\n                subDelayedSwapsIncome(_balances, _state, 0, orderIncome);\r\n            }\r\n        }\r\n\r\n        bytes32 _lastBreakHash = flowBroken(\r\n            _balances,\r\n            _state,\r\n            effectiveTime,\r\n            id,\r\n            reason,\r\n            claim    \r\n        );\r\n\r\n        Liquifi.Order storage storedOrder = orders[id];  \r\n        // save gas by re-using existing fields\r\n        // set highest bit to 1 in nextByTimeout to mark order as closed\r\n        storedOrder.nextByTimeout = uint64(uint(_lastBreakHash) >> 192);\r\n        storedOrder.prevByTimeout = uint64(uint(_lastBreakHash) >> 128);\r\n        storedOrder.nextByStopLoss = uint64(uint(_lastBreakHash) >> 64);\r\n        storedOrder.prevByStopLoss = uint64(uint(_lastBreakHash) | 1);\r\n\r\n        _state.ordersToClaimCount += 1; \r\n    }\r\n\r\n    function deleteOrderFromQueue(Liquifi.Order memory order, Liquifi.PoolState memory _state) private {\r\n        bool isTokenA = Liquifi.isTokenAIn(order.flags);\r\n        if (order.prevByTimeout == 0) {\r\n            Liquifi.setFlag(_state, Liquifi.Flag.QUEUE_TIMEOUT_DIRTY);\r\n            _state.firstByTimeout = order.nextByTimeout;\r\n        } else {\r\n            orders[order.prevByTimeout].nextByTimeout = order.nextByTimeout;\r\n        }\r\n\r\n        if (order.nextByTimeout == 0) {\r\n            Liquifi.setFlag(_state, Liquifi.Flag.QUEUE_TIMEOUT_DIRTY);\r\n            _state.lastByTimeout = order.prevByTimeout;\r\n        } else {\r\n            orders[order.nextByTimeout].prevByTimeout = order.prevByTimeout;\r\n        }\r\n\r\n\r\n        if (order.prevByStopLoss == 0) {\r\n            Liquifi.setFlag(_state, Liquifi.Flag.QUEUE_STOPLOSS_DIRTY);\r\n            if (isTokenA) {\r\n                _state.firstByTokenAStopLoss = order.nextByStopLoss;\r\n            } else {\r\n                _state.firstByTokenBStopLoss = order.nextByStopLoss;\r\n            }\r\n        } else {\r\n            orders[order.prevByStopLoss].nextByStopLoss = order.nextByStopLoss;\r\n        }\r\n\r\n        if (order.nextByStopLoss == 0) {\r\n            Liquifi.setFlag(_state, Liquifi.Flag.QUEUE_STOPLOSS_DIRTY);\r\n            if (isTokenA) {\r\n                _state.lastByTokenAStopLoss = order.prevByStopLoss;\r\n            } else {\r\n                _state.lastByTokenBStopLoss = order.prevByStopLoss;\r\n            }\r\n        } else {\r\n            orders[order.nextByStopLoss].prevByStopLoss = order.prevByStopLoss;\r\n        }\r\n    }\r\n\r\n    function saveOrder(Liquifi.PoolState memory _state,\r\n        uint period, uint prevByTimeout, uint prevByStopLoss, \r\n        uint amountIn, uint stopLossAmount, bool isTokenA\r\n    ) private returns (uint64 id) {\r\n        uint timeout = Liquifi.trimTime(poolTime(_state) + period);\r\n        id = 2 + _state.breaksCount & ~uint64(1); // valid id is always even\r\n\r\n        uint nextByTimeout;\r\n        (prevByTimeout, nextByTimeout) = ensureTimeoutSort(_state, timeout, prevByTimeout);\r\n        uint nextByStopLoss;\r\n        (prevByStopLoss, nextByStopLoss) = ensureStopLossSort(_state, stopLossAmount, amountIn, isTokenA, prevByStopLoss);\r\n\r\n        Liquifi.Order storage order = orders[id];\r\n        (order.nextByTimeout, order.prevByTimeout, order.nextByStopLoss, order.prevByStopLoss) =\r\n            (uint64(nextByTimeout), uint64(prevByTimeout), uint64(nextByStopLoss), uint64(prevByStopLoss));\r\n        \r\n        if (prevByTimeout == 0) {\r\n            Liquifi.setFlag(_state, Liquifi.Flag.QUEUE_TIMEOUT_DIRTY);\r\n            _state.firstByTimeout = id;\r\n        } else {\r\n            orders[prevByTimeout].nextByTimeout = id;\r\n        }\r\n\r\n        if (nextByTimeout == 0) {\r\n            Liquifi.setFlag(_state, Liquifi.Flag.QUEUE_TIMEOUT_DIRTY);\r\n            _state.lastByTimeout = id;\r\n        } else {\r\n            orders[nextByTimeout].prevByTimeout = id;\r\n        }\r\n\r\n        if (prevByStopLoss == 0) {   \r\n            Liquifi.setFlag(_state, Liquifi.Flag.QUEUE_STOPLOSS_DIRTY);\r\n            if (isTokenA) {\r\n                _state.firstByTokenAStopLoss = id;\r\n            } else {\r\n                _state.firstByTokenBStopLoss = id;\r\n            }\r\n        } else {\r\n            orders[prevByStopLoss].nextByStopLoss = id;\r\n        }\r\n\r\n        if (nextByStopLoss == 0) {   \r\n            Liquifi.setFlag(_state, Liquifi.Flag.QUEUE_STOPLOSS_DIRTY);\r\n            if (isTokenA) {\r\n                _state.lastByTokenAStopLoss = id;\r\n            } else {\r\n                _state.lastByTokenBStopLoss = id;\r\n            }\r\n        } else {\r\n            orders[nextByStopLoss].prevByStopLoss = id;\r\n        }\r\n    }\r\n\r\n    // find position in linked list sorted by timeouts ascending\r\n    function ensureTimeoutSort(Liquifi.PoolState memory _state, uint timeout, uint prevByTimeout) private view returns (uint _prevByTimeout, uint _nextByTimeout) {\r\n        _nextByTimeout = _state.firstByTimeout;\r\n        _prevByTimeout = prevByTimeout;\r\n\r\n        if (_prevByTimeout != 0) {\r\n            Liquifi.Order memory prevByTimeoutOrder = orders[_prevByTimeout];\r\n            if (prevByTimeoutOrder.period > 0 // check order existance by required field 'period'\r\n                && prevByTimeoutOrder.prevByStopLoss & 1 == 0 // check that order is not closed: closed order has invalid id (odd) in prevByStopLoss\r\n                ) {\r\n                _nextByTimeout = prevByTimeoutOrder.nextByTimeout;\r\n                uint prevTimeout = prevByTimeoutOrder.timeout;\r\n                \r\n                // iterate towards list start if needed\r\n                while (_prevByTimeout != 0) {\r\n                    if (prevTimeout <= timeout) {\r\n                        break;\r\n                    }\r\n\r\n                    _nextByTimeout = _prevByTimeout;\r\n                    _prevByTimeout = orders[_prevByTimeout].prevByTimeout;\r\n                    prevTimeout = orders[_prevByTimeout].timeout;\r\n                }               \r\n            } else {\r\n                // invalid prevByTimeout passed, start search from list head\r\n                _prevByTimeout = 0;\r\n            }            \r\n        }\r\n\r\n        // iterate towards list end if needed\r\n        while (_nextByTimeout != 0 && orders[_nextByTimeout].timeout < timeout) {\r\n            _prevByTimeout = _nextByTimeout;\r\n            _nextByTimeout = orders[_nextByTimeout].nextByTimeout;\r\n        }\r\n    }\r\n\r\n    // find position in linked list sorted by (amountIn/stopLossAmount) ascending\r\n    function ensureStopLossSort(Liquifi.PoolState memory _state, uint stopLossAmount, uint amountIn, bool isTokenA, uint prevByStopLoss) private view returns (uint _prevByStopLoss, uint _nextByStopLoss) {\r\n        _nextByStopLoss = isTokenA ? _state.firstByTokenAStopLoss : _state.firstByTokenBStopLoss;\r\n        _prevByStopLoss = prevByStopLoss;\r\n\r\n        if (_prevByStopLoss != 0) {\r\n            Liquifi.Order memory prevByStopLossOrder = orders[_prevByStopLoss];\r\n            if (prevByStopLossOrder.period > 0  // check order existance by required field 'period'\r\n                && prevByStopLossOrder.prevByStopLoss & 1 == 0 // check that order is not closed: closed order has invalid id (odd) in prevByStopLoss\r\n                && Liquifi.isTokenAIn(prevByStopLossOrder.flags) == isTokenA) {\r\n                _nextByStopLoss = prevByStopLossOrder.nextByStopLoss;\r\n\r\n                // iterate towards list start if needed\r\n                (uint prevStopLossAmount, uint prevAmountIn) = (prevByStopLossOrder.stopLossAmount, prevByStopLossOrder.amountIn);\r\n                while(_prevByStopLoss != 0) {\r\n                    if (prevAmountIn * stopLossAmount <= amountIn * prevStopLossAmount) {\r\n                        break;\r\n                    }\r\n\r\n                    _nextByStopLoss = _prevByStopLoss;\r\n                    _prevByStopLoss = orders[_prevByStopLoss].prevByStopLoss;\r\n                    \r\n                    (prevStopLossAmount, prevAmountIn) = \r\n                        (orders[_prevByStopLoss].stopLossAmount, orders[_prevByStopLoss].amountIn); // grouped read\r\n                }\r\n\r\n            } else {\r\n                // invalid prevByStopLoss passed, start search from list head\r\n                _prevByStopLoss = 0;\r\n            }            \r\n        }\r\n\r\n        // iterate towards list end if needed\r\n        while(_nextByStopLoss != 0) {            \r\n            (uint nextStopLossAmount, uint nextAmountIn) = \r\n                (orders[_nextByStopLoss].stopLossAmount, orders[_nextByStopLoss].amountIn); // grouped read\r\n\r\n            if (nextAmountIn * stopLossAmount >= amountIn * nextStopLossAmount) {\r\n                break;\r\n            }\r\n\r\n            _prevByStopLoss = _nextByStopLoss;\r\n            _nextByStopLoss = orders[_nextByStopLoss].nextByStopLoss;\r\n        }\r\n    }\r\n\r\n    // force reserves to match balances\r\n    function sync() external override {\r\n        (Liquifi.PoolBalances memory _balances, Liquifi.PoolState memory _state) = enter(Liquifi.ErrorArg.M_IN_CLAIM_ORDER);\r\n        Liquifi.setFlag(_state, Liquifi.Flag.TOTALS_DIRTY);\r\n        _balances.totalBalanceA = Liquifi.trimTotal(tokenA.balanceOf(address(this)), Liquifi.ErrorArg.O_TOKEN_A);\r\n        _balances.totalBalanceB = Liquifi.trimTotal(tokenB.balanceOf(address(this)), Liquifi.ErrorArg.P_TOKEN_B);\r\n        if (_state.firstByTimeout == 0 && _state.ordersToClaimCount == 0) {\r\n            _balances.balanceALocked = 0;\r\n            _balances.poolFlowSpeedA = 0;\r\n            _balances.balanceBLocked = 0;\r\n            _balances.poolFlowSpeedB = 0;\r\n            Liquifi.setFlag(_state, Liquifi.Flag.BALANCE_A_DIRTY);\r\n            Liquifi.setFlag(_state, Liquifi.Flag.BALANCE_B_DIRTY);\r\n        }\r\n        exit(_balances, _state);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenBAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_aIsWETH\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_governanceRouter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rootKLastTotalSupply\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"lastBreakHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"availableBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"flowSpeed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"others\",\"type\":\"uint256\"}],\"name\":\"FlowBreakEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"packedGovernance\",\"type\":\"uint256\"}],\"name\":\"GovernanceApplied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum LiquidityPool.MintReason\",\"name\":\"reason\",\"type\":\"uint8\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"location\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"invalidStateReason\",\"type\":\"uint256\"}],\"name\":\"OperatingInInvalidState\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OrderClaimedEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"aIsWETH\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"orderFlags\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prevByStopLoss\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prevByTimeout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stopLossAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"addOrder\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"packedGovernanceFields\",\"type\":\"uint256\"}],\"name\":\"applyGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"extractETH\",\"type\":\"bool\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"previousBreakHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[]\",\"name\":\"breaksHistory\",\"type\":\"uint256[]\"}],\"name\":\"claimOrder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountAOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"closeOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"findOrder\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nextByTimeout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prevByTimeout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextByStopLoss\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prevByStopLoss\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stopLossAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timeout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"flags\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governanceRouter\",\"outputs\":[{\"internalType\":\"contract GovernanceRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastBreakHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balanceALocked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolFlowSpeedA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balanceBLocked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolFlowSpeedB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBalanceA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBalanceB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delayedSwapsIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rootKLastTotalSupply\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolQueue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"firstByTokenAStopLoss\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastByTokenAStopLoss\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"firstByTokenBStopLoss\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastByTokenBStopLoss\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"firstByTimeout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastByTimeout\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolState\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"_prevBlockBreakHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"packed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"notFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastBalanceUpdateTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextBreakTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxHistory\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ordersToClaimCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"breaksCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"processDelayedOrders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"availableBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delayedSwapsIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"packed\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"extractETH\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amountAOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBOut\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"externalData\",\"type\":\"bytes\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountAIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBIn\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sync\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenA\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenB\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "LiquifiDelayedExchangePool", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c000000000000000000000000eee23f020e7e4d2d9392300d32eaabef3dd7b97c0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000e28820a80f12d0917ba63cabf33e893e49a83e570000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://db3977bdb84211d30f9cc5521e26e0cb58ad2676a93d516bb6d8c5c69f303ec8"}