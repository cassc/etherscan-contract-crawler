{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.1;\r\n\r\nlibrary AddressUpgradeable {\r\n    \r\n    function isContract(address account) internal view returns (bool) {\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                require(isContract(target), \"Address: call to non-contract\");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n        if (returndata.length > 0) {\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n}\r\n\r\npragma solidity ^0.8.2;\r\n\r\nabstract contract Initializable {\r\n   \r\n    uint8 private _initialized;\r\n\r\n    bool private _initializing;\r\n\r\n    event Initialized(uint8 version);\r\n\r\n    modifier initializer() {\r\n        bool isTopLevelCall = !_initializing;\r\n        require(\r\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\r\n            \"Initializable: contract is already initialized\"\r\n        );\r\n        _initialized = 1;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n        }\r\n        _;\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n            emit Initialized(1);\r\n        }\r\n    }\r\n\r\n    modifier reinitializer(uint8 version) {\r\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\r\n        _initialized = version;\r\n        _initializing = true;\r\n        _;\r\n        _initializing = false;\r\n        emit Initialized(version);\r\n    }\r\n\r\n    modifier onlyInitializing() {\r\n        require(_initializing, \"Initializable: contract is not initializing\");\r\n        _;\r\n    }\r\n\r\n    function _disableInitializers() internal virtual {\r\n        require(!_initializing, \"Initializable: contract is initializing\");\r\n        if (_initialized < type(uint8).max) {\r\n            _initialized = type(uint8).max;\r\n            emit Initialized(type(uint8).max);\r\n        }\r\n    }\r\n\r\n    function _getInitializedVersion() internal view returns (uint8) {\r\n        return _initialized;\r\n    }\r\n\r\n    function _isInitializing() internal view returns (bool) {\r\n        return _initializing;\r\n    }\r\n}\r\n\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract ContextUpgradeable is Initializable {\r\n    function __Context_init() internal onlyInitializing {\r\n    }\r\n\r\n    function __Context_init_unchained() internal onlyInitializing {\r\n    }\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n\r\n    uint256[50] private __gap;\r\n}\r\n\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    function __Ownable_init() internal onlyInitializing {\r\n        __Ownable_init_unchained();\r\n    }\r\n\r\n    function __Ownable_init_unchained() internal onlyInitializing {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n\r\n    uint256[49] private __gap;\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                require(isContract(target), \"Address: call to non-contract\");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n        if (returndata.length > 0) {\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\ninterface IBEP20 {\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function decimals() external view returns (uint8);\r\n\r\n  function symbol() external view returns (string memory);\r\n\r\n  function name() external view returns (string memory);\r\n\r\n  function getOwner() external view returns (address);\r\n\r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n  function allowance(address _owner, address spender)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) external returns (bool);\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\nlibrary SafeBEP20 {\r\n  using SafeMath for uint256;\r\n  using Address for address;\r\n\r\n  function safeTransfer(\r\n    IBEP20 token,\r\n    address to,\r\n    uint256 value\r\n  ) internal {\r\n    _callOptionalReturn(\r\n      token,\r\n      abi.encodeWithSelector(token.transfer.selector, to, value)\r\n    );\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    IBEP20 token,\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  ) internal {\r\n    _callOptionalReturn(\r\n      token,\r\n      abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\r\n    );\r\n  }\r\n\r\n  function safeApprove(\r\n    IBEP20 token,\r\n    address spender,\r\n    uint256 value\r\n  ) internal {\r\n    require(\r\n      (value == 0) || (token.allowance(address(this), spender) == 0),\r\n      \"SafeBEP20: approve from non-zero to non-zero allowance\"\r\n    );\r\n    _callOptionalReturn(\r\n      token,\r\n      abi.encodeWithSelector(token.approve.selector, spender, value)\r\n    );\r\n  }\r\n\r\n  function safeIncreaseAllowance(\r\n    IBEP20 token,\r\n    address spender,\r\n    uint256 value\r\n  ) internal {\r\n    uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n    _callOptionalReturn(\r\n      token,\r\n      abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\r\n    );\r\n  }\r\n\r\n  function safeDecreaseAllowance(\r\n    IBEP20 token,\r\n    address spender,\r\n    uint256 value\r\n  ) internal {\r\n    uint256 newAllowance =\r\n      token.allowance(address(this), spender).sub(\r\n        value,\r\n        \"SafeBEP20: decreased allowance below zero\"\r\n      );\r\n    _callOptionalReturn(\r\n      token,\r\n      abi.encodeWithSelector(token.approve.selector, spender, newAllowance)\r\n    );\r\n  }\r\n\r\n  function _callOptionalReturn(IBEP20 token, bytes memory data) private {\r\n    bytes memory returndata =\r\n      address(token).functionCall(data, \"SafeBEP20: low-level call failed\");\r\n    if (returndata.length > 0) {\r\n      require(\r\n        abi.decode(returndata, (bool)),\r\n        \"SafeBEP20: BEP20 operation did not succeed\"\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\ncontract IdoPro is OwnableUpgradeable {\r\n    using SafeMath for uint256;\r\n    using SafeBEP20 for IBEP20;\r\n\r\n    IBEP20 public mToken;\r\n\r\n    uint256 public supply;\r\n    uint256 public soldToken;\r\n    uint256 public invalidToken;\r\n    uint256 public startTime;\r\n    uint256 public endTime;\r\n    uint256 public priceDenominator;\r\n    uint256[] public genFees;\r\n    uint256 public feeDenominator;\r\n\r\n    mapping(address => mapping(uint256 => uint256)) public sales;\r\n    mapping(address => mapping(uint256 => uint256)) public periodTimes; \r\n    mapping(address => address) public inviters;\r\n    mapping(address => uint256) public teams; \r\n    mapping(address => uint256) public teamTokens; \r\n    mapping(address => address[]) public sharers;\r\n    mapping(uint256 => address[]) public periodUsers;\r\n    mapping(address => uint256) public claimeds;\r\n    mapping(address => uint256) public voids;\r\n    address[] public allUsers;  \r\n\r\n    bool public autoClaim;\r\n    bool public rewardMustBuy;\r\n    bool public whiteListFlag;\r\n    bool public forceBind;\r\n    bool public statisticsInviteFlag;\r\n    bool public statisticsBoughtFlag;\r\n    bool public voidFlag;\r\n    mapping(address => bool) public whiteLists;\r\n\r\n    uint256 public voidFee;\r\n\r\n    uint256 public period;\r\n\r\n    struct PayCoin {\r\n        address token;\r\n        uint256 price;\r\n        uint256 min;\r\n        uint256 max;\r\n        uint256 state;\r\n    }\r\n\r\n    PayCoin[] private _pCoins;\r\n\r\n    event BuyToken(address account, uint256 amount);\r\n\r\n    function initialize(\r\n        uint256 _supply,\r\n        uint256 _startTime,\r\n        uint256 _endTime,\r\n        address _mToken,\r\n        address[] memory _uTokens,\r\n        uint256[] memory _prices,\r\n        uint256[] memory _minAmounts,\r\n        uint256[] memory _maxAmounts,\r\n        uint256[] memory _flags,\r\n        uint256[] memory _genFees,\r\n        address service\r\n        ) external initializer payable {\r\n        __Ownable_init();\r\n\r\n        supply = _supply;\r\n        startTime = _startTime;\r\n        endTime = _endTime;\r\n\r\n        mToken = IBEP20(_mToken);\r\n        for(uint i=0; i<_uTokens.length; i++) {\r\n            _pCoins.push(PayCoin({\r\n                token: _uTokens[i],\r\n                price: _prices[i],\r\n                min: _minAmounts[i],\r\n                max: _maxAmounts[i],\r\n                state: 1\r\n            }));\r\n        }\r\n        if (_genFees.length > 0) genFees = _genFees;\r\n        priceDenominator = 10 ** 22;\r\n        feeDenominator = 1000;\r\n        autoClaim = _flags[0] > 0;\r\n        rewardMustBuy = _flags[1] > 0;\r\n        whiteListFlag = _flags[2] > 0;\r\n        forceBind = _flags[3] > 0;\r\n        statisticsInviteFlag = _flags[4] > 0;\r\n        statisticsBoughtFlag = _flags[5] > 0;\r\n        voidFlag = _flags[6] > 0;\r\n        period = 1;\r\n        inviters[msg.sender] = address(msg.sender);\r\n        whiteLists[msg.sender] = true;\r\n        payable(service).transfer(msg.value);\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function preSale(address inviter, uint256 id, uint256 amount) external payable {\r\n        if (whiteListFlag) {\r\n            require(whiteLists[msg.sender], \"In not white list\");\r\n        } else {\r\n            require(block.timestamp > startTime && block.timestamp < endTime, \"Is disable\");\r\n            if (forceBind) {\r\n                require(inviters[msg.sender] != address(0) || inviters[inviter] != address(0), \"Must be invited\");\r\n            }\r\n        }\r\n        require(sales[msg.sender][period] == 0, \"Is bought\");\r\n\r\n        PayCoin memory pCoin = _pCoins[id];\r\n        require(amount >= pCoin.min && amount <= pCoin.max, \"Amount is out of range\");\r\n        if (pCoin.token == address(0)) {\r\n            require(msg.value >= amount, \"ETH insufficient\");\r\n        }\r\n       \r\n        uint256 mTokenDecimals = uint256(mToken.decimals());\r\n        uint256 uTokenDecimals;\r\n        if (pCoin.token == address(0)) {\r\n            uTokenDecimals = 18;\r\n        }else {\r\n            uTokenDecimals = uint256(IBEP20(pCoin.token).decimals());\r\n        }\r\n        uint256 tokenNum;\r\n        uint256 factor;\r\n        if (mTokenDecimals > uTokenDecimals) {\r\n            factor = 10 ** (mTokenDecimals - uTokenDecimals);\r\n            tokenNum = amount.mul(factor).mul(priceDenominator).div(pCoin.price);    \r\n        }else {\r\n            factor = 10 ** (uTokenDecimals - mTokenDecimals);\r\n            tokenNum = amount.mul(priceDenominator).div(pCoin.price).div(factor);    \r\n        }\r\n        require(poolLeft() >= tokenNum, \"Insufficient pool\");\r\n\r\n        if (statisticsBoughtFlag){\r\n            periodUsers[period].push(msg.sender);\r\n            periodTimes[msg.sender][period] = block.timestamp;\r\n            if (userTotalSale(msg.sender) == 0) allUsers.push(msg.sender);\r\n        } \r\n        soldToken = soldToken.add(tokenNum);\r\n        sales[msg.sender][period] = tokenNum;\r\n        emit BuyToken(msg.sender, tokenNum);\r\n\r\n        uint256 leftAmount = _inviteFee(inviter, pCoin.token, address(msg.sender), amount, tokenNum);\r\n        if (pCoin.token != address(0)) {\r\n            IBEP20(pCoin.token).safeTransferFrom(address(msg.sender), address(this), leftAmount);\r\n        }\r\n        if (withdrawable()) {\r\n            mToken.safeTransfer(address(msg.sender), tokenNum);\r\n            claimeds[msg.sender] = claimeds[msg.sender].add(tokenNum);\r\n        }\r\n    }\r\n\r\n    function _inviteFee(address sharer, address uToken, address from, uint256 amount, uint256 tokenNum) internal returns(uint256) {\r\n        if (genFees.length == 0) return amount;\r\n        uint256 reward;\r\n        uint256 leftAmount = amount;\r\n        bool isInviteFlag;\r\n        if (inviters[from] == address(0)) {\r\n            if (sharer == address(0)){\r\n                inviters[from] = from;\r\n            } else {\r\n                inviters[from] = sharer;\r\n                isInviteFlag = true;\r\n            } \r\n        }\r\n        address inviter;\r\n        address invitee = from;\r\n        for (uint i=0; i<genFees.length; i++) {\r\n            inviter = inviters[invitee];\r\n            if (inviter == address(0) || inviter == invitee){\r\n                return leftAmount;\r\n            }\r\n            if (statisticsInviteFlag) {\r\n                teamTokens[inviter] = teamTokens[inviter].add(tokenNum);\r\n                if (isInviteFlag) {\r\n                    teams[inviter] = teams[inviter].add(1);\r\n                    if (i==0) sharers[inviter].push(invitee);\r\n                } \r\n            }\r\n            if (rewardMustBuy && userTotalSale(inviter) == 0) {\r\n                invitee = inviter;\r\n                continue;\r\n            }\r\n            reward = amount.mul(genFees[i]).div(feeDenominator);\r\n            if (uToken == address(0)) {\r\n                payable(inviter).transfer(reward);\r\n            }else {\r\n                IBEP20(uToken).safeTransferFrom(from, inviter, reward);\r\n            }\r\n            leftAmount = leftAmount.sub(reward);\r\n            invitee = inviter;\r\n        }\r\n        return leftAmount;\r\n    }\r\n\r\n    function voidSale(uint256 id, uint256 tokenNum) external payable {\r\n        uint256 totalSale = userTotalSale(msg.sender);\r\n        voids[msg.sender] = voids[msg.sender].add(tokenNum);\r\n        require(totalSale >= voids[msg.sender], \"Amount insufficient\");\r\n        require(voidFlag, \"No revocation allowed\");\r\n        uint256 mTokenDecimals = uint256(mToken.decimals());\r\n        uint256 uTokenDecimals;\r\n        PayCoin memory pCoin = _pCoins[id];\r\n        if (pCoin.token == address(0)) {\r\n            uTokenDecimals = 18;\r\n        }else {\r\n            uTokenDecimals = uint256(IBEP20(pCoin.token).decimals());\r\n        }\r\n        uint256 amount;\r\n        uint256 factor;\r\n        if (mTokenDecimals > uTokenDecimals) {\r\n            factor = 10 ** (mTokenDecimals - uTokenDecimals);\r\n            amount = tokenNum.mul(pCoin.price).div(priceDenominator).div(factor);    \r\n        }else {\r\n            factor = 10 ** (uTokenDecimals - mTokenDecimals);\r\n            amount = tokenNum.mul(factor).mul(pCoin.price).div(priceDenominator);    \r\n        }\r\n        if (voidFee > 0) {\r\n            uint256 amountFee = amount.mul(voidFee).div(feeDenominator);\r\n            amount = amount.sub(amountFee);\r\n        }\r\n        if (pCoin.token == address(0)) {\r\n            payable(address(msg.sender)).transfer(amount);\r\n        }else {\r\n            IBEP20(pCoin.token).safeTransfer(address(msg.sender), amount);\r\n        }\r\n        mToken.safeTransferFrom(address(msg.sender), address(this), tokenNum);\r\n        // soldToken = soldToken.sub(tokenNum);\r\n        if (statisticsInviteFlag) {\r\n            address inviter;\r\n            address invitee = address(msg.sender);\r\n            for (uint i=0; i<genFees.length; i++) {\r\n                inviter = inviters[invitee];\r\n                if (inviter == address(0) || inviter == invitee) break;\r\n                if (teamTokens[inviter] >= tokenNum) {\r\n                    teamTokens[inviter] = teamTokens[inviter].sub(tokenNum);\r\n                } \r\n                invitee = inviter;\r\n            }\r\n        }  \r\n    }\r\n\r\n    function withdrawFunds(address tokenAddr, address to, uint256 amount) external onlyOwner {\r\n        if (tokenAddr == address(0)) {\r\n            payable(to).transfer(amount);\r\n        }else {\r\n            IBEP20(tokenAddr).safeTransfer(to, amount);\r\n            if (tokenAddr == address(this)) {\r\n                invalidToken = invalidToken.add(amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function withdrawToken() external {\r\n        uint256 totalSale = userTotalSale(msg.sender);\r\n        require(totalSale > claimeds[msg.sender], \"Amount to withdraw too high\");\r\n        require(withdrawable(), \"Cannot take\");\r\n        mToken.safeTransfer(address(msg.sender), totalSale.sub(claimeds[msg.sender]));\r\n        claimeds[msg.sender] = totalSale;\r\n    }\r\n\r\n    function withdrawable() public view returns(bool) {\r\n        return autoClaim || block.timestamp >= endTime;\r\n    }\r\n\r\n    function bindAccount(address account) external {\r\n        require(inviters[msg.sender] == address(0));\r\n        require(inviters[account] != address(0));\r\n        inviters[msg.sender] = account;\r\n        if (genFees.length > 0 && statisticsInviteFlag) {\r\n            teams[account] = teams[account].add(1);     \r\n            sharers[account].push(msg.sender);\r\n            _invite(account, genFees.length - 1);\r\n        }\r\n    }\r\n\r\n    function _invite(address account, uint256 n) internal {\r\n        if (n == 0){\r\n            return;\r\n        }\r\n        n--;\r\n        address preInviter = inviters[account];\r\n        if (preInviter == address(0) || preInviter == account){\r\n            return;\r\n        }\r\n        teams[preInviter] = teams[preInviter].add(1);\r\n        _invite(preInviter,n);\r\n    }\r\n\r\n    function getInviter(address account) external view returns (address) {\r\n        return inviters[account];\r\n    }\r\n\r\n    function setSupply(uint256 value) external onlyOwner {\r\n       supply = value;\r\n    }\r\n\r\n    function setAutoClaim(bool flag) external onlyOwner {\r\n       autoClaim = flag;\r\n    }\r\n\r\n    function setRewardMustBuy(bool flag) external onlyOwner {\r\n       rewardMustBuy = flag;\r\n    }\r\n\r\n    function setForceBind(bool flag) external onlyOwner {\r\n       forceBind = flag;\r\n    }\r\n\r\n    function setStatisticsInviteFlag(bool flag) external onlyOwner {\r\n       statisticsInviteFlag = flag;\r\n    }\r\n\r\n    function setStatisticsBoughtFlag(bool flag) external onlyOwner {\r\n       statisticsBoughtFlag = flag;\r\n    }\r\n\r\n    function setVoidFlag(bool flag) external onlyOwner {\r\n       voidFlag = flag;\r\n    }\r\n\r\n    function setVoidFee(uint256 value) external onlyOwner {\r\n       voidFee = value;\r\n    }\r\n\r\n    function setWhiteListFlag(bool flag) external onlyOwner {\r\n       whiteListFlag = flag;\r\n    }\r\n\r\n    function addWhiteList(address [] memory addrs) external onlyOwner {\r\n        for (uint i=0; i<addrs.length; i++) {\r\n            if (whiteLists[addrs[i]]) continue;\r\n            whiteLists[addrs[i]] = true;\r\n        }\r\n    }\r\n    function removeWhiteList(address [] memory addrs) external onlyOwner {\r\n        for (uint i=0; i<addrs.length; i++) {\r\n            if (whiteLists[addrs[i]] == false) continue;\r\n            whiteLists[addrs[i]] = false;\r\n        }\r\n    }\r\n\r\n    function updateStartAndEndTime(uint256 _startTime, uint256 _endTime) external onlyOwner {\r\n        require(_startTime < _endTime, \"New startTime must be lower than new endTime\");\r\n        startTime = _startTime;\r\n        endTime = _endTime;\r\n    }\r\n\r\n    function updatePayCoin(uint256 id, uint256 _price, uint256 _minAmount, uint256 _maxAmount, uint256 _state) external onlyOwner {\r\n        PayCoin storage pCoin = _pCoins[id];\r\n        if (pCoin.price != _price) pCoin.price = _price;\r\n        if (pCoin.min != _minAmount) pCoin.min = _minAmount;\r\n        if (pCoin.max != _maxAmount) pCoin.max = _maxAmount;\r\n        if (pCoin.state != _state) pCoin.state = _state;\r\n    }\r\n\r\n    function addPayCoin(address _token, uint256 _price, uint256 _minAmount, uint256 _maxAmount) external onlyOwner {\r\n        require(_maxAmount > _minAmount, \"Amount fault\");\r\n         _pCoins.push(PayCoin({\r\n                token: _token,\r\n                price: _price,\r\n                min: _minAmount,\r\n                max: _maxAmount,\r\n                state: 1\r\n            }));\r\n    }\r\n\r\n    function setGenFees(uint256 [] memory _genFees) external onlyOwner {\r\n        genFees = _genFees;\r\n    }\r\n\r\n    function poolLeft() public view returns(uint256) {\r\n        uint256 unableToken = soldToken.add(invalidToken);\r\n        if (supply > unableToken){\r\n            return supply.sub(unableToken);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function stopIdo() external onlyOwner {\r\n        endTime = block.timestamp;\r\n    }\r\n\r\n    function startNextIdo(uint256 _startTime, uint256 _endTime, uint256 _supply) external onlyOwner {\r\n        require(_startTime < _endTime, \"New startTime must be lower than new endTime\");\r\n        startTime = _startTime;\r\n        endTime = _endTime;\r\n        supply = _supply;\r\n        soldToken = 0;\r\n        invalidToken = 0;\r\n        period++;\r\n    }\r\n\r\n    function userTotalSale(address account) public view returns (uint256) {\r\n        uint256 total = 0;\r\n        for(uint i=1; i<=period; i++) {\r\n            total = total.add(sales[account][i]);\r\n        }\r\n        return total;\r\n    }\r\n\r\n    function userSaleTime(address account) public view returns (uint256) {\r\n        for(uint i=1; i<=period; i++) {\r\n            if (periodTimes[account][i] > 0) return periodTimes[account][i];\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function getSystemData(uint256 no, uint256 start, uint256 end) external view returns(\r\n        uint256 total,\r\n        address[]memory users,\r\n        uint256[]memory amounts,\r\n        uint256[]memory voidAmounts,\r\n        uint256[]memory claimedAmounts,\r\n        uint256[]memory times,\r\n        uint256[]memory userTeams,\r\n        uint256[]memory userDirects,\r\n        uint256[]memory userTeamTokens\r\n    ) {\r\n        if (no > period) {\r\n            total = allUsers.length;\r\n        }else {\r\n            total = periodUsers[no].length;\r\n        }\r\n        if (end > total) {\r\n            end = total;\r\n        }\r\n        if (end > start) {\r\n            users = new address[](end - start);\r\n            amounts = new uint256[](end - start);\r\n            voidAmounts = new uint256[](end - start);\r\n            claimedAmounts = new uint256[](end - start);\r\n            times = new uint256[](end - start);\r\n            userTeams = new uint256[](end - start);\r\n            userDirects = new uint256[](end - start);\r\n            userTeamTokens = new uint256[](end - start);\r\n            uint256 currentIndex = 0;\r\n            for (uint256 i = start; i < end; i++) {\r\n                if (no > period) {\r\n                    users[currentIndex] = allUsers[i];\r\n                    amounts[currentIndex] = userTotalSale(users[currentIndex]);\r\n                    times[currentIndex] = userSaleTime(users[currentIndex]);\r\n                }else {\r\n                    users[currentIndex] = periodUsers[no][i];\r\n                    amounts[currentIndex] = sales[users[currentIndex]][no];\r\n                    times[currentIndex] = periodTimes[users[currentIndex]][no];\r\n                }\r\n                voidAmounts[currentIndex] = voids[users[currentIndex]];\r\n                claimedAmounts[currentIndex] = claimeds[users[currentIndex]];\r\n                userTeams[currentIndex] = teams[users[currentIndex]];\r\n                userDirects[currentIndex] = sharers[users[currentIndex]].length; \r\n                userTeamTokens[currentIndex] = teamTokens[users[currentIndex]];\r\n                currentIndex++;\r\n            }\r\n        } \r\n    }\r\n\r\n    function getDirectInfos(address account, uint256 start, uint256 end) external view returns(\r\n        uint256 total,\r\n        address[]memory users,\r\n        uint256[]memory amounts,\r\n        uint256[]memory voidAmounts,\r\n        uint256[]memory claimedAmounts,\r\n        uint256[]memory times,\r\n        uint256[]memory userTeams,\r\n        uint256[]memory userDirects,\r\n        uint256[]memory userTeamTokens\r\n    ) {\r\n        total = sharers[account].length;\r\n        if (end > total) {\r\n            end = total;\r\n        }\r\n        if (end > start) {\r\n            users = new address[](end - start);\r\n            amounts = new uint256[](end - start);\r\n            voidAmounts = new uint256[](end - start);\r\n            claimedAmounts = new uint256[](end - start);\r\n            times = new uint256[](end - start);\r\n            userTeams = new uint256[](end - start);\r\n            userDirects = new uint256[](end - start);\r\n            userTeamTokens = new uint256[](end - start);\r\n            uint256 currentIndex = 0;\r\n            for (uint256 i = start; i < end; i++) {\r\n                users[currentIndex] = sharers[account][i];\r\n                amounts[currentIndex] = userTotalSale(users[currentIndex]);\r\n                times[currentIndex] = userSaleTime(users[currentIndex]);\r\n                voidAmounts[currentIndex] = voids[users[currentIndex]];\r\n                claimedAmounts[currentIndex] = claimeds[users[currentIndex]];\r\n                userTeams[currentIndex] = teams[users[currentIndex]];\r\n                userDirects[currentIndex] = sharers[users[currentIndex]].length; \r\n                userTeamTokens[currentIndex] = teamTokens[users[currentIndex]];\r\n                currentIndex++;\r\n            }\r\n        } \r\n    }\r\n\r\n    function getIdoInfos() external view returns(\r\n        uint256[] memory,\r\n        uint256[] memory,\r\n        string[] memory,\r\n        address,\r\n        uint256[] memory,\r\n        uint256[] memory,\r\n        PayCoin[] memory\r\n       ){\r\n        uint256[] memory array = new uint256[](15);\r\n        array[0] = supply;\r\n        array[1] = soldToken;\r\n        array[2] = poolLeft();\r\n        array[3] = startTime;\r\n        array[4] = endTime;\r\n        array[5] = mToken.totalSupply();\r\n        array[6] = autoClaim ? 1: 0; \r\n        array[7] = whiteListFlag ? 1: 0;\r\n        array[8] = rewardMustBuy ? 1: 0;\r\n        array[9] = forceBind ? 1: 0;\r\n        array[10] = statisticsInviteFlag ? 1: 0;\r\n        array[11] = statisticsBoughtFlag ? 1: 0;\r\n        array[12] = voidFlag ? 1: 0;\r\n        array[13] = voidFee;\r\n        array[14] = period;\r\n\r\n        uint256 addrLen = _pCoins.length;\r\n\r\n        string[] memory strs = new string[](addrLen + 1);\r\n        strs[0] = mToken.symbol();\r\n\r\n        uint256[] memory decimals = new uint256[](addrLen + 1);\r\n        decimals[0] = mToken.decimals();\r\n\r\n        uint256[] memory balances = new uint256[](addrLen + 1);\r\n        balances[0] = mToken.balanceOf(address(this));\r\n\r\n        for (uint i=0; i<addrLen; i++) {\r\n            PayCoin memory pCoin = _pCoins[i];\r\n            if (pCoin.token == address(0)) {\r\n                strs[i+1] = '';\r\n                decimals[i+1] = 18;\r\n                balances[i+1] = address(this).balance;\r\n            }else {\r\n                strs[i+1] = IBEP20(pCoin.token).symbol();\r\n                decimals[i+1] = IBEP20(pCoin.token).decimals();\r\n                balances[i+1] = IBEP20(pCoin.token).balanceOf(address(this));\r\n            }\r\n            \r\n        }\r\n        return (array, genFees, strs, address(mToken), decimals, balances, _pCoins);\r\n    }\r\n\r\n    function getUserInfos(address account) external view returns(uint256[] memory, uint256[] memory, uint256[] memory, address preInviter){\r\n        uint256[] memory array = new uint256[](10);\r\n        array[0] = userTotalSale(account);\r\n        array[1] = sales[account][period];\r\n        array[2] = withdrawable() ? 1 : 0;\r\n        array[3] = userTotalSale(account).sub(claimeds[account]);\r\n        array[4] = teams[account];\r\n        array[5] = sharers[account].length;\r\n        array[6] = teamTokens[account];\r\n        array[7] = voids[account];\r\n        array[8] = claimeds[account];\r\n        array[9] = whiteLists[account] ? 1: 0;\r\n\r\n        preInviter = inviters[account];\r\n\r\n        uint256 addrLen = _pCoins.length;\r\n        uint256[] memory balances = new uint256[](addrLen + 1);\r\n        uint256[] memory allowances = new uint256[](addrLen + 1);\r\n        balances[0] = mToken.balanceOf(account);\r\n        allowances[0] = mToken.allowance(account, address(this));\r\n        for (uint i=0; i<addrLen; i++) {\r\n            if (_pCoins[i].token == address(0)) {\r\n                balances[i+1] = address(account).balance;\r\n                allowances[i+1] = 0;\r\n            }else {\r\n                balances[i+1] = IBEP20(_pCoins[i].token).balanceOf(account);\r\n                allowances[i+1] = IBEP20(_pCoins[i].token).allowance(account, address(this));\r\n            }\r\n        }\r\n        return (array, balances, allowances, preInviter);\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BuyToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxAmount\",\"type\":\"uint256\"}],\"name\":\"addPayCoin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"addWhiteList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoClaim\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"bindAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimeds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forceBind\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"genFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"getDirectInfos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"voidAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"claimedAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"times\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"userTeams\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"userDirects\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"userTeamTokens\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getIdoInfos\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"state\",\"type\":\"uint256\"}],\"internalType\":\"struct IdoPro.PayCoin[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getInviter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"no\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"getSystemData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"voidAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"claimedAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"times\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"userTeams\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"userDirects\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"userTeamTokens\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getUserInfos\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"preInviter\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_mToken\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_uTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_prices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_minAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_maxAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_flags\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_genFees\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"service\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"invalidToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"inviters\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mToken\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"period\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"periodTimes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"periodUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolLeft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"inviter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"preSale\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"removeWhiteList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardMustBuy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sales\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"flag\",\"type\":\"bool\"}],\"name\":\"setAutoClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"flag\",\"type\":\"bool\"}],\"name\":\"setForceBind\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_genFees\",\"type\":\"uint256[]\"}],\"name\":\"setGenFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"flag\",\"type\":\"bool\"}],\"name\":\"setRewardMustBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"flag\",\"type\":\"bool\"}],\"name\":\"setStatisticsBoughtFlag\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"flag\",\"type\":\"bool\"}],\"name\":\"setStatisticsInviteFlag\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setVoidFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"flag\",\"type\":\"bool\"}],\"name\":\"setVoidFlag\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"flag\",\"type\":\"bool\"}],\"name\":\"setWhiteListFlag\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sharers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"soldToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_supply\",\"type\":\"uint256\"}],\"name\":\"startNextIdo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"statisticsBoughtFlag\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"statisticsInviteFlag\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopIdo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"teamTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"teams\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_state\",\"type\":\"uint256\"}],\"name\":\"updatePayCoin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endTime\",\"type\":\"uint256\"}],\"name\":\"updateStartAndEndTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"userSaleTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"userTotalSale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"voidFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"voidFlag\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenNum\",\"type\":\"uint256\"}],\"name\":\"voidSale\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"voids\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whiteListFlag\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whiteLists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "IdoPro", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://4b3ff62a88ae365b154e11aed170a1b801363fcd9942119e49732ebac8f6badb"}