{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.8.6;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev \u8fd4\u56de\u4e24\u4e2a\u65e0\u7b26\u53f7\u6574\u6570\u7684\u76f8\u52a0\uff0c\u5728\u6ea2\u51fa\u65f6\u6062\u590d\u3002\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev \u8fd4\u56de\u4e24\u4e2a\u65e0\u7b26\u53f7\u6574\u6570\u76f8\u9664\u7684\u4f59\u6570\u3002 (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary TransferHelper {\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(0xa9059cbb, to, value)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"TransferHelper: TRANSFER_FAILED\"\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"TransferHelper: TRANSFER_FROM_FAILED\"\r\n        );\r\n    }\r\n}\r\n\r\ncontract BFC_LP_Staking {\r\n    using SafeMath for uint256;\r\n    address public owner;\r\n\r\n    // \u6bcf\u4e2a\u7528\u6237\u7684\u4fe1\u606f\u3002\r\n    struct UserInfo {\r\n        uint256 amount; // \u7528\u6237\u63d0\u4f9b\u4e86\u591a\u5c11 LP \u4ee3\u5e01\u3002\r\n        uint256 allotment; // \u7528\u6237\u5b9e\u9645\u4efd\u989d (amount * (1 + durationRate))\r\n        uint256 rewardDebt; // \u7528\u6237\u5df2\u7ecf\u83b7\u53d6\u7684\u5956\u52b1\r\n        uint256 duration; //\u8d28\u62bc\u5468\u671f\r\n        uint256 lastDepositAt; //\u6700\u540e\u8d28\u62bc\u65f6\u95f4\r\n        uint256 lastRewardAt; //\u6700\u540e\u9886\u5956\u65f6\u95f4\r\n    }\r\n\r\n    // \u6bcf\u4e2a\u6c60\u7684\u4fe1\u606f\u3002\r\n    struct PoolInfo {\r\n        uint256 supply; // \u603b\u80a1\u4efd\r\n        address lpToken; // LP \u4ee3\u5e01\u5408\u7ea6\u5730\u5740\u3002\r\n        uint256 allocPoint; // \u5206\u914d\u7ed9\u6b64\u6c60\u7684\u5206\u914d\u70b9\u6570\u3002\r\n        uint256 accPerShare; // \u8d28\u62bc\u4e00\u4e2aLPToken\u7684\u5168\u5c40\u6536\u76ca\r\n    }\r\n\r\n    address public token; //bfc\r\n    uint256 public BASE_BONUS_REWARD = 8750 * 10**9; //\u57fa\u7840\u6bcf\u671f\u4ea7\u51fa\r\n    uint256 public REDUCE_BONUS_DURATION = 2592000; //30d\r\n    uint256 public BONUS_DURATION = 86400; //1d\r\n    uint256 public DEPOSIT_DURATION_1 = 2592000; //30d\r\n    uint256 public DEPOSIT_DURATION_2 = 5184000; //60d\r\n    uint256 public DEPOSIT_DURATION_3 = 7776000; //90d\r\n\r\n    uint256 public startBonusAt;\r\n    uint256 public lastBonusAt;\r\n    uint256 public pendingToken; //\u6bcf\u671f\u4ea7\u51fa\r\n\r\n    // \u6bcf\u4e2a\u6c60\u7684\u4fe1\u606f\u3002\r\n    address[] public pools;\r\n    mapping(address => PoolInfo) public poolInfo; //\u8282\u70b9\u8be6\u60c5\r\n\r\n    // \u6bcf\u4e2a\u6301\u6709 LP \u4ee3\u5e01\u7684\u7528\u6237\u7684\u4fe1\u606f\u3002\r\n    mapping(address => mapping(address => UserInfo)) public userInfo;\r\n    mapping(address => uint256) public userReward;\r\n\r\n    // \u603b\u5206\u914d\u70b9\u6570\u3002 \u5fc5\u987b\u662f\u6240\u6709\u6c60\u4e2d\u6240\u6709\u5206\u914d\u70b9\u7684\u603b\u548c\u3002\r\n    uint256 public totalAllocPoint = 0;\r\n\r\n    event Deposit(\r\n        address indexed user,\r\n        address indexed lpToken,\r\n        uint256 amount\r\n    );\r\n    event Withdraw(\r\n        address indexed user,\r\n        address indexed lpToken,\r\n        uint256 amount\r\n    );\r\n    event EmergencyWithdraw(\r\n        address indexed user,\r\n        address indexed lpToken,\r\n        uint256 amount\r\n    );\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function initalize(address _token) public {\r\n        require(token == address(0));\r\n        token = _token;\r\n        startBonusAt = block.timestamp;\r\n    }\r\n\r\n    function setOwner(address owner_) public onlyOwner {\r\n        owner = owner_;\r\n    }\r\n\r\n    function setTokenAddr(address _token) public onlyOwner {\r\n        token = _token;\r\n    }\r\n\r\n    function setBonusReward(uint256 _start, uint256 _reward) public onlyOwner {\r\n        startBonusAt = _start;\r\n        BASE_BONUS_REWARD = _reward;\r\n    }\r\n\r\n    function setBonusOption(\r\n        uint256 _reduce,\r\n        uint256 _bonus,\r\n        uint256 deposit1,\r\n        uint256 deposit2,\r\n        uint256 deposit3\r\n    ) public onlyOwner {\r\n        REDUCE_BONUS_DURATION = _reduce; //30d\r\n        BONUS_DURATION = _bonus; //1d\r\n        DEPOSIT_DURATION_1 = deposit1; //30d\r\n        DEPOSIT_DURATION_2 = deposit2; //60d\r\n        DEPOSIT_DURATION_3 = deposit3; //90d\r\n    }\r\n\r\n    function poolLength() external view returns (uint256) {\r\n        return pools.length;\r\n    }\r\n\r\n    function getPool(uint256 pid) public view returns (PoolInfo memory) {\r\n        return poolInfo[pools[pid]];\r\n    }\r\n\r\n    function getUserPools(uint256 pid, address _account)\r\n        public\r\n        view\r\n        returns (PoolInfo memory, UserInfo memory)\r\n    {\r\n        address _lpToken = pools[pid];\r\n        return (poolInfo[_lpToken], userInfo[_lpToken][_account]);\r\n    }\r\n\r\n    // \u5c06\u65b0\u7684 lp \u6dfb\u52a0\u5230\u6c60\u4e2d\u3002 \u53ea\u80fd\u7531\u6240\u6709\u8005\u8c03\u7528\u3002\r\n    // XXX \u4e0d\u8981\u591a\u6b21\u6dfb\u52a0\u76f8\u540c\u7684 LP \u4ee4\u724c\u3002 \u5982\u679c\u4f60\u8fd9\u6837\u505a\uff0c\u5956\u52b1\u4f1a\u88ab\u641e\u7838\u3002\r\n    // _allocPoint \u5206\u914d\u70b9\r\n    function addPool(uint256 _allocPoint, address _lpToken) public onlyOwner {\r\n        require(poolInfo[_lpToken].lpToken == address(0)); //\u9632\u5446\uff0c\u907f\u514d\u91cd\u590d\u6dfb\u52a0\u6c60\r\n        totalAllocPoint = totalAllocPoint.add(_allocPoint);\r\n        pools.push(_lpToken);\r\n        poolInfo[_lpToken] = PoolInfo({\r\n            supply: 0,\r\n            lpToken: _lpToken,\r\n            allocPoint: _allocPoint,\r\n            accPerShare: 0\r\n        });\r\n    }\r\n\r\n    // \u66f4\u65b0\u7ed9\u5b9a\u6c60\u7684 token \u5206\u914d\u70b9\u3002 \u53ea\u80fd\u7531\u6240\u6709\u8005\u8c03\u7528\u3002\r\n    function setPool(address _lpToken, uint256 _allocPoint) public onlyOwner {\r\n        totalAllocPoint = totalAllocPoint\r\n            .sub(poolInfo[_lpToken].allocPoint)\r\n            .add(_allocPoint);\r\n        poolInfo[_lpToken].allocPoint = _allocPoint;\r\n    }\r\n\r\n    // \u66f4\u65b0\u6240\u6709\u6c60\u7684\u5956\u52b1\u53d8\u91cf\u3002 \u5c0f\u5fc3\u6c7d\u6cb9\u6d88\u8d39\uff01\r\n    function bonusReward() public {\r\n        require(\r\n            block.timestamp - lastBonusAt > BONUS_DURATION,\r\n            \"Error: BONUS_DURATION\"\r\n        );\r\n\r\n        uint256 _bonusReward = BASE_BONUS_REWARD;\r\n        uint256 _cycle = block.timestamp.sub(startBonusAt).div(\r\n            REDUCE_BONUS_DURATION\r\n        );\r\n        if (_cycle > 0) {\r\n            _bonusReward = _bonusReward.sub(\r\n                BASE_BONUS_REWARD.mul(5).mul(_cycle).div(1000)\r\n            );\r\n        }\r\n\r\n        pendingToken = _bonusReward / 30;\r\n        uint256 length = pools.length;\r\n        lastBonusAt = block.timestamp;\r\n\r\n        for (uint256 pid = 0; pid < length; ++pid) {\r\n            updatePool(pools[pid]);\r\n        }\r\n    }\r\n\r\n    function updatePool(address _lpToken) private {\r\n        PoolInfo storage pool = poolInfo[_lpToken];\r\n        if (pool.allocPoint > 0 && pool.supply > 0) {\r\n            uint256 _reward = pendingToken.mul(pool.allocPoint).div(\r\n                totalAllocPoint\r\n            );\r\n            pool.accPerShare = pool.accPerShare.add(\r\n                _reward.mul(1e12).div(pool.supply)\r\n            );\r\n        }\r\n    }\r\n\r\n    // \u5c06 LP \u4ee3\u5e01\u5b58\u5165\r\n    function deposit(\r\n        address _lpToken,\r\n        uint256 _duration,\r\n        uint256 _amount\r\n    ) public {\r\n        PoolInfo storage pool = poolInfo[_lpToken];\r\n        UserInfo storage user = userInfo[_lpToken][msg.sender];\r\n        if (user.allotment > 0) {\r\n            require(_duration == user.duration, \"Error: User Duration\");\r\n            _takeReward(msg.sender, _lpToken);\r\n        }\r\n\r\n        uint256 balanceBefore = IERC20(pool.lpToken).balanceOf(address(this)); //\u517c\u5bb9\u6709\u624b\u7eed\u8d39\u7684\u4ee3\u5e01\r\n        TransferHelper.safeTransferFrom(\r\n            pool.lpToken,\r\n            msg.sender,\r\n            address(this),\r\n            _amount\r\n        );\r\n        uint256 balanceAdd = IERC20(pool.lpToken).balanceOf(address(this)) -\r\n            balanceBefore; //\u517c\u5bb9\u6709\u624b\u7eed\u8d39\u7684\u4ee3\u5e01\r\n\r\n        uint256 _rate;\r\n        (_duration, _rate) = _depositRate(_duration);\r\n        user.duration = _duration;\r\n\r\n        uint256 _allotment = user.allotment;\r\n        user.amount = user.amount.add(balanceAdd);\r\n        user.allotment = user.amount.mul(_rate).div(100);\r\n        user.lastDepositAt = block.timestamp;\r\n        pool.supply = pool.supply.add(user.allotment.sub(_allotment));\r\n\r\n        user.rewardDebt = user.allotment.mul(pool.accPerShare).div(1e12);\r\n        emit Deposit(msg.sender, _lpToken, balanceAdd);\r\n    }\r\n\r\n    // \u4ece MasterChef \u4e2d\u63d0\u73b0 LP \u4ee3\u5e01\u3002\r\n    function withdraw(address _lpToken, uint256 _amount) public {\r\n        PoolInfo storage pool = poolInfo[_lpToken];\r\n        UserInfo storage user = userInfo[_lpToken][msg.sender];\r\n        require(user.amount >= _amount, \"withdraw: not good\");\r\n        require(\r\n            block.timestamp - user.lastDepositAt >= user.duration,\r\n            \"Error: User Duration\"\r\n        );\r\n\r\n        _takeReward(msg.sender, _lpToken);\r\n\r\n        user.amount = user.amount.sub(_amount);\r\n        (, uint256 _rate) = _depositRate(user.duration);\r\n        if (user.amount == 0) {\r\n            pool.supply = pool.supply.sub(user.allotment);\r\n            user.duration = 0;\r\n            user.allotment = 0;\r\n            user.rewardDebt = 0;\r\n        } else {\r\n            uint256 _allotment = user.amount.mul(_rate).div(100);\r\n            pool.supply = pool.supply.sub(user.allotment.sub(_allotment));\r\n            user.allotment = _allotment;\r\n            user.rewardDebt = user.allotment.mul(pool.accPerShare).div(1e12);\r\n        }\r\n\r\n        TransferHelper.safeTransfer(pool.lpToken, msg.sender, _amount);\r\n\r\n        emit Withdraw(msg.sender, _lpToken, _amount);\r\n    }\r\n\r\n    // \u63d0\u73b0\u800c\u4e0d\u5173\u5fc3\u5956\u52b1\u3002 \u4ec5\u9650\u7d27\u6025\u60c5\u51b5\u3002\r\n    function emergencyWithdraw(address _lpToken) public {\r\n        PoolInfo storage pool = poolInfo[_lpToken];\r\n        UserInfo storage user = userInfo[_lpToken][msg.sender];\r\n        require(\r\n            block.timestamp - user.lastDepositAt >= user.duration,\r\n            \"Error: User Duration\"\r\n        );\r\n        TransferHelper.safeTransfer(pool.lpToken, msg.sender, user.amount);\r\n\r\n        pool.supply = pool.supply.sub(user.allotment);\r\n        user.amount = 0;\r\n        user.allotment = 0;\r\n        user.duration = 0;\r\n        user.rewardDebt = 0;\r\n        emit EmergencyWithdraw(msg.sender, _lpToken, user.amount);\r\n    }\r\n\r\n    function rewardAmount(address _account, address _lpToken)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        PoolInfo storage pool = poolInfo[_lpToken];\r\n        UserInfo storage user = userInfo[_lpToken][_account];\r\n        uint256 pending;\r\n        if (\r\n            user.allotment > 0 &&\r\n            pool.supply > 0 &&\r\n            pool.allocPoint > 0 &&\r\n            pool.accPerShare > 0\r\n        ) {\r\n            pending = user.allotment.mul(pool.accPerShare).div(1e12).sub(\r\n                user.rewardDebt\r\n            );\r\n        }\r\n        return pending;\r\n    }\r\n\r\n    // \u76f4\u63a5\u9886\u53d6\u6536\u76ca\r\n    function takeReward(address _lpToken) public {\r\n        PoolInfo storage pool = poolInfo[_lpToken];\r\n        UserInfo storage user = userInfo[_lpToken][msg.sender];\r\n        require(lastBonusAt > user.lastRewardAt, \"Error: lastRewardAt\");\r\n\r\n        // \u8d28\u62bc\u5230\u671f\u65f6\u95f4\r\n        uint256 bonusTimes;\r\n        uint256 userDepositDuration = user.lastDepositAt + user.duration;\r\n        // \u8d85\u671f\u4e86\r\n        if (block.timestamp > userDepositDuration) {\r\n            //\u8d85\u8fc7\u65f6\u95f4\r\n            uint256 overflowTime = block.timestamp - userDepositDuration;\r\n            //\u8d85\u671f\u7684\u65f6\u95f4\u5185\u5206\u7ea2\u6b21\u6570\r\n            bonusTimes = overflowTime.div(BONUS_DURATION);\r\n        }\r\n\r\n        if (bonusTimes > 5) {\r\n            user.lastDepositAt = block.timestamp;\r\n        } else if (bonusTimes > 1) {\r\n            withdraw(_lpToken, user.amount);\r\n        } else {\r\n            _takeReward(msg.sender, _lpToken);\r\n            user.rewardDebt = user.allotment.mul(pool.accPerShare).div(1e12);\r\n        }\r\n    }\r\n\r\n    function _takeReward(address _account, address _lpToken) private {\r\n        uint256 pending = rewardAmount(_account, _lpToken);\r\n        if (pending > 0) {\r\n            UserInfo storage user = userInfo[_lpToken][_account];\r\n            safeTransfer(_account, pending);\r\n            user.lastRewardAt = block.timestamp;\r\n        }\r\n    }\r\n\r\n    function _depositRate(uint256 _duration)\r\n        public\r\n        view\r\n        returns (uint256, uint256)\r\n    {\r\n        if (_duration == DEPOSIT_DURATION_2) {\r\n            return (DEPOSIT_DURATION_2, 110);\r\n        } else if (_duration == DEPOSIT_DURATION_3) {\r\n            return (DEPOSIT_DURATION_3, 120);\r\n        } else {\r\n            return (DEPOSIT_DURATION_1, 100);\r\n        }\r\n    }\r\n\r\n    // \u5b89\u5168\u7684\u8f6c\u8d26\u529f\u80fd\uff0c\u4ee5\u9632\u4e07\u4e00\u5982\u679c\u820d\u5165\u9519\u8bef\u5bfc\u81f4\u6c60\u6ca1\u6709\u8db3\u591f\u7684\u5956\u52b1\u3002\r\n    function safeTransfer(address _to, uint256 _amount) internal {\r\n        if (_amount > 0) {\r\n            uint256 _reward = IERC20(token).balanceOf(address(this));\r\n            if (_amount > _reward) {\r\n                _amount = _reward;\r\n            }\r\n            userReward[_to] = userReward[_to].add(_amount);\r\n            TransferHelper.safeTransfer(token, _to, _amount);\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BASE_BONUS_REWARD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BONUS_DURATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEPOSIT_DURATION_1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEPOSIT_DURATION_2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEPOSIT_DURATION_3\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REDUCE_BONUS_DURATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"_depositRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_lpToken\",\"type\":\"address\"}],\"name\":\"addPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bonusReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpToken\",\"type\":\"address\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"}],\"name\":\"getPool\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accPerShare\",\"type\":\"uint256\"}],\"internalType\":\"struct BFC_LP_Staking.PoolInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getUserPools\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accPerShare\",\"type\":\"uint256\"}],\"internalType\":\"struct BFC_LP_Staking.PoolInfo\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allotment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastDepositAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardAt\",\"type\":\"uint256\"}],\"internalType\":\"struct BFC_LP_Staking.UserInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"initalize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastBonusAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"poolInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accPerShare\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pools\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_lpToken\",\"type\":\"address\"}],\"name\":\"rewardAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reduce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deposit1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deposit2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deposit3\",\"type\":\"uint256\"}],\"name\":\"setBonusOption\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reward\",\"type\":\"uint256\"}],\"name\":\"setBonusReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_allocPoint\",\"type\":\"uint256\"}],\"name\":\"setPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setTokenAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBonusAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpToken\",\"type\":\"address\"}],\"name\":\"takeReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAllocPoint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allotment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastDepositAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BFC_LP_Staking", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d902f8f9778315a152e76b97b0d146ef1976dbf2f03ce2547dbf07cfd8eb9072"}