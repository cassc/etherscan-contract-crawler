{"SourceCode": "{\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: --GRISE--\\r\\n\\r\\npragma solidity =0.7.6;\\r\\n\\r\\ncontract Context {\\r\\n\\r\\n    /**\\r\\n     * @dev returns address executing the method\\r\\n     */\\r\\n    function _msgSender() internal view virtual returns (address payable) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev returns data passed into the method\\r\\n     */\\r\\n    function _msgData() internal view virtual returns (bytes memory) {\\r\\n        this;\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\"},\"Declaration.sol\":{\"content\":\"// SPDX-License-Identifier: --GRISE--\\r\\n\\r\\nimport \\\"./Context.sol\\\";\\r\\nimport \\\"./Events.sol\\\";\\r\\n\\r\\npragma solidity =0.7.6;\\r\\n\\r\\nabstract contract Declaration is Context, Events {\\r\\n\\r\\n    uint256 constant _decimals = 18;\\r\\n    uint256 constant REI_PER_GRISE = 10 ** _decimals;\\r\\n\\r\\n    uint32 constant SECONDS_IN_DAY = 24 hours;\\r\\n    uint32 constant SECONDS_IN_DAY_LP = 4 hours; \\r\\n    uint32 constant GRISE_WEEK = 7;\\r\\n    uint32 constant GRISE_MONTH = 4 * GRISE_WEEK;\\r\\n    uint32 constant GRISE_YEAR = 12 * GRISE_MONTH;\\r\\n\\r\\n    uint64 constant PRECISION_RATE = 1E18;\\r\\n    uint16 constant REWARD_PRECISION_RATE = 1E4;\\r\\n    uint256 immutable LAUNCH_TIME;\\r\\n    uint256 immutable LP_LAUNCH_TIME; // PreSale Launch Time\\r\\n    \\r\\n    uint16 constant SELL_TRANS_FEE = 347; // 3.47% multiple 1E4 Precision\\r\\n    uint16 constant TRANSC_RESERVOIR_REWARD = 3054;\\r\\n    uint16 constant TRANSC_STAKER_REWARD = 1642;\\r\\n    uint16 constant TRANSC_TOKEN_HOLDER_REWARD = 2622;\\r\\n    uint16 constant TEAM_SELL_TRANSC_REWARD = 1441;\\r\\n    uint16 constant SELL_TRANS_BURN = 1239;\\r\\n    \\r\\n    uint16 constant BUY_TRANS_FEE = 30; // .30 multiple 1E4 Precision\\r\\n    uint16 constant TEAM_BUY_TRANS_REWARD = 6667; // 66.67 multiple 1E2 Precisions\\r\\n    uint16 constant BUY_TRANS_BURN = 3333;\\r\\n    address constant TEAM_ADDRESS = 0xa377433831E83C7a4Fa10fB75C33217cD7CABec2;\\r\\n    address constant DEVELOPER_ADDRESS = 0xcD8DcbA8e4791B19719934886A8bA77EA3fad447;\\r\\n    \\r\\n    constructor() {\\r\\n        LAUNCH_TIME = 1619740800; // (30th April 2021 @00:00 GMT == day 0)\\r\\n        LP_LAUNCH_TIME = 1620777600;  // (12th May 2021 @00:00 GMT == day 0)\\r\\n    }\\r\\n\\r\\n\\r\\n    uint256 internal stakedToken;\\r\\n    uint256 internal mediumTermShares;\\r\\n    mapping(uint256 =\\u003e uint256) internal sellTranscFee;  // week ==\\u003e weekly Accumalted transc fee\\r\\n    mapping(uint256 =\\u003e uint256) internal reservoirRewardPerShare;\\r\\n    mapping(uint256 =\\u003e uint256) internal stakerRewardPerShare;\\r\\n    mapping(uint256 =\\u003e uint256) internal tokenHolderReward;\\r\\n    mapping(address =\\u003e mapping(uint256 =\\u003e bool)) internal isTranscFeeClaimed;\\r\\n    mapping(uint256 =\\u003e uint256) internal totalToken;\\r\\n    mapping(address =\\u003e uint16) internal staker;\\r\\n}\\r\\n\"},\"Events.sol\":{\"content\":\"// SPDX-License-Identifier: --GRISE--\\r\\n\\r\\npragma solidity =0.7.6;\\r\\n\\r\\ncontract Events {\\r\\n\\r\\n    event TranscFeeClaimed(\\r\\n        address indexed tokenHolderAddress,\\r\\n        uint256 griseWeek,\\r\\n        uint256 claimedAmount\\r\\n    );\\r\\n}\"},\"GriseToken.sol\":{\"content\":\"// SPDX-License-Identifier: --GRISE--\\r\\n\\r\\npragma solidity =0.7.6;\\r\\n\\r\\nimport \\\"./Utils.sol\\\";\\r\\n\\r\\ncontract GriseToken is Utils {\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    mapping (address =\\u003e uint256) private _balances;\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\r\\n\\r\\n    address public LIQUIDITY_GATEKEEPER;\\r\\n    address public STAKE_GATEKEEPER;\\r\\n    address public VAULT_GATEKEEPER;\\r\\n\\r\\n    address private liquidtyGateKeeper;\\r\\n    address private stakeGateKeeper;\\r\\n    address private vaultGateKeeper;\\r\\n\\r\\n    /**\\r\\n     * @dev initial private\\r\\n     */\\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n    uint8 private _decimal = 18;\\r\\n\\r\\n    /**\\r\\n     * @dev \ud83d\udc7b Initial supply \\r\\n     */\\r\\n    uint256 private _totalSupply = 0;\\r\\n\\r\\n    event Transfer(\\r\\n        address indexed from,\\r\\n        address indexed to,\\r\\n        uint256 value\\r\\n    );\\r\\n\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n\\r\\n    constructor (string memory tokenName, string memory tokenSymbol) {\\r\\n        _name = tokenName;\\r\\n        _symbol = tokenSymbol;\\r\\n        liquidtyGateKeeper = _msgSender();\\r\\n        stakeGateKeeper = _msgSender();\\r\\n        vaultGateKeeper = _msgSender();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the name of the token.\\r\\n     */\\r\\n    function name() external view returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token.\\r\\n     */\\r\\n    function symbol() external view returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the decimals of the token.\\r\\n     */\\r\\n    function decimals() external view returns (uint8) {\\r\\n        return _decimal;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the total supply of the token.\\r\\n     */\\r\\n    function totalSupply() public view returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the token balance of specific address.\\r\\n     */\\r\\n    function balanceOf(address account) public view returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    function transfer(\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    )\\r\\n        external\\r\\n        returns (bool)\\r\\n    {  \\r\\n        _transfer(\\r\\n            _msgSender(),\\r\\n            recipient,\\r\\n            amount\\r\\n        );\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns approved balance to be spent by another address\\r\\n     * by using transferFrom method\\r\\n     */\\r\\n    function allowance(\\r\\n        address owner,\\r\\n        address spender\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the token allowance to another spender\\r\\n     */\\r\\n    function approve(\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    )\\r\\n        external\\r\\n        returns (bool)\\r\\n    {\\r\\n        _approve(\\r\\n            _msgSender(),\\r\\n            spender,\\r\\n            amount\\r\\n        );\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Allows to transfer tokens on senders behalf\\r\\n     * based on allowance approved for the executer\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    )\\r\\n        external\\r\\n        returns (bool)\\r\\n    {    \\r\\n        _approve(sender,\\r\\n            _msgSender(), _allowances[sender][_msgSender()].sub(\\r\\n                amount\\r\\n            )\\r\\n        );\\r\\n\\r\\n        _transfer(\\r\\n            sender,\\r\\n            recipient,\\r\\n            amount\\r\\n        );\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `sender` cannot be the zero address.\\r\\n     * - `recipient` cannot be the zero address.\\r\\n     * - `sender` must have a balance of at least `amount`.\\r\\n     */\\r\\n    function _transfer(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    )\\r\\n        internal\\r\\n        virtual\\r\\n    {\\r\\n        require(\\r\\n            sender != address(0x0)\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            recipient != address(0x0)\\r\\n        );\\r\\n\\r\\n        uint256 stFee;\\r\\n        uint256 btFee;\\r\\n        uint256 teamReward;\\r\\n        uint256 currentGriseDay = _currentGriseDay();\\r\\n\\r\\n        if (staker[sender] == 0) {\\r\\n            stFee = _calculateSellTranscFee(amount);\\r\\n\\r\\n            sellTranscFee[currentGriseDay] = \\r\\n            sellTranscFee[currentGriseDay]\\r\\n                        .add(stFee);\\r\\n                \\r\\n            reservoirRewardPerShare[currentGriseDay] = \\r\\n            reservoirRewardPerShare[currentGriseDay]\\r\\n                        .add(stFee.mul(TRANSC_RESERVOIR_REWARD)\\r\\n                        .div(REWARD_PRECISION_RATE)\\r\\n                        .div(mediumTermShares));\\r\\n                \\r\\n            stakerRewardPerShare[currentGriseDay] = \\r\\n            stakerRewardPerShare[currentGriseDay]\\r\\n                        .add(stFee.mul(TRANSC_STAKER_REWARD)\\r\\n                        .div(REWARD_PRECISION_RATE)\\r\\n                        .div(mediumTermShares));\\r\\n                \\r\\n            tokenHolderReward[currentGriseDay] = \\r\\n            tokenHolderReward[currentGriseDay]\\r\\n                        .add(stFee.mul(TRANSC_TOKEN_HOLDER_REWARD)\\r\\n                        .div(REWARD_PRECISION_RATE));\\r\\n            \\r\\n            teamReward = stFee.mul(TEAM_SELL_TRANSC_REWARD)\\r\\n                              .div(REWARD_PRECISION_RATE);\\r\\n        }\\r\\n\\r\\n        btFee = _calculateBuyTranscFee(amount);\\r\\n        \\r\\n        _balances[sender] =\\r\\n        _balances[sender].sub(amount);\\r\\n\\r\\n        _balances[recipient] =\\r\\n        _balances[recipient].add(amount.sub(btFee).sub(stFee));\\r\\n\\r\\n        teamReward += btFee.mul(TEAM_BUY_TRANS_REWARD)\\r\\n                           .div(REWARD_PRECISION_RATE);\\r\\n        \\r\\n        _balances[TEAM_ADDRESS] = \\r\\n        _balances[TEAM_ADDRESS].add(teamReward.mul(90).div(100));\\r\\n\\r\\n        _balances[DEVELOPER_ADDRESS] = \\r\\n        _balances[DEVELOPER_ADDRESS].add(teamReward.mul(10).div(100));\\r\\n\\r\\n        // Burn Transction fee\\r\\n        // We will mint token when user comes\\r\\n        // to claim transction fee reward.\\r\\n        _totalSupply =\\r\\n        _totalSupply.sub(stFee.add(btFee).sub(teamReward));\\r\\n\\r\\n        totalToken[currentGriseDay] = totalSupply().add(stakedToken);\\r\\n        \\r\\n        emit Transfer(\\r\\n            sender,\\r\\n            recipient,\\r\\n            amount\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\r\\n     * the total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `from` set to the zero address.\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     */\\r\\n    function _mint(\\r\\n        address account,\\r\\n        uint256 amount\\r\\n    )\\r\\n        internal\\r\\n        virtual\\r\\n    {\\r\\n        require(\\r\\n            account != address(0x0)\\r\\n        );\\r\\n        \\r\\n        _totalSupply =\\r\\n        _totalSupply.add(amount);\\r\\n\\r\\n        _balances[account] =\\r\\n        _balances[account].add(amount);\\r\\n\\r\\n        totalToken[currentGriseDay()] = totalSupply().add(stakedToken);\\r\\n        \\r\\n        emit Transfer(\\r\\n            address(0x0),\\r\\n            account,\\r\\n            amount\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\r\\n     * total supply.\\r\\n     *\\r\\n     * Emits a {Transfer} event with `to` set to the zero address.\\r\\n     *\\r\\n     * Requirements:\\r\\n\\r\\n     *\\r\\n     * - `account` cannot be the zero address.\\r\\n     * - `account` must have at least `amount` tokens.\\r\\n     */\\r\\n    function _burn(\\r\\n        address account,\\r\\n        uint256 amount\\r\\n    )\\r\\n        internal\\r\\n        virtual\\r\\n    {\\r\\n        require(\\r\\n            account != address(0x0)\\r\\n        );\\r\\n    \\r\\n        _balances[account] =\\r\\n        _balances[account].sub(amount);\\r\\n\\r\\n        _totalSupply =\\r\\n        _totalSupply.sub(amount);\\r\\n\\r\\n        totalToken[currentGriseDay()] = _totalSupply.add(stakedToken);\\r\\n        \\r\\n        emit Transfer(\\r\\n            account,\\r\\n            address(0x0),\\r\\n            amount\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\r\\n     * Emits an {Approval} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `owner` cannot be the zero address.\\r\\n     * - `spender` cannot be the zero address.\\r\\n     */\\r\\n    function _approve(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    )\\r\\n        internal\\r\\n        virtual\\r\\n    {\\r\\n        require(\\r\\n            owner != address(0x0)\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            spender != address(0x0)\\r\\n        );\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n\\r\\n        emit Approval(\\r\\n            owner,\\r\\n            spender,\\r\\n            amount\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice ability to define liquidity transformer contract\\r\\n     * @dev this method renounce liquidtyGateKeeper access\\r\\n     * @param _immutableGateKeeper contract address\\r\\n     */\\r\\n    function setLiquidtyGateKeeper(\\r\\n        address _immutableGateKeeper\\r\\n    )\\r\\n        external\\r\\n    {\\r\\n        require(\\r\\n            liquidtyGateKeeper == _msgSender(),\\r\\n            \\u0027GRISE: Operation not allowed\\u0027\\r\\n        );\\r\\n\\r\\n        LIQUIDITY_GATEKEEPER = _immutableGateKeeper;\\r\\n        liquidtyGateKeeper = address(0x0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice ability to define Staker contract\\r\\n     * @dev this method renounce stakeGateKeeper access\\r\\n     * @param _immutableGateKeeper contract address\\r\\n     */\\r\\n    function setStakeGateKeeper(\\r\\n        address _immutableGateKeeper\\r\\n    )\\r\\n        external\\r\\n    {\\r\\n        require(\\r\\n            stakeGateKeeper == _msgSender(),\\r\\n            \\u0027GRISE: Operation not allowed\\u0027\\r\\n        );\\r\\n\\r\\n        STAKE_GATEKEEPER = _immutableGateKeeper;\\r\\n        stakeGateKeeper = address(0x0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice ability to define vault contract\\r\\n     * @dev this method renounce vaultGateKeeper access\\r\\n     * @param _immutableGateKeeper contract address\\r\\n     */\\r\\n    function setVaultGateKeeper(\\r\\n        address _immutableGateKeeper\\r\\n    )\\r\\n        external\\r\\n    {\\r\\n        require(\\r\\n            vaultGateKeeper == _msgSender(),\\r\\n            \\u0027GRISE: Operation not allowed\\u0027\\r\\n        );\\r\\n\\r\\n        VAULT_GATEKEEPER = _immutableGateKeeper;\\r\\n        vaultGateKeeper = address(0x0);\\r\\n    }\\r\\n\\r\\n    modifier interfaceValidator() {\\r\\n        require (\\r\\n            _msgSender() == LIQUIDITY_GATEKEEPER ||\\r\\n            _msgSender() == STAKE_GATEKEEPER ||\\r\\n            _msgSender() == VAULT_GATEKEEPER,\\r\\n            \\u0027GRISE: Operation not allowed\\u0027\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice allows interfaceValidator to mint supply\\r\\n     * @param _investorAddress address for minting GRISE tokens\\r\\n     * @param _amount of tokens to mint for _investorAddress\\r\\n     */\\r\\n    function mintSupply(\\r\\n        address _investorAddress,\\r\\n        uint256 _amount\\r\\n    )\\r\\n        external\\r\\n        interfaceValidator\\r\\n    {       \\r\\n        _mint(\\r\\n            _investorAddress,\\r\\n            _amount\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice allows interfaceValidator to burn supply\\r\\n     * @param _investorAddress address for minting GRISE tokens\\r\\n     * @param _amount of tokens to mint for _investorAddress\\r\\n     */\\r\\n    function burnSupply(\\r\\n        address _investorAddress,\\r\\n        uint256 _amount\\r\\n    )\\r\\n        external\\r\\n        interfaceValidator\\r\\n    {\\r\\n        _burn(\\r\\n            _investorAddress,\\r\\n            _amount\\r\\n        );\\r\\n    }\\r\\n    \\r\\n    function viewTokenHolderTranscReward() \\r\\n        external \\r\\n        view \\r\\n        returns (uint256 rewardAmount) \\r\\n    {\\r\\n        \\r\\n        uint256 _day = currentGriseDay();\\r\\n        \\r\\n        if( (balanceOf(_msgSender()) \\u003c= 0) ||\\r\\n            isTranscFeeClaimed[_msgSender()][calculateGriseWeek(_day)] ||  \\r\\n            calculateGriseWeek(_day) != currentGriseWeek())\\r\\n        {\\r\\n            rewardAmount = 0;\\r\\n        }\\r\\n        else\\r\\n        {    \\r\\n            uint256 calculationDay = _day.mod(GRISE_WEEK) \\u003e 0 ? \\r\\n                                    _day.sub(_day.mod(GRISE_WEEK)) :\\r\\n                                    _day.sub(GRISE_WEEK);\\r\\n\\r\\n            for (uint256 day = calculationDay; day \\u003c _day; day++)\\r\\n            {\\r\\n                rewardAmount += tokenHolderReward[day]\\r\\n                                            .mul(_balances[_msgSender()])\\r\\n                                            .div(totalToken[day]);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    function claimTokenHolderTranscReward()\\r\\n        external \\r\\n        returns (uint256 rewardAmount)\\r\\n    {    \\r\\n        uint256 _day = currentGriseDay();\\r\\n        require( \\r\\n            balanceOf(_msgSender()) \\u003e 0,\\r\\n            \\u0027GRISE - Token holder doesnot enough balance to claim reward\\u0027\\r\\n        );\\r\\n        \\r\\n        require(\\r\\n            (currentGriseDay().mod(GRISE_WEEK)) == 0,\\r\\n            \\u0027GRISE - Transcation Reward window is not yeat open\\u0027\\r\\n        );\\r\\n        \\r\\n        require(\\r\\n            calculateGriseWeek(_day) == currentGriseWeek(),\\r\\n            \\u0027GRISE - You are late/early to claim reward\\u0027\\r\\n        );\\r\\n        \\r\\n        require( \\r\\n            !isTranscFeeClaimed[_msgSender()][currentGriseWeek()],\\r\\n            \\u0027GRISE - Transcation Reward is already been claimed\\u0027\\r\\n        );\\r\\n\\r\\n        for (uint256 day = _day.sub(GRISE_WEEK); day \\u003c _day; day++)\\r\\n        {\\r\\n            rewardAmount += tokenHolderReward[day]\\r\\n                                        .mul(_balances[_msgSender()])\\r\\n                                        .div(totalToken[day]);\\r\\n        }\\r\\n                                        \\r\\n        _mint(\\r\\n            _msgSender(),\\r\\n            rewardAmount\\r\\n        );\\r\\n        \\r\\n        isTranscFeeClaimed[_msgSender()][currentGriseWeek()] = true;\\r\\n\\r\\n        TranscFeeClaimed(_msgSender(), currentGriseWeek(), rewardAmount);\\r\\n    }\\r\\n\\r\\n    function setStaker(\\r\\n        address _staker\\r\\n    ) \\r\\n        external\\r\\n    {    \\r\\n        require(\\r\\n            _msgSender() == STAKE_GATEKEEPER,\\r\\n            \\u0027GRISE: Operation not allowed\\u0027\\r\\n        );\\r\\n        \\r\\n        staker[_staker] = staker[_staker] + 1;\\r\\n    }\\r\\n    \\r\\n    function resetStaker(\\r\\n        address _staker\\r\\n    ) \\r\\n        external\\r\\n    {    \\r\\n        require(\\r\\n            _msgSender() == STAKE_GATEKEEPER,\\r\\n            \\u0027GRISE: Operation not allowed\\u0027\\r\\n        );\\r\\n        \\r\\n        if (staker[_staker] \\u003e 0)\\r\\n        {\\r\\n            staker[_staker] = staker[_staker] - 1;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function updateStakedToken(\\r\\n        uint256 _stakedToken\\r\\n    ) \\r\\n        external\\r\\n    {\\r\\n        require(\\r\\n            _msgSender() == STAKE_GATEKEEPER,\\r\\n            \\u0027GRISE: Operation not allowed\\u0027\\r\\n        );\\r\\n            \\r\\n        stakedToken = _stakedToken;\\r\\n        totalToken[currentGriseDay()] = totalSupply().add(stakedToken);\\r\\n    }\\r\\n\\r\\n    function updateMedTermShares(\\r\\n        uint256 _shares\\r\\n    ) \\r\\n        external\\r\\n    {    \\r\\n        require(\\r\\n            _msgSender() == STAKE_GATEKEEPER,\\r\\n            \\u0027GRISE: Operation not allowed\\u0027\\r\\n        );\\r\\n        \\r\\n        mediumTermShares = _shares;\\r\\n    }\\r\\n\\r\\n    function getTransFeeReward(\\r\\n        uint256 _fromDay,\\r\\n        uint256 _toDay\\r\\n    ) \\r\\n        external \\r\\n        view \\r\\n        returns (uint256 rewardAmount)\\r\\n    {\\r\\n        require(\\r\\n            _msgSender() == STAKE_GATEKEEPER,\\r\\n            \\u0027GRISE: Operation not allowed\\u0027\\r\\n        );\\r\\n\\r\\n        for(uint256 day = _fromDay; day \\u003c _toDay; day++)\\r\\n        {\\r\\n            rewardAmount += stakerRewardPerShare[day];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getReservoirReward(\\r\\n        uint256 _fromDay,\\r\\n        uint256 _toDay\\r\\n    ) \\r\\n        external\\r\\n        view \\r\\n        returns (uint256 rewardAmount)\\r\\n    {\\r\\n        require(\\r\\n            _msgSender() == STAKE_GATEKEEPER,\\r\\n            \\u0027GRISE: Operation not allowed\\u0027\\r\\n        );\\r\\n\\r\\n        for(uint256 day = _fromDay; day \\u003c _toDay; day++)\\r\\n        {\\r\\n            rewardAmount += reservoirRewardPerShare[day];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getTokenHolderReward(\\r\\n        uint256 _fromDay,\\r\\n        uint256 _toDay\\r\\n    ) \\r\\n        external\\r\\n        view \\r\\n        returns (uint256 rewardAmount)\\r\\n    {\\r\\n\\r\\n        require(\\r\\n            _msgSender() == STAKE_GATEKEEPER,\\r\\n            \\u0027GRISE: Operation not allowed\\u0027\\r\\n        );\\r\\n\\r\\n        for(uint256 day = _fromDay; day \\u003c _toDay; day++)\\r\\n        {\\r\\n            rewardAmount += tokenHolderReward[day]\\r\\n                            .mul(PRECISION_RATE)\\r\\n                            .div(totalToken[day]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function timeToClaimWeeklyReward() \\r\\n        public\\r\\n        view\\r\\n        returns (uint256 _days)\\r\\n    {\\r\\n        _days = currentGriseDay().mod(GRISE_WEEK) \\u003e 0 ?\\r\\n                    GRISE_WEEK - currentGriseDay().mod(GRISE_WEEK) :\\r\\n                    0;\\r\\n    }\\r\\n\\r\\n    function timeToClaimMonthlyReward() \\r\\n        public \\r\\n        view \\r\\n        returns (uint256 _days)\\r\\n    {\\r\\n        _days = currentGriseDay().mod(GRISE_MONTH) \\u003e 0 ?\\r\\n                    GRISE_MONTH - currentGriseDay().mod(GRISE_MONTH) :\\r\\n                    0;\\r\\n    }\\r\\n\\r\\n    function balanceOfStaker(\\r\\n        address account\\r\\n    ) \\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    function getEpocTime() \\r\\n        external\\r\\n        view \\r\\n        returns (uint256)\\r\\n    {\\r\\n        return block.timestamp;\\r\\n    }\\r\\n\\r\\n    function getLaunchTime()\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return LAUNCH_TIME;\\r\\n    }\\r\\n\\r\\n    function getLPLaunchTime()\\r\\n        external\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return LP_LAUNCH_TIME;\\r\\n    }\\r\\n\\r\\n    function isStaker(\\r\\n        address _staker\\r\\n    ) \\r\\n        external\\r\\n        view\\r\\n        returns (bool status)\\r\\n    {\\r\\n        status = (staker[_staker] \\u003e 0) ? true : false;\\r\\n    }\\r\\n}\"},\"Migrations.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.7.6;\\r\\n\\r\\ncontract Migrations {\\r\\n    address public owner;\\r\\n    uint public last_completed_migration;\\r\\n\\r\\n    constructor() {\\r\\n        owner = msg.sender;\\r\\n    }\\r\\n\\r\\n    modifier restricted() {\\r\\n        if (msg.sender == owner)\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function setCompleted(uint completed) public restricted {\\r\\n        last_completed_migration = completed;\\r\\n    }\\r\\n\\r\\n    function upgrade(address new_address) public restricted {\\r\\n        Migrations upgraded = Migrations(new_address);\\r\\n        upgraded.setCompleted(last_completed_migration);\\r\\n    }\\r\\n}\\r\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: --GRISE--\\r\\n\\r\\npragma solidity =0.7.6;\\r\\n\\r\\nlibrary SafeMath {\\r\\n\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\u0027GRISE: SafeMath Add failed\\u0027);\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, \\u0027GRISE: SafeMath Sub failed\\u0027);\\r\\n        uint256 c = a - b;\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n\\r\\n        if (a == 0 || b == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\u0027GRISE: SafeMath Mul failed\\u0027);\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        \\r\\n        if (b == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a / b;\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b != 0, \\u0027GRISE: SafeMath Mod failed\\u0027);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\"},\"Timing.sol\":{\"content\":\"// SPDX-License-Identifier: --GRISE--\\r\\n\\r\\npragma solidity =0.7.6;\\r\\n\\r\\nimport \\\"./Declaration.sol\\\";\\r\\n\\r\\nabstract contract Timing is Declaration {\\r\\n\\r\\n    function currentLPDay() public view returns (uint256) {\\r\\n        return _getNow() \\u003e= LP_LAUNCH_TIME ? _currentLPDay() : 0;\\r\\n    } \\r\\n\\r\\n    function _currentLPDay() internal view returns (uint256) {\\r\\n        return _LPDayFromStamp(_getNow()) + 1;\\r\\n    }\\r\\n\\r\\n    function _LPDayFromStamp(uint256 _timestamp) internal view returns (uint256) {\\r\\n        return uint256((_timestamp - LP_LAUNCH_TIME) / SECONDS_IN_DAY_LP);\\r\\n    }\\r\\n\\r\\n    function currentGriseWeek() public view returns (uint256) {\\r\\n        return (currentGriseDay() / GRISE_WEEK);\\r\\n    }\\r\\n\\r\\n    function currentGriseDay() public view returns (uint256) {\\r\\n        return _getNow() \\u003e= LAUNCH_TIME ? _currentGriseDay() : 0;\\r\\n    }\\r\\n\\r\\n    function _currentGriseDay() internal view returns (uint256) {\\r\\n        return _griseDayFromStamp(_getNow());\\r\\n    }\\r\\n\\r\\n    function _nextGriseDay() internal view returns (uint256) {\\r\\n        return _currentGriseDay() + 1;\\r\\n    }\\r\\n\\r\\n    function _previousGriseDay() internal view returns (uint256) {\\r\\n        return _currentGriseDay() - 1;\\r\\n    }\\r\\n\\r\\n    function _griseDayFromStamp(uint256 _timestamp) internal view returns (uint256) {\\r\\n        return uint256((_timestamp - LAUNCH_TIME) / SECONDS_IN_DAY);\\r\\n    }\\r\\n\\r\\n    function _getNow() internal view returns (uint256) {\\r\\n        return block.timestamp;\\r\\n    }\\r\\n}\"},\"Utils.sol\":{\"content\":\"// SPDX-License-Identifier: --GRISE--\\r\\n\\r\\npragma solidity =0.7.6;\\r\\n\\r\\nimport \\\"./Timing.sol\\\";\\r\\n\\r\\nabstract contract Utils is Timing {\\r\\n\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    function toUint256(bytes memory _bytes)   \\r\\n    internal\\r\\n    pure\\r\\n    returns (uint256 value) {\\r\\n\\r\\n    assembly {\\r\\n      value := mload(add(_bytes, 0x20))\\r\\n    }\\r\\n    }\\r\\n\\r\\n    function notContract(address _addr) internal view returns (bool) {\\r\\n        uint32 size;\\r\\n        assembly {\\r\\n            size := extcodesize(_addr)\\r\\n        }\\r\\n        return (size == 0);\\r\\n    }\\r\\n\\r\\n    function toBytes16(uint256 x) internal pure returns (bytes16 b) {\\r\\n       return bytes16(bytes32(x));\\r\\n    }\\r\\n    \\r\\n    function _notFuture(uint256 _day) internal view returns (bool) {\\r\\n        return _day \\u003c= _currentGriseDay();\\r\\n    }\\r\\n\\r\\n    function _notPast(uint256 _day) internal view returns (bool) {\\r\\n        return _day \\u003e= _currentGriseDay();\\r\\n    }\\r\\n\\r\\n    function _nonZeroAddress(address _address) internal pure returns (bool) {\\r\\n        return _address != address(0x0);\\r\\n    }\\r\\n\\r\\n    function _calculateSellTranscFee(uint256 _tAmount) internal pure returns (uint256) {\\r\\n        return _tAmount.mul(SELL_TRANS_FEE).div(REWARD_PRECISION_RATE);\\r\\n    }\\r\\n\\r\\n    function _calculateBuyTranscFee(uint256 _tAmount) internal pure returns (uint256) {\\r\\n        return _tAmount.mul(BUY_TRANS_FEE).div(REWARD_PRECISION_RATE);\\r\\n    }\\r\\n    \\r\\n    function calculateGriseWeek(uint256 _day) internal pure returns (uint256) {\\r\\n        return (_day / GRISE_WEEK);\\r\\n    }\\r\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"tokenName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"tokenSymbol\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenHolderAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"griseWeek\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimedAmount\",\"type\":\"uint256\"}],\"name\":\"TranscFeeClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"LIQUIDITY_GATEKEEPER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STAKE_GATEKEEPER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VAULT_GATEKEEPER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOfStaker\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_investorAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burnSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimTokenHolderTranscReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentGriseDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentGriseWeek\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentLPDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEpocTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLPLaunchTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLaunchTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fromDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_toDay\",\"type\":\"uint256\"}],\"name\":\"getReservoirReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fromDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_toDay\",\"type\":\"uint256\"}],\"name\":\"getTokenHolderReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fromDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_toDay\",\"type\":\"uint256\"}],\"name\":\"getTransFeeReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"isStaker\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_investorAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mintSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"resetStaker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_immutableGateKeeper\",\"type\":\"address\"}],\"name\":\"setLiquidtyGateKeeper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_immutableGateKeeper\",\"type\":\"address\"}],\"name\":\"setStakeGateKeeper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"setStaker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_immutableGateKeeper\",\"type\":\"address\"}],\"name\":\"setVaultGateKeeper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeToClaimMonthlyReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_days\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeToClaimWeeklyReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_days\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_shares\",\"type\":\"uint256\"}],\"name\":\"updateMedTermShares\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakedToken\",\"type\":\"uint256\"}],\"name\":\"updateStakedToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewTokenHolderTranscReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "GriseToken", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000b475249534520544f4b454e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044752534500000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://93537cbdcf92071b83c90a906e00dd6e5d4a006ad23d8d948d9395e4ca34eee5"}