{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.18;\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the token decimals.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Returns the token symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token name.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the ERC token owner.\r\n     */\r\n    function getOwner() external view returns (address);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(\r\n        address _owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    constructor() {\r\n        _owner = msg.sender;\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == _owner, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        if (newOwner != address(0)) {\r\n            _owner = newOwner;\r\n        }\r\n    }\r\n\r\n    function MS() internal view returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\ncontract WorkAccurate is Ownable {\r\n    // **********************************\r\n    // Primary Data\r\n    // **********************************\r\n    using SafeMath for uint256;\r\n    IERC20 public tether;\r\n    IERC20 public token;\r\n    address public dwbTokenAddress;\r\n    uint8 public plan1Percent;\r\n    uint8 public plan2Percent;\r\n    uint8 public tokenPercent;\r\n    uint256 public plan1Liquidity;\r\n    uint256 public plan2Liquidity;\r\n    uint256 public plan1LastDistribution;\r\n    uint256 public plan2LastDistribution;\r\n    mapping(uint256 => uint256) public _balances;\r\n    mapping(uint256 => uint8) public _userTokenPercent;\r\n    mapping(uint256 => uint256) public _userTokenCharge;\r\n    uint256 public accurateShare = 1000000;\r\n    uint256 public accurateSharePrice = 20000 ether;\r\n    mapping(uint256 => uint256) public _accurateShareBalances;\r\n    uint256 private lastReferral;\r\n    uint256 startTime = block.timestamp - 6 days;\r\n\r\n    struct Position {\r\n        address wallet;\r\n        uint256 parent;\r\n        bool isLeft;\r\n        uint256 charged;\r\n        uint256 referral;\r\n        uint8 referralSide;\r\n        uint256 leftChild;\r\n        uint256 rightChild;\r\n        string name;\r\n        uint256 lastActivate;\r\n    }\r\n    Position[] public positions;\r\n\r\n    mapping(uint256 => uint256) public commissions;\r\n\r\n    struct Deposit {\r\n        uint256 amount;\r\n        uint256 timestamp;\r\n    }\r\n    mapping(uint256 => Deposit[]) public deposits;\r\n    // uint256 Position index => struct Deposit\r\n\r\n    struct Transaction {\r\n        uint256 poIndex;\r\n        uint8 txType;\r\n        uint256 amount;\r\n        uint256 time;\r\n    }\r\n    Transaction[] public transactions;\r\n\r\n    // Transaction Types\r\n    // 1.Join\r\n    // 2.Charge\r\n    // 3.Topup\r\n    // 4.Plan1 Commission\r\n    // 5.Plan2 DWB Commission\r\n    // 6.Plan2 Commission (Tether And DWB)\r\n    // 7.Withdraw\r\n    // 8.Withdraw DWB\r\n    // 9.Unsuccessful token purchase refund\r\n    // 10.ICO Share\r\n    // 11.Buy ICO\r\n    // 12.Sell ICO\r\n    // 13.Transfer Out ICO\r\n    // 14.Transfer In ICO\r\n    // 15.ICO: Project Profit\r\n\r\n    constructor() {\r\n        tether = IERC20(0x55d398326f99059fF775485246999027B3197955);\r\n        token = IERC20(0x10f28281B99B3e20D4324C4F434FDdCC3DA5D7df);\r\n        dwbTokenAddress = address(0x10f28281B99B3e20D4324C4F434FDdCC3DA5D7df);\r\n        plan1Percent = 50;\r\n        plan2Percent = 50;\r\n        tokenPercent = 20;\r\n        plan1LastDistribution = plan2LastDistribution = startTime;\r\n        address wallet0 = 0xAB6BcCec0022FBBbee0F73012752365A9b61A255;\r\n\r\n        addPosition(wallet0, 0, true, 100 ether);\r\n        deposits[0].push(Deposit({amount: 100 ether, timestamp: startTime}));\r\n        reportsFun(1, 0, 100 ether);\r\n\r\n        plan1Liquidity = 50 ether;\r\n        plan2Liquidity = 50 ether;\r\n\r\n        _accurateShareBalances[0] = accurateShare;\r\n    }\r\n\r\n    // **********************************\r\n    // Setting\r\n    // **********************************\r\n\r\n    function setting() public {\r\n        if (SafeMath.sub(block.timestamp, startTime) >= 365 days) {\r\n            plan1Percent = 60;\r\n            plan2Percent = 40;\r\n        }\r\n        if (SafeMath.sub(block.timestamp, startTime) >= 2 * 365 days) {\r\n            plan1Percent = 70;\r\n            plan2Percent = 30;\r\n        }\r\n        if (SafeMath.sub(block.timestamp, startTime) >= 3 * 365 days) {\r\n            plan1Percent = 80;\r\n            plan2Percent = 20;\r\n        }\r\n    }\r\n\r\n    // **********************************\r\n    // Main Functions\r\n    // **********************************\r\n\r\n    function myPI() internal view returns (uint256 _myPI) {\r\n        require(addressExists(MS()), \"Not Registered\");\r\n        _myPI = pIndex(MS());\r\n    }\r\n\r\n    function pIndex(\r\n        address _address\r\n    ) internal view returns (uint256 positionIndex) {\r\n        require(addressExists(_address), \"Not Registered\");\r\n        for (uint i = 0; i < positions.length; i++) {\r\n            if (positions[i].wallet == _address) {\r\n                positionIndex = i;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function addressExists(address _address) public view returns (bool) {\r\n        for (uint256 i = 0; i < positions.length; i++) {\r\n            if (positions[i].wallet == _address) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function getReferrer(\r\n        uint256 _referral\r\n    ) internal view returns (uint256 poIndex) {\r\n        for (uint256 i = 0; i < positions.length; i++) {\r\n            uint256 thisReferral = positions[i].referral;\r\n            if (thisReferral == _referral) {\r\n                poIndex = i;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getLastUser(\r\n        uint256 _node\r\n    )\r\n        internal\r\n        view\r\n        returns (\r\n            uint256 parentLeft,\r\n            uint256 leftCount,\r\n            uint256 parentRight,\r\n            uint256 rightCount\r\n        )\r\n    {\r\n        parentLeft = _node;\r\n        parentRight = _node;\r\n        leftCount = 0;\r\n        rightCount = 0;\r\n        uint256 currentLeft = positions[_node].leftChild;\r\n        uint256 currentRight = positions[_node].rightChild;\r\n\r\n        while (currentLeft != 0) {\r\n            parentLeft = currentLeft;\r\n            leftCount++;\r\n            currentLeft = positions[currentLeft].leftChild;\r\n        }\r\n        while (currentRight != 0) {\r\n            parentRight = currentRight;\r\n            rightCount++;\r\n            currentRight = positions[currentRight].rightChild;\r\n        }\r\n    }\r\n\r\n    function getParentSide(\r\n        uint256 _referrer\r\n    ) internal view returns (uint256, bool) {\r\n        (\r\n            uint256 leftUser,\r\n            uint256 leftCount,\r\n            uint256 rightUser,\r\n            uint256 rightCount\r\n        ) = getLastUser(_referrer);\r\n\r\n        uint8 referralSide = positions[_referrer].referralSide;\r\n        if (referralSide == 0) {\r\n            if (leftCount <= rightCount) {\r\n                return (leftUser, true);\r\n            } else {\r\n                return (rightUser, false);\r\n            }\r\n        } else if (referralSide == 1) {\r\n            return (leftUser, true);\r\n        } else {\r\n            return (rightUser, false);\r\n        }\r\n    }\r\n\r\n    function createReferral() internal returns (uint256 newReferral) {\r\n        newReferral = SafeMath.add(block.timestamp, positions.length);\r\n        while (newReferral == lastReferral) {\r\n            newReferral = SafeMath.add(newReferral, 1);\r\n        }\r\n        lastReferral = newReferral;\r\n    }\r\n\r\n    function addPosition(\r\n        address _wallet,\r\n        uint256 _parentI,\r\n        bool _isLeft,\r\n        uint256 _amount\r\n    ) internal {\r\n        positions.push(\r\n            Position({\r\n                wallet: _wallet,\r\n                parent: _parentI,\r\n                isLeft: _isLeft,\r\n                charged: _amount,\r\n                referral: createReferral(),\r\n                referralSide: 0,\r\n                leftChild: 0,\r\n                rightChild: 0,\r\n                name: \"Unset\",\r\n                lastActivate: block.timestamp\r\n            })\r\n        );\r\n    }\r\n\r\n    function addChild(\r\n        uint256 _referral,\r\n        address _child,\r\n        uint256 _amount\r\n    ) internal returns (bool done) {\r\n        uint256 referrer = getReferrer(_referral);\r\n        if (referrer != 0) {\r\n            (uint256 parent, bool isLeft) = getParentSide(referrer);\r\n            if (isLeft) {\r\n                if (positions[parent].leftChild == 0) {\r\n                    addPosition(_child, parent, isLeft, _amount);\r\n                    positions[parent].leftChild = pIndex(_child);\r\n                    done = true;\r\n                }\r\n            } else {\r\n                if (positions[parent].rightChild == 0) {\r\n                    addPosition(_child, parent, isLeft, _amount);\r\n                    positions[parent].rightChild = pIndex(_child);\r\n                    done = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function reportsFun(\r\n        uint8 _type,\r\n        uint256 _pIndex,\r\n        uint256 _amount\r\n    ) internal {\r\n        transactions.push(\r\n            Transaction({\r\n                poIndex: _pIndex,\r\n                txType: _type,\r\n                amount: _amount,\r\n                time: block.timestamp\r\n            })\r\n        );\r\n    }\r\n\r\n    function addBalance(uint256 _pIndex, uint256 _amount) internal {\r\n        _balances[_pIndex] = SafeMath.add(_balances[_pIndex], _amount);\r\n    }\r\n\r\n    function subBalance(uint256 _pIndex, uint256 _amount) internal {\r\n        _balances[_pIndex] = SafeMath.sub(_balances[_pIndex], _amount);\r\n    }\r\n\r\n    function addPlansLiquidity(uint256 _amount) internal {\r\n        plan1Liquidity = SafeMath.add(\r\n            plan1Liquidity,\r\n            SafeMath.div(SafeMath.mul(_amount, plan1Percent), 100)\r\n        );\r\n        plan2Liquidity = SafeMath.add(\r\n            plan2Liquidity,\r\n            SafeMath.div(SafeMath.mul(_amount, plan2Percent), 100)\r\n        );\r\n    }\r\n\r\n    function join(uint256 _referral, uint256 _amount) external payable {\r\n        require(!addressExists(MS()), \"Registered before\");\r\n        require(\r\n            _amount == 101 ether ||\r\n                _amount == 201 ether ||\r\n                _amount == 301 ether ||\r\n                _amount == 401 ether ||\r\n                _amount == 501 ether,\r\n            \"Amount is not enough.\"\r\n        );\r\n        require(\r\n            tether.allowance(MS(), address(this)) >= _amount,\r\n            \"Tether allowance not enough\"\r\n        );\r\n        require(\r\n            tether.balanceOf(MS()) >= _amount,\r\n            \"Insufficient tether balance\"\r\n        );\r\n\r\n        uint256 remain = SafeMath.sub(_amount, 1 ether);\r\n\r\n        bool done;\r\n        done = addChild(_referral, MS(), remain);\r\n        if (done) {\r\n            tether.transferFrom(MS(), address(this), _amount);\r\n            addBalance(3, 1 ether);\r\n            addPlansLiquidity(remain);\r\n            deposits[myPI()].push(\r\n                Deposit({amount: remain, timestamp: block.timestamp})\r\n            );\r\n            reportsFun(1, myPI(), remain);\r\n        }\r\n    }\r\n\r\n    function charge(uint256 _amount) external payable {\r\n        require(_amount > 0, \"Zero amount.\");\r\n        require(addressExists(MS()), \"Not Registered\");\r\n        require(\r\n            tether.allowance(MS(), address(this)) >= _amount,\r\n            \"Tether allowance not enough\"\r\n        );\r\n        require(\r\n            tether.balanceOf(MS()) >= _amount,\r\n            \"Insufficient tether balance\"\r\n        );\r\n        tether.transferFrom(MS(), address(this), _amount);\r\n        addBalance(myPI(), _amount);\r\n        reportsFun(2, myPI(), _amount);\r\n    }\r\n\r\n    function topupAmount(\r\n        uint256 _amount\r\n    ) internal view returns (uint256 chargeAmount) {\r\n        uint256 maxAmount = SafeMath.sub(500 ether, positions[myPI()].charged);\r\n        chargeAmount = _amount;\r\n        if (chargeAmount > maxAmount) {\r\n            chargeAmount = maxAmount;\r\n        }\r\n    }\r\n\r\n    function topup(uint256 _amount) public {\r\n        require(addressExists(MS()), \"Not Registered\");\r\n        require(\r\n            _amount == 100 ether ||\r\n                _amount == 200 ether ||\r\n                _amount == 300 ether ||\r\n                _amount == 400 ether,\r\n            \"Wrong amount.\"\r\n        );\r\n        require(\r\n            _balances[myPI()] >= SafeMath.add(_amount, 1 ether) &&\r\n                positions[myPI()].charged < 500 ether,\r\n            \"Amount is not enough.\"\r\n        );\r\n\r\n        uint256 chargeAmount = topupAmount(_amount);\r\n\r\n        addBalance(3, 1 ether);\r\n        subBalance(myPI(), SafeMath.add(chargeAmount, 1 ether));\r\n        positions[myPI()].charged = SafeMath.add(\r\n            positions[myPI()].charged,\r\n            chargeAmount\r\n        );\r\n        positions[myPI()].lastActivate = block.timestamp;\r\n        addPlansLiquidity(chargeAmount);\r\n        deposits[myPI()].push(\r\n            Deposit({amount: chargeAmount, timestamp: block.timestamp})\r\n        );\r\n        reportsFun(3, myPI(), chargeAmount);\r\n    }\r\n\r\n    //**********************************************************************************\r\n    function pLeftCount(uint256 _pIndex) public view returns (uint256 count) {\r\n        uint256 endTime = plan1LastDistribution + 30 days;\r\n        uint256 left = positions[_pIndex].leftChild;\r\n        if (left != 0) {\r\n            for (uint256 j = 0; j < deposits[left].length; j++) {\r\n                if (\r\n                    deposits[left][j].timestamp >= plan1LastDistribution &&\r\n                    deposits[left][j].timestamp < endTime\r\n                ) {\r\n                    count = SafeMath.add(count, deposits[left][j].amount);\r\n                }\r\n            }\r\n            count = SafeMath.add(count, totalDeposits(left, endTime));\r\n        }\r\n    }\r\n\r\n    function pRightCount(uint256 _pIndex) public view returns (uint256 count) {\r\n        uint256 endTime = plan1LastDistribution + 30 days;\r\n        uint256 right = positions[_pIndex].rightChild;\r\n        if (right != 0) {\r\n            for (uint256 j = 0; j < deposits[right].length; j++) {\r\n                if (\r\n                    deposits[right][j].timestamp >= plan1LastDistribution &&\r\n                    deposits[right][j].timestamp < endTime\r\n                ) {\r\n                    count = SafeMath.add(count, deposits[right][j].amount);\r\n                }\r\n            }\r\n            count = SafeMath.add(count, totalDeposits(right, endTime));\r\n        }\r\n    }\r\n\r\n    function totalDeposits(\r\n        uint256 _pIndex,\r\n        uint256 _endTime\r\n    ) public view returns (uint256 totalCharged) {\r\n        uint256 childCount = 0;\r\n        for (uint256 i = _pIndex + 1; i < positions.length; i++) {\r\n            if (positions[i].parent == _pIndex) {\r\n                childCount++;\r\n                for (uint256 j = 0; j < deposits[i].length; j++) {\r\n                    if (\r\n                        deposits[i][j].timestamp >= plan1LastDistribution &&\r\n                        deposits[i][j].timestamp < _endTime\r\n                    ) {\r\n                        totalCharged = SafeMath.add(\r\n                            totalCharged,\r\n                            deposits[i][j].amount\r\n                        );\r\n                    }\r\n                }\r\n                totalCharged = SafeMath.add(\r\n                    totalCharged,\r\n                    totalDeposits(i, _endTime)\r\n                );\r\n            }\r\n            if (childCount >= 2) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getPositionDiagramBalance(\r\n        uint256 _pIndex\r\n    ) public view returns (uint256 thisBalance) {\r\n        uint256 leftAmount = pLeftCount(_pIndex);\r\n        uint256 rightAmount = pRightCount(_pIndex);\r\n\r\n        thisBalance = leftAmount;\r\n        if (rightAmount < leftAmount) {\r\n            thisBalance = rightAmount;\r\n        }\r\n        thisBalance = SafeMath.div(thisBalance, 100 ether);\r\n    }\r\n\r\n    function getTotalDiagramBalance()\r\n        public\r\n        view\r\n        returns (uint256 totalDiagramBalance)\r\n    {\r\n        for (uint256 i = 0; i < positions.length; i++) {\r\n            uint256 thisBalance = getPositionDiagramBalance(i);\r\n            totalDiagramBalance = SafeMath.add(\r\n                totalDiagramBalance,\r\n                thisBalance\r\n            );\r\n        }\r\n    }\r\n\r\n    function checkCeiling(uint256 _pI) public view returns (uint256 ceilling) {\r\n        uint256 charged = positions[_pI].charged;\r\n        if (charged <= 100 ether) {\r\n            ceilling = 15000 ether;\r\n        } else if (charged <= 200 ether) {\r\n            ceilling = 30000 ether;\r\n        } else {\r\n            ceilling = 60000 ether;\r\n        }\r\n    }\r\n\r\n    function recivedCommission(\r\n        uint256 _pI\r\n    ) public view returns (uint256 recived) {\r\n        recived = commissions[_pI];\r\n    }\r\n\r\n    function sendPlan1Commission(uint256 _pI, uint256 _commission) internal {\r\n        commissions[_pI] = 0;\r\n        addBalance(_pI, _commission);\r\n        reportsFun(4, _pI, _commission);\r\n    }\r\n\r\n    function getTotalPlan2() public view returns (uint256 totalPlan2) {\r\n        for (uint256 i = 0; i < positions.length; i++) {\r\n            if (pLastActivate(i)) {\r\n                totalPlan2 = SafeMath.add(totalPlan2, 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    function pLastActivate(uint256 _pIndex) public view returns (bool) {\r\n        uint256 lastActivate = positions[_pIndex].lastActivate;\r\n        uint256 target = SafeMath.sub(plan2LastDistribution, 52.5 * 1 days);\r\n        if (lastActivate >= target || positions[_pIndex].charged == 500 ether) {\r\n            return true;\r\n        }\r\n        return pChildLastActivate(_pIndex, target);\r\n    }\r\n\r\n    function pChildLastActivate(\r\n        uint256 _pIndex,\r\n        uint256 _target\r\n    ) internal view returns (bool) {\r\n        for (uint256 i = _pIndex + 1; i < positions.length; i++) {\r\n            if (positions[i].parent == _pIndex) {\r\n                if (positions[i].lastActivate >= _target) {\r\n                    return true;\r\n                }\r\n                if (pChildLastActivate(i, _target)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function positionPlan2(\r\n        uint256 _pI\r\n    ) public view returns (bool can, uint256 maxRecive) {\r\n        if (pLastActivate(_pI)) {\r\n            uint256 ceiling = checkCeiling(_pI);\r\n            uint256 recived = recivedCommission(_pI);\r\n            if (recived < ceiling) {\r\n                can = true;\r\n                maxRecive = SafeMath.sub(ceiling, recived);\r\n            } else {\r\n                maxRecive = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    function sendPlan2Commission(uint256 _pI, uint256 _commission) internal {\r\n        commissions[_pI] = SafeMath.add(commissions[_pI], _commission);\r\n\r\n        uint256 tokenAmount = commissionToken(\r\n            positions[_pI].wallet,\r\n            _commission\r\n        );\r\n        _userTokenCharge[_pI] = SafeMath.add(\r\n            _userTokenCharge[_pI],\r\n            tokenAmount\r\n        );\r\n\r\n        uint256 pureCommission = SafeMath.sub(_commission, tokenAmount);\r\n        addBalance(_pI, pureCommission);\r\n        reportsFun(6, _pI, _commission);\r\n    }\r\n\r\n    function commissionToken(\r\n        address _address,\r\n        uint256 _amount\r\n    ) internal view returns (uint256 tokenAmount) {\r\n        uint256 pI = pIndex(_address);\r\n        uint256 thisCommissionTokenFee = tokenPercent;\r\n        if (_userTokenPercent[pI] > tokenPercent) {\r\n            thisCommissionTokenFee = _userTokenPercent[pI];\r\n        }\r\n        tokenAmount = SafeMath.div(\r\n            SafeMath.mul(_amount, thisCommissionTokenFee),\r\n            100\r\n        );\r\n    }\r\n\r\n    uint256 public plan2PerPerson;\r\n    uint256 public lastPlan2Reciver;\r\n\r\n    function distributionP2(uint256 _num) public {\r\n        if (block.timestamp >= plan2LastDistribution + 7.5 * 1 days) {\r\n            if (plan2PerPerson != 0) {\r\n                uint256 first = lastPlan2Reciver + 1;\r\n                uint256 last = lastPlan2Reciver + _num;\r\n                if (positions.length - 1 < last) {\r\n                    last = positions.length - 1;\r\n                }\r\n                uint256 totalCom;\r\n                for (uint256 i = first; i <= last; i++) {\r\n                    (bool can, uint256 maxRecive) = positionPlan2(i);\r\n                    if (can) {\r\n                        uint256 thisCom = plan2PerPerson;\r\n                        if (plan2PerPerson > maxRecive) {\r\n                            thisCom = maxRecive;\r\n                        }\r\n                        sendPlan2Commission(i, thisCom);\r\n                        totalCom = SafeMath.add(totalCom, thisCom);\r\n                    }\r\n                }\r\n                lastPlan2Reciver = last;\r\n                plan2Liquidity = SafeMath.sub(plan2Liquidity, totalCom);\r\n                if (lastPlan2Reciver == positions.length - 1) {\r\n                    plan2LastDistribution = SafeMath.add(\r\n                        plan2LastDistribution,\r\n                        7.5 * 1 days\r\n                    );\r\n                    plan2PerPerson = 0;\r\n                }\r\n            } else {\r\n                if (plan2Liquidity != 0 && getTotalPlan2() != 0) {\r\n                    plan2PerPerson = SafeMath.div(\r\n                        plan2Liquidity,\r\n                        getTotalPlan2()\r\n                    );\r\n                    lastPlan2Reciver = 0;\r\n                    (bool can, uint256 maxRecive) = positionPlan2(0);\r\n                    if (can) {\r\n                        uint256 thisCom = plan2PerPerson;\r\n                        if (plan2PerPerson > maxRecive) {\r\n                            thisCom = maxRecive;\r\n                        }\r\n                        sendPlan2Commission(0, thisCom);\r\n                        plan2Liquidity = SafeMath.sub(plan2Liquidity, thisCom);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    uint256 public plan1PerBalance;\r\n    uint256 public lastPlan1Reciver;\r\n\r\n    function distributionP1(uint256 _num) public {\r\n        if (block.timestamp >= plan1LastDistribution + 30 days) {\r\n            if (plan1PerBalance != 0) {\r\n                uint256 first = lastPlan1Reciver + 1;\r\n                uint256 last = lastPlan1Reciver + _num;\r\n                if (positions.length - 1 < last) {\r\n                    last = positions.length - 1;\r\n                }\r\n                uint256 totalCom;\r\n                for (uint256 i = first; i <= last; i++) {\r\n                    uint256 balance = getPositionDiagramBalance(i);\r\n                    if (balance != 0) {\r\n                        uint256 commission = SafeMath.mul(\r\n                            balance,\r\n                            plan1PerBalance\r\n                        );\r\n                        uint256 ceiling = checkCeiling(i);\r\n                        uint256 recived = recivedCommission(i);\r\n\r\n                        if (recived < ceiling) {\r\n                            uint256 thisCom = commission;\r\n                            if (SafeMath.add(recived, commission) > ceiling) {\r\n                                thisCom = SafeMath.sub(ceiling, recived);\r\n                            }\r\n                            sendPlan1Commission(i, thisCom);\r\n                            totalCom = SafeMath.add(totalCom, thisCom);\r\n                        }\r\n                    }\r\n                }\r\n                lastPlan1Reciver = last;\r\n                plan1Liquidity = SafeMath.sub(plan1Liquidity, totalCom);\r\n\r\n                if (lastPlan1Reciver == positions.length - 1) {\r\n                    plan1LastDistribution = SafeMath.add(\r\n                        plan1LastDistribution,\r\n                        30 days\r\n                    );\r\n                    plan1PerBalance = 0;\r\n                }\r\n            } else {\r\n                if (plan1Liquidity != 0 && getTotalDiagramBalance() != 0) {\r\n                    plan1PerBalance = SafeMath.div(\r\n                        plan1Liquidity,\r\n                        getTotalDiagramBalance()\r\n                    );\r\n                    lastPlan1Reciver = 0;\r\n                    uint256 balance = getPositionDiagramBalance(0);\r\n                    if (balance != 0) {\r\n                        uint256 commission = SafeMath.mul(\r\n                            balance,\r\n                            plan1PerBalance\r\n                        );\r\n                        uint256 ceiling = checkCeiling(0);\r\n                        uint256 recived = recivedCommission(0);\r\n\r\n                        if (recived < ceiling) {\r\n                            uint256 thisCom = commission;\r\n                            if (SafeMath.add(recived, commission) > ceiling) {\r\n                                thisCom = SafeMath.sub(ceiling, recived);\r\n                            }\r\n                            sendPlan1Commission(0, thisCom);\r\n                            plan1Liquidity = SafeMath.sub(\r\n                                plan1Liquidity,\r\n                                thisCom\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // **********************************\r\n    // User Setting\r\n    // **********************************\r\n\r\n    function setName(string memory _newName) public {\r\n        positions[myPI()].name = _newName;\r\n    }\r\n\r\n    function changePositionWallet(address _newWallet) public {\r\n        require(addressExists(MS()), \"Not registered\");\r\n        require(!addressExists(_newWallet), \"Address exists\");\r\n        positions[myPI()].wallet = _newWallet;\r\n    }\r\n\r\n    function setReferralSide(uint8 _newSide) public {\r\n        require(_newSide == 0 || _newSide == 1 || _newSide == 2, \"Wrong side.\");\r\n        positions[myPI()].referralSide = _newSide;\r\n    }\r\n\r\n    function setUserTokenPercent(uint8 _newPercent) public {\r\n        require(\r\n            _newPercent >= tokenPercent,\r\n            \"Percent should be >= tokenPercent.\"\r\n        );\r\n        require(_newPercent <= 100, \"Token percent should be <= plan2Percent.\");\r\n        _userTokenPercent[myPI()] = _newPercent;\r\n    }\r\n\r\n    // **********************************\r\n    // Withdraw Tether\r\n    // **********************************\r\n    function withdraw(uint256 _amount) public {\r\n        require(addressExists(MS()), \"Not registered\");\r\n        // _amount is Tether\r\n        require(_amount > 0, \"Zero?\");\r\n        if (myPI() != 0 && myPI() != 1 && myPI() != 2) {\r\n            // Users\r\n            require(_balances[myPI()] >= _amount, \"Insufficient balance.\");\r\n            _balances[myPI()] = SafeMath.sub(_balances[myPI()], _amount);\r\n            require(tether.transfer(MS(), _amount), \"Tether transfer failed\");\r\n            reportsFun(7, myPI(), _amount);\r\n            buyToken(MS(), _userTokenCharge[myPI()]);\r\n        } else {\r\n            // Owners\r\n            uint256 totalTokenCharge = SafeMath.add(\r\n                _userTokenCharge[0],\r\n                SafeMath.add(_userTokenCharge[1], _userTokenCharge[2])\r\n            );\r\n            if (totalTokenCharge > 0) {\r\n                buyToken(\r\n                    positions[0].wallet,\r\n                    SafeMath.div(totalTokenCharge, 3)\r\n                );\r\n                buyToken(\r\n                    positions[1].wallet,\r\n                    SafeMath.div(totalTokenCharge, 3)\r\n                );\r\n                buyToken(\r\n                    positions[2].wallet,\r\n                    SafeMath.div(totalTokenCharge, 3)\r\n                );\r\n            }\r\n            uint256 totalAmount = SafeMath.add(\r\n                _balances[0],\r\n                SafeMath.add(_balances[1], _balances[2])\r\n            );\r\n            if (totalAmount > 0) {\r\n                _balances[0] = _balances[1] = _balances[2] = 0;\r\n                uint256 per = SafeMath.div(totalAmount, 3);\r\n                require(\r\n                    tether.transfer(positions[0].wallet, per),\r\n                    \"Tether transfer failed\"\r\n                );\r\n                require(\r\n                    tether.transfer(positions[1].wallet, per),\r\n                    \"Tether transfer failed\"\r\n                );\r\n                require(\r\n                    tether.transfer(positions[2].wallet, per),\r\n                    \"Tether transfer failed\"\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    function buyToken(address _address, uint256 _amount) internal {\r\n        if (_amount > 0) {\r\n            uint256 pI = pIndex(_address);\r\n            tether.approve(dwbTokenAddress, _amount);\r\n            (bool success, ) = address(dwbTokenAddress).call(\r\n                abi.encodeWithSignature(\r\n                    \"buy(address,uint256)\",\r\n                    _address,\r\n                    _amount\r\n                )\r\n            );\r\n            if (success) {\r\n                _userTokenCharge[pI] = 0;\r\n                reportsFun(8, pI, _amount);\r\n            } else {\r\n                _balances[pI] = SafeMath.add(_balances[pI], _amount);\r\n                reportsFun(9, pI, _amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    // **********************************\r\n    // Get Public Data\r\n    // **********************************\r\n\r\n    function getDeposits(\r\n        address _wallet\r\n    ) public view returns (Deposit[] memory) {\r\n        require(addressExists(_wallet), \"Not registered\");\r\n        return (deposits[pIndex(_wallet)]);\r\n    }\r\n\r\n    function getPositions() public view returns (Position[] memory) {\r\n        return positions;\r\n    }\r\n\r\n    function getPositionIndex(address _wallet) public view returns (uint256) {\r\n        require(addressExists(_wallet), \"Not registered\");\r\n        for (uint256 i = 0; i < positions.length; i++) {\r\n            if (positions[i].wallet == _wallet) {\r\n                return i;\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function getPositionByWallet(\r\n        address _wallet\r\n    ) public view returns (uint256, Position memory) {\r\n        require(addressExists(_wallet), \"Not registered\");\r\n        for (uint256 i = 0; i < positions.length; i++) {\r\n            if (positions[i].wallet == _wallet) {\r\n                return (i, positions[i]);\r\n            }\r\n        }\r\n        return (0, positions[0]);\r\n    }\r\n\r\n    function getPositionById(\r\n        uint256 _pI\r\n    ) public view returns (Position memory) {\r\n        return positions[_pI];\r\n    }\r\n\r\n    function getTransactions() public view returns (Transaction[] memory) {\r\n        return transactions;\r\n    }\r\n\r\n    function getPositionTransactions(\r\n        uint256 _pI\r\n    ) public view returns (Transaction[] memory) {\r\n        Transaction[] memory positionTransactions = new Transaction[](\r\n            transactions.length + 1\r\n        );\r\n        for (uint i = 0; i < transactions.length; i++) {\r\n            if (transactions[i].poIndex == _pI) {\r\n                positionTransactions[i] = transactions[i];\r\n            }\r\n        }\r\n        return positionTransactions;\r\n    }\r\n\r\n    // After starting the new version, the owner cannot add new nodes.\r\n    bool public started;\r\n\r\n    function start() public onlyOwner {\r\n        started = true;\r\n    }\r\n\r\n    function lastVersionNodes(\r\n        address _node,\r\n        uint256 _parent,\r\n        bool _isLeft,\r\n        uint256 _amount,\r\n        string memory _name\r\n    ) public onlyOwner {\r\n        require(!started, \"Started\");\r\n        // After starting, owner cannot run this function.\r\n\r\n        require(!addressExists(_node), \"\");\r\n\r\n        bool done;\r\n        if (_isLeft) {\r\n            if (positions[_parent].leftChild == 0) {\r\n                addPosition(_node, _parent, _isLeft, _amount);\r\n                positions[_parent].leftChild = pIndex(_node);\r\n                done = true;\r\n            }\r\n        } else {\r\n            if (positions[_parent].rightChild == 0) {\r\n                addPosition(_node, _parent, _isLeft, _amount);\r\n                positions[_parent].rightChild = pIndex(_node);\r\n                done = true;\r\n            }\r\n        }\r\n        if (done) {\r\n            deposits[pIndex(_node)].push(\r\n                Deposit({amount: _amount, timestamp: block.timestamp})\r\n            );\r\n            positions[pIndex(_node)].name = _name;\r\n            reportsFun(1, pIndex(_node), _amount);\r\n\r\n            plan1Liquidity = SafeMath.add(\r\n                plan1Liquidity,\r\n                SafeMath.div(_amount, 2)\r\n            );\r\n            plan2Liquidity = SafeMath.add(\r\n                plan2Liquidity,\r\n                SafeMath.div(_amount, 2)\r\n            );\r\n        }\r\n    }\r\n\r\n    // ICO\r\n    function startICO(uint256 _amount) public payable {\r\n        // _amount is DWB Token\r\n        require(addressExists(MS()), \"Not registered\");\r\n        require(_amount > 0, \"Zero?\");\r\n        require(_amount % accurateSharePrice == 0, \"Amount % SharePrice != 0\");\r\n\r\n        // Do not accept extra amount.\r\n        uint256 share = SafeMath.div(_amount, accurateSharePrice);\r\n\r\n        require(\r\n            _accurateShareBalances[0] >= share,\r\n            \"Insufficient Owner share!\"\r\n        );\r\n\r\n        require(\r\n            token.allowance(MS(), address(this)) >=\r\n                SafeMath.div(SafeMath.mul(_amount, 102), 100),\r\n            \"Allowance not enough\"\r\n        );\r\n        require(\r\n            token.balanceOf(MS()) >=\r\n                SafeMath.div(SafeMath.mul(_amount, 102), 100),\r\n            \"Insufficient balance\"\r\n        );\r\n\r\n        token.transferFrom(MS(), address(this), _amount);\r\n\r\n        uint256 recivedAmount = SafeMath.div(SafeMath.mul(_amount, 99), 100);\r\n\r\n        distributionICO(recivedAmount);\r\n        signICO(share);\r\n    }\r\n\r\n    function distributionICO(uint256 _recivedAmount) private {\r\n        uint256 current = positions[myPI()].parent;\r\n        uint i = 0;\r\n        uint256 parentShare = SafeMath.div(\r\n            SafeMath.mul(_recivedAmount, 5),\r\n            100\r\n        );\r\n        uint256 paidAmount;\r\n        while (current != 0 && i < 3) {\r\n            require(\r\n                token.transfer(positions[current].wallet, parentShare),\r\n                \"Parent DWB transfer failed\"\r\n            );\r\n            reportsFun(10, current, parentShare);\r\n            paidAmount = SafeMath.add(\r\n                paidAmount,\r\n                SafeMath.div(SafeMath.mul(parentShare, 102), 100)\r\n            );\r\n            current = positions[current].parent;\r\n            i++;\r\n        }\r\n        uint256 ownerAmount = SafeMath.sub(_recivedAmount, paidAmount);\r\n        require(\r\n            token.transfer(\r\n                positions[0].wallet,\r\n                SafeMath.div(SafeMath.mul(ownerAmount, 100), 102)\r\n            ),\r\n            \"Owner DWB transfer failed\"\r\n        );\r\n        reportsFun(10, 0, ownerAmount);\r\n    }\r\n\r\n    function signICO(uint256 _share) private {\r\n        _accurateShareBalances[myPI()] = SafeMath.add(\r\n            _accurateShareBalances[myPI()],\r\n            _share\r\n        );\r\n        reportsFun(11, myPI(), _share);\r\n        _accurateShareBalances[0] = SafeMath.sub(\r\n            _accurateShareBalances[0],\r\n            _share\r\n        );\r\n        reportsFun(12, 0, _share);\r\n    }\r\n\r\n    function transferICO(uint256 _amount, address recipient) public {\r\n        require(recipient != address(0), \"Mint to the zero\");\r\n        require(addressExists(recipient), \"Not registered.\");\r\n        require(_amount > 0, \"Zero?\");\r\n        require(_accurateShareBalances[myPI()] >= _amount, \"\");\r\n\r\n        _accurateShareBalances[myPI()] = SafeMath.sub(\r\n            _accurateShareBalances[myPI()],\r\n            _amount\r\n        );\r\n        reportsFun(13, myPI(), _amount);\r\n        _accurateShareBalances[pIndex(recipient)] = SafeMath.add(\r\n            _accurateShareBalances[pIndex(recipient)],\r\n            _amount\r\n        );\r\n        reportsFun(14, pIndex(recipient), _amount);\r\n    }\r\n\r\n    function getICOBalances()\r\n        public\r\n        view\r\n        returns (address[] memory addresses, uint256[] memory balances)\r\n    {\r\n        for (uint256 i = 0; i < positions.length; i++) {\r\n            address wallet = positions[i].wallet;\r\n            uint256 balance = _accurateShareBalances[pIndex(wallet)];\r\n            if (balance > 0) {\r\n                addresses = pushAddress(addresses, wallet);\r\n                balances = pushUint(balances, balance);\r\n            }\r\n        }\r\n        return (addresses, balances);\r\n    }\r\n\r\n    //Add projects Profit to liquidity\r\n    function projectsProfit(uint256 _amount) public payable {\r\n        // _amount is Tether\r\n        require(_amount > 0, \"zero?\");\r\n        require(\r\n            tether.allowance(MS(), address(this)) >= _amount,\r\n            \"Tether allowance not enough\"\r\n        );\r\n        require(\r\n            tether.balanceOf(MS()) >= _amount,\r\n            \"Insufficient tether balance\"\r\n        );\r\n        tether.transferFrom(MS(), address(this), _amount);\r\n\r\n        uint256 thisShare = SafeMath.div(SafeMath.mul(_amount, 80), 100);\r\n        uint256 liquidityShare = SafeMath.div(SafeMath.mul(_amount, 20), 100);\r\n\r\n        (\r\n            address[] memory addresses,\r\n            uint256[] memory balances\r\n        ) = getICOBalances();\r\n\r\n        for (uint256 i = 0; i < addresses.length; i++) {\r\n            address wallet = addresses[i];\r\n            uint256 balance = balances[i];\r\n            uint256 walletShare = SafeMath.mul(\r\n                SafeMath.div(balance, accurateShare),\r\n                thisShare\r\n            );\r\n            _balances[pIndex(wallet)] = SafeMath.add(\r\n                _balances[pIndex(wallet)],\r\n                walletShare\r\n            );\r\n            reportsFun(15, pIndex(wallet), walletShare);\r\n        }\r\n\r\n        addTokenLiquidity(liquidityShare);\r\n    }\r\n\r\n    function addTokenLiquidity(uint256 _amount) internal {\r\n        if (_amount > 0) {\r\n            tether.approve(dwbTokenAddress, _amount);\r\n            (bool success, ) = address(dwbTokenAddress).call(\r\n                abi.encodeWithSignature(\"addLiquidity(uint256)\", _amount)\r\n            );\r\n            if (!success) {\r\n                _balances[0] = SafeMath.add(_balances[0], _amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function pushAddress(\r\n        address[] memory array,\r\n        address newValue\r\n    ) internal pure returns (address[] memory) {\r\n        address[] memory newArray = new address[](array.length + 1);\r\n        for (uint256 i = 0; i < array.length; i++) {\r\n            newArray[i] = array[i];\r\n        }\r\n        newArray[array.length] = newValue;\r\n        return newArray;\r\n    }\r\n\r\n    function pushUint(\r\n        uint256[] memory array,\r\n        uint256 newValue\r\n    ) internal pure returns (uint256[] memory) {\r\n        uint256[] memory newArray = new uint256[](array.length + 1);\r\n        for (uint256 i = 0; i < array.length; i++) {\r\n            newArray[i] = array[i];\r\n        }\r\n        newArray[array.length] = newValue;\r\n        return newArray;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_accurateShareBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_userTokenCharge\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_userTokenPercent\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accurateShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accurateSharePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"addressExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newWallet\",\"type\":\"address\"}],\"name\":\"changePositionWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"charge\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pI\",\"type\":\"uint256\"}],\"name\":\"checkCeiling\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ceilling\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"commissions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_num\",\"type\":\"uint256\"}],\"name\":\"distributionP1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_num\",\"type\":\"uint256\"}],\"name\":\"distributionP2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dwbTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"getDeposits\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct WorkAccurate.Deposit[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getICOBalances\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pI\",\"type\":\"uint256\"}],\"name\":\"getPositionById\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"parent\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isLeft\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"charged\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referral\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"referralSide\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"leftChild\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rightChild\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"lastActivate\",\"type\":\"uint256\"}],\"internalType\":\"struct WorkAccurate.Position\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"getPositionByWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"parent\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isLeft\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"charged\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referral\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"referralSide\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"leftChild\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rightChild\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"lastActivate\",\"type\":\"uint256\"}],\"internalType\":\"struct WorkAccurate.Position\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pIndex\",\"type\":\"uint256\"}],\"name\":\"getPositionDiagramBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"thisBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"getPositionIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pI\",\"type\":\"uint256\"}],\"name\":\"getPositionTransactions\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"poIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"txType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"internalType\":\"struct WorkAccurate.Transaction[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPositions\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"parent\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isLeft\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"charged\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referral\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"referralSide\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"leftChild\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rightChild\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"lastActivate\",\"type\":\"uint256\"}],\"internalType\":\"struct WorkAccurate.Position[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalDiagramBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalDiagramBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalPlan2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalPlan2\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTransactions\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"poIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"txType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"internalType\":\"struct WorkAccurate.Transaction[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_referral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"join\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastPlan1Reciver\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastPlan2Reciver\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_node\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_parent\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isLeft\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"lastVersionNodes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pIndex\",\"type\":\"uint256\"}],\"name\":\"pLastActivate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pIndex\",\"type\":\"uint256\"}],\"name\":\"pLeftCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pIndex\",\"type\":\"uint256\"}],\"name\":\"pRightCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"plan1LastDistribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"plan1Liquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"plan1PerBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"plan1Percent\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"plan2LastDistribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"plan2Liquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"plan2PerPerson\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"plan2Percent\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pI\",\"type\":\"uint256\"}],\"name\":\"positionPlan2\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"can\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"maxRecive\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"positions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"parent\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isLeft\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"charged\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referral\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"referralSide\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"leftChild\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rightChild\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"lastActivate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"projectsProfit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pI\",\"type\":\"uint256\"}],\"name\":\"recivedCommission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"recived\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_newName\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_newSide\",\"type\":\"uint8\"}],\"name\":\"setReferralSide\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_newPercent\",\"type\":\"uint8\"}],\"name\":\"setUserTokenPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"startICO\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"started\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tether\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenPercent\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"topup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endTime\",\"type\":\"uint256\"}],\"name\":\"totalDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalCharged\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transactions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"txType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"transferICO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "WorkAccurate", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://402f3fb34b35f13dc48eea5b03858f9a5aa98f58fba6595f5c600496633e409d"}