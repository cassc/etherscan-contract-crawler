{"SourceCode": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity 0.8.10;\r\n/**\r\n\r\n\u2593\u2588\u2588   \u2588\u2588\u2593 \u2588\u2588\u2593\u2593\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2593    \u2593\u2588\u2588\u2588\u2588\u2588\u2584     \u2588\u2588\u2580\u2588\u2588\u2588   \u2592\u2588\u2588\u2588\u2588\u2588   \u2584\u2588\u2588\u2588\u2588\u2584   \u2588\u2588 \u2584\u2588\u2580\u2593\u2588\u2588\u2588\u2588\u2588\u2584\u2584\u2584\u2588\u2588\u2588\u2588\u2588\u2593\r\n \u2592\u2588\u2588  \u2588\u2588\u2592\u2593\u2588\u2588\u2592\u2593\u2588   \u2580 \u2593\u2588\u2588\u2592    \u2592\u2588\u2588\u2580 \u2588\u2588\u258c   \u2593\u2588\u2588 \u2592 \u2588\u2588\u2592\u2592\u2588\u2588\u2592  \u2588\u2588\u2592\u2592\u2588\u2588\u2580 \u2580\u2588   \u2588\u2588\u2584\u2588\u2592 \u2593\u2588   \u2580\u2593  \u2588\u2588\u2592 \u2593\u2592\r\n  \u2592\u2588\u2588 \u2588\u2588\u2591\u2592\u2588\u2588\u2592\u2592\u2588\u2588\u2588   \u2592\u2588\u2588\u2591    \u2591\u2588\u2588   \u2588\u258c   \u2593\u2588\u2588 \u2591\u2584\u2588 \u2592\u2592\u2588\u2588\u2591  \u2588\u2588\u2592\u2592\u2593\u2588    \u2584 \u2593\u2588\u2588\u2588\u2584\u2591 \u2592\u2588\u2588\u2588  \u2592 \u2593\u2588\u2588\u2591 \u2592\u2591\r\n  \u2591 \u2590\u2588\u2588\u2593\u2591\u2591\u2588\u2588\u2591\u2592\u2593\u2588  \u2584 \u2592\u2588\u2588\u2591    \u2591\u2593\u2588\u2584   \u258c   \u2592\u2588\u2588\u2580\u2580\u2588\u2584  \u2592\u2588\u2588   \u2588\u2588\u2591\u2592\u2593\u2593\u2584 \u2584\u2588\u2588\u2592\u2593\u2588\u2588 \u2588\u2584 \u2592\u2593\u2588  \u2584\u2591 \u2593\u2588\u2588\u2593 \u2591 \r\n  \u2591 \u2588\u2588\u2592\u2593\u2591\u2591\u2588\u2588\u2591\u2591\u2592\u2588\u2588\u2588\u2588\u2592\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2592\u2591\u2592\u2588\u2588\u2588\u2588\u2593    \u2591\u2588\u2588\u2593 \u2592\u2588\u2588\u2592\u2591 \u2588\u2588\u2588\u2588\u2593\u2592\u2591\u2592 \u2593\u2588\u2588\u2588\u2580 \u2591\u2592\u2588\u2588\u2592 \u2588\u2584\u2591\u2592\u2588\u2588\u2588\u2588\u2592 \u2592\u2588\u2588\u2592 \u2591 \r\n   \u2588\u2588\u2592\u2592\u2592 \u2591\u2593  \u2591\u2591 \u2592\u2591 \u2591\u2591 \u2592\u2591\u2593  \u2591 \u2592\u2592\u2593  \u2592    \u2591 \u2592\u2593 \u2591\u2592\u2593\u2591\u2591 \u2592\u2591\u2592\u2591\u2592\u2591 \u2591 \u2591\u2592 \u2592  \u2591\u2592 \u2592\u2592 \u2593\u2592\u2591\u2591 \u2592\u2591 \u2591 \u2592 \u2591\u2591   \r\n \u2593\u2588\u2588 \u2591\u2592\u2591  \u2592 \u2591 \u2591 \u2591  \u2591\u2591 \u2591 \u2592  \u2591 \u2591 \u2592  \u2592      \u2591\u2592 \u2591 \u2592\u2591  \u2591 \u2592 \u2592\u2591   \u2591  \u2592   \u2591 \u2591\u2592 \u2592\u2591 \u2591 \u2591  \u2591   \u2591    \r\n \u2592 \u2592 \u2591\u2591   \u2592 \u2591   \u2591     \u2591 \u2591    \u2591 \u2591  \u2591      \u2591\u2591   \u2591 \u2591 \u2591 \u2591 \u2592  \u2591        \u2591 \u2591\u2591 \u2591    \u2591    \u2591      \r\n \u2591 \u2591      \u2591     \u2591  \u2591    \u2591  \u2591   \u2591          \u2591         \u2591 \u2591  \u2591 \u2591      \u2591  \u2591      \u2591  \u2591        \r\n \u2591 \u2591                         \u2591                           \u2591                              \r\n                                            \u2591                              \r\n */\r\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol)\r\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\r\nabstract contract Auth {\r\n    event OwnerUpdated(address indexed user, address indexed newOwner);\r\n\r\n    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);\r\n\r\n    address public owner;\r\n\r\n    Authority public authority;\r\n\r\n    constructor(address _owner, Authority _authority) {\r\n        owner = _owner;\r\n        authority = _authority;\r\n\r\n        emit OwnerUpdated(msg.sender, _owner);\r\n        emit AuthorityUpdated(msg.sender, _authority);\r\n    }\r\n\r\n    modifier requiresAuth() {\r\n        require(isAuthorized(msg.sender, msg.sig), \"UNAUTHORIZED\");\r\n\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\r\n        Authority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\r\n\r\n        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\r\n        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\r\n        return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig)) || user == owner;\r\n    }\r\n\r\n    function setAuthority(Authority newAuthority) public virtual {\r\n        // We check if the caller is the owner first because we want to ensure they can\r\n        // always swap out the authority even if it's reverting or using up a lot of gas.\r\n        require(msg.sender == owner || authority.canCall(msg.sender, address(this), msg.sig));\r\n\r\n        authority = newAuthority;\r\n\r\n        emit AuthorityUpdated(msg.sender, newAuthority);\r\n    }\r\n\r\n    function setOwner(address newOwner) public virtual requiresAuth {\r\n        owner = newOwner;\r\n\r\n        emit OwnerUpdated(msg.sender, newOwner);\r\n    }\r\n}\r\n\r\n/// @notice A generic interface for a contract which provides authorization data to an Auth instance.\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol)\r\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\r\ninterface Authority {\r\n    function canCall(\r\n        address user,\r\n        address target,\r\n        bytes4 functionSig\r\n    ) external view returns (bool);\r\n}\r\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\r\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\r\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\r\nabstract contract ERC20 {\r\n    /*///////////////////////////////////////////////////////////////\r\n                                  EVENTS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                             METADATA STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    string public name;\r\n\r\n    string public symbol;\r\n\r\n    uint8 public immutable decimals;\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                              ERC20 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    uint256 public totalSupply;\r\n\r\n    mapping(address => uint256) public balanceOf;\r\n\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                             EIP-2612 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    bytes32 public constant PERMIT_TYPEHASH =\r\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n\r\n    uint256 internal immutable INITIAL_CHAIN_ID;\r\n\r\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\r\n\r\n    mapping(address => uint256) public nonces;\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                               CONSTRUCTOR\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        uint8 _decimals\r\n    ) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n\r\n        INITIAL_CHAIN_ID = block.chainid;\r\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                              ERC20 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\r\n        allowance[msg.sender][spender] = amount;\r\n\r\n        emit Approval(msg.sender, spender, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\r\n        balanceOf[msg.sender] -= amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(msg.sender, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual returns (bool) {\r\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\r\n\r\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\r\n\r\n        balanceOf[from] -= amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                              EIP-2612 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public virtual {\r\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\r\n\r\n        // Unchecked because the only math done is incrementing\r\n        // the owner's nonce which cannot realistically overflow.\r\n        unchecked {\r\n            bytes32 digest = keccak256(\r\n                abi.encodePacked(\r\n                    \"\\x19\\x01\",\r\n                    DOMAIN_SEPARATOR(),\r\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\r\n                )\r\n            );\r\n\r\n            address recoveredAddress = ecrecover(digest, v, r, s);\r\n\r\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\r\n\r\n            allowance[recoveredAddress][spender] = value;\r\n        }\r\n\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\r\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\r\n    }\r\n\r\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encode(\r\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n                    keccak256(bytes(name)),\r\n                    keccak256(\"1\"),\r\n                    block.chainid,\r\n                    address(this)\r\n                )\r\n            );\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                       INTERNAL MINT/BURN LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function _mint(address to, uint256 amount) internal virtual {\r\n        totalSupply += amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(address(0), to, amount);\r\n    }\r\n\r\n    function _burn(address from, uint256 amount) internal virtual {\r\n        balanceOf[from] -= amount;\r\n\r\n        // Cannot underflow because a user's balance\r\n        // will never be larger than the total supply.\r\n        unchecked {\r\n            totalSupply -= amount;\r\n        }\r\n\r\n        emit Transfer(from, address(0), amount);\r\n    }\r\n}\r\n\r\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\r\n/// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\r\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\r\nlibrary SafeTransferLib {\r\n    /*///////////////////////////////////////////////////////////////\r\n                            ETH OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function safeTransferETH(address to, uint256 amount) internal {\r\n        bool callStatus;\r\n\r\n        assembly {\r\n            // Transfer the ETH and store if it succeeded or not.\r\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\r\n        }\r\n\r\n        require(callStatus, \"ETH_TRANSFER_FAILED\");\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                           ERC20 OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function safeTransferFrom(\r\n        ERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool callStatus;\r\n\r\n        assembly {\r\n            // Get a pointer to some free memory.\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // Write the abi-encoded calldata to memory piece by piece:\r\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\r\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"from\" argument.\r\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\r\n            mstore(add(freeMemoryPointer, 68), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\r\n\r\n            // Call the token and store if it succeeded or not.\r\n            // We use 100 because the calldata length is 4 + 32 * 3.\r\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)\r\n        }\r\n\r\n        require(didLastOptionalReturnCallSucceed(callStatus), \"TRANSFER_FROM_FAILED\");\r\n    }\r\n\r\n    function safeTransfer(\r\n        ERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool callStatus;\r\n\r\n        assembly {\r\n            // Get a pointer to some free memory.\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // Write the abi-encoded calldata to memory piece by piece:\r\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\r\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\r\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\r\n\r\n            // Call the token and store if it succeeded or not.\r\n            // We use 68 because the calldata length is 4 + 32 * 2.\r\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\r\n        }\r\n\r\n        require(didLastOptionalReturnCallSucceed(callStatus), \"TRANSFER_FAILED\");\r\n    }\r\n\r\n    function safeApprove(\r\n        ERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool callStatus;\r\n\r\n        assembly {\r\n            // Get a pointer to some free memory.\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // Write the abi-encoded calldata to memory piece by piece:\r\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\r\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\r\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\r\n\r\n            // Call the token and store if it succeeded or not.\r\n            // We use 68 because the calldata length is 4 + 32 * 2.\r\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\r\n        }\r\n\r\n        require(didLastOptionalReturnCallSucceed(callStatus), \"APPROVE_FAILED\");\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                         INTERNAL HELPER LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function didLastOptionalReturnCallSucceed(bool callStatus) private pure returns (bool success) {\r\n        assembly {\r\n            // Get how many bytes the call returned.\r\n            let returnDataSize := returndatasize()\r\n\r\n            // If the call reverted:\r\n            if iszero(callStatus) {\r\n                // Copy the revert message into memory.\r\n                returndatacopy(0, 0, returnDataSize)\r\n\r\n                // Revert with the same message.\r\n                revert(0, returnDataSize)\r\n            }\r\n\r\n            switch returnDataSize\r\n            case 32 {\r\n                // Copy the return data into memory.\r\n                returndatacopy(0, 0, returnDataSize)\r\n\r\n                // Set success to whether it returned true.\r\n                success := iszero(iszero(mload(0)))\r\n            }\r\n            case 0 {\r\n                // There was no return data.\r\n                success := 1\r\n            }\r\n            default {\r\n                // It returned some malformed input.\r\n                success := 0\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/// @notice Minimalist and modern Wrapped Ether implementation.\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/WETH.sol)\r\n/// @author Inspired by WETH9 (https://github.com/dapphub/ds-weth/blob/master/src/weth9.sol)\r\ncontract WETH is ERC20(\"Wrapped Ether\", \"WETH\", 18) {\r\n    using SafeTransferLib for address;\r\n\r\n    event Deposit(address indexed from, uint256 amount);\r\n\r\n    event Withdrawal(address indexed to, uint256 amount);\r\n\r\n    function deposit() public payable virtual {\r\n        _mint(msg.sender, msg.value);\r\n\r\n        emit Deposit(msg.sender, msg.value);\r\n    }\r\n\r\n    function withdraw(uint256 amount) public virtual {\r\n        _burn(msg.sender, amount);\r\n\r\n        emit Withdrawal(msg.sender, amount);\r\n\r\n        msg.sender.safeTransferETH(amount);\r\n    }\r\n\r\n    receive() external payable virtual {\r\n        deposit();\r\n    }\r\n}\r\n\r\n/// @notice Safe unsigned integer casting library that reverts on overflow.\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeCastLib.sol)\r\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\r\nlibrary SafeCastLib {\r\n    function safeCastTo248(uint256 x) internal pure returns (uint248 y) {\r\n        require(x <= type(uint248).max);\r\n\r\n        y = uint248(x);\r\n    }\r\n\r\n    function safeCastTo128(uint256 x) internal pure returns (uint128 y) {\r\n        require(x <= type(uint128).max);\r\n\r\n        y = uint128(x);\r\n    }\r\n\r\n    function safeCastTo96(uint256 x) internal pure returns (uint96 y) {\r\n        require(x <= type(uint96).max);\r\n\r\n        y = uint96(x);\r\n    }\r\n\r\n    function safeCastTo64(uint256 x) internal pure returns (uint64 y) {\r\n        require(x <= type(uint64).max);\r\n\r\n        y = uint64(x);\r\n    }\r\n\r\n    function safeCastTo32(uint256 x) internal pure returns (uint32 y) {\r\n        require(x <= type(uint32).max);\r\n\r\n        y = uint32(x);\r\n    }\r\n}\r\n\r\n/// @notice Arithmetic library with operations for fixed-point numbers.\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\r\nlibrary FixedPointMathLib {\r\n    /*///////////////////////////////////////////////////////////////\r\n                            COMMON BASE UNITS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    uint256 internal constant YAD = 1e8;\r\n    uint256 internal constant WAD = 1e18;\r\n    uint256 internal constant RAY = 1e27;\r\n    uint256 internal constant RAD = 1e45;\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                         FIXED POINT OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function fmul(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 baseUnit\r\n    ) internal pure returns (uint256 z) {\r\n        assembly {\r\n            // Store x * y in z for now.\r\n            z := mul(x, y)\r\n\r\n            // Equivalent to require(x == 0 || (x * y) / x == y)\r\n            if iszero(or(iszero(x), eq(div(z, x), y))) {\r\n                revert(0, 0)\r\n            }\r\n\r\n            // If baseUnit is zero this will return zero instead of reverting.\r\n            z := div(z, baseUnit)\r\n        }\r\n    }\r\n\r\n    function fdiv(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 baseUnit\r\n    ) internal pure returns (uint256 z) {\r\n        assembly {\r\n            // Store x * baseUnit in z for now.\r\n            z := mul(x, baseUnit)\r\n\r\n            // Equivalent to require(y != 0 && (x == 0 || (x * baseUnit) / x == baseUnit))\r\n            if iszero(and(iszero(iszero(y)), or(iszero(x), eq(div(z, x), baseUnit)))) {\r\n                revert(0, 0)\r\n            }\r\n\r\n            // We ensure y is not zero above, so there is never division by zero here.\r\n            z := div(z, y)\r\n        }\r\n    }\r\n\r\n    function fpow(\r\n        uint256 x,\r\n        uint256 n,\r\n        uint256 baseUnit\r\n    ) internal pure returns (uint256 z) {\r\n        assembly {\r\n            switch x\r\n            case 0 {\r\n                switch n\r\n                case 0 {\r\n                    // 0 ** 0 = 1\r\n                    z := baseUnit\r\n                }\r\n                default {\r\n                    // 0 ** n = 0\r\n                    z := 0\r\n                }\r\n            }\r\n            default {\r\n                switch mod(n, 2)\r\n                case 0 {\r\n                    // If n is even, store baseUnit in z for now.\r\n                    z := baseUnit\r\n                }\r\n                default {\r\n                    // If n is odd, store x in z for now.\r\n                    z := x\r\n                }\r\n\r\n                // Shifting right by 1 is like dividing by 2.\r\n                let half := shr(1, baseUnit)\r\n\r\n                for {\r\n                    // Shift n right by 1 before looping to halve it.\r\n                    n := shr(1, n)\r\n                } n {\r\n                    // Shift n right by 1 each iteration to halve it.\r\n                    n := shr(1, n)\r\n                } {\r\n                    // Revert immediately if x ** 2 would overflow.\r\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\r\n                    if shr(128, x) {\r\n                        revert(0, 0)\r\n                    }\r\n\r\n                    // Store x squared.\r\n                    let xx := mul(x, x)\r\n\r\n                    // Round to the nearest number.\r\n                    let xxRound := add(xx, half)\r\n\r\n                    // Revert if xx + half overflowed.\r\n                    if lt(xxRound, xx) {\r\n                        revert(0, 0)\r\n                    }\r\n\r\n                    // Set x to scaled xxRound.\r\n                    x := div(xxRound, baseUnit)\r\n\r\n                    // If n is even:\r\n                    if mod(n, 2) {\r\n                        // Compute z * x.\r\n                        let zx := mul(z, x)\r\n\r\n                        // If z * x overflowed:\r\n                        if iszero(eq(div(zx, x), z)) {\r\n                            // Revert if x is non-zero.\r\n                            if iszero(iszero(x)) {\r\n                                revert(0, 0)\r\n                            }\r\n                        }\r\n\r\n                        // Round to the nearest number.\r\n                        let zxRound := add(zx, half)\r\n\r\n                        // Revert if zx + half overflowed.\r\n                        if lt(zxRound, zx) {\r\n                            revert(0, 0)\r\n                        }\r\n\r\n                        // Return properly scaled zxRound.\r\n                        z := div(zxRound, baseUnit)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                        GENERAL NUMBER UTILITIES\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\r\n        assembly {\r\n            // Start off with z at 1.\r\n            z := 1\r\n\r\n            // Used below to help find a nearby power of 2.\r\n            let y := x\r\n\r\n            // Find the lowest power of 2 that is at least sqrt(x).\r\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\r\n                y := shr(128, y) // Like dividing by 2 ** 128.\r\n                z := shl(64, z)\r\n            }\r\n            if iszero(lt(y, 0x10000000000000000)) {\r\n                y := shr(64, y) // Like dividing by 2 ** 64.\r\n                z := shl(32, z)\r\n            }\r\n            if iszero(lt(y, 0x100000000)) {\r\n                y := shr(32, y) // Like dividing by 2 ** 32.\r\n                z := shl(16, z)\r\n            }\r\n            if iszero(lt(y, 0x10000)) {\r\n                y := shr(16, y) // Like dividing by 2 ** 16.\r\n                z := shl(8, z)\r\n            }\r\n            if iszero(lt(y, 0x100)) {\r\n                y := shr(8, y) // Like dividing by 2 ** 8.\r\n                z := shl(4, z)\r\n            }\r\n            if iszero(lt(y, 0x10)) {\r\n                y := shr(4, y) // Like dividing by 2 ** 4.\r\n                z := shl(2, z)\r\n            }\r\n            if iszero(lt(y, 0x8)) {\r\n                // Equivalent to 2 ** z.\r\n                z := shl(1, z)\r\n            }\r\n\r\n            // Shifting right by 1 is like dividing by 2.\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n\r\n            // Compute a rounded down version of z.\r\n            let zRoundDown := div(x, z)\r\n\r\n            // If zRoundDown is smaller, use it.\r\n            if lt(zRoundDown, z) {\r\n                z := zRoundDown\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nabstract contract Strategy is ERC20 {\r\n    /// @notice Returns whether the strategy accepts ETH or an ERC20.\r\n    /// @return True if the strategy accepts ETH, false otherwise.\r\n    function isEther() external view virtual returns (bool);\r\n\r\n    /// @notice Withdraws a specific amount of underlying tokens from the strategy.\r\n    /// @param amount The amount of underlying tokens to withdraw.\r\n    /// @return 0 if the withdrawal was successful.\r\n    function redeemUnderlying(uint256 amount) external virtual returns (uint256);\r\n\r\n    /// @notice Returns a user's strategy balance in underlying tokens.\r\n    /// @param user The user to get the underlying balance of.\r\n    /// @return The user's strategy balance in underlying tokens.\r\n    /// @dev May mutate the state of the strategy by accruing interest.\r\n    function balanceOfUnderlying(address user) external virtual returns (uint256);\r\n\r\n    function sweep(\r\n        address to,\r\n        ERC20 token,\r\n        uint256 amount\r\n    ) external virtual;\r\n\r\n    function fire() external virtual;\r\n}\r\n\r\n/// @notice Minimal interface for Vault strategies that accept ERC20s.\r\nabstract contract ERC20Strategy is Strategy {\r\n    /// @notice Returns the underlying ERC20 token the strategy accepts.\r\n    /// @return The underlying ERC20 token the strategy accepts.\r\n    function underlying() external view virtual returns (ERC20);\r\n\r\n    /// @notice Deposit a specific amount of underlying tokens into the strategy.\r\n    /// @param amount The amount of underlying tokens to deposit.\r\n    /// @return 0 if the deposit was successful.\r\n    function mint(uint256 amount) external virtual returns (uint256);\r\n}\r\n\r\n/// @notice Minimal interface for Vault strategies that accept ETH.\r\nabstract contract ETHStrategy is Strategy {\r\n    /// @notice Deposit a specific amount of ETH into the strategy.\r\n    /// @dev The amount of ETH is specified via msg.value. Reverts on error.\r\n    function mint() external payable virtual;\r\n}\r\n\r\n/// @notice Multi-strategy vaults\r\ncontract Vault is ERC20, Auth {\r\n    using SafeCastLib for uint256;\r\n    using SafeTransferLib for ERC20;\r\n    using FixedPointMathLib for uint256;\r\n\r\n    /// @notice The underlying token the Vault accepts.\r\n    ERC20 public immutable UNDERLYING;\r\n\r\n    /// @notice The base unit of the underlying token and hence arToken.\r\n    /// @dev Equal to 10 ** decimals. Used for fixed point arithmetic.\r\n    uint256 public immutable BASE_UNIT;\r\n\r\n    /// @notice Creates a new Vault that accepts a specific underlying token.\r\n    /// @param _UNDERLYING The ERC20 compliant token the Vault should accept.\r\n    constructor(ERC20 _UNDERLYING)\r\n        ERC20(\r\n            string(abi.encodePacked(\"Aperocket \", _UNDERLYING.name(), \" Vault\")),\r\n            string(abi.encodePacked(\"ar\", _UNDERLYING.symbol())),\r\n            _UNDERLYING.decimals()\r\n        )\r\n        Auth(Auth(msg.sender).owner(), Auth(msg.sender).authority())\r\n    {\r\n        UNDERLYING = _UNDERLYING;\r\n        BASE_UNIT = 10**decimals;\r\n        // Prevent minting of arTokens until\r\n        // the initialize function is called.\r\n        totalSupply = type(uint256).max;\r\n    }\r\n\r\n    /// @notice The percentage of withdrawal recognized each withdraw/redeem to reserve as fees.\r\n    /// @dev A fixed point number where 1e18 represents 100% and 0 represents 0%.\r\n    uint256 public withdrawalFeePercent;\r\n\r\n    /// @notice The percentage of profit recognized each harvest to reserve as fees.\r\n    /// @dev A fixed point number where 1e18 represents 100% and 0 represents 0%.\r\n    uint256 public feePercent;\r\n\r\n    /// @notice Emitted when the fee percentage is updated.\r\n    /// @param user The authorized user who triggered the update.\r\n    /// @param newFeePercent The new fee percentage.\r\n    event FeePercentUpdated(address indexed user, uint256 newFeePercent);\r\n\r\n    /// @notice Emitted when the withdrawal fee percentage is updated.\r\n    /// @param user The authorized user who triggered the update.\r\n    /// @param newWithdrawalFeePercent The new fee percentage.\r\n    event WithdrawalFeeUpdated(address indexed user, uint256 newWithdrawalFeePercent);\r\n\r\n    /// @notice Sets a new fee percentage.\r\n    /// @param newFeePercent The new fee percentage.\r\n    function setFeePercent(uint256 newFeePercent) external requiresAuth {\r\n        // A fee percentage over 100% doesn't make sense.\r\n        require(newFeePercent <= 1e18, \"FEE_TOO_HIGH\");\r\n\r\n        // Update the fee percentage.\r\n        feePercent = newFeePercent;\r\n\r\n        emit FeePercentUpdated(msg.sender, newFeePercent);\r\n    }\r\n\r\n    /// @notice Sets a new withdrawal fee percentage.\r\n    /// @param newWithdrawalFeePercent The new fee percentage.\r\n    /// @dev 1% Max.\r\n    function setWithdrawalFeePercent(uint256 newWithdrawalFeePercent) external requiresAuth {\r\n        require(newWithdrawalFeePercent <= 1e16, \"FEE_TOO_HIGH\");\r\n\r\n        // Update the fee percentage.\r\n        withdrawalFeePercent = newWithdrawalFeePercent;\r\n\r\n        emit FeePercentUpdated(msg.sender, newWithdrawalFeePercent);\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////////////\r\n    /// --- HARVEST CONFIGURATION\r\n    ///////////////////////////////////////////////////////////////\r\n\r\n    /// @notice Emitted when the harvest window is updated.\r\n    /// @param user The authorized user who triggered the update.\r\n    /// @param newHarvestWindow The new harvest window.\r\n    event HarvestWindowUpdated(address indexed user, uint128 newHarvestWindow);\r\n\r\n    /// @notice Emitted when the harvest delay is updated.\r\n    /// @param user The authorized user who triggered the update.\r\n    /// @param newHarvestDelay The new harvest delay.\r\n    event HarvestDelayUpdated(address indexed user, uint64 newHarvestDelay);\r\n\r\n    /// @notice Emitted when the harvest delay is scheduled to be updated next harvest.\r\n    /// @param user The authorized user who triggered the update.\r\n    /// @param newHarvestDelay The scheduled updated harvest delay.\r\n    event HarvestDelayUpdateScheduled(address indexed user, uint64 newHarvestDelay);\r\n\r\n    /// @notice The period in seconds during which multiple harvests can occur\r\n    /// regardless if they are taking place before the harvest delay has elapsed.\r\n    /// @dev Long harvest windows open the Vault up to profit distribution slowdown attacks.\r\n    uint128 public harvestWindow;\r\n\r\n    /// @notice The period in seconds over which locked profit is unlocked.\r\n    /// @dev Cannot be 0 as it opens harvests up to sandwich attacks.\r\n    uint64 public harvestDelay;\r\n\r\n    /// @notice The value that will replace harvestDelay next harvest.\r\n    /// @dev In the case that the next delay is 0, no update will be applied.\r\n    uint64 public nextHarvestDelay;\r\n\r\n    /// @notice Sets a new harvest window.\r\n    /// @param newHarvestWindow The new harvest window.\r\n    /// @dev The Vault's harvestDelay must already be set before calling.\r\n    function setHarvestWindow(uint128 newHarvestWindow) external requiresAuth {\r\n        // A harvest window longer than the harvest delay doesn't make sense.\r\n        require(newHarvestWindow <= harvestDelay, \"WINDOW_TOO_LONG\");\r\n\r\n        // Update the harvest window.\r\n        harvestWindow = newHarvestWindow;\r\n\r\n        emit HarvestWindowUpdated(msg.sender, newHarvestWindow);\r\n    }\r\n\r\n    /// @notice Sets a new harvest delay.\r\n    /// @param newHarvestDelay The new harvest delay to set.\r\n    /// @dev If the current harvest delay is 0, meaning it has not\r\n    /// been set before, it will be updated immediately, otherwise\r\n    /// it will be scheduled to take effect after the next harvest.\r\n    function setHarvestDelay(uint64 newHarvestDelay) external requiresAuth {\r\n        // A harvest delay of 0 makes harvests vulnerable to sandwich attacks.\r\n        require(newHarvestDelay != 0, \"DELAY_CANNOT_BE_ZERO\");\r\n\r\n        // A harvest delay longer than 1 year doesn't make sense.\r\n        require(newHarvestDelay <= 365 days, \"DELAY_TOO_LONG\");\r\n\r\n        // If the harvest delay is 0, meaning it has not been set before:\r\n        if (harvestDelay == 0) {\r\n            // We'll apply the update immediately.\r\n            harvestDelay = newHarvestDelay;\r\n\r\n            emit HarvestDelayUpdated(msg.sender, newHarvestDelay);\r\n        } else {\r\n            // We'll apply the update next harvest.\r\n            nextHarvestDelay = newHarvestDelay;\r\n\r\n            emit HarvestDelayUpdateScheduled(msg.sender, newHarvestDelay);\r\n        }\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////////////\r\n    /// --- TARGET FLOAT CONFIGURATION\r\n    ///////////////////////////////////////////////////////////////\r\n\r\n    /// @notice The desired percentage of the Vault's holdings to keep as float.\r\n    /// @dev A fixed point number where 1e18 represents 100% and 0 represents 0%.\r\n    uint256 public targetFloatPercent;\r\n\r\n    /// @notice Emitted when the target float percentage is updated.\r\n    /// @param user The authorized user who triggered the update.\r\n    /// @param newTargetFloatPercent The new target float percentage.\r\n    event TargetFloatPercentUpdated(address indexed user, uint256 newTargetFloatPercent);\r\n\r\n    /// @notice Set a new target float percentage.\r\n    /// @param newTargetFloatPercent The new target float percentage.\r\n    function setTargetFloatPercent(uint256 newTargetFloatPercent) external requiresAuth {\r\n        // A target float percentage over 100% doesn't make sense.\r\n        require(newTargetFloatPercent <= 1e18, \"TARGET_TOO_HIGH\");\r\n\r\n        // Update the target float percentage.\r\n        targetFloatPercent = newTargetFloatPercent;\r\n\r\n        emit TargetFloatPercentUpdated(msg.sender, newTargetFloatPercent);\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////////////\r\n    /// --- UNDERLYING IS WETH\r\n    ///////////////////////////////////////////////////////////////\r\n\r\n    /// @notice Whether the Vault should treat the underlying token as WETH compatible.\r\n    /// @dev If enabled the Vault will allow trusting strategies that accept Ether.\r\n    bool public underlyingIsWETH;\r\n\r\n    /// @notice Emitted when whether the Vault should treat the underlying as WETH is updated.\r\n    /// @param user The authorized user who triggered the update.\r\n    /// @param newUnderlyingIsWETH Whether the Vault nows treats the underlying as WETH.\r\n    event UnderlyingIsWETHUpdated(address indexed user, bool newUnderlyingIsWETH);\r\n\r\n    /// @notice Sets whether the Vault treats the underlying as WETH.\r\n    /// @param newUnderlyingIsWETH Whether the Vault should treat the underlying as WETH.\r\n    /// @dev The underlying token must have 18 decimals, to match Ether's decimal scheme.\r\n    function setUnderlyingIsWETH(bool newUnderlyingIsWETH) external requiresAuth {\r\n        // Ensure the underlying token's decimals match ETH.\r\n        require(UNDERLYING.decimals() == 18, \"WRONG_DECIMALS\");\r\n\r\n        // Update whether the Vault treats the underlying as WETH.\r\n        underlyingIsWETH = newUnderlyingIsWETH;\r\n\r\n        emit UnderlyingIsWETHUpdated(msg.sender, newUnderlyingIsWETH);\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////////////\r\n    /// --- STRATEGY STORAGE\r\n    ///////////////////////////////////////////////////////////////\r\n\r\n    /// @notice The total amount of underlying tokens held in strategies at the time of the last harvest.\r\n    /// @dev Includes maxLockedProfit, must be correctly subtracted to compute available/free holdings.\r\n    uint256 public totalStrategyHoldings;\r\n\r\n    /// @dev Packed struct of strategy data.\r\n    /// @param trusted Whether the strategy is trusted.\r\n    /// @param balance The amount of underlying tokens held in the strategy.\r\n    struct StrategyData {\r\n        // Used to determine if the Vault will operate on a strategy.\r\n        bool trusted;\r\n        // Used to determine profit and loss during harvests of the strategy.\r\n        uint248 balance;\r\n    }\r\n\r\n    /// @notice Maps strategies to data the Vault holds on them.\r\n    mapping(Strategy => StrategyData) public getStrategyData;\r\n\r\n    ////////////////////////////////////////////////////////////////\r\n    /// --- HARVEST STORAGE\r\n    ///////////////////////////////////////////////////////////////\r\n\r\n    /// @notice A timestamp representing when the first harvest in the most recent harvest window occurred.\r\n    /// @dev May be equal to lastHarvest if there was/has only been one harvest in the most last/current window.\r\n    uint64 public lastHarvestWindowStart;\r\n\r\n    /// @notice A timestamp representing when the most recent harvest occurred.\r\n    uint64 public lastHarvest;\r\n\r\n    /// @notice The amount of locked profit at the end of the last harvest.\r\n    uint128 public maxLockedProfit;\r\n\r\n    ////////////////////////////////////////////////////////////////\r\n    /// --- WITHDRAWAL QUEUE STORAGE\r\n    ///////////////////////////////////////////////////////////////\r\n\r\n    /// @notice An ordered array of strategies representing the withdrawal queue.\r\n    /// @dev The queue is processed in descending order, meaning the last index will be withdrawn from first.\r\n    /// @dev Strategies that are untrusted, duplicated, or have no balance are filtered out when encountered at\r\n    /// withdrawal time, not validated upfront, meaning the queue may not reflect the \"true\" set used for withdrawals.\r\n    Strategy[] public withdrawalQueue;\r\n\r\n    /// @notice Gets the full withdrawal queue.\r\n    /// @return An ordered array of strategies representing the withdrawal queue.\r\n    /// @dev This is provided because Solidity converts public arrays into index getters,\r\n    /// but we need a way to allow external contracts and users to access the whole array.\r\n    function getWithdrawalQueue() external view returns (Strategy[] memory) {\r\n        return withdrawalQueue;\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////////////\r\n    /// --- DEPOSIT/WITHDRAW LOGIC\r\n    ///////////////////////////////////////////////////////////////\r\n\r\n    /// @notice Emitted after a successful deposit.\r\n    /// @param user The address that deposited into the Vault.\r\n    /// @param underlyingAmount The amount of underlying tokens that were deposited.\r\n    event Deposit(address indexed user, uint256 underlyingAmount);\r\n\r\n    /// @notice Emitted after a successful withdrawal.\r\n    /// @param user The address that withdrew from the Vault.\r\n    /// @param underlyingAmount The amount of underlying tokens that were withdrawn.\r\n    event Withdraw(address indexed user, uint256 underlyingAmount);\r\n\r\n    /// @notice Deposit all user balance of underlying tokens.\r\n    function depositAll() external {\r\n        uint256 underlyingAmount = UNDERLYING.balanceOf(msg.sender);\r\n        _deposit(underlyingAmount);\r\n    }\r\n\r\n    /// @notice Deposit a specific amount of underlying tokens.\r\n    /// @param underlyingAmount The amount of the underlying token to deposit.\r\n    function deposit(uint256 underlyingAmount) external {\r\n        // We don't allow depositing 0 to prevent emitting a useless event.\r\n        require(underlyingAmount != 0, \"AMOUNT_CANNOT_BE_ZERO\");\r\n        _deposit(underlyingAmount);\r\n    }\r\n\r\n    /// @notice Deposit a specific amount of underlying tokens.\r\n    function _deposit(uint256 underlyingAmount) internal {\r\n        // Determine the equivalent amount of arTokens and mint them.\r\n        _mint(msg.sender, underlyingAmount.fdiv(exchangeRate(), BASE_UNIT));\r\n\r\n        emit Deposit(msg.sender, underlyingAmount);\r\n\r\n        // Transfer in underlying tokens from the user.\r\n        // This will revert if the user does not have the amount specified.\r\n        UNDERLYING.safeTransferFrom(msg.sender, address(this), underlyingAmount);\r\n    }\r\n\r\n    /// @notice Withdraw a specific amount of underlying tokens.\r\n    /// @param underlyingAmount The amount of underlying tokens to withdraw.\r\n    function withdraw(uint256 underlyingAmount) external {\r\n        // We don't allow withdrawing 0 to prevent emitting a useless event.\r\n        require(underlyingAmount != 0, \"AMOUNT_CANNOT_BE_ZERO\");\r\n\r\n        uint256 arToken = underlyingAmount.fdiv(exchangeRate(), BASE_UNIT);\r\n        underlyingAmount = underlyingAmount.fmul(1e18 - withdrawalFeePercent, 1e18);\r\n\r\n        // Determine the equivalent amount of arTokens and burn them.\r\n        // This will revert if the user does not have enough arTokens.\r\n        _burn(msg.sender, arToken);\r\n\r\n        emit Withdraw(msg.sender, underlyingAmount);\r\n\r\n        // Withdraw from strategies if needed and transfer.\r\n        transferUnderlyingTo(msg.sender, underlyingAmount);\r\n    }\r\n\r\n    /// @notice Redeem all balance of arTokens for underlying tokens.\r\n    function redeemAll() external {\r\n        uint256 arTokenAmount = balanceOf[msg.sender];\r\n\r\n        uint256 underlyingAmount = arTokenAmount.fmul(exchangeRate(), BASE_UNIT);\r\n        underlyingAmount = underlyingAmount.fmul(1e18 - withdrawalFeePercent, 1e18);\r\n\r\n        _redeem(arTokenAmount, underlyingAmount);\r\n    }\r\n\r\n    /// @notice Redeem a specific amount of arTokens for underlying tokens.\r\n    /// @param arTokenAmount The amount of arTokens to redeem for underlying tokens.\r\n    function redeem(uint256 arTokenAmount) external {\r\n        // We don't allow redeeming 0 to prevent emitting a useless event.\r\n        require(arTokenAmount != 0, \"AMOUNT_CANNOT_BE_ZERO\");\r\n        uint256 underlyingAmount = arTokenAmount.fmul(exchangeRate(), BASE_UNIT);\r\n        underlyingAmount = underlyingAmount.fmul(1e18 - withdrawalFeePercent, 1e18);\r\n\r\n        _redeem(arTokenAmount, underlyingAmount);\r\n    }\r\n\r\n    /// @notice Redeem a specific amount of arTokens for underlying tokens without withdrawal fees.\r\n    /// @param arTokenAmount The amount of arTokens to redeem for underlying tokens.\r\n    /// @dev Used by strategies/approved contracts\r\n    function redeemRestricted(uint256 arTokenAmount) external requiresAuth {\r\n        // We don't allow redeeming 0 to prevent emitting a useless event.\r\n        require(arTokenAmount != 0, \"AMOUNT_CANNOT_BE_ZERO\");\r\n        uint256 underlyingAmount = arTokenAmount.fmul(exchangeRate(), BASE_UNIT);\r\n        _redeem(arTokenAmount, underlyingAmount);\r\n    }\r\n\r\n    function _redeem(uint256 arTokenAmount, uint256 underlyingAmount) internal {\r\n        // Burn the provided amount of arTokens.\r\n        // This will revert if the user does not have enough arTokens.\r\n        _burn(msg.sender, arTokenAmount);\r\n\r\n        emit Withdraw(msg.sender, underlyingAmount);\r\n\r\n        // Withdraw from strategies if needed and transfer.\r\n        transferUnderlyingTo(msg.sender, underlyingAmount);\r\n    }\r\n\r\n    /// @dev Transfers a specific amount of underlying tokens held in strategies and/or float to a recipient.\r\n    /// @dev Only withdraws from strategies if needed and maintains the target float percentage if possible.\r\n    /// @param recipient The user to transfer the underlying tokens to.\r\n    /// @param underlyingAmount The amount of underlying tokens to transfer.\r\n    function transferUnderlyingTo(address recipient, uint256 underlyingAmount) internal {\r\n        // Get the Vault's floating balance.\r\n        uint256 float = totalFloat();\r\n\r\n        // If the amount is greater than the float, withdraw from strategies.\r\n        if (underlyingAmount > float) {\r\n            // Compute the amount needed to reach our target float percentage.\r\n            uint256 floatMissingForTarget = (totalHoldings() - underlyingAmount).fmul(targetFloatPercent, 1e18);\r\n\r\n            // Compute the bare minimum amount we need for this withdrawal.\r\n            uint256 floatMissingForWithdrawal = underlyingAmount - float;\r\n\r\n            // Pull enough to cover the withdrawal and reach our target float percentage.\r\n            pullFromWithdrawalQueue(floatMissingForWithdrawal + floatMissingForTarget);\r\n        }\r\n\r\n        // Transfer the provided amount of underlying tokens.\r\n        UNDERLYING.safeTransfer(recipient, underlyingAmount);\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////////////\r\n    /// --- VAULT ACCOUNTING LOGIC\r\n    ///////////////////////////////////////////////////////////////\r\n\r\n    /// @notice Returns a user's Vault balance in underlying tokens.\r\n    /// @param user The user to get the underlying balance of.\r\n    /// @return The user's Vault balance in underlying tokens.\r\n    function balanceOfUnderlying(address user) external view returns (uint256) {\r\n        return balanceOf[user].fmul(exchangeRate(), BASE_UNIT);\r\n    }\r\n\r\n    /// @notice Returns the amount of underlying tokens an arToken can be redeemed for.\r\n    /// @return The amount of underlying tokens an arToken can be redeemed for.\r\n    function exchangeRate() public view returns (uint256) {\r\n        // Get the total supply of arTokens.\r\n        uint256 arTokenSupply = totalSupply;\r\n\r\n        // If there are no arTokens in circulation, return an exchange rate of 1:1.\r\n        if (arTokenSupply == 0) return BASE_UNIT;\r\n\r\n        // Calculate the exchange rate by dividing the total holdings by the arToken supply.\r\n        return totalHoldings().fdiv(arTokenSupply, BASE_UNIT);\r\n    }\r\n\r\n    /// @notice Calculates the total amount of underlying tokens the Vault holds.\r\n    /// @return totalUnderlyingHeld The total amount of underlying tokens the Vault holds.\r\n    function totalHoldings() public view returns (uint256 totalUnderlyingHeld) {\r\n        unchecked {\r\n            // Cannot underflow as locked profit can't exceed total strategy holdings.\r\n            totalUnderlyingHeld = totalStrategyHoldings - lockedProfit();\r\n        }\r\n\r\n        // Include our floating balance in the total.\r\n        totalUnderlyingHeld += totalFloat();\r\n    }\r\n\r\n    /// @notice Calculates the current amount of locked profit.\r\n    /// @return The current amount of locked profit.\r\n    function lockedProfit() public view returns (uint256) {\r\n        // Get the last harvest and harvest delay.\r\n        uint256 previousHarvest = lastHarvest;\r\n        uint256 harvestInterval = harvestDelay;\r\n\r\n        unchecked {\r\n            // If the harvest delay has passed, there is no locked profit.\r\n            // Cannot overflow on human timescales since harvestInterval is capped.\r\n            if (block.timestamp >= previousHarvest + harvestInterval) return 0;\r\n\r\n            // Get the maximum amount we could return.\r\n            uint256 maximumLockedProfit = maxLockedProfit;\r\n\r\n            // Compute how much profit remains locked based on the last harvest and harvest delay.\r\n            // It's impossible for the previous harvest to be in the future, so this will never underflow.\r\n            return maximumLockedProfit - (maximumLockedProfit * (block.timestamp - previousHarvest)) / harvestInterval;\r\n        }\r\n    }\r\n\r\n    /// @notice Returns the amount of underlying tokens that idly sit in the Vault.\r\n    /// @return The amount of underlying tokens that sit idly in the Vault.\r\n    function totalFloat() public view returns (uint256) {\r\n        return UNDERLYING.balanceOf(address(this));\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////////////\r\n    /// --- HARVEST LOGIC\r\n    ///////////////////////////////////////////////////////////////\r\n\r\n    /// @notice Emitted after a successful harvest.\r\n    /// @param user The authorized user who triggered the harvest.\r\n    /// @param strategies The trusted strategies that were harvested.\r\n    event Harvest(address indexed user, Strategy[] strategies);\r\n\r\n    /// @notice Harvest a set of trusted strategies.\r\n    /// @param strategies The trusted strategies to harvest.\r\n    /// @dev Will always revert if called outside of an active\r\n    /// harvest window or before the harvest delay has passed.\r\n    function harvest(Strategy[] calldata strategies) external requiresAuth {\r\n        // If this is the first harvest after the last window:\r\n        if (block.timestamp >= lastHarvest + harvestDelay) {\r\n            // Set the harvest window's start timestamp.\r\n            // Cannot overflow 64 bits on human timescales.\r\n            lastHarvestWindowStart = uint64(block.timestamp);\r\n        } else {\r\n            // We know this harvest is not the first in the window so we need to ensure it's within it.\r\n            require(block.timestamp <= lastHarvestWindowStart + harvestWindow, \"BAD_HARVEST_TIME\");\r\n        }\r\n\r\n        // Get the Vault's current total strategy holdings.\r\n        uint256 oldTotalStrategyHoldings = totalStrategyHoldings;\r\n\r\n        // Used to store the total profit accrued by the strategies.\r\n        uint256 totalProfitAccrued;\r\n\r\n        // Used to store the new total strategy holdings after harvesting.\r\n        uint256 newTotalStrategyHoldings = oldTotalStrategyHoldings;\r\n\r\n        // Will revert if any of the specified strategies are untrusted.\r\n        for (uint256 i = 0; i < strategies.length; i++) {\r\n            // Get the strategy at the current index.\r\n            Strategy strategy = strategies[i];\r\n\r\n            // If an untrusted strategy could be harvested a malicious user could use\r\n            // a fake strategy that over-reports holdings to manipulate the exchange rate.\r\n            require(getStrategyData[strategy].trusted, \"UNTRUSTED_STRATEGY\");\r\n\r\n            // Get the strategy's previous and current balance.\r\n            uint256 balanceLastHarvest = getStrategyData[strategy].balance;\r\n            uint256 balanceThisHarvest = strategy.balanceOfUnderlying(address(this));\r\n\r\n            // Update the strategy's stored balance. Cast overflow is unrealistic.\r\n            getStrategyData[strategy].balance = balanceThisHarvest.safeCastTo248();\r\n\r\n            // Increase/decrease newTotalStrategyHoldings based on the profit/loss registered.\r\n            // We cannot wrap the subtraction in parenthesis as it would underflow if the strategy had a loss.\r\n            newTotalStrategyHoldings = newTotalStrategyHoldings + balanceThisHarvest - balanceLastHarvest;\r\n\r\n            unchecked {\r\n                // Update the total profit accrued while counting losses as zero profit.\r\n                // Cannot overflow as we already increased total holdings without reverting.\r\n                totalProfitAccrued += balanceThisHarvest > balanceLastHarvest\r\n                    ? balanceThisHarvest - balanceLastHarvest // Profits since last harvest.\r\n                    : 0; // If the strategy registered a net loss we don't have any new profit.\r\n            }\r\n        }\r\n\r\n        // Compute fees as the fee percent multiplied by the profit.\r\n        uint256 feesAccrued = totalProfitAccrued.fmul(feePercent, 1e18);\r\n\r\n        // If we accrued any fees, mint an equivalent amount of arTokens.\r\n        // Authorized users can claim the newly minted arTokens via claimFees.\r\n        _mint(address(this), feesAccrued.fdiv(exchangeRate(), BASE_UNIT));\r\n\r\n        // Update max unlocked profit based on any remaining locked profit plus new profit.\r\n        maxLockedProfit = (lockedProfit() + totalProfitAccrued - feesAccrued).safeCastTo128();\r\n\r\n        // Set strategy holdings to our new total.\r\n        totalStrategyHoldings = newTotalStrategyHoldings;\r\n\r\n        // Update the last harvest timestamp.\r\n        // Cannot overflow on human timescales.\r\n        lastHarvest = uint64(block.timestamp);\r\n\r\n        emit Harvest(msg.sender, strategies);\r\n\r\n        // Get the next harvest delay.\r\n        uint64 newHarvestDelay = nextHarvestDelay;\r\n\r\n        // If the next harvest delay is not 0:\r\n        if (newHarvestDelay != 0) {\r\n            // Update the harvest delay.\r\n            harvestDelay = newHarvestDelay;\r\n\r\n            // Reset the next harvest delay.\r\n            nextHarvestDelay = 0;\r\n\r\n            emit HarvestDelayUpdated(msg.sender, newHarvestDelay);\r\n        }\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////////////\r\n    /// --- STRATEGY DEPOSIT/WITHDRAWAL LOGIC\r\n    ///////////////////////////////////////////////////////////////\r\n\r\n    /// @notice Emitted after the Vault deposits into a strategy contract.\r\n    /// @param user The authorized user who triggered the deposit.\r\n    /// @param strategy The strategy that was deposited into.\r\n    /// @param underlyingAmount The amount of underlying tokens that were deposited.\r\n    event StrategyDeposit(address indexed user, Strategy indexed strategy, uint256 underlyingAmount);\r\n\r\n    /// @notice Emitted after the Vault withdraws funds from a strategy contract.\r\n    /// @param user The authorized user who triggered the withdrawal.\r\n    /// @param strategy The strategy that was withdrawn from.\r\n    /// @param underlyingAmount The amount of underlying tokens that were withdrawn.\r\n    event StrategyWithdrawal(address indexed user, Strategy indexed strategy, uint256 underlyingAmount);\r\n\r\n    /// @notice Deposit a specific amount of float into a trusted strategy.\r\n    /// @param strategy The trusted strategy to deposit into.\r\n    /// @param underlyingAmount The amount of underlying tokens in float to deposit.\r\n    function depositIntoStrategy(Strategy strategy, uint256 underlyingAmount) external requiresAuth {\r\n        // A strategy must be trusted before it can be deposited into.\r\n        require(getStrategyData[strategy].trusted, \"UNTRUSTED_STRATEGY\");\r\n\r\n        // We don't allow depositing 0 to prevent emitting a useless event.\r\n        require(underlyingAmount != 0, \"AMOUNT_CANNOT_BE_ZERO\");\r\n\r\n        // Increase totalStrategyHoldings to account for the deposit.\r\n        totalStrategyHoldings += underlyingAmount;\r\n\r\n        unchecked {\r\n            // Without this the next harvest would count the deposit as profit.\r\n            // Cannot overflow as the balance of one strategy can't exceed the sum of all.\r\n            getStrategyData[strategy].balance += underlyingAmount.safeCastTo248();\r\n        }\r\n\r\n        emit StrategyDeposit(msg.sender, strategy, underlyingAmount);\r\n\r\n        // We need to deposit differently if the strategy takes ETH.\r\n        if (strategy.isEther()) {\r\n            // Unwrap the right amount of WETH.\r\n            WETH(payable(address(UNDERLYING))).withdraw(underlyingAmount);\r\n\r\n            // Deposit into the strategy and assume it will revert on error.\r\n            ETHStrategy(address(strategy)).mint{value: underlyingAmount}();\r\n        } else {\r\n            // Approve underlyingAmount to the strategy so we can deposit.\r\n            UNDERLYING.safeApprove(address(strategy), underlyingAmount);\r\n\r\n            // Deposit into the strategy and revert if it returns an error code.\r\n            require(ERC20Strategy(address(strategy)).mint(underlyingAmount) == 0, \"MINT_FAILED\");\r\n        }\r\n    }\r\n\r\n    /// @notice Withdraw a specific amount of underlying tokens from a strategy.\r\n    /// @param strategy The strategy to withdraw from.\r\n    /// @param underlyingAmount  The amount of underlying tokens to withdraw.\r\n    /// @dev Withdrawing from a strategy will not remove it from the withdrawal queue.\r\n    function withdrawFromStrategy(Strategy strategy, uint256 underlyingAmount) external requiresAuth {\r\n        // A strategy must be trusted before it can be withdrawn from.\r\n        require(getStrategyData[strategy].trusted, \"UNTRUSTED_STRATEGY\");\r\n\r\n        // We don't allow withdrawing 0 to prevent emitting a useless event.\r\n        require(underlyingAmount != 0, \"AMOUNT_CANNOT_BE_ZERO\");\r\n\r\n        // Without this the next harvest would count the withdrawal as a loss.\r\n        getStrategyData[strategy].balance -= underlyingAmount.safeCastTo248();\r\n\r\n        unchecked {\r\n            // Decrease totalStrategyHoldings to account for the withdrawal.\r\n            // Cannot underflow as the balance of one strategy will never exceed the sum of all.\r\n            totalStrategyHoldings -= underlyingAmount;\r\n        }\r\n\r\n        emit StrategyWithdrawal(msg.sender, strategy, underlyingAmount);\r\n\r\n        // Withdraw from the strategy and revert if it returns an error code.\r\n        require(strategy.redeemUnderlying(underlyingAmount) == 0, \"REDEEM_FAILED\");\r\n\r\n        // Wrap the withdrawn Ether into WETH if necessary.\r\n        if (strategy.isEther()) WETH(payable(address(UNDERLYING))).deposit{value: underlyingAmount}();\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////////////\r\n    /// --- STRATEGY TRUST/DISTRUST LOGIC\r\n    ///////////////////////////////////////////////////////////////\r\n\r\n    /// @notice Emitted when a strategy is set to trusted.\r\n    /// @param user The authorized user who trusted the strategy.\r\n    /// @param strategy The strategy that became trusted.\r\n    event StrategyTrusted(address indexed user, Strategy indexed strategy);\r\n\r\n    /// @notice Emitted when a strategy is set to untrusted.\r\n    /// @param user The authorized user who untrusted the strategy.\r\n    /// @param strategy The strategy that became untrusted.\r\n    event StrategyDistrusted(address indexed user, Strategy indexed strategy);\r\n\r\n    /// @notice Stores a strategy as trusted, enabling it to be harvested.\r\n    /// @param strategy The strategy to make trusted.\r\n    function trustStrategy(Strategy strategy) external requiresAuth {\r\n        // Ensure the strategy accepts the correct underlying token.\r\n        // If the strategy accepts ETH the Vault should accept WETH, it'll handle wrapping when necessary.\r\n        require(\r\n            strategy.isEther() ? underlyingIsWETH : ERC20Strategy(address(strategy)).underlying() == UNDERLYING,\r\n            \"WRONG_UNDERLYING\"\r\n        );\r\n\r\n        // Store the strategy as trusted.\r\n        getStrategyData[strategy].trusted = true;\r\n\r\n        emit StrategyTrusted(msg.sender, strategy);\r\n    }\r\n\r\n    /// @notice Stores a strategy as untrusted, disabling it from being harvested.\r\n    /// @param strategy The strategy to make untrusted.\r\n    function distrustStrategy(Strategy strategy) external requiresAuth {\r\n        // Store the strategy as untrusted.\r\n        getStrategyData[strategy].trusted = false;\r\n\r\n        emit StrategyDistrusted(msg.sender, strategy);\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////////////\r\n    /// --- WITHDRAWAL QUEUE LOGIC\r\n    ///////////////////////////////////////////////////////////////\r\n\r\n    /// @notice Emitted when a strategy is pushed to the withdrawal queue.\r\n    /// @param user The authorized user who triggered the push.\r\n    /// @param pushedStrategy The strategy pushed to the withdrawal queue.\r\n    event WithdrawalQueuePushed(address indexed user, Strategy indexed pushedStrategy);\r\n\r\n    /// @notice Emitted when a strategy is popped from the withdrawal queue.\r\n    /// @param user The authorized user who triggered the pop.\r\n    /// @param poppedStrategy The strategy popped from the withdrawal queue.\r\n    event WithdrawalQueuePopped(address indexed user, Strategy indexed poppedStrategy);\r\n\r\n    /// @notice Emitted when the withdrawal queue is updated.\r\n    /// @param user The authorized user who triggered the set.\r\n    /// @param replacedWithdrawalQueue The new withdrawal queue.\r\n    event WithdrawalQueueSet(address indexed user, Strategy[] replacedWithdrawalQueue);\r\n\r\n    /// @notice Emitted when an index in the withdrawal queue is replaced.\r\n    /// @param user The authorized user who triggered the replacement.\r\n    /// @param index The index of the replaced strategy in the withdrawal queue.\r\n    /// @param replacedStrategy The strategy in the withdrawal queue that was replaced.\r\n    /// @param replacementStrategy The strategy that overrode the replaced strategy at the index.\r\n    event WithdrawalQueueIndexReplaced(\r\n        address indexed user,\r\n        uint256 index,\r\n        Strategy indexed replacedStrategy,\r\n        Strategy indexed replacementStrategy\r\n    );\r\n\r\n    /// @notice Emitted when an index in the withdrawal queue is replaced with the tip.\r\n    /// @param user The authorized user who triggered the replacement.\r\n    /// @param index The index of the replaced strategy in the withdrawal queue.\r\n    /// @param replacedStrategy The strategy in the withdrawal queue replaced by the tip.\r\n    /// @param previousTipStrategy The previous tip of the queue that replaced the strategy.\r\n    event WithdrawalQueueIndexReplacedWithTip(\r\n        address indexed user,\r\n        uint256 index,\r\n        Strategy indexed replacedStrategy,\r\n        Strategy indexed previousTipStrategy\r\n    );\r\n\r\n    /// @notice Emitted when the strategies at two indexes are swapped.\r\n    /// @param user The authorized user who triggered the swap.\r\n    /// @param index1 One index involved in the swap\r\n    /// @param index2 The other index involved in the swap.\r\n    /// @param newStrategy1 The strategy (previously at index2) that replaced index1.\r\n    /// @param newStrategy2 The strategy (previously at index1) that replaced index2.\r\n    event WithdrawalQueueIndexesSwapped(\r\n        address indexed user,\r\n        uint256 index1,\r\n        uint256 index2,\r\n        Strategy indexed newStrategy1,\r\n        Strategy indexed newStrategy2\r\n    );\r\n\r\n    /// @dev Withdraw a specific amount of underlying tokens from strategies in the withdrawal queue.\r\n    /// @param underlyingAmount The amount of underlying tokens to pull into float.\r\n    /// @dev Automatically removes depleted strategies from the withdrawal queue.\r\n    function pullFromWithdrawalQueue(uint256 underlyingAmount) internal {\r\n        // We will update this variable as we pull from strategies.\r\n        uint256 amountLeftToPull = underlyingAmount;\r\n\r\n        // We'll start at the tip of the queue and traverse backwards.\r\n        uint256 currentIndex = withdrawalQueue.length - 1;\r\n\r\n        // Iterate in reverse so we pull from the queue in a \"last in, first out\" manner.\r\n        // Will revert due to underflow if we empty the queue before pulling the desired amount.\r\n        for (; ; currentIndex--) {\r\n            // Get the strategy at the current queue index.\r\n            Strategy strategy = withdrawalQueue[currentIndex];\r\n\r\n            // Get the balance of the strategy before we withdraw from it.\r\n            uint256 strategyBalance = getStrategyData[strategy].balance;\r\n\r\n            // If the strategy is currently untrusted or was already depleted:\r\n            if (!getStrategyData[strategy].trusted || strategyBalance == 0) {\r\n                // Remove it from the queue.\r\n                withdrawalQueue.pop();\r\n\r\n                emit WithdrawalQueuePopped(msg.sender, strategy);\r\n\r\n                // Move onto the next strategy.\r\n                continue;\r\n            }\r\n\r\n            uint256 amountToPull = amountLeftToPull < strategyBalance ? amountLeftToPull : strategyBalance;\r\n\r\n            unchecked {\r\n                // Compute the balance of the strategy that will remain after we withdraw.\r\n                // Cannot underflow as we cap the amount to pull at the strategy's balance.\r\n                uint256 strategyBalanceAfterWithdrawal = strategyBalance - amountToPull;\r\n\r\n                // Without this the next harvest would count the withdrawal as a loss.\r\n                getStrategyData[strategy].balance = strategyBalanceAfterWithdrawal.safeCastTo248();\r\n\r\n                // Adjust our goal based on how much we can pull from the strategy.\r\n                // Cannot underflow as we cap the amount to pull at the amount left to pull.\r\n                amountLeftToPull -= amountToPull;\r\n\r\n                emit StrategyWithdrawal(msg.sender, strategy, amountToPull);\r\n\r\n                // Withdraw from the strategy and revert if returns an error code.\r\n                require(strategy.redeemUnderlying(amountToPull) == 0, \"REDEEM_FAILED\");\r\n\r\n                // If we fully depleted the strategy:\r\n                if (strategyBalanceAfterWithdrawal == 0) {\r\n                    // Remove it from the queue.\r\n                    withdrawalQueue.pop();\r\n\r\n                    emit WithdrawalQueuePopped(msg.sender, strategy);\r\n                }\r\n            }\r\n\r\n            // If we've pulled all we need, exit the loop.\r\n            if (amountLeftToPull == 0) break;\r\n        }\r\n\r\n        unchecked {\r\n            // Account for the withdrawals done in the loop above.\r\n            // Cannot underflow as the balances of some strategies cannot exceed the sum of all.\r\n            totalStrategyHoldings -= underlyingAmount;\r\n        }\r\n\r\n        // Cache the Vault's balance of ETH.\r\n        uint256 ethBalance = address(this).balance;\r\n\r\n        // If the Vault's underlying token is WETH compatible and we have some ETH, wrap it into WETH.\r\n        if (ethBalance != 0 && underlyingIsWETH) WETH(payable(address(UNDERLYING))).deposit{value: ethBalance}();\r\n    }\r\n\r\n    /// @notice Pushes a single strategy to front of the withdrawal queue.\r\n    /// @param strategy The strategy to be inserted at the front of the withdrawal queue.\r\n    /// @dev Strategies that are untrusted, duplicated, or have no balance are\r\n    /// filtered out when encountered at withdrawal time, not validated upfront.\r\n    function pushToWithdrawalQueue(Strategy strategy) external requiresAuth {\r\n        // Push the strategy to the front of the queue.\r\n        withdrawalQueue.push(strategy);\r\n\r\n        emit WithdrawalQueuePushed(msg.sender, strategy);\r\n    }\r\n\r\n    /// @notice Removes the strategy at the tip of the withdrawal queue.\r\n    /// @dev Be careful, another authorized user could push a different strategy\r\n    /// than expected to the queue while a popFromWithdrawalQueue transaction is pending.\r\n    function popFromWithdrawalQueue() external requiresAuth {\r\n        // Get the (soon to be) popped strategy.\r\n        Strategy poppedStrategy = withdrawalQueue[withdrawalQueue.length - 1];\r\n\r\n        // Pop the first strategy in the queue.\r\n        withdrawalQueue.pop();\r\n\r\n        emit WithdrawalQueuePopped(msg.sender, poppedStrategy);\r\n    }\r\n\r\n    /// @notice Sets a new withdrawal queue.\r\n    /// @param newQueue The new withdrawal queue.\r\n    /// @dev Strategies that are untrusted, duplicated, or have no balance are\r\n    /// filtered out when encountered at withdrawal time, not validated upfront.\r\n    function setWithdrawalQueue(Strategy[] calldata newQueue) external requiresAuth {\r\n        // Replace the withdrawal queue.\r\n        withdrawalQueue = newQueue;\r\n\r\n        emit WithdrawalQueueSet(msg.sender, newQueue);\r\n    }\r\n\r\n    /// @notice Replaces an index in the withdrawal queue with another strategy.\r\n    /// @param index The index in the queue to replace.\r\n    /// @param replacementStrategy The strategy to override the index with.\r\n    /// @dev Strategies that are untrusted, duplicated, or have no balance are\r\n    /// filtered out when encountered at withdrawal time, not validated upfront.\r\n    function replaceWithdrawalQueueIndex(uint256 index, Strategy replacementStrategy) external requiresAuth {\r\n        // Get the (soon to be) replaced strategy.\r\n        Strategy replacedStrategy = withdrawalQueue[index];\r\n\r\n        // Update the index with the replacement strategy.\r\n        withdrawalQueue[index] = replacementStrategy;\r\n\r\n        emit WithdrawalQueueIndexReplaced(msg.sender, index, replacedStrategy, replacementStrategy);\r\n    }\r\n\r\n    /// @notice Moves the strategy at the tip of the queue to the specified index and pop the tip off the queue.\r\n    /// @param index The index of the strategy in the withdrawal queue to replace with the tip.\r\n    function replaceWithdrawalQueueIndexWithTip(uint256 index) external requiresAuth {\r\n        // Get the (soon to be) previous tip and strategy we will replace at the index.\r\n        Strategy previousTipStrategy = withdrawalQueue[withdrawalQueue.length - 1];\r\n        Strategy replacedStrategy = withdrawalQueue[index];\r\n\r\n        // Replace the index specified with the tip of the queue.\r\n        withdrawalQueue[index] = previousTipStrategy;\r\n\r\n        // Remove the now duplicated tip from the array.\r\n        withdrawalQueue.pop();\r\n\r\n        emit WithdrawalQueueIndexReplacedWithTip(msg.sender, index, replacedStrategy, previousTipStrategy);\r\n    }\r\n\r\n    /// @notice Swaps two indexes in the withdrawal queue.\r\n    /// @param index1 One index involved in the swap\r\n    /// @param index2 The other index involved in the swap.\r\n    function swapWithdrawalQueueIndexes(uint256 index1, uint256 index2) external requiresAuth {\r\n        // Get the (soon to be) new strategies at each index.\r\n        Strategy newStrategy2 = withdrawalQueue[index1];\r\n        Strategy newStrategy1 = withdrawalQueue[index2];\r\n\r\n        // Swap the strategies at both indexes.\r\n        withdrawalQueue[index1] = newStrategy1;\r\n        withdrawalQueue[index2] = newStrategy2;\r\n\r\n        emit WithdrawalQueueIndexesSwapped(msg.sender, index1, index2, newStrategy1, newStrategy2);\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////////////\r\n    /// --- SEIZE STRATEGY LOGIC\r\n    ///////////////////////////////////////////////////////////////\r\n\r\n    /// @notice Emitted after a strategy is seized.\r\n    /// @param user The authorized user who triggered the seize.\r\n    /// @param strategy The strategy that was seized.\r\n    event StrategySeized(address indexed user, Strategy indexed strategy);\r\n\r\n    /// @notice Seizes a strategy.\r\n    /// @param strategy The strategy to seize.\r\n    /// @dev Intended for use in emergencies or other extraneous situations where the\r\n    /// strategy requires interaction outside of the Vault's standard operating procedures.\r\n    function seizeStrategy(Strategy strategy) external requiresAuth {\r\n        // A strategy must be trusted before it can be seized.\r\n        require(getStrategyData[strategy].trusted, \"UNTRUSTED_STRATEGY\");\r\n\r\n        // Get the strategy's last reported balance of underlying tokens.\r\n        uint256 strategyBalance = getStrategyData[strategy].balance;\r\n\r\n        // If the strategy's balance exceeds the Vault's current\r\n        // holdings, instantly unlock any remaining locked profit.\r\n        if (strategyBalance > totalHoldings()) maxLockedProfit = 0;\r\n\r\n        // Set the strategy's balance to 0.\r\n        getStrategyData[strategy].balance = 0;\r\n\r\n        unchecked {\r\n            // Decrease totalStrategyHoldings to account for the seize.\r\n            // Cannot underflow as the balance of one strategy will never exceed the sum of all.\r\n            totalStrategyHoldings -= strategyBalance;\r\n        }\r\n\r\n        emit StrategySeized(msg.sender, strategy);\r\n\r\n        // Transfer all of the strategy's tokens to the caller.\r\n        ERC20(strategy).safeTransfer(msg.sender, strategy.balanceOf(address(this)));\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////////////\r\n    /// --- FEE CLAIM LOGIC\r\n    ///////////////////////////////////////////////////////////////\r\n\r\n    /// @notice Emitted after fees are claimed.\r\n    /// @param user The authorized user who claimed the fees.\r\n    /// @param arTokenAmount The amount of arTokens that were claimed.\r\n    event FeesClaimed(address indexed user, uint256 arTokenAmount);\r\n\r\n    /// @notice Claims fees accrued from harvests.\r\n    /// @param arTokenAmount The amount of arTokens to claim.\r\n    /// @dev Accrued fees are measured as arTokens held by the Vault.\r\n    function claimFees(uint256 arTokenAmount) external requiresAuth {\r\n        emit FeesClaimed(msg.sender, arTokenAmount);\r\n\r\n        // Transfer the provided amount of arTokens to the caller.\r\n        ERC20(this).safeTransfer(msg.sender, arTokenAmount);\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////////////\r\n    /// --- INIT/DESTROY LOGIC\r\n    ///////////////////////////////////////////////////////////////\r\n\r\n    /// @notice Emitted when the Vault is initialized.\r\n    /// @param user The authorized user who triggered the initialization.\r\n    event Initialized(address indexed user);\r\n\r\n    /// @notice Whether the Vault has been initialized yet.\r\n    /// @dev Can go from false to true, never from true to false.\r\n    bool public isInitialized;\r\n\r\n    /// @notice Initializes the Vault, enabling it to receive deposits.\r\n    /// @dev All critical parameters must already be set before calling.\r\n    function initialize() external requiresAuth {\r\n        // Ensure the Vault has not already been initialized.\r\n        require(!isInitialized, \"ALREADY_INITIALIZED\");\r\n\r\n        // Mark the Vault as initialized.\r\n        isInitialized = true;\r\n\r\n        // Open for deposits.\r\n        totalSupply = 0;\r\n\r\n        emit Initialized(msg.sender);\r\n    }\r\n\r\n    /// @notice Self destructs a Vault, enabling it to be redeployed.\r\n    /// @dev Caller will receive any ETH held as float in the Vault.\r\n    function destroy() external requiresAuth {\r\n        selfdestruct(payable(msg.sender));\r\n    }\r\n\r\n    /// @dev Required for the Vault to receive unwrapped ETH.\r\n    receive() external payable {}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"_UNDERLYING\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract Authority\",\"name\":\"newAuthority\",\"type\":\"address\"}],\"name\":\"AuthorityUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"underlyingAmount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFeePercent\",\"type\":\"uint256\"}],\"name\":\"FeePercentUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"arTokenAmount\",\"type\":\"uint256\"}],\"name\":\"FeesClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract Strategy[]\",\"name\":\"strategies\",\"type\":\"address[]\"}],\"name\":\"Harvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"newHarvestDelay\",\"type\":\"uint64\"}],\"name\":\"HarvestDelayUpdateScheduled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"newHarvestDelay\",\"type\":\"uint64\"}],\"name\":\"HarvestDelayUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"newHarvestWindow\",\"type\":\"uint128\"}],\"name\":\"HarvestWindowUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract Strategy\",\"name\":\"strategy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"underlyingAmount\",\"type\":\"uint256\"}],\"name\":\"StrategyDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract Strategy\",\"name\":\"strategy\",\"type\":\"address\"}],\"name\":\"StrategyDistrusted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract Strategy\",\"name\":\"strategy\",\"type\":\"address\"}],\"name\":\"StrategySeized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract Strategy\",\"name\":\"strategy\",\"type\":\"address\"}],\"name\":\"StrategyTrusted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract Strategy\",\"name\":\"strategy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"underlyingAmount\",\"type\":\"uint256\"}],\"name\":\"StrategyWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTargetFloatPercent\",\"type\":\"uint256\"}],\"name\":\"TargetFloatPercentUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"newUnderlyingIsWETH\",\"type\":\"bool\"}],\"name\":\"UnderlyingIsWETHUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"underlyingAmount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newWithdrawalFeePercent\",\"type\":\"uint256\"}],\"name\":\"WithdrawalFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"contract Strategy\",\"name\":\"replacedStrategy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract Strategy\",\"name\":\"replacementStrategy\",\"type\":\"address\"}],\"name\":\"WithdrawalQueueIndexReplaced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"contract Strategy\",\"name\":\"replacedStrategy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract Strategy\",\"name\":\"previousTipStrategy\",\"type\":\"address\"}],\"name\":\"WithdrawalQueueIndexReplacedWithTip\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index2\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"contract Strategy\",\"name\":\"newStrategy1\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract Strategy\",\"name\":\"newStrategy2\",\"type\":\"address\"}],\"name\":\"WithdrawalQueueIndexesSwapped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract Strategy\",\"name\":\"poppedStrategy\",\"type\":\"address\"}],\"name\":\"WithdrawalQueuePopped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract Strategy\",\"name\":\"pushedStrategy\",\"type\":\"address\"}],\"name\":\"WithdrawalQueuePushed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract Strategy[]\",\"name\":\"replacedWithdrawalQueue\",\"type\":\"address[]\"}],\"name\":\"WithdrawalQueueSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BASE_UNIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNDERLYING\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contract Authority\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balanceOfUnderlying\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"arTokenAmount\",\"type\":\"uint256\"}],\"name\":\"claimFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingAmount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Strategy\",\"name\":\"strategy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"underlyingAmount\",\"type\":\"uint256\"}],\"name\":\"depositIntoStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Strategy\",\"name\":\"strategy\",\"type\":\"address\"}],\"name\":\"distrustStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Strategy\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getStrategyData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"trusted\",\"type\":\"bool\"},{\"internalType\":\"uint248\",\"name\":\"balance\",\"type\":\"uint248\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWithdrawalQueue\",\"outputs\":[{\"internalType\":\"contract Strategy[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Strategy[]\",\"name\":\"strategies\",\"type\":\"address[]\"}],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvestDelay\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvestWindow\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isInitialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastHarvest\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastHarvestWindowStart\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockedProfit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxLockedProfit\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextHarvestDelay\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"popFromWithdrawalQueue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Strategy\",\"name\":\"strategy\",\"type\":\"address\"}],\"name\":\"pushToWithdrawalQueue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"arTokenAmount\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeemAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"arTokenAmount\",\"type\":\"uint256\"}],\"name\":\"redeemRestricted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"contract Strategy\",\"name\":\"replacementStrategy\",\"type\":\"address\"}],\"name\":\"replaceWithdrawalQueueIndex\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"replaceWithdrawalQueueIndexWithTip\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Strategy\",\"name\":\"strategy\",\"type\":\"address\"}],\"name\":\"seizeStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Authority\",\"name\":\"newAuthority\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFeePercent\",\"type\":\"uint256\"}],\"name\":\"setFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"newHarvestDelay\",\"type\":\"uint64\"}],\"name\":\"setHarvestDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"newHarvestWindow\",\"type\":\"uint128\"}],\"name\":\"setHarvestWindow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTargetFloatPercent\",\"type\":\"uint256\"}],\"name\":\"setTargetFloatPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"newUnderlyingIsWETH\",\"type\":\"bool\"}],\"name\":\"setUnderlyingIsWETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newWithdrawalFeePercent\",\"type\":\"uint256\"}],\"name\":\"setWithdrawalFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Strategy[]\",\"name\":\"newQueue\",\"type\":\"address[]\"}],\"name\":\"setWithdrawalQueue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index2\",\"type\":\"uint256\"}],\"name\":\"swapWithdrawalQueueIndexes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetFloatPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFloat\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalHoldings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalUnderlyingHeld\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStrategyHoldings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Strategy\",\"name\":\"strategy\",\"type\":\"address\"}],\"name\":\"trustStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlyingIsWETH\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"underlyingAmount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Strategy\",\"name\":\"strategy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"underlyingAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawFromStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalFeePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"withdrawalQueue\",\"outputs\":[{\"internalType\":\"contract Strategy\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Vault", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000603c7f932ed1fc6575303d8fb018fdcbb0f39a95", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d40d7d9370927e095c8ffa3f9bae214e993ee3717d8624c65e973397d4d73408"}