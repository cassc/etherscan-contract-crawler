{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/FarmBooster.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport \\\"@openzeppelin-4.5.0/contracts/access/Ownable.sol\\\";\\nimport \\\"bsc-library/contracts/IBEP20.sol\\\";\\nimport \\\"./interfaces/ICakePool.sol\\\";\\nimport \\\"./interfaces/IMasterChefV2.sol\\\";\\nimport \\\"./libraries/IterateMapping.sol\\\";\\n\\ncontract FarmBooster is Ownable {\\n    using IterableMapping for ItMap;\\n\\n    /// @notice cake token.\\n    address public immutable CAKE;\\n    /// @notice cake pool.\\n    address public immutable CAKE_POOL;\\n    /// @notice MCV2 contract.\\n    address public immutable MASTER_CHEF;\\n    /// @notice boost proxy factory.\\n    address public BOOSTER_FACTORY;\\n\\n    /// @notice Maximum allowed boosted pool numbers\\n    uint256 public MAX_BOOST_POOL;\\n    /// @notice limit max boost\\n    uint256 public cA;\\n    /// @notice include 1e4\\n    uint256 public constant MIN_CA = 1e4;\\n    /// @notice include 1e5\\n    uint256 public constant MAX_CA = 1e5;\\n    /// @notice cA precision\\n    uint256 public constant CA_PRECISION = 1e5;\\n    /// @notice controls difficulties\\n    uint256 public cB;\\n    /// @notice not include 0\\n    uint256 public constant MIN_CB = 0;\\n    /// @notice include 50\\n    uint256 public constant MAX_CB = 50;\\n    /// @notice MCV2 basic boost factor, none boosted user's boost factor\\n    uint256 public constant BOOST_PRECISION = 100 * 1e10;\\n    /// @notice MCV2 Hard limit for maxmium boost factor\\n    uint256 public constant MAX_BOOST_PRECISION = 200 * 1e10;\\n    /// @notice Average boost ratio precion\\n    uint256 public constant BOOST_RATIO_PRECISION = 1e5;\\n    /// @notice Cake pool BOOST_WEIGHT precision\\n    uint256 public constant BOOST_WEIGHT_PRECISION = 100 * 1e10; // 100%\\n\\n    /// @notice The whitelist of pools allowed for farm boosting.\\n    mapping(uint256 => bool) public whiteList;\\n    /// @notice The boost proxy contract mapping(user => proxy).\\n    mapping(address => address) public proxyContract;\\n    /// @notice Info of each pool user.\\n    mapping(address => ItMap) public userInfo;\\n\\n    event UpdateMaxBoostPool(uint256 factory);\\n    event UpdateBoostFactory(address factory);\\n    event UpdateCA(uint256 oldCA, uint256 newCA);\\n    event UpdateCB(uint256 oldCB, uint256 newCB);\\n    event Refresh(address indexed user, address proxy, uint256 pid);\\n    event UpdateBoostFarms(uint256 pid, bool status);\\n    event ActiveFarmPool(address indexed user, address proxy, uint256 pid);\\n    event DeactiveFarmPool(address indexed user, address proxy, uint256 pid);\\n    event UpdateBoostProxy(address indexed user, address proxy);\\n    event UpdatePoolBoostMultiplier(address indexed user, uint256 pid, uint256 oldMultiplier, uint256 newMultiplier);\\n    event UpdateCakePool(\\n        address indexed user,\\n        uint256 lockedAmount,\\n        uint256 lockedDuration,\\n        uint256 totalLockedAmount,\\n        uint256 maxLockDuration\\n    );\\n\\n    /// @param _cake CAKE token contract address.\\n    /// @param _cakePool Cake Pool contract address.\\n    /// @param _v2 MasterChefV2 contract address.\\n    /// @param _max Maximum allowed boosted farm  quantity\\n    /// @param _cA Limit max boost\\n    /// @param _cB Controls difficulties\\n    constructor(\\n        address _cake,\\n        address _cakePool,\\n        address _v2,\\n        uint256 _max,\\n        uint256 _cA,\\n        uint256 _cB\\n    ) {\\n        require(\\n            _max > 0 && _cA >= MIN_CA && _cA <= MAX_CA && _cB > MIN_CB && _cB <= MAX_CB,\\n            \\\"constructor: Invalid parameter\\\"\\n        );\\n        CAKE = _cake;\\n        CAKE_POOL = _cakePool;\\n        MASTER_CHEF = _v2;\\n        MAX_BOOST_POOL = _max;\\n        cA = _cA;\\n        cB = _cB;\\n    }\\n\\n    /// @notice Checks if the msg.sender is a contract or a proxy\\n    modifier notContract() {\\n        require(!_isContract(msg.sender), \\\"contract not allowed\\\");\\n        require(msg.sender == tx.origin, \\\"proxy contract not allowed\\\");\\n        _;\\n    }\\n\\n    /// @notice Checks if the msg.sender is the FarmBooster Factory.\\n    modifier onlyFactory() {\\n        require(msg.sender == BOOSTER_FACTORY, \\\"onlyFactory: Not factory\\\");\\n        _;\\n    }\\n\\n    /// @notice Checks if the msg.sender is the FarmBooster Proxy.\\n    modifier onlyProxy(address _user) {\\n        require(msg.sender == proxyContract[_user], \\\"onlyProxy: Not proxy\\\");\\n        _;\\n    }\\n\\n    /// @notice Checks if the msg.sender is the cake pool.\\n    modifier onlyCakePool() {\\n        require(msg.sender == CAKE_POOL, \\\"onlyCakePool: Not cake pool\\\");\\n        _;\\n    }\\n\\n    /// @notice set maximum allowed boosted pool numbers.\\n    function setMaxBoostPool(uint256 _max) external onlyOwner {\\n        require(_max > 0, \\\"setMaxBoostPool: Maximum boost pool should greater than 0\\\");\\n        MAX_BOOST_POOL = _max;\\n        emit UpdateMaxBoostPool(_max);\\n    }\\n\\n    /// @notice set boost factory contract.\\n    function setBoostFactory(address _factory) external onlyOwner {\\n        require(_factory != address(0), \\\"setBoostFactory: Invalid factory\\\");\\n        BOOSTER_FACTORY = _factory;\\n\\n        emit UpdateBoostFactory(_factory);\\n    }\\n\\n    /// @notice Set user boost proxy contract, can only invoked by boost contract.\\n    /// @param _user boost user address.\\n    /// @param _proxy boost proxy contract.\\n    function setProxy(address _user, address _proxy) external onlyFactory {\\n        require(_proxy != address(0), \\\"setProxy: Invalid proxy address\\\");\\n        require(proxyContract[_user] == address(0), \\\"setProxy: User has already set proxy\\\");\\n\\n        proxyContract[_user] = _proxy;\\n\\n        emit UpdateBoostProxy(_user, _proxy);\\n    }\\n\\n    /// @notice Only allow whitelisted pids for farm boosting\\n    /// @param _pid pool id(MasterchefV2 pool).\\n    /// @param _status farm pool allowed boosted or not\\n    function setBoosterFarms(uint256 _pid, bool _status) external onlyOwner {\\n        whiteList[_pid] = _status;\\n        emit UpdateBoostFarms(_pid, _status);\\n    }\\n\\n    /// @notice limit max boost\\n    /// @param _cA max boost\\n    function setCA(uint256 _cA) external onlyOwner {\\n        require(_cA >= MIN_CA && _cA <= MAX_CA, \\\"setCA: Invalid cA\\\");\\n        uint256 temp = cA;\\n        cA = _cA;\\n        emit UpdateCA(temp, cA);\\n    }\\n\\n    /// @notice controls difficulties\\n    /// @param _cB difficulties\\n    function setCB(uint256 _cB) external onlyOwner {\\n        require(_cB > MIN_CB && _cB <= MAX_CB, \\\"setCB: Invalid cB\\\");\\n        uint256 temp = cB;\\n        cB = _cB;\\n        emit UpdateCB(temp, cB);\\n    }\\n\\n    /// @notice Cakepool operation(deposit/withdraw) automatically call this function.\\n    /// @param _user user address.\\n    /// @param _lockedAmount user locked amount in cake pool.\\n    /// @param _lockedDuration user locked duration in cake pool.\\n    /// @param _totalLockedAmount Total locked cake amount in cake pool.\\n    /// @param _maxLockDuration maximum locked duration in cake pool.\\n    function onCakePoolUpdate(\\n        address _user,\\n        uint256 _lockedAmount,\\n        uint256 _lockedDuration,\\n        uint256 _totalLockedAmount,\\n        uint256 _maxLockDuration\\n    ) external onlyCakePool {\\n        address proxy = proxyContract[_user];\\n        ItMap storage itmap = userInfo[proxy];\\n        uint256 avgDuration;\\n        bool flag;\\n        for (uint256 i = 0; i < itmap.keys.length; i++) {\\n            uint256 pid = itmap.keys[i];\\n            if (!flag) {\\n                avgDuration = avgLockDuration();\\n                flag = true;\\n            }\\n            _updateBoostMultiplier(_user, proxy, pid, avgDuration);\\n        }\\n\\n        emit UpdateCakePool(_user, _lockedAmount, _lockedDuration, _totalLockedAmount, _maxLockDuration);\\n    }\\n\\n    /// @notice Update user boost multiplier in V2 pool,only for proxy.\\n    /// @param _user user address.\\n    /// @param _pid pool id in MasterchefV2 pool.\\n    function updatePoolBoostMultiplier(address _user, uint256 _pid) public onlyProxy(_user) {\\n        // if user not actived this farm, just return.\\n        if (!userInfo[msg.sender].contains(_pid)) return;\\n        _updateBoostMultiplier(_user, msg.sender, _pid, avgLockDuration());\\n    }\\n\\n    /// @notice Active user farm pool.\\n    /// @param _pid pool id(MasterchefV2 pool).\\n    function activate(uint256 _pid) external {\\n        address proxy = proxyContract[msg.sender];\\n        require(whiteList[_pid] && proxy != address(0), \\\"activate: Not boosted farm pool\\\");\\n\\n        ItMap storage itmap = userInfo[proxy];\\n        require(itmap.keys.length < MAX_BOOST_POOL, \\\"activate: Boosted farms reach to MAX\\\");\\n\\n        _updateBoostMultiplier(msg.sender, proxy, _pid, avgLockDuration());\\n\\n        emit ActiveFarmPool(msg.sender, proxy, _pid);\\n    }\\n\\n    /// @notice Deactive user farm pool.\\n    /// @param _pid pool id(MasterchefV2 pool).\\n    function deactive(uint256 _pid) external {\\n        address proxy = proxyContract[msg.sender];\\n        ItMap storage itmap = userInfo[proxy];\\n        require(itmap.contains(_pid), \\\"deactive: None boost user\\\");\\n\\n        if (itmap.data[_pid] > BOOST_PRECISION) {\\n            IMasterChefV2(MASTER_CHEF).updateBoostMultiplier(proxy, _pid, BOOST_PRECISION);\\n        }\\n        itmap.remove(_pid);\\n\\n        emit DeactiveFarmPool(msg.sender, proxy, _pid);\\n    }\\n\\n    /// @notice Anyone can refesh sepecific user boost multiplier\\n    /// @param _user user address.\\n    /// @param _pid pool id(MasterchefV2 pool).\\n    function refresh(address _user, uint256 _pid) external notContract {\\n        address proxy = proxyContract[_user];\\n        ItMap storage itmap = userInfo[proxy];\\n        require(itmap.contains(_pid), \\\"refresh: None boost user\\\");\\n\\n        _updateBoostMultiplier(_user, proxy, _pid, avgLockDuration());\\n\\n        emit Refresh(_user, proxy, _pid);\\n    }\\n\\n    /// @notice Whether user boosted specific farm pool.\\n    /// @param _user user address.\\n    /// @param _pid pool id(MasterchefV2 pool).\\n    function isBoostedPool(address _user, uint256 _pid) external view returns (bool) {\\n        return userInfo[proxyContract[_user]].contains(_pid);\\n    }\\n\\n    /// @notice Actived farm pool list.\\n    /// @param _user user address.\\n    function activedPools(address _user) external view returns (uint256[] memory pools) {\\n        ItMap storage itmap = userInfo[proxyContract[_user]];\\n        if (itmap.keys.length == 0) return pools;\\n\\n        pools = new uint256[](itmap.keys.length);\\n        // solidity for-loop not support multiple variables initializae by ',' separate.\\n        uint256 i;\\n        for (uint256 index = 0; index < itmap.keys.length; index++) {\\n            uint256 pid = itmap.keys[index];\\n            pools[i] = pid;\\n            i++;\\n        }\\n    }\\n\\n    /// @notice Anyone can call this function, if you find some guys effectived multiplier is not fair\\n    /// for other users, just call 'refresh' function.\\n    /// @param _user user address.\\n    /// @param _pid pool id(MasterchefV2 pool).\\n    /// @dev If return value not in range [BOOST_PRECISION, MAX_BOOST_PRECISION]\\n    /// the actual effectived multiplier will be the close to side boundry value.\\n    function getUserMultiplier(address _user, uint256 _pid) external view returns (uint256) {\\n        return _boostCalculate(_user, proxyContract[_user], _pid, avgLockDuration());\\n    }\\n\\n    /// @notice cake pool average locked duration calculator.\\n    function avgLockDuration() public view returns (uint256) {\\n        uint256 totalStakedAmount = IBEP20(CAKE).balanceOf(CAKE_POOL);\\n\\n        uint256 totalLockedAmount = ICakePool(CAKE_POOL).totalLockedAmount();\\n\\n        uint256 pricePerFullShare = ICakePool(CAKE_POOL).getPricePerFullShare();\\n\\n        uint256 flexibleShares = ((totalStakedAmount - totalLockedAmount) * 1e18) / pricePerFullShare;\\n        if (flexibleShares == 0) return 0;\\n\\n        uint256 originalShares = (totalLockedAmount * 1e18) / pricePerFullShare;\\n        if (originalShares == 0) return 0;\\n\\n        uint256 boostedRatio = ((ICakePool(CAKE_POOL).totalShares() - flexibleShares) * BOOST_RATIO_PRECISION) /\\n            originalShares;\\n        if (boostedRatio <= BOOST_RATIO_PRECISION) return 0;\\n\\n        uint256 boostWeight = ICakePool(CAKE_POOL).BOOST_WEIGHT();\\n        uint256 maxLockDuration = ICakePool(CAKE_POOL).MAX_LOCK_DURATION() * BOOST_RATIO_PRECISION;\\n\\n        uint256 duration = ((boostedRatio - BOOST_RATIO_PRECISION) * 365 * BOOST_WEIGHT_PRECISION) / boostWeight;\\n        return duration <= maxLockDuration ? duration : maxLockDuration;\\n    }\\n\\n    /// @param _user user address.\\n    /// @param _proxy proxy address corresponding to the user.\\n    /// @param _pid pool id.\\n    /// @param _duration cake pool average locked duration.\\n    function _updateBoostMultiplier(\\n        address _user,\\n        address _proxy,\\n        uint256 _pid,\\n        uint256 _duration\\n    ) internal {\\n        ItMap storage itmap = userInfo[_proxy];\\n\\n        // Used to be boost farm pool and current is not, remove from mapping\\n        if (!whiteList[_pid]) {\\n            if (itmap.data[_pid] > BOOST_PRECISION) {\\n                // reset to BOOST_PRECISION\\n                IMasterChefV2(MASTER_CHEF).updateBoostMultiplier(_proxy, _pid, BOOST_PRECISION);\\n            }\\n            itmap.remove(_pid);\\n            return;\\n        }\\n\\n        uint256 prevMultiplier = IMasterChefV2(MASTER_CHEF).getBoostMultiplier(_proxy, _pid);\\n        uint256 multiplier = _boostCalculate(_user, _proxy, _pid, _duration);\\n\\n        if (multiplier < BOOST_PRECISION) {\\n            multiplier = BOOST_PRECISION;\\n        } else if (multiplier > MAX_BOOST_PRECISION) {\\n            multiplier = MAX_BOOST_PRECISION;\\n        }\\n\\n        // Update multiplier to MCV2\\n        if (multiplier != prevMultiplier) {\\n            IMasterChefV2(MASTER_CHEF).updateBoostMultiplier(_proxy, _pid, multiplier);\\n        }\\n        itmap.insert(_pid, multiplier);\\n\\n        emit UpdatePoolBoostMultiplier(_user, _pid, prevMultiplier, multiplier);\\n    }\\n\\n    /// @param _user user address.\\n    /// @param _proxy proxy address corresponding to the user.\\n    /// @param _pid pool id(MasterchefV2 pool).\\n    /// @param _duration cake pool average locked duration.\\n    function _boostCalculate(\\n        address _user,\\n        address _proxy,\\n        uint256 _pid,\\n        uint256 _duration\\n    ) internal view returns (uint256) {\\n        if (_duration == 0) return BOOST_PRECISION;\\n\\n        (uint256 lpBalance, , ) = IMasterChefV2(MASTER_CHEF).userInfo(_pid, _proxy);\\n        uint256 dB = (cA * lpBalance) / CA_PRECISION;\\n        // dB == 0 means lpBalance close to 0\\n        if (lpBalance == 0 || dB == 0) return BOOST_PRECISION;\\n\\n        (, , , , uint256 lockStartTime, uint256 lockEndTime, , , uint256 userLockedAmount) = ICakePool(CAKE_POOL)\\n            .userInfo(_user);\\n        if (userLockedAmount == 0 || block.timestamp >= lockEndTime) return BOOST_PRECISION;\\n\\n        // userLockedAmount > 0 means totalLockedAmount > 0\\n        uint256 totalLockedAmount = ICakePool(CAKE_POOL).totalLockedAmount();\\n\\n        IBEP20 lp = IBEP20(IMasterChefV2(MASTER_CHEF).lpToken(_pid));\\n        uint256 userLockedDuration = (lockEndTime - lockStartTime) / (3600 * 24); // days\\n\\n        uint256 aB = (((lp.balanceOf(MASTER_CHEF) * userLockedAmount * userLockedDuration) * BOOST_RATIO_PRECISION) /\\n            cB) / (totalLockedAmount * _duration);\\n\\n        // should '*' BOOST_PRECISION\\n        return ((lpBalance < (dB + aB) ? lpBalance : (dB + aB)) * BOOST_PRECISION) / dB;\\n    }\\n\\n    /// @notice Checks if address is a contract\\n    /// @dev It prevents contract from being targetted\\n    function _isContract(address addr) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(addr)\\n        }\\n        return size > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin-4.5.0/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"bsc-library/contracts/IBEP20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.4.0;\\n\\ninterface IBEP20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the token decimals.\\n   */\\n  function decimals() external view returns (uint8);\\n\\n  /**\\n   * @dev Returns the token symbol.\\n   */\\n  function symbol() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the token name.\\n   */\\n  function name() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the bep token owner.\\n   */\\n  function getOwner() external view returns (address);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address _owner, address spender)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICakePool.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ICakePool {\\n    function userInfo(address _user)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            bool,\\n            uint256\\n        );\\n\\n    function getPricePerFullShare() external view returns (uint256);\\n\\n    function totalLockedAmount() external view returns (uint256);\\n\\n    function totalShares() external view returns (uint256);\\n\\n    function BOOST_WEIGHT() external view returns (uint256);\\n\\n    function MAX_LOCK_DURATION() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMasterChefV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\ninterface IMasterChefV2 {\\n    function deposit(uint256 _pid, uint256 _amount) external;\\n\\n    function withdraw(uint256 _pid, uint256 _amount) external;\\n\\n    function pendingCake(uint256 _pid, address _user) external view returns (uint256);\\n\\n    function userInfo(uint256 _pid, address _user)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function emergencyWithdraw(uint256 _pid) external;\\n\\n    function lpToken(uint256 _pid) external view returns (address);\\n\\n    function poolLength() external view returns (uint256 pools);\\n\\n    function getBoostMultiplier(address _user, uint256 _pid) external view returns (uint256);\\n\\n    function updateBoostMultiplier(\\n        address _user,\\n        uint256 _pid,\\n        uint256 _newMultiplier\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/IterateMapping.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nstruct ItMap {\\n    // pid => boost\\n    mapping(uint256 => uint256) data;\\n    // pid => index\\n    mapping(uint256 => uint256) indexs;\\n    // array of pid\\n    uint256[] keys;\\n    // never use it, just for keep compile success.\\n    uint256 size;\\n}\\n\\nlibrary IterableMapping {\\n    function insert(\\n        ItMap storage self,\\n        uint256 key,\\n        uint256 value\\n    ) internal {\\n        uint256 keyIndex = self.indexs[key];\\n        self.data[key] = value;\\n        if (keyIndex > 0) return;\\n        else {\\n            self.indexs[key] = self.keys.length + 1;\\n            self.keys.push(key);\\n            return;\\n        }\\n    }\\n\\n    function remove(ItMap storage self, uint256 key) internal {\\n        uint256 index = self.indexs[key];\\n        if (index == 0) return;\\n        uint256 lastKey = self.keys[self.keys.length - 1];\\n        if (key != lastKey) {\\n            self.keys[index - 1] = lastKey;\\n            self.indexs[lastKey] = index;\\n        }\\n        delete self.data[key];\\n        delete self.indexs[key];\\n        self.keys.pop();\\n    }\\n\\n    function contains(ItMap storage self, uint256 key) internal view returns (bool) {\\n        return self.indexs[key] > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin-4.5.0/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 99999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_cake\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_cakePool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_v2\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_max\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_cA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_cB\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"}],\"name\":\"ActiveFarmPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"}],\"name\":\"DeactiveFarmPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"}],\"name\":\"Refresh\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"}],\"name\":\"UpdateBoostFactory\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"UpdateBoostFarms\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"UpdateBoostProxy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldCA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCA\",\"type\":\"uint256\"}],\"name\":\"UpdateCA\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldCB\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCB\",\"type\":\"uint256\"}],\"name\":\"UpdateCB\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockedDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalLockedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxLockDuration\",\"type\":\"uint256\"}],\"name\":\"UpdateCakePool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"factory\",\"type\":\"uint256\"}],\"name\":\"UpdateMaxBoostPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMultiplier\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMultiplier\",\"type\":\"uint256\"}],\"name\":\"UpdatePoolBoostMultiplier\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BOOSTER_FACTORY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BOOST_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BOOST_RATIO_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BOOST_WEIGHT_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CAKE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CAKE_POOL\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CA_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MASTER_CHEF\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BOOST_POOL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BOOST_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_CA\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_CB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_CA\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_CB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"activate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"activedPools\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"pools\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"avgLockDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cA\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"deactive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"getUserMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"isBoostedPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_lockedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lockedDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalLockedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxLockDuration\",\"type\":\"uint256\"}],\"name\":\"onCakePoolUpdate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"proxyContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"refresh\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"name\":\"setBoostFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setBoosterFarms\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cA\",\"type\":\"uint256\"}],\"name\":\"setCA\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cB\",\"type\":\"uint256\"}],\"name\":\"setCB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_max\",\"type\":\"uint256\"}],\"name\":\"setMaxBoostPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_proxy\",\"type\":\"address\"}],\"name\":\"setProxy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"updatePoolBoostMultiplier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"whiteList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "FarmBooster", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "99999", "ConstructorArguments": "0000000000000000000000000e09fabb73bd3ade0a17ecc321fd13a19e81ce8200000000000000000000000045c54210128a065de780c4b0df3d16664f7f859e000000000000000000000000a5f8c5dbd5f286960b9d90548680ae5ebff076520000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000c350000000000000000000000000000000000000000000000000000000000000000a", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}