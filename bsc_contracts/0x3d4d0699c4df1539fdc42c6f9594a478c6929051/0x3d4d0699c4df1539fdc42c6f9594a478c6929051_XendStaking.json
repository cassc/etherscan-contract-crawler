{"SourceCode": "// SPDX-License-Identifier: MIT\r\n// File: contracts/interfaces/IXend.sol\r\n\r\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @title ICliq\r\n * @dev   Contract interface for token contract \r\n */\r\ninterface IXend {\r\n  function name() external view returns (string memory);\r\n  function symbol() external view returns (string memory);\r\n  function decimals() external view returns (uint8);\r\n  function totalSupply() external view returns (uint256);\r\n  function balanceOf(address) external view returns (uint256);\r\n  function allowance(address, address) external view returns (uint256);\r\n  function transfer(address, uint256) external returns (bool);\r\n  function transferFrom(address, address, uint256) external returns (bool);\r\n}\r\n// File: contracts/SafeMath.sol\r\n\r\n\r\n\r\npragma solidity 0.6.12;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        uint256 c = a + b;\r\n        if (c < a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b > a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n// File: contracts/XendStaking.sol\r\n\r\n\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n/**\r\n * @title Staking\r\n * @dev   Staking Contract\r\n */\r\ncontract XendStaking {\r\n    \r\n  using SafeMath for uint256;\r\n  address private _owner;                                           // variable for Owner of the Contract.\r\n\r\n  uint256 public constant BASIS_POINT = 100000;\r\n\r\n  struct Package {\r\n    string name;                          // variable for package name\r\n    uint256 period;                       // variable for time period management (days)\r\n    uint256 withdrawTime;                 // variable to manage withdraw time lock up (timestamp)\r\n    uint256 tokenRewardPercent;           // variable to manage token reward percentage\r\n    uint256 tokenPenaltyPercent;          // variable to manage token penalty percentage \r\n    uint256 limit;                        // variable for max token amount that can be staked, the same as capacity of pacakge\r\n  }\r\n\r\n  Package[] public categories;\r\n  \r\n  // events to handle staking pause or unpause for token\r\n  event Paused();\r\n  event Unpaused();\r\n  \r\n  event PackageAdded(\r\n    uint256 packageId,\r\n    string name,\r\n    uint256 period,\r\n    uint256 withdrawTime,\r\n    uint256 tokenRewardPercent,\r\n    uint256 tokenPenaltyPercent,\r\n    uint256 limit\r\n  );\r\n\r\n  event PackageUpdated(\r\n    uint256 packageId,\r\n    string name,\r\n    uint256 period,\r\n    uint256 withdrawTime,\r\n    uint256 tokenRewardPercent,\r\n    uint256 tokenPenaltyPercent,\r\n    uint256 limit\r\n  );\r\n  \r\n  event Deposit(\r\n    address user,\r\n    uint256 amount,\r\n    uint256 time,\r\n    uint256 stakingId,\r\n    uint256 timestamp\r\n  );\r\n\r\n  event Withdraw(\r\n    address user,\r\n    uint256 stakingId,\r\n    uint256 amount,\r\n    uint256 rewardAmount,\r\n    uint256 timestamp\r\n  );\r\n  \r\n  /*\r\n  * ---------------------------------------------------------------------------------------------------------------------------\r\n  * Functions for owner.\r\n  * ---------------------------------------------------------------------------------------------------------------------------\r\n  */\r\n\r\n   /**\r\n   * @dev get address of smart contract owner\r\n   * @return address of owner\r\n   */\r\n   function getowner() external view returns (address) {\r\n     return _owner;\r\n   }\r\n\r\n   /**\r\n   * @dev modifier to check if the message sender is owner\r\n   */\r\n   modifier onlyOwner() {\r\n     require(isOwner(),\"You are not authenticate to make this transfer\");\r\n     _;\r\n   }\r\n\r\n   /**\r\n   * @dev Internal function for modifier\r\n   */\r\n   function isOwner() internal view returns (bool) {\r\n      return msg.sender == _owner;\r\n   }\r\n\r\n   /**\r\n   * @dev Transfer ownership of the smart contract. For owner only\r\n   * @return request status\r\n   */\r\n   function transferOwnership(address newOwner) external onlyOwner returns (bool){\r\n      _owner = newOwner;\r\n      return true;\r\n   }\r\n   \r\n  /*\r\n  * ---------------------------------------------------------------------------------------------------------------------------\r\n  * Functionality of Constructor and Interface  \r\n  * ---------------------------------------------------------------------------------------------------------------------------\r\n  */\r\n  \r\n  // constructor to declare owner of the contract during time of deploy  \r\n  constructor() public {\r\n     _owner = msg.sender;\r\n  }\r\n  \r\n  // Interface declaration for contract\r\n  IXend ixend;\r\n    \r\n  // function to set Contract Address for Token Transfer Functions\r\n  function setContractAddress(address tokenContractAddress) external onlyOwner returns(bool){\r\n    ixend = IXend(tokenContractAddress);\r\n    return true;\r\n  }\r\n  \r\n   /*\r\n  * ----------------------------------------------------------------------------------------------------------------------------\r\n  * Owner functions of get value, set value and other Functionality\r\n  * ----------------------------------------------------------------------------------------------------------------------------\r\n  */\r\n\r\n  // function to add new category\r\n  function addPackage(\r\n    string memory _name,\r\n    uint256 _period,                    // variable for time period management (days)\r\n    uint256 _withdrawTime,              // variable to manage withdraw time lock up (timestamp)\r\n    uint256 _tokenRewardPercent,        // variable to manage token reward percentage\r\n    uint256 _tokenPenaltyPercent,       // variable to manage token penalty percentage \r\n    uint256 _limit                      // variable for max token amount that can be staked, the same as capacity of pacakge\r\n  ) external onlyOwner returns(bool) {\r\n    // simple validation check\r\n    assert(_period > 1);\r\n    assert(_withdrawTime > 1 days && _withdrawTime <= _period * 1 days);\r\n    assert(_tokenRewardPercent != 0);\r\n    assert(_tokenPenaltyPercent <= _tokenRewardPercent);\r\n    assert(_limit >= 0);\r\n\r\n    // more check\r\n    for (uint i = 0; i < categories.length; i++) {\r\n      if (_period == categories[i].period) assert(false);       // can't add package that has the same period as the existing package\r\n    }\r\n\r\n    Package memory package = Package({\r\n      name: _name,\r\n      period: _period,\r\n      withdrawTime: _withdrawTime,\r\n      tokenRewardPercent: _tokenRewardPercent,\r\n      tokenPenaltyPercent: _tokenPenaltyPercent,\r\n      limit: _limit\r\n    });\r\n\r\n    categories.push(package);\r\n    \r\n    emit PackageAdded(\r\n      categories.length - 1,\r\n      _name,\r\n      _period,\r\n      _withdrawTime,\r\n      _tokenRewardPercent,\r\n      _tokenPenaltyPercent,\r\n      _limit\r\n    );\r\n\r\n    return true;\r\n  }\r\n\r\n  // function to set package parameters\r\n  function setPackage(\r\n    uint256 packageId,                      // package id to set\r\n    string memory _name,\r\n    uint256 _period, \r\n    uint256 _withdrawTime, \r\n    uint256 _tokenRewardPercent, \r\n    uint256 _tokenPenaltyPercent, \r\n    uint256 _limit\r\n  ) external onlyOwner returns (bool) {\r\n    // simple validation check\r\n    assert(_period > 1);\r\n    assert(_withdrawTime > 1 days && _withdrawTime <= _period * 1 days);\r\n    assert(_tokenRewardPercent != 0);\r\n    assert(_tokenPenaltyPercent <= _tokenRewardPercent);\r\n    assert(_limit >= 0);\r\n\r\n    // confirm\r\n    for (uint i = 0; i < categories.length; i++) {\r\n      if (packageId == i) continue;\r\n      if (_period == categories[i].period) assert(false);       // can't add package that has the same period as the existing package\r\n    }\r\n\r\n    categories[packageId] = Package({\r\n      name: _name,\r\n      period: _period,\r\n      withdrawTime: _withdrawTime,\r\n      tokenRewardPercent: _tokenRewardPercent,\r\n      tokenPenaltyPercent: _tokenPenaltyPercent,\r\n      limit: _limit\r\n    });\r\n\r\n    emit PackageUpdated(\r\n      packageId,\r\n      _name,\r\n      _period,\r\n      _withdrawTime,\r\n      _tokenRewardPercent,\r\n      _tokenPenaltyPercent,\r\n      _limit\r\n    );\r\n\r\n    return true;\r\n  }\r\n  \r\n  // function to add token reward in contract\r\n  function addTokenReward(uint256 token) external onlyOwner returns(bool){\r\n    ixend.transferFrom(msg.sender, address(this), token);\r\n    _ownerTokenAllowance = _ownerTokenAllowance.add(token);\r\n    return true;\r\n  }\r\n  \r\n  // function to withdraw added token reward in contract\r\n  function withdrawAddedTokenReward(uint256 token) external onlyOwner returns(bool){\r\n    require(token < _ownerTokenAllowance,\"Value is not feasible, Please Try Again!!!\");\r\n    ixend.transferFrom(address(this), msg.sender, token);\r\n    _ownerTokenAllowance = _ownerTokenAllowance.sub(token);\r\n    return true;\r\n  }\r\n  \r\n  // function to get token reward in contract\r\n  function getTokenReward() external view returns(uint256){\r\n    return _ownerTokenAllowance;\r\n  }\r\n\r\n  // function to get distributed reward amount of the system\r\n  function getDistributedRewardAmount() external view returns (uint256) {\r\n    return _distributedRewardAmount;\r\n  }\r\n  \r\n  // function to pause Token Staking\r\n  function pauseTokenStaking() external onlyOwner {\r\n    tokenPaused = true;\r\n    emit Paused();\r\n  }\r\n\r\n  // function to unpause Token Staking\r\n  function unpauseTokenStaking() external onlyOwner {\r\n    tokenPaused = false;\r\n    emit Unpaused();\r\n  }\r\n  \r\n  /*\r\n  * ----------------------------------------------------------------------------------------------------------------------------\r\n  * Variable, Mapping for Token Staking Functionality\r\n  * ----------------------------------------------------------------------------------------------------------------------------\r\n  */\r\n  \r\n  // mapping for users with id => address Staking Address\r\n  mapping (uint256 => address) private _tokenStakingAddress;\r\n  \r\n  // mapping for users with address => id staking id\r\n  mapping (address => uint256[]) private _tokenStakingId;\r\n\r\n  // mapping for users with id => Staking Time\r\n  mapping (uint256 => uint256) private _tokenStakingStartTime;\r\n  \r\n  // mapping for users with id => End Time\r\n  mapping (uint256 => uint256) private _tokenStakingEndTime;\r\n\r\n  // mapping for users with id => Tokens \r\n  mapping (uint256 => uint256) private _usersTokens;\r\n  \r\n  // mapping for users with id => Status\r\n  mapping (uint256 => bool) private _TokenTransactionStatus;    \r\n  \r\n  // mapping to keep track of final withdraw value of staked token\r\n  mapping(uint256=>uint256) private _finalTokenStakeWithdraw;\r\n  \r\n  // mapping to keep track total number of staking days\r\n  mapping(uint256=>uint256) private _tokenTotalDays;\r\n  \r\n  // variable to keep count of Token Staking\r\n  uint256 private _tokenStakingCount = 0;\r\n  \r\n  // variable to keep track on reward added by owner\r\n  uint256 private _ownerTokenAllowance = 0;\r\n\r\n  // variable to keep track on paid out reward of the system\r\n  uint256 private _distributedRewardAmount = 0;\r\n\r\n  // variable for token time management\r\n  uint256 private _tokentime;\r\n  \r\n  // variable for token staking pause and unpause mechanism\r\n  bool public tokenPaused = false;\r\n  \r\n  // variable for total Token staked by user\r\n  uint256 public totalStakedToken = 0;\r\n  \r\n  // variable for total stake token in contract\r\n  uint256 public totalTokenStakesInContract = 0;\r\n\r\n  // variable for total stake tokens for package in contract\r\n  mapping (uint256 => uint256) public totalStakedInPackage;\r\n  \r\n  // modifier to check the user for staking || Re-enterance Guard\r\n  modifier tokenStakeCheck(uint256 tokens, uint256 timePeriod){\r\n    require(tokens > 0, \"Invalid Token Amount, Please Try Again!!! \");\r\n    bool validTime = false;\r\n    for (uint i = 0; i < categories.length; i++) {\r\n      if (timePeriod == categories[i].period) {\r\n        require(totalStakedInPackage[timePeriod].add(tokens) <= categories[i].limit, \"Selected Package was already filled. Try another package.\");\r\n        validTime = true;\r\n      }\r\n    }\r\n    require(validTime == true, \"Enter the Valid Time Period and Try Again !!!\");\r\n    _;\r\n  }\r\n    \r\n  /*\r\n  * ------------------------------------------------------------------------------------------------------------------------------\r\n  * Functions for Token Staking Functionality\r\n  * ------------------------------------------------------------------------------------------------------------------------------\r\n  */\r\n\r\n  // function to performs staking for user tokens for a specific period of time\r\n  function stakeToken(uint256 tokens, uint256 time) external tokenStakeCheck(tokens, time) returns(bool){\r\n    require(tokenPaused == false, \"Staking is Paused, Please try after staking get unpaused!!!\");\r\n    \r\n    _tokentime = block.timestamp + (time * 1 days);\r\n    _tokenStakingCount = _tokenStakingCount + 1;\r\n    _tokenTotalDays[_tokenStakingCount] = time;\r\n    _tokenStakingAddress[_tokenStakingCount] = msg.sender;\r\n    _tokenStakingId[msg.sender].push(_tokenStakingCount);\r\n    _tokenStakingEndTime[_tokenStakingCount] = _tokentime;\r\n    _tokenStakingStartTime[_tokenStakingCount] = block.timestamp;\r\n    _usersTokens[_tokenStakingCount] = tokens;\r\n    _TokenTransactionStatus[_tokenStakingCount] = false;\r\n    totalStakedToken = totalStakedToken.add(tokens);\r\n    totalTokenStakesInContract = totalTokenStakesInContract.add(tokens);\r\n    totalStakedInPackage[time] = totalStakedInPackage[time].add(tokens);\r\n    ixend.transferFrom(msg.sender, address(this), tokens);\r\n\r\n    emit Deposit(msg.sender, tokens, time, _tokenStakingCount, block.timestamp);\r\n\r\n    return true;\r\n  }\r\n\r\n  // function to get staking count for token\r\n  function getTokenStakingCount() external view returns(uint256){\r\n    return _tokenStakingCount;\r\n  }\r\n  \r\n  // function to get total Staked tokens\r\n  function getTotalStakedToken() external view returns(uint256){\r\n    return totalStakedToken;\r\n  }\r\n  \r\n  // function to calculate reward for the message sender for token\r\n  function getTokenRewardDetailsByStakingId(uint256 id) public view returns(uint256){\r\n    for (uint i = 0; i < categories.length; i++) {\r\n      if (_tokenTotalDays[id] == categories[i].period) {\r\n        return (_usersTokens[id] * categories[i].tokenRewardPercent/BASIS_POINT);\r\n      }\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  // function to calculate penalty for the message sender for token\r\n  function getTokenPenaltyDetailByStakingId(uint256 id) public view returns(uint256){\r\n    if(_tokenStakingEndTime[id] > block.timestamp){\r\n        for (uint i = 0; i < categories.length; i++) {\r\n          if (_tokenTotalDays[id] == categories[i].period) {\r\n            return (_usersTokens[id] * categories[i].tokenPenaltyPercent/BASIS_POINT);\r\n          }\r\n        }\r\n        return 0;\r\n    } else{\r\n       return 0;\r\n     }\r\n  }\r\n \r\n  // function for withdrawing staked tokens\r\n  function withdrawStakedTokens(uint256 stakingId) external returns(bool) {\r\n    require(_tokenStakingAddress[stakingId] == msg.sender,\"No staked token found on this address and ID\");\r\n    require(_TokenTransactionStatus[stakingId] != true,\"Either tokens are already withdrawn or blocked by admin\");\r\n    \r\n    for (uint i = 0; i < categories.length; i++) {\r\n      if (_tokenTotalDays[stakingId] == categories[i].period) {\r\n        require(block.timestamp >= _tokenStakingStartTime[stakingId] + categories[i].withdrawTime, \"Unable to Withdraw Staked token before withdraw time of staking start time, Please Try Again Later!!!\");\r\n        _TokenTransactionStatus[stakingId] = true;\r\n        \r\n        if(block.timestamp >= _tokenStakingEndTime[stakingId]) {\r\n          _finalTokenStakeWithdraw[stakingId] = _usersTokens[stakingId].add(getTokenRewardDetailsByStakingId(stakingId));\r\n          _distributedRewardAmount += getTokenRewardDetailsByStakingId(stakingId);\r\n        } else {\r\n          _finalTokenStakeWithdraw[stakingId] = _usersTokens[stakingId].add(getTokenPenaltyDetailByStakingId(stakingId));\r\n          _distributedRewardAmount += getTokenPenaltyDetailByStakingId(stakingId);\r\n        }\r\n        ixend.transferFrom(address(this), msg.sender,_finalTokenStakeWithdraw[stakingId]);\r\n        totalTokenStakesInContract = totalTokenStakesInContract.sub(_usersTokens[stakingId]);\r\n        totalStakedInPackage[categories[i].period] = totalStakedInPackage[categories[i].period].sub(_usersTokens[stakingId]);\r\n\r\n        emit Withdraw(msg.sender, stakingId, _usersTokens[stakingId], _finalTokenStakeWithdraw[stakingId].sub(_usersTokens[stakingId]), block.timestamp);\r\n\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n  \r\n  // function to get Final Withdraw Staked value for token\r\n  function getFinalTokenStakeWithdraw(uint256 id) external view returns(uint256){\r\n    return _finalTokenStakeWithdraw[id];\r\n  }\r\n  \r\n  // function to get total token stake in contract\r\n  function getTotalTokenStakesInContract() external view returns(uint256){\r\n      return totalTokenStakesInContract;\r\n  }\r\n  \r\n  /*\r\n  * -------------------------------------------------------------------------------------------------------------------------------\r\n  * Get Functions for Stake Token Functionality\r\n  * -------------------------------------------------------------------------------------------------------------------------------\r\n  */\r\n\r\n  // function to get Token Staking address by id\r\n  function getTokenStakingAddressById(uint256 id) external view returns (address){\r\n    require(id <= _tokenStakingCount,\"Unable to reterive data on specified id, Please try again!!\");\r\n    return _tokenStakingAddress[id];\r\n  }\r\n  \r\n  // function to get Token staking id by address\r\n  function getTokenStakingIdByAddress(address add) external view returns(uint256[] memory){\r\n    require(add != address(0),\"Invalid Address, Pleae Try Again!!!\");\r\n    return _tokenStakingId[add];\r\n  }\r\n  \r\n  // function to get Token Staking Starting time by id\r\n  function getTokenStakingStartTimeById(uint256 id) external view returns(uint256){\r\n    require(id <= _tokenStakingCount,\"Unable to reterive data on specified id, Please try again!!\");\r\n    return _tokenStakingStartTime[id];\r\n  }\r\n  \r\n  // function to get Token Staking Ending time by id\r\n  function getTokenStakingEndTimeById(uint256 id) external view returns(uint256){\r\n    require(id <= _tokenStakingCount,\"Unable to reterive data on specified id, Please try again!!\");\r\n    return _tokenStakingEndTime[id];\r\n  }\r\n  \r\n  // function to get Token Staking Total Days by Id\r\n  function getTokenStakingTotalDaysById(uint256 id) external view returns(uint256){\r\n    require(id <= _tokenStakingCount,\"Unable to reterive data on specified id, Please try again!!\");\r\n    return _tokenTotalDays[id];\r\n  }\r\n\r\n  // function to get Staking tokens by id\r\n  function getStakingTokenById(uint256 id) external view returns(uint256){\r\n    require(id <= _tokenStakingCount,\"Unable to reterive data on specified id, Please try again!!\");\r\n    return _usersTokens[id];\r\n  }\r\n\r\n  // function to get Token lockstatus by id\r\n  function getTokenLockStatus(uint256 id) external view returns(bool){\r\n    require(id <= _tokenStakingCount,\"Unable to reterive data on specified id, Please try again!!\");\r\n    return _TokenTransactionStatus[id];\r\n  }\r\n\r\n  // function to get staked amount, earned amount and reward amount of user based on address\r\n  function getUserInfoByAddress(address addr) external view returns (uint256 staked, uint256 earned, uint256 reward) {\r\n    require(addr != address(0), \"Invalid Address, Pleae Try Again!!!\");\r\n    uint256[] memory tokenStakingIds = _tokenStakingId[addr];\r\n\r\n    for (uint i = 0; i < tokenStakingIds.length; i++) {\r\n      uint256 stakingId = tokenStakingIds[i];\r\n      if (_finalTokenStakeWithdraw[stakingId] == 0) {\r\n        staked += _usersTokens[stakingId];\r\n        for (uint j = 0; j < categories.length; j++) {\r\n          if (_tokenTotalDays[stakingId] == categories[j].period) {\r\n            if(block.timestamp >= _tokenStakingEndTime[stakingId]) {\r\n              reward += getTokenRewardDetailsByStakingId(stakingId);\r\n            } else {\r\n              reward += getTokenPenaltyDetailByStakingId(stakingId);\r\n            }\r\n            break;\r\n          }\r\n        }\r\n      }\r\n      \r\n      earned += _finalTokenStakeWithdraw[tokenStakingIds[i]];\r\n    }\r\n  }\r\n\r\n  // function to get category list\r\n  function getCategories() external view returns (Package[] memory) {\r\n    return categories;\r\n  }\r\n\r\n  struct UserActivePackage {\r\n    string name;\r\n    uint256 period;\r\n    uint256 amount;\r\n  }\r\n\r\n  // Get the user's staked balance per package\r\n  function getActivePackagesByAddress(address addr) external view returns (UserActivePackage[] memory) {\r\n    require(addr != address(0), \"Invalid Address, Pleae Try Again!!!\");\r\n    uint256 length = categories.length;\r\n    UserActivePackage[] memory packages = new UserActivePackage[](length);\r\n    uint256[] memory tokenStakingIds = _tokenStakingId[addr];\r\n\r\n    for (uint i = 0; i < categories.length; i++) {\r\n      packages[i].name = categories[i].name;\r\n      packages[i].period = categories[i].period;\r\n      packages[i].amount = 0;\r\n      \r\n      for (uint j = 0; j < tokenStakingIds.length; j++) {\r\n        uint256 stakingId = tokenStakingIds[j];\r\n        if (_finalTokenStakeWithdraw[stakingId] == 0 && _tokenTotalDays[stakingId] == categories[i].period) {\r\n          packages[i].amount += _usersTokens[stakingId];\r\n        }\r\n      }\r\n    }\r\n\r\n    return packages;\r\n  }\r\n  \r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakingId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"packageId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenRewardPercent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenPenaltyPercent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"PackageAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"packageId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenRewardPercent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenPenaltyPercent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"PackageUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakingId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BASIS_POINT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_period\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenRewardPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenPenaltyPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"addPackage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"token\",\"type\":\"uint256\"}],\"name\":\"addTokenReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"categories\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenRewardPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenPenaltyPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getActivePackagesByAddress\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct XendStaking.UserActivePackage[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCategories\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenRewardPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenPenaltyPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"internalType\":\"struct XendStaking.Package[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDistributedRewardAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getFinalTokenStakeWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getStakingTokenById\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getTokenLockStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getTokenPenaltyDetailByStakingId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getTokenRewardDetailsByStakingId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getTokenStakingAddressById\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenStakingCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getTokenStakingEndTimeById\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"add\",\"type\":\"address\"}],\"name\":\"getTokenStakingIdByAddress\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getTokenStakingStartTimeById\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getTokenStakingTotalDaysById\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalStakedToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalTokenStakesInContract\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getUserInfoByAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"staked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"earned\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getowner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseTokenStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContractAddress\",\"type\":\"address\"}],\"name\":\"setContractAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"packageId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_period\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenRewardPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenPenaltyPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"setPackage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"stakeToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalStakedInPackage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStakedToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTokenStakesInContract\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpauseTokenStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"token\",\"type\":\"uint256\"}],\"name\":\"withdrawAddedTokenReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakingId\",\"type\":\"uint256\"}],\"name\":\"withdrawStakedTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "XendStaking", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://86a531bb2098bc0af9c9d3f627c988b9b02aa981880644df9a5481c956320d42"}