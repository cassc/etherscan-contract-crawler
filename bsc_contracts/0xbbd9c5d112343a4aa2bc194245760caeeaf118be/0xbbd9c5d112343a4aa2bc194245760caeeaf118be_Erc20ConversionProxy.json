{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/contracts/Erc20ConversionProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport './ChainlinkConversionPath.sol';\\nimport './interfaces/ERC20FeeProxy.sol';\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\n\\n/**\\n * @title Erc20ConversionProxy\\n * @notice This contract convert from chainlink then swaps ERC20 tokens\\n *         before paying a request thanks to a conversion payment proxy\\n */\\ncontract Erc20ConversionProxy is Ownable {\\n    address public paymentProxy;\\n    ChainlinkConversionPath public chainlinkConversionPath;\\n\\n    constructor(\\n        address _paymentProxyAddress,\\n        address _chainlinkConversionPathAddress,\\n        address _owner\\n    ) {\\n        paymentProxy = _paymentProxyAddress;\\n        chainlinkConversionPath = ChainlinkConversionPath(_chainlinkConversionPathAddress);\\n        transferOwnership(_owner);\\n    }\\n\\n    // Event to declare a conversion with a reference\\n    event TransferWithConversionAndReference(\\n        uint256 amount,\\n        address currency,\\n        bytes indexed paymentReference,\\n        uint256 feeAmount,\\n        uint256 maxRateTimespan\\n    );\\n\\n    // Event to declare a transfer with a reference\\n    event TransferWithReferenceAndFee(\\n        address tokenAddress,\\n        address to,\\n        uint256 amount,\\n        bytes indexed paymentReference,\\n        uint256 feeAmount,\\n        address feeAddress\\n    );\\n\\n    /**\\n     * @notice Transfers ERC20 tokens with a reference with amount based on the request amount in fiat\\n     * @param _to Transfer recipient of the payement\\n     * @param _requestAmount Request amount\\n     * @param _path Conversion path\\n     * @param _paymentReference Reference of the payment related\\n     * @param _feeAmount The amount of the payment fee\\n     * @param _feeAddress The fee recipient\\n     * @param _maxToSpend Amount max that we can spend on the behalf of the user\\n     * @param _maxRateTimespan Max time span with the oldestrate, ignored if zero\\n     */\\n    function transferFromWithReferenceAndFee(\\n        address _to,\\n        uint256 _requestAmount,\\n        address[] calldata _path,\\n        bytes calldata _paymentReference,\\n        uint256 _feeAmount,\\n        address _feeAddress,\\n        uint256 _maxToSpend,\\n        uint256 _maxRateTimespan\\n    ) external {\\n        (uint256 amountToPay, uint256 amountToPayInFees) = getConversions(\\n            _path,\\n            _requestAmount,\\n            _feeAmount,\\n            _maxRateTimespan\\n        );\\n\\n        require(\\n            amountToPay + amountToPayInFees <= _maxToSpend,\\n            'Amount to pay is over the user limit'\\n        );\\n\\n        // Pay the request and fees\\n        (bool status, ) = paymentProxy.delegatecall(\\n            abi.encodeWithSignature(\\n                'transferFromWithReferenceAndFee(address,address,uint256,bytes,uint256,address)',\\n                // payment currency\\n                _path[_path.length - 1],\\n                _to,\\n                amountToPay,\\n                _paymentReference,\\n                amountToPayInFees,\\n                _feeAddress\\n            )\\n        );\\n        require(status, 'transferFromWithReferenceAndFee failed');\\n\\n        // Event to declare a transfer with a reference\\n        emit TransferWithConversionAndReference(\\n            _requestAmount,\\n            // request currency\\n            _path[0],\\n            _paymentReference,\\n            _feeAmount,\\n            _maxRateTimespan\\n        );\\n    }\\n\\n    function getConversions(\\n        address[] memory _path,\\n        uint256 _requestAmount,\\n        uint256 _feeAmount,\\n        uint256 _maxRateTimespan\\n    ) internal view returns (uint256 amountToPay, uint256 amountToPayInFees) {\\n        (uint256 rate, uint256 oldestTimestampRate, uint256 decimals) = chainlinkConversionPath\\n            .getRate(_path);\\n\\n        // Check rate timespan\\n        require(\\n            _maxRateTimespan == 0 || block.timestamp - oldestTimestampRate <= _maxRateTimespan,\\n            'aggregator rate is outdated'\\n        );\\n\\n        // Get the amount to pay in the crypto currency chosen\\n        amountToPay = (_requestAmount * rate) / decimals;\\n        amountToPayInFees = (_feeAmount * rate) / decimals;\\n    }\\n\\n    /**\\n     * @notice Update the conversion path contract used to fetch conversions\\n     * @param _chainlinkConversionPathAddress address of the conversion path contract\\n     */\\n    function updateConversionPathAddress(address _chainlinkConversionPathAddress)\\n        external\\n        onlyOwner\\n    {\\n        chainlinkConversionPath = ChainlinkConversionPath(_chainlinkConversionPathAddress);\\n    }\\n\\n    /**\\n     * @notice Update the conversion proxy used to process the payment\\n     * @param _paymentProxyAddress address of the ETH conversion proxy\\n     */\\n    function updateConversionProxyAddress(address _paymentProxyAddress) external onlyOwner {\\n        paymentProxy = _paymentProxyAddress;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/contracts/ChainlinkConversionPath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport './legacy_openzeppelin/contracts/access/roles/WhitelistAdminRole.sol';\\n\\ninterface ERC20fraction {\\n    function decimals() external view returns (uint8);\\n}\\n\\ninterface AggregatorFraction {\\n    function decimals() external view returns (uint8);\\n\\n    function latestAnswer() external view returns (int256);\\n\\n    function latestTimestamp() external view returns (uint256);\\n}\\n\\n/**\\n * @title ChainlinkConversionPath\\n *\\n * @notice ChainlinkConversionPath is a contract computing currency conversion rates based on Chainlink aggretators\\n */\\ncontract ChainlinkConversionPath is WhitelistAdminRole {\\n    uint256 constant PRECISION = 1e18;\\n    uint256 constant NATIVE_TOKEN_DECIMALS = 18;\\n    uint256 constant FIAT_DECIMALS = 8;\\n    address public nativeTokenHash;\\n\\n    /**\\n     * @param _nativeTokenHash hash of the native token\\n     */\\n    constructor(address _nativeTokenHash) {\\n        nativeTokenHash = _nativeTokenHash;\\n    }\\n\\n    // Mapping of Chainlink aggregators (input currency => output currency => contract address)\\n    // input & output currencies are the addresses of the ERC20 contracts OR the sha3(\\\"currency code\\\")\\n    mapping(address => mapping(address => address)) public allAggregators;\\n\\n    // declare a new aggregator\\n    event AggregatorUpdated(address _input, address _output, address _aggregator);\\n\\n    /**\\n     * @notice Update an aggregator\\n     * @param _input address representing the input currency\\n     * @param _output address representing the output currency\\n     * @param _aggregator address of the aggregator contract\\n     */\\n    function updateAggregator(\\n        address _input,\\n        address _output,\\n        address _aggregator\\n    ) external onlyWhitelistAdmin {\\n        allAggregators[_input][_output] = _aggregator;\\n        emit AggregatorUpdated(_input, _output, _aggregator);\\n    }\\n\\n    /**\\n     * @notice Update a list of aggregators\\n     * @param _inputs list of addresses representing the input currencies\\n     * @param _outputs list of addresses representing the output currencies\\n     * @param _aggregators list of addresses of the aggregator contracts\\n     */\\n    function updateAggregatorsList(\\n        address[] calldata _inputs,\\n        address[] calldata _outputs,\\n        address[] calldata _aggregators\\n    ) external onlyWhitelistAdmin {\\n        require(_inputs.length == _outputs.length, 'arrays must have the same length');\\n        require(_inputs.length == _aggregators.length, 'arrays must have the same length');\\n\\n        // For every conversions of the path\\n        for (uint256 i; i < _inputs.length; i++) {\\n            allAggregators[_inputs[i]][_outputs[i]] = _aggregators[i];\\n            emit AggregatorUpdated(_inputs[i], _outputs[i], _aggregators[i]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Computes the conversion of an amount through a list of intermediate conversions\\n     * @param _amountIn Amount to convert\\n     * @param _path List of addresses representing the currencies for the intermediate conversions\\n     * @return result The result after all the conversions\\n     * @return oldestRateTimestamp The oldest timestamp of the path\\n     */\\n    function getConversion(uint256 _amountIn, address[] calldata _path)\\n        external\\n        view\\n        returns (uint256 result, uint256 oldestRateTimestamp)\\n    {\\n        (uint256 rate, uint256 timestamp, uint256 decimals) = getRate(_path);\\n\\n        // initialize the result\\n        result = (_amountIn * rate) / decimals;\\n\\n        oldestRateTimestamp = timestamp;\\n    }\\n\\n    /**\\n     * @notice Computes the conversion rate from a list of currencies\\n     * @param _path List of addresses representing the currencies for the conversions\\n     * @return rate The rate\\n     * @return oldestRateTimestamp The oldest timestamp of the path\\n     * @return decimals of the conversion rate\\n     */\\n    function getRate(address[] memory _path)\\n        public\\n        view\\n        returns (\\n            uint256 rate,\\n            uint256 oldestRateTimestamp,\\n            uint256 decimals\\n        )\\n    {\\n        // initialize the result with 18 decimals (for more precision)\\n        rate = PRECISION;\\n        decimals = PRECISION;\\n        oldestRateTimestamp = block.timestamp;\\n\\n        // For every conversion of the path\\n        for (uint256 i; i < _path.length - 1; i++) {\\n            (\\n                AggregatorFraction aggregator,\\n                bool reverseAggregator,\\n                uint256 decimalsInput,\\n                uint256 decimalsOutput\\n            ) = getAggregatorAndDecimals(_path[i], _path[i + 1]);\\n\\n            // store the latest timestamp of the path\\n            uint256 currentTimestamp = aggregator.latestTimestamp();\\n            if (currentTimestamp < oldestRateTimestamp) {\\n                oldestRateTimestamp = currentTimestamp;\\n            }\\n\\n            // get the rate of the current step\\n            uint256 currentRate = uint256(aggregator.latestAnswer());\\n            // get the number of decimals of the current rate\\n            uint256 decimalsAggregator = uint256(aggregator.decimals());\\n\\n            // mul with the difference of decimals before the current rate computation (for more precision)\\n            if (decimalsAggregator > decimalsInput) {\\n                rate = rate * (10**(decimalsAggregator - decimalsInput));\\n            }\\n            if (decimalsAggregator < decimalsOutput) {\\n                rate = rate * (10**(decimalsOutput - decimalsAggregator));\\n            }\\n\\n            // Apply the current rate (if path uses an aggregator in the reverse way, div instead of mul)\\n            if (reverseAggregator) {\\n                rate = (rate * (10**decimalsAggregator)) / currentRate;\\n            } else {\\n                rate = (rate * currentRate) / (10**decimalsAggregator);\\n            }\\n\\n            // div with the difference of decimals AFTER the current rate computation (for more precision)\\n            if (decimalsAggregator < decimalsInput) {\\n                rate = rate / (10**(decimalsInput - decimalsAggregator));\\n            }\\n            if (decimalsAggregator > decimalsOutput) {\\n                rate = rate / (10**(decimalsAggregator - decimalsOutput));\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Gets aggregators and decimals of two currencies\\n     * @param _input input Address\\n     * @param _output output Address\\n     * @return aggregator to get the rate between the two currencies\\n     * @return reverseAggregator true if the aggregator returned give the rate from _output to _input\\n     * @return decimalsInput decimals of _input\\n     * @return decimalsOutput decimals of _output\\n     */\\n    function getAggregatorAndDecimals(address _input, address _output)\\n        private\\n        view\\n        returns (\\n            AggregatorFraction aggregator,\\n            bool reverseAggregator,\\n            uint256 decimalsInput,\\n            uint256 decimalsOutput\\n        )\\n    {\\n        // Try to get the right aggregator for the conversion\\n        aggregator = AggregatorFraction(allAggregators[_input][_output]);\\n        reverseAggregator = false;\\n\\n        // if no aggregator found we try to find an aggregator in the reverse way\\n        if (address(aggregator) == address(0x00)) {\\n            aggregator = AggregatorFraction(allAggregators[_output][_input]);\\n            reverseAggregator = true;\\n        }\\n\\n        require(address(aggregator) != address(0x00), 'No aggregator found');\\n\\n        // get the decimals for the two currencies\\n        decimalsInput = getDecimals(_input);\\n        decimalsOutput = getDecimals(_output);\\n    }\\n\\n    /**\\n     * @notice Gets decimals from an address currency\\n     * @param _addr address to check\\n     * @return decimals number of decimals\\n     */\\n    function getDecimals(address _addr) private view returns (uint256 decimals) {\\n        // by default we assume it is fiat\\n        decimals = FIAT_DECIMALS;\\n        // if address is the hash of the ETH currency\\n        if (_addr == nativeTokenHash) {\\n            decimals = NATIVE_TOKEN_DECIMALS;\\n        } else if (isContract(_addr)) {\\n            // otherwise, we get the decimals from the erc20 directly\\n            decimals = ERC20fraction(_addr).decimals();\\n        }\\n    }\\n\\n    /**\\n     * @notice Checks if an address is a contract\\n     * @param _addr Address to check\\n     * @return true if the address hosts a contract, false otherwise\\n     */\\n    function isContract(address _addr) private view returns (bool) {\\n        uint32 size;\\n        // solium-disable security/no-inline-assembly\\n        assembly {\\n            size := extcodesize(_addr)\\n        }\\n        return (size > 0);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/contracts/interfaces/ERC20FeeProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IERC20FeeProxy {\\n  event TransferWithReferenceAndFee(\\n    address tokenAddress,\\n    address to,\\n    uint256 amount,\\n    bytes indexed paymentReference,\\n    uint256 feeAmount,\\n    address feeAddress\\n  );\\n\\n  function transferFromWithReferenceAndFee(\\n    address _tokenAddress,\\n    address _to,\\n    uint256 _amount,\\n    bytes calldata _paymentReference,\\n    uint256 _feeAmount,\\n    address _feeAddress\\n    ) external;\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/contracts/legacy_openzeppelin/contracts/access/roles/WhitelistAdminRole.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/utils/Context.sol';\\nimport \\\"../Roles.sol\\\";\\n\\n/**\\n * @title WhitelistAdminRole\\n * @dev WhitelistAdmins are responsible for assigning and removing Whitelisted accounts.\\n */\\nabstract contract WhitelistAdminRole is Context {\\n    using Roles for Roles.Role;\\n\\n    event WhitelistAdminAdded(address indexed account);\\n    event WhitelistAdminRemoved(address indexed account);\\n\\n    Roles.Role private _whitelistAdmins;\\n\\n    constructor () {\\n        _addWhitelistAdmin(_msgSender());\\n    }\\n\\n    modifier onlyWhitelistAdmin() {\\n        require(isWhitelistAdmin(_msgSender()), \\\"WhitelistAdminRole: caller does not have the WhitelistAdmin role\\\");\\n        _;\\n    }\\n\\n    function isWhitelistAdmin(address account) public view returns (bool) {\\n        return _whitelistAdmins.has(account);\\n    }\\n\\n    function addWhitelistAdmin(address account) public onlyWhitelistAdmin {\\n        _addWhitelistAdmin(account);\\n    }\\n\\n    function renounceWhitelistAdmin() public {\\n        _removeWhitelistAdmin(_msgSender());\\n    }\\n\\n    function _addWhitelistAdmin(address account) internal {\\n        _whitelistAdmins.add(account);\\n        emit WhitelistAdminAdded(account);\\n    }\\n\\n    function _removeWhitelistAdmin(address account) internal {\\n        _whitelistAdmins.remove(account);\\n        emit WhitelistAdminRemoved(account);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/contracts/legacy_openzeppelin/contracts/access/Roles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Roles\\n * @dev Library for managing addresses assigned to a Role.\\n */\\nlibrary Roles {\\n    struct Role {\\n        mapping (address => bool) bearer;\\n    }\\n\\n    /**\\n     * @dev Give an account access to this role.\\n     */\\n    function add(Role storage role, address account) internal {\\n        require(!has(role, account), \\\"Roles: account already has role\\\");\\n        role.bearer[account] = true;\\n    }\\n\\n    /**\\n     * @dev Remove an account's access to this role.\\n     */\\n    function remove(Role storage role, address account) internal {\\n        require(has(role, account), \\\"Roles: account does not have role\\\");\\n        role.bearer[account] = false;\\n    }\\n\\n    /**\\n     * @dev Check if an account has this role.\\n     * @return bool\\n     */\\n    function has(Role storage role, address account) internal view returns (bool) {\\n        require(account != address(0), \\\"Roles: account is the zero address\\\");\\n        return role.bearer[account];\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_paymentProxyAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_chainlinkConversionPathAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currency\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes\",\"name\":\"paymentReference\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxRateTimespan\",\"type\":\"uint256\"}],\"name\":\"TransferWithConversionAndReference\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes\",\"name\":\"paymentReference\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeAddress\",\"type\":\"address\"}],\"name\":\"TransferWithReferenceAndFee\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"chainlinkConversionPath\",\"outputs\":[{\"internalType\":\"contract ChainlinkConversionPath\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paymentProxy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_requestAmount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_path\",\"type\":\"address[]\"},{\"internalType\":\"bytes\",\"name\":\"_paymentReference\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_feeAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_feeAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxToSpend\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxRateTimespan\",\"type\":\"uint256\"}],\"name\":\"transferFromWithReferenceAndFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_chainlinkConversionPathAddress\",\"type\":\"address\"}],\"name\":\"updateConversionPathAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_paymentProxyAddress\",\"type\":\"address\"}],\"name\":\"updateConversionProxyAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Erc20ConversionProxy", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004e64c2d06d19d13061e62e291b2c4e9fe5679b93", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}