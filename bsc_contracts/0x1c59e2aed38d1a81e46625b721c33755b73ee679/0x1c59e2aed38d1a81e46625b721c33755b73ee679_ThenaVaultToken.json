{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\ncontract Context {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n    constructor () internal { }\\n    // solhint-disable-previous-line no-empty-blocks\\n\\n    function _msgSender() internal view returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/ownership/Ownable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.0;\\n\\nimport \\\"../GSN/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(isOwner(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the caller is the current owner.\\n     */\\n    function isOwner() public view returns (bool) {\\n        return _msgSender() == _owner;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     */\\n    function _transferOwnership(address newOwner) internal {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBaseV1Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IBaseV1Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function stable() external view returns (bool);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\t\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function tokens() external view returns (address, address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n\\n    function observationLength() external view returns (uint);\\n    function observations(uint) external view returns (\\n        uint timestamp,\\n        uint reserve0Cumulative,\\n        uint reserve1Cumulative\\n    );\\n    function currentCumulativePrices() external view returns (\\n        uint reserve0Cumulative,\\n        uint reserve1Cumulative,\\n        uint timestamp\\n    );\\n\\n    function metadata() external view returns (uint, uint, uint, uint, bool, address, address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IERC20 {\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOptiSwap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0;\\n\\ninterface IOptiSwap {\\n    function weth() external view returns (address);\\n\\n    function bridgeFromTokens(uint256 index) external view returns (address token);\\n\\n    function bridgeFromTokensLength() external view returns (uint256);\\n\\n    function getBridgeToken(address _token) external view returns (address bridgeToken);\\n\\n    function addBridgeToken(address _token, address _bridgeToken) external;\\n\\n    function getDexInfo(uint256 index) external view returns (address dex, address handler);\\n\\n    function dexListLength() external view returns (uint256);\\n\\n    function indexOfDex(address _dex) external view returns (uint256);\\n\\n    function getDexEnabled(address _dex) external view returns (bool);\\n\\n    function addDex(address _dex, address _handler) external;\\n\\n    function removeDex(address _dex) external;\\n\\n    function getBestAmountOut(\\n        uint256 _amountIn,\\n        address _tokenIn,\\n        address _tokenOut\\n    ) external view returns (address pair, uint256 amountOut);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPoolToken.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IPoolToken {\\n    /*** Tarot ERC20 ***/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    function name() external pure returns (string memory);\\n\\n    function symbol() external pure returns (string memory);\\n\\n    function decimals() external pure returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /*** Pool Token ***/\\n\\n    event Mint(\\n        address indexed sender,\\n        address indexed minter,\\n        uint256 mintAmount,\\n        uint256 mintTokens\\n    );\\n    event Redeem(\\n        address indexed sender,\\n        address indexed redeemer,\\n        uint256 redeemAmount,\\n        uint256 redeemTokens\\n    );\\n    event Sync(uint256 totalBalance);\\n\\n    function underlying() external view returns (address);\\n\\n    function factory() external view returns (address);\\n\\n    function totalBalance() external view returns (uint256);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n    function exchangeRate() external view returns (uint256);\\n\\n    function mint(address minter) external returns (uint256 mintTokens);\\n\\n    function redeem(address redeemer) external returns (uint256 redeemAmount);\\n\\n    function skim(address to) external;\\n\\n    function sync() external;\\n\\n    function _setFactory() external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IThenaGauge.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IThenaGauge {\\n    function notifyRewardAmount(address token, uint amount) external;\\n    function getReward() external;\\n    function claimFees() external returns (uint claimed0, uint claimed1);\\n    function isForPair() external view returns (bool);\\n    function earned(address account) external view returns (uint);\\n    function balanceOf(address account) external view returns (uint);\\n    function deposit(uint256 amount) external;\\n    function withdraw(uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IThenaVaultToken.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IThenaVaultToken {\\n    /*** Tarot ERC20 ***/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    function name() external pure returns (string memory);\\n\\n    function symbol() external pure returns (string memory);\\n\\n    function decimals() external pure returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /*** Pool Token ***/\\n\\n    event Mint(address indexed sender, address indexed minter, uint256 mintAmount, uint256 mintTokens);\\n    event Redeem(address indexed sender, address indexed redeemer, uint256 redeemAmount, uint256 redeemTokens);\\n    event Sync(uint256 totalBalance);\\n\\n    function underlying() external view returns (address);\\n\\n    function factory() external view returns (address);\\n\\n    function totalBalance() external view returns (uint256);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n    function exchangeRate() external view returns (uint256);\\n\\n    function mint(address minter) external returns (uint256 mintTokens);\\n\\n    function redeem(address redeemer) external returns (uint256 redeemAmount);\\n\\n    function skim(address to) external;\\n\\n    function sync() external;\\n\\n    function _setFactory() external;\\n\\n    /*** VaultToken ***/\\n\\n    event Reinvest(address indexed caller, uint256 reward, uint256 bounty, uint256 fee);\\n\\n    function isVaultToken() external pure returns (bool);\\n\\n    function stable() external pure returns (bool);\\n\\n    function optiSwap() external view returns (address);\\n\\n    function router() external view returns (address);\\n\\n    function voter() external view returns (address);\\n\\n    function pairFactory() external view returns (address);\\n\\n    function rewardsToken() external view returns (address);\\n\\n    function WETH() external view returns (address);\\n\\n    function reinvestFeeTo() external view returns (address);\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    function REINVEST_BOUNTY() external view returns (uint256);\\n\\n    function REINVEST_FEE() external view returns (uint256);\\n\\n    function reinvestorListLength() external view returns (uint256);\\n\\n    function reinvestorListItem(uint256 index) external view returns (address);\\n\\n    function isReinvestorEnabled(address reinvestor) external view returns (bool);\\n\\n    function addReinvestor(address reinvestor) external;\\n\\n    function removeReinvestor(address reinvestor) external;\\n\\n    function updateReinvestBounty(uint256 _newReinvestBounty) external;\\n\\n    function updateReinvestFee(uint256 _newReinvestFee) external;\\n\\n    function updateReinvestFeeTo(address _newReinvestFeeTo) external;\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 reserve0,\\n            uint112 reserve1,\\n            uint32 blockTimestampLast\\n        );\\n\\n    function observationLength() external view returns (uint);\\n\\n    function observations(uint index)\\n        external\\n        view\\n        returns (\\n            uint timestamp,\\n            uint reserve0Cumulative,\\n            uint reserve1Cumulative\\n        );\\n\\n    function currentCumulativePrices()\\n        external\\n        view\\n        returns (\\n            uint reserve0Cumulative,\\n            uint reserve1Cumulative,\\n            uint timestamp\\n        );\\n\\n    function _initialize(\\n        address _underlying,\\n        address _optiSwap,\\n        address _router,\\n        address _voter,\\n        address _pairFactory,\\n        address _rewardsToken,\\n        address _reinvestFeeTo\\n    ) external;\\n\\n    function reinvest() external;\\n\\n    function getReward() external returns (uint256);\\n\\n    function getBlockTimestamp() external view returns (uint32);\\n\\n    function adminClaimRewards() external;\\n\\n    function adminRescueTokens(address _to, address[] calldata _tokens) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 reserve0,\\n            uint112 reserve1,\\n            uint32 blockTimestampLast\\n        );\\n\\n    function price0CumulativeLast() external view returns (uint256);\\n\\n    function price1CumulativeLast() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVeloPairFactory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IVeloPairFactory {\\n    function allPairsLength() external view returns (uint);\\n    function isPair(address pair) external view returns (bool);\\n    function pairCodeHash() external pure returns (bytes32);\\n    function getPair(address tokenA, address token, bool stable) external view returns (address);\\n    function createPair(address tokenA, address tokenB, bool stable) external returns (address pair);\\n    function getFee(bool _stable) external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVeloRouter.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IVeloRouter {\\n  function weth() external pure returns (address);\\n\\n  function addLiquidity(\\n    address tokenA,\\n    address tokenB,\\n    bool stable,\\n    uint256 amountADesired,\\n    uint256 amountBDesired,\\n    uint256 amountAMin,\\n    uint256 amountBMin,\\n    address to,\\n    uint256 deadline\\n  ) external returns (uint amountA, uint amountB, uint liquidity);\\n\\n  function swapExactTokensForTokensSimple(\\n    uint256 amountIn,\\n    uint256 amountOutMin,\\n    address tokenFrom,\\n    address tokenTo,\\n    bool stable,\\n    address to,\\n    uint256 deadline\\n  ) external returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVeloVoter.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IVeloVoter {\\n    function _ve() external view returns (address);\\n    function governor() external view returns (address);\\n    function emergencyCouncil() external view returns (address);\\n    function attachTokenToGauge(uint _tokenId, address account) external;\\n    function detachTokenFromGauge(uint _tokenId, address account) external;\\n    function emitDeposit(uint _tokenId, address account, uint amount) external;\\n    function emitWithdraw(uint _tokenId, address account, uint amount) external;\\n    function isWhitelisted(address token) external view returns (bool);\\n    function notifyRewardAmount(uint amount) external;\\n    function distribute(address _gauge) external;\\n    function gauges(address token) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Math.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\n// a library for performing various math operations\\n// forked from: https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/libraries/Math.sol\\n\\nlibrary Math {\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x < y ? x : y;\\n    }\\n\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\\n        if (y > 3) {\\n            z = y;\\n            uint256 x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\\n// Subject to the MIT license.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, errorMessage);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot underflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction underflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot underflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, errorMessage);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers.\\n     * Reverts on division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers.\\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeToken.sol\": {\r\n      \"content\": \"pragma solidity 0.5.16;\\n\\ninterface ERC20Interface {\\n    function balanceOf(address user) external view returns (uint256);\\n}\\n\\nlibrary SafeToken {\\n    function myBalance(address token) internal view returns (uint256) {\\n        return ERC20Interface(token).balanceOf(address(this));\\n    }\\n\\n    function balanceOf(address token, address user)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return ERC20Interface(token).balanceOf(user);\\n    }\\n\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(0x095ea7b3, to, value)\\n        );\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"!safeApprove\\\"\\n        );\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(0xa9059cbb, to, value)\\n        );\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"!safeTransfer\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\\n        );\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"!safeTransferFrom\\\"\\n        );\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call.value(value)(new bytes(0));\\n        require(success, \\\"!safeTransferETH\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/PoolToken.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\nimport \\\"./TarotERC20.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IPoolToken.sol\\\";\\nimport \\\"./libraries/SafeMath.sol\\\";\\n\\ncontract PoolToken is IPoolToken, TarotERC20 {\\n    uint256 internal constant initialExchangeRate = 1e18;\\n    address public underlying;\\n    address public factory;\\n    uint256 public totalBalance;\\n    uint256 public constant MINIMUM_LIQUIDITY = 1000;\\n\\n    event Mint(\\n        address indexed sender,\\n        address indexed minter,\\n        uint256 mintAmount,\\n        uint256 mintTokens\\n    );\\n    event Redeem(\\n        address indexed sender,\\n        address indexed redeemer,\\n        uint256 redeemAmount,\\n        uint256 redeemTokens\\n    );\\n    event Sync(uint256 totalBalance);\\n\\n    /*** Initialize ***/\\n\\n    // called once by the factory\\n    function _setFactory() external {\\n        require(factory == address(0), \\\"Tarot: FACTORY_ALREADY_SET\\\");\\n        factory = msg.sender;\\n    }\\n\\n    /*** PoolToken ***/\\n\\n    function _update() internal {\\n        totalBalance = IERC20(underlying).balanceOf(address(this));\\n        emit Sync(totalBalance);\\n    }\\n\\n    function exchangeRate() public view returns (uint256) {\\n        uint256 _totalSupply = totalSupply; // gas savings\\n        uint256 _totalBalance = totalBalance; // gas savings\\n        if (_totalSupply == 0 || _totalBalance == 0) return initialExchangeRate;\\n        return _totalBalance.mul(1e18).div(_totalSupply);\\n    }\\n\\n    // this low-level function should be called from another contract\\n    function mint(address minter)\\n        external\\n        nonReentrant\\n        update\\n        returns (uint256 mintTokens)\\n    {\\n        uint256 balance = IERC20(underlying).balanceOf(address(this));\\n        uint256 mintAmount = balance.sub(totalBalance);\\n        mintTokens = mintAmount.mul(1e18).div(exchangeRate());\\n\\n        if (totalSupply == 0) {\\n            // permanently lock the first MINIMUM_LIQUIDITY tokens\\n            mintTokens = mintTokens.sub(MINIMUM_LIQUIDITY);\\n            _mint(address(0), MINIMUM_LIQUIDITY);\\n        }\\n        require(mintTokens > 0, \\\"Tarot: MINT_AMOUNT_ZERO\\\");\\n        _mint(minter, mintTokens);\\n        emit Mint(msg.sender, minter, mintAmount, mintTokens);\\n    }\\n\\n    // this low-level function should be called from another contract\\n    function redeem(address redeemer)\\n        external\\n        nonReentrant\\n        update\\n        returns (uint256 redeemAmount)\\n    {\\n        uint256 redeemTokens = balanceOf[address(this)];\\n        redeemAmount = redeemTokens.mul(exchangeRate()).div(1e18);\\n\\n        require(redeemAmount > 0, \\\"Tarot: REDEEM_AMOUNT_ZERO\\\");\\n        require(redeemAmount <= totalBalance, \\\"Tarot: INSUFFICIENT_CASH\\\");\\n        _burn(address(this), redeemTokens);\\n        _safeTransfer(redeemer, redeemAmount);\\n        emit Redeem(msg.sender, redeemer, redeemAmount, redeemTokens);\\n    }\\n\\n    // force real balance to match totalBalance\\n    function skim(address to) external nonReentrant {\\n        _safeTransfer(\\n            to,\\n            IERC20(underlying).balanceOf(address(this)).sub(totalBalance)\\n        );\\n    }\\n\\n    // force totalBalance to match real balance\\n    function sync() external nonReentrant update {}\\n\\n    /*** Utilities ***/\\n\\n    // same safe transfer function used by UniSwapV2 (with fixed underlying)\\n    bytes4 private constant SELECTOR =\\n        bytes4(keccak256(bytes(\\\"transfer(address,uint256)\\\")));\\n\\n    function _safeTransfer(address to, uint256 amount) internal {\\n        (bool success, bytes memory data) = underlying.call(\\n            abi.encodeWithSelector(SELECTOR, to, amount)\\n        );\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"Tarot: TRANSFER_FAILED\\\"\\n        );\\n    }\\n\\n    // prevents a contract from calling itself, directly or indirectly.\\n    bool internal _notEntered = true;\\n    modifier nonReentrant() {\\n        require(_notEntered, \\\"Tarot: REENTERED\\\");\\n        _notEntered = false;\\n        _;\\n        _notEntered = true;\\n    }\\n\\n    // update totalBalance with current balance\\n    modifier update() {\\n        _;\\n        _update();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/TarotERC20.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\nimport \\\"./libraries/SafeMath.sol\\\";\\n\\n// This contract is basically UniswapV2ERC20 with small modifications\\n// src: https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol\\n\\ncontract TarotERC20 {\\n    using SafeMath for uint256;\\n\\n    string public name;\\n    string public symbol;\\n    uint8 public decimals = 18;\\n    uint256 public totalSupply;\\n    mapping(address => uint256) public balanceOf;\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    bytes32 public DOMAIN_SEPARATOR;\\n    mapping(address => uint256) public nonces;\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    constructor() public {}\\n\\n    function _setName(string memory _name, string memory _symbol) internal {\\n        name = _name;\\n        symbol = _symbol;\\n        uint256 chainId;\\n        assembly {\\n            chainId := chainid\\n        }\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256(\\n                    \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n                ),\\n                keccak256(bytes(_name)),\\n                keccak256(bytes(\\\"1\\\")),\\n                chainId,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    function _mint(address to, uint256 value) internal {\\n        totalSupply = totalSupply.add(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(address(0), to, value);\\n    }\\n\\n    function _burn(address from, uint256 value) internal {\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        totalSupply = totalSupply.sub(value);\\n        emit Transfer(from, address(0), value);\\n    }\\n\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 value\\n    ) private {\\n        allowance[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        balanceOf[from] = balanceOf[from].sub(\\n            value,\\n            \\\"Tarot: TRANSFER_TOO_HIGH\\\"\\n        );\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(from, to, value);\\n    }\\n\\n    function approve(address spender, uint256 value) external returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 value) external returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool) {\\n        if (allowance[from][msg.sender] != uint256(-1)) {\\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(\\n                value,\\n                \\\"Tarot: TRANSFER_NOT_ALLOWED\\\"\\n            );\\n        }\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    function _checkSignature(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s,\\n        bytes32 typehash\\n    ) internal {\\n        require(deadline >= block.timestamp, \\\"Tarot: EXPIRED\\\");\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR,\\n                keccak256(\\n                    abi.encode(\\n                        typehash,\\n                        owner,\\n                        spender,\\n                        value,\\n                        nonces[owner]++,\\n                        deadline\\n                    )\\n                )\\n            )\\n        );\\n        address recoveredAddress = ecrecover(digest, v, r, s);\\n        require(\\n            recoveredAddress != address(0) && recoveredAddress == owner,\\n            \\\"Tarot: INVALID_SIGNATURE\\\"\\n        );\\n    }\\n\\n    // keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 public constant PERMIT_TYPEHASH =\\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external {\\n        _checkSignature(\\n            owner,\\n            spender,\\n            value,\\n            deadline,\\n            v,\\n            r,\\n            s,\\n            PERMIT_TYPEHASH\\n        );\\n        _approve(owner, spender, value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ThenaVaultToken.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\nimport \\\"@openzeppelin/contracts/ownership/Ownable.sol\\\";\\nimport \\\"./PoolToken.sol\\\";\\nimport \\\"./interfaces/IOptiSwap.sol\\\";\\nimport \\\"./interfaces/IVeloVoter.sol\\\";\\nimport \\\"./interfaces/IVeloPairFactory.sol\\\";\\nimport \\\"./interfaces/IThenaGauge.sol\\\";\\nimport \\\"./interfaces/IVeloRouter.sol\\\";\\nimport \\\"./interfaces/IBaseV1Pair.sol\\\";\\nimport \\\"./interfaces/IThenaVaultToken.sol\\\";\\nimport \\\"./interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./libraries/SafeToken.sol\\\";\\nimport \\\"./libraries/Math.sol\\\";\\n\\ninterface OptiSwapPair {\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n}\\n\\ncontract ThenaVaultToken is IThenaVaultToken, PoolToken {\\n    using SafeToken for address;\\n\\n    bool public constant isVaultToken = true;\\n    bool public constant stable = false;\\n\\n    address public optiSwap;\\n    address public router;\\n    address public voter;\\n    address public gauge;\\n    address public pairFactory;\\n    address public rewardsToken;\\n    address public WETH;\\n    address public reinvestFeeTo;\\n    address public token0;\\n    address public token1;\\n\\n    uint256 public constant MIN_REINVEST_BOUNTY = 0;\\n    uint256 public constant MAX_REINVEST_BOUNTY = 0.05e18;\\n    uint256 public REINVEST_BOUNTY = 0.02e18;\\n    uint256 public constant MIN_REINVEST_FEE = 0;\\n    uint256 public constant MAX_REINVEST_FEE = 0.05e18;\\n    uint256 public REINVEST_FEE = 0.02e18;\\n\\n    address[] reinvestorList;\\n    mapping(address => bool) reinvestorEnabled;\\n\\n    event Reinvest(address indexed caller, uint256 reward, uint256 bounty, uint256 fee);\\n    event UpdateReinvestBounty(uint256 _newReinvestBounty);\\n    event UpdateReinvestFee(uint256 _newReinvestFee);\\n    event UpdateReinvestFeeTo(address _newReinvestFeeTo);\\n\\n    function _initialize(\\n        address _underlying,\\n        address _optiSwap,\\n        address _router,\\n        address _voter,\\n        address _pairFactory,\\n        address _rewardsToken,\\n        address _reinvestFeeTo\\n    ) external {\\n        require(factory == address(0), \\\"VaultToken: FACTORY_ALREADY_SET\\\"); // sufficient check\\n        factory = msg.sender;\\n        _setName(\\\"Tarot Vault Token\\\", \\\"vTAROT\\\");\\n        underlying = _underlying;\\n        optiSwap = _optiSwap;\\n        voter = _voter;\\n        gauge = IVeloVoter(voter).gauges(underlying);\\n        require(gauge != address(0), \\\"VaultToken: NO_GAUGE\\\");\\n        router = _router;\\n        pairFactory = _pairFactory;\\n        WETH = IVeloRouter(_router).weth();\\n        (token0, token1) = IBaseV1Pair(_underlying).tokens();\\n        rewardsToken = _rewardsToken;\\n        reinvestFeeTo = _reinvestFeeTo;\\n        rewardsToken.safeApprove(address(router), uint256(-1));\\n        WETH.safeApprove(address(router), uint256(-1));\\n        underlying.safeApprove(address(gauge), uint256(-1));\\n    }\\n\\n    function reinvestorListLength() external view returns (uint256) {\\n        return reinvestorList.length;\\n    }\\n\\n    function reinvestorListItem(uint256 index) external view returns (address) {\\n        return reinvestorList[index];\\n    }\\n\\n    function isReinvestorEnabled(address reinvestor) external view returns (bool) {\\n        return reinvestorEnabled[reinvestor];\\n    }\\n\\n    function _addReinvestor(address reinvestor) private {\\n        require(!reinvestorEnabled[reinvestor], \\\"VaultToken: REINVESTOR_ENABLED\\\");\\n\\n        reinvestorEnabled[reinvestor] = true;\\n        reinvestorList.push(reinvestor);\\n    }\\n\\n    function addReinvestor(address reinvestor) external onlyFactoryOwner {\\n        _addReinvestor(reinvestor);\\n    }\\n\\n    function _indexOfReinvestor(address reinvestor) private view returns (uint256 index) {\\n        uint256 count = reinvestorList.length;\\n        for (uint256 i = 0; i < count; i++) {\\n            if (reinvestorList[i] == reinvestor) {\\n                return i;\\n            }\\n        }\\n        require(false, \\\"VaultToken: REINVESTOR_NOT_FOUND\\\");\\n    }\\n\\n    function removeReinvestor(address reinvestor) external onlyFactoryOwner {\\n        require(reinvestorEnabled[reinvestor], \\\"VaultToken: REINVESTOR_ENABLED\\\");\\n\\n        uint256 index = _indexOfReinvestor(reinvestor);\\n        address last = reinvestorList[reinvestorList.length - 1];\\n        reinvestorList[index] = last;\\n        reinvestorList.pop();\\n        delete reinvestorEnabled[reinvestor];\\n    }\\n\\n    function updateReinvestBounty(uint256 _newReinvestBounty) external onlyFactoryOwner {\\n        require(_newReinvestBounty >= MIN_REINVEST_BOUNTY && _newReinvestBounty <= MAX_REINVEST_BOUNTY, \\\"VaultToken: INVLD_REINVEST_BOUNTY\\\");\\n        REINVEST_BOUNTY = _newReinvestBounty;\\n\\n        emit UpdateReinvestBounty(_newReinvestBounty);\\n    }\\n\\n    function updateReinvestFee(uint256 _newReinvestFee) external onlyFactoryOwner {\\n        require(_newReinvestFee >= MIN_REINVEST_FEE && _newReinvestFee <= MAX_REINVEST_FEE, \\\"VaultToken: INVLD_REINVEST_FEE\\\");\\n        REINVEST_FEE = _newReinvestFee;\\n\\n        emit UpdateReinvestFee(_newReinvestFee);\\n    }\\n\\n    function updateReinvestFeeTo(address _newReinvestFeeTo) external onlyFactoryOwner {\\n        reinvestFeeTo = _newReinvestFeeTo;\\n\\n        emit UpdateReinvestFeeTo(_newReinvestFeeTo);\\n    }\\n\\n    /*** PoolToken Overrides ***/\\n\\n    function _update() internal {\\n        uint256 _totalBalance = IThenaGauge(gauge).balanceOf(address(this));\\n        totalBalance = _totalBalance;\\n        emit Sync(_totalBalance);\\n    }\\n\\n    // this low-level function should be called from another contract\\n    function mint(address minter) external nonReentrant update returns (uint256 mintTokens) {\\n        uint256 mintAmount = underlying.myBalance();\\n        // handle pools with deposit fees by checking balance before and after deposit\\n        uint256 _totalBalanceBefore = IThenaGauge(gauge).balanceOf(address(this));\\n        IThenaGauge(gauge).deposit(mintAmount);\\n        uint256 _totalBalanceAfter = IThenaGauge(gauge).balanceOf(address(this));\\n        mintTokens = _totalBalanceAfter.sub(_totalBalanceBefore).mul(1e18).div(exchangeRate());\\n\\n        if (totalSupply == 0) {\\n            // permanently lock the first MINIMUM_LIQUIDITY tokens\\n            mintTokens = mintTokens.sub(MINIMUM_LIQUIDITY);\\n            _mint(address(0), MINIMUM_LIQUIDITY);\\n        }\\n        require(mintTokens > 0, \\\"VaultToken: MINT_AMOUNT_ZERO\\\");\\n        _mint(minter, mintTokens);\\n        emit Mint(msg.sender, minter, mintAmount, mintTokens);\\n    }\\n\\n    // this low-level function should be called from another contract\\n    function redeem(address redeemer) external nonReentrant update returns (uint256 redeemAmount) {\\n        uint256 redeemTokens = balanceOf[address(this)];\\n        redeemAmount = redeemTokens.mul(exchangeRate()).div(1e18);\\n\\n        require(redeemAmount > 0, \\\"VaultToken: REDEEM_AMOUNT_ZERO\\\");\\n        require(redeemAmount <= totalBalance, \\\"VaultToken: INSUFFICIENT_CASH\\\");\\n        _burn(address(this), redeemTokens);\\n        IThenaGauge(gauge).withdraw(redeemAmount);\\n        _safeTransfer(redeemer, redeemAmount);\\n        emit Redeem(msg.sender, redeemer, redeemAmount, redeemTokens);\\n    }\\n\\n    /*** Reinvest ***/\\n\\n    function _optimalDepositA(\\n        uint256 _amountA,\\n        uint256 _reserveA\\n    ) internal view returns (uint256) {\\n        uint256 swapFee = IVeloPairFactory(pairFactory).getFee(false);\\n        uint256 swapFeeFactor = uint256(10000).sub(swapFee);\\n        uint256 a = uint256(10000).add(swapFeeFactor).mul(_reserveA);\\n        uint256 b = _amountA.mul(10000).mul(_reserveA).mul(4).mul(swapFeeFactor);\\n        uint256 c = Math.sqrt(a.mul(a).add(b));\\n        uint256 d = uint256(2).mul(swapFeeFactor);\\n        return c.sub(a).div(d);\\n    }\\n\\n    function approveRouter(address token, uint256 amount) internal {\\n        if (IERC20(token).allowance(address(this), router) >= amount) return;\\n        token.safeApprove(address(router), uint256(-1));\\n    }\\n\\n    function swapExactTokensForTokens(\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 amount\\n    ) internal {\\n        approveRouter(tokenIn, amount);\\n        IVeloRouter(router).swapExactTokensForTokensSimple(amount, 0, tokenIn, tokenOut, false, address(this), block.timestamp);\\n    }\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountA,\\n        uint256 amountB\\n    ) internal returns (uint256 liquidity) {\\n        approveRouter(tokenA, amountA);\\n        approveRouter(tokenB, amountB);\\n        (, , liquidity) = IVeloRouter(router).addLiquidity(tokenA, tokenB, false, amountA, amountB, 0, 0, address(this), block.timestamp);\\n    }\\n\\n    function swapTokensForBestAmountOut(\\n        IOptiSwap _optiSwap,\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 amountIn\\n    ) internal returns (uint256 amountOut) {\\n        if (tokenIn == tokenOut) {\\n            return amountIn;\\n        }\\n        address pair;\\n        (pair, amountOut) = _optiSwap.getBestAmountOut(amountIn, tokenIn, tokenOut);\\n        require(pair != address(0), \\\"NO_PAIR\\\");\\n        tokenIn.safeTransfer(pair, amountIn);\\n        if (tokenIn < tokenOut) {\\n            OptiSwapPair(pair).swap(0, amountOut, address(this), new bytes(0));\\n        } else {\\n            OptiSwapPair(pair).swap(amountOut, 0, address(this), new bytes(0));\\n        }\\n    }\\n\\n    function optiSwapExactTokensForTokens(\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 amountIn\\n    ) internal returns (uint256 amountOut) {\\n        if (tokenIn == tokenOut) {\\n            return amountIn;\\n        }\\n        IOptiSwap _optiSwap = IOptiSwap(optiSwap);\\n        address nextHop = _optiSwap.getBridgeToken(tokenIn);\\n        if (nextHop == tokenOut) {\\n            return swapTokensForBestAmountOut(_optiSwap, tokenIn, tokenOut, amountIn);\\n        }\\n        address waypoint = _optiSwap.getBridgeToken(tokenOut);\\n        if (tokenIn == waypoint) {\\n            return swapTokensForBestAmountOut(_optiSwap, tokenIn, tokenOut, amountIn);\\n        }\\n        uint256 hopAmountOut;\\n        if (nextHop != tokenIn) {\\n            hopAmountOut = swapTokensForBestAmountOut(_optiSwap, tokenIn, nextHop, amountIn);\\n        } else {\\n            hopAmountOut = amountIn;\\n        }\\n        if (nextHop == waypoint) {\\n            return swapTokensForBestAmountOut(_optiSwap, nextHop, tokenOut, hopAmountOut);\\n        } else if (waypoint == tokenOut) {\\n            return optiSwapExactTokensForTokens(nextHop, tokenOut, hopAmountOut);\\n        } else {\\n            uint256 waypointAmountOut = optiSwapExactTokensForTokens(nextHop, waypoint, hopAmountOut);\\n            return swapTokensForBestAmountOut(_optiSwap, waypoint, tokenOut, waypointAmountOut);\\n        }\\n    }\\n\\n    function _getReward() internal returns (uint256 amount) {\\n        IThenaGauge(gauge).getReward();\\n\\n        return rewardsToken.myBalance();\\n    }\\n\\n    function getReward() external nonReentrant returns (uint256) {\\n        require(msg.sender == tx.origin || reinvestorEnabled[msg.sender]);\\n        return _getReward();\\n    }\\n\\n    function reinvest() external nonReentrant update {\\n        require(msg.sender == tx.origin || reinvestorEnabled[msg.sender]);\\n        // 1. Withdraw all the rewards.\\n        uint256 reward = _getReward();\\n        if (reward == 0) return;\\n        // 2. Send the reward bounty to the caller.\\n        uint256 bounty = reward.mul(REINVEST_BOUNTY) / 1e18;\\n        if (bounty > 0) {\\n            rewardsToken.safeTransfer(msg.sender, bounty);\\n        }\\n        uint256 fee = reward.mul(REINVEST_FEE) / 1e18;\\n        if (fee > 0) {\\n            rewardsToken.safeTransfer(reinvestFeeTo, fee);\\n        }\\n        // 3. Convert all the remaining rewards to token0 or token1.\\n        address tokenA;\\n        address tokenB;\\n        if (token0 == rewardsToken || token1 == rewardsToken) {\\n            (tokenA, tokenB) = token0 == rewardsToken ? (token0, token1) : (token1, token0);\\n        } else {\\n            if (token1 == WETH) {\\n                (tokenA, tokenB) = (token1, token0);\\n            } else {\\n                (tokenA, tokenB) = (token0, token1);\\n            }\\n            optiSwapExactTokensForTokens(rewardsToken, tokenA, reward.sub(bounty.add(fee)));\\n        }\\n        // 4. Convert tokenA to LP Token underlyings.\\n        uint256 totalAmountA = tokenA.myBalance();\\n        assert(totalAmountA > 0);\\n        (uint256 r0, uint256 r1, ) = IUniswapV2Pair(underlying).getReserves();\\n        uint256 reserveA = tokenA == token0 ? r0 : r1;\\n        uint256 swapAmount = _optimalDepositA(totalAmountA, reserveA);\\n        swapExactTokensForTokens(tokenA, tokenB, swapAmount);\\n        uint256 liquidity = addLiquidity(tokenA, tokenB, totalAmountA.sub(swapAmount), tokenB.myBalance());\\n        // 5. Stake the LP Tokens.\\n        IThenaGauge(gauge).deposit(liquidity);\\n        emit Reinvest(msg.sender, reward, bounty, fee);\\n    }\\n\\n    function adminClaimRewards() external onlyFactoryOwner nonReentrant {\\n        IThenaGauge(gauge).getReward();\\n    }\\n\\n    function adminRescueTokens(address _to, address[] calldata _tokens) external onlyFactoryOwner nonReentrant {\\n        require(_to != address(0), \\\"VaultToken: INVLD_TO\\\");\\n\\n        for (uint256 i = 0; i < _tokens.length; i++) {\\n            address token = _tokens[i];\\n            require(token != underlying, \\\"VaultToken: IS_UNDERLYING\\\");\\n            require(token != rewardsToken, \\\"VaultToken: IS_REWARDS_TOKEN\\\");\\n            require(token != token0, \\\"VaultToken: IS_TOKEN_0\\\");\\n            require(token != token1, \\\"VaultToken: IS_TOKEN_1\\\");\\n\\n            uint256 tokenBalance = token.myBalance();\\n            if (tokenBalance > 0) {\\n                token.safeTransfer(_to, tokenBalance);\\n            }\\n        }\\n    }\\n\\n    /*** Mirrored From uniswapV2Pair ***/\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 reserve0,\\n            uint112 reserve1,\\n            uint32 blockTimestampLast\\n        )\\n    {\\n        (uint _reserve0, uint _reserve1, uint _blockTimestampLast) = IUniswapV2Pair(underlying).getReserves();\\n        reserve0 = safe112(_reserve0);\\n        reserve1 = safe112(_reserve1);\\n        blockTimestampLast = uint32(_blockTimestampLast % 2**32);\\n        // if no token has been minted yet mirror uniswap getReserves\\n        if (totalSupply == 0) return (reserve0, reserve1, blockTimestampLast);\\n        // else, return the underlying reserves of this contract\\n        uint256 _totalBalance = totalBalance;\\n        uint256 _totalSupply = IUniswapV2Pair(underlying).totalSupply();\\n        reserve0 = safe112(_totalBalance.mul(reserve0).div(_totalSupply));\\n        reserve1 = safe112(_totalBalance.mul(reserve1).div(_totalSupply));\\n        require(reserve0 > 100 && reserve1 > 100, \\\"VaultToken: INSUFFICIENT_RESERVES\\\");\\n    }\\n\\n    /*** Mirrored from BaseV1Pair ***/\\n\\n    function observationLength() external view returns (uint) {\\n        return IBaseV1Pair(underlying).observationLength();\\n    }\\n\\n    function observations(uint index)\\n        external\\n        view\\n        returns (\\n            uint timestamp,\\n            uint reserve0Cumulative,\\n            uint reserve1Cumulative\\n        )\\n    {\\n        return IBaseV1Pair(underlying).observations(index);\\n    }\\n\\n    function currentCumulativePrices()\\n        external\\n        view\\n        returns (\\n            uint reserve0Cumulative,\\n            uint reserve1Cumulative,\\n            uint timestamp\\n        )\\n    {\\n        return IBaseV1Pair(underlying).currentCumulativePrices();\\n    }\\n\\n    /*** Utilities ***/\\n\\n    function safe112(uint256 n) internal pure returns (uint112) {\\n        require(n < 2**112, \\\"VaultToken: SAFE112\\\");\\n        return uint112(n);\\n    }\\n\\n    function getBlockTimestamp() public view returns (uint32) {\\n        return uint32(block.timestamp % 2**32);\\n    }\\n\\n    /*** Modifiers ***/\\n\\n    modifier onlyFactoryOwner() {\\n        require(Ownable(factory).owner() == msg.sender, \\\"NOT_AUTHORIZED\\\");\\n        _;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintTokens\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redeemAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redeemTokens\",\"type\":\"uint256\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bounty\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"Reinvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBalance\",\"type\":\"uint256\"}],\"name\":\"Sync\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newReinvestBounty\",\"type\":\"uint256\"}],\"name\":\"UpdateReinvestBounty\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newReinvestFee\",\"type\":\"uint256\"}],\"name\":\"UpdateReinvestFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newReinvestFeeTo\",\"type\":\"address\"}],\"name\":\"UpdateReinvestFeeTo\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_REINVEST_BOUNTY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_REINVEST_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MINIMUM_LIQUIDITY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_REINVEST_BOUNTY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_REINVEST_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REINVEST_BOUNTY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REINVEST_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_optiSwap\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_voter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pairFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardsToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_reinvestFeeTo\",\"type\":\"address\"}],\"name\":\"_initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"_setFactory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"reinvestor\",\"type\":\"address\"}],\"name\":\"addReinvestor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"adminClaimRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"}],\"name\":\"adminRescueTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentCumulativePrices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reserve0Cumulative\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve1Cumulative\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gauge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBlockTimestamp\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getReserves\",\"outputs\":[{\"internalType\":\"uint112\",\"name\":\"reserve0\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"reserve1\",\"type\":\"uint112\"},{\"internalType\":\"uint32\",\"name\":\"blockTimestampLast\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"reinvestor\",\"type\":\"address\"}],\"name\":\"isReinvestorEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isVaultToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mintTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"observationLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"observations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve0Cumulative\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve1Cumulative\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"optiSwap\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pairFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"redeemAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reinvest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reinvestFeeTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"reinvestorListItem\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reinvestorListLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"reinvestor\",\"type\":\"address\"}],\"name\":\"removeReinvestor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardsToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"skim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sync\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token0\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"underlying\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newReinvestBounty\",\"type\":\"uint256\"}],\"name\":\"updateReinvestBounty\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newReinvestFee\",\"type\":\"uint256\"}],\"name\":\"updateReinvestFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newReinvestFeeTo\",\"type\":\"address\"}],\"name\":\"updateReinvestFeeTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"voter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ThenaVaultToken", "CompilerVersion": "v0.5.16+commit.9c3226ce", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}