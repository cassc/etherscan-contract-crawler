{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Barz.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.21;\\n\\nimport {LibDiamond} from \\\"./libraries/LibDiamond.sol\\\";\\nimport {IBarz} from \\\"./interfaces/IBarz.sol\\\";\\n\\n/**\\n * @title Barz\\n * @dev A diamond proxy wallet with a modular & upgradeable architecture\\n * @author David Yongjun Kim (@Powerstream3604)\\n */\\ncontract Barz is IBarz {\\n    /**\\n     * @notice Initializes Barz with the given parameters. Barz account is intended to be created from Barz Factory for stable deployment.\\n     * @dev This method makes a delegate call to account facet and account facet handles the initialization.\\n     *      With modular architecture, Barz encompasses wide spectrum of architecture and logic.\\n     *      The only requirement is account facet to comply with initialize() interface.\\n     *      Barz doesn't include built-in functions and is a full proxy, for maximum extensibility and modularity.\\n     * @param _accountFacet Address of Account Facet in charge of the Barz initialization\\n     * @param _verificationFacet Address of Verification Facet for verifying the signature. Could be any signature scheme\\n     * @param _entryPoint Address of Entry Point contract\\n     * @param _facetRegistry Address of Facet Registry. Facet Registry is a registry holding trusted facets that could be added to user's wallet\\n     * @param _defaultFallBack Address of Default FallBack Handler. Middleware contract for more efficient deployment\\n     * @param _ownerPublicKey Bytes of Owner Public Key using for initialization\\n     */\\n    constructor(\\n        address _accountFacet,\\n        address _verificationFacet,\\n        address _entryPoint,\\n        address _facetRegistry,\\n        address _defaultFallBack,\\n        bytes memory _ownerPublicKey\\n    ) payable {\\n        bytes memory initCall = abi.encodeWithSignature(\\n            \\\"initialize(address,address,address,address,bytes)\\\",\\n            _verificationFacet,\\n            _entryPoint,\\n            _facetRegistry,\\n            _defaultFallBack,\\n            _ownerPublicKey\\n        );\\n        (bool success, bytes memory result) = _accountFacet.delegatecall(\\n            initCall\\n        );\\n        if (!success || uint256(bytes32(result)) != 1) {\\n            revert Barz__InitializationFailure();\\n        }\\n    }\\n\\n    /**\\n     * @notice Fallback function for Barz complying with Diamond Standard with customization of adding Default Fallback Handler\\n     * @dev Find facet for function that is called and execute the function if a facet is found and return any value.\\n     */\\n    fallback() external payable {\\n        LibDiamond.DiamondStorage storage ds;\\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\\n        // get diamond storage\\n        assembly {\\n            ds.slot := position\\n        }\\n        // get facet from function selector\\n        address facet = address(bytes20(ds.facets[msg.sig]));\\n        if (facet == address(0))\\n            facet = ds.defaultFallbackHandler.facetAddress(msg.sig);\\n        require(facet != address(0), \\\"Barz: Function does not exist\\\");\\n        // Execute external function from facet using delegatecall and return any value.\\n        assembly {\\n            // copy function selector and any arguments\\n            calldatacopy(0, 0, calldatasize())\\n            // execute function call using the facet\\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\\n            // get any return value\\n            returndatacopy(0, 0, returndatasize())\\n            // return any return value or error back to the caller\\n            switch result\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Receive function to receive native token without data\\n     */\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/BarzFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.21;\\n\\nimport {Barz} from \\\"./Barz.sol\\\";\\nimport {IBarzFactory} from \\\"./interfaces/IBarzFactory.sol\\\";\\n\\n/**\\n * @title Barz Factory\\n * @dev Contract to easily deploy Barz to a pre-computed address with a single call\\n * @author David Yongjun Kim (@Powerstream3604)\\n */\\ncontract BarzFactory is IBarzFactory {\\n    event BarzDeployed(address);\\n\\n    address public immutable accountFacet;\\n    address public immutable entryPoint;\\n    address public immutable facetRegistry;\\n    address public immutable defaultFallback;\\n\\n    /**\\n     * @notice Sets the initialization data for Barz contract initialization\\n     * @param _accountFacet Account Facet to be used to create Barz\\n     * @param _entryPoint Entrypoint contract to be used to create Barz. This uses canonical EntryPoint deployed by EF\\n     * @param _facetRegistry Facet Registry to be used to create Barz\\n     * @param _defaultFallback Default Fallback Handler to be used to create Barz\\n     */\\n    constructor(\\n        address _accountFacet,\\n        address _entryPoint,\\n        address _facetRegistry,\\n        address _defaultFallback\\n    ) {\\n        accountFacet = _accountFacet;\\n        entryPoint = _entryPoint;\\n        facetRegistry = _facetRegistry;\\n        defaultFallback = _defaultFallback;\\n    }\\n\\n    /**\\n     * @notice Creates the Barz with a single call. It creates the Barz contract with the givent verification facet\\n     * @param _verificationFacet Address of verification facet used for creating the barz account\\n     * @param _owner Public Key of the owner to initialize barz account\\n     * @param _salt Salt used for deploying barz with create2\\n     * @return barz Instance of Barz contract deployed with the given parameters\\n     */\\n    function createAccount(\\n        address _verificationFacet,\\n        bytes calldata _owner,\\n        uint256 _salt\\n    ) external override returns (Barz barz) {\\n        address addr = getAddress(_verificationFacet, _owner, _salt);\\n        uint codeSize = addr.code.length;\\n        if (codeSize > 0) {\\n            return Barz(payable(addr));\\n        }\\n        barz = new Barz{salt: bytes32(_salt)}(\\n            accountFacet,\\n            _verificationFacet,\\n            entryPoint,\\n            facetRegistry,\\n            defaultFallback,\\n            _owner\\n        );\\n        emit BarzDeployed(address(barz));\\n    }\\n\\n    /**\\n     * @notice Calculates the address of Barz with the given parameters\\n     * @param _verificationFacet Address of verification facet used for creating the barz account\\n     * @param _owner Public Key of the owner to initialize barz account\\n     * @param _salt Salt used for deploying barz with create2\\n     * @return barzAddress Precalculated Barz address\\n     */\\n    function getAddress(\\n        address _verificationFacet,\\n        bytes calldata _owner,\\n        uint256 _salt\\n    ) public view override returns (address barzAddress) {\\n        bytes memory bytecode = getBytecode(\\n            accountFacet,\\n            _verificationFacet,\\n            entryPoint,\\n            facetRegistry,\\n            defaultFallback,\\n            _owner\\n        );\\n        bytes32 hash = keccak256(\\n            abi.encodePacked(\\n                bytes1(0xff),\\n                address(this),\\n                _salt,\\n                keccak256(bytecode)\\n            )\\n        );\\n        barzAddress = address(uint160(uint256(hash)));\\n    }\\n\\n    /**\\n     * @notice Returns the bytecode of Barz with the given parameter\\n     * @param _accountFacet Account Facet to be used to create Barz\\n     * @param _verificationFacet Verification Facet to be used to create Barz\\n     * @param _entryPoint Entrypoint contract to be used to create Barz. This uses canonical EntryPoint deployed by EF\\n     * @param _facetRegistry Facet Registry to be used to create Barz\\n     * @param _defaultFallback Default Fallback Handler to be used to create Barz\\n     * @param _ownerPublicKey Public Key of owner to be used to initialize Barz ownership\\n     * @return barzBytecode Bytecode of Barz\\n     */\\n    function getBytecode(\\n        address _accountFacet,\\n        address _verificationFacet,\\n        address _entryPoint,\\n        address _facetRegistry,\\n        address _defaultFallback,\\n        bytes calldata _ownerPublicKey\\n    ) public pure override returns (bytes memory barzBytecode) {\\n        bytes memory bytecode = type(Barz).creationCode;\\n        barzBytecode = abi.encodePacked(\\n            bytecode,\\n            abi.encode(\\n                _accountFacet,\\n                _verificationFacet,\\n                _entryPoint,\\n                _facetRegistry,\\n                _defaultFallback,\\n                _ownerPublicKey\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @notice Returns the creation code of the Barz contract\\n     * @return creationCode Creation code of Barz\\n     */\\n    function getCreationCode()\\n        public\\n        pure\\n        override\\n        returns (bytes memory creationCode)\\n    {\\n        creationCode = type(Barz).creationCode;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/facets/base/interfaces/IDiamondCut.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.21;\\n\\n/**\\n * @title DiamondCut Facet Interface\\n * @dev Interface for DiamondCut Facet responsible for adding/removing/replace facets in Barz\\n * @author David Yongjun Kim (@Powerstream3604)\\n */\\ninterface IDiamondCut {\\n    error DiamondCutFacet__InvalidRouteWithGuardian();\\n    error DiamondCutFacet__InvalidRouteWithoutGuardian();\\n    error DiamondCutFacet__InvalidArrayLength();\\n    error DiamondCutFacet__InsufficientApprovers();\\n    error DiamondCutFacet__InvalidApprover();\\n    error DiamondCutFacet__InvalidApproverSignature();\\n    error DiamondCutFacet__InvalidApprovalValidationPeriod();\\n    error DiamondCutFacet__CannotRevokeUnapproved();\\n    error DiamondCutFacet__GuardianApprovalNotRequired();\\n    error DiamondCutFacet__LackOfOwnerApproval();\\n    error DiamondCutFacet__OwnerAlreadyApproved();\\n    error DiamondCutFacet__DuplicateApproval();\\n\\n    event DiamondCutApproved(\\n        FacetCut[] diamondCut,\\n        address init,\\n        bytes initCalldata\\n    );\\n    event DiamondCutApprovalRevoked(\\n        FacetCut[] diamondCut,\\n        address init,\\n        bytes initCalldata\\n    );\\n\\n    event SupportsInterfaceUpdated(bytes4 interfaceId, bool _lag);\\n\\n    enum FacetCutAction {\\n        Add,\\n        Replace,\\n        Remove\\n    }\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param diamondCut Contains the facet addresses and function selectors\\n    /// @param init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata diamondCut,\\n        address init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    function updateSupportsInterface(bytes4 interfaceId, bool flag) external;\\n\\n    function diamondCutWithGuardian(\\n        FacetCut[] calldata diamondCut,\\n        address init,\\n        bytes calldata _calldata,\\n        address[] calldata approvers,\\n        bytes[] calldata signatures\\n    ) external;\\n\\n    function approveDiamondCut(\\n        FacetCut[] calldata diamondCut,\\n        address init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    function revokeDiamondCutApproval(\\n        FacetCut[] calldata diamondCut,\\n        address init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    function getDiamondCutApprovalCountWithTimeValidity(\\n        bytes32 diamondCutHash\\n    ) external view returns (uint256);\\n\\n    function getOwnerCutApprovalWithTimeValidity(\\n        bytes32 diamondCutHash\\n    ) external view returns (bool);\\n\\n    function isCutApproved(\\n        bytes32 diamondCutHash,\\n        address approver\\n    ) external view returns (bool);\\n\\n    function getDiamondCutHash(\\n        FacetCut[] calldata diamondCut,\\n        address init,\\n        bytes calldata _calldata\\n    ) external view returns (bytes32);\\n\\n    function getDiamondCutNonce() external view returns (uint128);\\n}\\n\"\r\n    },\r\n    \"contracts/facets/base/interfaces/IDiamondLoupe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.21;\\n\\n// A loupe is a small magnifying glass used to look at diamonds.\\n// These functions look at diamonds\\ninterface IDiamondLoupe {\\n    /// These functions are expected to be called frequently\\n    /// by tools.\\n\\n    struct Facet {\\n        address facetAddress;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Gets all facet addresses and their four byte function selectors.\\n    /// @return facets_ Facet\\n    function facets() external view returns (Facet[] memory facets_);\\n\\n    /// @notice Gets all the function selectors supported by a specific facet.\\n    /// @param _facet The facet address.\\n    /// @return facetFunctionSelectors_\\n    function facetFunctionSelectors(\\n        address _facet\\n    ) external view returns (bytes4[] memory facetFunctionSelectors_);\\n\\n    /// @notice Get all the facet addresses used by a diamond.\\n    /// @return facetAddresses_\\n    function facetAddresses()\\n        external\\n        view\\n        returns (address[] memory facetAddresses_);\\n\\n    /// @notice Gets the facet that supports the given selector.\\n    /// @dev If facet is not found return address(0).\\n    /// @param _functionSelector The function selector.\\n    /// @return facetAddress_ The facet address.\\n    function facetAddress(\\n        bytes4 _functionSelector\\n    ) external view returns (address facetAddress_);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBarz.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.21;\\n\\n/**\\n * @title Barz Interface\\n * @dev Interface of Barz\\n * @author David Yongjun Kim (@Powerstream3604)\\n */\\ninterface IBarz {\\n    error Barz__InitializationFailure();\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBarzFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.21;\\n\\nimport {Barz} from \\\"../Barz.sol\\\";\\n\\n/**\\n * @title Barz Factory Interface\\n * @dev Interface of contract to easily deploy Barz to a pre-computed address with a single call\\n * @author David Yongjun Kim (@Powerstream3604)\\n */\\ninterface IBarzFactory {\\n    function createAccount(\\n        address verificationFacet,\\n        bytes calldata owner,\\n        uint256 salt\\n    ) external returns (Barz);\\n\\n    function getAddress(\\n        address verificationFacet,\\n        bytes calldata owner,\\n        uint256 salt\\n    ) external view returns (address);\\n\\n    function getBytecode(\\n        address accountFacet,\\n        address verificationFacet,\\n        address entryPoint,\\n        address facetRegistry,\\n        address defaultFallback,\\n        bytes memory ownerPublicKey\\n    ) external pure returns (bytes memory);\\n\\n    function getCreationCode() external pure returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LibDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.21;\\n\\nimport {IDiamondCut} from \\\"../facets/base/interfaces/IDiamondCut.sol\\\";\\nimport {IDiamondLoupe} from \\\"../facets/base/interfaces/IDiamondLoupe.sol\\\";\\n\\nerror InitializationFunctionReverted(\\n    address _initializationContractAddress,\\n    bytes _calldata\\n);\\n\\nlibrary LibDiamond {\\n    bytes32 constant DIAMOND_STORAGE_POSITION =\\n        keccak256(\\\"trustwallet.barz.diamond.storage\\\");\\n\\n    struct DiamondStorage {\\n        // maps function selectors to the facets that execute the functions.\\n        // and maps the selectors to their position in the selectorSlots array.\\n        // func selector => address facet, selector position\\n        mapping(bytes4 => bytes32) facets;\\n        // array of slots of function selectors.\\n        // each slot holds 8 function selectors.\\n        mapping(uint256 => bytes32) selectorSlots;\\n        // The number of function selectors in selectorSlots\\n        uint16 selectorCount;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // Default Fallback Handler of the barz.\\n        IDiamondLoupe defaultFallbackHandler;\\n    }\\n\\n    function diamondStorage()\\n        internal\\n        pure\\n        returns (DiamondStorage storage ds)\\n    {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    function enforceIsSelf() internal view {\\n        require(msg.sender == address(this), \\\"LibDiamond: Caller not self\\\");\\n    }\\n\\n    event DiamondCut(\\n        IDiamondCut.FacetCut[] _diamondCut,\\n        address _init,\\n        bytes _calldata\\n    );\\n\\n    bytes32 constant CLEAR_ADDRESS_MASK =\\n        bytes32(uint256(0xffffffffffffffffffffffff));\\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\\n\\n    // Internal function version of diamondCut\\n    // This code is almost the same as the external diamondCut,\\n    // except it is using 'Facet[] memory _diamondCut' instead of\\n    // 'Facet[] calldata _diamondCut'.\\n    // The code is duplicated to prevent copying calldata to memory which\\n    // causes an error for a two dimensional array.\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        uint256 originalSelectorCount = ds.selectorCount;\\n        uint256 selectorCount = originalSelectorCount;\\n        bytes32 selectorSlot;\\n        // Check if last selector slot is not full\\n        // \\\"selectorCount & 7\\\" is a gas efficient modulo by eight \\\"selectorCount % 8\\\"\\n        if (selectorCount & 7 > 0) {\\n            // get last selectorSlot\\n            // \\\"selectorSlot >> 3\\\" is a gas efficient division by 8 \\\"selectorSlot / 8\\\"\\n            selectorSlot = ds.selectorSlots[selectorCount >> 3];\\n        }\\n        // loop through diamond cut\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; ) {\\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\\n                selectorCount,\\n                selectorSlot,\\n                _diamondCut[facetIndex].facetAddress,\\n                _diamondCut[facetIndex].action,\\n                _diamondCut[facetIndex].functionSelectors\\n            );\\n\\n            unchecked {\\n                facetIndex++;\\n            }\\n        }\\n        if (selectorCount != originalSelectorCount) {\\n            ds.selectorCount = uint16(selectorCount);\\n        }\\n        // If last selector slot is not full\\n        // \\\"selectorCount & 7\\\" is a gas efficient modulo by eight \\\"selectorCount % 8\\\"\\n        if (selectorCount & 7 > 0) {\\n            // \\\"selectorSlot >> 3\\\" is a gas efficient division by 8 \\\"selectorSlot / 8\\\"\\n            ds.selectorSlots[selectorCount >> 3] = selectorSlot;\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addReplaceRemoveFacetSelectors(\\n        uint256 _selectorCount,\\n        bytes32 _selectorSlot,\\n        address _newFacetAddress,\\n        IDiamondCut.FacetCutAction _action,\\n        bytes4[] memory _selectors\\n    ) internal returns (uint256, bytes32) {\\n        DiamondStorage storage ds = diamondStorage();\\n        require(\\n            _selectors.length > 0,\\n            \\\"LibDiamondCut: No selectors in facet to cut\\\"\\n        );\\n        if (_action == IDiamondCut.FacetCutAction.Add) {\\n            enforceHasContractCode(\\n                _newFacetAddress,\\n                \\\"LibDiamondCut: Add facet has no code\\\"\\n            );\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\\n                bytes4 selector = _selectors[selectorIndex];\\n                bytes32 oldFacet = ds.facets[selector];\\n                require(\\n                    address(bytes20(oldFacet)) == address(0),\\n                    \\\"LibDiamondCut: Can't add function that already exists\\\"\\n                );\\n                // add facet for selector\\n                ds.facets[selector] =\\n                    bytes20(_newFacetAddress) |\\n                    bytes32(_selectorCount);\\n                // \\\"_selectorCount & 7\\\" is a gas efficient modulo by eight \\\"_selectorCount % 8\\\"\\n                // \\\" << 5 is the same as multiplying by 32 ( * 32)\\n                uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\\n                // clear selector position in slot and add selector\\n                _selectorSlot =\\n                    (_selectorSlot &\\n                        ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) |\\n                    (bytes32(selector) >> selectorInSlotPosition);\\n                // if slot is full then write it to storage\\n                if (selectorInSlotPosition == 224) {\\n                    // \\\"_selectorSlot >> 3\\\" is a gas efficient division by 8 \\\"_selectorSlot / 8\\\"\\n                    ds.selectorSlots[_selectorCount >> 3] = _selectorSlot;\\n                    _selectorSlot = 0;\\n                }\\n                _selectorCount++;\\n\\n                unchecked {\\n                    selectorIndex++;\\n                }\\n            }\\n        } else if (_action == IDiamondCut.FacetCutAction.Replace) {\\n            enforceHasContractCode(\\n                _newFacetAddress,\\n                \\\"LibDiamondCut: Replace facet has no code\\\"\\n            );\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\\n                bytes4 selector = _selectors[selectorIndex];\\n                bytes32 oldFacet = ds.facets[selector];\\n                address oldFacetAddress = address(bytes20(oldFacet));\\n                // only useful if immutable functions exist\\n                require(\\n                    oldFacetAddress != address(this),\\n                    \\\"LibDiamondCut: Can't replace immutable function\\\"\\n                );\\n                require(\\n                    oldFacetAddress != _newFacetAddress,\\n                    \\\"LibDiamondCut: Can't replace function with same function\\\"\\n                );\\n                require(\\n                    oldFacetAddress != address(0),\\n                    \\\"LibDiamondCut: Can't replace function that doesn't exist\\\"\\n                );\\n                // replace old facet address\\n                ds.facets[selector] =\\n                    (oldFacet & CLEAR_ADDRESS_MASK) |\\n                    bytes20(_newFacetAddress);\\n\\n                unchecked {\\n                    selectorIndex++;\\n                }\\n            }\\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\\n            require(\\n                _newFacetAddress == address(0),\\n                \\\"LibDiamondCut: Remove facet address must be address(0)\\\"\\n            );\\n            // \\\"_selectorCount >> 3\\\" is a gas efficient division by 8 \\\"_selectorCount / 8\\\"\\n            uint256 selectorSlotCount = _selectorCount >> 3;\\n            // \\\"_selectorCount & 7\\\" is a gas efficient modulo by eight \\\"_selectorCount % 8\\\"\\n            uint256 selectorInSlotIndex = _selectorCount & 7;\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\\n                if (_selectorSlot == 0) {\\n                    // get last selectorSlot\\n                    selectorSlotCount--;\\n                    _selectorSlot = ds.selectorSlots[selectorSlotCount];\\n                    selectorInSlotIndex = 7;\\n                } else {\\n                    selectorInSlotIndex--;\\n                }\\n                bytes4 lastSelector;\\n                uint256 oldSelectorsSlotCount;\\n                uint256 oldSelectorInSlotPosition;\\n                // adding a block here prevents stack too deep error\\n                {\\n                    bytes4 selector = _selectors[selectorIndex];\\n                    bytes32 oldFacet = ds.facets[selector];\\n                    require(\\n                        address(bytes20(oldFacet)) != address(0),\\n                        \\\"LibDiamondCut: Can't remove function that doesn't exist\\\"\\n                    );\\n                    // only useful if immutable functions exist\\n                    require(\\n                        address(bytes20(oldFacet)) != address(this),\\n                        \\\"LibDiamondCut: Can't remove immutable function\\\"\\n                    );\\n                    // replace selector with last selector in ds.facets\\n                    // gets the last selector\\n                    // \\\" << 5 is the same as multiplying by 32 ( * 32)\\n                    lastSelector = bytes4(\\n                        _selectorSlot << (selectorInSlotIndex << 5)\\n                    );\\n                    if (lastSelector != selector) {\\n                        // update last selector slot position info\\n                        ds.facets[lastSelector] =\\n                            (oldFacet & CLEAR_ADDRESS_MASK) |\\n                            bytes20(ds.facets[lastSelector]);\\n                    }\\n                    delete ds.facets[selector];\\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\\n                    // \\\"oldSelectorCount >> 3\\\" is a gas efficient division by 8 \\\"oldSelectorCount / 8\\\"\\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\\n                    // \\\"oldSelectorCount & 7\\\" is a gas efficient modulo by eight \\\"oldSelectorCount % 8\\\"\\n                    // \\\" << 5 is the same as multiplying by 32 ( * 32)\\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\\n                }\\n                if (oldSelectorsSlotCount != selectorSlotCount) {\\n                    bytes32 oldSelectorSlot = ds.selectorSlots[\\n                        oldSelectorsSlotCount\\n                    ];\\n                    // clears the selector we are deleting and puts the last selector in its place.\\n                    oldSelectorSlot =\\n                        (oldSelectorSlot &\\n                            ~(CLEAR_SELECTOR_MASK >>\\n                                oldSelectorInSlotPosition)) |\\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n                    // update storage with the modified slot\\n                    ds.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\\n                } else {\\n                    // clears the selector we are deleting and puts the last selector in its place.\\n                    _selectorSlot =\\n                        (_selectorSlot &\\n                            ~(CLEAR_SELECTOR_MASK >>\\n                                oldSelectorInSlotPosition)) |\\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n                }\\n                if (selectorInSlotIndex == 0) {\\n                    delete ds.selectorSlots[selectorSlotCount];\\n                    _selectorSlot = 0;\\n                }\\n\\n                unchecked {\\n                    selectorIndex++;\\n                }\\n            }\\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\\n        } else {\\n            revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n        }\\n        return (_selectorCount, _selectorSlot);\\n    }\\n\\n    function initializeDiamondCut(\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        if (_init == address(0)) {\\n            return;\\n        }\\n        enforceHasContractCode(\\n            _init,\\n            \\\"LibDiamondCut: _init address has no code\\\"\\n        );\\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n        if (!success) {\\n            if (error.length > 0) {\\n                // bubble up error\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(error)\\n                    revert(add(32, error), returndata_size)\\n                }\\n            } else {\\n                revert InitializationFunctionReverted(_init, _calldata);\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(\\n        address _contract,\\n        string memory _errorMessage\\n    ) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n\\n    function restrictionsFacet() internal view returns (address facetAddress_) {\\n        bytes4 selector = bytes4(\\n            keccak256(\\\"verifyRestrictions(address,address,uint256,bytes)\\\")\\n        );\\n        facetAddress_ = address(\\n            bytes20(LibDiamond.diamondStorage().facets[selector])\\n        );\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_accountFacet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_entryPoint\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_facetRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_defaultFallback\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"BarzDeployed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"accountFacet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_verificationFacet\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_owner\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_salt\",\"type\":\"uint256\"}],\"name\":\"createAccount\",\"outputs\":[{\"internalType\":\"contract Barz\",\"name\":\"barz\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultFallback\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"entryPoint\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"facetRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_verificationFacet\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_owner\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_salt\",\"type\":\"uint256\"}],\"name\":\"getAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"barzAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_accountFacet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_verificationFacet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_entryPoint\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_facetRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_defaultFallback\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_ownerPublicKey\",\"type\":\"bytes\"}],\"name\":\"getBytecode\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"barzBytecode\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCreationCode\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"creationCode\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "BarzFactory", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "000000000000000000000000aa25b34558f66246a7f23050a14f386f1316963c0000000000000000000000005ff137d4b0fdcd49dca30c7cf57e578a026d2789000000000000000000000000afcb70e6e9514e2a15b23a01d2a9b9f7a34f2c33000000000000000000000000a0bb5bf7eb7dc7aa001f4ec6271e543ce31374fc", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}