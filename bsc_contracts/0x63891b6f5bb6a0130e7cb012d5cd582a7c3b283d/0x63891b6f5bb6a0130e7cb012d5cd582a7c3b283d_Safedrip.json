{"SourceCode": "/*\r\n * Https://T.me/safedrip\r\n * Written by: MrGreenCrypto\r\n * Co-Founder of CodeCraftrs.com\r\n * GET MONEY GET MONEY GET MONEY\r\n * SPDX-License-Identifier: None\r\n */\r\n\r\npragma solidity 0.8.19;\r\n\r\ninterface IBEP20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount ) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IDEXFactory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n}\r\n\r\ninterface IDEXPair {function sync() external;}\r\ninterface IHelper {\r\n    function giveMeMyMoneyBack(uint256 tax) external returns (bool);\r\n}\r\n\r\ninterface IDEXRouter {\r\n    function factory() external pure returns (address);    \r\n    function WETH() external pure returns (address);\r\n    function addLiquidityETH(address token,uint amountTokenDesired,uint amountTokenMin,uint amountETHMin,address to,uint deadline) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function addLiquidity(address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline) external returns (uint amountA, uint amountB, uint liquidity);\r\n    \r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);    \r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn,uint amountOutMin,address[] calldata path,address to,uint deadline) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external payable;\r\n}\r\n\r\ncontract Safedrip is IBEP20 {\r\n    string private _name = \"Safedrip\";\r\n    string private _symbol = \"SFDR\";\r\n    uint8 constant _decimals = 18;\r\n    uint256 _totalSupply = 1_000_000 * (10**_decimals);\r\n\r\n    address public constant CEO = 0xB0DeaCA927fdEAb69FF2E630E23A549CC285Ca14;\r\n\r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n    mapping(address => bool) public limitless;\r\n    mapping(address => bool) public ai;\r\n    mapping(address => bool) public isExludedFromMaxWallet;\r\n\r\n    bool public renounced = false;\r\n\r\n    uint256 public tax = 8;\r\n    uint256 public rewards = 2;\r\n    uint256 public liq = 4;\r\n    uint256 public outreach = 1;\r\n    uint256 public ecosystem = 1;\r\n    uint256 public estate = 1;\r\n    uint256 public jackpot = 1;\r\n    uint256 public jackpotBalance;\r\n    uint256 public jackpotFrequency = 50;\r\n    uint256 public buyCounter;\r\n    uint256 public enough = 0.02 ether;\r\n    uint256 private swapAt = _totalSupply / 10_000;\r\n    uint256 public maxWalletInPermille = 10;\r\n    uint256 private maxTx = 75;\r\n\r\n    IDEXRouter public constant ROUTER = IDEXRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n    IHelper private constant helper = IHelper(0x37AA8EC8382CCC16cD53d2500eBbe5C64Ee25268);\r\n    address private constant DEAD = 0x000000000000000000000000000000000000dEaD;\r\n    address private constant WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\r\n    address public mainReward = 0x76A797A59Ba2C17726896976B7B3747BfD1d220f;\r\n    address public outreachWallet = 0xC7e3318C300f0b821C27888E88a2417Bb8F7c8e2;\r\n\r\n    address public immutable pcsPair;\r\n    address[] public pairs;\r\n\r\n    struct Share {\r\n        uint256 amount;\r\n        uint256 totalExcluded;\r\n        uint256 totalRealised; \r\n    }\r\n\r\n    mapping (address => uint256) public shareholderIndexes;\r\n    mapping (address => uint256) public lastClaim;\r\n    mapping (address => Share) public shares;\r\n    mapping (address => bool) public addressNotGettingRewards;\r\n    mapping (address => bool) public isPaperhand;\r\n\r\n    uint256 public totalShares;\r\n    uint256 public totalDistributed;\r\n    uint256 public rewardsPerShare;\r\n    uint256 private veryLargeNumber = 10 ** 36;\r\n    uint256 private rewardTokenBalanceBefore;\r\n\r\n    address[] private shareholders;\r\n    \r\n    mapping(address => mapping(address => uint256)) public otherLpToken;\r\n    mapping(address => uint256) public ethLpToken;\r\n    uint256 public lpFee = 3;\r\n\r\n    modifier onlyCEO(){\r\n        require (msg.sender == CEO, \"Only the CEO can do that\");\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        pcsPair = IDEXFactory(IDEXRouter(ROUTER).factory()).createPair(WBNB, address(this));\r\n        _allowances[address(this)][address(ROUTER)] = type(uint256).max;\r\n        _allowances[CEO][address(ROUTER)] = type(uint256).max;\r\n        isExludedFromMaxWallet[pcsPair] = true;\r\n        isExludedFromMaxWallet[address(this)] = true;\r\n        pairs.push(pcsPair);\r\n\r\n        addressNotGettingRewards[pcsPair] = true;\r\n        addressNotGettingRewards[address(this)] = true;\r\n\r\n        limitless[CEO] = true;\r\n        limitless[address(this)] = true;\r\n\r\n        _balances[CEO] = _totalSupply;\r\n        emit Transfer(address(0), CEO, _totalSupply);\r\n    }\r\n\r\n    receive() external payable {}\r\n    function name() public view override returns (string memory) {return _name;}\r\n    function totalSupply() public view override returns (uint256) {return _totalSupply - _balances[DEAD];}\r\n    function decimals() public pure override returns (uint8) {return _decimals;}\r\n    function symbol() public view override returns (string memory) {return _symbol;}\r\n    function balanceOf(address account) public view override returns (uint256) {return _balances[account];}\r\n    function rescueBnb(uint256 amount) external onlyCEO {payable(CEO).transfer(amount);}\r\n    function rescueToken(address token, uint256 amount) external onlyCEO {IBEP20(token).transfer(CEO, amount);}\r\n    function allowance(address holder, address spender) public view override returns (uint256) {return _allowances[holder][spender];}\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {return _transferFrom(msg.sender, recipient, amount);}\r\n    function approveMax(address spender) external returns (bool) {return approve(spender, type(uint256).max);}\r\n    \r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        require(spender != address(0), \"Can't use zero address here\");\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        require(spender != address(0), \"Can't use zero address here\");\r\n        _allowances[msg.sender][spender]  = allowance(msg.sender, spender) + addedValue;\r\n        emit Approval(msg.sender, spender, _allowances[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        require(spender != address(0), \"Can't use zero address here\");\r\n        require(allowance(msg.sender, spender) >= subtractedValue, \"Can't subtract more than current allowance\");\r\n        _allowances[msg.sender][spender]  = allowance(msg.sender, spender) - subtractedValue;\r\n        emit Approval(msg.sender, spender, _allowances[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount ) external override returns (bool) {\r\n        if (_allowances[sender][msg.sender] != type(uint256).max) {\r\n            require(_allowances[sender][msg.sender] >= amount, \"Insufficient Allowance\");\r\n            _allowances[sender][msg.sender] -= amount;\r\n            emit Approval(sender, msg.sender, _allowances[sender][msg.sender]);\r\n        }\r\n        return _transferFrom(sender, recipient, amount);\r\n    }\r\n\r\n    function setTaxes(uint256 rewardsTax, uint256 liqTax, uint256 outreachTax, uint256 estateTax, uint256 ecosystemTax, uint256 jackpotTax) external onlyCEO {\r\n        if(renounced) require(rewardsTax + liqTax + estateTax + ecosystemTax + outreachTax+ jackpotTax <= tax , \"Once renounced, taxes can only be lowered\");\r\n        rewards = rewardsTax;\r\n        liq = liqTax;\r\n        outreach = outreachTax;\r\n        ecosystem = ecosystemTax;\r\n        estate = estateTax;\r\n        jackpot = jackpotTax; \r\n        tax = rewards + liq + outreach + ecosystem + estate + jackpot;\r\n        require(tax < 18, \"Tax safety limit\");     \r\n    }\r\n    \r\n    function setMaxWalletInPermille(uint256 permille) external onlyCEO {\r\n        if(renounced) {\r\n            maxWalletInPermille = 1000;\r\n            return;\r\n        }\r\n        maxWalletInPermille = permille;\r\n        require(maxWalletInPermille >= 10, \"MaxWallet safety limit\");\r\n    }\r\n\r\n    function setMaxTxInPercentOfMaxWallet(uint256 percent) external onlyCEO {\r\n        if(renounced) {maxTx = 100; return;}\r\n        maxTx = percent;\r\n        require(maxTx >= 75, \"MaxTx safety limit\");\r\n    }\r\n    \r\n    function setNameAndSymbol(string memory newName, string memory newSymbol) external onlyCEO {\r\n        _name = newName;\r\n        _symbol = newSymbol;\r\n    }\r\n\r\n    function setMinBuy(uint256 inWei) external onlyCEO {\r\n        enough = inWei;\r\n    }    \r\n    \r\n    function setLpFee(uint256 percent) external onlyCEO {\r\n        lpFee = percent;\r\n    }\r\n\r\n    function setLimitlessWallet(address limitlessWallet, bool status) external onlyCEO {\r\n        if(renounced) return;\r\n        isExludedFromMaxWallet[limitlessWallet] = status;\r\n        addressNotGettingRewards[limitlessWallet] = status;\r\n        limitless[limitlessWallet] = status;\r\n    }\r\n\r\n    function excludeFromRewards(address excludedWallet, bool status) external onlyCEO {\r\n        addressNotGettingRewards[excludedWallet] = status;\r\n    }\r\n\r\n    function changeOutreachWallet(address newOutreachWallet) external onlyCEO {\r\n        outreachWallet = newOutreachWallet;\r\n    }    \r\n    \r\n    function changeMainRewards(address newRewards) external onlyCEO {\r\n        mainReward = newRewards;\r\n    }\r\n\r\n    function excludeFromMax(address excludedWallet, bool status) external onlyCEO {\r\n        isExludedFromMaxWallet[excludedWallet] = status;\r\n    }    \r\n\r\n    function setAi(address aiWallet, bool status) external onlyCEO {\r\n        ai[aiWallet] = status;\r\n    }    \r\n    \r\n    function changeJackpotFrequency(uint256 frequency) external onlyCEO {\r\n        jackpotFrequency = frequency;\r\n    }\r\n\r\n    function renounceOnwrship() external onlyCEO {\r\n        if(renounced) return;\r\n        renounced = true;\r\n    }\r\n\r\n    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        if (limitless[sender] || limitless[recipient]) return _lowGasTransfer(sender, recipient, amount);\r\n        amount = takeTax(sender, recipient, amount);\r\n        _lowGasTransfer(sender, recipient, amount);\r\n        if(!addressNotGettingRewards[sender]) setShare(sender);\r\n        if(!addressNotGettingRewards[recipient]) setShare(recipient);\r\n        return true;\r\n    }\r\n\r\n    function takeTax(address sender, address recipient, uint256 amount) internal returns (uint256) {\r\n        if(maxWalletInPermille <= 1000) {    \r\n            if(!isExludedFromMaxWallet[recipient]) require(_balances[recipient] + amount <= _totalSupply * maxWalletInPermille / 1000, \"MaxWallet\");\r\n            if(!isExludedFromMaxWallet[sender]) require(amount <= _totalSupply * maxWalletInPermille * maxTx / 1000 / 100, \"MaxTx\");\r\n        }\r\n\r\n        if(ai[sender] || ai[recipient]) {\r\n            uint256 aiTax = amount * 14 / 100;\r\n            if(isPair(recipient)) _lowGasTransfer(sender, recipient, aiTax);\r\n            else if(isPair(sender)) _lowGasTransfer(sender, sender, aiTax);\r\n            else _lowGasTransfer(sender, pcsPair, aiTax);\r\n            return amount * 86 / 100;           \r\n        } else if(!isPair(sender) && !isPair(recipient)) return amount;\r\n\r\n        if(tax == 0) return amount;\r\n        uint256 taxToSwap = amount * (rewards + outreach + ecosystem + estate) / 100;\r\n        if(taxToSwap > 0) _lowGasTransfer(sender, address(this), taxToSwap);\r\n        \r\n        if(jackpot > 0) {\r\n            uint256 jackpotTax = amount * jackpot / 100;\r\n            _lowGasTransfer(sender, address(this), jackpotTax);\r\n            jackpotBalance += jackpotTax;\r\n        }\r\n\r\n        if(isPair(sender)) {\r\n            if(enough == 0 || isEnough(amount)) {\r\n                buyCounter++;\r\n                if(buyCounter >= jackpotFrequency) {\r\n                    _lowGasTransfer(address(this), recipient, jackpotBalance);\r\n                    jackpotBalance = 0;\r\n                    buyCounter = 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        if(liq > 0) {\r\n            uint256 liqTax = amount * liq / 100;\r\n            if(isPair(recipient)) _lowGasTransfer(sender, recipient, liqTax);\r\n            else if(isPair(sender)) _lowGasTransfer(sender, sender, liqTax);\r\n            else _lowGasTransfer(sender, pcsPair, liqTax);\r\n        }\r\n\r\n        if(!isPair(sender)) {\r\n            swapForRewards();\r\n            IDEXPair(pcsPair).sync();\r\n        }\r\n        return amount - (amount * tax / 100);\r\n    }\r\n\r\n    function isEnough(uint256 amount) public view returns (bool isIt) {\r\n        uint256 equivalent = IBEP20(WBNB).balanceOf(pcsPair) * amount / _balances[pcsPair];\r\n        if(equivalent >= enough) return true;\r\n        return false;\r\n    }\r\n\r\n    function _lowGasTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        require(sender != address(0), \"Can't use zero addresses here\");\r\n        require(amount <= _balances[sender], \"Can't transfer more than you own\");\r\n        if(amount == 0) return true;\r\n        _balances[sender] -= amount;\r\n        _balances[recipient] += amount;\r\n        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function swapForRewards() internal {\r\n        if(_balances[address(this)] - jackpotBalance < swapAt || rewards + outreach + ecosystem + estate == 0) return;\r\n        rewardTokenBalanceBefore = address(this).balance;\r\n\r\n        address[] memory pathForSelling = new address[](2);\r\n        pathForSelling[0] = address(this);\r\n        pathForSelling[1] = WBNB;\r\n\r\n        ROUTER.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            _balances[address(this)] - jackpotBalance,\r\n            0,\r\n            pathForSelling,\r\n            address(helper),\r\n            block.timestamp\r\n        );\r\n        require(helper.giveMeMyMoneyBack(rewards + outreach + ecosystem + estate),\"Something went wrong\");\r\n        uint256 newRewardTokenBalance = address(this).balance;\r\n        if(newRewardTokenBalance <= rewardTokenBalanceBefore) return;\r\n        uint256 amount = newRewardTokenBalance - rewardTokenBalanceBefore;\r\n        if(rewards + outreach > 0){\r\n            uint256 outreachShare = amount * outreach / (rewards + outreach);\r\n            payable(outreachWallet).transfer(outreachShare);\r\n            rewardsPerShare += veryLargeNumber * (amount - outreachShare) / totalShares;\r\n        } else rewardsPerShare += veryLargeNumber * amount / totalShares;\r\n    }\r\n\r\n    function setShare(address shareholder) internal {\r\n        if(shares[shareholder].amount > 0) distributeRewards(shareholder);\r\n        if(shares[shareholder].amount == 0 && _balances[shareholder] >= 0) addShareholder(shareholder);\r\n        \r\n        if(shares[shareholder].amount > 0 && _balances[shareholder] < 0){\r\n            totalShares = totalShares - shares[shareholder].amount;\r\n            shares[shareholder].amount = 0;\r\n            removeShareholder(shareholder);\r\n            return;\r\n        }\r\n\r\n        if(_balances[shareholder] > 0){\r\n            totalShares = totalShares - shares[shareholder].amount + _balances[shareholder];\r\n            shares[shareholder].amount = _balances[shareholder];\r\n            shares[shareholder].totalExcluded = getTotalRewardsOf(shares[shareholder].amount);\r\n        }\r\n    }\r\n\r\n    function claimNoSwap() external {if(getUnpaidEarnings(msg.sender) > 0) distributeRewards(msg.sender);}\r\n    function claimBnbPaired(address desiredRewardToken) external {if(getUnpaidEarnings(msg.sender) > 0) distributeRewardsSplit(msg.sender, desiredRewardToken);}\r\n    function claimExpert(address[] memory path) external {if(getUnpaidEarnings(msg.sender) > 0) distributeRewardsExpert(msg.sender, path);}\r\n\r\n    function distributeRewards(address shareholder) internal {\r\n        uint256 amount = getUnpaidEarnings(shareholder);\r\n        if(amount == 0) return;\r\n        payable(shareholder).transfer(amount);\r\n        totalDistributed = totalDistributed + amount;\r\n        shares[shareholder].totalRealised = shares[shareholder].totalRealised + amount;\r\n        shares[shareholder].totalExcluded = getTotalRewardsOf(shares[shareholder].amount);\r\n    }\r\n\r\n    function distributeRewardsSplit(address shareholder, address userReward) internal {\r\n        uint256 amount = getUnpaidEarnings(shareholder);\r\n        if(amount == 0) return;\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = WBNB;\r\n        path[1] = mainReward;\r\n\r\n        ROUTER.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount / 2}(\r\n            0,\r\n            path,\r\n            shareholder,\r\n            block.timestamp\r\n        );\r\n\r\n        path[1] = userReward;\r\n        \r\n        ROUTER.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount / 2}(\r\n            0,\r\n            path,\r\n            shareholder,\r\n            block.timestamp\r\n        );\r\n\r\n        totalDistributed = totalDistributed + amount;\r\n        shares[shareholder].totalRealised = shares[shareholder].totalRealised + amount;\r\n        shares[shareholder].totalExcluded = getTotalRewardsOf(shares[shareholder].amount);\r\n    }\r\n\r\n    function distributeRewardsExpert(address shareholder, address[] memory userPath) internal {\r\n        uint256 amount = getUnpaidEarnings(shareholder);\r\n        if(amount == 0) return;\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = WBNB;\r\n        path[1] = mainReward;\r\n\r\n        ROUTER.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount / 2}(\r\n            0,\r\n            path,\r\n            shareholder,\r\n            block.timestamp\r\n        );\r\n\r\n        ROUTER.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount / 2}(\r\n            0,\r\n            userPath,\r\n            shareholder,\r\n            block.timestamp\r\n        );\r\n        \r\n        totalDistributed = totalDistributed + amount;\r\n        shares[shareholder].totalRealised = shares[shareholder].totalRealised + amount;\r\n        shares[shareholder].totalExcluded = getTotalRewardsOf(shares[shareholder].amount);\r\n    }\r\n\r\n    function getUnpaidEarnings(address shareholder) public view returns (uint256) {\r\n        uint256 shareholderTotalRewards = getTotalRewardsOf(shares[shareholder].amount);\r\n        uint256 shareholderTotalExcluded = shares[shareholder].totalExcluded;\r\n        if(shareholderTotalRewards <= shareholderTotalExcluded) return 0;\r\n        return shareholderTotalRewards - shareholderTotalExcluded;\r\n    }\r\n\r\n    function getTotalRewardsOf(uint256 share) internal view returns (uint256) {\r\n        return share * rewardsPerShare / veryLargeNumber;\r\n    }\r\n   \r\n    function addShareholder(address shareholder) internal {\r\n        shareholderIndexes[shareholder] = shareholders.length;\r\n        shareholders.push(shareholder);\r\n    }\r\n\r\n    function removeShareholder(address shareholder) internal {\r\n        shareholders[shareholderIndexes[shareholder]] = shareholders[shareholders.length-1];\r\n        shareholderIndexes[shareholders[shareholders.length-1]] = shareholderIndexes[shareholder];\r\n        shareholders.pop();\r\n    }\r\n\r\n// add liquidity in ETH and tokens for investors\r\n    function addLiquidityETH() public payable {\r\n        \r\n        uint256 tokensFromInvestor = balanceOf(msg.sender);\r\n        _lowGasTransfer(msg.sender, address(this), tokensFromInvestor);\r\n        \r\n\r\n        (uint256 tokensIntoLp, uint256 ethIntoLp, uint256 lpReceived) =  ROUTER.addLiquidityETH{value: msg.value}(\r\n            address(this),\r\n            tokensFromInvestor,\r\n            0,\r\n            0,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n\r\n        ethLpToken[msg.sender] += lpReceived;\r\n\r\n        if(msg.value > ethIntoLp) payable(msg.sender).transfer(msg.value - ethIntoLp);\r\n        if(tokensFromInvestor > tokensIntoLp) _lowGasTransfer(address(this), msg.sender, tokensFromInvestor - tokensIntoLp);\r\n    }\r\n\r\n    function removeLiquidityETH() public {\r\n        uint256 lpTokenToBeRemoved = ethLpToken[msg.sender];\r\n        ethLpToken[msg.sender] = 0;\r\n\r\n        IBEP20(pcsPair).approve(address(ROUTER), type(uint256).max);\r\n\r\n        (uint256 tokensFromLP, uint256 ethFromLP) = ROUTER.removeLiquidityETH(\r\n            address(this),\r\n            lpTokenToBeRemoved,\r\n            0,\r\n            0,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        _lowGasTransfer(address(this), msg.sender, tokensFromLP * (100 - lpFee) / 100);\r\n        payable(msg.sender).transfer(ethFromLP * (100 - lpFee) / 100);\r\n    }   \r\n\r\n    function addLiquidity(uint256 howMuch, address whatToken) public  {\r\n        \r\n        uint256 tokensFromInvestor = balanceOf(msg.sender);\r\n        _lowGasTransfer(msg.sender, address(this), tokensFromInvestor);\r\n\r\n        IBEP20(whatToken).approve(address(ROUTER), type(uint256).max);\r\n        IBEP20(whatToken).transferFrom(msg.sender, address(this),howMuch);\r\n        address liqPair = IDEXFactory(ROUTER.factory()).getPair(address(this),whatToken);\r\n        if(!isPair(liqPair)) pairs.push(liqPair); \r\n        isExludedFromMaxWallet[liqPair] = true;\r\n        addressNotGettingRewards[liqPair] = true;\r\n\r\n        (uint256 tokensIntoLp, uint256 liqTokenIntoLP, uint256 lpReceived) = ROUTER.addLiquidity(\r\n            address(this),\r\n            whatToken,\r\n            tokensFromInvestor,\r\n            howMuch,\r\n            0,\r\n            0,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        otherLpToken[msg.sender][whatToken] += lpReceived;\r\n\r\n        if(IBEP20(whatToken).balanceOf(address(this)) > 0) IBEP20(whatToken).transfer(msg.sender, howMuch - liqTokenIntoLP);\r\n        if(tokensFromInvestor > tokensIntoLp) _lowGasTransfer(address(this), msg.sender, tokensFromInvestor - tokensIntoLp);\r\n    }\r\n\r\n    function removeLiquidity(address whatToken) public {\r\n        uint256 lpTokenToBeRemoved = otherLpToken[msg.sender][whatToken];\r\n        otherLpToken[msg.sender][whatToken] = 0;\r\n\r\n        address liqPair = IDEXFactory(ROUTER.factory()).getPair(address(this),whatToken);\r\n        \r\n        IBEP20(liqPair).approve(address(ROUTER), type(uint256).max);\r\n\r\n        (uint256 tokensFromLP, uint256 liqTokenFromLP) = ROUTER.removeLiquidity(\r\n            address(this),\r\n            whatToken,\r\n            lpTokenToBeRemoved,\r\n            0,\r\n            0,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        _lowGasTransfer(address(this), msg.sender, tokensFromLP * (100 - lpFee) / 100);\r\n        IBEP20(whatToken).transfer(msg.sender,liqTokenFromLP * (100 - lpFee) / 100);\r\n    }\r\n\r\n    function isPair(address toCheck) public view returns (bool) {\r\n        address[] memory liqPairs = pairs;\r\n        for (uint256 i = 0; i < liqPairs.length; i++) if (toCheck == liqPairs[i]) return true;\r\n        return false;\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CEO\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROUTER\",\"outputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"howMuch\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"whatToken\",\"type\":\"address\"}],\"name\":\"addLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addLiquidityETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressNotGettingRewards\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ai\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"approveMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"frequency\",\"type\":\"uint256\"}],\"name\":\"changeJackpotFrequency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRewards\",\"type\":\"address\"}],\"name\":\"changeMainRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOutreachWallet\",\"type\":\"address\"}],\"name\":\"changeOutreachWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"desiredRewardToken\",\"type\":\"address\"}],\"name\":\"claimBnbPaired\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"claimExpert\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimNoSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ecosystem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enough\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"estate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ethLpToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"excludedWallet\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"excludeFromMax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"excludedWallet\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"excludeFromRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"shareholder\",\"type\":\"address\"}],\"name\":\"getUnpaidEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"isEnough\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isIt\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isExludedFromMaxWallet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"toCheck\",\"type\":\"address\"}],\"name\":\"isPair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isPaperhand\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"jackpot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"jackpotBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"jackpotFrequency\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"limitless\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liq\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mainReward\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWalletInPermille\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"otherLpToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"outreach\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"outreachWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pairs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pcsPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"whatToken\",\"type\":\"address\"}],\"name\":\"removeLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeLiquidityETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOnwrship\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounced\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rescueBnb\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rescueToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsPerShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aiWallet\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setAi\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"limitlessWallet\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setLimitlessWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"setLpFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"setMaxTxInPercentOfMaxWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"permille\",\"type\":\"uint256\"}],\"name\":\"setMaxWalletInPermille\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inWei\",\"type\":\"uint256\"}],\"name\":\"setMinBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"newSymbol\",\"type\":\"string\"}],\"name\":\"setNameAndSymbol\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardsTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liqTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outreachTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"estateTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ecosystemTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"jackpotTax\",\"type\":\"uint256\"}],\"name\":\"setTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"shareholderIndexes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"shares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalExcluded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRealised\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Safedrip", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://7c5631001c9bf4022834b9382ae73f6fcb3af98e7b704e040ac671e4b4f0671b"}