{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/StakePool/FarmBLB.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\n\\ninterface IBLBSwap {\\n    function BLBsForUSD(uint256 amountBUSD) external view returns(uint256);\\n    function BLBsForBNB(uint256 amountBNB) external view returns(uint256);\\n}\\n\\ncontract FarmBLB is Ownable, Pausable {\\n    using EnumerableSet for EnumerableSet.UintSet;\\n\\n    IERC20 public BUSD;\\n    IERC20 public BLB;\\n    IBLBSwap public BLBSwap;\\n\\n    uint256 public totalDepositBLB;\\n\\n    mapping(address => Investment[]) investments;\\n    mapping(address => mapping(uint256 => Payment[])) _investmentPayments;\\n\\n    Checkpoint checkpoint1;\\n    Checkpoint checkpoint2;\\n    Checkpoint checkpoint3;\\n\\n    struct InvestInfo {\\n        uint256 start;\\n        uint256 end;\\n        uint256 claimedMonth;\\n        uint256 claimedBLB;\\n        uint256 withdrawTime;\\n        uint256 amountBLB;\\n        uint256 amountUSD;\\n        uint256 monthId;\\n        uint256 monthlyProfitBLB;\\n        uint256 claimable;\\n    }\\n\\n    struct Payment {\\n        uint256 amountBLB;\\n        uint256 amountUSD;\\n        uint256 monthId;\\n        uint256 monthlyProfitBLB;\\n    }\\n\\n    struct Investment {\\n        uint256 start;\\n        uint256 end;\\n        uint256 claimedMonth;\\n        uint256 claimedBLB;\\n        uint256 withdrawTime;\\n    }\\n\\n    struct Checkpoint{\\n        uint256 passTime; //Percent\\n        uint256 saveDeposit; //Percent\\n        uint256 saveProfit; //Percent\\n    }\\n\\n    constructor(\\n        IERC20 _BUSD,\\n        IERC20 _BLB,\\n        address blbSwap,\\n        uint256[] memory _investPlanAmounts_,\\n        uint256[] memory _investPlanProfits_\\n    ) {\\n        BUSD = _BUSD;\\n        BLB = _BLB;\\n        BLBSwap = IBLBSwap(blbSwap);\\n        minStakeTime = 360 days;\\n\\n        setCheckpoints({\\n            passTime1 : 0 , saveDeposit1 : 80 , saveProfit1 : 0,\\n            passTime2 : 50, saveDeposit2 : 100, saveProfit2 : 0,\\n            passTime3 : 80, saveDeposit3 : 100, saveProfit3 : 40\\n        });\\n\\n        setInvestPlans(_investPlanAmounts_, _investPlanProfits_);\\n    }\\n\\n    function BLBsForUSD(uint256 amountBUSD) public view returns(uint256){\\n        return BLBSwap.BLBsForUSD(amountBUSD);\\n    }\\n\\n    function BLBsForBNB(uint256 amountBNB) external view returns(uint256){\\n        return BLBSwap.BLBsForBNB(amountBNB);\\n    }\\n\\n    function userInvestments(address investor) public view returns(\\n        InvestInfo[] memory _investments_\\n    ) {\\n        Investment[] memory _invests = investments[investor];\\n        uint256 len = investments[investor].length;\\n        _investments_ = new InvestInfo[](len);\\n        Payment memory _payment;\\n\\n        for (uint256 i; i < len; i++) {\\n            _payment = _investmentPayments[investor][i][_investmentPayments[investor][i].length - 1];\\n            _investments_[i] = InvestInfo(\\n                _invests[i].start,\\n                _invests[i].end,\\n                _invests[i].claimedMonth,\\n                _invests[i].claimedBLB,\\n                _invests[i].withdrawTime,\\n                _payment.amountBLB,\\n                _payment.amountUSD,\\n                _payment.monthId,\\n                _payment.monthlyProfitBLB,\\n                claimable(investor, i)\\n            );\\n        }\\n    }\\n\\n    function investmentPayments(address investor, uint256 investmentId) public view returns(Payment[] memory _payments_) {\\n        return _investmentPayments[investor][investmentId];\\n    }\\n\\n    function userTotalStake(address investor) public view returns(uint256 totalStake) {\\n        Investment[] storage invests = investments[investor];\\n        uint256 len = invests.length;\\n\\n        for(uint256 i; i < len; i++) {\\n            if(invests[i].withdrawTime == 0) {\\n                totalStake += _investmentPayments[investor][i][_investmentPayments[investor][i].length - 1].amountBLB;\\n            }\\n        }\\n    }\\n\\n    function userTotalStakeUSD(address investor) public view returns(uint256 totalStake) {\\n        Investment[] storage invests = investments[investor];\\n        uint256 len = invests.length;\\n\\n        for(uint256 i; i < len; i++) {\\n            if(invests[i].withdrawTime == 0) {\\n                totalStake += _investmentPayments[investor][i][_investmentPayments[investor][i].length - 1].amountUSD;\\n            }\\n        }\\n    }\\n\\n// investing in --------------------------------------------------------------------------------\\n\\n    function buyAndStake(uint256 amountBUSD) public payable whenNotPaused {\\n        uint256 duration = minStakeTime;\\n        address investor = msg.sender;\\n        uint256 amountBLB;\\n        uint256 amountUSD;\\n\\n        if(amountBUSD != 0) {\\n            require(msg.value == 0, \\\"not allowed to buy in BUSD and BNB in same time\\\");\\n            amountBLB = BLBSwap.BLBsForUSD(amountBUSD);\\n            amountUSD = amountBUSD;\\n            BUSD.transferFrom(investor, owner(), amountBUSD); \\n        } else {\\n            amountBLB = BLBSwap.BLBsForBNB(msg.value);\\n            amountUSD = amountBLB * 10 ** 18 / BLBSwap.BLBsForUSD(10 ** 18);\\n            payable(owner()).transfer(msg.value);\\n        }\\n\\n        uint256 start = block.timestamp;\\n        uint256 end = block.timestamp + duration;\\n        investments[investor].push(Investment(start, end, 0, 0, 0));\\n        _investmentPayments[investor][investments[investor].length - 1].push(Payment(amountBLB, amountUSD, 1, monthlyProfit(amountBLB, amountUSD)));\\n\\n        totalDepositBLB += amountBLB;\\n    }\\n\\n    function newInvestment(uint256 amountBLB) public whenNotPaused {\\n        uint256 duration = minStakeTime;\\n\\n        address investor = msg.sender;\\n        uint256 start = block.timestamp;\\n        uint256 end = block.timestamp + duration;\\n        uint256 amountUSD = amountBLB * 10 ** 18 / BLBSwap.BLBsForUSD(10 ** 18);\\n\\n        BLB.transferFrom(investor, address(this), amountBLB);\\n\\n\\n        investments[investor].push(Investment(start, end, 0, 0, 0));\\n        _investmentPayments[investor][investments[investor].length - 1].push(Payment(amountBLB, amountUSD, 1, monthlyProfit(amountBLB, amountUSD)));\\n\\n        totalDepositBLB += amountBLB;\\n    }\\n\\n    function topUpPayable(uint256 amountBUSD, uint256 investmentId) public payable whenNotPaused {\\n\\n        uint256 addingAmount;\\n        uint256 addingAmountUSD;\\n        address investor = msg.sender;\\n        uint256 currentTime = block.timestamp;\\n\\n        if(amountBUSD != 0) {\\n            require(msg.value == 0, \\\"not allowed to topUp in BUSD and BNB in same time\\\");\\n            addingAmount = BLBSwap.BLBsForUSD(amountBUSD);\\n            addingAmountUSD = amountBUSD;\\n            BUSD.transferFrom(investor, owner(), amountBUSD); \\n        } else {\\n            addingAmount = BLBSwap.BLBsForBNB(msg.value);\\n            addingAmountUSD = addingAmount * 10 ** 18 / BLBSwap.BLBsForUSD(10 ** 18);\\n            payable(owner()).transfer(msg.value);\\n        }\\n\\n        Investment memory investment = investments[investor][investmentId];\\n        Payment memory lastPayment = _investmentPayments[investor][investmentId][_investmentPayments[investor][investmentId].length - 1];\\n\\n        require(investment.withdrawTime == 0, \\\"investment ended\\\");\\n\\n        uint256 profitMonth = (currentTime - investment.start) / 30 days + 2;\\n        uint256 totalAmountBLB = lastPayment.amountBLB + addingAmount;\\n        uint256 totalAmountUSD = lastPayment.amountUSD + addingAmountUSD;\\n        _investmentPayments[investor][investmentId].push(Payment(\\n            totalAmountBLB, \\n            totalAmountUSD, \\n            profitMonth,\\n            monthlyProfit(totalAmountBLB, totalAmountUSD)\\n        ));\\n\\n        totalDepositBLB += addingAmount;\\n    }\\n\\n    function topUp(uint256 addingAmount, uint256 investmentId) public whenNotPaused {\\n\\n        address investor = msg.sender;\\n        uint256 currentTime = block.timestamp;\\n        uint256 addingAmountUSD = addingAmount * 10 ** 18 / BLBSwap.BLBsForUSD(10 ** 18);\\n\\n        Investment memory investment = investments[investor][investmentId];\\n        Payment memory lastPayment = _investmentPayments[investor][investmentId][_investmentPayments[investor][investmentId].length - 1];\\n        require(investment.withdrawTime == 0, \\\"investment ended\\\");\\n\\n        BLB.transferFrom(investor, address(this), addingAmount);\\n\\n        uint256 profitMonth = (currentTime - investment.start) / 30 days + 2;\\n        uint256 totalAmountBLB = lastPayment.amountBLB + addingAmount;\\n        uint256 totalAmountUSD = lastPayment.amountUSD + addingAmountUSD;\\n        _investmentPayments[investor][investmentId].push(Payment(\\n            totalAmountBLB, \\n            totalAmountUSD, \\n            profitMonth,\\n            monthlyProfit(totalAmountBLB, totalAmountUSD)\\n        ));\\n\\n        totalDepositBLB += addingAmount;\\n    }\\n\\n\\n// claiming ------------------------------------------------------------------------------------\\n\\n    function claimable(address investor, uint256 investmentId) public view returns(uint256 amountBLB) {\\n        require(investmentId < investments[investor].length, \\\"invalid investmentId\\\");\\n        \\n        Investment storage investment = investments[investor][investmentId];\\n        if(investment.withdrawTime != 0) {return 0;}\\n        uint256 currentTime = block.timestamp;\\n        uint256 pastMonths = (currentTime - investment.start) / 30 days;\\n        uint256 paidMonths = investment.claimedMonth;\\n\\n        uint256 payPlanId = _investmentPayments[investor][investmentId].length - 1;\\n        for(uint256 i = pastMonths; i > paidMonths; i--) {\\n            while(_investmentPayments[investor][investmentId][payPlanId].monthId > i) {\\n                payPlanId --;\\n            }\\n            amountBLB += _investmentPayments[investor][investmentId][payPlanId].monthlyProfitBLB;\\n        }\\n    }\\n\\n    function claimById(uint256 investmentId) public {\\n        address investor = msg.sender;\\n        uint256 amountBLB;\\n\\n        require(investmentId < investments[investor].length, \\\"invalid investmentId\\\");\\n        \\n        Investment storage investment = investments[investor][investmentId];\\n        require(investment.withdrawTime == 0, \\\"investment ended\\\");\\n        \\n        uint256 currentTime = block.timestamp;\\n        uint256 pastMonths = (currentTime - investment.start) / 30 days;\\n        uint256 paidMonths = investment.claimedMonth;\\n\\n        uint256 payPlanId = _investmentPayments[investor][investmentId].length - 1;\\n        for(uint256 i = pastMonths; i > paidMonths; i--) {\\n            while(_investmentPayments[investor][investmentId][payPlanId].monthId > i) {\\n                payPlanId --;\\n            }\\n            amountBLB += _investmentPayments[investor][investmentId][payPlanId].monthlyProfitBLB;\\n        }\\n        investment.claimedMonth = pastMonths;\\n        investment.claimedBLB += amountBLB;\\n\\n        BLB.transfer(investor, amountBLB);\\n    }\\n\\n// investing out --------------------------------------------------------------------------------\\n\\n    function releaseTime(\\n        address investor, \\n        uint256 investmentId\\n    ) public view returns(uint256) {\\n        return investments[investor][investmentId].end;\\n    }\\n\\n    function pendingWithdrawalById(\\n        address investor, \\n        uint256 investmentId\\n    ) public view returns(uint256) {\\n\\n        Investment storage investment = investments[investor][investmentId];\\n        Payment[] memory payments = _investmentPayments[investor][investmentId];\\n        Payment memory lastPayment = payments[payments.length - 1];\\n\\n        if(investment.withdrawTime != 0) {\\n            return 0;\\n        }\\n\\n        uint256 currentTime = block.timestamp;\\n        uint256 start = investment.start;\\n        uint256 end = investment.end; \\n        uint256 duration = investment.end - investment.start;\\n        uint256 monthRemaining = (duration / 30 days) - (currentTime - start) / 30 days - 1;\\n        uint256 totalDeposit = lastPayment.amountBLB; \\n        uint256 totalClaimed = investment.claimedBLB;\\n        uint256 totalProfit = investment.claimedBLB + monthRemaining * lastPayment.monthlyProfitBLB;\\n\\n        uint256 amountDeposit; \\n        uint256 amountProfit; \\n\\n        if(\\n            currentTime >= end\\n        ){\\n            amountDeposit = totalDeposit;\\n            amountProfit = totalProfit;\\n        } else if(\\n            currentTime >= checkpoint3.passTime * duration /100 + start\\n        ){\\n            amountDeposit = totalDeposit * checkpoint3.saveDeposit / 100;\\n            amountProfit = totalProfit * checkpoint3.saveProfit / 100;\\n        } else if(\\n            currentTime >= checkpoint2.passTime * duration /100 + start\\n        ){\\n            amountDeposit = totalDeposit * checkpoint2.saveDeposit / 100;\\n            amountProfit = totalProfit * checkpoint2.saveProfit / 100;\\n        } else if(\\n            currentTime >= checkpoint1.passTime * duration /100 + start\\n        ){\\n            amountDeposit = totalDeposit * checkpoint1.saveDeposit / 100;\\n            amountProfit = totalProfit * checkpoint1.saveProfit / 100;\\n        }\\n\\n        uint256 totalAmount = amountDeposit + amountProfit;\\n\\n        return totalAmount > totalClaimed ? totalAmount - totalClaimed : 0;\\n    }\\n\\n    function pendingWithdrawal(\\n        address investor\\n    ) public view returns(uint256 total) {\\n\\n        uint256 len = investments[investor].length;\\n\\n        for(uint256 i; i < len; i++) {\\n            total += pendingWithdrawalById(investor, i);\\n        }\\n    }\\n\\n    function withdraw(uint256 investmentId) public {\\n        address investor = msg.sender;\\n\\n        require(investmentId < investments[investor].length, \\\"invalid investmentId\\\");\\n        Investment storage investment = investments[investor][investmentId];\\n\\n        claimById(investmentId);\\n        uint256 amount = pendingWithdrawalById(investor, investmentId);\\n\\n        require(amount > 0, \\\"StakePool: nothing to withdraw\\\");\\n\\n        investment.withdrawTime = block.timestamp;\\n\\n        require(\\n            BLB.balanceOf(address(this)) > amount, \\n            \\\"insufficient BLB balance in the contract\\\"\\n        );\\n        BLB.transfer(investor, amount);\\n    }\\n\\n// profit plans ---------------------------------------------------------------------------------\\n    uint256[] _investPlanAmounts;\\n    uint256[] _investPlanProfits;\\n\\n    function setInvestPlans(\\n        uint256[] memory _investPlanAmounts_,\\n        uint256[] memory _investPlanProfits_\\n    ) public onlyOwner {\\n        uint256 len = _investPlanAmounts_.length;\\n        require(len ==_investPlanProfits_.length, \\\"arrays length must be same\\\");\\n        for(uint256 i = 1; i < len; i++) {\\n            require(\\n                _investPlanAmounts_[i] > _investPlanAmounts_[i-1],\\n                \\\"amounts must be increasing in a row\\\"\\n            );\\n            require(\\n                _investPlanProfits_[i] >= _investPlanProfits_[i-1],\\n                \\\"profits must be same or increasing in a row\\\"\\n            );\\n        }\\n        _investPlanAmounts = _investPlanAmounts_;\\n        _investPlanProfits = _investPlanProfits_;\\n    }\\n\\n    function plans() external view returns(\\n        uint256[] memory _investPlanAmounts_, \\n        uint256[] memory _investPlanProfits_  \\n    ) {\\n        _investPlanAmounts_ = _investPlanAmounts;\\n        _investPlanProfits_ = _investPlanProfits;\\n    }\\n\\n\\n// profit calculator -------------------------------------------------------------------\\n\\n    function monthlyProfit(uint256 amountBLB, uint256 amountUSD) public view returns(uint256 profitBLB) {\\n        uint256 len = _investPlanAmounts.length;\\n        for(uint256 i = len; i > 0; i--) {\\n            if(amountUSD >= _investPlanAmounts[i - 1]) {\\n                profitBLB = amountBLB * _investPlanProfits[i - 1]/10000;\\n                break;\\n            }\\n        }\\n        require(profitBLB != 0, \\\"no plan for this amount\\\");\\n    }\\n\\n// minStakeTime -------------------------------------------------------------------------\\n\\n    uint256 public minStakeTime;\\n    function setMinStakeTime(uint256 _minStakeTime) public onlyOwner {\\n        minStakeTime = _minStakeTime;\\n    }\\n\\n\\n// administration -----------------------------------------------------------------------\\n    \\n\\n    function checkpoints() public view returns(\\n        Checkpoint memory checkpoint1_, \\n        Checkpoint memory checkpoint2_, \\n        Checkpoint memory checkpoint3_\\n    ){\\n        checkpoint1_ = checkpoint1;\\n        checkpoint2_ = checkpoint2;\\n        checkpoint3_ = checkpoint3;\\n    }\\n\\n    function setCheckpoints(\\n        uint256 passTime1, uint256 saveDeposit1, uint256 saveProfit1,\\n        uint256 passTime2, uint256 saveDeposit2, uint256 saveProfit2,\\n        uint256 passTime3, uint256 saveDeposit3, uint256 saveProfit3\\n    ) public onlyOwner {\\n        require(\\n            passTime1 < passTime2 && passTime2 < passTime3, \\n            \\\"Pass Times must be increasing in a row\\\"\\n        );\\n        require(\\n            saveDeposit1 <= saveDeposit2 && saveDeposit2 <= saveDeposit3, \\n            \\\"Pass Times must be same or increasing in a row\\\"\\n        );\\n        require(\\n            saveProfit1 <= saveProfit2 && saveProfit2 <= saveProfit3, \\n            \\\"Pass Times must be same or increasing in a row\\\"\\n        );\\n        checkpoint1 = Checkpoint(passTime1, saveDeposit1, saveProfit1);\\n        checkpoint2 = Checkpoint(passTime2, saveDeposit2, saveProfit2);\\n        checkpoint3 = Checkpoint(passTime3, saveDeposit3, saveProfit3);\\n    }\\n\\n    function loanBLB(address borrower, uint256 amount) public onlyOwner {\\n        BLB.transfer(borrower, amount);\\n    }\\n\\n    function pause() public onlyOwner {\\n        _pause();\\n    }\\n\\n    function unpause() public onlyOwner {\\n        _unpause();\\n    }\\n\\n    function changeBLBSwap(address _BLBSwap) public onlyOwner {\\n        BLBSwap = IBLBSwap(_BLBSwap);\\n    }\\n\\n    function pay(\\n        address user,\\n        uint256 amount\\n    ) external {\\n        BLB.transferFrom(msg.sender, user, amount);\\n    }\\n\\n    function payBatch(\\n        address[] calldata users,\\n        uint256[] calldata amounts\\n    ) external {\\n        uint256 len = users.length;\\n        require(len == amounts.length, \\\"Lists must be same in length\\\");\\n        address from = msg.sender;\\n        for(uint256 i; i < len; i++) {\\n            BLB.transferFrom(from, users[i], amounts[i]);\\n        }\\n    }\\n\\n    function payToOwner(uint256 amountBUSD) public payable {\\n\\n        if(amountBUSD != 0) {\\n            require(msg.value == 0, \\\"not allowed to buy in BUSD and BNB in same time\\\");\\n            BUSD.transferFrom(msg.sender, owner(), amountBUSD); \\n        } else {\\n            payable(owner()).transfer(msg.value);\\n        }\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableSet.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.\\n *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n *  In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        return _values(set._inner);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_BUSD\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_BLB\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"blbSwap\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_investPlanAmounts_\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_investPlanProfits_\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BLB\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BLBSwap\",\"outputs\":[{\"internalType\":\"contract IBLBSwap\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountBNB\",\"type\":\"uint256\"}],\"name\":\"BLBsForBNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountBUSD\",\"type\":\"uint256\"}],\"name\":\"BLBsForUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BUSD\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountBUSD\",\"type\":\"uint256\"}],\"name\":\"buyAndStake\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_BLBSwap\",\"type\":\"address\"}],\"name\":\"changeBLBSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkpoints\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"passTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"saveDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"saveProfit\",\"type\":\"uint256\"}],\"internalType\":\"struct FarmBLB.Checkpoint\",\"name\":\"checkpoint1_\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"passTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"saveDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"saveProfit\",\"type\":\"uint256\"}],\"internalType\":\"struct FarmBLB.Checkpoint\",\"name\":\"checkpoint2_\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"passTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"saveDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"saveProfit\",\"type\":\"uint256\"}],\"internalType\":\"struct FarmBLB.Checkpoint\",\"name\":\"checkpoint3_\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"investmentId\",\"type\":\"uint256\"}],\"name\":\"claimById\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"investor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"investmentId\",\"type\":\"uint256\"}],\"name\":\"claimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountBLB\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"investor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"investmentId\",\"type\":\"uint256\"}],\"name\":\"investmentPayments\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountBLB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountUSD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"monthId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"monthlyProfitBLB\",\"type\":\"uint256\"}],\"internalType\":\"struct FarmBLB.Payment[]\",\"name\":\"_payments_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"loanBLB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minStakeTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountBLB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountUSD\",\"type\":\"uint256\"}],\"name\":\"monthlyProfit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"profitBLB\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountBLB\",\"type\":\"uint256\"}],\"name\":\"newInvestment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"pay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"payBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountBUSD\",\"type\":\"uint256\"}],\"name\":\"payToOwner\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"pendingWithdrawal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"investor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"investmentId\",\"type\":\"uint256\"}],\"name\":\"pendingWithdrawalById\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"plans\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_investPlanAmounts_\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_investPlanProfits_\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"investor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"investmentId\",\"type\":\"uint256\"}],\"name\":\"releaseTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"passTime1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"saveDeposit1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"saveProfit1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"passTime2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"saveDeposit2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"saveProfit2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"passTime3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"saveDeposit3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"saveProfit3\",\"type\":\"uint256\"}],\"name\":\"setCheckpoints\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_investPlanAmounts_\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_investPlanProfits_\",\"type\":\"uint256[]\"}],\"name\":\"setInvestPlans\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minStakeTime\",\"type\":\"uint256\"}],\"name\":\"setMinStakeTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"addingAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investmentId\",\"type\":\"uint256\"}],\"name\":\"topUp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountBUSD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investmentId\",\"type\":\"uint256\"}],\"name\":\"topUpPayable\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDepositBLB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"userInvestments\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedMonth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedBLB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBLB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountUSD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"monthId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"monthlyProfitBLB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimable\",\"type\":\"uint256\"}],\"internalType\":\"struct FarmBLB.InvestInfo[]\",\"name\":\"_investments_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"userTotalStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalStake\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"userTotalStakeUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalStake\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"investmentId\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "FarmBLB", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000e9e7cea3dedca5984780bafc599bd69add087d5600000000000000000000000013d67fd10bdbe8301e978e4adcbd2c0ad26f7549000000000000000000000000f3516758a3d6ac6d9182e86b069bcac132e0d79000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000056bc75e2d6310000000000000000000000000000000000000000000000000001b1ae4d6e2ef50000000000000000000000000000000000000000000000000003635c9adc5dea0000000000000000000000000000000000000000000000000010f0cf064dd592000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000015e00000000000000000000000000000000000000000000000000000000000001c2000000000000000000000000000000000000000000000000000000000000025800000000000000000000000000000000000000000000000000000000000002ee", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}