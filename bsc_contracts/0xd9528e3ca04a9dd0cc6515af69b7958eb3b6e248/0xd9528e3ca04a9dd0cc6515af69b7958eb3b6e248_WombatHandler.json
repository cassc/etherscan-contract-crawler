{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorInterface {\\n  function latestAnswer() external view returns (int256);\\n\\n  function latestTimestamp() external view returns (uint256);\\n\\n  function latestRound() external view returns (uint256);\\n\\n  function getAnswer(uint256 roundId) external view returns (int256);\\n\\n  function getTimestamp(uint256 roundId) external view returns (uint256);\\n\\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\\n\\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AggregatorInterface.sol\\\";\\nimport \\\"./AggregatorV3Interface.sol\\\";\\n\\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-4.8.2/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-4.8.2/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable-4.3.2/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@uniswap/lib/contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.6.0;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            'TransferHelper::safeApprove: approve failed'\\n        );\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            'TransferHelper::safeTransfer: transfer failed'\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            'TransferHelper::transferFrom: transferFrom failed'\\n        );\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/FunctionParameters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.16;\\n\\nlibrary FunctionParameters {\\n  /**\\n   * @notice Struct having the init data for a new IndexFactory creation\\n   * @param _indexSwapLibrary Address of the base IndexSwapLibrary\\n   * @param _baseIndexSwapAddress Address of the base IndexSwap\\n   * @param _baseRebalancingAddres Address of the base Rebalancing module\\n   * @param _baseOffChainRebalancingAddress Address of the base Offchain-Rebalance module\\n   * @param _baseRebalanceAggregatorAddress Address of the base Rebalance Aggregator module\\n   * @param _baseExchangeHandlerAddress Address of the base Exchange Handler\\n   * @param _baseAssetManagerConfigAddress Address of the baes AssetManager Config address\\n   * @param _baseOffChainIndexSwapAddress Address of the base Offchain-IndexSwap module\\n   * @param _feeModuleImplementationAddress Address of the base Fee Module implementation\\n   * @param _baseVelvetGnosisSafeModuleAddress Address of the base Gnosis-Safe module\\n   * @param _gnosisSingleton Address of the Gnosis Singleton\\n   * @param _gnosisFallbackLibrary Address of the Gnosis Fallback Library\\n   * @param _gnosisMultisendLibrary Address of the Gnosis Multisend Library\\n   * @param _gnosisSafeProxyFactory Address of the Gnosis Safe Proxy Factory\\n   * @param _priceOracle Address of the base Price Oracle to be used\\n   * @param _tokenRegistry Address of the Token Registry to be used\\n   * @param _velvetProtocolFee Fee cut that is being charged (eg: 25% of the fees)\\n   */\\n  struct IndexFactoryInitData {\\n    address _indexSwapLibrary;\\n    address _baseIndexSwapAddress;\\n    address _baseRebalancingAddres;\\n    address _baseOffChainRebalancingAddress;\\n    address _baseRebalanceAggregatorAddress;\\n    address _baseExchangeHandlerAddress;\\n    address _baseAssetManagerConfigAddress;\\n    address _baseOffChainIndexSwapAddress;\\n    address _feeModuleImplementationAddress;\\n    address _baseVelvetGnosisSafeModuleAddress;\\n    address _gnosisSingleton;\\n    address _gnosisFallbackLibrary;\\n    address _gnosisMultisendLibrary;\\n    address _gnosisSafeProxyFactory;\\n    address _priceOracle;\\n    address _tokenRegistry;\\n  }\\n\\n  /**\\n   * @notice Data passed from the Factory for the init of IndexSwap module\\n   * @param _name Name of the Index Fund\\n   * @param _symbol Symbol to represent the Index Fund\\n   * @param _vault Address of the Vault associated with that Index Fund\\n   * @param _module Address of the Safe module  associated with that Index Fund\\n   * @param _oracle Address of the Price Oracle associated with that Index Fund\\n   * @param _accessController Address of the Access Controller associated with that Index Fund\\n   * @param _tokenRegistry Address of the Token Registry associated with that Index Fund\\n   * @param _exchange Address of the Exchange Handler associated with that Index Fund\\n   * @param _iAssetManagerConfig Address of the Asset Manager Config associated with that Index Fund\\n   * @param _feeModule Address of the Fee Module associated with that Index Fund\\n   */\\n  struct IndexSwapInitData {\\n    string _name;\\n    string _symbol;\\n    address _vault;\\n    address _module;\\n    address _oracle;\\n    address _accessController;\\n    address _tokenRegistry;\\n    address _exchange;\\n    address _iAssetManagerConfig;\\n    address _feeModule;\\n  }\\n\\n  /**\\n   * @notice Struct used to pass data when a Token is swapped to ETH (native token) using the swap handler\\n   * @param _token Address of the token being swapped\\n   * @param _to Receiver address that is receiving the swapped result\\n   * @param _swapHandler Address of the swap handler being used for the swap\\n   * @param _swapAmount Amount of tokens to be swapped\\n   * @param _slippage Slippage allowed for the swap\\n   * @param _lpSlippage LP Slippage allowed for the swap\\n   */\\n  struct SwapTokenToETHData {\\n    address _token;\\n    address _to;\\n    address _swapHandler;\\n    uint256 _swapAmount;\\n    uint256 _slippage;\\n    uint256 _lpSlippage;\\n  }\\n\\n  /**\\n   * @notice Struct used to pass data when ETH (native token) is swapped to some other Token using the swap handler\\n   * @param _token Address of the token being swapped to\\n   * @param _to Receiver address that will receive the swapped tokens\\n   * @param _swapHandler Address of the swap handler being used for the swap\\n   * @param _toUser Address used to return the dust amount accumulated while investment/withdrawal\\n   * @param _slippage Slippage allowed for the swap\\n   * @param _lpSlippage LP Slippage allowed for the swap\\n   * @param _swapAmount Amount of tokens that is to be swapped\\n   */\\n  struct SwapETHToTokenData {\\n    address _token;\\n    address _to;\\n    address _swapHandler;\\n    address _toUser;\\n    uint256 _slippage;\\n    uint256 _lpSlippage;\\n    uint256 _swapAmount;\\n  }\\n\\n  /**\\n   * @notice Struct used to pass data when ETH (native token) is swapped to some other Token using the swap handler\\n   * @param _token Address of the token being swapped to\\n   * @param _to Receiver address that will receive the swapped tokens\\n   * @param _swapHandler Address of the swap handler being used for the swap\\n   * @param _toUser Address used to return the dust amount accumulated while investment/withdrawal\\n   * @param _slippage Slippage allowed for the swap\\n   * @param _lpSlippage LP Slippage allowed for the swap\\n   */\\n  struct SwapETHToTokenPublicData {\\n    address _token;\\n    address _to;\\n    address _swapHandler;\\n    address _toUser;\\n    uint256 _slippage;\\n    uint256 _lpSlippage;\\n  }\\n\\n  /**\\n   * @notice Struct used to pass data when a Token is swapped to another token using the swap handler\\n   * @param _tokenIn Address of the token being swapped from\\n   * @param _tokenOut Address of the token being swapped to\\n   * @param _to Receiver address that will receive the swapped tokens\\n   * @param _swapHandler Address of the swap handler being used for the swap\\n   * @param _toUser Address used to return the dust amount accumulated while investment/withdrawal\\n   * @param _swapAmount Amount of tokens that is to be swapped\\n   * @param _slippage Slippage allowed for the swap\\n   * @param _lpSlippage LP Slippage allowed for the swap\\n   * @param _isInvesting Boolean parameter indicating if the swap is being done during investment or withdrawal\\n   */\\n  struct SwapTokenToTokenData {\\n    address _tokenIn;\\n    address _tokenOut;\\n    address _to;\\n    address _swapHandler;\\n    address _toUser;\\n    uint256 _swapAmount;\\n    uint256 _slippage;\\n    uint256 _lpSlippage;\\n    bool _isInvesting;\\n  }\\n\\n  /**\\n   * @notice Struct having data for the swap of one token to another based on the input\\n   * @param _index Address of the IndexSwap associated with the swap tokens\\n   * @param _inputToken Address of the token being swapped from\\n   * @param _swapHandler Address of the swap handler being used\\n   * @param _toUser Address used to return the dust amount accumulated while investment/withdrawal\\n   * @param _tokenAmount Investment amount that is being distributed into all the portfolio tokens\\n   * @param _totalSupply Total supply of the Index tokens\\n   * @param amount The swap amount (in case totalSupply != 0) value calculated from the IndexSwapLibrary\\n   * @param _slippage Slippage for providing the liquidity\\n   * @param _lpSlippage LP Slippage for providing the liquidity\\n   */\\n  struct SwapTokenToTokensData {\\n    address _index;\\n    address _inputToken;\\n    address _swapHandler;\\n    address _toUser;\\n    uint256 _tokenAmount;\\n    uint256 _totalSupply;\\n    uint256[] amount;\\n    uint256[] _slippage;\\n    uint256[] _lpSlippage;\\n  }\\n\\n  /**\\n   * @notice Struct having the Offchain Investment data used for multiple functions\\n   * @param _offChainHandler Address of the off-chain handler being used\\n   * @param _buyAmount Array of amounts representing the distribution to all portfolio tokens; sum of this amount is the total investment amount\\n   * @param _buySwapData Array including the calldata which is required for the external swap handlers to swap (\\\"buy\\\") the portfolio tokens\\n   */\\n  struct ZeroExData {\\n    address _offChainHandler;\\n    uint256[] _buyAmount;\\n    bytes[] _buySwapData;\\n  }\\n\\n  /**\\n   * @notice Struct having the init data for a new Index Fund creation using the Factory\\n   * @param _assetManagerTreasury Address of the Asset Manager Treasury to be associated with the fund\\n   * @param _whitelistedTokens Array of tokens which limits the use of only those addresses as portfolio tokens in the fund\\n   * @param maxIndexInvestmentAmount Maximum Investment amount for the fund\\n   * @param maxIndexInvestmentAmount Minimum Investment amount for the fund\\n   * @param _managementFee Management fee (streaming fee) that the asset manager will receive for managing the fund\\n   * @param _performanceFee Fee that the asset manager will receive for managing the fund and if the portfolio performance well\\n   * @param _entryFee Entry fee for investing into the fund\\n   * @param _exitFee Exit fee for withdrawal from the fund\\n   * @param _public Boolean parameter for is the fund eligible for public investment or only some whitelist users can invest\\n   * @param _transferable Boolean parameter for is the Index tokens from the fund transferable or not\\n   * @param _transferableToPublic Boolean parameter for is the Index tokens from the fund transferable to public or only to whitelisted users\\n   * @param _whitelistTokens Boolean parameter which specifies if the asset manager can only choose portfolio tokens from the whitelisted array or not\\n   * @param name Name of the fund\\n   * @param symbol Symbol associated with the fund\\n   */\\n  struct IndexCreationInitData {\\n    address _assetManagerTreasury;\\n    address[] _whitelistedTokens;\\n    uint256 maxIndexInvestmentAmount;\\n    uint256 minIndexInvestmentAmount;\\n    uint256 _managementFee;\\n    uint256 _performanceFee;\\n    uint256 _entryFee;\\n    uint256 _exitFee;\\n    bool _public;\\n    bool _transferable;\\n    bool _transferableToPublic;\\n    bool _whitelistTokens;\\n    string name;\\n    string symbol;\\n  }\\n\\n  /**\\n   * @notice Struct having data for the Enable Rebalance (1st transaction) during ZeroEx's `Update Weight` call\\n   * @param _lpSlippage Array of LP Slippage values passed to the function\\n   * @param _newWeights Array of new weights for the rebalance\\n   */\\n  struct EnableRebalanceData {\\n    uint256[] _lpSlippage;\\n    uint96[] _newWeights;\\n  }\\n\\n  /**\\n   * @notice Struct having data for the init of Asset Manager Config\\n   * @param _managementFee Management fee (streaming fee) that the asset manager will receive for managing the fund\\n   * @param _performanceFee Fee that the asset manager will receive for managing the fund and if the portfolio performance well\\n   * @param _entryFee Entry fee associated with the config\\n   * @param _exitFee Exit fee associated with the config\\n   * @param _minInvestmentAmount Minimum investment amount specified as per the config\\n   * @param _maxInvestmentAmount Maximum investment amount specified as per the config\\n   * @param _tokenRegistry Address of the Token Registry associated with the config\\n   * @param _accessController Address of the Access Controller associated with the config\\n   * @param _assetManagerTreasury Address of the Asset Manager Treasury account\\n   * @param _whitelistTokens Boolean parameter which specifies if the asset manager can only choose portfolio tokens from the whitelisted array or not\\n   * @param _publicPortfolio Boolean parameter for is the portfolio eligible for public investment or not\\n   * @param _transferable Boolean parameter for is the Index tokens from the fund transferable to public or not\\n   * @param _transferableToPublic Boolean parameter for is the Index tokens from the fund transferable to public or not\\n   * @param _whitelistTokens Boolean parameter for is the token whitelisting enabled for the fund or not\\n   */\\n  struct AssetManagerConfigInitData {\\n    uint256 _managementFee;\\n    uint256 _performanceFee;\\n    uint256 _entryFee;\\n    uint256 _exitFee;\\n    uint256 _minInvestmentAmount;\\n    uint256 _maxInvestmentAmount;\\n    address _tokenRegistry;\\n    address _accessController;\\n    address _assetManagerTreasury;\\n    address[] _whitelistedTokens;\\n    bool _publicPortfolio;\\n    bool _transferable;\\n    bool _transferableToPublic;\\n    bool _whitelistTokens;\\n  }\\n\\n  /**\\n   * @notice Struct with data passed during the withdrawal from the Index Fund\\n   * @param _slippage Array of Slippage values passed for the withdrawal\\n   * @param _lpSlippage Array of LP Slippage values passed for the withdrawal\\n   * @param tokenAmount Amount of the Index Tokens that is to be withdrawn\\n   * @param _swapHandler Address of the swap handler being used for the withdrawal process\\n   * @param _token Address of the token being withdrawn to (must be a primary token)\\n   * @param isMultiAsset Boolean parameter for is the withdrawal being done in portfolio tokens (multi-token) or in the native token\\n   */\\n  struct WithdrawFund {\\n    uint256[] _slippage;\\n    uint256[] _lpSlippage;\\n    uint256 tokenAmount;\\n    address _swapHandler;\\n    address _token;\\n    bool isMultiAsset;\\n  }\\n\\n  /**\\n   * @notice Struct with data passed during the investment into the Index Fund\\n   * @param _slippage Array of Slippage values passed for the investment\\n   * @param _lpSlippage Array of LP Slippage values passed for the deposit into LP protocols\\n   * @param _tokenAmount Amount of token being invested\\n   * @param _to Address that would receive the index tokens post successful investment\\n   * @param _swapHandler Address of the swap handler being used for the investment process\\n   * @param _token Address of the token being made investment in\\n   */\\n  struct InvestFund {\\n    uint256[] _slippage;\\n    uint256[] _lpSlippage;\\n    uint256 _tokenAmount;\\n    address _swapHandler;\\n    address _token;\\n  }\\n\\n  /**\\n   * @notice Struct passed with values for the updation of tokens via the Rebalancing module\\n   * @param tokens Array of the new tokens that is to be updated to \\n   * @param _swapHandler Address of the swap handler being used for the token update\\n   * @param denorms Denorms of the new tokens\\n   * @param _slippageSell Slippage allowed for the sale of tokens\\n   * @param _slippageBuy Slippage allowed for the purchase of tokens\\n   * @param _lpSlippageSell LP Slippage allowed for the sale of tokens\\n   * @param _lpSlippageBuy LP Slippage allowed for the purchase of tokens\\n   */\\n  struct UpdateTokens {\\n    address[] tokens;\\n    address _swapHandler;\\n    uint96[] denorms;\\n    uint256[] _slippageSell;\\n    uint256[] _slippageBuy;\\n    uint256[] _lpSlippageSell;\\n    uint256[] _lpSlippageBuy;\\n  }\\n\\n  /**\\n   * @notice Struct having data for the redeem of tokens using the handlers for different protocols\\n   * @param _amount Amount of protocol tokens to be redeemed using the handler\\n   * @param _lpSlippage LP Slippage allowed for the redeem process\\n   * @param _to Address that would receive the redeemed tokens\\n   * @param _yieldAsset Address of the protocol token that is being redeemed against\\n   * @param isWETH Boolean parameter for is the redeem being done for WETH (native token) or not\\n   */\\n  struct RedeemData {\\n    uint256 _amount;\\n    uint256 _lpSlippage;\\n    address _to;\\n    address _yieldAsset;\\n    bool isWETH;\\n  }\\n\\n  /**\\n   * @notice Struct having data for the setup of different roles during an Index Fund creation\\n   * @param _exchangeHandler Addresss of the Exchange handler for the fund\\n   * @param _index Address of the IndexSwap for the fund\\n   * @param _tokenRegistry Address of the Token Registry for the fund\\n   * @param _portfolioCreator Address of the account creating/deploying the portfolio\\n   * @param _rebalancing Address of the Rebalancing module for the fund\\n   * @param _offChainRebalancing Address of the Offchain-Rebalancing module for the fund\\n   * @param _rebalanceAggregator Address of the Rebalance Aggregator for the fund\\n   * @param _feeModule Address of the Fee Module for the fund\\n   * @param _offChainIndexSwap Address of the OffChain-IndexSwap for the fund\\n   */\\n  struct AccessSetup {\\n    address _exchangeHandler;\\n    address _index;\\n    address _tokenRegistry;\\n    address _portfolioCreator;\\n    address _rebalancing;\\n    address _offChainRebalancing;\\n    address _rebalanceAggregator;\\n    address _feeModule;\\n    address _offChainIndexSwap;\\n  }\\n}\"\r\n    },\r\n    \"contracts/handler/DustHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.16;\\n\\nimport {ISwapHandler} from \\\"../handler/ISwapHandler.sol\\\";\\nimport {TransferHelper} from \\\"@uniswap/lib/contracts/libraries/TransferHelper.sol\\\";\\nimport {IERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable-4.3.2/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport {ErrorLibrary} from \\\"../library/ErrorLibrary.sol\\\";\\n\\nabstract contract DustHandler {\\n  address public constant WETH = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\\n\\n  // after investment if we can't deposit everything we might have underlying tokens left, no need to deposit/redeem - only swap\\n  function _returnDust(address _token, address _to) internal {\\n    if (_token == WETH) {\\n      (bool success, ) = payable(_to).call{value: address(this).balance}(\\\"\\\");\\n      if (!success) revert ErrorLibrary.TransferFailed();\\n    } else {\\n      uint balance = IERC20Upgradeable(_token).balanceOf(address(this));\\n      TransferHelper.safeTransfer(_token, _to, balance);\\n    }\\n  }\\n}\"\r\n    },\r\n    \"contracts/handler/IHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\n// lend token\\n// redeem token\\n// claim token\\n// get token balance\\n// get underlying balance\\n\\npragma solidity 0.8.16;\\n\\nimport {FunctionParameters} from \\\"../FunctionParameters.sol\\\";\\n\\ninterface IHandler {\\n  function deposit(address, uint256[] memory, uint256, address, address) external payable returns (uint256);\\n\\n  function redeem(FunctionParameters.RedeemData calldata inputData) external;\\n\\n  function getTokenBalance(address, address) external view returns (uint256);\\n\\n  function getUnderlyingBalance(address, address) external returns (uint256[] memory);\\n\\n  function getUnderlying(address) external view returns (address[] memory);\\n\\n  function getRouterAddress() external view returns (address);\\n\\n  function encodeData(address t, uint256 _amount) external returns (bytes memory);\\n\\n  function getClaimTokenCalldata(address _alpacaToken, address _holder) external returns (bytes memory, address);\\n\\n  function getTokenBalanceUSD(address _tokenHolder, address t) external returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/handler/ISwapHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.16;\\n\\ninterface ISwapHandler {\\n  function getETH() external view returns (address);\\n\\n  function getSwapAddress(uint256 _swapAmount, address _t) external view returns (address);\\n\\n  function swapTokensToETH(uint256 _swapAmount, uint256 _slippage, address _t, address _to, bool isEnabled) external returns (uint256);\\n\\n  function swapETHToTokens(uint256 _slippage, address _t, address _to) external payable returns (uint256);\\n\\n  function swapTokenToTokens(\\n    uint256 _swapAmount,\\n    uint256 _slippage,\\n    address _tokenIn,\\n    address _tokenOut,\\n    address _to,\\n    bool isEnabled\\n  ) external returns (uint256 swapResult);\\n\\n  function getPathForETH(address crypto) external view returns (address[] memory);\\n\\n  function getPathForToken(address token) external view returns (address[] memory);\\n\\n  function getSlippage(\\n    uint256 _amount,\\n    uint256 _slippage,\\n    address[] memory path\\n  ) external view returns (uint256 minAmount);\\n}\"\r\n    },\r\n    \"contracts/handler/SlippageControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.16;\\n\\nimport {Ownable} from \\\"@openzeppelin/contracts-4.8.2/access/Ownable.sol\\\";\\n\\nimport {ErrorLibrary} from \\\"../library/ErrorLibrary.sol\\\";\\n\\n/*\\n  This contract is for LP slippage to protect the users of an imbalanced pool\\n */\\nabstract contract SlippageControl is Ownable {\\n  uint256 public maxSlippage;\\n\\n  uint256 public constant HUNDRED_PERCENT = 10_000;\\n\\n  event AddOrUpdateProtocolSlippage(uint256 _slippage);\\n\\n  /**\\n   * @notice This function updates/adds max slippage allowed\\n   */\\n  function addOrUpdateProtocolSlippage(uint256 _slippage) public onlyOwner {\\n    if (_slippage >= HUNDRED_PERCENT) {\\n      revert ErrorLibrary.IncorrectSlippageRange();\\n    }\\n    maxSlippage = _slippage;\\n    emit AddOrUpdateProtocolSlippage(_slippage);\\n  }\\n\\n  /**\\n   * @notice This function calculates slippage from the called protocol\\n   */\\n  function getSlippage(uint256 _amount, uint256 _lpSlippage) internal view returns (uint256 minAmount) {\\n    if (maxSlippage < _lpSlippage) {\\n      revert ErrorLibrary.InvalidLPSlippage();\\n    }\\n    minAmount = (_amount * (HUNDRED_PERCENT - _lpSlippage)) / (HUNDRED_PERCENT);\\n  }\\n\\n  /**\\n   * @notice This function validates liquidity slippage from the called protocol\\n   * @param _amountA The amount of tokenA used by the protocol\\n   * @param _amountB The amount of tokenB used by the protocol\\n   * @param _priceA The price of tokenA\\n   * @param _priceB The price of tokenB\\n   * @param _lpSlippage The max slippage between tokenA and tokenB accepted\\n   */\\n  function _validateLPSlippage(\\n    uint _amountA,\\n    uint _amountB,\\n    uint _priceA,\\n    uint _priceB,\\n    uint _lpSlippage\\n  ) internal view {\\n    if (maxSlippage < _lpSlippage) {\\n      revert ErrorLibrary.InvalidLPSlippage();\\n    }\\n    uint decimal = 10 ** 18;\\n    /**\\n     *  amountA * priceA = amountB * priceB ( in ideal scenario )\\n     *  amountA/amountB - priceB/priceA = 0\\n     *  When the amount of either token is not fully accepted then the\\n     *  amountA and amountB wont be equal to 0 and that becomes our lpSlippage\\n     */\\n\\n    uint amountDivision = (_amountA * decimal) / (_amountB); // 18 decimals \\n    uint priceDivision = (_priceB * decimal) / (_priceA); // 18 decimals\\n    uint absoluteValue = 0;\\n    if (amountDivision > priceDivision) {\\n      absoluteValue = amountDivision - priceDivision; // 18 decimals\\n    } else {\\n      absoluteValue = priceDivision - amountDivision; // 18 decimals\\n    }\\n    uint256 percentageDifference = (absoluteValue * decimal) / priceDivision;\\n    if (percentageDifference * HUNDRED_PERCENT > (_lpSlippage * decimal)) {\\n      revert ErrorLibrary.InvalidAmount();\\n    }\\n  }\\n}\"\r\n    },\r\n    \"contracts/handler/Wombat/interfaces/IAsset.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.16;\\n\\ninterface IAsset {\\n  function pool() external view returns (address);\\n\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  function transfer(address dst, uint256 amount) external returns (bool);\\n\\n  function transferFrom(address src, address dst, uint256 amount) external returns (bool);\\n\\n  function decimals() external view returns (uint8);\\n\\n  function balanceOf(address owner) external view returns (uint256);\\n\\n  function underlyingTokenBalance() external view returns (uint256);\\n\\n  function underlyingToken() external view returns (address);\\n\\n  function totalSupply() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/handler/Wombat/interfaces/IPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.16;\\n\\ninterface IPool {\\n  function deposit(\\n    address token,\\n    uint256 amount,\\n    uint256 minimumLiquidity,\\n    address to,\\n    uint256 deadline,\\n    bool shouldStake\\n  ) external returns (uint256 liquidity);\\n\\n  function withdraw(\\n    address token,\\n    uint256 liquidity,\\n    uint256 minimumAmount,\\n    address to,\\n    uint256 deadline\\n  ) external returns (uint256 amount);\\n\\n  function quotePotentialWithdraw(address token, uint256 liquidity) external returns (uint256 amount, uint256 fee);\\n\\n  function quotePotentialDeposit(address token, uint256 liquidity) external returns (uint256 amount, uint256 fee);\\n}\\n\"\r\n    },\r\n    \"contracts/handler/Wombat/interfaces/IWombat.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity 0.8.16;\\n\\nlibrary StructLib {\\n  // Struct of main contract A\\n  struct UserInfo {\\n    uint128 amount;\\n    uint128 factor;\\n    uint128 rewardDebt;\\n    uint128 pendingWom;\\n  }\\n}\\n\\ninterface IWombat {\\n  function withdraw(uint256 _pid, uint256 _amount) external returns (uint256, uint256[] memory);\\n\\n  function getAssetPid(address asset) external view returns (uint256);\\n\\n  function userInfo(uint256 pid, address owner) external view returns (StructLib.UserInfo memory);\\n\\n  function deposit(uint256 _pid, uint256 _amount) external;\\n\\n  //0xE2C07d20AF0Fb50CAE6cDD615CA44AbaAA31F9c8\\n}\\n\"\r\n    },\r\n    \"contracts/handler/Wombat/interfaces/IWombatRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.16;\\n\\nimport {IPool} from \\\"./IPool.sol\\\";\\n\\ninterface IWombatRouter {\\n  function addLiquidityNative(\\n    IPool pool,\\n    uint256 minimumLiquidity,\\n    address to,\\n    uint256 deadline,\\n    bool shouldStake\\n  ) external payable returns (uint256 liquidity);\\n\\n  function removeLiquidityNative(\\n    IPool pool,\\n    uint256 liquidity,\\n    uint256 minimumAmount,\\n    address to,\\n    uint256 deadline\\n  ) external returns (uint256 amount);\\n}\\n\"\r\n    },\r\n    \"contracts/handler/Wombat/WombatHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\n// Wombat Official Docs: https://docs.wombat.exchange/docs/\\n// Wombat GitHub: https://github.com/wombat-exchange\\n\\n/**\\n * @title Handler for the Wombat's staking protocol\\n * @author Velvet.Capital\\n * @notice This contract is used to stake tokens\\n *      to/from the Wombat protocol.\\n * @dev This contract includes functionalities:\\n *      1. Stake tokens to the Wombat protocol\\n *      2. Redeem staked tokens from the Wombat protocol\\n *      3. Get underlying asset address\\n *      4. Get protocol token balance\\n *      5. Get underlying asset balance\\n */\\n\\npragma solidity 0.8.16;\\n\\nimport {IERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable-4.3.2/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport {TransferHelper} from \\\"@uniswap/lib/contracts/libraries/TransferHelper.sol\\\";\\nimport {IAsset} from \\\"./interfaces/IAsset.sol\\\";\\nimport {IPool} from \\\"./interfaces/IPool.sol\\\";\\nimport {IWombat, StructLib} from \\\"./interfaces/IWombat.sol\\\";\\nimport {IWombatRouter} from \\\"./interfaces/IWombatRouter.sol\\\";\\nimport {IPriceOracle} from \\\"../../oracle/IPriceOracle.sol\\\";\\nimport {IHandler} from \\\"../IHandler.sol\\\";\\nimport {ErrorLibrary} from \\\"./../../library/ErrorLibrary.sol\\\";\\nimport {SlippageControl} from \\\"../SlippageControl.sol\\\";\\nimport {FunctionParameters} from \\\"contracts/FunctionParameters.sol\\\";\\n\\nimport {DustHandler} from \\\"../DustHandler.sol\\\";\\n\\ncontract WombatHandler is IHandler, SlippageControl, DustHandler {\\n  address internal constant WOMBAT_OPTIMIZED_PROXY = 0x489833311676B566f888119c29bd997Dc6C95830;\\n  IWombat internal MasterWombat = IWombat(WOMBAT_OPTIMIZED_PROXY);\\n\\n  address internal constant WOMBAT_ROUTER = 0x19609B03C976CCA288fbDae5c21d4290e9a4aDD7;\\n\\n  IPriceOracle internal _oracle;\\n\\n  event Deposit(address indexed user, address indexed token, uint256[] amounts, address indexed to);\\n  event Redeem(\\n    address indexed user,\\n    address indexed token,\\n    uint256 amount,\\n    address indexed to,\\n    bool isWETH\\n  );\\n\\n  constructor(address _priceOracle) {\\n    if(_priceOracle == address(0)){\\n      revert ErrorLibrary.InvalidAddress();\\n    }\\n    _oracle = IPriceOracle(_priceOracle);\\n  }\\n\\n  /**\\n   * @notice This function stakes to the Wombat protocol\\n   * @param _lpAsset Address of the protocol asset to be staked\\n   * @param _amount Amount that is to be deposited\\n   * @param _lpSlippage LP slippage value passed to the function\\n   * @param _to Address that would receive the cTokens in return\\n   */\\n  function deposit(\\n    address _lpAsset,\\n    uint256[] calldata _amount,\\n    uint256 _lpSlippage,\\n    address _to,\\n    address user\\n  ) public payable override returns (uint256 _mintedAmount) {\\n    if (_lpAsset == address(0) || _to == address(0)) {\\n      revert ErrorLibrary.InvalidAddress();\\n    }\\n    IAsset asset = IAsset(_lpAsset);\\n    IERC20Upgradeable underlyingToken = IERC20Upgradeable(getUnderlying(_lpAsset)[0]);\\n    IPool _pool = IPool(asset.pool());\\n\\n    if (msg.value == 0) {\\n      TransferHelper.safeApprove(address(underlyingToken), address(_pool), 0);\\n      TransferHelper.safeApprove(address(underlyingToken), address(_pool), _amount[0]);\\n      _mintedAmount = _pool.deposit(\\n        address(underlyingToken),\\n        _amount[0],\\n        getInternalSlippage(_amount[0], _lpAsset, _lpSlippage, true),\\n        _to,\\n        block.timestamp,\\n        true\\n      );\\n    } else {\\n      if (msg.value < _amount[0]) {\\n        revert ErrorLibrary.MintAmountNotEqualToPassedValue();\\n      }\\n      if (address(underlyingToken) != _oracle.WETH()) revert ErrorLibrary.TokenNotETH();\\n      _mintedAmount = IWombatRouter(WOMBAT_ROUTER).addLiquidityNative{value: _amount[0]}(\\n        _pool,\\n        getInternalSlippage(_amount[0], _lpAsset, _lpSlippage, true),\\n        _to,\\n        block.timestamp,\\n        true\\n      );\\n    }\\n\\n    _returnDust(address(underlyingToken), user);\\n\\n    emit Deposit(msg.sender, _lpAsset, _amount, _to);\\n\\n    (uint256 _potentialWithdrawalAmount, ) = _pool.quotePotentialWithdraw(address(underlyingToken), _mintedAmount);\\n    _mintedAmount = _oracle.getPriceTokenUSD18Decimals(address(underlyingToken), _potentialWithdrawalAmount);\\n  }\\n\\n  /**\\n   * @notice This function redeems the staked tokens from the Wombat protocol\\n   */\\n  function redeem(FunctionParameters.RedeemData calldata inputData) public override {\\n    if (inputData._yieldAsset == address(0) || inputData._to == address(0)) {\\n      revert ErrorLibrary.InvalidAddress();\\n    }\\n    IAsset token = IAsset(inputData._yieldAsset);\\n    IERC20Upgradeable underlyingToken = IERC20Upgradeable(getUnderlying(inputData._yieldAsset)[0]);\\n    if (inputData._amount > token.balanceOf(address(this))) {\\n      revert ErrorLibrary.NotEnoughBalanceInWombatProtocol();\\n    }\\n    IPool _pool = IPool(token.pool());\\n    if (!inputData.isWETH) {\\n      TransferHelper.safeApprove(address(token), address(_pool), 0);\\n      TransferHelper.safeApprove(address(token), address(_pool), inputData._amount);\\n\\n      _pool.withdraw(\\n        address(underlyingToken),\\n        inputData._amount,\\n        getInternalSlippage(inputData._amount, inputData._yieldAsset, inputData._lpSlippage, false),\\n        inputData._to,\\n        block.timestamp\\n      );\\n    } else {\\n      TransferHelper.safeApprove(address(token), address(WOMBAT_ROUTER), 0);\\n      TransferHelper.safeApprove(address(token), address(WOMBAT_ROUTER), inputData._amount);\\n\\n      IWombatRouter(WOMBAT_ROUTER).removeLiquidityNative(\\n        _pool,\\n        inputData._amount,\\n        getInternalSlippage(inputData._amount, inputData._yieldAsset, inputData._lpSlippage, false),\\n        inputData._to,\\n        block.timestamp\\n      );\\n    }\\n    emit Redeem(msg.sender, inputData._yieldAsset, inputData._amount, inputData._to, inputData.isWETH);\\n  }\\n\\n  /**\\n   * @notice This function returns address of the underlying asset\\n   * @param _lpToken Address of the protocol token whose underlying asset is needed\\n   * @return underlying Address of the underlying asset\\n   */\\n  function getUnderlying(address _lpToken) public view override returns (address[] memory) {\\n    if (_lpToken == address(0)) {\\n      revert ErrorLibrary.InvalidAddress();\\n    }\\n    address[] memory underlying = new address[](1);\\n    IAsset token = IAsset(_lpToken);\\n    underlying[0] = token.underlyingToken();\\n    return underlying;\\n  }\\n\\n  /**\\n   * @notice This function returns the protocol token balance of the passed address\\n   * @param _tokenHolder Address whose balance is to be retrieved\\n   * @param t Address of the protocol token\\n   * @return tokenBalance t token balance of the holder\\n   */\\n  function getTokenBalance(address _tokenHolder, address t) public view override returns (uint256 tokenBalance) {\\n    if (_tokenHolder == address(0) || t == address(0)) {\\n      revert ErrorLibrary.InvalidAddress();\\n    }\\n    IAsset asset = IAsset(t);\\n    StructLib.UserInfo memory _amountStaked = MasterWombat.userInfo(\\n      MasterWombat.getAssetPid(address(asset)),\\n      _tokenHolder\\n    );\\n    tokenBalance = _amountStaked.amount;\\n  }\\n\\n  /**\\n   * @notice This function returns the underlying asset balance of the passed address\\n   * @param _tokenHolder Address whose balance is to be retrieved\\n   * @param t Address of the protocol token\\n   * @return tokenBalance t token's underlying asset balance of the holder\\n   */\\n  function getUnderlyingBalance(address _tokenHolder, address t) public override returns (uint256[] memory) {\\n    if (_tokenHolder == address(0) || t == address(0)) {\\n      revert ErrorLibrary.InvalidAddress();\\n    }\\n    uint256[] memory tokenBalance = new uint256[](1);\\n    uint256 yieldTokenBalance = getTokenBalance(_tokenHolder, t);\\n    if (yieldTokenBalance != 0) {\\n      (tokenBalance[0], ) = IPool(IAsset(t).pool()).quotePotentialWithdraw(getUnderlying(t)[0], yieldTokenBalance);\\n    }\\n    return tokenBalance;\\n  }\\n\\n  /**\\n   * @notice This function returns the USD value of the LP asset using Fair LP Price model\\n   * @param _tokenHolder Address whose balance is to be retrieved\\n   * @param t Address of the protocol token\\n   */\\n  function getTokenBalanceUSD(address _tokenHolder, address t) public override returns (uint256) {\\n    if (t == address(0) || _tokenHolder == address(0)) {\\n      revert ErrorLibrary.InvalidAddress();\\n    }\\n    uint[] memory underlyingBalance = getUnderlyingBalance(_tokenHolder, t);\\n    address[] memory underlyingToken = getUnderlying(t);\\n\\n    uint balanceUSD = _oracle.getPriceTokenUSD18Decimals(underlyingToken[0], underlyingBalance[0]);\\n    return balanceUSD;\\n  }\\n\\n  function encodeData(address t, uint256 _amount) public view returns (bytes memory) {\\n    IAsset asset = IAsset(t);\\n    return abi.encodeWithSelector(IWombat.withdraw.selector, MasterWombat.getAssetPid(address(asset)), _amount);\\n  }\\n\\n  function getRouterAddress() public pure returns (address) {\\n    return WOMBAT_OPTIMIZED_PROXY;\\n  }\\n\\n  function getClaimTokenCalldata(address _token, address _holder) public view returns (bytes memory, address) {\\n    uint256 pid = MasterWombat.getAssetPid(address(_token));\\n    return (abi.encodeWithSelector(IWombat.deposit.selector, pid, 0), address(MasterWombat));\\n  }\\n\\n  /**\\n   * @notice This function returns the slippage required by the Wombat Handler\\n   * @param _amount This amount needed to be checked\\n   * @param _token Address of the token needed\\n   * @param _slippage Slippage required to be checked\\n   * @param _deposit Type of operation done here, can be deposit or redeem\\n   * @return slippageAmount amount calculated after slippage\\n   */\\n  function getInternalSlippage(\\n    uint _amount,\\n    address _token,\\n    uint _slippage,\\n    bool _deposit\\n  ) internal returns (uint slippageAmount) {\\n    IAsset asset = IAsset(_token);\\n    IERC20Upgradeable underlyingToken = IERC20Upgradeable(getUnderlying(_token)[0]);\\n    address pool = asset.pool();\\n    //Formula By Wombat For Slippage\\n    /**\\n     minAmount = liquidity * (1/1+slippage)\\n     */\\n    //Here 1 is 100%(For Velvet) as slippage denoted by wombat is 0.01 for 1%\\n    uint expectedAmount;\\n    if (_deposit) {\\n      (expectedAmount, ) = IPool(pool).quotePotentialDeposit(address(underlyingToken), _amount);\\n    } else {\\n      (expectedAmount, ) = IPool(pool).quotePotentialWithdraw(address(underlyingToken), _amount);\\n    }\\n    slippageAmount = (expectedAmount * HUNDRED_PERCENT ) / (HUNDRED_PERCENT + _slippage);\\n  }\\n\\n  receive() external payable {}\\n}\"\r\n    },\r\n    \"contracts/library/ErrorLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.16;\\n\\n/**\\n * @title ErrorLibrary\\n * @author Velvet.Capital\\n * @notice This is a library contract including custom defined errors\\n */\\n\\nlibrary ErrorLibrary {\\n  error ContractPaused();\\n  /// @notice Thrown when caller is not rebalancer contract\\n  error CallerNotRebalancerContract();\\n  /// @notice Thrown when caller is not asset manager\\n  error CallerNotAssetManager();\\n  /// @notice Thrown when caller is not asset manager\\n  error CallerNotSuperAdmin();\\n  /// @notice Thrown when caller is not whitelist manager\\n  error CallerNotWhitelistManager();\\n  /// @notice Thrown when length of slippage array is not equal to tokens array\\n  error InvalidSlippageLength();\\n  /// @notice Thrown when length of tokens array is zero\\n  error InvalidLength();\\n  /// @notice Thrown when token is not permitted\\n  error TokenNotPermitted();\\n  /// @notice Thrown when user is not allowed to invest\\n  error UserNotAllowedToInvest();\\n  /// @notice Thrown when index token in not initialized\\n  error NotInitialized();\\n  /// @notice Thrown when investment amount is greater than or less than the set range\\n  error WrongInvestmentAmount(uint256 minInvestment, uint256 maxInvestment);\\n  /// @notice Thrown when swap amount is greater than BNB balance of the contract\\n  error NotEnoughBNB();\\n  /// @notice Thrown when the total sum of weights is not equal to 10000\\n  error InvalidWeights(uint256 totalWeight);\\n  /// @notice Thrown when balance is below set velvet min investment amount\\n  error BalanceCantBeBelowVelvetMinInvestAmount(uint256 minVelvetInvestment);\\n  /// @notice Thrown when caller is not holding underlying token amount being swapped\\n  error CallerNotHavingGivenTokenAmount();\\n  /// @notice Thrown when length of denorms array is not equal to tokens array\\n  error InvalidInitInput();\\n  /// @notice Thrown when the tokens are already initialized\\n  error AlreadyInitialized();\\n  /// @notice Thrown when the token is not whitelisted\\n  error TokenNotWhitelisted();\\n  /// @notice Thrown when denorms array length is zero\\n  error InvalidDenorms();\\n  /// @notice Thrown when token address being passed is zero\\n  error InvalidTokenAddress();\\n  /// @notice Thrown when token is not permitted\\n  error InvalidToken();\\n  /// @notice Thrown when token is not approved\\n  error TokenNotApproved();\\n  /// @notice Thrown when transfer is prohibited\\n  error Transferprohibited();\\n  /// @notice Thrown when transaction caller balance is below than token amount being invested\\n  error LowBalance();\\n  /// @notice Thrown when address is already approved\\n  error AddressAlreadyApproved();\\n  /// @notice Thrown when swap handler is not enabled inside token registry\\n  error SwapHandlerNotEnabled();\\n  /// @notice Thrown when swap amount is zero\\n  error ZeroBalanceAmount();\\n  /// @notice Thrown when caller is not index manager\\n  error CallerNotIndexManager();\\n  /// @notice Thrown when caller is not fee module contract\\n  error CallerNotFeeModule();\\n  /// @notice Thrown when lp balance is zero\\n  error LpBalanceZero();\\n  /// @notice Thrown when desired swap amount is greater than token balance of this contract\\n  error InvalidAmount();\\n  /// @notice Thrown when the redeem amount is more than protocol balance\\n  error NotEnoughBalanceInAlpacaProtocol();\\n  /// @notice Thrown when the mint amount is not equal to token amount passed\\n  error MintAmountMustBeEqualToValue();\\n  /// @notice Thrown when the mint function returned 0 for success & 1 for failure\\n  error MintProcessFailed();\\n  /// @notice Thrown when the redeem amount is more than protocol balance\\n  error NotEnoughBalanceInApeSwap();\\n  /// @notice Thrown when the redeeming was success(0) or failure(1)\\n  error RedeemingCTokenFailed();\\n  /// @notice Thrown when native BNB is sent for any vault other than mooVenusBNB\\n  error PleaseDepositUnderlyingToken();\\n  /// @notice Thrown when redeem amount is greater than tokenBalance of protocol\\n  error NotEnoughBalanceInBeefyProtocol();\\n  /// @notice Thrown when the redeem amount is more than protocol balance\\n  error NotEnoughBalanceInBeefy();\\n  /// @notice Thrown when the deposit amount of underlying token A is more than contract balance\\n  error InsufficientTokenABalance();\\n  /// @notice Thrown when the deposit amount of underlying token B is more than contract balance\\n  error InsufficientTokenBBalance();\\n  /// @notice Thrown when the redeem amount is more than protocol balance\\n  error NotEnoughBalanceInBiSwapProtocol();\\n  //Not enough funds\\n  error InsufficientFunds(uint256 available, uint256 required);\\n  //Not enough eth for protocol fee\\n  error InsufficientFeeFunds(uint256 available, uint256 required);\\n  //Order success but amount 0\\n  error ZeroTokensSwapped();\\n  /// @notice Thrown when the redeem amount is more than protocol balance\\n  error NotEnoughBalanceInLiqeeProtocol();\\n  /// @notice Thrown when the mint amount is not equal to token amount passed\\n  error MintAmountMustBeEqualToValuePassed();\\n  /// @notice Thrown when the redeem amount is more than protocol balance\\n  error NotEnoughBalanceInPancakeProtocol();\\n  /// @notice Thrown when Pid passed is not equal to Pid stored in Pid map\\n  error InvalidPID();\\n  /// @notice Thrown when the redeem amount is more than protocol balance\\n  error InsufficientBalance();\\n  /// @notice Thrown when the redeem function returns 1 for fail & 0 for success\\n  error RedeemingFailed();\\n  /// @notice Thrown when the token passed in getUnderlying is not vToken\\n  error NotVToken();\\n  /// @notice Thrown when the redeem amount is more than protocol balance\\n  error NotEnoughBalanceInWombatProtocol();\\n  /// @notice Thrown when the mint amount is not equal to token amount passed\\n  error MintAmountNotEqualToPassedValue();\\n  /// @notice Thrown when slippage value passed is greater than 100\\n  error SlippageCannotBeGreaterThan100();\\n  /// @notice Thrown when tokens are already staked\\n  error TokensStaked();\\n  /// @notice Thrown when contract is not paused\\n  error ContractNotPaused();\\n  /// @notice Thrown when offchain handler is not valid\\n  error OffHandlerNotValid();\\n  /// @notice Thrown when offchain handler is not enabled\\n  error OffHandlerNotEnabled();\\n  /// @notice Thrown when swapHandler is not enabled\\n  error SwaphandlerNotEnabled();\\n  /// @notice Thrown when account other than asset manager calls\\n  error OnlyAssetManagerCanCall();\\n  /// @notice Thrown when already redeemed\\n  error AlreadyRedeemed();\\n  /// @notice Thrown when contract is not paused\\n  error NotPaused();\\n  /// @notice Thrown when token is not index token\\n  error TokenNotIndexToken();\\n  /// @notice Thrown when swaphandler is invalid\\n  error SwapHandlerNotValid();\\n  /// @notice Thrown when token that will be bought is invalid\\n  error BuyTokenAddressNotValid();\\n  /// @notice Thrown when not redeemed\\n  error NotRedeemed();\\n  /// @notice Thrown when caller is not asset manager\\n  error CallerIsNotAssetManager();\\n  /// @notice Thrown when account other than asset manager is trying to pause\\n  error OnlyAssetManagerCanCallUnpause();\\n  /// @notice Thrown when trying to redeem token that is not staked\\n  error TokensNotStaked();\\n  /// @notice Thrown when account other than asset manager is trying to revert or unpause\\n  error FifteenMinutesNotExcedeed();\\n  /// @notice Thrown when swapping weight is zero\\n  error WeightNotGreaterThan0();\\n  /// @notice Thrown when dividing by zero\\n  error DivBy0Sumweight();\\n  /// @notice Thrown when lengths of array are not equal\\n  error LengthsDontMatch();\\n  /// @notice Thrown when contract is not paused\\n  error ContractIsNotPaused();\\n  /// @notice Thrown when set time period is not over\\n  error TimePeriodNotOver();\\n  /// @notice Thrown when trying to set any fee greater than max allowed fee\\n  error InvalidFee();\\n  /// @notice Thrown when zero address is passed for treasury\\n  error ZeroAddressTreasury();\\n  /// @notice Thrown when assetManagerFee or performaceFee is set zero\\n  error ZeroFee();\\n  /// @notice Thrown when trying to enable an already enabled handler\\n  error HandlerAlreadyEnabled();\\n  /// @notice Thrown when trying to disable an already disabled handler\\n  error HandlerAlreadyDisabled();\\n  /// @notice Thrown when zero is passed as address for oracle address\\n  error InvalidOracleAddress();\\n  /// @notice Thrown when zero is passed as address for handler address\\n  error InvalidHandlerAddress();\\n  /// @notice Thrown when token is not in price oracle\\n  error TokenNotInPriceOracle();\\n  /// @notice Thrown when address is not approved\\n  error AddressNotApproved();\\n  /// @notice Thrown when minInvest amount passed is less than minInvest amount set\\n  error InvalidMinInvestmentAmount();\\n  /// @notice Thrown when maxInvest amount passed is greater than minInvest amount set\\n  error InvalidMaxInvestmentAmount();\\n  /// @notice Thrown when zero address is being passed\\n  error InvalidAddress();\\n  /// @notice Thrown when caller is not the owner\\n  error CallerNotOwner();\\n  /// @notice Thrown when out asset address is zero\\n  error InvalidOutAsset();\\n  /// @notice Thrown when protocol is not paused\\n  error ProtocolNotPaused();\\n  /// @notice Thrown when protocol is paused\\n  error ProtocolIsPaused();\\n  /// @notice Thrown when proxy implementation is wrong\\n  error ImplementationNotCorrect();\\n  /// @notice Thrown when caller is not offChain contract\\n  error CallerNotOffChainContract();\\n  /// @notice Thrown when user has already redeemed tokens\\n  error TokenAlreadyRedeemed();\\n  /// @notice Thrown when user has not redeemed tokens\\n  error TokensNotRedeemed();\\n  /// @notice Thrown when user has entered wrong amount\\n  error InvalidSellAmount();\\n  /// @notice Thrown when trasnfer fails\\n  error WithdrawTransferFailed();\\n  /// @notice Thrown when caller is not having minter role\\n  error CallerNotMinter();\\n  /// @notice Thrown when caller is not handler contract\\n  error CallerNotHandlerContract();\\n  /// @notice Thrown when token is not enabled\\n  error TokenNotEnabled();\\n  /// @notice Thrown when index creation is paused\\n  error IndexCreationIsPause();\\n  /// @notice Thrown denorm value sent is zero\\n  error ZeroDenormValue();\\n  /// @notice Thrown when asset manager is trying to input token which already exist\\n  error TokenAlreadyExist();\\n  /// @notice Thrown when cool down period is not passed\\n  error CoolDownPeriodNotPassed();\\n  /// @notice Thrown When Buy And Sell Token Are Same\\n  error BuyAndSellTokenAreSame();\\n  /// @notice Throws arrow when token is not a reward token\\n  error NotRewardToken();\\n  /// @notice Throws arrow when MetaAggregator Swap Failed\\n  error SwapFailed();\\n  /// @notice Throws arrow when Token is Not  Primary\\n  error NotPrimaryToken();\\n  /// @notice Throws when the setup is failed in gnosis\\n  error ModuleNotInitialised();\\n  /// @notice Throws when threshold is more than owner length\\n  error InvalidThresholdLength();\\n  /// @notice Throws when no owner address is passed while fund creation\\n  error NoOwnerPassed();\\n  /// @notice Throws when length of underlying token is greater than 1\\n  error InvalidTokenLength();\\n  /// @notice Throws when already an operation is taking place and another operation is called\\n  error AlreadyOngoingOperation();\\n  /// @notice Throws when wrong function is executed for revert offchain fund\\n  error InvalidExecution();\\n  /// @notice Throws when Final value after investment is zero\\n  error ZeroFinalInvestmentValue();\\n  /// @notice Throws when token amount after swap / token amount to be minted comes out as zero\\n  error ZeroTokenAmount();\\n  /// @notice Throws eth transfer failed\\n  error ETHTransferFailed();\\n  /// @notice Thorws when the caller does not have a default admin role\\n  error CallerNotAdmin();\\n  /// @notice Throws when buyAmount is not correct in offchainIndexSwap\\n  error InvalidBuyValues();\\n  /// @notice Throws when token is not primary\\n  error TokenNotPrimary();\\n  /// @notice Throws when tokenOut during withdraw is not permitted in the asset manager config\\n  error _tokenOutNotPermitted();\\n  /// @notice Throws when token balance is too small to be included in index\\n  error BalanceTooSmall();\\n  /// @notice Throws when a public fund is tried to made transferable only to whitelisted addresses\\n  error PublicFundToWhitelistedNotAllowed();\\n  /// @notice Throws when list input by user is invalid (meta aggregator)\\n  error InvalidInputTokenList();\\n  /// @notice Generic call failed error\\n  error CallFailed();\\n  /// @notice Generic transfer failed error\\n  error TransferFailed();\\n  /// @notice Throws when incorrect token amount is encountered during offchain/onchain investment\\n  error IncorrectInvestmentTokenAmount();\\n  /// @notice Throws when final invested amount after slippage is 0\\n  error ZeroInvestedAmountAfterSlippage();\\n  /// @notice Throws when the slippage trying to be set is in incorrect range\\n  error IncorrectSlippageRange();\\n  /// @notice Throws when invalid LP slippage is passed\\n  error InvalidLPSlippage();\\n  /// @notice Throws when invalid slippage for swapping is passed\\n  error InvalidSlippage();\\n  /// @notice Throws when msg.value is less than the amount passed into the handler\\n  error WrongNativeValuePassed();\\n  /// @notice Throws when there is an overflow during muldiv full math operation\\n  error FULLDIV_OVERFLOW();\\n  /// @notice Throws when the oracle price is not updated under set timeout\\n  error PriceOracleExpired();\\n  /// @notice Throws when the oracle price is returned 0\\n  error PriceOracleInvalid();\\n  /// @notice Throws when the initToken or updateTokenList function of IndexSwap is having more tokens than set by the Registry\\n  error TokenCountOutOfLimit(uint256 limit);\\n  /// @notice Throws when the array lenghts don't match for adding price feed or enabling tokens\\n  error IncorrectArrayLength();\\n  /// @notice Common Reentrancy error for IndexSwap and IndexSwapOffChain\\n  error ReentrancyGuardReentrantCall();\\n  /// @notice Throws when user calls updateFees function before proposing a new fee\\n  error NoNewFeeSet();\\n  /// @notice Throws when token is not ETH\\n  error TokenNotETH();\\n}\\n\"\r\n    },\r\n    \"contracts/oracle/IPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.16;\\n\\nimport {AggregatorV2V3Interface} from \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\\\";\\n\\ninterface IPriceOracle {\\n  function WETH() external returns(address);\\n\\n  function _addFeed(address base, address quote, AggregatorV2V3Interface aggregator) external;\\n\\n  function decimals(address base, address quote) external view returns (uint8);\\n\\n  function latestRoundData(address base, address quote) external view returns (int256);\\n\\n  function getUsdEthPrice(uint256 amountIn) external view returns (uint256 amountOut);\\n\\n  function getEthUsdPrice(uint256 amountIn) external view returns (uint256 amountOut);\\n\\n  function getPrice(address base, address quote) external view returns (int256);\\n\\n  function getPriceForAmount(address token, uint256 amount, bool ethPath) external view returns (uint256 amountOut);\\n\\n  function getPriceForTokenAmount(\\n    address tokenIn,\\n    address tokenOut,\\n    uint256 amount\\n  ) external view returns (uint256 amountOut);\\n\\n  function getPriceTokenUSD18Decimals(address _base, uint256 amountIn) external view returns (uint256 amountOut);\\n\\n  function getPriceForOneTokenInUSD(address _base) external view returns (uint256 amountOut);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_priceOracle\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"IncorrectSlippageRange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintAmountNotEqualToPassedValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEnoughBalanceInWombatProtocol\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenNotETH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFailed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_slippage\",\"type\":\"uint256\"}],\"name\":\"AddOrUpdateProtocolSlippage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isWETH\",\"type\":\"bool\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"HUNDRED_PERCENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_slippage\",\"type\":\"uint256\"}],\"name\":\"addOrUpdateProtocolSlippage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpAsset\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_amount\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_lpSlippage\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_mintedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"encodeData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_holder\",\"type\":\"address\"}],\"name\":\"getClaimTokenCalldata\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRouterAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenHolder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"getTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenHolder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"getTokenBalanceUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpToken\",\"type\":\"address\"}],\"name\":\"getUnderlying\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenHolder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"getUnderlyingBalance\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSlippage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lpSlippage\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_yieldAsset\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isWETH\",\"type\":\"bool\"}],\"internalType\":\"struct FunctionParameters.RedeemData\",\"name\":\"inputData\",\"type\":\"tuple\"}],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "WombatHandler", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c2f2bf0c228714d038c2495343224c0d9199cc82", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}