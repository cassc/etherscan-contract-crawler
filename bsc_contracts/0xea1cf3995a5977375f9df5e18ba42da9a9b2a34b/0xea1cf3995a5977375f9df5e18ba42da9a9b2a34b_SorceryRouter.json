{"SourceCode": "/**\r\n *Submitted for verification at BscScan.com on 2023-03-10\r\n*/\r\n\r\n//SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.16;\r\n\r\nabstract contract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() {\r\n        _transferOwnership(msg.sender);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint256 value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(0x095ea7b3, to, value)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"TransferHelper::safeApprove: approve failed\"\r\n        );\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint256 value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(0xa9059cbb, to, value)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"TransferHelper::safeTransfer: transfer failed\"\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"TransferHelper::transferFrom: transferFrom failed\"\r\n        );\r\n    }\r\n\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success, ) = to.call{value: value}(new bytes(0));\r\n        require(\r\n            success,\r\n            \"TransferHelper::safeTransferETH: ETH transfer failed\"\r\n        );\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\r\n    }\r\n\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\r\n    }\r\n\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\r\n    }\r\n}\r\n\r\ninterface ISorceryPair {\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n\r\n    function swap(\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address to,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\ninterface ISorceryFactory {\r\n    function getPair(\r\n        address tokenA,\r\n        address tokenB\r\n    ) external view returns (address pair);\r\n}\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n\r\n    function transfer(address to, uint value) external returns (bool);\r\n\r\n    function withdraw(uint) external;\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address owner) external view returns (uint);\r\n}\r\n\r\ncontract SorceryRouter is Ownable {\r\n    using SafeMath for uint;\r\n\r\n    address public immutable factory;\r\n    address public immutable WETH;\r\n    address private treasury;\r\n\r\n    mapping(address => bool) public stable;\r\n\r\n    modifier ensure(uint deadline) {\r\n        require(deadline >= block.timestamp, \"SorceryRouter: EXPIRED\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _factory, address _WETH, address treasuryAddress) {\r\n        factory = _factory;\r\n        WETH = _WETH;\r\n        treasury = treasuryAddress;\r\n        stable[0xeD24FC36d5Ee211Ea25A80239Fb8C4Cfd80f12Ee] = true;\r\n        stable[0x337610d27c682E347C9cD60BD4b3b107C9d34dDd] = true;\r\n        stable[0x64544969ed7EBf5f083679233325356EbE738930] = true;\r\n        stable[0xEC5dCb5Dbf4B114C9d0F65BcCAb49EC54F6A0867] = true;\r\n    }\r\n\r\n    receive() external payable {\r\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\r\n    }\r\n\r\n    // **** OWNER FUCNTIONS ****\r\n\r\n    function updateTreasury(address treasuryAddress) external onlyOwner {\r\n        treasury = treasuryAddress;\r\n    }\r\n\r\n    function updateStable(\r\n        address tokenAddress,\r\n        bool isStable\r\n    ) public onlyOwner {\r\n        stable[tokenAddress] = isStable;\r\n    }\r\n\r\n    // fee is calculated as parts per million\r\n    function getFee(\r\n        address token0,\r\n        address token1\r\n    ) internal view returns (uint256 fees) {\r\n        uint256 stableCount;\r\n        if (stable[token0]) {\r\n            stableCount = stableCount + 1;\r\n        }\r\n        if (stable[token1]) {\r\n            stableCount = stableCount + 1;\r\n        }\r\n        if (stableCount == 0) {\r\n            fees = 3000;\r\n        } else if (stableCount == 1) {\r\n            fees = 1500;\r\n        } else if (stableCount == 2) {\r\n            fees = 500;\r\n        }\r\n    }\r\n\r\n    function getFeeAmount(\r\n        address token0,\r\n        address token1,\r\n        uint amount\r\n    ) internal view returns (uint256 feeAmount) {\r\n        uint256 fee = getFee(token0, token1);\r\n        feeAmount = (amount * fee) / 1000000;\r\n    }\r\n\r\n    // **** LIBRARY ****\r\n\r\n    function sortTokens(\r\n        address tokenA,\r\n        address tokenB\r\n    ) internal pure returns (address token0, address token1) {\r\n        require(tokenA != tokenB, \"PancakeLibrary: IDENTICAL_ADDRESSES\");\r\n        (token0, token1) = tokenA < tokenB\r\n            ? (tokenA, tokenB)\r\n            : (tokenB, tokenA);\r\n        require(token0 != address(0), \"PancakeLibrary: ZERO_ADDRESS\");\r\n    }\r\n\r\n    function pairFor(\r\n        address tokenA,\r\n        address tokenB\r\n    ) internal view returns (address pair) {\r\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\r\n        pair = ISorceryFactory(factory).getPair(token0, token1);\r\n    }\r\n\r\n    // **** SWAP ****\r\n    // requires the initial amount to have already been sent to the first pair\r\n    function _swap(\r\n        uint[] memory amounts,\r\n        address[] memory path,\r\n        address _to\r\n    ) internal virtual {\r\n        for (uint i; i < path.length - 1; i++) {\r\n            (address input, address output) = (path[i], path[i + 1]);\r\n            (address token0, ) = sortTokens(input, output);\r\n            uint amountOut = amounts[i + 1];\r\n            (uint amount0Out, uint amount1Out) = input == token0\r\n                ? (uint(0), amountOut)\r\n                : (amountOut, uint(0));\r\n            address to = i < path.length - 2\r\n                ? pairFor(output, path[i + 2])\r\n                : _to;\r\n            ISorceryPair(pairFor(input, output)).swap(\r\n                amount0Out,\r\n                amount1Out,\r\n                to,\r\n                new bytes(0)\r\n            );\r\n        }\r\n    }\r\n\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external virtual ensure(deadline) returns (uint[] memory amounts) {\r\n        uint256 feeAmount = getFeeAmount(\r\n            path[0],\r\n            path[path.length - 1],\r\n            amountIn\r\n        );\r\n        amountIn = amountIn - feeAmount;\r\n        amounts = getAmountsOut(amountIn, path);\r\n        require(\r\n            amounts[amounts.length - 1] >= amountOutMin,\r\n            \"SorceryRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\r\n        );\r\n        TransferHelper.safeTransferFrom(\r\n            path[0],\r\n            msg.sender,\r\n            pairFor(path[0], path[1]),\r\n            amounts[0]\r\n        );\r\n        TransferHelper.safeTransferFrom(\r\n            path[0],\r\n            msg.sender,\r\n            treasury,\r\n            feeAmount\r\n        );\r\n        _swap(amounts, path, to);\r\n    }\r\n\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external virtual ensure(deadline) returns (uint[] memory amounts) {\r\n        amounts = getAmountsIn(amountOut, path);\r\n        uint256 feeAmount = getFeeAmount(\r\n            path[0],\r\n            path[path.length - 1],\r\n            amounts[0]\r\n        );\r\n        require(\r\n            (amounts[0] + feeAmount) <= amountInMax,\r\n            \"SorceryRouter: EXCESSIVE_INPUT_AMOUNT\"\r\n        );\r\n        TransferHelper.safeTransferFrom(\r\n            path[0],\r\n            msg.sender,\r\n            pairFor(path[0], path[1]),\r\n            amounts[0]\r\n        );\r\n        TransferHelper.safeTransferFrom(\r\n            path[0],\r\n            msg.sender,\r\n            treasury,\r\n            feeAmount\r\n        );\r\n        _swap(amounts, path, to);\r\n    }\r\n\r\n    function swapExactETHForTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    )\r\n        external\r\n        payable\r\n        virtual\r\n        ensure(deadline)\r\n        returns (uint[] memory amounts)\r\n    {\r\n        require(path[0] == WETH, \"SorceryRouter: INVALID_PATH\");\r\n        uint256 feeAmount = getFeeAmount(\r\n            path[0],\r\n            path[path.length - 1],\r\n            msg.value\r\n        );\r\n        amounts = getAmountsOut((msg.value - feeAmount), path);\r\n\r\n        require(\r\n            amounts[amounts.length - 1] >= amountOutMin,\r\n            \"SorceryRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\r\n        );\r\n        IWETH(WETH).deposit{value: (amounts[0] + feeAmount)}();\r\n        assert(IWETH(WETH).transfer(pairFor(path[0], path[1]), amounts[0]));\r\n        assert(IWETH(WETH).transfer(treasury, feeAmount));\r\n        _swap(amounts, path, to);\r\n    }\r\n\r\n    function swapTokensForExactETH(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external virtual ensure(deadline) returns (uint[] memory amounts) {\r\n        require(path[path.length - 1] == WETH, \"SorceryRouter: INVALID_PATH\");\r\n        amounts = getAmountsIn(amountOut, path);\r\n        uint256 feeAmount = getFeeAmount(\r\n            path[0],\r\n            path[path.length - 1],\r\n            amounts[0]\r\n        );\r\n        require(\r\n            (amounts[0] + feeAmount) <= amountInMax,\r\n            \"SorceryRouter: EXCESSIVE_INPUT_AMOUNT\"\r\n        );\r\n        TransferHelper.safeTransferFrom(\r\n            path[0],\r\n            msg.sender,\r\n            pairFor(path[0], path[1]),\r\n            amounts[0]\r\n        );\r\n        TransferHelper.safeTransferFrom(\r\n            path[0],\r\n            msg.sender,\r\n            treasury,\r\n            feeAmount\r\n        );\r\n        _swap(amounts, path, address(this));\r\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\r\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\r\n    }\r\n\r\n    function swapExactTokensForETH(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external virtual ensure(deadline) returns (uint[] memory amounts) {\r\n        require(path[path.length - 1] == WETH, \"SorceryRouter: INVALID_PATH\");\r\n        uint256 feeAmount = getFeeAmount(\r\n            path[0],\r\n            path[path.length - 1],\r\n            amountIn\r\n        );\r\n        amountIn = amountIn - feeAmount;\r\n        amounts = getAmountsOut(amountIn, path);\r\n        require(\r\n            amounts[amounts.length - 1] >= amountOutMin,\r\n            \"SorceryRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\r\n        );\r\n        TransferHelper.safeTransferFrom(\r\n            path[0],\r\n            msg.sender,\r\n            pairFor(path[0], path[1]),\r\n            amounts[0]\r\n        );\r\n        TransferHelper.safeTransferFrom(\r\n            path[0],\r\n            msg.sender,\r\n            treasury,\r\n            feeAmount\r\n        );\r\n        _swap(amounts, path, address(this));\r\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\r\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\r\n    }\r\n\r\n    function swapETHForExactTokens(\r\n        uint amountOut,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    )\r\n        external\r\n        payable\r\n        virtual\r\n        ensure(deadline)\r\n        returns (uint[] memory amounts)\r\n    {\r\n        require(path[0] == WETH, \"SorceryRouter: INVALID_PATH\");\r\n        amounts = getAmountsIn(amountOut, path);\r\n        uint256 feeAmount = getFeeAmount(\r\n            path[0],\r\n            path[path.length - 1],\r\n            amounts[0]\r\n        );\r\n        require(\r\n            (amounts[0] + feeAmount) <= msg.value,\r\n            \"SorceryRouter: EXCESSIVE_INPUT_AMOUNT\"\r\n        );\r\n        IWETH(WETH).deposit{value: amounts[0] + feeAmount}();\r\n        assert(IWETH(WETH).transfer(pairFor(path[0], path[1]), amounts[0]));\r\n        assert(IWETH(WETH).transfer(treasury, feeAmount));\r\n        _swap(amounts, path, to);\r\n        // refund dust eth, if any\r\n        if (msg.value > (amounts[0]+feeAmount))\r\n            TransferHelper.safeTransferETH(msg.sender, msg.value - (amounts[0]+feeAmount));\r\n    }\r\n\r\n    // **** SWAP (supporting fee-on-transfer tokens) ****\r\n    // requires the initial amount to have already been sent to the first pair\r\n    function _swapSupportingFeeOnTransferTokens(\r\n        address[] memory path,\r\n        address _to\r\n    ) internal virtual {\r\n        for (uint i; i < path.length - 1; i++) {\r\n            (address input, address output) = (path[i], path[i + 1]);\r\n            (address token0, ) = sortTokens(input, output);\r\n            ISorceryPair pair = ISorceryPair(pairFor(input, output));\r\n            uint amountInput;\r\n            uint amountOutput;\r\n            {\r\n                // scope to avoid stack too deep errors\r\n                (uint reserve0, uint reserve1, ) = pair.getReserves();\r\n                (uint reserveInput, uint reserveOutput) = input == token0\r\n                    ? (reserve0, reserve1)\r\n                    : (reserve1, reserve0);\r\n                amountInput = IERC20(input).balanceOf(address(pair)).sub(\r\n                    reserveInput\r\n                );\r\n                amountOutput = getAmountOut(\r\n                    amountInput,\r\n                    reserveInput,\r\n                    reserveOutput\r\n                );\r\n            }\r\n            (uint amount0Out, uint amount1Out) = input == token0\r\n                ? (uint(0), amountOutput)\r\n                : (amountOutput, uint(0));\r\n            address to = i < path.length - 2\r\n                ? pairFor(output, path[i + 2])\r\n                : _to;\r\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\r\n        }\r\n    }\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external virtual ensure(deadline) {\r\n        uint256 feeAmount = getFeeAmount(\r\n            path[0],\r\n            path[path.length - 1],\r\n            amountIn\r\n        );\r\n        amountIn = amountIn - feeAmount;\r\n        TransferHelper.safeTransferFrom(\r\n            path[0],\r\n            msg.sender,\r\n            treasury,\r\n            feeAmount\r\n        );\r\n        TransferHelper.safeTransferFrom(\r\n            path[0],\r\n            msg.sender,\r\n            pairFor(path[0], path[1]),\r\n            amountIn\r\n        );\r\n        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\r\n        _swapSupportingFeeOnTransferTokens(path, to);\r\n        require(\r\n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >=\r\n                amountOutMin,\r\n            \"SorceryRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\r\n        );\r\n    }\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable virtual ensure(deadline) {\r\n        require(path[0] == WETH, \"SorceryRouter: INVALID_PATH\");\r\n        uint amountIn = msg.value;\r\n        uint256 feeAmount = getFeeAmount(\r\n            path[0],\r\n            path[path.length - 1],\r\n            amountIn\r\n        );\r\n        IWETH(WETH).deposit{value: amountIn}();\r\n        assert(IWETH(WETH).transfer(pairFor(path[0], path[1]), (amountIn - feeAmount)));\r\n        assert(IWETH(WETH).transfer(treasury, feeAmount));\r\n        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\r\n        _swapSupportingFeeOnTransferTokens(path, to);\r\n        require(\r\n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >=\r\n                amountOutMin,\r\n            \"SorceryRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\r\n        );\r\n    }\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external virtual ensure(deadline) {\r\n        require(path[path.length - 1] == WETH, \"SorceryRouter: INVALID_PATH\");\r\n        uint256 feeAmount = getFeeAmount(\r\n            path[0],\r\n            path[path.length - 1],\r\n            amountIn\r\n        );\r\n        amountIn = amountIn - feeAmount;\r\n        TransferHelper.safeTransferFrom(\r\n            path[0],\r\n            msg.sender,\r\n            treasury,\r\n            feeAmount\r\n        );\r\n        TransferHelper.safeTransferFrom(\r\n            path[0],\r\n            msg.sender,\r\n            pairFor(path[0], path[1]),\r\n            amountIn\r\n        );\r\n        _swapSupportingFeeOnTransferTokens(path, address(this));\r\n        uint amountOut = IERC20(WETH).balanceOf(address(this));\r\n        require(\r\n            amountOut >= amountOutMin,\r\n            \"SorceryRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\r\n        );\r\n        IWETH(WETH).withdraw(amountOut);\r\n        TransferHelper.safeTransferETH(to, amountOut);\r\n    }\r\n\r\n    // **** LIBRARY FUNCTIONS ****\r\n    function quote(\r\n        uint amountA,\r\n        uint reserveA,\r\n        uint reserveB\r\n    ) public pure virtual returns (uint amountB) {\r\n        require(amountA > 0, \"SorcerySwap: INSUFFICIENT_AMOUNT\");\r\n        require(\r\n            reserveA > 0 && reserveB > 0,\r\n            \"SorcerySwap: INSUFFICIENT_LIQUIDITY\"\r\n        );\r\n        amountB = amountA.mul(reserveB) / reserveA;\r\n    }\r\n\r\n    function getReserves(\r\n        address tokenA,\r\n        address tokenB\r\n    ) internal view returns (uint reserveA, uint reserveB) {\r\n        (address token0, ) = sortTokens(tokenA, tokenB);\r\n        pairFor(tokenA, tokenB);\r\n        (uint reserve0, uint reserve1, ) = ISorceryPair(pairFor(tokenA, tokenB))\r\n            .getReserves();\r\n        (reserveA, reserveB) = tokenA == token0\r\n            ? (reserve0, reserve1)\r\n            : (reserve1, reserve0);\r\n    }\r\n\r\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\r\n    function getAmountOut(\r\n        uint amountIn,\r\n        uint reserveIn,\r\n        uint reserveOut\r\n    ) internal pure returns (uint amountOut) {\r\n        require(amountIn > 0, \"SorcerySwap: INSUFFICIENT_INPUT_AMOUNT\");\r\n        require(\r\n            reserveIn > 0 && reserveOut > 0,\r\n            \"SorcerySwap: INSUFFICIENT_LIQUIDITY\"\r\n        );\r\n        uint amountInWithFee = amountIn.mul(9975);\r\n        uint numerator = amountInWithFee.mul(reserveOut);\r\n        uint denominator = reserveIn.mul(10000).add(amountInWithFee);\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\r\n    function getAmountIn(\r\n        uint amountOut,\r\n        uint reserveIn,\r\n        uint reserveOut\r\n    ) internal pure returns (uint amountIn) {\r\n        require(amountOut > 0, \"SorcerySwap: INSUFFICIENT_OUTPUT_AMOUNT\");\r\n        require(\r\n            reserveIn > 0 && reserveOut > 0,\r\n            \"SorcerySwap: INSUFFICIENT_LIQUIDITY\"\r\n        );\r\n        uint numerator = reserveIn.mul(amountOut).mul(10000);\r\n        uint denominator = reserveOut.sub(amountOut).mul(9975);\r\n        amountIn = (numerator / denominator).add(1);\r\n    }\r\n\r\n    // performs chained getAmountOut calculations on any number of pairs\r\n    function getAmountsOut(\r\n        uint amountIn,\r\n        address[] memory path\r\n    ) public view returns (uint[] memory amounts) {\r\n        require(path.length >= 2, \"SorcerySwap: INVALID_PATH\");\r\n        amounts = new uint[](path.length);\r\n        amounts[0] = amountIn;\r\n        for (uint i; i < path.length - 1; i++) {\r\n            (uint reserveIn, uint reserveOut) = getReserves(\r\n                path[i],\r\n                path[i + 1]\r\n            );\r\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\r\n        }\r\n    }\r\n\r\n    // performs chained getAmountIn calculations on any number of pairs\r\n    function getAmountsIn(\r\n        uint amountOut,\r\n        address[] memory path\r\n    ) public view returns (uint[] memory amounts) {\r\n        require(path.length >= 2, \"SorcerySwap: INVALID_PATH\");\r\n        amounts = new uint[](path.length);\r\n        amounts[amounts.length - 1] = amountOut;\r\n        for (uint i = path.length - 1; i > 0; i--) {\r\n            (uint reserveIn, uint reserveOut) = getReserves(\r\n                path[i - 1],\r\n                path[i]\r\n            );\r\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_WETH\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"treasuryAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"getAmountsIn\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"getAmountsOut\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveB\",\"type\":\"uint256\"}],\"name\":\"quote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapETHForExactTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactETHForTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactETHForTokensSupportingFeeOnTransferTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForETH\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForETHSupportingFeeOnTransferTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForTokensSupportingFeeOnTransferTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMax\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapTokensForExactETH\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMax\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapTokensForExactTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isStable\",\"type\":\"bool\"}],\"name\":\"updateStable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"treasuryAddress\",\"type\":\"address\"}],\"name\":\"updateTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SorceryRouter", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000ca143ce32fe78f1f7019d7d551a6402fc5350c73000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c000000000000000000000000f697ba6e14858d3df1490a4b602b10957486311f", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d2f889049ce7ecf5eb59e9765e1882e714c389abb8d081325dbba7e5bb26ebb4"}