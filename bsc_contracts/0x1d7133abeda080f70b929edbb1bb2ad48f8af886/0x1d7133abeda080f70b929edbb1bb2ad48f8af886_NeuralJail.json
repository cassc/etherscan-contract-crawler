{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/src/contracts/NeuralPrison.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./IBEP20.sol\\\";\\n\\n\\ninterface INeuralPepe {\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n}\\n\\ncontract NeuralJail is Ownable {\\n  uint256 public constant SECONDS_IN_A_DAY = 86400;\\n\\n  address private _aiTreasuryAddress = 0x2ecC66A6b5773596a1d66e91f62dd7F460cdA21c;\\n  address private _bnbTreasuryAddress = 0x4e65E0177CBa8B58b25158d428131f6986361476;\\n  address private _aiAddress;\\n  address private _pepeAddress;\\n  \\n  uint256 public pepeBnbPrice = 1500000000000000000;\\n  uint256 public pepeAiPrice = 1000000000000000000000000;\\n\\n  IBEP20 private AI;\\n  INeuralPepe private PEPE;\\n  \\n  mapping(uint256 => uint256) private _pepeReleased;\\n\\n  constructor (address ai, address pepe) {\\n    _aiAddress = ai;\\n    _pepeAddress = pepe;\\n    PEPE = INeuralPepe(_pepeAddress);\\n    AI = IBEP20(_aiAddress);\\n  }\\n\\n  event PepeToPepeSwap(uint256 incomingPepe, uint256 releasedPepe);\\n  event PepeReleased(uint256 releasedPepe);\\n\\n\\n  function _isPepeApproved(uint tokenId) private view returns (bool) {\\n    try PEPE.getApproved(tokenId) returns (address tokenOperator) {\\n        return tokenOperator == address(this);\\n    } catch {\\n        return false;\\n    }\\n  }\\n\\n  function _isPepeApprovedForAll() private view returns (bool) {\\n    return PEPE.isApprovedForAll(msg.sender, address(this));\\n  }\\n\\n  function _isAiApproved() private view returns (uint256) {\\n    return AI.allowance(msg.sender, address(this));\\n  }\\n\\n  function getRandomIndex(uint256 maxIndex) internal view returns(uint256){\\n    return uint256(keccak256(abi.encodePacked(block.difficulty, block.timestamp, msg.sender))) % maxIndex;\\n  }\\n\\n  function getRandomPepe() private view returns (uint256) {\\n    uint256 totalPepesInPrison = PEPE.balanceOf(address(this));\\n    uint256 randomIndex = getRandomIndex(totalPepesInPrison);\\n    uint256 pepeToSend = PEPE.tokenOfOwnerByIndex(address(this), randomIndex);\\n    return pepeToSend;\\n  }\\n\\n  function _pepeValidReveal(uint256 pepeId) internal view returns (bool) {\\n    return (block.timestamp - SECONDS_IN_A_DAY) > _pepeReleased[pepeId];\\n  }\\n\\n  function swapPepeForPepe(uint256 incomingTokenId) public {\\n    require(_pepeValidReveal(incomingTokenId), 'This pepe has been released from jail less than 24h ago');\\n    require(PEPE.balanceOf(address(this)) > 0, 'All pepes are free atm');\\n    require(PEPE.ownerOf(incomingTokenId) == _msgSender(), 'is not token owner');\\n    require(_isPepeApprovedForAll() || _isPepeApproved(incomingTokenId), 'contract is missing approvement for pepe transfer');\\n    require(AI.balanceOf(_msgSender()) >= pepeAiPrice && _isAiApproved() > pepeAiPrice, 'Not enough ai or allowance');\\n\\n\\n    uint256 tokenToSend = getRandomPepe();\\n    claimAI(tokenToSend);\\n    AI.transferFrom(_msgSender(), _aiTreasuryAddress, pepeAiPrice);\\n    PEPE.safeTransferFrom(_msgSender(), address(this), incomingTokenId);\\n    PEPE.safeTransferFrom(address(this), _msgSender(), tokenToSend);\\n\\n    _pepeReleased[tokenToSend] = block.timestamp;\\n\\n    emit PepeToPepeSwap(incomingTokenId, tokenToSend);\\n  }\\n\\n  function buyPepe() public payable {\\n    require(PEPE.balanceOf(address(this)) > 0, 'All pepes are free atm');\\n    require(pepeBnbPrice == msg.value, \\\"BNB value sent is not correct\\\");\\n\\n    uint256 tokenToSend = getRandomPepe();\\n    claimAI(tokenToSend);\\n    \\n    PEPE.safeTransferFrom(address(this), msg.sender, tokenToSend);\\n    _pepeReleased[tokenToSend] = block.timestamp;\\n\\n    payable(_bnbTreasuryAddress).transfer(pepeBnbPrice);\\n\\n    emit PepeReleased(tokenToSend);\\n  }\\n\\n  function claimAI(uint256 tokenId) internal {\\n    uint256[] memory tokenToClaim = new uint256[](1);\\n    tokenToClaim[0] = tokenId;\\n\\n    AI.claim(tokenToClaim);\\n    uint256 balance = AI.balanceOf(address(this));\\n    AI.transfer(_aiTreasuryAddress, balance);\\n  }\\n\\n  /**\\n    * @dev Changes the AI treasury address\\n  */\\n  function changeAiTreasuryAddress(address newAddress) onlyOwner public {\\n      require(newAddress != address(0), 'cannot be zero address');\\n      _aiTreasuryAddress = newAddress;\\n  }\\n\\n  /**\\n    * @dev Changes the BNB treasury address\\n  */\\n  function changeBnbTreasuryAddress(address newAddress) onlyOwner public {\\n      require(newAddress != address(0), 'cannot be zero address');\\n      _bnbTreasuryAddress = newAddress;\\n  }\\n\\n  /**\\n    * @dev Changes the AI contract address\\n  */\\n  function changeAiAddress(address newAddress) onlyOwner public {\\n      require(newAddress != address(0), 'cannot be zero address');\\n      _aiAddress = newAddress;\\n      AI = IBEP20(_aiAddress);\\n  }\\n\\n  /**\\n    * @dev Changes the Pepe contract address\\n  */\\n  function changePepeAddress(address newAddress) onlyOwner public {\\n      require(newAddress != address(0), 'cannot be zero address');\\n      _pepeAddress = newAddress;\\n      PEPE = INeuralPepe(_pepeAddress);\\n  }\\n\\n  /**\\n    * @dev Changes the Pepe contract address\\n  */\\n  function changePepeBnbPrice(uint256 newPrice) onlyOwner public {\\n    require(newPrice >= 10000000000000000, 'value cannot be less then 0.01bnb');\\n    pepeBnbPrice = newPrice;\\n  }\\n\\n  /**\\n    * @dev Changes the Pepe contract address\\n  */\\n  function changePepeAiPrice(uint256 newPrice) onlyOwner public {\\n    require(newPrice >= 1000000000000000000, 'value cannot be less then 1 ai');\\n    pepeAiPrice = newPrice;\\n  }\\n\\n  /**\\n    * @dev returns 30 tokens\\n  */\\n  function releasePepes() onlyOwner public {\\n    uint256 pepeBalance = PEPE.balanceOf(address(this));\\n    uint256 txlimit = pepeBalance > 30 ? 30 : pepeBalance;\\n\\n    for(uint256 i = 0; i < txlimit; i++) {\\n      uint256 tokenId = PEPE.tokenOfOwnerByIndex(address(this), i);\\n      PEPE.safeTransferFrom(address(this), owner(), tokenId);\\n    }\\n  }\\n\\n    /**\\n    * @dev Return randox X tokens\\n  */\\n  function releaseRandomPepes(uint256 n) onlyOwner public {\\n    require(n > 0 && n < 30, 'wrong n');\\n    uint256 pepeBalance = PEPE.balanceOf(address(this));\\n    uint256 txlimit = pepeBalance < n ? pepeBalance : n;\\n\\n    for(uint256 i = 0; i < txlimit; i++) {\\n      uint256 tokenToSend = getRandomPepe();\\n      PEPE.safeTransferFrom(address(this), owner(), tokenToSend);\\n\\n    }\\n  }\\n\\n  \\n\\n  function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external pure returns(bytes4){\\n    return bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"));\\n  } \\n}\"\r\n    },\r\n    \"/src/contracts/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\"\r\n    },\r\n    \"/src/contracts/IBEP20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.0 <0.9.0;\\n\\ninterface IBEP20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the token decimals.\\n   */\\n  function decimals() external view returns (uint8);\\n\\n  /**\\n   * @dev Returns the token symbol.\\n   */\\n  function symbol() external view returns (string memory);\\n\\n  /**\\n  * @dev Returns the token name.\\n  */\\n  function name() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the bep token owner.\\n   */\\n  function getOwner() external view returns (address);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address _owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  function burn(uint256 burnQuantity) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n\\n  function claim(uint256[] memory tokenIndices) external returns (uint256);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"/src/contracts/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"petersburg\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ai\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pepe\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"releasedPepe\",\"type\":\"uint256\"}],\"name\":\"PepeReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"incomingPepe\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"releasedPepe\",\"type\":\"uint256\"}],\"name\":\"PepeToPepeSwap\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"SECONDS_IN_A_DAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyPepe\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"changeAiAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"changeAiTreasuryAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"changeBnbTreasuryAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"changePepeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"changePepeAiPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"changePepeBnbPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pepeAiPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pepeBnbPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"releasePepes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"releaseRandomPepes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"incomingTokenId\",\"type\":\"uint256\"}],\"name\":\"swapPepeForPepe\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "NeuralJail", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000007b617145ece988b864cd12f67476c24903f605a9000000000000000000000000012f90e777bdb2b4ca132f0f6eb9e7959075e9b2", "EVMVersion": "petersburg", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}