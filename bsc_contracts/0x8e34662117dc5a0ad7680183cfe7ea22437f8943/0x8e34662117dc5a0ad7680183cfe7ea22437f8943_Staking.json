{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStaking.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Business Source License 1.1\\npragma solidity ^0.8.17;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\ninterface IStaking {\\n    struct Stake {\\n        uint256 amount;\\n        uint256 claimedReward; // how much reward was already claimed\\n        uint256 lockTime;\\n        uint256 startTime;\\n        uint256 claimedTime; // when stake was withdrawn (meaning no more rewards after that point)\\n    }\\n\\n    struct UserData {\\n        uint256 rewardToClaim;\\n        uint256 totalStaked;\\n        StakeView[] stakes;\\n    }\\n\\n    struct StakeView {\\n        uint256 amount;\\n        uint256 reward;\\n        uint256 timeLeft;\\n        bool stakeClaimed;\\n        address contractAddr;\\n        uint256 stakingIndex;\\n    }\\n\\n    event Staked(address user, uint256 stakedAmount, uint256 lockTime);\\n    event Claimed(address user, uint256 stakedAmount, uint256 reward);\\n    event ClaimedReward(address user, uint256 reward);\\n    event ClaimedStakedAmount(address user, uint256 stakedAmount);\\n    event OwnerChanged(address oldOwner, address newOwner);\\n    event TotalRewardsEarned(uint256 rewards);\\n\\n    error AddressZero();\\n    error TransferFailed();\\n    error OnlyOwnerAccess();\\n    error AlreadyClaimed();\\n    error StakeNotExist();\\n    error LocktimeNotPassed();\\n    error NotParticipated();\\n    error InvalidLockTime();\\n    error BalanceNotEnough();\\n    error TokensLimitReached();\\n    error StakingInProgress();\\n    error NotInTheFuture();\\n    error TooMuchStakes();\\n\\n    function stakeTokens(uint256 _amount, uint256 _lockTime) external;\\n\\n    function calculateReward(address _user, uint256 _index) external view returns (uint256);\\n\\n    function claimReward(uint256 _index) external;\\n\\n    function claimStakedAmount(uint256 _index) external;\\n\\n    function claim(uint256 _index) external;\\n\\n    function totalStaked() external view returns (uint256);\\n\\n    function setOwner(address _owner) external;\\n\\n    function getUserSummary(address _user) external view returns(UserData memory);\\n\\n    function getStakes(address _user) external view returns (Stake[] memory);\\n\\n    function getStakesLen(address _user) external view returns(uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/Staking.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.17;\\n\\nimport './interfaces/IStaking.sol';\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '@openzeppelin/contracts/security/Pausable.sol';\\n\\n\\ncontract Staking is IStaking, Pausable {\\n    uint256 constant internal MAX_USER_STAKES = 100;\\n    address public owner;\\n    IERC20 public token;\\n    IERC20 public rewardToken;\\n    uint256 public override totalStaked;\\n    mapping(address => uint256) public totalUserStaked;\\n    uint256 public rewardDeadline;\\n    uint256 public maximumStakingRewards;\\n\\n    mapping(address => Stake[]) private stakes;\\n    mapping(uint256 => uint256) public apy;\\n    mapping(uint256 => uint256) public tokensLocked;\\n    mapping(uint256 => uint256) public tokensLimits;\\n    uint256[] public lockLengths;\\n    mapping(uint256 => uint256) internal lastEarnedCalculation;\\n    mapping(uint256 => uint256) internal earnedPerLockTime;\\n\\n    constructor(\\n        address _tokenAddress,\\n        address _rewardAddress,\\n        uint256[] memory _lockLengths,\\n        uint256[] memory _percentages,\\n        uint256[] memory _tokensLimits,\\n        uint256 _maximumStakingRewards\\n    ) {\\n        owner = msg.sender;\\n        if (_tokenAddress == address(0) || _rewardAddress == address(0)) {\\n            revert AddressZero();\\n        }\\n        token = IERC20(_tokenAddress);\\n        rewardToken = IERC20(_rewardAddress);\\n        maximumStakingRewards = _maximumStakingRewards;\\n        for (uint256 i = 0; i < _lockLengths.length; ) {\\n            apy[_lockLengths[i]] = _percentages[i];\\n            lockLengths.push(_lockLengths[i]);\\n            tokensLimits[_lockLengths[i]] = _tokensLimits[i];\\n            lastEarnedCalculation[_lockLengths[i]] = block.timestamp;\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        rewardDeadline = block.timestamp + (60 * 60 * 24 * 365); // 1 year from start\\n\\n        _pause();\\n    }\\n\\n    modifier onlyOwnerAccess() {\\n        if (msg.sender != owner) {\\n            revert OnlyOwnerAccess();\\n        }\\n        _;\\n    }\\n\\n    modifier recalculateEarnings() {\\n        uint256 alreadyEarned = 0;\\n        uint256 rewardEnd = _getRewardEnd();\\n        for (uint256 i = 0; i < lockLengths.length; i++) {\\n            uint256 timePassed = rewardEnd - lastEarnedCalculation[lockLengths[i]];\\n            if (timePassed == 0) {\\n                alreadyEarned += earnedPerLockTime[lockLengths[i]];\\n                continue;\\n            }\\n            uint256 newReward = _calculateRewardIncrease(tokensLocked[lockLengths[i]], apy[lockLengths[i]], timePassed);\\n            lastEarnedCalculation[lockLengths[i]] = rewardEnd;\\n            earnedPerLockTime[lockLengths[i]] += newReward;\\n\\n            alreadyEarned += earnedPerLockTime[lockLengths[i]];\\n        }\\n\\n        emit TotalRewardsEarned(alreadyEarned);\\n\\n        if (maximumStakingRewards <= alreadyEarned && rewardDeadline > block.timestamp) {\\n            rewardDeadline = block.timestamp;\\n        }\\n        _;\\n    }\\n\\n    function updateTotalEarningsState() external recalculateEarnings {\\n\\n    }\\n\\n    function stakeTokens(uint256 _amount, uint256 _lockTime) public recalculateEarnings whenNotPaused {\\n        if (apy[_lockTime] == 0) {\\n            revert InvalidLockTime();\\n        }\\n\\n        if (tokensLimits[_lockTime] != 0) {\\n            if (tokensLocked[_lockTime] + _amount > tokensLimits[_lockTime]) {\\n                revert TokensLimitReached();\\n            }\\n        }\\n\\n        Stake memory newStake = Stake(_amount, 0, _lockTime, block.timestamp, 0);\\n        stakes[msg.sender].push(newStake);\\n        if (stakes[msg.sender].length > MAX_USER_STAKES) {\\n            revert TooMuchStakes();\\n        }\\n\\n        totalStaked += _amount;\\n        totalUserStaked[msg.sender] += _amount;\\n        tokensLocked[_lockTime] += _amount;\\n        if (!token.transferFrom(msg.sender, address(this), _amount)) {\\n            revert TransferFailed();\\n        }\\n        emit Staked(msg.sender, _amount, _lockTime);\\n    }\\n\\n    function _calculateRewardIncrease(uint256 _stakeAmount, uint256 _apy, uint256 _timePassed) internal pure returns(uint256) {\\n        return ((_stakeAmount * _apy * _timePassed) / (100 * 365 days));\\n    }\\n\\n    function _calculateReward(Stake storage _stake) internal view returns (uint256) {\\n        if (rewardDeadline < _stake.startTime) {\\n            return 0;\\n        }\\n        uint256 timePassed = 0;\\n        if (_stake.claimedTime > 0) {\\n            timePassed = _min(_stake.claimedTime, rewardDeadline) - _stake.startTime;\\n        } else {\\n            timePassed = _getRewardEnd() - _stake.startTime;\\n        }\\n\\n        return _calculateRewardIncrease(_stake.amount, apy[_stake.lockTime], timePassed) - _stake.claimedReward;\\n    }\\n\\n    function calculateReward(address _user, uint256 _index) public view returns (uint256) {\\n        return _calculateReward(_getStake(_user, _index));\\n    }\\n\\n    function claimReward(uint256 _index) public recalculateEarnings {\\n        Stake storage stake = _getStake(msg.sender, _index);\\n        if (block.timestamp <= stake.startTime + stake.lockTime) {\\n            revert LocktimeNotPassed();\\n        }\\n        uint256 reward = calculateReward(msg.sender, _index);\\n        if (reward == 0) {\\n            revert AlreadyClaimed();\\n        }\\n        stake.claimedReward += reward;\\n        if (address(token) == address(rewardToken)) {\\n            if (token.balanceOf(address(this)) < totalStaked + reward) {\\n                revert BalanceNotEnough();\\n            }\\n            if (!token.transfer(msg.sender, reward)) {\\n                revert TransferFailed();\\n            }\\n        } else {\\n            if (!rewardToken.transfer(msg.sender, reward)) {\\n                revert TransferFailed();\\n            }\\n        }\\n\\n        emit ClaimedReward(msg.sender, reward);\\n    }\\n\\n    function claimStakedAmount(uint256 _index) public recalculateEarnings {\\n        Stake storage stake = _getStake(msg.sender, _index);\\n        _checkStake(stake);\\n        totalStaked -= stake.amount;\\n        totalUserStaked[msg.sender] -= stake.amount;\\n        stake.claimedTime = block.timestamp;\\n        if (!token.transfer(msg.sender, stake.amount)) {\\n            revert TransferFailed();\\n        }\\n        emit ClaimedStakedAmount(msg.sender, stake.amount);\\n    }\\n\\n    function claim(uint256 _index) public recalculateEarnings {\\n        Stake storage stake = _getStake(msg.sender, _index);\\n        _checkStake(stake);\\n        uint256 reward = calculateReward(msg.sender, _index);\\n        stake.claimedTime = block.timestamp;\\n        stake.claimedReward += reward;\\n        totalStaked -= stake.amount;\\n        totalUserStaked[msg.sender] -= stake.amount;\\n        if (address(token) == address(rewardToken)) {\\n            if (token.balanceOf(address(this)) < totalStaked + reward + stake.amount) {\\n                revert BalanceNotEnough();\\n            }\\n            if (!token.transfer(msg.sender, stake.amount + reward)) {\\n                revert TransferFailed();\\n            }\\n        } else {\\n            if (!token.transfer(msg.sender, stake.amount)) {\\n                revert TransferFailed();\\n            }\\n            if (!rewardToken.transfer(msg.sender, reward)) {\\n                revert TransferFailed();\\n            }\\n        }\\n\\n        emit Claimed(msg.sender, stake.amount, reward);\\n    }\\n\\n    function getStakes(address _user) public view override returns (Stake[] memory) {\\n        return stakes[_user];\\n    }\\n\\n    function getStakesLen(address _user) external view override returns(uint256) {\\n        return stakes[_user].length;\\n    }\\n\\n    function getUserSummary(address _user) external view override returns(UserData memory) {\\n        StakeView[] memory _stakes = new StakeView[](stakes[_user].length);\\n        uint256 _rewardToClaim = 0;\\n        for(uint256 i = 0; i < stakes[_user].length; ) {\\n            Stake storage s = stakes[_user][i];\\n\\n            uint256 unlockTime = s.lockTime + s.startTime;\\n            uint256 _reward = _calculateReward(s);\\n            _rewardToClaim += _reward;\\n\\n            _stakes[i] = StakeView({\\n                amount: s.amount,\\n                reward: _reward,\\n                timeLeft: block.timestamp < unlockTime ? unlockTime - block.timestamp : 0,\\n                stakeClaimed: s.claimedTime != 0,\\n                contractAddr: address(this),\\n                stakingIndex: i\\n            });\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        return UserData({\\n            stakes: _stakes,\\n            totalStaked: totalUserStaked[_user],\\n            rewardToClaim: _rewardToClaim\\n        });\\n    }\\n\\n    function setOwner(address _owner) public onlyOwnerAccess {\\n        if (_owner == address(0)) {\\n            revert AddressZero();\\n        }\\n        address oldOwner = owner;\\n        owner = _owner;\\n        emit OwnerChanged(oldOwner, owner);\\n    }\\n\\n    function _checkStake(Stake memory stake) internal view {\\n        if (stake.claimedTime > 0) {\\n            revert AlreadyClaimed();\\n        }\\n        if (block.timestamp <= stake.startTime + stake.lockTime) {\\n            revert LocktimeNotPassed();\\n        }\\n    }\\n\\n    function _getStake(address _user, uint256 _index) internal view returns (Stake storage) {\\n        Stake[] storage userStakes = stakes[_user];\\n        if (userStakes.length == 0) {\\n            revert NotParticipated();\\n        }\\n        if (userStakes.length <= _index) {\\n            revert StakeNotExist();\\n        }\\n        Stake storage stake = userStakes[_index];\\n        return stake;\\n    }\\n\\n    function _min(uint256 _a, uint256 _b) internal pure returns (uint256) {\\n        return _a <= _b ? _a : _b;\\n    }\\n\\n    function _getRewardEnd() internal view returns(uint256) {\\n        return _min(block.timestamp, rewardDeadline);\\n    }\\n\\n    function getLockLengths() external view returns (uint256[] memory) {\\n        return lockLengths;\\n    }\\n\\n    function pauseNewStakes() external onlyOwnerAccess {\\n        return _pause();\\n    }\\n\\n    function unpauseNewStakes() external onlyOwnerAccess {\\n        return _unpause();\\n    }\\n\\n    function withdrawReward(uint256 _amount) external onlyOwnerAccess {\\n        if (block.timestamp < rewardDeadline) {\\n            revert StakingInProgress();\\n        }\\n\\n        if (address(token) == address(rewardToken)) {\\n            if (rewardToken.balanceOf(address(this)) < totalStaked + _amount) {\\n                revert BalanceNotEnough();\\n            }\\n\\n        }\\n        if (!rewardToken.transfer(msg.sender, _amount)) {\\n            revert TransferFailed();\\n        }\\n    }\\n\\n    function increaseMaxStakingReward(uint256 _increaseBy) external onlyOwnerAccess {\\n        maximumStakingRewards += _increaseBy;\\n    }\\n\\n    function extendStakingTime(uint256 _newDeadline) external onlyOwnerAccess {\\n        if (_newDeadline <= rewardDeadline) {\\n            revert NotInTheFuture();\\n        }\\n        rewardDeadline = _newDeadline;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardAddress\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_lockLengths\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_percentages\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokensLimits\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_maximumStakingRewards\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AddressZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AlreadyClaimed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BalanceNotEnough\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidLockTime\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LocktimeNotPassed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotInTheFuture\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotParticipated\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyOwnerAccess\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StakeNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StakingInProgress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokensLimitReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TooMuchStakes\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFailed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"ClaimedReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"}],\"name\":\"ClaimedStakedAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockTime\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"}],\"name\":\"TotalRewardsEarned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"apy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"calculateReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"claimReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"claimStakedAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newDeadline\",\"type\":\"uint256\"}],\"name\":\"extendStakingTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLockLengths\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getStakes\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedTime\",\"type\":\"uint256\"}],\"internalType\":\"struct IStaking.Stake[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getStakesLen\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserSummary\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"rewardToClaim\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStaked\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeLeft\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"stakeClaimed\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"contractAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakingIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct IStaking.StakeView[]\",\"name\":\"stakes\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IStaking.UserData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_increaseBy\",\"type\":\"uint256\"}],\"name\":\"increaseMaxStakingReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lockLengths\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maximumStakingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseNewStakes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardDeadline\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lockTime\",\"type\":\"uint256\"}],\"name\":\"stakeTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokensLimits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokensLocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalUserStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpauseNewStakes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateTotalEarningsState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Staking", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000426c1c971fb00caaf1883bd801323a8becb0c919000000000000000000000000426c1c971fb00caaf1883bd801323a8becb0c91900000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000001600000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000165578eecf9d0ffb0000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000076a7000000000000000000000000000000000000000000000000000000000000ed4e000000000000000000000000000000000000000000000000000000000001da9c000000000000000000000000000000000000000000000000000000000001da9c01000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000280000000000000000000000000000000000000000000000000000000000000064000000000000000000000000000000000000000000000000000000000000009600000000000000000000000000000000000000000000000000000000000000c8000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000d3c21bcecceda1000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}