{"SourceCode": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\r\n\r\npragma solidity =0.6.12;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        uint256 c = a + b;\r\n        if (c < a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b > a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) private pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0), \"SafeERC20: approve from non-zero to non-zero allowance\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() internal {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\nabstract contract Pausable is Context {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor() internal {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!paused(), \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(paused(), \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\n/**\r\n * @title OwnerPausable\r\n * @notice An ownable contract allows the owner to pause and unpause the\r\n * contract without a delay.\r\n * @dev Only methods using the provided modifiers will be paused.\r\n */\r\ncontract OwnerPausable is Ownable, Pausable {\r\n    /**\r\n     * @notice Pause the contract. Revert if already paused.\r\n     */\r\n    function pause() external onlyOwner {\r\n        Pausable._pause();\r\n    }\r\n\r\n    /**\r\n     * @notice Unpause the contract. Revert if already unpaused.\r\n     */\r\n    function unpause() external onlyOwner {\r\n        Pausable._unpause();\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\r\n     * a default value of 18.\r\n     *\r\n     * To select a different value for {decimals}, use {_setupDecimals}.\r\n     *\r\n     * All three of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor(string memory name_, string memory symbol_) public {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _decimals = 18;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\r\n     * called.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``sender``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets {decimals} to a value other than the default one of 18.\r\n     *\r\n     * WARNING: This function should only be called from the constructor. Most\r\n     * applications that interact with token contracts will not expect\r\n     * {decimals} to ever change, and may work incorrectly if it does.\r\n     */\r\n    function _setupDecimals(uint8 decimals_) internal virtual {\r\n        _decimals = decimals_;\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be to transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n}\r\n\r\n/**\r\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\r\n * tokens and those that they have an allowance for, in a way that can be\r\n * recognized off-chain (via event analysis).\r\n */\r\nabstract contract ERC20Burnable is Context, ERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from the caller.\r\n     *\r\n     * See {ERC20-_burn}.\r\n     */\r\n    function burn(uint256 amount) public virtual {\r\n        _burn(_msgSender(), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\r\n     * allowance.\r\n     *\r\n     * See {ERC20-_burn} and {ERC20-allowance}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have allowance for ``accounts``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function burnFrom(address account, uint256 amount) public virtual {\r\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \"ERC20: burn amount exceeds allowance\");\r\n\r\n        _approve(account, _msgSender(), decreasedAllowance);\r\n        _burn(account, amount);\r\n    }\r\n}\r\n\r\ninterface ISwap {\r\n    // pool data view functions\r\n    function getA() external view returns (uint256);\r\n\r\n    function getToken(uint8 index) external view returns (IERC20);\r\n\r\n    function getTokenIndex(address tokenAddress) external view returns (uint8);\r\n\r\n    function getTokenBalance(uint8 index) external view returns (uint256);\r\n\r\n    function getVirtualPrice() external view returns (uint256);\r\n\r\n    // min return calculation functions\r\n    function calculateSwap(\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx\r\n    ) external view returns (uint256);\r\n\r\n    function calculateTokenAmount(uint256[] calldata amounts, bool deposit) external view returns (uint256);\r\n\r\n    function calculateRemoveLiquidity(uint256 amount) external view returns (uint256[] memory);\r\n\r\n    function calculateRemoveLiquidityOneToken(uint256 tokenAmount, uint8 tokenIndex) external view returns (uint256 availableTokenAmount);\r\n\r\n    // state modifying functions\r\n    function swap(\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx,\r\n        uint256 minDy,\r\n        uint256 deadline\r\n    ) external returns (uint256);\r\n\r\n    function addLiquidity(\r\n        uint256[] calldata amounts,\r\n        uint256 minToMint,\r\n        uint256 deadline,\r\n        bytes32[] calldata merkleProof\r\n    ) external returns (uint256);\r\n\r\n    function removeLiquidity(\r\n        uint256 amount,\r\n        uint256[] calldata minAmounts,\r\n        uint256 deadline\r\n    ) external returns (uint256[] memory);\r\n\r\n    function removeLiquidityOneToken(\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex,\r\n        uint256 minAmount,\r\n        uint256 deadline\r\n    ) external returns (uint256);\r\n\r\n    function removeLiquidityImbalance(\r\n        uint256[] calldata amounts,\r\n        uint256 maxBurnAmount,\r\n        uint256 deadline\r\n    ) external returns (uint256);\r\n\r\n    // withdraw fee update function\r\n    function updateUserWithdrawFee(address recipient, uint256 transferAmount) external;\r\n}\r\n\r\n/**\r\n * @title Liquidity Provider Token\r\n * @notice This token is an ERC20 detailed token with added capability to be minted by the owner.\r\n * It is used to represent user's shares when providing liquidity to swap contracts.\r\n */\r\ncontract LPToken is ERC20Burnable, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    // Address of the swap contract that owns this LP token. When a user adds liquidity to the swap contract,\r\n    // they receive a proportionate amount of this LPToken.\r\n    ISwap public swap;\r\n\r\n    /**\r\n     * @notice Deploys LPToken contract with given name, symbol, and decimals\r\n     * @dev the caller of this constructor will become the owner of this contract\r\n     * @param name_ name of this token\r\n     * @param symbol_ symbol of this token\r\n     * @param decimals_ number of decimals this token will be based on\r\n     */\r\n    constructor(\r\n        string memory name_,\r\n        string memory symbol_,\r\n        uint8 decimals_\r\n    ) public ERC20(name_, symbol_) {\r\n        _setupDecimals(decimals_);\r\n        swap = ISwap(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @notice Mints the given amount of LPToken to the recipient.\r\n     * @dev only owner can call this mint function\r\n     * @param recipient address of account to receive the tokens\r\n     * @param amount amount of tokens to mint\r\n     */\r\n    function mint(address recipient, uint256 amount) external onlyOwner {\r\n        require(amount != 0, \"amount == 0\");\r\n        _mint(recipient, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Overrides ERC20._beforeTokenTransfer() which get called on every transfers including\r\n     * minting and burning. This ensures that swap.updateUserWithdrawFees are called everytime.\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal override(ERC20) {\r\n        super._beforeTokenTransfer(from, to, amount);\r\n        swap.updateUserWithdrawFee(to, amount);\r\n    }\r\n}\r\n\r\n/**\r\n * @title MathUtils library\r\n * @notice A library to be used in conjunction with SafeMath. Contains functions for calculating\r\n * differences between two uint256.\r\n */\r\nlibrary MathUtils {\r\n    /**\r\n     * @notice Compares a and b and returns true if the difference between a and b\r\n     *         is less than 1 or equal to each other.\r\n     * @param a uint256 to compare with\r\n     * @param b uint256 to compare with\r\n     * @return True if the difference between a and b is less than 1 or equal,\r\n     *         otherwise return false\r\n     */\r\n    function within1(uint256 a, uint256 b) external pure returns (bool) {\r\n        return (_difference(a, b) <= 1);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates absolute difference between a and b\r\n     * @param a uint256 to compare with\r\n     * @param b uint256 to compare with\r\n     * @return Difference between a and b\r\n     */\r\n    function difference(uint256 a, uint256 b) external pure returns (uint256) {\r\n        return _difference(a, b);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates absolute difference between a and b\r\n     * @param a uint256 to compare with\r\n     * @param b uint256 to compare with\r\n     * @return Difference between a and b\r\n     */\r\n    function _difference(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a > b) {\r\n            return a - b;\r\n        }\r\n        return b - a;\r\n    }\r\n}\r\n\r\n/**\r\n * @title SwapUtils library\r\n * @notice A library to be used within Swap.sol. Contains functions responsible for custody and AMM functionalities.\r\n * @dev Contracts relying on this library must initialize SwapUtils.Swap struct then use this library\r\n * for SwapUtils.Swap struct. Note that this library contains both functions called by users and admins.\r\n * Admin functions should be protected within contracts using this library.\r\n */\r\nlibrary SwapUtils {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n    using MathUtils for uint256;\r\n\r\n    /*** EVENTS ***/\r\n\r\n    event TokenSwap(address indexed buyer, uint256 tokensSold, uint256 tokensBought, uint128 soldId, uint128 boughtId);\r\n    event AddLiquidity(address indexed provider, uint256[] tokenAmounts, uint256[] fees, uint256 invariant, uint256 lpTokenSupply);\r\n    event RemoveLiquidity(address indexed provider, uint256[] tokenAmounts, uint256 lpTokenSupply);\r\n    event RemoveLiquidityOne(address indexed provider, uint256 lpTokenAmount, uint256 lpTokenSupply, uint256 boughtId, uint256 tokensBought);\r\n    event RemoveLiquidityImbalance(address indexed provider, uint256[] tokenAmounts, uint256[] fees, uint256 invariant, uint256 lpTokenSupply);\r\n    event CollectProtocolFee(address token, uint256 amount);\r\n    event NewAdminFee(uint256 newAdminFee);\r\n    event NewSwapFee(uint256 newSwapFee);\r\n    event NewWithdrawFee(uint256 newWithdrawFee);\r\n    event RampA(uint256 oldA, uint256 newA, uint256 initialTime, uint256 futureTime);\r\n    event StopRampA(uint256 currentA, uint256 time);\r\n\r\n    struct Swap {\r\n        // variables around the ramp management of A,\r\n        // the amplification coefficient * n * (n - 1)\r\n        // see https://www.curve.fi/stableswap-paper.pdf for details\r\n        uint256 initialA;\r\n        uint256 futureA;\r\n        uint256 initialATime;\r\n        uint256 futureATime;\r\n        // fee calculation\r\n        uint256 swapFee;\r\n        uint256 adminFee;\r\n        uint256 defaultWithdrawFee;\r\n        LPToken lpToken;\r\n        // contract references for all tokens being pooled\r\n        IERC20[] pooledTokens;\r\n        // multipliers for each pooled token's precision to get to POOL_PRECISION_DECIMALS\r\n        // for example, TBTC has 18 decimals, so the multiplier should be 1. WBTC\r\n        // has 8, so the multiplier should be 10 ** 18 / 10 ** 8 => 10 ** 10\r\n        uint256[] tokenPrecisionMultipliers;\r\n        // the pool balance of each token, in the token's precision\r\n        // the contract's actual token balance might differ\r\n        uint256[] balances;\r\n        mapping(address => uint256) depositTimestamp;\r\n        mapping(address => uint256) withdrawFeeMultiplier;\r\n    }\r\n\r\n    // Struct storing variables used in calculations in the\r\n    // calculateWithdrawOneTokenDY function to avoid stack too deep errors\r\n    struct CalculateWithdrawOneTokenDYInfo {\r\n        uint256 d0;\r\n        uint256 d1;\r\n        uint256 newY;\r\n        uint256 feePerToken;\r\n        uint256 preciseA;\r\n    }\r\n\r\n    // Struct storing variables used in calculation in addLiquidity function\r\n    // to avoid stack too deep error\r\n    struct AddLiquidityInfo {\r\n        uint256 d0;\r\n        uint256 d1;\r\n        uint256 d2;\r\n        uint256 preciseA;\r\n    }\r\n\r\n    // Struct storing variables used in calculation in removeLiquidityImbalance function\r\n    // to avoid stack too deep error\r\n    struct RemoveLiquidityImbalanceInfo {\r\n        uint256 d0;\r\n        uint256 d1;\r\n        uint256 d2;\r\n        uint256 preciseA;\r\n    }\r\n\r\n    // the precision all pools tokens will be converted to\r\n    uint8 public constant POOL_PRECISION_DECIMALS = 18;\r\n\r\n    // the denominator used to calculate admin and LP fees. For example, an\r\n    // LP fee might be something like tradeAmount.mul(fee).div(FEE_DENOMINATOR)\r\n    uint256 private constant FEE_DENOMINATOR = 10**10;\r\n\r\n    // Max swap fee is 1% or 100bps of each swap\r\n    uint256 public constant MAX_SWAP_FEE = 10**8;\r\n\r\n    // Max adminFee is 100% of the swapFee\r\n    // adminFee does not add additional fee on top of swapFee\r\n    // Instead it takes a certain % of the swapFee. Therefore it has no impact on the\r\n    // users but only on the earnings of LPs\r\n    uint256 public constant MAX_ADMIN_FEE = 10**10;\r\n\r\n    // Max withdrawFee is 1% of the value withdrawn\r\n    // Fee will be redistributed to the LPs in the pool, rewarding\r\n    // long term providers.\r\n    uint256 public constant MAX_WITHDRAW_FEE = 10**8;\r\n\r\n    // Constant value used as max loop limit\r\n    uint256 private constant MAX_LOOP_LIMIT = 256;\r\n\r\n    // Constant values used in ramping A calculations\r\n    uint256 public constant A_PRECISION = 100;\r\n    uint256 public constant MAX_A = 10**6;\r\n    uint256 private constant MAX_A_CHANGE = 2;\r\n    uint256 private constant MIN_RAMP_TIME = 14 days;\r\n\r\n    /*** VIEW & PURE FUNCTIONS ***/\r\n\r\n    /**\r\n     * @notice Return A, the amplification coefficient * n * (n - 1)\r\n     * @dev See the StableSwap paper for details\r\n     * @param self Swap struct to read from\r\n     * @return A parameter\r\n     */\r\n    function getA(Swap storage self) external view returns (uint256) {\r\n        return _getA(self);\r\n    }\r\n\r\n    /**\r\n     * @notice Return A, the amplification coefficient * n * (n - 1)\r\n     * @dev See the StableSwap paper for details\r\n     * @param self Swap struct to read from\r\n     * @return A parameter\r\n     */\r\n    function _getA(Swap storage self) internal view returns (uint256) {\r\n        return _getAPrecise(self).div(A_PRECISION);\r\n    }\r\n\r\n    /**\r\n     * @notice Return A in its raw precision\r\n     * @dev See the StableSwap paper for details\r\n     * @param self Swap struct to read from\r\n     * @return A parameter in its raw precision form\r\n     */\r\n    function getAPrecise(Swap storage self) external view returns (uint256) {\r\n        return _getAPrecise(self);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates and returns A based on the ramp settings\r\n     * @dev See the StableSwap paper for details\r\n     * @param self Swap struct to read from\r\n     * @return A parameter in its raw precision form\r\n     */\r\n    function _getAPrecise(Swap storage self) internal view returns (uint256) {\r\n        uint256 t1 = self.futureATime; // time when ramp is finished\r\n        uint256 a1 = self.futureA; // final A value when ramp is finished\r\n\r\n        if (block.timestamp < t1) {\r\n            uint256 t0 = self.initialATime; // time when ramp is started\r\n            uint256 a0 = self.initialA; // initial A value when ramp is started\r\n            if (a1 > a0) {\r\n                // a0 + (a1 - a0) * (block.timestamp - t0) / (t1 - t0)\r\n                return a0.add(a1.sub(a0).mul(block.timestamp.sub(t0)).div(t1.sub(t0)));\r\n            } else {\r\n                // a0 - (a0 - a1) * (block.timestamp - t0) / (t1 - t0)\r\n                return a0.sub(a0.sub(a1).mul(block.timestamp.sub(t0)).div(t1.sub(t0)));\r\n            }\r\n        } else {\r\n            return a1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves the timestamp of last deposit made by the given address\r\n     * @param self Swap struct to read from\r\n     * @return timestamp of last deposit\r\n     */\r\n    function getDepositTimestamp(Swap storage self, address user) external view returns (uint256) {\r\n        return self.depositTimestamp[user];\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the dy, the amount of selected token that user receives and\r\n     * the fee of withdrawing in one token\r\n     * @param account the address that is withdrawing\r\n     * @param tokenAmount the amount to withdraw in the pool's precision\r\n     * @param tokenIndex which token will be withdrawn\r\n     * @param self Swap struct to read from\r\n     * @return the amount of token user will receive and the associated swap fee\r\n     */\r\n    function calculateWithdrawOneToken(\r\n        Swap storage self,\r\n        address account,\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex\r\n    ) public view returns (uint256, uint256) {\r\n        uint256 dy;\r\n        uint256 newY;\r\n\r\n        (dy, newY) = calculateWithdrawOneTokenDY(self, tokenIndex, tokenAmount);\r\n\r\n        // dy_0 (without fees)\r\n        // dy, dy_0 - dy\r\n\r\n        uint256 dySwapFee = _xp(self)[tokenIndex].sub(newY).div(self.tokenPrecisionMultipliers[tokenIndex]).sub(dy);\r\n\r\n        dy = dy.mul(FEE_DENOMINATOR.sub(calculateCurrentWithdrawFee(self, account))).div(FEE_DENOMINATOR);\r\n\r\n        return (dy, dySwapFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the dy of withdrawing in one token\r\n     * @param self Swap struct to read from\r\n     * @param tokenIndex which token will be withdrawn\r\n     * @param tokenAmount the amount to withdraw in the pools precision\r\n     * @return the d and the new y after withdrawing one token\r\n     */\r\n    function calculateWithdrawOneTokenDY(\r\n        Swap storage self,\r\n        uint8 tokenIndex,\r\n        uint256 tokenAmount\r\n    ) internal view returns (uint256, uint256) {\r\n        require(tokenIndex < self.pooledTokens.length, \"Token index out of range\");\r\n\r\n        // Get the current D, then solve the stableswap invariant\r\n        // y_i for D - tokenAmount\r\n        uint256[] memory xp = _xp(self);\r\n        CalculateWithdrawOneTokenDYInfo memory v = CalculateWithdrawOneTokenDYInfo(0, 0, 0, 0, 0);\r\n        v.preciseA = _getAPrecise(self);\r\n        v.d0 = getD(xp, v.preciseA);\r\n        v.d1 = v.d0.sub(tokenAmount.mul(v.d0).div(self.lpToken.totalSupply()));\r\n\r\n        require(tokenAmount <= xp[tokenIndex], \"Withdraw exceeds available\");\r\n\r\n        v.newY = getYD(v.preciseA, tokenIndex, xp, v.d1);\r\n\r\n        uint256[] memory xpReduced = new uint256[](xp.length);\r\n\r\n        v.feePerToken = _feePerToken(self);\r\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\r\n            uint256 xpi = xp[i];\r\n            // if i == tokenIndex, dxExpected = xp[i] * d1 / d0 - newY\r\n            // else dxExpected = xp[i] - (xp[i] * d1 / d0)\r\n            // xpReduced[i] -= dxExpected * fee / FEE_DENOMINATOR\r\n            xpReduced[i] = xpi.sub(((i == tokenIndex) ? xpi.mul(v.d1).div(v.d0).sub(v.newY) : xpi.sub(xpi.mul(v.d1).div(v.d0))).mul(v.feePerToken).div(FEE_DENOMINATOR));\r\n        }\r\n\r\n        uint256 dy = xpReduced[tokenIndex].sub(getYD(v.preciseA, tokenIndex, xpReduced, v.d1));\r\n        dy = dy.sub(1).div(self.tokenPrecisionMultipliers[tokenIndex]);\r\n\r\n        return (dy, v.newY);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the price of a token in the pool with given\r\n     * precision-adjusted balances and a particular D.\r\n     *\r\n     * @dev This is accomplished via solving the invariant iteratively.\r\n     * See the StableSwap paper and Curve.fi implementation for further details.\r\n     *\r\n     * x_1**2 + x1 * (sum' - (A*n**n - 1) * D / (A * n**n)) = D ** (n + 1) / (n ** (2 * n) * prod' * A)\r\n     * x_1**2 + b*x_1 = c\r\n     * x_1 = (x_1**2 + c) / (2*x_1 + b)\r\n     *\r\n     * @param a the amplification coefficient * n * (n - 1). See the StableSwap paper for details.\r\n     * @param tokenIndex Index of token we are calculating for.\r\n     * @param xp a precision-adjusted set of pool balances. Array should be\r\n     * the same cardinality as the pool.\r\n     * @param d the stableswap invariant\r\n     * @return the price of the token, in the same precision as in xp\r\n     */\r\n    function getYD(\r\n        uint256 a,\r\n        uint8 tokenIndex,\r\n        uint256[] memory xp,\r\n        uint256 d\r\n    ) internal pure returns (uint256) {\r\n        uint256 numTokens = xp.length;\r\n        require(tokenIndex < numTokens, \"Token not found\");\r\n\r\n        uint256 c = d;\r\n        uint256 s;\r\n        uint256 nA = a.mul(numTokens);\r\n\r\n        for (uint256 i = 0; i < numTokens; i++) {\r\n            if (i != tokenIndex) {\r\n                s = s.add(xp[i]);\r\n                c = c.mul(d).div(xp[i].mul(numTokens));\r\n                // If we were to protect the division loss we would have to keep the denominator separate\r\n                // and divide at the end. However this leads to overflow with large numTokens or/and D.\r\n                // c = c * D * D * D * ... overflow!\r\n            }\r\n        }\r\n        c = c.mul(d).mul(A_PRECISION).div(nA.mul(numTokens));\r\n\r\n        uint256 b = s.add(d.mul(A_PRECISION).div(nA));\r\n        uint256 yPrev;\r\n        uint256 y = d;\r\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\r\n            yPrev = y;\r\n            y = y.mul(y).add(c).div(y.mul(2).add(b).sub(d));\r\n            if (y.within1(yPrev)) {\r\n                return y;\r\n            }\r\n        }\r\n        revert(\"Approximation did not converge\");\r\n    }\r\n\r\n    /**\r\n     * @notice Get D, the StableSwap invariant, based on a set of balances and a particular A.\r\n     * @param xp a precision-adjusted set of pool balances. Array should be the same cardinality\r\n     * as the pool.\r\n     * @param a the amplification coefficient * n * (n - 1) in A_PRECISION.\r\n     * See the StableSwap paper for details\r\n     * @return the invariant, at the precision of the pool\r\n     */\r\n    function getD(uint256[] memory xp, uint256 a) internal pure returns (uint256) {\r\n        uint256 numTokens = xp.length;\r\n        uint256 s;\r\n        for (uint256 i = 0; i < numTokens; i++) {\r\n            s = s.add(xp[i]);\r\n        }\r\n        if (s == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 prevD;\r\n        uint256 d = s;\r\n        uint256 nA = a.mul(numTokens);\r\n\r\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\r\n            uint256 dP = d;\r\n            for (uint256 j = 0; j < numTokens; j++) {\r\n                dP = dP.mul(d).div(xp[j].mul(numTokens));\r\n                // If we were to protect the division loss we would have to keep the denominator separate\r\n                // and divide at the end. However this leads to overflow with large numTokens or/and D.\r\n                // dP = dP * D * D * D * ... overflow!\r\n            }\r\n            prevD = d;\r\n            d = nA.mul(s).div(A_PRECISION).add(dP.mul(numTokens)).mul(d).div(nA.sub(A_PRECISION).mul(d).div(A_PRECISION).add(numTokens.add(1).mul(dP)));\r\n            if (d.within1(prevD)) {\r\n                return d;\r\n            }\r\n        }\r\n\r\n        // Convergence should occur in 4 loops or less. If this is reached, there may be something wrong\r\n        // with the pool. If this were to occur repeatedly, LPs should withdraw via `removeLiquidity()`\r\n        // function which does not rely on D.\r\n        revert(\"D does not converge\");\r\n    }\r\n\r\n    /**\r\n     * @notice Get D, the StableSwap invariant, based on self Swap struct\r\n     * @param self Swap struct to read from\r\n     * @return The invariant, at the precision of the pool\r\n     */\r\n    function getD(Swap storage self) internal view returns (uint256) {\r\n        return getD(_xp(self), _getAPrecise(self));\r\n    }\r\n\r\n    /**\r\n     * @notice Given a set of balances and precision multipliers, return the\r\n     * precision-adjusted balances.\r\n     *\r\n     * @param balances an array of token balances, in their native precisions.\r\n     * These should generally correspond with pooled tokens.\r\n     *\r\n     * @param precisionMultipliers an array of multipliers, corresponding to\r\n     * the amounts in the balances array. When multiplied together they\r\n     * should yield amounts at the pool's precision.\r\n     *\r\n     * @return an array of amounts \"scaled\" to the pool's precision\r\n     */\r\n    function _xp(uint256[] memory balances, uint256[] memory precisionMultipliers) internal pure returns (uint256[] memory) {\r\n        uint256 numTokens = balances.length;\r\n        require(numTokens == precisionMultipliers.length, \"Balances must match multipliers\");\r\n        uint256[] memory xp = new uint256[](numTokens);\r\n        for (uint256 i = 0; i < numTokens; i++) {\r\n            xp[i] = balances[i].mul(precisionMultipliers[i]);\r\n        }\r\n        return xp;\r\n    }\r\n\r\n    /**\r\n     * @notice Return the precision-adjusted balances of all tokens in the pool\r\n     * @param self Swap struct to read from\r\n     * @param balances array of balances to scale\r\n     * @return balances array \"scaled\" to the pool's precision, allowing\r\n     * them to be more easily compared.\r\n     */\r\n    function _xp(Swap storage self, uint256[] memory balances) internal view returns (uint256[] memory) {\r\n        return _xp(balances, self.tokenPrecisionMultipliers);\r\n    }\r\n\r\n    /**\r\n     * @notice Return the precision-adjusted balances of all tokens in the pool\r\n     * @param self Swap struct to read from\r\n     * @return the pool balances \"scaled\" to the pool's precision, allowing\r\n     * them to be more easily compared.\r\n     */\r\n    function _xp(Swap storage self) internal view returns (uint256[] memory) {\r\n        return _xp(self.balances, self.tokenPrecisionMultipliers);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the virtual price, to help calculate profit\r\n     * @param self Swap struct to read from\r\n     * @return the virtual price, scaled to precision of POOL_PRECISION_DECIMALS\r\n     */\r\n    function getVirtualPrice(Swap storage self) external view returns (uint256) {\r\n        uint256 d = getD(_xp(self), _getAPrecise(self));\r\n        uint256 supply = self.lpToken.totalSupply();\r\n        if (supply > 0) {\r\n            return d.mul(10**uint256(ERC20(self.lpToken).decimals())).div(supply);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the new balances of the tokens given the indexes of the token\r\n     * that is swapped from (FROM) and the token that is swapped to (TO).\r\n     * This function is used as a helper function to calculate how much TO token\r\n     * the user should receive on swap.\r\n     *\r\n     * @param self Swap struct to read from\r\n     * @param tokenIndexFrom index of FROM token\r\n     * @param tokenIndexTo index of TO token\r\n     * @param x the new total amount of FROM token\r\n     * @param xp balances of the tokens in the pool\r\n     * @return the amount of TO token that should remain in the pool\r\n     */\r\n    function getY(\r\n        Swap storage self,\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 x,\r\n        uint256[] memory xp\r\n    ) internal view returns (uint256) {\r\n        uint256 numTokens = self.pooledTokens.length;\r\n        require(tokenIndexFrom != tokenIndexTo, \"Can't compare token to itself\");\r\n        require(tokenIndexFrom < numTokens && tokenIndexTo < numTokens, \"Tokens must be in pool\");\r\n\r\n        uint256 a = _getAPrecise(self);\r\n        uint256 d = getD(xp, a);\r\n        uint256 c = d;\r\n        uint256 s;\r\n        uint256 nA = numTokens.mul(a);\r\n\r\n        uint256 _x;\r\n        for (uint256 i = 0; i < numTokens; i++) {\r\n            if (i == tokenIndexFrom) {\r\n                _x = x;\r\n            } else if (i != tokenIndexTo) {\r\n                _x = xp[i];\r\n            } else {\r\n                continue;\r\n            }\r\n            s = s.add(_x);\r\n            c = c.mul(d).div(_x.mul(numTokens));\r\n            // If we were to protect the division loss we would have to keep the denominator separate\r\n            // and divide at the end. However this leads to overflow with large numTokens or/and D.\r\n            // c = c * D * D * D * ... overflow!\r\n        }\r\n        c = c.mul(d).mul(A_PRECISION).div(nA.mul(numTokens));\r\n        uint256 b = s.add(d.mul(A_PRECISION).div(nA));\r\n        uint256 yPrev;\r\n        uint256 y = d;\r\n\r\n        // iterative approximation\r\n        for (uint256 i = 0; i < MAX_LOOP_LIMIT; i++) {\r\n            yPrev = y;\r\n            y = y.mul(y).add(c).div(y.mul(2).add(b).sub(d));\r\n            if (y.within1(yPrev)) {\r\n                return y;\r\n            }\r\n        }\r\n        revert(\"Approximation did not converge\");\r\n    }\r\n\r\n    /**\r\n     * @notice Externally calculates a swap between two tokens.\r\n     * @param self Swap struct to read from\r\n     * @param tokenIndexFrom the token to sell\r\n     * @param tokenIndexTo the token to buy\r\n     * @param dx the number of tokens to sell. If the token charges a fee on transfers,\r\n     * use the amount that gets transferred after the fee.\r\n     * @return dy the number of tokens the user will get\r\n     */\r\n    function calculateSwap(\r\n        Swap storage self,\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx\r\n    ) external view returns (uint256 dy) {\r\n        (dy, ) = _calculateSwap(self, tokenIndexFrom, tokenIndexTo, dx);\r\n    }\r\n\r\n    /**\r\n     * @notice Internally calculates a swap between two tokens.\r\n     *\r\n     * @dev The caller is expected to transfer the actual amounts (dx and dy)\r\n     * using the token contracts.\r\n     *\r\n     * @param self Swap struct to read from\r\n     * @param tokenIndexFrom the token to sell\r\n     * @param tokenIndexTo the token to buy\r\n     * @param dx the number of tokens to sell. If the token charges a fee on transfers,\r\n     * use the amount that gets transferred after the fee.\r\n     * @return dy the number of tokens the user will get\r\n     * @return dyFee the associated fee\r\n     */\r\n    function _calculateSwap(\r\n        Swap storage self,\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx\r\n    ) internal view returns (uint256 dy, uint256 dyFee) {\r\n        uint256[] memory xp = _xp(self);\r\n        require(tokenIndexFrom < xp.length && tokenIndexTo < xp.length, \"Token index out of range\");\r\n        uint256 x = dx.mul(self.tokenPrecisionMultipliers[tokenIndexFrom]).add(xp[tokenIndexFrom]);\r\n        uint256 y = getY(self, tokenIndexFrom, tokenIndexTo, x, xp);\r\n        dy = xp[tokenIndexTo].sub(y).sub(1);\r\n        dyFee = dy.mul(self.swapFee).div(FEE_DENOMINATOR);\r\n        dy = dy.sub(dyFee).div(self.tokenPrecisionMultipliers[tokenIndexTo]);\r\n    }\r\n\r\n    /**\r\n     * @notice A simple method to calculate amount of each underlying\r\n     * tokens that is returned upon burning given amount of\r\n     * LP tokens\r\n     *\r\n     * @param account the address that is removing liquidity. required for withdraw fee calculation\r\n     * @param amount the amount of LP tokens that would to be burned on\r\n     * withdrawal\r\n     * @return array of amounts of tokens user will receive\r\n     */\r\n    function calculateRemoveLiquidity(\r\n        Swap storage self,\r\n        address account,\r\n        uint256 amount\r\n    ) external view returns (uint256[] memory) {\r\n        return _calculateRemoveLiquidity(self, account, amount);\r\n    }\r\n\r\n    function _calculateRemoveLiquidity(\r\n        Swap storage self,\r\n        address account,\r\n        uint256 amount\r\n    ) internal view returns (uint256[] memory) {\r\n        uint256 totalSupply = self.lpToken.totalSupply();\r\n        require(amount <= totalSupply, \"Cannot exceed total supply\");\r\n\r\n        uint256 feeAdjustedAmount = amount.mul(FEE_DENOMINATOR.sub(calculateCurrentWithdrawFee(self, account))).div(FEE_DENOMINATOR);\r\n\r\n        uint256[] memory amounts = new uint256[](self.pooledTokens.length);\r\n\r\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\r\n            amounts[i] = self.balances[i].mul(feeAdjustedAmount).div(totalSupply);\r\n        }\r\n        return amounts;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the fee that is applied when the given user withdraws.\r\n     * Withdraw fee decays linearly over 4 weeks.\r\n     * @param user address you want to calculate withdraw fee of\r\n     * @return current withdraw fee of the user\r\n     */\r\n    function calculateCurrentWithdrawFee(Swap storage self, address user) public view returns (uint256) {\r\n        uint256 endTime = self.depositTimestamp[user].add(4 weeks);\r\n        if (endTime > block.timestamp) {\r\n            uint256 timeLeftover = endTime.sub(block.timestamp);\r\n            return self.defaultWithdrawFee.mul(self.withdrawFeeMultiplier[user]).mul(timeLeftover).div(4 weeks).div(FEE_DENOMINATOR);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @notice A simple method to calculate prices from deposits or\r\n     * withdrawals, excluding fees but including slippage. This is\r\n     * helpful as an input into the various \"min\" parameters on calls\r\n     * to fight front-running\r\n     *\r\n     * @dev This shouldn't be used outside frontends for user estimates.\r\n     *\r\n     * @param self Swap struct to read from\r\n     * @param account address of the account depositing or withdrawing tokens\r\n     * @param amounts an array of token amounts to deposit or withdrawal,\r\n     * corresponding to pooledTokens. The amount should be in each\r\n     * pooled token's native precision. If a token charges a fee on transfers,\r\n     * use the amount that gets transferred after the fee.\r\n     * @param deposit whether this is a deposit or a withdrawal\r\n     * @return if deposit was true, total amount of lp token that will be minted and if\r\n     * deposit was false, total amount of lp token that will be burned\r\n     */\r\n    function calculateTokenAmount(\r\n        Swap storage self,\r\n        address account,\r\n        uint256[] calldata amounts,\r\n        bool deposit\r\n    ) external view returns (uint256) {\r\n        uint256 numTokens = self.pooledTokens.length;\r\n        uint256 a = _getAPrecise(self);\r\n        uint256 d0 = getD(_xp(self, self.balances), a);\r\n        uint256[] memory balances1 = self.balances;\r\n        for (uint256 i = 0; i < numTokens; i++) {\r\n            if (deposit) {\r\n                balances1[i] = balances1[i].add(amounts[i]);\r\n            } else {\r\n                balances1[i] = balances1[i].sub(amounts[i], \"Cannot withdraw more than available\");\r\n            }\r\n        }\r\n        uint256 d1 = getD(_xp(self, balances1), a);\r\n        uint256 totalSupply = self.lpToken.totalSupply();\r\n\r\n        if (deposit) {\r\n            return d1.sub(d0).mul(totalSupply).div(d0);\r\n        } else {\r\n            return d0.sub(d1).mul(totalSupply).div(d0).mul(FEE_DENOMINATOR).div(FEE_DENOMINATOR.sub(calculateCurrentWithdrawFee(self, account)));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice return accumulated amount of admin fees of the token with given index\r\n     * @param self Swap struct to read from\r\n     * @param index Index of the pooled token\r\n     * @return admin balance in the token's precision\r\n     */\r\n    function getAdminBalance(Swap storage self, uint256 index) external view returns (uint256) {\r\n        require(index < self.pooledTokens.length, \"Token index out of range\");\r\n        return self.pooledTokens[index].balanceOf(address(this)).sub(self.balances[index]);\r\n    }\r\n\r\n    /**\r\n     * @notice internal helper function to calculate fee per token multiplier used in\r\n     * swap fee calculations\r\n     * @param self Swap struct to read from\r\n     */\r\n    function _feePerToken(Swap storage self) internal view returns (uint256) {\r\n        return self.swapFee.mul(self.pooledTokens.length).div(self.pooledTokens.length.sub(1).mul(4));\r\n    }\r\n\r\n    /*** STATE MODIFYING FUNCTIONS ***/\r\n\r\n    /**\r\n     * @notice swap two tokens in the pool\r\n     * @param self Swap struct to read from and write to\r\n     * @param tokenIndexFrom the token the user wants to sell\r\n     * @param tokenIndexTo the token the user wants to buy\r\n     * @param dx the amount of tokens the user wants to sell\r\n     * @param minDy the min amount the user would like to receive, or revert.\r\n     * @return amount of token user received on swap\r\n     */\r\n    function swap(\r\n        Swap storage self,\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx,\r\n        uint256 minDy\r\n    ) external returns (uint256) {\r\n        IERC20 poolTokenFrom = self.pooledTokens[tokenIndexFrom];\r\n        require(dx <= poolTokenFrom.balanceOf(msg.sender), \"Cannot swap more than you own\");\r\n\r\n        // Transfer tokens first to see if a fee was charged on transfer\r\n        uint256 transferredDx;\r\n        {\r\n            uint256 beforeBalance = poolTokenFrom.balanceOf(address(this));\r\n            poolTokenFrom.safeTransferFrom(msg.sender, address(this), dx);\r\n\r\n            // Use the actual transferred amount for AMM math\r\n            transferredDx = poolTokenFrom.balanceOf(address(this)).sub(beforeBalance);\r\n        }\r\n\r\n        (uint256 dy, uint256 dyFee) = _calculateSwap(self, tokenIndexFrom, tokenIndexTo, transferredDx);\r\n        require(dy >= minDy, \"Swap didn't result in min tokens\");\r\n\r\n        uint256 dyAdminFee = dyFee.mul(self.adminFee).div(FEE_DENOMINATOR).div(self.tokenPrecisionMultipliers[tokenIndexTo]);\r\n\r\n        self.balances[tokenIndexFrom] = self.balances[tokenIndexFrom].add(transferredDx);\r\n        self.balances[tokenIndexTo] = self.balances[tokenIndexTo].sub(dy).sub(dyAdminFee);\r\n\r\n        self.pooledTokens[tokenIndexTo].safeTransfer(msg.sender, dy);\r\n\r\n        emit TokenSwap(msg.sender, transferredDx, dy, tokenIndexFrom, tokenIndexTo);\r\n\r\n        return dy;\r\n    }\r\n\r\n    /**\r\n     * @notice Add liquidity to the pool\r\n     * @param self Swap struct to read from and write to\r\n     * @param amounts the amounts of each token to add, in their native precision\r\n     * @param minToMint the minimum LP tokens adding this amount of liquidity\r\n     * should mint, otherwise revert. Handy for front-running mitigation\r\n     * @return amount of LP token user received\r\n     */\r\n    function addLiquidity(\r\n        Swap storage self,\r\n        uint256[] memory amounts,\r\n        uint256 minToMint\r\n    ) external returns (uint256) {\r\n        require(amounts.length == self.pooledTokens.length, \"Amounts must match pooled tokens\");\r\n\r\n        uint256[] memory fees = new uint256[](self.pooledTokens.length);\r\n\r\n        // current state\r\n        AddLiquidityInfo memory v = AddLiquidityInfo(0, 0, 0, 0);\r\n\r\n        LPToken lpToken = self.lpToken;\r\n        if (lpToken.totalSupply() != 0) {\r\n            v.d0 = getD(self);\r\n        }\r\n        uint256[] memory newBalances = self.balances;\r\n\r\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\r\n            require(lpToken.totalSupply() != 0 || amounts[i] > 0, \"Must supply all tokens in pool\");\r\n\r\n            // Transfer tokens first to see if a fee was charged on transfer\r\n            if (amounts[i] != 0) {\r\n                uint256 beforeBalance = self.pooledTokens[i].balanceOf(address(this));\r\n                self.pooledTokens[i].safeTransferFrom(msg.sender, address(this), amounts[i]);\r\n\r\n                // Update the amounts[] with actual transfer amount\r\n                amounts[i] = self.pooledTokens[i].balanceOf(address(this)).sub(beforeBalance);\r\n            }\r\n\r\n            newBalances[i] = self.balances[i].add(amounts[i]);\r\n        }\r\n\r\n        // invariant after change\r\n        v.preciseA = _getAPrecise(self);\r\n        v.d1 = getD(_xp(self, newBalances), v.preciseA);\r\n        require(v.d1 > v.d0, \"D should increase\");\r\n\r\n        // updated to reflect fees and calculate the user's LP tokens\r\n        v.d2 = v.d1;\r\n        if (lpToken.totalSupply() != 0) {\r\n            uint256 feePerToken = _feePerToken(self);\r\n            for (uint256 i = 0; i < self.pooledTokens.length; i++) {\r\n                uint256 idealBalance = v.d1.mul(self.balances[i]).div(v.d0);\r\n                fees[i] = feePerToken.mul(idealBalance.difference(newBalances[i])).div(FEE_DENOMINATOR);\r\n                self.balances[i] = newBalances[i].sub(fees[i].mul(self.adminFee).div(FEE_DENOMINATOR));\r\n                newBalances[i] = newBalances[i].sub(fees[i]);\r\n            }\r\n            v.d2 = getD(_xp(self, newBalances), v.preciseA);\r\n        } else {\r\n            // the initial depositor doesn't pay fees\r\n            self.balances = newBalances;\r\n        }\r\n\r\n        uint256 toMint;\r\n        if (lpToken.totalSupply() == 0) {\r\n            toMint = v.d1;\r\n        } else {\r\n            toMint = v.d2.sub(v.d0).mul(lpToken.totalSupply()).div(v.d0);\r\n        }\r\n\r\n        require(toMint >= minToMint, \"Couldn't mint min requested\");\r\n\r\n        // mint the user's LP tokens\r\n        lpToken.mint(msg.sender, toMint);\r\n\r\n        emit AddLiquidity(msg.sender, amounts, fees, v.d1, lpToken.totalSupply());\r\n\r\n        return toMint;\r\n    }\r\n\r\n    /**\r\n     * @notice Update the withdraw fee for `user`. If the user is currently\r\n     * not providing liquidity in the pool, sets to default value. If not, recalculate\r\n     * the starting withdraw fee based on the last deposit's time & amount relative\r\n     * to the new deposit.\r\n     *\r\n     * @param self Swap struct to read from and write to\r\n     * @param user address of the user depositing tokens\r\n     * @param toMint amount of pool tokens to be minted\r\n     */\r\n    function updateUserWithdrawFee(\r\n        Swap storage self,\r\n        address user,\r\n        uint256 toMint\r\n    ) external {\r\n        _updateUserWithdrawFee(self, user, toMint);\r\n    }\r\n\r\n    function _updateUserWithdrawFee(\r\n        Swap storage self,\r\n        address user,\r\n        uint256 toMint\r\n    ) internal {\r\n        // If token is transferred to address 0 (or burned), don't update the fee.\r\n        if (user == address(0)) {\r\n            return;\r\n        }\r\n        if (self.defaultWithdrawFee == 0) {\r\n            // If current fee is set to 0%, set multiplier to FEE_DENOMINATOR\r\n            self.withdrawFeeMultiplier[user] = FEE_DENOMINATOR;\r\n        } else {\r\n            // Otherwise, calculate appropriate discount based on last deposit amount\r\n            uint256 currentFee = calculateCurrentWithdrawFee(self, user);\r\n            uint256 currentBalance = self.lpToken.balanceOf(user);\r\n\r\n            // ((currentBalance * currentFee) + (toMint * defaultWithdrawFee)) * FEE_DENOMINATOR /\r\n            // ((toMint + currentBalance) * defaultWithdrawFee)\r\n            self.withdrawFeeMultiplier[user] = currentBalance.mul(currentFee).add(toMint.mul(self.defaultWithdrawFee)).mul(FEE_DENOMINATOR).div(\r\n                toMint.add(currentBalance).mul(self.defaultWithdrawFee)\r\n            );\r\n        }\r\n        self.depositTimestamp[user] = block.timestamp;\r\n    }\r\n\r\n    /**\r\n     * @notice Burn LP tokens to remove liquidity from the pool.\r\n     * @dev Liquidity can always be removed, even when the pool is paused.\r\n     * @param self Swap struct to read from and write to\r\n     * @param amount the amount of LP tokens to burn\r\n     * @param minAmounts the minimum amounts of each token in the pool\r\n     * acceptable for this burn. Useful as a front-running mitigation\r\n     * @return amounts of tokens the user received\r\n     */\r\n    function removeLiquidity(\r\n        Swap storage self,\r\n        uint256 amount,\r\n        uint256[] calldata minAmounts\r\n    ) external returns (uint256[] memory) {\r\n        LPToken lpToken = self.lpToken;\r\n        require(amount <= lpToken.balanceOf(msg.sender), \">LP.balanceOf\");\r\n        require(minAmounts.length == self.pooledTokens.length, \"minAmounts must match poolTokens\");\r\n\r\n        uint256[] memory amounts = _calculateRemoveLiquidity(self, msg.sender, amount);\r\n\r\n        for (uint256 i = 0; i < amounts.length; i++) {\r\n            require(amounts[i] >= minAmounts[i], \"amounts[i] < minAmounts[i]\");\r\n            self.balances[i] = self.balances[i].sub(amounts[i]);\r\n            self.pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\r\n        }\r\n\r\n        lpToken.burnFrom(msg.sender, amount);\r\n\r\n        emit RemoveLiquidity(msg.sender, amounts, lpToken.totalSupply());\r\n\r\n        return amounts;\r\n    }\r\n\r\n    /**\r\n     * @notice Remove liquidity from the pool all in one token.\r\n     * @param self Swap struct to read from and write to\r\n     * @param tokenAmount the amount of the lp tokens to burn\r\n     * @param tokenIndex the index of the token you want to receive\r\n     * @param minAmount the minimum amount to withdraw, otherwise revert\r\n     * @return amount chosen token that user received\r\n     */\r\n    function removeLiquidityOneToken(\r\n        Swap storage self,\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex,\r\n        uint256 minAmount\r\n    ) external returns (uint256) {\r\n        LPToken lpToken = self.lpToken;\r\n        uint256 totalSupply = lpToken.totalSupply();\r\n        uint256 numTokens = self.pooledTokens.length;\r\n        require(tokenAmount <= lpToken.balanceOf(msg.sender), \">LP.balanceOf\");\r\n        require(tokenIndex < numTokens, \"Token not found\");\r\n\r\n        uint256 dyFee;\r\n        uint256 dy;\r\n\r\n        (dy, dyFee) = calculateWithdrawOneToken(self, msg.sender, tokenAmount, tokenIndex);\r\n\r\n        require(dy >= minAmount, \"dy < minAmount\");\r\n\r\n        self.balances[tokenIndex] = self.balances[tokenIndex].sub(dy.add(dyFee.mul(self.adminFee).div(FEE_DENOMINATOR)));\r\n        lpToken.burnFrom(msg.sender, tokenAmount);\r\n        self.pooledTokens[tokenIndex].safeTransfer(msg.sender, dy);\r\n\r\n        emit RemoveLiquidityOne(msg.sender, tokenAmount, totalSupply, tokenIndex, dy);\r\n\r\n        return dy;\r\n    }\r\n\r\n    /**\r\n     * @notice Remove liquidity from the pool, weighted differently than the\r\n     * pool's current balances.\r\n     *\r\n     * @param self Swap struct to read from and write to\r\n     * @param amounts how much of each token to withdraw\r\n     * @param maxBurnAmount the max LP token provider is willing to pay to\r\n     * remove liquidity. Useful as a front-running mitigation.\r\n     * @return actual amount of LP tokens burned in the withdrawal\r\n     */\r\n    function removeLiquidityImbalance(\r\n        Swap storage self,\r\n        uint256[] memory amounts,\r\n        uint256 maxBurnAmount\r\n    ) public returns (uint256) {\r\n        require(amounts.length == self.pooledTokens.length, \"Amounts should match pool tokens\");\r\n        require(maxBurnAmount <= self.lpToken.balanceOf(msg.sender) && maxBurnAmount != 0, \">LP.balanceOf\");\r\n\r\n        RemoveLiquidityImbalanceInfo memory v = RemoveLiquidityImbalanceInfo(0, 0, 0, 0);\r\n\r\n        uint256 tokenSupply = self.lpToken.totalSupply();\r\n        uint256 feePerToken = _feePerToken(self);\r\n\r\n        uint256[] memory balances1 = self.balances;\r\n\r\n        v.preciseA = _getAPrecise(self);\r\n        v.d0 = getD(_xp(self), v.preciseA);\r\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\r\n            balances1[i] = balances1[i].sub(amounts[i], \"Cannot withdraw more than available\");\r\n        }\r\n        v.d1 = getD(_xp(self, balances1), v.preciseA);\r\n        uint256[] memory fees = new uint256[](self.pooledTokens.length);\r\n\r\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\r\n            uint256 idealBalance = v.d1.mul(self.balances[i]).div(v.d0);\r\n            uint256 difference = idealBalance.difference(balances1[i]);\r\n            fees[i] = feePerToken.mul(difference).div(FEE_DENOMINATOR);\r\n            self.balances[i] = balances1[i].sub(fees[i].mul(self.adminFee).div(FEE_DENOMINATOR));\r\n            balances1[i] = balances1[i].sub(fees[i]);\r\n        }\r\n\r\n        v.d2 = getD(_xp(self, balances1), v.preciseA);\r\n\r\n        uint256 tokenAmount = v.d0.sub(v.d2).mul(tokenSupply).div(v.d0);\r\n        require(tokenAmount != 0, \"Burnt amount cannot be zero\");\r\n        tokenAmount = tokenAmount.add(1).mul(FEE_DENOMINATOR).div(FEE_DENOMINATOR.sub(calculateCurrentWithdrawFee(self, msg.sender)));\r\n\r\n        require(tokenAmount <= maxBurnAmount, \"tokenAmount > maxBurnAmount\");\r\n\r\n        self.lpToken.burnFrom(msg.sender, tokenAmount);\r\n\r\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\r\n            self.pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\r\n        }\r\n\r\n        emit RemoveLiquidityImbalance(msg.sender, amounts, fees, v.d1, tokenSupply.sub(tokenAmount));\r\n\r\n        return tokenAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice withdraw all admin fees to a given address\r\n     * @param self Swap struct to withdraw fees from\r\n     * @param to Address to send the fees to\r\n     */\r\n    function withdrawAdminFees(Swap storage self, address to) external {\r\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\r\n            IERC20 token = self.pooledTokens[i];\r\n            uint256 balance = token.balanceOf(address(this)).sub(self.balances[i]);\r\n            if (balance != 0) {\r\n                token.safeTransfer(to, balance);\r\n                emit CollectProtocolFee(address(token), balance);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the admin fee\r\n     * @dev adminFee cannot be higher than 100% of the swap fee\r\n     * @param self Swap struct to update\r\n     * @param newAdminFee new admin fee to be applied on future transactions\r\n     */\r\n    function setAdminFee(Swap storage self, uint256 newAdminFee) external {\r\n        require(newAdminFee <= MAX_ADMIN_FEE, \"Fee is too high\");\r\n        self.adminFee = newAdminFee;\r\n\r\n        emit NewAdminFee(newAdminFee);\r\n    }\r\n\r\n    /**\r\n     * @notice update the swap fee\r\n     * @dev fee cannot be higher than 1% of each swap\r\n     * @param self Swap struct to update\r\n     * @param newSwapFee new swap fee to be applied on future transactions\r\n     */\r\n    function setSwapFee(Swap storage self, uint256 newSwapFee) external {\r\n        require(newSwapFee <= MAX_SWAP_FEE, \"Fee is too high\");\r\n        self.swapFee = newSwapFee;\r\n\r\n        emit NewSwapFee(newSwapFee);\r\n    }\r\n\r\n    /**\r\n     * @notice update the default withdraw fee. This also affects deposits made in the past as well.\r\n     * @param self Swap struct to update\r\n     * @param newWithdrawFee new withdraw fee to be applied\r\n     */\r\n    function setDefaultWithdrawFee(Swap storage self, uint256 newWithdrawFee) external {\r\n        require(newWithdrawFee <= MAX_WITHDRAW_FEE, \"Fee is too high\");\r\n        self.defaultWithdrawFee = newWithdrawFee;\r\n\r\n        emit NewWithdrawFee(newWithdrawFee);\r\n    }\r\n\r\n    /**\r\n     * @notice Start ramping up or down A parameter towards given futureA_ and futureTime_\r\n     * Checks if the change is too rapid, and commits the new A value only when it falls under\r\n     * the limit range.\r\n     * @param self Swap struct to update\r\n     * @param futureA_ the new A to ramp towards\r\n     * @param futureTime_ timestamp when the new A should be reached\r\n     */\r\n    function rampA(\r\n        Swap storage self,\r\n        uint256 futureA_,\r\n        uint256 futureTime_\r\n    ) external {\r\n        require(block.timestamp >= self.initialATime.add(1 days), \"Wait 1 day before starting ramp\");\r\n        require(futureTime_ >= block.timestamp.add(MIN_RAMP_TIME), \"Insufficient ramp time\");\r\n        require(futureA_ > 0 && futureA_ < MAX_A, \"futureA_ must be > 0 and < MAX_A\");\r\n\r\n        uint256 initialAPrecise = _getAPrecise(self);\r\n        uint256 futureAPrecise = futureA_.mul(A_PRECISION);\r\n\r\n        if (futureAPrecise < initialAPrecise) {\r\n            require(futureAPrecise.mul(MAX_A_CHANGE) >= initialAPrecise, \"futureA_ is too small\");\r\n        } else {\r\n            require(futureAPrecise <= initialAPrecise.mul(MAX_A_CHANGE), \"futureA_ is too large\");\r\n        }\r\n\r\n        self.initialA = initialAPrecise;\r\n        self.futureA = futureAPrecise;\r\n        self.initialATime = block.timestamp;\r\n        self.futureATime = futureTime_;\r\n\r\n        emit RampA(initialAPrecise, futureAPrecise, block.timestamp, futureTime_);\r\n    }\r\n\r\n    /**\r\n     * @notice Stops ramping A immediately. Once this function is called, rampA()\r\n     * cannot be called for another 24 hours\r\n     * @param self Swap struct to update\r\n     */\r\n    function stopRampA(Swap storage self) external {\r\n        require(self.futureATime > block.timestamp, \"Ramp is already stopped\");\r\n        uint256 currentA = _getAPrecise(self);\r\n\r\n        self.initialA = currentA;\r\n        self.futureA = currentA;\r\n        self.initialATime = block.timestamp;\r\n        self.futureATime = block.timestamp;\r\n\r\n        emit StopRampA(currentA, block.timestamp);\r\n    }\r\n}\r\n\r\ninterface IStableSwapFactory {\r\n    event SwapCreated(IERC20[] pooledTokens, address indexed swap, uint256 length);\r\n    event SetFeeTo(address indexed feeTo);\r\n    event SetFeeToken(address indexed token);\r\n    event SetFeeAmount(uint256 indexed amount);\r\n\r\n    function feeTo() external view returns (address);\r\n\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function allPools(uint256) external view returns (address pool);\r\n\r\n    function isPool(address) external view returns (bool);\r\n\r\n    function allPoolsLength() external view returns (uint256);\r\n\r\n    function isTimelock(address) external view returns (bool);\r\n\r\n    function createPool(\r\n        IERC20[] memory _pooledTokens,\r\n        uint8[] memory decimals,\r\n        string memory lpTokenName,\r\n        string memory lpTokenSymbol,\r\n        uint256 _a,\r\n        uint256 _fee,\r\n        uint256 _adminFee,\r\n        uint256 _withdrawFee,\r\n        uint256 delayTimeLock\r\n    ) external returns (address pool);\r\n\r\n    function setFeeTo(address) external;\r\n\r\n    function setFeeToSetter(address) external;\r\n\r\n    function setFeeToken(address _token) external;\r\n\r\n    function setFeeAmount(uint256 _token) external;\r\n}\r\n\r\n/**\r\n * @title Swap - A StableSwap implementation in solidity.\r\n * @notice This contract is responsible for custody of closely pegged assets (eg. group of stablecoins)\r\n * and automatic market making system. Users become an LP (Liquidity Provider) by depositing their tokens\r\n * in desired ratios for an exchange of the pool token that represents their share of the pool.\r\n * Users can burn pool tokens and withdraw their share of token(s).\r\n *\r\n * Each time a swap between the pooled tokens happens, a set fee incurs which effectively gets\r\n * distributed to the LPs.\r\n *\r\n * In case of emergencies, admin can pause additional deposits, swaps, or single-asset withdraws - which\r\n * stops the ratio of the tokens in the pool from changing.\r\n * Users can always withdraw their tokens via multi-asset withdraws.\r\n *\r\n * @dev Most of the logic is stored as a library `SwapUtils` for the sake of reducing contract's\r\n * deployment size.\r\n */\r\ncontract Swap is OwnerPausable, ReentrancyGuard {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n    using MathUtils for uint256;\r\n    using SwapUtils for SwapUtils.Swap;\r\n\r\n    // Struct storing data responsible for automatic market maker functionalities. In order to\r\n    // access this data, this contract uses SwapUtils library. For more details, see SwapUtils.sol\r\n    SwapUtils.Swap public swapStorage;\r\n\r\n    // Maps token address to an index in the pool. Used to prevent duplicate tokens in the pool.\r\n    // getTokenIndex function also relies on this mapping to retrieve token index.\r\n    mapping(address => uint8) private tokenIndexes;\r\n    address public factory;\r\n\r\n    /*** EVENTS ***/\r\n\r\n    // events replicated from SwapUtils to make the ABI easier for dumb\r\n    // clients\r\n    event TokenSwap(address indexed buyer, uint256 tokensSold, uint256 tokensBought, uint128 soldId, uint128 boughtId);\r\n    event AddLiquidity(address indexed provider, uint256[] tokenAmounts, uint256[] fees, uint256 invariant, uint256 lpTokenSupply);\r\n    event RemoveLiquidity(address indexed provider, uint256[] tokenAmounts, uint256 lpTokenSupply);\r\n    event RemoveLiquidityOne(address indexed provider, uint256 lpTokenAmount, uint256 lpTokenSupply, uint256 boughtId, uint256 tokensBought);\r\n    event RemoveLiquidityImbalance(address indexed provider, uint256[] tokenAmounts, uint256[] fees, uint256 invariant, uint256 lpTokenSupply);\r\n    event CollectProtocolFee(address token, uint256 amount);\r\n    event NewAdminFee(uint256 newAdminFee);\r\n    event NewSwapFee(uint256 newSwapFee);\r\n    event NewWithdrawFee(uint256 newWithdrawFee);\r\n    event RampA(uint256 oldA, uint256 newA, uint256 initialTime, uint256 futureTime);\r\n    event StopRampA(uint256 currentA, uint256 time);\r\n\r\n    /**\r\n     * @notice Deploys this Swap contract with given parameters as default\r\n     * values. This will also deploy a LPToken that represents users\r\n     * LP position. The owner of LPToken will be this contract - which means\r\n     * only this contract is allowed to mint new tokens.\r\n     *\r\n     * @param _pooledTokens an array of ERC20s this pool will accept\r\n     * @param decimals the decimals to use for each pooled token,\r\n     * eg 8 for WBTC. Cannot be larger than POOL_PRECISION_DECIMALS\r\n     * @param lpTokenName the long-form name of the token to be deployed\r\n     * @param lpTokenSymbol the short symbol for the token to be deployed\r\n     * @param _a the amplification coefficient * n * (n - 1). See the\r\n     * StableSwap paper for details\r\n     * @param _fee default swap fee to be initialized with\r\n     * @param _adminFee default adminFee to be initialized with\r\n     * @param _withdrawFee default withdrawFee to be initialized with\r\n     */\r\n    constructor(\r\n        IERC20[] memory _pooledTokens,\r\n        uint8[] memory decimals,\r\n        string memory lpTokenName,\r\n        string memory lpTokenSymbol,\r\n        uint256 _a,\r\n        uint256 _fee,\r\n        uint256 _adminFee,\r\n        uint256 _withdrawFee\r\n    ) public OwnerPausable() ReentrancyGuard() {\r\n        // Check _pooledTokens and precisions parameter\r\n        require(_pooledTokens.length > 1, \"_pooledTokens.length <= 1\");\r\n        require(_pooledTokens.length <= 32, \"_pooledTokens.length > 32\");\r\n        require(_pooledTokens.length == decimals.length, \"_pooledTokens decimals mismatch\");\r\n\r\n        uint256[] memory precisionMultipliers = new uint256[](decimals.length);\r\n\r\n        for (uint8 i = 0; i < _pooledTokens.length; i++) {\r\n            if (i > 0) {\r\n                // Check if index is already used. Check if 0th element is a duplicate.\r\n                require(tokenIndexes[address(_pooledTokens[i])] == 0 && _pooledTokens[0] != _pooledTokens[i], \"Duplicate tokens\");\r\n            }\r\n            require(address(_pooledTokens[i]) != address(0), \"The 0 address isn't an ERC-20\");\r\n            require(decimals[i] <= SwapUtils.POOL_PRECISION_DECIMALS, \"Token decimals exceeds max\");\r\n            precisionMultipliers[i] = 10**uint256(SwapUtils.POOL_PRECISION_DECIMALS).sub(uint256(decimals[i]));\r\n            tokenIndexes[address(_pooledTokens[i])] = i;\r\n        }\r\n\r\n        // Check _a, _fee, _adminFee, _withdrawFee parameters\r\n        require(_a < SwapUtils.MAX_A, \"_a exceeds maximum\");\r\n        require(_fee <= SwapUtils.MAX_SWAP_FEE, \"_fee exceeds maximum\");\r\n        require(_adminFee < SwapUtils.MAX_ADMIN_FEE, \"_adminFee exceeds maximum\");\r\n        require(_withdrawFee <= SwapUtils.MAX_WITHDRAW_FEE, \"_withdrawFee exceeds maximum\");\r\n\r\n        // Initialize swapStorage struct\r\n        swapStorage.lpToken = new LPToken(lpTokenName, lpTokenSymbol, SwapUtils.POOL_PRECISION_DECIMALS);\r\n        swapStorage.pooledTokens = _pooledTokens;\r\n        swapStorage.tokenPrecisionMultipliers = precisionMultipliers;\r\n        swapStorage.balances = new uint256[](_pooledTokens.length);\r\n        swapStorage.initialA = _a.mul(SwapUtils.A_PRECISION);\r\n        swapStorage.futureA = _a.mul(SwapUtils.A_PRECISION);\r\n        swapStorage.initialATime = 0;\r\n        swapStorage.futureATime = 0;\r\n        swapStorage.swapFee = _fee;\r\n        swapStorage.adminFee = _adminFee;\r\n        swapStorage.defaultWithdrawFee = _withdrawFee;\r\n\r\n        // Initialize variables related to guarding the initial deposits\r\n        factory = msg.sender;\r\n    }\r\n\r\n    /*** MODIFIERS ***/\r\n\r\n    /**\r\n     * @notice Modifier to check deadline against current timestamp\r\n     * @param deadline latest timestamp to accept this transaction\r\n     */\r\n    modifier deadlineCheck(uint256 deadline) {\r\n        require(block.timestamp <= deadline, \"Deadline not met\");\r\n        _;\r\n    }\r\n\r\n    /*** VIEW FUNCTIONS ***/\r\n\r\n    /**\r\n     * @notice Return A, the amplification coefficient * n * (n - 1)\r\n     * @dev See the StableSwap paper for details\r\n     * @return A parameter\r\n     */\r\n    function getA() external view returns (uint256) {\r\n        return swapStorage.getA();\r\n    }\r\n\r\n    /**\r\n     * @notice Return A in its raw precision form\r\n     * @dev See the StableSwap paper for details\r\n     * @return A parameter in its raw precision form\r\n     */\r\n    function getAPrecise() external view returns (uint256) {\r\n        return swapStorage.getAPrecise();\r\n    }\r\n\r\n    /**\r\n     * @notice Return address of the pooled token at given index. Reverts if tokenIndex is out of range.\r\n     * @param index the index of the token\r\n     * @return address of the token at given index\r\n     */\r\n    function getToken(uint8 index) public view returns (IERC20) {\r\n        require(index < swapStorage.pooledTokens.length, \"Out of range\");\r\n        return swapStorage.pooledTokens[index];\r\n    }\r\n\r\n    function getTokenLength() public view returns (uint256) {\r\n        return swapStorage.pooledTokens.length;\r\n    }\r\n\r\n    /**\r\n     * @notice Return the index of the given token address. Reverts if no matching\r\n     * token is found.\r\n     * @param tokenAddress address of the token\r\n     * @return the index of the given token address\r\n     */\r\n    function getTokenIndex(address tokenAddress) external view returns (uint8) {\r\n        uint8 index = tokenIndexes[tokenAddress];\r\n        require(address(getToken(index)) == tokenAddress, \"Token does not exist\");\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * @notice Return timestamp of last deposit of given address\r\n     * @return timestamp of the last deposit made by the given address\r\n     */\r\n    function getDepositTimestamp(address user) external view returns (uint256) {\r\n        return swapStorage.getDepositTimestamp(user);\r\n    }\r\n\r\n    /**\r\n     * @notice Return current balance of the pooled token at given index\r\n     * @param index the index of the token\r\n     * @return current balance of the pooled token at given index with token's native precision\r\n     */\r\n    function getTokenBalance(uint8 index) external view returns (uint256) {\r\n        require(index < swapStorage.pooledTokens.length, \"Index out of range\");\r\n        return swapStorage.balances[index];\r\n    }\r\n\r\n    /**\r\n     * @notice Get the virtual price, to help calculate profit\r\n     * @return the virtual price, scaled to the POOL_PRECISION_DECIMALS\r\n     */\r\n    function getVirtualPrice() external view returns (uint256) {\r\n        return swapStorage.getVirtualPrice();\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate amount of tokens you receive on swap\r\n     * @param tokenIndexFrom the token the user wants to sell\r\n     * @param tokenIndexTo the token the user wants to buy\r\n     * @param dx the amount of tokens the user wants to sell. If the token charges\r\n     * a fee on transfers, use the amount that gets transferred after the fee.\r\n     * @return amount of tokens the user will receive\r\n     */\r\n    function calculateSwap(\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx\r\n    ) external view returns (uint256) {\r\n        return swapStorage.calculateSwap(tokenIndexFrom, tokenIndexTo, dx);\r\n    }\r\n\r\n    /**\r\n     * @notice A simple method to calculate prices from deposits or\r\n     * withdrawals, excluding fees but including slippage. This is\r\n     * helpful as an input into the various \"min\" parameters on calls\r\n     * to fight front-running\r\n     *\r\n     * @dev This shouldn't be used outside frontends for user estimates.\r\n     *\r\n     * @param account address that is depositing or withdrawing tokens\r\n     * @param amounts an array of token amounts to deposit or withdrawal,\r\n     * corresponding to pooledTokens. The amount should be in each\r\n     * pooled token's native precision. If a token charges a fee on transfers,\r\n     * use the amount that gets transferred after the fee.\r\n     * @param deposit whether this is a deposit or a withdrawal\r\n     * @return token amount the user will receive\r\n     */\r\n    function calculateTokenAmount(\r\n        address account,\r\n        uint256[] calldata amounts,\r\n        bool deposit\r\n    ) external view returns (uint256) {\r\n        return swapStorage.calculateTokenAmount(account, amounts, deposit);\r\n    }\r\n\r\n    /**\r\n     * @notice A simple method to calculate amount of each underlying\r\n     * tokens that is returned upon burning given amount of LP tokens\r\n     * @param account the address that is withdrawing tokens\r\n     * @param amount the amount of LP tokens that would be burned on withdrawal\r\n     * @return array of token balances that the user will receive\r\n     */\r\n    function calculateRemoveLiquidity(address account, uint256 amount) external view returns (uint256[] memory) {\r\n        return swapStorage.calculateRemoveLiquidity(account, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the amount of underlying token available to withdraw\r\n     * when withdrawing via only single token\r\n     * @param account the address that is withdrawing tokens\r\n     * @param tokenAmount the amount of LP token to burn\r\n     * @param tokenIndex index of which token will be withdrawn\r\n     * @return availableTokenAmount calculated amount of underlying token\r\n     * available to withdraw\r\n     */\r\n    function calculateRemoveLiquidityOneToken(\r\n        address account,\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex\r\n    ) external view returns (uint256 availableTokenAmount) {\r\n        (availableTokenAmount, ) = swapStorage.calculateWithdrawOneToken(account, tokenAmount, tokenIndex);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the fee that is applied when the given user withdraws. The withdraw fee\r\n     * decays linearly over period of 4 weeks. For example, depositing and withdrawing right away\r\n     * will charge you the full amount of withdraw fee. But withdrawing after 4 weeks will charge you\r\n     * no additional fees.\r\n     * @dev returned value should be divided by FEE_DENOMINATOR to convert to correct decimals\r\n     * @param user address you want to calculate withdraw fee of\r\n     * @return current withdraw fee of the user\r\n     */\r\n    function calculateCurrentWithdrawFee(address user) external view returns (uint256) {\r\n        return swapStorage.calculateCurrentWithdrawFee(user);\r\n    }\r\n\r\n    /**\r\n     * @notice This function reads the accumulated amount of admin fees of the token with given index\r\n     * @param index Index of the pooled token\r\n     * @return admin's token balance in the token's precision\r\n     */\r\n    function getAdminBalance(uint256 index) external view returns (uint256) {\r\n        return swapStorage.getAdminBalance(index);\r\n    }\r\n\r\n    /*** STATE MODIFYING FUNCTIONS ***/\r\n\r\n    /**\r\n     * @notice Swap two tokens using this pool\r\n     * @param tokenIndexFrom the token the user wants to swap from\r\n     * @param tokenIndexTo the token the user wants to swap to\r\n     * @param dx the amount of tokens the user wants to swap from\r\n     * @param minDy the min amount the user would like to receive, or revert.\r\n     * @param deadline latest timestamp to accept this transaction\r\n     */\r\n    function swap(\r\n        uint8 tokenIndexFrom,\r\n        uint8 tokenIndexTo,\r\n        uint256 dx,\r\n        uint256 minDy,\r\n        uint256 deadline\r\n    ) external nonReentrant whenNotPaused deadlineCheck(deadline) returns (uint256) {\r\n        return swapStorage.swap(tokenIndexFrom, tokenIndexTo, dx, minDy);\r\n    }\r\n\r\n    /**\r\n     * @notice Add liquidity to the pool with given amounts.\r\n     * @param amounts the amounts of each token to add, in their native precision\r\n     * @param minToMint the minimum LP tokens adding this amount of liquidity\r\n     * should mint, otherwise revert. Handy for front-running mitigation\r\n     * @param deadline latest timestamp to accept this transaction\r\n     * @return amount of LP token user minted and received\r\n     */\r\n    function addLiquidity(\r\n        uint256[] calldata amounts,\r\n        uint256 minToMint,\r\n        uint256 deadline\r\n    ) external nonReentrant whenNotPaused deadlineCheck(deadline) returns (uint256) {\r\n        return swapStorage.addLiquidity(amounts, minToMint);\r\n    }\r\n\r\n    /**\r\n     * @notice Burn LP tokens to remove liquidity from the pool. Withdraw fee that decays linearly\r\n     * over period of 4 weeks since last deposit will apply.\r\n     * @dev Liquidity can always be removed, even when the pool is paused.\r\n     * @param amount the amount of LP tokens to burn\r\n     * @param minAmounts the minimum amounts of each token in the pool\r\n     *        acceptable for this burn. Useful as a front-running mitigation\r\n     * @param deadline latest timestamp to accept this transaction\r\n     * @return amounts of tokens user received\r\n     */\r\n    function removeLiquidity(\r\n        uint256 amount,\r\n        uint256[] calldata minAmounts,\r\n        uint256 deadline\r\n    ) external nonReentrant deadlineCheck(deadline) returns (uint256[] memory) {\r\n        return swapStorage.removeLiquidity(amount, minAmounts);\r\n    }\r\n\r\n    /**\r\n     * @notice Remove liquidity from the pool all in one token. Withdraw fee that decays linearly\r\n     * over period of 4 weeks since last deposit will apply.\r\n     * @param tokenAmount the amount of the token you want to receive\r\n     * @param tokenIndex the index of the token you want to receive\r\n     * @param minAmount the minimum amount to withdraw, otherwise revert\r\n     * @param deadline latest timestamp to accept this transaction\r\n     * @return amount of chosen token user received\r\n     */\r\n    function removeLiquidityOneToken(\r\n        uint256 tokenAmount,\r\n        uint8 tokenIndex,\r\n        uint256 minAmount,\r\n        uint256 deadline\r\n    ) external nonReentrant whenNotPaused deadlineCheck(deadline) returns (uint256) {\r\n        return swapStorage.removeLiquidityOneToken(tokenAmount, tokenIndex, minAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Remove liquidity from the pool, weighted differently than the\r\n     * pool's current balances. Withdraw fee that decays linearly\r\n     * over period of 4 weeks since last deposit will apply.\r\n     * @param amounts how much of each token to withdraw\r\n     * @param maxBurnAmount the max LP token provider is willing to pay to\r\n     * remove liquidity. Useful as a front-running mitigation.\r\n     * @param deadline latest timestamp to accept this transaction\r\n     * @return amount of LP tokens burned\r\n     */\r\n    function removeLiquidityImbalance(\r\n        uint256[] calldata amounts,\r\n        uint256 maxBurnAmount,\r\n        uint256 deadline\r\n    ) external nonReentrant whenNotPaused deadlineCheck(deadline) returns (uint256) {\r\n        return swapStorage.removeLiquidityImbalance(amounts, maxBurnAmount);\r\n    }\r\n\r\n    /*** ADMIN FUNCTIONS ***/\r\n\r\n    /**\r\n     * @notice Updates the user withdraw fee. This function can only be called by\r\n     * the pool token. Should be used to update the withdraw fee on transfer of pool tokens.\r\n     * Transferring your pool token will reset the 4 weeks period. If the recipient is already\r\n     * holding some pool tokens, the withdraw fee will be discounted in respective amounts.\r\n     * @param recipient address of the recipient of pool token\r\n     * @param transferAmount amount of pool token to transfer\r\n     */\r\n    function updateUserWithdrawFee(address recipient, uint256 transferAmount) external {\r\n        require(msg.sender == address(swapStorage.lpToken), \"Only callable by pool token\");\r\n        swapStorage.updateUserWithdrawFee(recipient, transferAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw all admin fees to the fee collector\r\n     */\r\n    function withdrawAdminFees() external {\r\n        address feeTo = IStableSwapFactory(factory).feeTo();\r\n        if (feeTo != address(0)) {\r\n            swapStorage.withdrawAdminFees(feeTo);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Start ramping up or down A parameter towards given futureA and futureTime\r\n     * Checks if the change is too rapid, and commits the new A value only when it falls under\r\n     * the limit range.\r\n     * @param futureA the new A to ramp towards\r\n     * @param futureTime timestamp when the new A should be reached\r\n     */\r\n    function rampA(uint256 futureA, uint256 futureTime) external onlyOwner {\r\n        swapStorage.rampA(futureA, futureTime);\r\n    }\r\n\r\n    /**\r\n     * @notice Stop ramping A immediately. Reverts if ramp A is already stopped.\r\n     */\r\n    function stopRampA() external onlyOwner {\r\n        swapStorage.stopRampA();\r\n    }\r\n}\r\n\r\ninterface ISwapCreator {\r\n    function create(\r\n        IERC20[] memory _pooledTokens,\r\n        uint8[] memory decimals,\r\n        string memory lpTokenName,\r\n        string memory lpTokenSymbol,\r\n        uint256 _a,\r\n        uint256 _fee,\r\n        uint256 _adminFee,\r\n        uint256 _withdrawFee,\r\n        address timeLock\r\n    ) external returns (address);\r\n}\r\n\r\ncontract SwapCreator is ISwapCreator {\r\n    function create(\r\n        IERC20[] memory _pooledTokens,\r\n        uint8[] memory decimals,\r\n        string memory lpTokenName,\r\n        string memory lpTokenSymbol,\r\n        uint256 _a,\r\n        uint256 _fee,\r\n        uint256 _adminFee,\r\n        uint256 _withdrawFee,\r\n        address timeLock\r\n    ) external override returns (address) {\r\n        Swap swap = new Swap(_pooledTokens, decimals, lpTokenName, lpTokenSymbol, _a, _fee, _adminFee, _withdrawFee);\r\n        swap.transferOwnership(timeLock);\r\n\r\n        return address(swap);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"_pooledTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint8[]\",\"name\":\"decimals\",\"type\":\"uint8[]\"},{\"internalType\":\"string\",\"name\":\"lpTokenName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"lpTokenSymbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_adminFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawFee\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenAmounts\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"fees\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"invariant\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpTokenSupply\",\"type\":\"uint256\"}],\"name\":\"AddLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CollectProtocolFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAdminFee\",\"type\":\"uint256\"}],\"name\":\"NewAdminFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSwapFee\",\"type\":\"uint256\"}],\"name\":\"NewSwapFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newWithdrawFee\",\"type\":\"uint256\"}],\"name\":\"NewWithdrawFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"initialTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"futureTime\",\"type\":\"uint256\"}],\"name\":\"RampA\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenAmounts\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpTokenSupply\",\"type\":\"uint256\"}],\"name\":\"RemoveLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"tokenAmounts\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"fees\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"invariant\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpTokenSupply\",\"type\":\"uint256\"}],\"name\":\"RemoveLiquidityImbalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpTokenSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"boughtId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensBought\",\"type\":\"uint256\"}],\"name\":\"RemoveLiquidityOne\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"StopRampA\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensBought\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"soldId\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"boughtId\",\"type\":\"uint128\"}],\"name\":\"TokenSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"minToMint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"calculateCurrentWithdrawFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"calculateRemoveLiquidity\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"tokenIndex\",\"type\":\"uint8\"}],\"name\":\"calculateRemoveLiquidityOneToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"availableTokenAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"tokenIndexFrom\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"tokenIndexTo\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"dx\",\"type\":\"uint256\"}],\"name\":\"calculateSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"deposit\",\"type\":\"bool\"}],\"name\":\"calculateTokenAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getA\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAPrecise\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getAdminBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getDepositTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"}],\"name\":\"getToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"}],\"name\":\"getTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"getTokenIndex\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVirtualPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"futureA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"futureTime\",\"type\":\"uint256\"}],\"name\":\"rampA\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"minAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"maxBurnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityImbalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"tokenIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityOneToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopRampA\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"tokenIndexFrom\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"tokenIndexTo\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"dx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minDy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapStorage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"initialA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"futureA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialATime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"futureATime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"adminFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"defaultWithdrawFee\",\"type\":\"uint256\"},{\"internalType\":\"contract LPToken\",\"name\":\"lpToken\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"transferAmount\",\"type\":\"uint256\"}],\"name\":\"updateUserWithdrawFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAdminFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Swap", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001a00000000000000000000000000000000000000000000000000000000000000240000000000000000000000000000000000000000000000000000000000000028000000000000000000000000000000000000000000000000000000000000000c800000000000000000000000000000000000000000000000000000000003d0900000000000000000000000000000000000000000000000000000000012a05f200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000000000000000000000001af3f329e8be154074d8769d1ffa4ee058b1dbc30000000000000000000000008ac76a51cc950d9822d68b83fe1ad97b32cd580d00000000000000000000000055d398326f99059ff775485246999027b3197955000000000000000000000000e9e7cea3dedca5984780bafc599bd69add087d5600000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000001456616c7565446566692e696f2076446f6c6c6172000000000000000000000000000000000000000000000000000000000000000000000000000000000000000776444f4c4c415200000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "SwapUtils:02818a8256cf93564fab2199de2b13628fca2c39", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e75db5f9d5e59ce374ff364d0d99ae23caf9275e706642bc7353b97ff31903dc"}