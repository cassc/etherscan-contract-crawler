{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.21;\r\n/*               _______            _                     __   _____ \r\n     /\\         |__   __|          | |                   /_ | | ____|\r\n    /  \\   _ __ ___| |_ __ __ _  __| | ___ _ __  __   __  | | | |__  \r\n   / /\\ \\ | '__/ __| | '__/ _` |/ _` |/ _ \\ '__| \\ \\ / /  | | |___ \\ \r\n  / ____ \\| | | (__| | | | (_| | (_| |  __/ |     \\ V /   | |_ ___) |\r\n /_/    \\_\\_|  \\___|_|_|  \\__,_|\\__,_|\\___|_|      \\_/    |_(_)____/ \r\n\r\n  Changes from v 1.4:\r\n\r\n  * Have buy() and sell() return the amount of tokens we will get/need so we can call them statically\r\n    to get both the checksum and the expected result of the buy or sell.\r\n  * Use a better checksum algorithm.\r\n  * Pack the (integer) number of Arc to buy and sell together with the checksum into a single\r\n    parameter. This way we save gas (less input data) and only need one version of sell() and buy().\r\n  * Add a function to sell the specific amount of 100,000 Arc (without checksum, which is safer for\r\n    selling than for buying) to sometimes save even more gas.\r\n  * Some internal refactoring and comment adjustments.\r\n*/\r\n\r\n// Interfaces of external contracts we need to interact with (only the functions we use)\r\ninterface IERC20 {\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n  function balanceOf(address account) external view returns (uint256);\r\n  function symbol() external pure returns (string memory);\r\n  function transferFrom(address sender, address recipient, uint256 amount)\r\n    external returns (bool);\r\n}\r\n\r\ninterface IFactory {\r\n  function getPair(address tokenA, address tokenB, bool stable) external view returns (address);\r\n}\r\n\r\ninterface IPair {\r\n  // The amounts of the two tokens (sorted by address) in the pair\r\n  function getReserves() external view\r\n    returns (uint256 reserve0, uint256 reserve1, uint256 blockTimestampLast);\r\n\r\n  function swap(\r\n    uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;\r\n}\r\n\r\n// Conctract to buy and sell Arc from/to multiple pools in the same transaction\r\ncontract ArcTrader {\r\n  // The Arc token address\r\n  address immutable public Arc;\r\n\r\n  // Address of the Archly pair factory\r\n  address immutable public PairFactory;\r\n\r\n  // The number of tokens that Arc may have pools with\r\n  uint256 immutable public Count;\r\n\r\n  // The tokens that Arc may have pools with (pools with other tokens will be ignored),\r\n  // set once and for all in the constructor. Tokens with transfer tax are not supported.\r\n  address[] public Tokens;\r\n\r\n  // The Arc/Token (or Token/Arc) liquidity pools. This is set in the constructor but may\r\n  // be updated to include newly added pools (with token from the Tokens array) by calling\r\n  // the public function updatePools().\r\n  address[] public Pools;\r\n\r\n  // Used for packing and unpacking parameters to sell() and buy()\r\n  uint256 constant private MAX128 = type(uint128).max;\r\n\r\n  // \"Magic\" value for computing the checksum hash\r\n  uint256 constant private CHECKSUM_MULTIPLIER = 0xbf58476d1ce4e5b9;\r\n\r\n  // The following functions with names beginning with underscores are helper functions to make\r\n  // the contract smaller and more readable.\r\n  function _isStringEqualToArc(string memory symbol) private pure returns (bool) {\r\n    bytes memory b = bytes(symbol);\r\n    if (b.length != 3) {\r\n      return false;\r\n    }\r\n\r\n    return b[0] == 'A' && b[1] == 'r' && b[2] == 'c';\r\n  }\r\n\r\n  // From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/Math.sol\r\n  function _log10(uint256 value) internal pure returns (uint256) {\r\n    uint256 result = 0;\r\n    unchecked {\r\n      if (value >= 10 ** 64) {\r\n        value /= 10 ** 64;\r\n        result += 64;\r\n      }\r\n      if (value >= 10 ** 32) {\r\n        value /= 10 ** 32;\r\n        result += 32;\r\n      }\r\n      if (value >= 10 ** 16) {\r\n        value /= 10 ** 16;\r\n        result += 16;\r\n      }\r\n      if (value >= 10 ** 8) {\r\n        value /= 10 ** 8;\r\n        result += 8;\r\n      }\r\n      if (value >= 10 ** 4) {\r\n        value /= 10 ** 4;\r\n        result += 4;\r\n      }\r\n      if (value >= 10 ** 2) {\r\n        value /= 10 ** 2;\r\n        result += 2;\r\n      }\r\n      if (value >= 10 ** 1) {\r\n        result += 1;\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  // Converts a uint256 to a string representation\r\n  // (Adapted from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Strings.sol)\r\n  bytes16 private constant _DIGITS = \"0123456789\";\r\n  function _toString(uint256 value) internal pure returns (string memory) {\r\n    unchecked {\r\n      uint256 length = _log10(value) + 1;\r\n      string memory buffer = new string(length);\r\n      uint256 ptr;\r\n      /// @solidity memory-safe-assembly\r\n      assembly {\r\n        ptr := add(buffer, add(32, length))\r\n      }\r\n      while (true) {\r\n        ptr--;\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n          mstore8(ptr, byte(mod(value, 10), _DIGITS))\r\n        }\r\n        value /= 10;\r\n        if (value == 0) break;\r\n      }\r\n      return buffer;\r\n    }\r\n  }\r\n\r\n  function _callerAllowance(address token, address spender) private view returns (uint256) {\r\n    return IERC20(token).allowance(msg.sender, spender);\r\n  }\r\n\r\n  function _callerBalanceOf(address token) private view returns (uint256) {\r\n    return IERC20(token).balanceOf(msg.sender);\r\n  }\r\n\r\n  function _transferFromCaller(address token, address to, uint256 amount) private {\r\n    bool success = IERC20(token).transferFrom(msg.sender, to, amount);\r\n\r\n    // Failure here is unexpected because we should have already checked the allowance and balance\r\n    require(success, \"ArcTrader: unexpected token transfer failure\");\r\n  }\r\n\r\n  // Returns a (volatile) pair that token has with Arc, or the zero address if the pool does not exist.\r\n  function _getPairWith(address token) private view returns (address) {\r\n    return IFactory(PairFactory).getPair(Arc, token, false);\r\n  }\r\n\r\n  function _getReserves(address lpToken) private view returns (\r\n    uint256 token0Reserve, uint256 token1Reserve) {\r\n      (token0Reserve, token1Reserve, ) = IPair(lpToken).getReserves();\r\n  }\r\n\r\n  // Returns the Arc reserves for each potential pool (zero for non-existing pools) and the sum of them\r\n  function _getArcReserves() private view returns (uint256[] memory arcReserves, uint256 total) {\r\n    uint256 count = Count;\r\n    arcReserves = new uint256[](count);\r\n    unchecked {\r\n      for (uint256 i = 0; i < count; ++i) {\r\n        if (Pools[i] != address(0)) {\r\n          (uint256 token0Reserve, uint256 token1Reserve) = _getReserves(Pools[i]);\r\n          uint256 arcReserve = (Arc < Tokens[i]) ? token0Reserve : token1Reserve;\r\n          arcReserves[i] = arcReserve;\r\n          total += arcReserve;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function _pairSwapToCaller(address pair, uint256 outAmount0, uint256 outAmount1) private {\r\n    IPair(pair).swap(outAmount0, outAmount1, msg.sender, new bytes(0));\r\n  }\r\n\r\n  function _getToAmount(uint256 fromAmount, uint256 fromReserve, uint256 toReserve)\r\n    private pure returns (uint256) {\r\n\r\n    unchecked {\r\n      // Note that these calculations (originally from UniSwapV2) only work for volatile pairs.\r\n      uint256 fromAmountAfterFee = fromAmount * 9995;  // 0.05% fee\r\n      uint256 numerator = fromAmountAfterFee * toReserve;\r\n      uint256 denominator = (fromReserve * 10000) + fromAmountAfterFee;\r\n      return numerator / denominator;\r\n    }\r\n  }\r\n\r\n  function _getFromAmount(uint256 toAmount, uint256 fromReserve, uint256 toReserve)\r\n    private pure returns (uint256) {\r\n\r\n    unchecked {\r\n      uint256 numerator = fromReserve * toAmount * 10000;\r\n      uint256 denominator = (toReserve - toAmount) * 9995;  // 0.05% fee\r\n      return (numerator / denominator) + 1;\r\n    }\r\n  }\r\n\r\n  // Swaps a specific amount from one token to the other.\r\n  // fromToken and toToken must be the tokens in the pair (not checked here).\r\n  function _swapFromExact(address pair, address fromToken, address toToken, uint256 fromAmount)\r\n    private returns (uint256 toAmount) {\r\n\r\n    (uint256 fromReserve, uint256 toReserve) = _getReserves(pair);\r\n\r\n    bool sorted = fromToken < toToken;\r\n    if (!sorted) {\r\n      (fromReserve, toReserve) = (toReserve, fromReserve);\r\n    }\r\n\r\n    _transferFromCaller(fromToken, pair, fromAmount);\r\n    toAmount = _getToAmount(fromAmount, fromReserve, toReserve);\r\n\r\n    if (sorted) {\r\n      _pairSwapToCaller(pair, 0, toAmount);\r\n    } else {\r\n      _pairSwapToCaller(pair, toAmount, 0);\r\n    }\r\n  }\r\n\r\n  // Swaps from one token to a specific amount of the other.\r\n  // fromToken and toToken must be the tokens in the pair (not checked here).\r\n  function _swapToExact(address pair, address fromToken, address toToken, uint256 toAmount)\r\n    private returns (uint256 fromAmount) {\r\n\r\n    (uint256 fromReserve, uint256 toReserve) = _getReserves(pair);\r\n\r\n    bool sorted = fromToken < toToken;\r\n    if (!sorted) {\r\n      (fromReserve, toReserve) = (toReserve, fromReserve);\r\n    }\r\n\r\n    fromAmount = _getFromAmount(toAmount, fromReserve, toReserve);\r\n\r\n    // Verify the caller's allowance and balance so we can provide descriptive error messages.\r\n    require(_callerAllowance(fromToken, address(this)) >= fromAmount,\r\n      string.concat(string.concat(\r\n        \"ArcTrader: insufficient \", IERC20(fromToken).symbol()), \" allowance\"));\r\n\r\n    require(_callerBalanceOf(fromToken) >= fromAmount, string.concat(\r\n      string.concat(\r\n        \"ArcTrader: insufficient \", IERC20(fromToken).symbol()),\r\n        string.concat(\r\n          \" balance. Needs \", _toString(fromAmount))));\r\n\r\n    _transferFromCaller(fromToken, pair, fromAmount);\r\n    if (sorted) {\r\n      _pairSwapToCaller(pair, 0, toAmount);\r\n    } else {\r\n      _pairSwapToCaller(pair, toAmount, 0);\r\n    }\r\n  }\r\n\r\n  // The constructor sets the Arc token address, the Archly pair factory and all the tokens\r\n  // with which Arc will (potentially) have pools (only volatile pools are considered).\r\n  constructor(address arc, address[] memory tokens, address pairFactory) {\r\n    // Gas optimization is less important here but errors could cause headaches (and be\r\n    // costly) so we include some extra checks with descriptive error messages.\r\n    try IERC20(arc).symbol() returns (string memory symbol) {\r\n      require(_isStringEqualToArc(symbol), string.concat(string.concat(\r\n          \"ArcTrader: Arc token address is the \", symbol), \" token\"));\r\n    } catch {\r\n      revert(\"ArcTrader: invalid Arc token address\");\r\n    }\r\n\r\n    Arc = arc;\r\n\r\n    Count = tokens.length;\r\n    require(Count >= 1, \"ArcTrader: Arc must have a pool with at least one token\");\r\n\r\n    for (uint256 i = 0; i < Count; ++i) {\r\n      require(tokens[i] != arc, \"ArcTrader: Arc cannot have a pair with itself\");\r\n\r\n      try IERC20(tokens[i]).balanceOf(address(this)) { }\r\n      catch {\r\n        revert(\"ArcTrader: one or more token addresses are not valid tokens\");\r\n      }\r\n\r\n      for (uint256 j = 0; j < i; ++j) {\r\n        require(tokens[i] != tokens[j], \"ArcTrader: duplicate token\");\r\n      }\r\n\r\n      Tokens.push(tokens[i]);\r\n      Pools.push(address(0));\r\n    }\r\n\r\n    // Verify that the factory is correct and that the pair for the first token exists.\r\n    PairFactory = pairFactory;\r\n    try IFactory(pairFactory).getPair(Arc, tokens[0], false) returns (address pairAddress) {\r\n      require(pairAddress != address(0), \"ArcTrader: a pool with the first token must exist\");\r\n      Pools[0] = pairAddress;\r\n    } catch {\r\n      revert(\"ArcTrader: invalid pairFactory address\");\r\n    }\r\n\r\n    // Find and save the pool addresses.\r\n    updatePools();\r\n  }\r\n\r\n  // This function is called by the constructor and should also be called externally when\r\n  // needsPoolUpdate() returns true.\r\n  // (This is not done on every call to buy() and sell() because that would waste gas.)\r\n  function updatePools() public {\r\n    uint256 count = Count;\r\n    unchecked {\r\n      // The first pool has been set in the constructor so we start from index 1\r\n      for (uint256 i = 1; i < count; ++i) {\r\n        if (Pools[i] == address(0)) {\r\n          Pools[i] = _getPairWith(Tokens[i]);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // View function that will return true if we should call updatePools() because one or more new pools\r\n  // (with tokens set in the constructor) have been created.\r\n  function needsPoolUpdate() external view returns (bool) {\r\n    uint256 count = Count;\r\n    unchecked {\r\n      for (uint256 i = 1; i < count; ++i) {\r\n        if (Pools[i] == address(0)) {\r\n          if (_getPairWith(Tokens[i]) != address(0)) {\r\n            return true;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  // View function to get all the pool reserves.\r\n  function getAllReserves() external view returns (\r\n    uint256[] memory tokenReserves, uint256[] memory arcReserves) {\r\n\r\n    uint256 count = Count;\r\n    tokenReserves = new uint256[](count);\r\n    arcReserves = new uint256[](count);\r\n\r\n    unchecked {\r\n      for (uint256 i = 0; i < count; ++i) {\r\n        if (Pools[i] != address(0)) {\r\n          (uint256 arcReserve, uint256 tokenReserve) = _getReserves(Pools[i]);\r\n          if (Arc > Tokens[i]) {\r\n            (arcReserve, tokenReserve) = (tokenReserve, arcReserve);\r\n          }\r\n\r\n          tokenReserves[i] = tokenReserve;\r\n          arcReserves[i] = arcReserve;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Sells a specific amount of Arc for the other tokens in the right proportions.\r\n  // The sell amount and desired checksum are packed as two 128-bit values in the parameter, with the\r\n  // amount in integer Arc tokens (i.e. divided by 1e18).\r\n  function sell(uint256 packedParams)\r\n    external returns (uint256 checksum, uint256[] memory tokenAmounts) {\r\n\r\n    uint256 arcSellAmount = (packedParams & MAX128) * 1e18;\r\n    packedParams >>= 128;\r\n    uint256 desiredChecksum = packedParams;\r\n\r\n    return _sell(arcSellAmount, desiredChecksum);\r\n  }\r\n\r\n  // Sells exactly 100,000 Arc (without checksum check).\r\n  function sell100k() external {\r\n    _sell(100000 * 1e18, 0);\r\n  }\r\n\r\n  // Sells ALL the caller's Arc tokens (for convenience and gas savings on chains with expensive input).\r\n  function sellAll() external {\r\n    // Just call _sell() with our full balance and no checksum check.\r\n    _sell(_callerBalanceOf(Arc), 0);\r\n  }\r\n\r\n  // Actual implementation of selling\r\n  function _sell(uint256 arcSellAmount, uint256 desiredChecksum)\r\n    private returns (uint256 checksum, uint256[] memory tokenAmounts) {\r\n\r\n    require(arcSellAmount >= 1e18, \"ArcTrader: cannot sell less than 1 Arc\");\r\n    require(_callerAllowance(Arc, address(this)) >= arcSellAmount,\r\n      \"ArcTrader: insufficient Arc allowance\");\r\n\r\n    // By checking that the caller balance is sufficient we not only can provide a descriptive\r\n    // error message but also safely use unchecked math on arcSellAmount.\r\n    require(_callerBalanceOf(Arc) >= arcSellAmount, \"ArcTrader: insufficient Arc balance\");\r\n\r\n    // Get all the pool Arc reserves and the sum of them.\r\n    (uint256[] memory arcReserves, uint256 totalArcReserve) = _getArcReserves();\r\n\r\n    tokenAmounts = new uint256[](Count);\r\n\r\n    // Compute how many Arc to sell into each pool and perform the swaps.\r\n    uint256 arcSold = 0;\r\n    checksum = 0;\r\n    uint256 count = Count;\r\n\r\n    unchecked {\r\n      // Initially skip the first (always existing) pool; it will be used last.\r\n      for (uint256 i = 1; i < count; ++i) {\r\n        if (arcReserves[i] > 0) {\r\n          uint256 poolSellAmount = arcSellAmount * arcReserves[i] / totalArcReserve;\r\n          if (poolSellAmount >= arcSellAmount / 1000) {\r\n            // Use this pool if the swap amount is at least 0.1% of the total\r\n            uint256 tokenAmount = _swapFromExact(Pools[i], Arc, Tokens[i], poolSellAmount);\r\n            checksum = ((checksum ^ (checksum >> 30)) * CHECKSUM_MULTIPLIER) + tokenAmount;\r\n            arcSold += poolSellAmount;\r\n            tokenAmounts[i] = tokenAmount;\r\n          }\r\n        }\r\n      }\r\n\r\n      // The amount to sell into the first pool is simply what's left (this makes sure the total\r\n      // number of Arc sold is exactly right).\r\n      if (arcSellAmount > arcSold) {\r\n        uint256 tokenAmount = _swapFromExact(Pools[0], Arc, Tokens[0], arcSellAmount - arcSold);\r\n        checksum = ((checksum ^ (checksum >> 30)) * CHECKSUM_MULTIPLIER) + tokenAmount;\r\n        tokenAmounts[0] = tokenAmount;\r\n      }\r\n\r\n      // Truncate checksum to 128 bits\r\n      checksum = checksum & MAX128;\r\n\r\n      // Revert if the checksum (if used) doesn't match. This means that some trade (in either\r\n      // direction, or rarely a liquidity add or remove) happened between the checksum calculation and\r\n      // this transaction.\r\n      require(desiredChecksum == 0 || desiredChecksum == checksum, \"ArcTrader: checksum mismatch\");\r\n    }\r\n  }\r\n\r\n  // Buys a specific amount of Arc (up to half of the existing reserves) using the right amount of all\r\n  // the other tokens.\r\n  // The buy amount and desired checksum are packed as two 128-bit values in the parameter, with the\r\n  // amount in integer Arc tokens (i.e. divided by 1e18).\r\n  // Note that spend approvals must have been given to all tokens (that will actually be used) and the\r\n  // caller must have enough balance of them.\r\n  function buy(uint256 packedParams)\r\n    external returns (uint256 checksum, uint256[] memory tokenAmounts) {\r\n\r\n    uint256 arcBuyAmount = (packedParams & MAX128) * 1e18; packedParams >>= 128;\r\n    uint256 desiredChecksum = packedParams;\r\n\r\n    return _buy(arcBuyAmount, desiredChecksum);\r\n  }\r\n\r\n  function _buy(uint256 arcBuyAmount, uint256 desiredChecksum) \r\n    private returns (uint256 checksum, uint256[] memory tokenAmounts) {\r\n\r\n    require(arcBuyAmount >= 1e18, \"ArcTrader: cannot buy less than 1 Arc\");\r\n\r\n    // Get all the pool reserves and the total amount of Arc reserves.\r\n    (uint256[] memory arcReserves, uint256 totalArcReserve) = _getArcReserves();\r\n\r\n    tokenAmounts = new uint256[](Count);\r\n\r\n    unchecked {\r\n      // By limiting the max amount to half of the total reserves (enough to quadruple the price)\r\n      // we guard against mistakenly buying too much and can use unchecked math.\r\n      require(arcBuyAmount <= totalArcReserve / 2,\r\n        \"ArcTrader: cannot buy more than half the pool reserves\");\r\n\r\n      // Compute how many Arc we want to get from each pool and perform the swaps.\r\n      uint256 arcBought = 0;\r\n      checksum = 0;\r\n      uint256 count = Count;\r\n\r\n      // Initially skip the first (always existing) pool; it will be used last.\r\n      for (uint256 i = 1; i < count; ++i) {\r\n        if (arcReserves[i] > 0) {\r\n          uint256 poolBuyAmount = arcBuyAmount * arcReserves[i] / totalArcReserve;\r\n          if (poolBuyAmount >= arcBuyAmount / 1000) {\r\n            // Use this pool if the swap amount is at least 0.1% of the total\r\n            uint256 tokenAmount = _swapToExact(Pools[i], Tokens[i], Arc, poolBuyAmount);\r\n            checksum = ((checksum ^ (checksum >> 30)) * CHECKSUM_MULTIPLIER) + tokenAmount;\r\n            arcBought += poolBuyAmount;\r\n            tokenAmounts[i] = tokenAmount;\r\n          }\r\n        }\r\n      }\r\n\r\n      // The amount to buy from the first pool is simply what's left (this makes sure the total\r\n      // number of Arc bought is exactly right).\r\n      if (arcBuyAmount > arcBought) {\r\n        uint256 poolBuyAmount = arcBuyAmount - arcBought;\r\n        uint256 tokenAmount = _swapToExact(Pools[0], Tokens[0], Arc, poolBuyAmount);\r\n        checksum = ((checksum ^ (checksum >> 30)) * CHECKSUM_MULTIPLIER) + tokenAmount;\r\n        tokenAmounts[0] = tokenAmount;\r\n      }\r\n\r\n      // Truncate checksum to 128 bits\r\n      checksum = checksum & MAX128;\r\n\r\n      // Revert if the checksum (if used) doesn't match. This means that some trade (in either\r\n      // direction, or rarely a liquidity add or remove) happened between the checksum calculation and\r\n      // this transaction.\r\n      require(desiredChecksum == 0 || desiredChecksum == checksum, \"ArcTrader: checksum mismatch\");\r\n    }\r\n  }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"arc\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"pairFactory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Arc\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Count\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PairFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Pools\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Tokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"packedParams\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"checksum\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenAmounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllReserves\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenReserves\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"arcReserves\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"needsPoolUpdate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"packedParams\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"checksum\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenAmounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sell100k\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updatePools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ArcTrader", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000684802262d614d0cd0c9571672f03dd9e85d78240000000000000000000000000000000000000000000000000000000000000060000000000000000000000000ba06043a777652baf540ccc785edafd94ee05b370000000000000000000000000000000000000000000000000000000000000006000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c000000000000000000000000e9e7cea3dedca5984780bafc599bd69add087d560000000000000000000000008ac76a51cc950d9822d68b83fe1ad97b32cd580d00000000000000000000000055d398326f99059ff775485246999027b31979550000000000000000000000002170ed0880ac9a755fd29b2688956bd959f933f80000000000000000000000007130d2a12b9bcbfae4f2634d864a1ee1ce3ead9c", "EVMVersion": "paris", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://10198762bbfa1fa2cbfcecb18d2cadfaafe1ed7055bb87cafb4572cd2afe1416"}