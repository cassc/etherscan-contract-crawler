{"SourceCode": "{\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.19;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller\\u0027s account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\"},\"Main.sol\":{\"content\":\"//Prebit - Predict Beta Version 0.1\\n\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.19;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n// Interfaces\\n\\ninterface IPrebitReferrals {\\n    function generateReferralCode(uint256 _parentCode) external;\\n\\n    function generateReferralCodeWithContract(\\n        uint256 _parentCode,\\n        address _user\\n    ) external;\\n\\n    function userReferralCode(address _user)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            address,\\n            address,\\n            bool\\n        );\\n\\n    function referralCodeToAddress(uint256 _referralCode)\\n        external\\n        view\\n        returns (address);\\n\\n    function userReferralCodeCheck(address _user) external view returns (bool);\\n\\n    function userReferralCodeToAddress(uint256 _code)\\n        external\\n        view\\n        returns (address);\\n\\n    function getUserTparent(address _user) external view returns (address);\\n\\n    function getUserParent(address _user) external view returns (address);\\n\\n    function isContractAllowed(address _contractAddress)\\n        external\\n        view\\n        returns (bool);\\n}\\n\\ninterface IPrebit {\\n    function injectFundsFromContract(\\n        uint256 _prebitId,\\n        uint256 _amount,\\n        uint256 _row\\n    ) external;\\n\\n    function currentPreBitId() external view returns (uint256);\\n}\\n\\ncontract MainPrebit is Ownable {\\n    using SafeMath for uint256;\\n\\n    // Interfaces\\n    IPrebitReferrals public referralContract;\\n    IERC20 public payToken;\\n\\n    // Addresses\\n    address public injectorAddress;\\n    address public operatorAddress;\\n    address public treasuryAddress;\\n    address public contractInject;\\n\\n\\n    address[] public treasuryWallets;\\n    uint256[] public treasuryPercentages;\\n\\n    // Percents\\n    uint256 public percentTreasury = 15;\\n    uint256 public percentReferralsLv1 = 10;\\n    uint256 public percentReferralsLv2 = 5;\\n\\n    // Constants\\n    uint256 public constant MAX_CARD_PRICE = 10000000000000000000;\\n\\n    // Price and variables\\n    uint256 precardPrice = 2000000000000000000;\\n\\n    // Rows to Injection\\n    uint256 percentOfRowsToInjection = 0;\\n    uint256 public constant MAX_ROWS_TO_INJECTION = 100;\\n\\n    // Pot Percent\\n    uint256 public potPercent = 70;\\n\\n    // Current PreBit and PreCard IDs\\n    uint256 public currentPreBitId;\\n    uint256 public currentPreCardId;\\n\\n    // Time Intervals\\n    uint256 public intervalToOpenNextPrebit = 0;\\n    uint256 public intervalToCloseNextPrebit = 1800;\\n    uint256 public intervalToEndNextPrebit = 3600;\\n\\n    // Enumeration for Prebit status\\n    enum Status {\\n        Pending,\\n        Open,\\n        Close,\\n        End\\n    }\\n\\n    // Structs\\n    struct Prebit {\\n        Status status;\\n        uint256 startTime;\\n        uint256 openPredictTime;\\n        uint256 closePredictTime;\\n        uint256 endTime;\\n        uint256[6] amountInRows;\\n        uint256[6] rewardEachCard;\\n        uint256[6] cardsInRows;\\n        uint256 firstPrecardId;\\n        uint256 totalTreasuryAmount;\\n        uint256 totalEntryAmount;\\n        uint256 finalPrice;\\n        bool priceSet;\\n    }\\n\\n    struct RowData {\\n        uint256 amountInRow;\\n        uint256 cardsInRow;\\n        uint256 rewardEachCard;\\n    }\\n\\n    struct PrebitData {\\n        uint256 endTime;\\n        uint256 userPrecardCount;\\n    }\\n\\n    struct RewardResult {\\n        bool claimed;\\n        uint256 rewards;\\n    }\\n\\n    struct Precard {\\n        uint256 predictPrice;\\n        address owner;\\n        bool claimed;\\n    }\\n\\n    // State Variables\\n    mapping(uint256 =\\u003e Prebit) public _prebits;\\n    mapping(uint256 =\\u003e Precard) public _precards;\\n    uint256[6] public rowsRange;\\n    uint256 public latestPrecardCalculated;\\n    uint256[6] public pendingInjectionNextPrebit;\\n    mapping(address =\\u003e mapping(uint256 =\\u003e uint256[]))\\n        public _userPreCardIdsPerPreBitId;\\n\\n    // Modifiers\\n    modifier onlyOperator() {\\n        require(msg.sender == operatorAddress, \\\"Not operator\\\");\\n        _;\\n    }\\n\\n    modifier onlyOwnerOrInjector() {\\n        require(\\n            (msg.sender == owner()) || (msg.sender == injectorAddress),\\n            \\\"Not owner or injector\\\"\\n        );\\n        _;\\n    }\\n\\n\\n    modifier contractInjector() {\\n        require(msg.sender == contractInject, \\\"Not Contract Injector\\\");\\n        _;\\n    }\\n    //Events\\n    event PurchasePrecardEvent(\\n        address _user,\\n        uint256 _prebitID,\\n        uint256[] _prediction,\\n        uint256 _count,\\n        uint256 _referralCode\\n    );\\n    event PayReferralsEvent(\\n        address _parent,\\n        uint256 _prebitID,\\n        uint256 _payReferralAmount,\\n        uint256 _totalAmount,\\n        uint256 _type\\n    );\\n    event StartNextPrebitEvent(\\n        uint256 indexed prebitId,\\n        uint256 _endTime,\\n        uint256 _openPrecardTime,\\n        uint256 _closePrecardTime,\\n        uint256 firstTicketId\\n    );\\n    event ExecuteDrawFinalPriceEvent(\\n        uint256 indexed prebitId,\\n        uint256 finalPrice\\n    );\\n    event ClaimTicketEvent(\\n        address _user,\\n        uint256 indexed prebitId,\\n        uint256[] precards,\\n        uint256 amount\\n    );\\n\\n    // Event to set addresses\\n    event SetAddressesEvent(\\n        address indexed operatorAddress,\\n        address indexed treasuryAddress,\\n        address indexed injectorAddress\\n       \\n    );\\n\\n    // Event to update Precard price\\n    event UpdatePrecardPriceEvent(uint256 newPrice);\\n\\n    // Event for injecting funds\\n    event InjectFundsEvent(uint256 prebitId, uint256 amount, uint256 row);\\n\\n    // Event for migrating to a new version\\n    event MigrateToNewVersionEvent(address newContract);\\n\\n    // Event for setting the percent of rows\\n    event SetPercentOfRowsEvent(uint256 percent);\\n\\n    // Event for setting new intervals\\n    event SetNewIntervalEvent(\\n        uint256 openInterval,\\n        uint256 closeInterval,\\n        uint256 endInterval\\n    );\\n\\n    constructor(address _payToken, address _referralContractAddress,address _contractInjector) {\\n        payToken = IERC20(_payToken);\\n        contractInject=_contractInjector;\\n        referralContract = IPrebitReferrals(_referralContractAddress);\\n        rowsRange[0] = 0; // Row 1 - 0 Cent\\n        rowsRange[1] = 2; // Row 2 - 2 Cent\\n        rowsRange[2] = 5; // Row 3 - 5 Cent\\n        rowsRange[3] = 10; // Row 4 - 10 Cent\\n        rowsRange[4] = 50; // Row 5 - 50 Cent\\n        rowsRange[5] = 100; // Row 6 - 100 Cent\\n    }\\n\\n    // Purchase a Precard\\n    function purchasePrecard(\\n        uint256 _prebitID,\\n        uint256[] memory _prediction,\\n        uint256 _referralCode\\n    ) external {\\n        require(\\n            _prebits[_prebitID].status == Status.Open,\\n            \\\"Prebit ID is not open\\\"\\n        );\\n        require(\\n            block.timestamp \\u003c _prebits[_prebitID].closePredictTime,\\n            \\\"Prebit ID is over\\\"\\n        );\\n\\n        require(\\n            _prediction.length \\u003e 0,\\n            \\\"101 : Precard count must be greater than 0\\\"\\n        );\\n\\n        uint256 totalPayAmount = _prediction.length * precardPrice;\\n\\n        require(\\n            payToken.balanceOf(msg.sender) \\u003e= totalPayAmount,\\n            \\\"102 : Insufficient USDT balance\\\"\\n        );\\n\\n        // Pays \\u0026 Generate referral code\\n\\n        referralContract.generateReferralCodeWithContract(\\n            _referralCode,\\n            msg.sender\\n        );\\n        _paysProcess(totalPayAmount);\\n\\n        uint256 amountPot = totalPayAmount.mul(potPercent).div(100);\\n        // Increment the total amount collected for the prebit round\\n        _prebits[_prebitID].totalEntryAmount += amountPot;\\n        _prebits[_prebitID].totalTreasuryAmount += totalPayAmount\\n            .mul(percentTreasury)\\n            .div(100);\\n\\n        //Calulate\\n      \\n        _prebits[_prebitID].amountInRows[0] += amountPot.mul(30).div(100);\\n        _prebits[_prebitID].amountInRows[1] += amountPot.mul(20).div(100);\\n        _prebits[_prebitID].amountInRows[2] += amountPot.mul(15).div(100);\\n        _prebits[_prebitID].amountInRows[3] += amountPot.mul(12).div(100);\\n        _prebits[_prebitID].amountInRows[4] += amountPot.mul(10).div(100);\\n        _prebits[_prebitID].amountInRows[5] += amountPot.mul(13).div(100);\\n\\n       \\n\\n        //Insert Precard\\n\\n        for (uint256 i = 0; i \\u003c _prediction.length; i++) {\\n            uint256 thisPrecardPrice = _prediction[i];\\n\\n            _userPreCardIdsPerPreBitId[msg.sender][_prebitID].push(\\n                currentPreCardId\\n            );\\n\\n            _precards[currentPreCardId] = Precard({\\n                predictPrice: thisPrecardPrice,\\n                owner: msg.sender,\\n                claimed: false\\n            });\\n\\n            currentPreCardId++;\\n        }\\n\\n        emit PurchasePrecardEvent(\\n            msg.sender,\\n            _prebitID,\\n            _prediction,\\n            _prediction.length,\\n            _referralCode\\n        );\\n    }\\n\\n    function _paysProcess(uint256 _totalPayAmount) private {\\n        uint256 newAmount = _totalPayAmount;\\n        address parentAddress = referralContract.getUserParent(msg.sender);\\n        if (parentAddress != address(0)) {\\n            newAmount -= _totalPayAmount.mul(percentReferralsLv1).div(100);\\n            payToken.transferFrom(\\n                msg.sender,\\n                parentAddress,\\n                _totalPayAmount.mul(percentReferralsLv1).div(100)\\n            );\\n            emit PayReferralsEvent(\\n                parentAddress,\\n                currentPreBitId,\\n                _totalPayAmount.mul(percentReferralsLv1).div(100),\\n                _totalPayAmount,\\n                1\\n            );\\n            address tParentAddress = referralContract.getUserTparent(\\n                msg.sender\\n            );\\n            if (tParentAddress != address(0)) {\\n                payToken.transferFrom(\\n                    msg.sender,\\n                    tParentAddress,\\n                    _totalPayAmount.mul(percentReferralsLv2).div(100)\\n                );\\n\\n                emit PayReferralsEvent(\\n                    tParentAddress,\\n                    currentPreBitId,\\n                    _totalPayAmount.mul(percentReferralsLv2).div(100),\\n                    _totalPayAmount,\\n                    2\\n                );\\n\\n                newAmount -= _totalPayAmount.mul(percentReferralsLv2).div(100);\\n            } else {\\n                _prebits[currentPreBitId].totalTreasuryAmount += _totalPayAmount\\n                    .mul(percentReferralsLv2)\\n                    .div(100);\\n            }\\n        } else {\\n            _prebits[currentPreBitId].totalTreasuryAmount += _totalPayAmount\\n                .mul(percentReferralsLv1 + percentReferralsLv2)\\n                .div(100);\\n        }\\n\\n        payToken.transferFrom(msg.sender, address(this), newAmount);\\n    }\\n\\n    function adjustTimestamp(\\n        uint256 _prebitId,\\n        uint256 endTimestamp,\\n        uint256 openTimestamp,\\n        uint256 closeTimestamp\\n    ) external onlyOwner {\\n        _prebits[_prebitId].endTime = endTimestamp;\\n        _prebits[_prebitId].openPredictTime = openTimestamp;\\n        _prebits[_prebitId].closePredictTime = closeTimestamp;\\n    }\\n\\n    function startNextPrebit() external onlyOperator {\\n        require(\\n            (_prebits[currentPreBitId].status == Status.End),\\n            \\\"Not time to start PreBit\\\"\\n        );\\n\\n        currentPreBitId++;\\n        uint256 nowTimestamp = block.timestamp;\\n\\n        uint256 openTimestamp = nowTimestamp + intervalToOpenNextPrebit;\\n        uint256 endTimestamp = _prebits[currentPreBitId - 1].endTime +\\n            intervalToEndNextPrebit;\\n        uint256 closeTimestamp = _prebits[currentPreBitId - 1].endTime +\\n            intervalToCloseNextPrebit;\\n\\n        // Ensure that endTimestamp is not earlier than nowTimestamp\\n        while (endTimestamp \\u003c openTimestamp) {\\n            endTimestamp += intervalToEndNextPrebit;\\n        }\\n\\n        // Ensure that openTimestamp is not later than\\n        while (closeTimestamp \\u003c openTimestamp) {\\n            closeTimestamp += intervalToCloseNextPrebit;\\n        }\\n\\n        // Ensure that closeTimestamp is not later than endTimestamp\\n        while (closeTimestamp \\u003e endTimestamp) {\\n            endTimestamp += intervalToEndNextPrebit;\\n        }\\n        if (closeTimestamp == endTimestamp) {\\n            closeTimestamp = endTimestamp - intervalToCloseNextPrebit;\\n        }\\n\\n        startNext(endTimestamp, openTimestamp, closeTimestamp);\\n    }\\n\\n    function startNextPrebitGenesis(\\n        uint256 _endTime,\\n        uint256 _openPrecardTime,\\n        uint256 _closePrecardTime\\n    ) external onlyOwner {\\n        require((currentPreBitId == 0), \\\"Not time to start PreBit\\\");\\n\\n        currentPreBitId++;\\n\\n        startNext(_endTime, _openPrecardTime, _closePrecardTime);\\n    }\\n\\n    function startNext(\\n        uint256 _endTime,\\n        uint256 _openPrecardTime,\\n        uint256 _closePrecardTime\\n    ) private {\\n        _prebits[currentPreBitId] = Prebit({\\n            status: Status.Open,\\n            startTime: block.timestamp,\\n            openPredictTime: _openPrecardTime,\\n            closePredictTime: _closePrecardTime,\\n            endTime: _endTime,\\n            amountInRows: [\\n                uint256(0),\\n                uint256(0),\\n                uint256(0),\\n                uint256(0),\\n                uint256(0),\\n                uint256(0)\\n            ],\\n            rewardEachCard: [\\n                uint256(0),\\n                uint256(0),\\n                uint256(0),\\n                uint256(0),\\n                uint256(0),\\n                uint256(0)\\n            ],\\n            cardsInRows: [\\n                uint256(0),\\n                uint256(0),\\n                uint256(0),\\n                uint256(0),\\n                uint256(0),\\n                uint256(0)\\n            ],\\n            firstPrecardId: currentPreCardId,\\n            totalTreasuryAmount: 0,\\n            totalEntryAmount: 0,\\n            finalPrice: 0,\\n            priceSet: false\\n        });\\n\\n        uint256 sumAllPendingExceptBitpot = pendingInjectionNextPrebit[1]+pendingInjectionNextPrebit[2]+pendingInjectionNextPrebit[3]+pendingInjectionNextPrebit[4]+pendingInjectionNextPrebit[5];\\n        \\n        _prebits[currentPreBitId].amountInRows[0] = pendingInjectionNextPrebit[0];\\n        _prebits[currentPreBitId].amountInRows[1] = sumAllPendingExceptBitpot.mul(20).div(70);\\n        _prebits[currentPreBitId].amountInRows[2] = sumAllPendingExceptBitpot.mul(15).div(70);\\n        _prebits[currentPreBitId].amountInRows[3] = sumAllPendingExceptBitpot.mul(12).div(70);\\n        _prebits[currentPreBitId].amountInRows[4] = sumAllPendingExceptBitpot.mul(10).div(70);\\n        _prebits[currentPreBitId].amountInRows[5] = sumAllPendingExceptBitpot.mul(13).div(70);\\n\\n        pendingInjectionNextPrebit[0] = 0;\\n        pendingInjectionNextPrebit[1] = 0;\\n        pendingInjectionNextPrebit[2] = 0;\\n        pendingInjectionNextPrebit[3] = 0;\\n        pendingInjectionNextPrebit[4] = 0;\\n        pendingInjectionNextPrebit[5] = 0;\\n\\n        emit StartNextPrebitEvent(\\n            currentPreBitId,\\n            _endTime,\\n            _openPrecardTime,\\n            _closePrecardTime,\\n            currentPreCardId\\n        );\\n    }\\n\\n    function executeDrawFinalPrice(\\n        uint256 _prebitId,\\n        uint256 _price,\\n        uint256 _batchSize\\n    ) external onlyOperator {\\n        require(\\n            block.timestamp \\u003e _prebits[_prebitId].endTime,\\n            \\\"This Prebit Not End\\\"\\n        );\\n\\n        require(\\n            _prebits[_prebitId].status != Status.End,\\n            \\\"This Prebit is Finished\\\"\\n        );\\n\\n        uint256 finalPrice;\\n        if (_prebits[_prebitId].priceSet == false) {\\n            _prebits[_prebitId].finalPrice = _price;\\n            finalPrice = _price;\\n            _prebits[_prebitId].priceSet = true;\\n        } else {\\n            finalPrice = _prebits[_prebitId].finalPrice;\\n        }\\n\\n        //Percent Rows\\n\\n        uint256 startPrecardId = latestPrecardCalculated;\\n        uint256 endPrecardId = startPrecardId + _batchSize;\\n        // Ensure we don\\u0027t exceed the total number of precards\\n        if (endPrecardId \\u003e currentPreCardId) {\\n            endPrecardId = currentPreCardId;\\n        }\\n\\n        for (uint256 i = startPrecardId; i \\u003c endPrecardId; i++) {\\n            uint256 cardPrice = _precards[i].predictPrice;\\n            if (cardPrice == finalPrice) {\\n                //Jackpot\\n                _prebits[_prebitId].cardsInRows[0] =\\n                    _prebits[_prebitId].cardsInRows[0] +\\n                    1;\\n            } else if (\\n                isPredictionWithinRange(cardPrice, rowsRange[1], finalPrice)\\n            ) {\\n                _prebits[_prebitId].cardsInRows[1] =\\n                    _prebits[_prebitId].cardsInRows[1] +\\n                    1;\\n            } else if (\\n                isPredictionWithinRange(cardPrice, rowsRange[2], finalPrice)\\n            ) {\\n                _prebits[_prebitId].cardsInRows[2] =\\n                    _prebits[_prebitId].cardsInRows[2] +\\n                    1;\\n            } else if (\\n                isPredictionWithinRange(cardPrice, rowsRange[3], finalPrice)\\n            ) {\\n                _prebits[_prebitId].cardsInRows[3] =\\n                    _prebits[_prebitId].cardsInRows[3] +\\n                    1;\\n            } else if (\\n                isPredictionWithinRange(cardPrice, rowsRange[4], finalPrice)\\n            ) {\\n                _prebits[_prebitId].cardsInRows[4] =\\n                    _prebits[_prebitId].cardsInRows[4] +\\n                    1;\\n            } else if (\\n                isPredictionWithinRange(cardPrice, rowsRange[5], finalPrice)\\n            ) {\\n                _prebits[_prebitId].cardsInRows[5] =\\n                    _prebits[_prebitId].cardsInRows[5] +\\n                    1;\\n            }\\n\\n            latestPrecardCalculated++;\\n        }\\n\\n        if (latestPrecardCalculated == currentPreCardId) {\\n            //Calc  Reward Each card\\n            if (_prebits[_prebitId].cardsInRows[0] \\u003e 0) {\\n                _prebits[_prebitId].rewardEachCard[0] = (\\n                    _prebits[_prebitId].amountInRows[0]\\n                ).div(_prebits[_prebitId].cardsInRows[0]);\\n            } else {\\n                pendingInjectionNextPrebit[0] += _prebits[_prebitId]\\n                    .amountInRows[0];\\n            }\\n\\n            if (_prebits[_prebitId].cardsInRows[1] \\u003e 0) {\\n                _prebits[_prebitId].rewardEachCard[1] = (\\n                    _prebits[_prebitId].amountInRows[1]\\n                ).div(_prebits[_prebitId].cardsInRows[1]);\\n            } else {\\n                pendingInjectionNextPrebit[0] += (_prebits[_prebitId].amountInRows[1]).mul(percentOfRowsToInjection).div(100);\\n                pendingInjectionNextPrebit[1] += (_prebits[_prebitId].amountInRows[1]).mul(100 - percentOfRowsToInjection).div(100);\\n            }\\n\\n            if (_prebits[_prebitId].cardsInRows[2] \\u003e 0) {\\n                _prebits[_prebitId].rewardEachCard[2] = (\\n                    _prebits[_prebitId].amountInRows[2]\\n                ).div(_prebits[_prebitId].cardsInRows[2]);\\n            } else {\\n                pendingInjectionNextPrebit[0] += (\\n                    _prebits[_prebitId].amountInRows[2]\\n                ).mul(percentOfRowsToInjection).div(100);\\n                pendingInjectionNextPrebit[2] += (\\n                    _prebits[_prebitId].amountInRows[2]\\n                ).mul(100 - percentOfRowsToInjection).div(100);\\n            }\\n\\n            if (_prebits[_prebitId].cardsInRows[3] \\u003e 0) {\\n                _prebits[_prebitId].rewardEachCard[3] = (\\n                    _prebits[_prebitId].amountInRows[3]\\n                ).div(_prebits[_prebitId].cardsInRows[3]);\\n            } else {\\n                pendingInjectionNextPrebit[0] += (\\n                    _prebits[_prebitId].amountInRows[3]\\n                ).mul(percentOfRowsToInjection).div(100);\\n                pendingInjectionNextPrebit[3] += (\\n                    _prebits[_prebitId].amountInRows[3]\\n                ).mul(100 - percentOfRowsToInjection).div(100);\\n            }\\n\\n            if (_prebits[_prebitId].cardsInRows[4] \\u003e 0) {\\n                _prebits[_prebitId].rewardEachCard[4] = (\\n                    _prebits[_prebitId].amountInRows[4]\\n                ).div(_prebits[_prebitId].cardsInRows[4]);\\n            } else {\\n                pendingInjectionNextPrebit[0] += (\\n                    _prebits[_prebitId].amountInRows[4]\\n                ).mul(percentOfRowsToInjection).div(100);\\n                pendingInjectionNextPrebit[4] += (\\n                    _prebits[_prebitId].amountInRows[4]\\n                ).mul(100 - percentOfRowsToInjection).div(100);\\n            }\\n\\n            if (_prebits[_prebitId].cardsInRows[5] \\u003e 0) {\\n                _prebits[_prebitId].rewardEachCard[5] = (\\n                    _prebits[_prebitId].amountInRows[5]\\n                ).div(_prebits[_prebitId].cardsInRows[5]);\\n            } else {\\n                pendingInjectionNextPrebit[0] += (\\n                    _prebits[_prebitId].amountInRows[5]\\n                ).mul(percentOfRowsToInjection).div(100);\\n                pendingInjectionNextPrebit[5] += (\\n                    _prebits[_prebitId].amountInRows[5]\\n                ).mul(100 - percentOfRowsToInjection).div(100);\\n            }\\n\\n            // Mark the Prebit as finalized\\n            _prebits[_prebitId].status = Status.End;\\n\\n            //Transfer TreasuryAmount\\n\\n              _paysTreasury(_prebits[_prebitId].totalTreasuryAmount);\\n\\n            //\\n            emit ExecuteDrawFinalPriceEvent(_prebitId, finalPrice);\\n        }\\n    }\\n\\n    function claimRewardPrebit(uint256 _prebitID) external {\\n        require(\\n            _prebits[_prebitID].status == Status.End,\\n            \\\"Prebit not claimable\\\"\\n        );\\n        uint256[] memory _preCardsIDs;\\n        _preCardsIDs = getUserPreCardIDs(msg.sender, _prebitID);\\n\\n        require(\\n            _preCardsIDs.length != 0,\\n            \\\"You Don\\u0027t Have Any Precard in This Round\\\"\\n        );\\n        uint256 rewardInUsdtToTransfer;\\n        for (uint256 i = 0; i \\u003c _preCardsIDs.length; i++) {\\n            uint256 thisPrecard = _preCardsIDs[i];\\n\\n            require(\\n                _prebits[_prebitID].firstPrecardId \\u003c= thisPrecard,\\n                \\\"TicketId too low\\\"\\n            );\\n            require(\\n                msg.sender == _precards[thisPrecard].owner,\\n                \\\"Not the owner\\\"\\n            );\\n\\n            // Update the lottery ticket owner to 0x address\\n            _precards[thisPrecard].owner = address(0);\\n\\n            uint256 rewardForPrecardId = _calculateRewardsForOnePrecard(\\n                _prebitID,\\n                thisPrecard\\n            );\\n            _precards[thisPrecard].claimed = true;\\n            // Increment the reward to transfer\\n            rewardInUsdtToTransfer += rewardForPrecardId;\\n        }\\n\\n        require(rewardInUsdtToTransfer \\u003e 0, \\\"You are not winner in this round\\\");\\n        //Transfer to User\\n        payToken.transfer(msg.sender, rewardInUsdtToTransfer.mul(97).div(100));\\n        //Transfer to Referrals lv1\\n        if (referralContract.getUserParent(msg.sender) != address(0)) {\\n            address parentAddress = referralContract.getUserParent(msg.sender);\\n            payToken.transfer(\\n                parentAddress,\\n                rewardInUsdtToTransfer.mul(3).div(100)\\n            );\\n            emit PayReferralsEvent(\\n                parentAddress,\\n                _prebitID,\\n                rewardInUsdtToTransfer.mul(3).div(100),\\n                rewardInUsdtToTransfer.mul(97).div(100),\\n                10\\n            ); //10 means from winner\\n        } else {\\n            _paysTreasury(rewardInUsdtToTransfer.mul(3).div(100));\\n        }\\n\\n        emit ClaimTicketEvent(\\n            msg.sender,\\n            _prebitID,\\n            _preCardsIDs,\\n            rewardInUsdtToTransfer.mul(97).div(100)\\n        );\\n    }\\n\\n    function _paysTreasury(uint256 _totalTransfers) private {\\n        uint256 remainingAmount = _totalTransfers;\\n        if (treasuryWallets.length \\u003e 0) {\\n            for (uint256 i = 0; i \\u003c treasuryWallets.length; i++) {\\n                uint256 amountToTransfer = (_totalTransfers)\\n                    .mul(treasuryPercentages[i])\\n                    .div(100);\\n\\n                if (amountToTransfer \\u003e 0) {\\n                    remainingAmount -= amountToTransfer;\\n                    payToken.transfer(treasuryWallets[i], amountToTransfer);\\n                }\\n            }\\n\\n            if (remainingAmount \\u003e 0) {\\n                payToken.transfer(treasuryAddress, remainingAmount);\\n            }\\n        } else {\\n            payToken.transfer(treasuryAddress, remainingAmount);\\n        }\\n    }\\n\\n    function _calculateRewardsForOnePrecard(\\n        uint256 _prebitId,\\n        uint256 _precardId\\n    ) public view returns (uint256) {\\n        // Retrieve the user number combination from the ticketId\\n        if (!_precards[_precardId].claimed) {\\n            uint256 userPredictPrice = _precards[_precardId].predictPrice;\\n\\n            uint256 rowCard = getRowsTicketInPrebit(\\n                userPredictPrice,\\n                _prebitId\\n            );\\n            if (rowCard != 6) {\\n                // Means not in any rows and return 0\\n                if (getCountAndAmountCardsInRow(_prebitId, rowCard)[2] \\u003e 0) {\\n                    return getCountAndAmountCardsInRow(_prebitId, rowCard)[2];\\n                } else {\\n                    return 0;\\n                }\\n            } else {\\n                return 0;\\n            }\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    function _calculateRewardsForAllPrecard(uint256 _prebitId, address _user)\\n        public\\n        view\\n        returns (RewardResult memory)\\n    {\\n        // Retrieve the user number combination from the ticketId\\n\\n        uint256[] memory userPrecards = getUserPreCardIDs(_user, _prebitId);\\n        uint256 sumReward=0;\\n        bool claimed = false;\\n        for (uint256 i = 0; i \\u003c userPrecards.length; i++) {\\n            uint256 userPredictPrice = _precards[userPrecards[i]].predictPrice;\\n            if( _precards[userPrecards[i]].claimed){\\n                 claimed = true;\\n            } \\n          \\n            uint256 rowCard = getRowsTicketInPrebit(\\n                userPredictPrice,\\n                _prebitId\\n            );\\n\\n            if (rowCard != 6) {\\n                // Means not in any rows and return 0\\n                if (getCountAndAmountCardsInRow(_prebitId, rowCard)[2] \\u003e 0) {\\n                    sumReward += getCountAndAmountCardsInRow(\\n                        _prebitId,\\n                        rowCard\\n                    )[2];\\n                } else {\\n                    sumReward += 0;\\n                }\\n            } else {\\n                sumReward += 0;\\n            }\\n        }\\n\\n        return RewardResult({claimed: claimed, rewards: sumReward});\\n    }\\n\\n    function getRowsTicketInPrebit(uint256 _cardPrice, uint256 _prebitId)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 _prebitFinalPrice = _prebits[_prebitId].finalPrice;\\n        if (_cardPrice == _prebitFinalPrice) {\\n            //Bitpot\\n            return 0;\\n        } else if (\\n            isPredictionWithinRange(_cardPrice, rowsRange[1], _prebitFinalPrice)\\n        ) {\\n            return 1;\\n        } else if (\\n            isPredictionWithinRange(_cardPrice, rowsRange[2], _prebitFinalPrice)\\n        ) {\\n            return 2;\\n        } else if (\\n            isPredictionWithinRange(_cardPrice, rowsRange[3], _prebitFinalPrice)\\n        ) {\\n            return 3;\\n        } else if (\\n            isPredictionWithinRange(_cardPrice, rowsRange[4], _prebitFinalPrice)\\n        ) {\\n            return 4;\\n        } else if (\\n            isPredictionWithinRange(_cardPrice, rowsRange[5], _prebitFinalPrice)\\n        ) {\\n            return 5;\\n        } else {\\n            return 6; // Means not in any rows\\n        }\\n    }\\n\\n    function isPredictionWithinRange(\\n        uint256 _myPrice,\\n        uint256 _rangeCent,\\n        uint256 _bitcoinPrice\\n    ) private pure returns (bool) {\\n        return\\n            (_myPrice \\u003e= _bitcoinPrice.sub(_rangeCent)) \\u0026\\u0026\\n            (_myPrice \\u003c= _bitcoinPrice.add(_rangeCent));\\n    }\\n\\n    function getUserPreCardIDs(address _address, uint256 _prebit)\\n        public\\n        view\\n        returns (uint256[] memory)\\n    {\\n        return _userPreCardIdsPerPreBitId[_address][_prebit];\\n    }\\n\\n    function getPredictPriceWithPrecards(uint256[] memory _cards)\\n        public\\n        view\\n        returns (uint256[] memory)\\n    {\\n        uint256[] memory _data = new uint256[](_cards.length);\\n        for (uint256 i = 0; i \\u003c _cards.length; i++) {\\n            _data[i] = _precards[_cards[i]].predictPrice;\\n        }\\n        return _data;\\n    }\\n\\n    function TotalTicketInPrebitId(uint256 _prebit)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        if (currentPreBitId == _prebit) {\\n            return currentPreCardId - (_prebits[_prebit].firstPrecardId);\\n        } else {\\n            return\\n                (_prebits[_prebit + 1].firstPrecardId) -\\n                _prebits[_prebit].firstPrecardId;\\n        }\\n    }\\n\\n    function getCurrentBitPot() public view returns (uint256) {\\n        return getCountAndAmountCardsInRow(currentPreBitId, 0)[0];\\n    }\\n\\n    function getCurrentAmountInAllRows() public view returns (uint256) {\\n        uint256 sumAmount = 0;\\n        for (uint256 i = 0; i \\u003c 6; i++) {\\n            sumAmount += getCountAndAmountCardsInRow(currentPreBitId, i)[0];\\n        }\\n        return sumAmount;\\n    }\\n\\n    function getRowsData(uint256 _prebit)\\n        public\\n        view\\n        returns (RowData[] memory)\\n    {\\n        RowData[] memory rowArray = new RowData[](6);\\n\\n        for (uint256 i = 0; i \\u003c 6; i++) {\\n            rowArray[i] = RowData({\\n                amountInRow: _prebits[_prebit].amountInRows[i],\\n                cardsInRow: _prebits[_prebit].cardsInRows[i],\\n                rewardEachCard: _prebits[_prebit].rewardEachCard[i]\\n            });\\n        }\\n\\n        return rowArray;\\n    }\\n\\n    // Function to get data for multiple Prebits\\n    function getLatestPrebitsData(uint256[] memory _prebitIds, address _user)\\n        public\\n        view\\n        returns (PrebitData[] memory)\\n    {\\n        PrebitData[] memory prebitsData = new PrebitData[](_prebitIds.length);\\n\\n        for (uint256 i = 0; i \\u003c _prebitIds.length; i++) {\\n            uint256 prebitId = _prebitIds[i];\\n            uint256 getUserPrecardCount = getUserPreCardIDs(_user, prebitId)\\n                .length;\\n\\n            prebitsData[i] = PrebitData({\\n                endTime: _prebits[prebitId].endTime,\\n                userPrecardCount: getUserPrecardCount\\n            });\\n        }\\n\\n        return prebitsData;\\n    }\\n\\n    function getCountAndAmountCardsInRow(uint256 _prebit, uint256 _row)\\n        public\\n        view\\n        returns (uint256[] memory)\\n    {\\n        uint256[] memory _data = new uint256[](3); // Initialize _data with a length of 3\\n\\n        _data[0] = _prebits[_prebit].amountInRows[_row];\\n        _data[1] = _prebits[_prebit].cardsInRows[_row];\\n        _data[2] = _prebits[_prebit].rewardEachCard[_row];\\n\\n        return _data;\\n    }\\n\\n    function injectFunds(\\n        uint256 _prebitId,\\n        uint256 _amount,\\n        uint256 _row\\n    ) external onlyOwnerOrInjector {\\n        require(_prebits[_prebitId].status != Status.End, \\\"Prebit not be End\\\");\\n\\n        payToken.transferFrom(address(msg.sender), address(this), _amount);\\n        _prebits[_prebitId].amountInRows[_row] += _amount;\\n\\n        emit InjectFundsEvent(_prebitId, _amount, _row);\\n    }\\n\\n     function injectFundsFromContract(\\n        uint256 _prebitId,\\n        uint256 _amount,\\n        uint256 _row\\n    ) external contractInjector {\\n        require(_prebits[_prebitId].status != Status.End, \\\"Prebit not be End\\\");\\n\\n        _prebits[_prebitId].amountInRows[_row] += _amount;\\n\\n        emit InjectFundsEvent(_prebitId, _amount, _row);\\n    }\\n\\n    function setOperatorAndTreasuryAndInjectorAddresses(\\n        address _operatorAddress,\\n        address _treasuryAddress,\\n        address _injectorAddress\\n      \\n    ) external onlyOwner {\\n        require(_operatorAddress != address(0), \\\"Cannot be zero address\\\");\\n        require(_treasuryAddress != address(0), \\\"Cannot be zero address\\\");\\n        require(_injectorAddress != address(0), \\\"Cannot be zero address\\\");\\n\\n        operatorAddress = _operatorAddress;\\n        treasuryAddress = _treasuryAddress;\\n        injectorAddress = _injectorAddress;\\n       \\n        emit SetAddressesEvent(\\n            _operatorAddress,\\n            _treasuryAddress,\\n            _injectorAddress\\n            \\n        );\\n    }\\n\\n    function setPrecardPrice(uint256 _newPrice) external onlyOwner {\\n        require(\\n            _newPrice \\u003c= MAX_CARD_PRICE,\\n            \\\"Price exceeds the maximum allowed\\\"\\n        );\\n\\n        precardPrice = _newPrice;\\n\\n        emit UpdatePrecardPriceEvent(_newPrice);\\n    }\\n\\n    function addTreasuryWallet(address _wallet, uint256 _percentage)\\n        external\\n        onlyOwner\\n    {\\n        require(\\n            _wallet != address(0),\\n            \\\"Treasury wallet address cannot be zero\\\"\\n        );\\n        require(_percentage \\u003c= 100, \\\"Percentage must be between 0 and 100\\\");\\n        uint256 totalPercentage = 0;\\n        for (uint256 i = 0; i \\u003c treasuryWallets.length; i++) {\\n            totalPercentage += treasuryPercentages[i];\\n        }\\n        require(\\n            totalPercentage + _percentage \\u003c= 100,\\n            \\\"Percentage must be less than 100\\\"\\n        );\\n\\n        treasuryWallets.push(_wallet);\\n        treasuryPercentages.push(_percentage);\\n    }\\n\\n    function updateTreasuryWallet(\\n        uint256 _index,\\n        address _wallet,\\n        uint256 _percentage\\n    ) external onlyOwner {\\n        require(_index \\u003c treasuryWallets.length, \\\"Invalid index\\\");\\n        require(\\n            _wallet != address(0),\\n            \\\"Treasury wallet address cannot be zero\\\"\\n        );\\n        require(_percentage \\u003c= 100, \\\"Percentage must be between 1 and 100\\\");\\n\\n        uint256 totalPercentage = 0;\\n        for (uint256 i = 0; i \\u003c treasuryWallets.length; i++) {\\n            totalPercentage += treasuryPercentages[i];\\n        }\\n        require(\\n            totalPercentage + _percentage \\u003c= 100,\\n            \\\"Percentage must be less than 100\\\"\\n        );\\n\\n        treasuryWallets[_index] = _wallet;\\n        treasuryPercentages[_index] = _percentage;\\n    }\\n\\n    function migrateToNewVersion(address _newContract) external onlyOwner {\\n        // Ensure that the new contract address is set\\n        require(_newContract != address(0), \\\"New contract address not set\\\");\\n        //require Status end\\n        require(\\n            _prebits[currentPreBitId].status == Status.End,\\n            \\\"Prebit must be End\\\"\\n        );\\n\\n        // Transfer all pending injections to the new contract\\n\\n        for (uint256 i = 0; i \\u003c pendingInjectionNextPrebit.length; i++) {\\n            payToken.transfer(_newContract, pendingInjectionNextPrebit[i]);\\n            IPrebit(_newContract).injectFundsFromContract(\\n                IPrebit(_newContract).currentPreBitId(),\\n                pendingInjectionNextPrebit[i],\\n                i\\n            );\\n            pendingInjectionNextPrebit[i] = 0;\\n        }\\n\\n        emit MigrateToNewVersionEvent(_newContract);\\n    }\\n\\n    function setPercentOfRowsToInjection(uint256 _percent) external onlyOwner {\\n        require(_percent \\u003c= MAX_ROWS_TO_INJECTION, \\\"Percent exceeds maximum\\\");\\n        percentOfRowsToInjection = _percent;\\n\\n        emit SetPercentOfRowsEvent(_percent);\\n    }\\n\\n    function setIntervals(\\n        uint256 _openInterval,\\n        uint256 _closeInterval,\\n        uint256 _endInterval\\n    ) external onlyOwner {\\n        require(\\n            _openInterval \\u003c _closeInterval,\\n            \\\"Open must be smaller than Close\\\"\\n        );\\n        require(\\n            _closeInterval \\u003c= _endInterval,\\n            \\\"Close must be grater than End\\\"\\n        );\\n\\n        intervalToOpenNextPrebit = _openInterval;\\n        intervalToCloseNextPrebit = _closeInterval;\\n        intervalToEndNextPrebit = _endInterval;\\n\\n        emit SetNewIntervalEvent(_openInterval, _closeInterval, _endInterval);\\n    }\\n}\\n\"},\"Ownable.sol\":{\"content\":\"\\n// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.19;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\"},\"SafeMath.sol\":{\"content\":\"\\n// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.19;\\n\\n\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\\n\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler\\u0027s built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c \\u003c a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b \\u003e a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n            // benefit is lost if \\u0027b\\u0027 is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b \\u003c= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b \\u003e 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b \\u003e 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_payToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_referralContractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_contractInjector\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"prebitId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"precards\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClaimTicketEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"prebitId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"finalPrice\",\"type\":\"uint256\"}],\"name\":\"ExecuteDrawFinalPriceEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prebitId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"row\",\"type\":\"uint256\"}],\"name\":\"InjectFundsEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"MigrateToNewVersionEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_parent\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_prebitID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_payReferralAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_totalAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"}],\"name\":\"PayReferralsEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_prebitID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_prediction\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_referralCode\",\"type\":\"uint256\"}],\"name\":\"PurchasePrecardEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operatorAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"treasuryAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"injectorAddress\",\"type\":\"address\"}],\"name\":\"SetAddressesEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"openInterval\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"closeInterval\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endInterval\",\"type\":\"uint256\"}],\"name\":\"SetNewIntervalEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"SetPercentOfRowsEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"prebitId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_endTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_openPrecardTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_closePrecardTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"firstTicketId\",\"type\":\"uint256\"}],\"name\":\"StartNextPrebitEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"UpdatePrecardPriceEvent\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_CARD_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_ROWS_TO_INJECTION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_prebit\",\"type\":\"uint256\"}],\"name\":\"TotalTicketInPrebitId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_prebitId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"_calculateRewardsForAllPrecard\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"claimed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"}],\"internalType\":\"struct MainPrebit.RewardResult\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_prebitId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_precardId\",\"type\":\"uint256\"}],\"name\":\"_calculateRewardsForOnePrecard\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_prebits\",\"outputs\":[{\"internalType\":\"enum MainPrebit.Status\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"openPredictTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"closePredictTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"firstPrecardId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalTreasuryAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalEntryAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finalPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"priceSet\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_precards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"predictPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"claimed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_userPreCardIdsPerPreBitId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_percentage\",\"type\":\"uint256\"}],\"name\":\"addTreasuryWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_prebitId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"openTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"closeTimestamp\",\"type\":\"uint256\"}],\"name\":\"adjustTimestamp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_prebitID\",\"type\":\"uint256\"}],\"name\":\"claimRewardPrebit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractInject\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentPreBitId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentPreCardId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_prebitId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_batchSize\",\"type\":\"uint256\"}],\"name\":\"executeDrawFinalPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_prebit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_row\",\"type\":\"uint256\"}],\"name\":\"getCountAndAmountCardsInRow\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentAmountInAllRows\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentBitPot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_prebitIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getLatestPrebitsData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userPrecardCount\",\"type\":\"uint256\"}],\"internalType\":\"struct MainPrebit.PrebitData[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_cards\",\"type\":\"uint256[]\"}],\"name\":\"getPredictPriceWithPrecards\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_prebit\",\"type\":\"uint256\"}],\"name\":\"getRowsData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountInRow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cardsInRow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardEachCard\",\"type\":\"uint256\"}],\"internalType\":\"struct MainPrebit.RowData[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cardPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_prebitId\",\"type\":\"uint256\"}],\"name\":\"getRowsTicketInPrebit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_prebit\",\"type\":\"uint256\"}],\"name\":\"getUserPreCardIDs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_prebitId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_row\",\"type\":\"uint256\"}],\"name\":\"injectFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_prebitId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_row\",\"type\":\"uint256\"}],\"name\":\"injectFundsFromContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"injectorAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"intervalToCloseNextPrebit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"intervalToEndNextPrebit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"intervalToOpenNextPrebit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestPrecardCalculated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newContract\",\"type\":\"address\"}],\"name\":\"migrateToNewVersion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operatorAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"payToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pendingInjectionNextPrebit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percentReferralsLv1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percentReferralsLv2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percentTreasury\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"potPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_prebitID\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_prediction\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_referralCode\",\"type\":\"uint256\"}],\"name\":\"purchasePrecard\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralContract\",\"outputs\":[{\"internalType\":\"contract IPrebitReferrals\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rowsRange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_openInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_closeInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endInterval\",\"type\":\"uint256\"}],\"name\":\"setIntervals\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operatorAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasuryAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_injectorAddress\",\"type\":\"address\"}],\"name\":\"setOperatorAndTreasuryAndInjectorAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_percent\",\"type\":\"uint256\"}],\"name\":\"setPercentOfRowsToInjection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newPrice\",\"type\":\"uint256\"}],\"name\":\"setPrecardPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startNextPrebit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_openPrecardTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_closePrecardTime\",\"type\":\"uint256\"}],\"name\":\"startNextPrebitGenesis\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"treasuryPercentages\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"treasuryWallets\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_percentage\",\"type\":\"uint256\"}],\"name\":\"updateTreasuryWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MainPrebit", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000055d398326f99059ff775485246999027b31979550000000000000000000000009a8ae3be63fc293ce1bc934010dcd0132b6585b0000000000000000000000000cf26a30ea2c226207c30b9a0a6e43a6a6bbbce89", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5194f727537bf2bd4410dc546190aef37a1472bbfd87d9df4b0b4d80118410d3"}