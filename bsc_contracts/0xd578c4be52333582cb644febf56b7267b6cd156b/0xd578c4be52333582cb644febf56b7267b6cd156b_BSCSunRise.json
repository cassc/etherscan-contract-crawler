{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\n/*\r\n\u2588\u2584\u2584  \u2588\u2580  \u2588\u2580\u2580\u2003  \u2003\u2588\u2580  \u2588\u2591\u2588  \u2588\u2584\u2591\u2588  \u2588\u2580\u2588  \u2588  \u2588\u2580  \u2588\u2580\u2580\r\n\u2588\u2584\u2588  \u2584\u2588  \u2588\u2584\u2584\u2003  \u2003\u2584\u2588  \u2588\u2584\u2588  \u2588\u2591\u2580\u2588  \u2588\u2580\u2584  \u2588  \u2584\u2588  \u2588\u2588\u2584\r\n*/\r\n\r\npragma solidity ^0.8.7;\r\n\r\ninterface IERC20 {\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n} \r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable {\r\n    address private _owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _setOwner(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n    \r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n    * @dev Leaves the contract without owner. It will not be possible to call\r\n    * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n    *\r\n    * NOTE: Renouncing ownership will leave the contract without an owner,\r\n    * thereby removing any functionality that is only available to the owner.\r\n    */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n \r\ncontract BSCSunRise is Ownable {  \r\n    event NodeRegister(address node , address upline , uint8 level);\r\n    event NodeLevelUp(address node , uint8 oldLevel , uint8 newLevel);\r\n    event UserFlashedOut(address node ,uint8 atLevel, uint256 profit);\r\n    event PoolCharged(uint16 forDays, uint256 amount);\r\n\r\n    uint24 internal constant calcPeriod = 86400;\r\n    uint16 internal constant basePrice = 20;\r\n    uint16 internal lastCalcIndex = 10;\r\n    uint16 internal lastWithdrawIndex = 9;\r\n    uint256 lastCalc = block.timestamp;\r\n    bool internal canWithdraw;\r\n\r\n    struct Level{\r\n        uint256 price;\r\n        uint8  parityAmount;\r\n        uint16 perDay;\r\n        uint256 perDayUSDT;\r\n    }\r\n    mapping (uint8 => Level)  internal Levels;\r\n    struct Node {\r\n        address ad;\r\n        uint24 LCap;\r\n        uint24 RCap;\r\n        uint8 ln;\r\n        uint32 allTimeParity;\r\n        uint256 registerTime;\r\n        uint16 rwi;\r\n        bool needLevelUp;\r\n    }\r\n    \r\n    mapping (uint32 => Node) internal Nodes;\r\n    uint32 internal totalUsers = 0;\r\n \r\n    IERC20 PaymentToken = IERC20(0x55d398326f99059fF775485246999027B3197955);\r\n\r\n    uint256 internal withdrawPool;\r\n    uint256 internal lotteryPool;\r\n\r\n    struct PoolStruct {\r\n        uint256 sumDeposit;\r\n        uint24  sumParity;    \r\n        mapping(address => uint24) userParity;\r\n        mapping(uint16 => uint32) users;\r\n        mapping(uint32 => bool) selfWithdrawalUsers;\r\n        uint16  countUserParity;\r\n        mapping(uint32 => uint256) userProfit;\r\n    }\r\n\r\n    mapping (address => uint256)  internal userProfits;\r\n    mapping (uint16  => PoolStruct) internal pool;\r\n    mapping (address => address) internal parent;\r\n    mapping (address => mapping (uint8 => address)) internal children;\r\n    mapping (address => uint32) internal uids;\r\n    mapping (address => uint256) internal lotteryPerUser;\r\n    mapping (address => uint256) internal lotteryPerUserTime;\r\n    \r\n    constructor() { \r\n        setLevels(); \r\n        totalUsers++;\r\n        Nodes[totalUsers].registerTime = block.timestamp;\r\n        Nodes[totalUsers].ad = msg.sender; \r\n        Nodes[totalUsers].ln = 5;\r\n        Nodes[totalUsers].rwi = lastCalcIndex;\r\n        uids[msg.sender] = totalUsers;\r\n    }\r\n\r\n    function chargeBinaryPool(uint16 addDay , uint256 amount) external{\r\n        require(PaymentToken.allowance(msg.sender , address(this)) >= amount , \"Approve to transfer BUSD first.\");\r\n        require(PaymentToken.transferFrom(msg.sender , address(this) , amount),\"Token transfer failure.\");\r\n        pool[lastCalcIndex + addDay].sumDeposit += amount;\r\n        emit PoolCharged(addDay , amount);\r\n    }\r\n\r\n    function setLevels() internal{\r\n        // level $20\r\n        Levels[1].price = (uint256)(basePrice) * (10 ** 18);\r\n        Levels[1].parityAmount = 1;\r\n        Levels[1].perDay = 9;\r\n        Levels[1].perDayUSDT = 4  * (10 ** 19);\r\n\r\n        // level $60\r\n        Levels[2].price = (uint256)(basePrice * 3) * (10 ** 18);\r\n        Levels[2].parityAmount = 3;\r\n        Levels[2].perDay = 40;\r\n        Levels[2].perDayUSDT = 18  * (10 ** 19);\r\n\r\n        // level $100\r\n        Levels[3].price = (uint256)(basePrice * 5) * (10 ** 18);\r\n        Levels[3].parityAmount = 5;\r\n        Levels[3].perDay = 90;\r\n        Levels[3].perDayUSDT = 4  * (10 ** 20);\r\n\r\n        // level $200\r\n        Levels[4].price = (uint256)(basePrice) * (10 ** 19);\r\n        Levels[4].parityAmount = 10;\r\n        Levels[4].perDay = 205;\r\n        Levels[4].perDayUSDT = 10 ** 21;\r\n\r\n        // level $400\r\n        Levels[5].price = (uint256)(basePrice * 25) * (10 ** 18);\r\n        Levels[5].parityAmount = 25;\r\n        Levels[5].perDay = 310;\r\n        Levels[5].perDayUSDT = 15 *  (10 ** 20);\r\n    }    \r\n\r\n    function checkLastCalc() private {\r\n        if(block.timestamp - lastCalc > calcPeriod){ \r\n            if(pool[lastCalcIndex].sumParity ==0){\r\n                pool[lastCalcIndex+1].sumDeposit += pool[lastCalcIndex].sumDeposit;\r\n                pool[lastCalcIndex].sumDeposit=0;\r\n            } else {\r\n                canWithdraw = true;\r\n            }\r\n            \r\n            lastCalcIndex++;\r\n            lastCalc = block.timestamp;\r\n        }\r\n    }\r\n\r\n    function CalcParity(address user) internal{\r\n        uint24 currentUserParity = 0;\r\n        uint32 userId = uids[user];\r\n        bool isNew = pool[lastCalcIndex].userParity[user] == 0;\r\n        uint16 pd = Levels[Nodes[userId].ln].perDay;\r\n\r\n        if(Nodes[userId].LCap >= Nodes[userId].RCap ){\r\n            if(Nodes[userId].RCap + pool[lastCalcIndex].userParity[user] > pd){\r\n                currentUserParity = pd - pool[lastCalcIndex].userParity[user];\r\n                if(currentUserParity > 0){\r\n                    pool[lastCalcIndex].userParity[user] = pd;\r\n                }\r\n                if(Nodes[userId].ln < 4){\r\n                    Nodes[userId].needLevelUp = true;\r\n                }\r\n            } else {\r\n                pool[lastCalcIndex].userParity[user] += Nodes[userId].RCap;\r\n                currentUserParity = Nodes[userId].RCap;\r\n            }\r\n\r\n            Nodes[userId].LCap = Nodes[userId].LCap - Nodes[userId].RCap; \r\n            Nodes[userId].RCap = 0;\r\n        } else{\r\n            if(Nodes[userId].LCap + pool[lastCalcIndex].userParity[user] > pd){\r\n                currentUserParity = pd - pool[lastCalcIndex].userParity[user];\r\n                if(currentUserParity > 0){\r\n                    pool[lastCalcIndex].userParity[user] = pd;\r\n                }\r\n\r\n                if(Nodes[userId].ln < 4){\r\n                    Nodes[userId].needLevelUp = true;\r\n                }\r\n            } else {\r\n                pool[lastCalcIndex].userParity[user] += Nodes[userId].LCap;\r\n                currentUserParity = Nodes[userId].LCap;\r\n            }\r\n            Nodes[userId].RCap = Nodes[userId].RCap - Nodes[userId].LCap; \r\n            Nodes[userId].LCap = 0;\r\n        }\r\n\r\n        if(currentUserParity > 0){\r\n            Nodes[userId].allTimeParity += currentUserParity;\r\n            pool[lastCalcIndex].sumParity += currentUserParity;\r\n\r\n            if(isNew){\r\n                pool[lastCalcIndex].users[pool[lastCalcIndex].countUserParity++] = userId;\r\n            }\r\n        }\r\n    }\r\n\r\n    function setRefferalsSalesCap(address currentUser , uint8 levelId) internal{\r\n        pool[lastCalcIndex].sumDeposit += Levels[levelId].price * 9 / 10;      // 90% for public pool\r\n        uint256 remain = Levels[levelId].price / 10;\r\n        withdrawPool += 10 ** 18; // $1 for withdraw pool\r\n        lotteryPool  += remain - (10 ** 18);   \r\n        \r\n        address child = currentUser;\r\n        address userParent = parent[child];\r\n        uint32 userId = uids[userParent];\r\n   \r\n        do{\r\n            if(children[userParent][0] == child){\r\n                Nodes[userId].LCap += Levels[levelId].parityAmount;\r\n            } else {\r\n                Nodes[userId].RCap += Levels[levelId].parityAmount ;\r\n            }\r\n            \r\n            if(Nodes[userId].LCap > 0 && Nodes[userId].RCap > 0){\r\n                CalcParity(userParent);    \r\n            } \r\n\r\n            child = userParent;\r\n            userParent = parent[child];\r\n            userId = uids[userParent];\r\n   \r\n        } while(userParent !=  address(0));\r\n    }\r\n\r\n    function getChildCount(address a) internal view returns (uint8){\r\n        uint8 c = 0;\r\n        if(children[a][0] != address(0))\r\n            c++;\r\n        \r\n        if(children[a][1] != address(0))\r\n            c++;\r\n\r\n        return c;\r\n    }\r\n    \r\n\r\n    function Register(address upline,uint8 levelId) external {\r\n        bool v = levelId >= 1 && levelId <=4;\r\n        require(v , \"Wrong level Id\");\r\n\r\n        uint256 needAmount = Levels[levelId].price ;\r\n        uint32 upId = uids[upline];\r\n\r\n        require(PaymentToken.allowance(msg.sender , address(this)) >= needAmount , \"Approve to transfer BUSD first.\");\r\n        require(upId > 0 , \"Your selected upline is not exists.\");\r\n        require(parent[msg.sender]  == address(0) , \"You are already registered.\");\r\n\r\n        uint8 directCount = getChildCount(upline);\r\n        require(directCount < 2 , \"Upline already has 2 directs.\");             \r\n        require(PaymentToken.transferFrom(msg.sender , address(this) , needAmount),\"Token transfer failure.\");\r\n\r\n        checkLastCalc();\r\n        _register(upline , msg.sender , levelId);\r\n        setRefferalsSalesCap(msg.sender, levelId);\r\n    }\r\n\r\n    function _register(address upline , address user , uint8 levelId) internal{\r\n        totalUsers++;\r\n        parent[user] = upline; \r\n        Nodes[totalUsers].registerTime = block.timestamp;\r\n        Nodes[totalUsers].ln = levelId;\r\n        Nodes[totalUsers].ad = user;\r\n        Nodes[totalUsers].rwi = lastCalcIndex;\r\n        uids[user] = totalUsers;\r\n\r\n        if(children[upline][0] == address(0)) {\r\n            children[upline][0] = user;\r\n        } else {\r\n            children[upline][1] = user;\r\n        }\r\n\r\n        emit NodeRegister(user, upline, levelId);\r\n    }\r\n\r\n    function getUserId() external view returns(uint32){\r\n        return uids[msg.sender];\r\n    }\r\n\r\n    function getUserRegisterDate(address user) external view returns(uint256){\r\n        return Nodes[uids[user]].registerTime;\r\n    }\r\n\r\n    function getUserLevel(address user) external view returns(uint8){\r\n        return Nodes[uids[user]].ln;\r\n    }\r\n\r\n    function getNodesHasBalanceToday() external view returns(address[] memory){\r\n        address [] memory users = new address[](pool[lastCalcIndex].countUserParity);\r\n        for(uint16 i =0 ; i< pool[lastCalcIndex].countUserParity ; i++){\r\n            users[i] = Nodes[pool[lastCalcIndex].users[i]].ad;\r\n        }\r\n        return users;\r\n    }\r\n\r\n    function canTopUpTo5() external view returns(bool){\r\n        return _canTopUpTo5(msg.sender);\r\n    }\r\n\r\n    function _canTopUpTo5(address sender) internal view returns(bool){\r\n         uint32 userId = uids[sender];\r\n         \r\n         if(userId == 0){\r\n            return false;\r\n        }\r\n\r\n        bool canTopUp = Nodes[userId].ln == 4;\r\n        \r\n        if(canTopUp){ \r\n            uint8 count = 0;\r\n            for(uint16 i = Nodes[userId].rwi; i < lastCalcIndex; i++){\r\n                if(pool[i].userParity[sender] == Levels[4].perDay){\r\n                    if(++count == 2){\r\n                        break;\r\n                    }\r\n                } else {\r\n                    count=0;\r\n                }\r\n            }\r\n            if(count < 2){\r\n                canTopUp = false;\r\n            }\r\n        }\r\n\r\n        return canTopUp;\r\n    }\r\n\r\n    function LevelUp(uint8 levelId) external {\r\n        bool v = levelId >= 2 && levelId <=5; \r\n        require(v , \"Wrong level Id\");\r\n        uint32 userId = uids[msg.sender];\r\n        require(levelId > Nodes[userId].ln , \"Level Id should be greater than the current.\");\r\n\r\n        if(levelId == 5){           \r\n            require(_canTopUpTo5(msg.sender) , \"Based on your account status, top up to level 5 is currently unavailbe for you.\");\r\n        }\r\n\r\n\r\n        uint256 needPrice = Levels[levelId].price;\r\n        require(PaymentToken.allowance(msg.sender , address(this)) == needPrice , \"Payment token allowance error\");\r\n\r\n        checkLastCalc();\r\n        require(PaymentToken.transferFrom(msg.sender , address(this) , needPrice) , \"Token transfer failure.\");\r\n      \r\n        emit NodeLevelUp(msg.sender , Nodes[userId].ln, levelId);\r\n    \r\n        Nodes[userId].ln = levelId;         \r\n        Nodes[userId].needLevelUp = false;\r\n        setRefferalsSalesCap(msg.sender, levelId);\r\n    } \r\n\r\n    function SmartLottery() external returns(bool){\r\n        uint32 userId = uids[msg.sender];\r\n        require(userId > 0 , \"You are not Registered.\");\r\n        uint8 levelId  = Nodes[userId].ln;\r\n        uint256 am = Levels[levelId].price / 10;\r\n\r\n        require(lotteryPool >= am, \"Lottery pool is empty. wait for next cycle.\");\r\n        require(lotteryPerUser[msg.sender] < Levels[levelId].price , \"You can't participate in the lottery anymore\");\r\n        require(Nodes[userId].allTimeParity <= 1 , \"you have already more than 1 parity points.\");\r\n        require(block.timestamp -  Nodes[userId].registerTime > 2678400 ,\r\n         \"Only users who have been registered for at least one month can participate in the lottery\");\r\n        require(lotteryPerUserTime[msg.sender] < block.timestamp , \"You already participated in lottey in this cycle.\");\r\n        bool win = false;\r\n        uint8 randomNumber = uint8(uint256(keccak256(abi.encodePacked(block.timestamp ,block.number, msg.sender))) % 6);\r\n        uint256 tm = block.timestamp + 86400;\r\n        randomNumber++;\r\n        if(randomNumber == 6){\r\n            lotteryPool -= am;\r\n            lotteryPerUser[msg.sender] += am;\r\n            tm = block.timestamp + 172800;\r\n            require(PaymentToken.transfer(msg.sender, am), \"Token transfer failure.\");\r\n            win=true;\r\n        }  \r\n        lotteryPerUserTime[msg.sender] = tm;\r\n        return win;\r\n    }\r\n\r\n    function WithdrawForAll() external {\r\n        checkLastCalc();\r\n        require(uids[msg.sender] > 0 , \"Permission Denied!\");\r\n        require(canWithdraw , \"It has not been 24 hours past yet.\");  \r\n        bool hasBonus = false;\r\n        \r\n        for(uint16 i = lastWithdrawIndex ; i < lastCalcIndex ; i++){\r\n            uint24 poolSumParity = pool[i].sumParity;\r\n            if(poolSumParity == 0){\r\n                continue;\r\n            }\r\n\r\n            uint256 poolAmount = pool[i].sumDeposit;\r\n            for(uint16 j = 0; j < pool[i].countUserParity; j++){\r\n                uint32 theUser = pool[i].users[j]; \r\n                if(pool[i].selfWithdrawalUsers[theUser]){\r\n                    continue;\r\n                }\r\n\r\n                address ad = Nodes[theUser].ad;\r\n                uint256 maxPD = Levels[Nodes[theUser].ln].perDayUSDT;\r\n                uint256 profit =(poolAmount * pool[i].userParity[ad]) / poolSumParity;\r\n                \r\n                if(profit > maxPD){\r\n                    pool[i+1].sumDeposit += profit - maxPD;\r\n                    profit = maxPD;\r\n                    emit UserFlashedOut(ad, Nodes[theUser].ln , profit);\r\n                }\r\n                pool[i].userProfit[theUser] = profit;\r\n                require(PaymentToken.transfer(ad, profit), \"Token transfer failure.\");\r\n            }\r\n            hasBonus = true;\r\n        }\r\n\r\n        require(hasBonus , \"Total users' balances is currently zero.\");\r\n        \r\n        canWithdraw = false; \r\n        uint256 bonus = withdrawPool; \r\n        withdrawPool = 0;\r\n        lastWithdrawIndex = lastCalcIndex;\r\n        require(PaymentToken.transfer(msg.sender, bonus), \"Bonus transfer failure.\");\r\n    }\r\n \r\n    function Withdraw() external {\r\n        checkLastCalc();\r\n        uint32 userId = uids[msg.sender];\r\n        require(userId > 0 , \"Permission Denied!\");\r\n\r\n        address ad = Nodes[userId].ad;\r\n        uint256 cup = 0;\r\n        uint256 maxPD = Levels[Nodes[userId].ln].perDayUSDT;\r\n\r\n        for(uint16 i = lastWithdrawIndex ; i < lastCalcIndex; i++){\r\n            if(pool[i].userParity[ad] > 0 && !pool[i].selfWithdrawalUsers[userId]){ \r\n                uint256 profit =(pool[i].sumDeposit * pool[i].userParity[ad]) / pool[i].sumParity ;\r\n                if(profit > maxPD){\r\n                    pool[i+1].sumDeposit += profit - maxPD;\r\n                    profit = maxPD;\r\n                    emit UserFlashedOut(ad, Nodes[userId].ln , profit);\r\n                }\r\n                cup +=profit;\r\n                pool[i].selfWithdrawalUsers[userId] = true;\r\n                pool[i].userProfit[userId] = profit;\r\n            }\r\n        }\r\n\r\n        require(cup > 0 , \"User has no balance yet.\");\r\n        require(PaymentToken.transfer(ad, cup) , \"Token transfer failure.\");  \r\n    }\r\n\r\n    function addPreviousNodes(address[] memory nAddresses , address[] memory nUplines , uint8[] memory nLevels , uint24[] memory nSaveLeft , uint24[] memory nSaveRight , uint8 count) external {\r\n        require(totalUsers < 77 , \"Users are already added.\");\r\n        for( uint8 i = 0 ; i < count ; i++){\r\n            if(uids[nAddresses[i]] == 0 ){\r\n                _register(nUplines[i] , nAddresses[i] , nLevels[i]);\r\n            }\r\n            Nodes[uids[nAddresses[i]]].LCap = nSaveLeft[i];\r\n            Nodes[uids[nAddresses[i]]].RCap = nSaveRight[i];\r\n        }\r\n    }\r\n \r\n    function getDynamicAtLow(address starter) external view returns(address){\r\n        address current = starter;\r\n        while(getChildCount(current) == 2){\r\n            uint32 currentId = uids[current];\r\n            current = children[current][Nodes[currentId].LCap < Nodes[currentId].RCap ? 0 : 1];\r\n        }\r\n\r\n        return current;\r\n    }\r\n    \r\n    function getDynamicAtHigh(address starter) external view returns(address){\r\n        address current = starter;\r\n        while(getChildCount(current) > 0){\r\n            uint32 currentId = uids[current];\r\n            if(getChildCount(current) == 1){\r\n                current = children[current][0];\r\n                continue;\r\n            }\r\n            current = children[current][Nodes[currentId].LCap < Nodes[currentId].RCap ? 1 : 0];\r\n        }\r\n        return current;\r\n    }\r\n    \r\n    function MyWithdrawableProfit() external view returns (uint256){\r\n        return _myWithdrawableProfit(msg.sender);\r\n    }\r\n    \r\n    function _myWithdrawableProfit(address ad) internal view returns (uint256){\r\n        uint32 userId = uids[ad];\r\n        require(userId > 0 , \"Permission Denied!\");\r\n        uint256 maxPD = Levels[Nodes[userId].ln].perDayUSDT;\r\n\r\n        uint256 cup = 0;\r\n        for(uint16 i = lastWithdrawIndex ; i< lastCalcIndex; i++){\r\n            if(pool[i].sumParity > 0){ \r\n                if(pool[i].selfWithdrawalUsers[userId]){\r\n                    continue;\r\n                }\r\n                uint256 profit =(pool[i].sumDeposit * pool[i].userParity[ad]) / pool[i].sumParity ;\r\n                if(profit > maxPD){\r\n                    profit = maxPD;\r\n                }\r\n                cup +=profit;\r\n\r\n            }\r\n        } \r\n        return cup;\r\n    }\r\n      \r\n    function MyParityCountToday() external view returns(uint24){\r\n        uint32 userId = uids[msg.sender];\r\n        require(userId > 0 , \"You are not registered.\"); \r\n        return pool[lastCalcIndex].userParity[msg.sender];\r\n    }\r\n    \r\n    function MyProfitToday() external view returns(uint256){\r\n        return userProfitToday(msg.sender);\r\n    }\r\n\r\n    function userProfitToday(address ad) internal view returns(uint256){\r\n        require(uids[ad] > 0 , \"You are not registered.\"); \r\n        uint32 userId = uids[ad];\r\n        uint256 maxPD = Levels[Nodes[userId].ln].perDayUSDT;\r\n\r\n        if(pool[lastCalcIndex].sumParity == 0){\r\n            return 0;\r\n        }\r\n\r\n        uint256 profit =  (pool[lastCalcIndex].sumDeposit * pool[lastCalcIndex].userParity[ad]) / pool[lastCalcIndex].sumParity;\r\n        if(profit > maxPD){\r\n            profit = maxPD;\r\n        }\r\n        return profit;\r\n    } \r\n\r\n    function TodayPoolAmount() external view returns(uint256){\r\n        return pool[lastCalcIndex].sumDeposit;\r\n    }\r\n\r\n    function TodayTotalParity() external view returns(uint24){\r\n        return pool[lastCalcIndex].sumParity;\r\n    }\r\n      \r\n    function LotteryPoolAmount() external view returns(uint256){\r\n        return lotteryPool;\r\n    }\r\n    \r\n    function MyDirects() external view returns(address , address){\r\n        return (\r\n            children[msg.sender][0],\r\n            children[msg.sender][1]\r\n        );\r\n    }\r\n\r\n    function getSystemData() external view returns(uint256,uint256,uint256,uint256,uint32,bool,uint256){\r\n        bool withdrawable = canWithdraw;\r\n        if(pool[lastCalcIndex].sumParity > 0 && block.timestamp - lastCalc > calcPeriod){ \r\n            withdrawable = true;\r\n        } \r\n        return (                                    \r\n            lotteryPool,\r\n            pool[lastCalcIndex].sumParity,\r\n            pool[lastCalcIndex].sumDeposit,\r\n            withdrawPool,\r\n            totalUsers,\r\n            withdrawable,\r\n            pool[lastCalcIndex+1].sumDeposit\r\n       );\r\n    }\r\n\r\n    function getUserProfitByPoolId(uint32 userId , uint16 poolId) internal view returns(uint256){\r\n        return pool[poolId].userProfit[userId];\r\n    }\r\n\r\n    function getUserAllTimeProfit(uint32 userId) internal view returns(uint256){\r\n        uint256 sumProfit = 0;\r\n        for(uint16 i = Nodes[userId].rwi ; i< lastWithdrawIndex ; i++){\r\n            sumProfit += getUserProfitByPoolId(userId , i);\r\n        }\r\n        return sumProfit;\r\n    }\r\n\r\n    function getLastWeekUserProfit() external view returns(uint256,uint256,uint256,uint256,uint256,uint256,uint256){\r\n        uint32 userId = uids[msg.sender];\r\n        require(userId > 0, \"Access Denied.\");\r\n\r\n        uint16 index = lastWithdrawIndex;\r\n\r\n        return(\r\n            getUserProfitByPoolId(userId , index  ),\r\n            getUserProfitByPoolId(userId , index-1),\r\n            getUserProfitByPoolId(userId , index-2),\r\n            getUserProfitByPoolId(userId , index-3),\r\n            getUserProfitByPoolId(userId , index-4),\r\n            getUserProfitByPoolId(userId , index-5),\r\n            getUserProfitByPoolId(userId , index-6)\r\n        );\r\n    }\r\n\r\n    function _getUserBalanceByPoolId(address userAddress , uint16 poolId) internal view returns(uint24){\r\n        return pool[poolId].userParity[userAddress];\r\n    }\r\n\r\n    function getUserBalanceByPoolId(uint16 poolId) external view returns(uint24){\r\n        uint32 userId = uids[msg.sender];\r\n        require(userId > 0, \"Access Denied.\");\r\n\r\n        return _getUserBalanceByPoolId(msg.sender , poolId);\r\n    }\r\n\r\n    function getLastWeekUserBalance() external view returns(uint24,uint24,uint24,uint24,uint24,uint24,uint24){\r\n        uint32 userId = uids[msg.sender];\r\n        require(userId > 0, \"Access Denied.\");\r\n        address s = msg.sender;\r\n        uint16 index = lastWithdrawIndex;\r\n\r\n        return(\r\n            _getUserBalanceByPoolId(s , index  ),\r\n            _getUserBalanceByPoolId(s , index-1),\r\n            _getUserBalanceByPoolId(s , index-2),\r\n            _getUserBalanceByPoolId(s , index-3),\r\n            _getUserBalanceByPoolId(s , index-4),\r\n            _getUserBalanceByPoolId(s , index-5),\r\n            _getUserBalanceByPoolId(s , index-6)\r\n        );\r\n    }\r\n\r\n    function getUserLotteryData() external view returns(bool, bool, uint256,uint256, uint256){\r\n        uint32 userId = uids[msg.sender];\r\n        bool canJoinNow = true;\r\n        bool canJoinEver = true;\r\n\r\n        if(Nodes[userId].allTimeParity > 1){\r\n            canJoinNow = false;\r\n            canJoinEver = false;\r\n        }\r\n        \r\n        uint256 elapsed = block.timestamp - Nodes[userId].registerTime;\r\n        if(elapsed < 30 * 86400){\r\n            canJoinNow = false;\r\n        }\r\n        if(lotteryPerUser[msg.sender] >= Levels[Nodes[userId].ln].price){\r\n            canJoinNow = false;\r\n            canJoinEver = false;\r\n        }\r\n        uint256 wait = 0;\r\n        if(canJoinEver){\r\n            if(block.timestamp < lotteryPerUserTime[msg.sender]){\r\n                wait = lotteryPerUserTime[msg.sender] - block.timestamp;\r\n                canJoinNow = false;\r\n            }\r\n        }\r\n\r\n        return (\r\n            canJoinEver,\r\n            canJoinNow,\r\n            elapsed,\r\n            wait,\r\n            lotteryPerUser[msg.sender]\r\n        );\r\n    }\r\n    \r\n    function getUserData() external view returns(uint256,uint256,uint256,address,address,address,uint8,uint32,uint24,uint256,bool,uint24,uint24){\r\n        uint32 userId = uids[msg.sender];\r\n        return (                                    \r\n            userProfitToday(msg.sender),\r\n            _myWithdrawableProfit(msg.sender),\r\n            getUserAllTimeProfit(userId),\r\n            parent[msg.sender],\r\n            children[msg.sender][0],\r\n            children[msg.sender][1],\r\n            Nodes[userId].ln,\r\n            Nodes[userId].allTimeParity,\r\n            pool[lastCalcIndex].userParity[msg.sender],\r\n            Nodes[userId].registerTime,\r\n            Nodes[userId].needLevelUp,\r\n            Nodes[userId].LCap,\r\n            Nodes[userId].RCap\r\n       );\r\n    }\r\n\r\n    function getUserPublicData(address user) external view returns(uint256,uint8,uint24,uint256){\r\n        uint32 userId = uids[user];\r\n        return (                                    \r\n            userProfitToday(user),\r\n            Nodes[userId].ln,\r\n            pool[lastCalcIndex].userParity[user],\r\n            Nodes[userId].registerTime\r\n       );\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"node\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"oldLevel\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"newLevel\",\"type\":\"uint8\"}],\"name\":\"NodeLevelUp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"node\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"upline\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"NodeRegister\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"forDays\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PoolCharged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"node\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"atLevel\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"}],\"name\":\"UserFlashedOut\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"levelId\",\"type\":\"uint8\"}],\"name\":\"LevelUp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LotteryPoolAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MyDirects\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MyParityCountToday\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MyProfitToday\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MyWithdrawableProfit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"upline\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"levelId\",\"type\":\"uint8\"}],\"name\":\"Register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SmartLottery\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TodayPoolAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TodayTotalParity\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WithdrawForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"nAddresses\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"nUplines\",\"type\":\"address[]\"},{\"internalType\":\"uint8[]\",\"name\":\"nLevels\",\"type\":\"uint8[]\"},{\"internalType\":\"uint24[]\",\"name\":\"nSaveLeft\",\"type\":\"uint24[]\"},{\"internalType\":\"uint24[]\",\"name\":\"nSaveRight\",\"type\":\"uint24[]\"},{\"internalType\":\"uint8\",\"name\":\"count\",\"type\":\"uint8\"}],\"name\":\"addPreviousNodes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"canTopUpTo5\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"addDay\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"chargeBinaryPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"starter\",\"type\":\"address\"}],\"name\":\"getDynamicAtHigh\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"starter\",\"type\":\"address\"}],\"name\":\"getDynamicAtLow\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastWeekUserBalance\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastWeekUserProfit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNodesHasBalanceToday\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSystemData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"poolId\",\"type\":\"uint16\"}],\"name\":\"getUserBalanceByPoolId\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUserData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUserId\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserLevel\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUserLotteryData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserPublicData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserRegisterDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BSCSunRise", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://58393b55478bf807e2130c91325a83d60f47737ef6e122b5bc7ae40b858b70ca"}