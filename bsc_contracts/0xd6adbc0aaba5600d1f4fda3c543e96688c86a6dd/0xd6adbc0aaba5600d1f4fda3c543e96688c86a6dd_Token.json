{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.14;\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n\r\n    function transfer(address to, uint value) external returns (bool);\r\n\r\n    function withdraw(uint) external;\r\n}\r\n\r\ninterface IERC20 {\r\n    function decimals() external view returns (uint8);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\ninterface ISwapRouter {\r\n    function factory() external pure returns (address);\r\n\r\n    function getAmountsOut(\r\n        uint amountIn,\r\n        address[] calldata path\r\n    ) external view returns (uint[] memory amounts);\r\n\r\n    function getAmountsIn(\r\n        uint amountOut,\r\n        address[] calldata path\r\n    ) external view returns (uint[] memory amounts);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n}\r\n\r\ninterface ISwapFactory {\r\n    function createPair(\r\n        address tokenA,\r\n        address tokenB\r\n    ) external returns (address pair);\r\n}\r\n\r\ninterface ISwapPair {\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (uint256 reserve0, uint256 reserve1, uint32 blockTimestampLast);\r\n\r\n    function totalSupply() external view returns (uint);\r\n}\r\n\r\ninterface INFT {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function getIdxs(address account) external view returns (uint256[] memory);\r\n}\r\n\r\ninterface HSToken {\r\n    function getLPProviderLength() external view returns (uint256);\r\n\r\n    function lpProviders(uint256 idx) external view returns (address);\r\n}\r\n\r\nabstract contract Ownable {\r\n    address internal _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() {\r\n        address msgSender = msg.sender;\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"!owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"new is 0\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract Token is IERC20, Ownable {\r\n    address private RouterAddr = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\r\n    address public USDT = 0x55d398326f99059fF775485246999027B3197955;\r\n    address public WBNB = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;\r\n    address public HS = 0xcD423DD42775C90c56be3DbA51748Ad796E19ca8;\r\n    address public HSPAIR = 0x9A3A09e0304af7368fd6Dde0959b18e4b7Eb9622;\r\n\r\n    string private constant _name = \"777\";\r\n    string private constant _symbol = \"777\";\r\n    uint8 private constant _decimals = 18;\r\n    uint256 private constant _tTotal = 1000000000 * 10 ** _decimals;\r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    ISwapRouter private _swapRouter;\r\n    address public mainPair;\r\n\r\n    mapping(address => bool) public _feeWhiteList;\r\n\r\n    NFTRewards public nftRewards;\r\n    TokenDistribute public tokenDistribute;\r\n\r\n    address public dev = 0x9F4016C75E019912DFb71B56671B1B62B48df606;\r\n    address public genesisAddr = 0xBD3054B8F8028433D8F4C17b5fDf150307D70bf8;\r\n    address public envAddr = 0x1126F64cd2532241788C51e68903665657964381;\r\n    address public hsReceiver = 0x7F6694Fe02B22fc8cd809e1BC176fa9503E7AB06;\r\n    address public bnbReceiver = 0x393dd7DeC436AAf8a8a00F79D0Ca2ED65af3734c;\r\n    address[6] public envs = [\r\n        0xc307a08E4172789f815dF976350d7cb4c0D64A6A,\r\n        0x67fE96eD77B9De3bD7740e21A1Ad92a21349ad65,\r\n        0x95B33cC99024B0AD02E914B8e2311868618EA144,\r\n        0x983bEFF3ADf12084e10802D77dA5935a61b9a866,\r\n        0x4c186F1D8480C5e7826F37C929c6beC6Bac8806B,\r\n        0x47b4EadDD8C93fa3A084fC951d73B1760f6a67dc\r\n    ];\r\n    uint256[6] public envRates = [104, 104, 104, 208, 200, 280];\r\n    mapping(address => bool) public nodes;\r\n\r\n    uint256 public constant MAX = ~uint256(0);\r\n    uint256 public constant buyDays = 30;\r\n    uint256 public constant dayTs = 1 days;\r\n\r\n    uint256 public lastPriceTimestamp;\r\n    uint256 public lastPrice;\r\n    uint256 public maxDepth = 100;\r\n    uint256 public returnPercent = 100;\r\n    uint256 public pumpPercent = 1200;\r\n    uint256 public nodeSellPrice = 1 ether;\r\n    uint256 public minInvestBNB = 1 ether;\r\n    uint256 public minerAmount = 0.000001 ether;\r\n    uint256 public groupMinCount = 20;\r\n\r\n    uint256 public totalInverstBNB;\r\n    mapping(address => uint256) public userTotalInvestBNB;\r\n    mapping(address => uint256) public userTotalClaimedBNB;\r\n    mapping(address => uint256) public userInvestBNB;\r\n    mapping(address => uint256) public userClaimedBNB;\r\n    mapping(address => uint256) public userReferBNB;\r\n    mapping(address => uint256) public userRefersCount;\r\n    mapping(address => uint256) public userPendingReferAmount;\r\n    mapping(address => uint256) public userPendingGroupAmount;\r\n    mapping(address => uint256) public userPerDayBuyBNB;\r\n    mapping(address => address) public userRefers;\r\n    mapping(address => address) public ancestors;\r\n    mapping(address => uint256) public lastClaimedBlock;\r\n    mapping(address => uint256) public userBuybackCounts;\r\n    mapping(address => uint256) public groupTotalRecommendAcount;\r\n    mapping(address => uint256) public groupTotalInverstBNB;\r\n\r\n    uint256[3] public referRate = [3, 2, 1];\r\n    uint256[3] public minerRate = [3, 2, 1];\r\n\r\n    modifier onlyDev() {\r\n        require(msg.sender == dev || msg.sender == owner(), \"not dev\");\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        require(WBNB < address(this), \"eeee\");\r\n        _swapRouter = ISwapRouter(RouterAddr);\r\n        ISwapFactory swapFactory = ISwapFactory(_swapRouter.factory());\r\n        mainPair = swapFactory.createPair(address(this), WBNB);\r\n        _feeWhiteList[address(0xdead)] = true;\r\n        _feeWhiteList[address(0x1)] = true;\r\n        _feeWhiteList[genesisAddr] = true;\r\n        _feeWhiteList[envAddr] = true;\r\n        nftRewards = new NFTRewards(dev, bnbReceiver, HS);\r\n        tokenDistribute = new TokenDistribute(dev, HS, HSPAIR);\r\n        _balances[genesisAddr] = (_tTotal * 25) / 100;\r\n        emit Transfer(address(0), genesisAddr, (_tTotal * 25) / 100);\r\n\r\n        _balances[address(this)] = (_tTotal * 75) / 100;\r\n        emit Transfer(address(0), address(this), (_tTotal * 75) / 100);\r\n    }\r\n\r\n    function symbol() external pure override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function name() external pure override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function decimals() external pure override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public pure override returns (uint256) {\r\n        return _tTotal;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(\r\n        address recipient,\r\n        uint256 amount\r\n    ) public override returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) public view override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(\r\n        address spender,\r\n        uint256 amount\r\n    ) public override returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        if (_allowances[sender][msg.sender] != MAX) {\r\n            _allowances[sender][msg.sender] =\r\n                _allowances[sender][msg.sender] -\r\n                amount;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) private {\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _transfer(address from, address to, uint256 amount) private {\r\n        require(from != to, \"Same\");\r\n        require(amount > 0, \"Zero\");\r\n        uint256 balance = _balances[from];\r\n        require(balance >= amount, \"balance Not Enough\");\r\n\r\n        if (_feeWhiteList[from] || _feeWhiteList[to]) {\r\n            _tokenTransfer(from, to, amount);\r\n            return;\r\n        }\r\n\r\n        if (from == mainPair) {\r\n            if (to == address(this)) {\r\n                _tokenTransfer(from, to, amount);\r\n                return;\r\n            }\r\n            revert(\"can not buy\");\r\n        }\r\n\r\n        if (to == mainPair) {\r\n            require(nodes[from], \"can not sell\");\r\n            address[] memory path = new address[](3);\r\n            path[0] = address(this);\r\n            path[1] = WBNB;\r\n            path[2] = USDT;\r\n            uint256 price = ISwapRouter(RouterAddr).getAmountsOut(\r\n                1 ether,\r\n                path\r\n            )[2];\r\n            require(price >= nodeSellPrice, \"under target price\");\r\n            _tokenTransfer(from, to, amount);\r\n            return;\r\n        }\r\n\r\n        if (to == address(this)) {\r\n            address sender = msg.sender;\r\n            require(sender == from, \"Bot\");\r\n            require(sender == tx.origin, \"BOT\");\r\n            _tokenTransfer(from, to, amount);\r\n\r\n            if (amount == minerAmount) {\r\n                if (\r\n                    0 == userInvestBNB[sender] ||\r\n                    lastClaimedBlock[sender] == 0 ||\r\n                    lastClaimedBlock[sender] + dayTs > block.timestamp\r\n                ) {\r\n                    return;\r\n                }\r\n\r\n                address[] memory path = new address[](2);\r\n                path[0] = WBNB;\r\n                path[1] = address(this);\r\n                if (userBuybackCounts[sender] < buyDays) {\r\n                    uint256 ccprice = ISwapRouter(RouterAddr).getAmountsIn(\r\n                        1 ether,\r\n                        path\r\n                    )[0];\r\n                    if (lastPriceTimestamp + dayTs < block.timestamp) {\r\n                        lastPrice = ccprice;\r\n                        lastPriceTimestamp = lastPriceTimestamp + dayTs;\r\n                    }\r\n                    if (ccprice < (lastPrice * pumpPercent) / 1000) {\r\n                        buyHHH(userPerDayBuyBNB[sender], path);\r\n                        userBuybackCounts[sender] =\r\n                            userBuybackCounts[sender] +\r\n                            1;\r\n                    }\r\n                }\r\n\r\n                uint256 staticMint = _swapRouter.getAmountsOut(\r\n                    (userPerDayBuyBNB[sender] * returnPercent) / 100,\r\n                    path\r\n                )[1];\r\n\r\n                if (userPendingReferAmount[sender] > 0) {\r\n                    _tokenTransfer(\r\n                        address(this),\r\n                        sender,\r\n                        userPendingReferAmount[sender]\r\n                    );\r\n                }\r\n                if (userPendingGroupAmount[sender] > 0) {\r\n                    _tokenTransfer(\r\n                        address(this),\r\n                        sender,\r\n                        userPendingGroupAmount[sender]\r\n                    );\r\n                }\r\n                _tokenTransfer(address(this), sender, staticMint);\r\n                lastClaimedBlock[sender] = block.timestamp;\r\n                userPendingReferAmount[sender] = 0;\r\n                userPendingGroupAmount[sender] = 0;\r\n\r\n                address ancestor = userRefers[sender];\r\n                for (uint256 i = 0; i < minerRate.length; i++) {\r\n                    if (\r\n                        ancestor != address(0) &&\r\n                        userInvestBNB[ancestor] > 0 &&\r\n                        userRefersCount[ancestor] >= i + 1\r\n                    ) {\r\n                        userPendingReferAmount[ancestor] =\r\n                            userPendingReferAmount[ancestor] +\r\n                            (staticMint * minerRate[i]) /\r\n                            100;\r\n                    }\r\n                    ancestor = userRefers[ancestor];\r\n                }\r\n\r\n                address node = ancestors[sender];\r\n                if (node != address(0) && userInvestBNB[node] > 0) {\r\n                    userPendingReferAmount[node] =\r\n                        userPendingReferAmount[node] +\r\n                        staticMint /\r\n                        200;\r\n                }\r\n\r\n                address group = userRefers[sender];\r\n                uint256 maxRate = 20;\r\n                uint256 sRate = 0;\r\n                for (uint j = 0; j < maxDepth; j++) {\r\n                    if (group != address(0)) {\r\n                        if (\r\n                            groupTotalInverstBNB[group] >= 50000 ether &&\r\n                            userInvestBNB[group] > 0 &&\r\n                            userRefersCount[group] >= groupMinCount &&\r\n                            maxRate > sRate\r\n                        ) {\r\n                            userPendingGroupAmount[group] =\r\n                                userPendingGroupAmount[group] +\r\n                                (staticMint * (maxRate - sRate)) /\r\n                                1000;\r\n                            sRate = 20;\r\n                        }\r\n\r\n                        if (\r\n                            groupTotalInverstBNB[group] < 50000 ether &&\r\n                            groupTotalInverstBNB[group] >= 5000 ether &&\r\n                            userInvestBNB[group] > 0 &&\r\n                            userRefersCount[group] >= groupMinCount &&\r\n                            maxRate > sRate\r\n                        ) {\r\n                            userPendingGroupAmount[group] =\r\n                                userPendingGroupAmount[group] +\r\n                                (staticMint * (10 - sRate)) /\r\n                                1000;\r\n                            sRate = 10;\r\n                        }\r\n\r\n                        if (\r\n                            groupTotalInverstBNB[group] < 5000 ether &&\r\n                            groupTotalInverstBNB[group] >= 500 ether &&\r\n                            userInvestBNB[group] > 0 &&\r\n                            userRefersCount[group] >= groupMinCount &&\r\n                            maxRate > sRate\r\n                        ) {\r\n                            userPendingGroupAmount[group] =\r\n                                userPendingGroupAmount[group] +\r\n                                (staticMint * (5 - sRate)) /\r\n                                1000;\r\n                            sRate = 5;\r\n                        }\r\n                        group = userRefers[group];\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n            } else {\r\n                if (0 == userInvestBNB[sender]) {\r\n                    return;\r\n                }\r\n                address[] memory path = new address[](2);\r\n                path[0] = WBNB;\r\n                path[1] = address(this);\r\n\r\n                uint256 canSellBNB = _swapRouter.getAmountsIn(amount, path)[0];\r\n\r\n                uint256 claimedBNB = userClaimedBNB[sender];\r\n                uint256 totalBNB = canSellBNB + claimedBNB;\r\n\r\n                uint256 sBNB = totalBNB <= 3 * userInvestBNB[sender]\r\n                    ? canSellBNB\r\n                    : 3 * userInvestBNB[sender] - claimedBNB;\r\n\r\n                (uint256 rwbnb, , ) = ISwapPair(mainPair).getReserves();\r\n                uint256 lpTotalSupply = ISwapPair(mainPair).totalSupply();\r\n                uint256 removeLPAmount = (((sBNB * lpTotalSupply) / rwbnb) *\r\n                    777) / 1000;\r\n                IERC20(mainPair).transfer(mainPair, removeLPAmount);\r\n                (uint rb, ) = ISwapPair(mainPair).burn(address(this));\r\n                IWETH(WBNB).withdraw(rb);\r\n                uint256 totalEnv = (rb * 50) / 777;\r\n                payable(sender).transfer((rb * 667) / 777);\r\n                payable(address(tokenDistribute)).transfer(totalEnv);\r\n                payable(genesisAddr).transfer((rb * 10) / 777);\r\n\r\n                for (uint i = 0; i < envs.length; i++) {\r\n                    payable(envs[i]).transfer((totalEnv * envRates[i]) / 1000);\r\n                }\r\n                userClaimedBNB[sender] = userClaimedBNB[sender] + sBNB;\r\n                userTotalClaimedBNB[sender] =\r\n                    userTotalClaimedBNB[sender] +\r\n                    sBNB;\r\n                if (userClaimedBNB[sender] >= 3 * userInvestBNB[sender]) {\r\n                    userClaimedBNB[sender] = 0;\r\n                    userInvestBNB[sender] = 0;\r\n                    userPendingReferAmount[sender] = 0;\r\n                    userPendingGroupAmount[sender] = 0;\r\n                    _tokenTransfer(sender, address(this), balanceOf(sender));\r\n                    if (userBuybackCounts[sender] < buyDays) {\r\n                        payable(envAddr).transfer(\r\n                            (buyDays - userBuybackCounts[sender]) *\r\n                                userPerDayBuyBNB[sender]\r\n                        );\r\n                    }\r\n                } else {\r\n                    if (balanceOf(sender) < minerAmount) {\r\n                        _tokenTransfer(address(this), sender, minerAmount * 2);\r\n                    }\r\n                }\r\n                tokenDistribute.process(300000);\r\n            }\r\n        } else {\r\n            revert(\"can not transfer\");\r\n        }\r\n    }\r\n\r\n    receive() external payable {\r\n        if (msg.sender == WBNB) {\r\n            return;\r\n        }\r\n        address account = msg.sender;\r\n        uint256 value = msg.value;\r\n        require(tx.origin == msg.sender && !isContract(msg.sender), \"bot\");\r\n        require(userInvestBNB[account] == 0, \"not end\");\r\n        require(value >= minInvestBNB, \"Less investment\");\r\n        address refer = userRefers[account];\r\n        require(refer != address(0), \"need refer\");\r\n\r\n        lastClaimedBlock[account] = block.timestamp;\r\n        totalInverstBNB += value;\r\n        userInvestBNB[account] = value;\r\n        userTotalInvestBNB[account] = userTotalInvestBNB[account] + value;\r\n        userPerDayBuyBNB[account] = (value * 36) / 100 / buyDays;\r\n\r\n        address ancestor = userRefers[account];\r\n        for (uint256 i = 0; i < maxDepth; i++) {\r\n            if (ancestor != address(0)) {\r\n                groupTotalRecommendAcount[ancestor]++;\r\n                groupTotalInverstBNB[ancestor] += value;\r\n                ancestor = userRefers[ancestor];\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (nodes[account]) {\r\n            payable(address(genesisAddr)).transfer((value * 4) / 100);\r\n            ancestors[account] = account;\r\n        } else {\r\n            ancestor = ancestors[refer];\r\n            if (ancestor == address(0)) {\r\n                ancestor = genesisAddr;\r\n            }\r\n            ancestors[account] = ancestor;\r\n            if (userInvestBNB[ancestor] > 0) {\r\n                payable(address(ancestor)).transfer((value * 4) / 100);\r\n                userReferBNB[ancestor] =\r\n                    userReferBNB[ancestor] +\r\n                    (value * 4) /\r\n                    100;\r\n            } else {\r\n                payable(address(genesisAddr)).transfer((value * 4) / 100);\r\n            }\r\n        }\r\n        nftRewards.addNftRewards{value: (value * 6) / 100}();\r\n        payable(address(genesisAddr)).transfer((value * 1) / 100);\r\n        ancestor = userRefers[account];\r\n        for (uint i = 0; i < referRate.length; i++) {\r\n            if (\r\n                ancestor != address(0) &&\r\n                userInvestBNB[ancestor] > 0 &&\r\n                userRefersCount[ancestor] >= i + 1\r\n            ) {\r\n                payable(ancestor).transfer((value * referRate[i]) / 100);\r\n                userReferBNB[ancestor] =\r\n                    userReferBNB[ancestor] +\r\n                    (value * referRate[i]) /\r\n                    100;\r\n            } else {\r\n                payable(genesisAddr).transfer((value * referRate[i]) / 100);\r\n            }\r\n            ancestor = userRefers[ancestor];\r\n        }\r\n        burnHS((value * 3) / 100);\r\n        if (_balances[account] == 0) {\r\n            _tokenTransfer(address(this), account, 0.00002 ether);\r\n        }\r\n        addLP((value * 44) / 100);\r\n    }\r\n\r\n    function _tokenTransfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 tAmount\r\n    ) private {\r\n        _balances[sender] = _balances[sender] - tAmount;\r\n        _balances[recipient] = _balances[recipient] + tAmount;\r\n        emit Transfer(sender, recipient, tAmount);\r\n    }\r\n\r\n    function setFeeWhiteList(\r\n        address[] calldata addList,\r\n        bool enable\r\n    ) external onlyDev {\r\n        for (uint256 i = 0; i < addList.length; i++) {\r\n            _feeWhiteList[addList[i]] = enable;\r\n        }\r\n    }\r\n\r\n    function setNodes(\r\n        address[] calldata addList,\r\n        bool enable\r\n    ) external onlyDev {\r\n        for (uint256 i = 0; i < addList.length; i++) {\r\n            nodes[addList[i]] = enable;\r\n        }\r\n    }\r\n\r\n    function setNodeSellPrice(uint256 _nodeSellPrice) external onlyDev {\r\n        nodeSellPrice = _nodeSellPrice;\r\n    }\r\n\r\n    function setPumpPercent(uint256 _percent) external onlyDev {\r\n        pumpPercent = _percent;\r\n    }\r\n\r\n    function setReturnPercent(uint256 _returnPercent) external onlyDev {\r\n        returnPercent = _returnPercent;\r\n    }\r\n\r\n    function setlastPriceTimestamp(\r\n        uint256 _lastPriceTimestamp\r\n    ) external onlyDev {\r\n        lastPriceTimestamp = _lastPriceTimestamp;\r\n    }\r\n\r\n    function setMinInvestBNB(uint256 _minInvestBNB) external onlyDev {\r\n        minInvestBNB = _minInvestBNB;\r\n    }\r\n\r\n    function setMinerAmount(uint256 _minerAmount) external onlyDev {\r\n        minerAmount = _minerAmount;\r\n    }\r\n\r\n    function setGroupMinCount(uint256 _groupMinCount) external onlyDev {\r\n        groupMinCount = _groupMinCount;\r\n    }\r\n\r\n    function claimBalance() external onlyDev {\r\n        payable(msg.sender).transfer(address(this).balance);\r\n    }\r\n\r\n    function claimToken(\r\n        address token,\r\n        uint256 amount,\r\n        address to\r\n    ) public onlyDev {\r\n        IERC20(token).transfer(to, amount);\r\n    }\r\n\r\n    function register(address _refer) public {\r\n        require(userInvestBNB[_refer] > 0 || _refer == genesisAddr, \"eee\");\r\n        require(userRefers[msg.sender] == address(0), \"ddd\");\r\n        userRefers[msg.sender] = _refer;\r\n        userRefersCount[_refer]++;\r\n    }\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    function addLP(uint256 bnbAmount) internal {\r\n        address[] memory path = new address[](2);\r\n        path[0] = WBNB;\r\n        path[1] = address(this);\r\n        IWETH(WBNB).deposit{value: bnbAmount}();\r\n        uint256 addLPTokenAmount = ISwapRouter(RouterAddr).getAmountsOut(\r\n            bnbAmount,\r\n            path\r\n        )[1];\r\n        _tokenTransfer(address(this), mainPair, addLPTokenAmount);\r\n        IWETH(WBNB).transfer(mainPair, bnbAmount);\r\n        ISwapPair(mainPair).mint(address(this));\r\n    }\r\n\r\n    function burnHS(uint256 amount) internal {\r\n        address[] memory path = new address[](2);\r\n        path[0] = WBNB;\r\n        path[1] = HS;\r\n        _swapRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{\r\n            value: amount\r\n        }(1, path, hsReceiver, block.timestamp);\r\n    }\r\n\r\n    function buyHHH(uint256 amount, address[] memory path) internal {\r\n        _swapRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{\r\n            value: amount\r\n        }(0, path, address(0x1), block.timestamp);\r\n\r\n        _tokenTransfer(address(0x1), address(this), balanceOf(address(0x1)));\r\n    }\r\n}\r\n\r\ncontract NFTRewards {\r\n    INFT public nft = INFT(0xcce005E2c61eae599D8dCA7f7f83F6D4867258F8);\r\n    uint256 public totalNFTRewards = 0;\r\n    uint256 public totalClaimedNFTRewards = 0;\r\n    mapping(uint256 => uint256) public pendingNFTRewards;\r\n    mapping(uint256 => uint256) public claimedNFTRewards;\r\n    address public owner;\r\n    address public hs;\r\n    uint256 public reinverstBNBs = 2 ether;\r\n    uint256 public outsBNBs = 10 ether;\r\n    uint256 public hsMinHolder = 5 ether;\r\n    address public bnbReceiver;\r\n\r\n    constructor(address _owner, address _bnbReceiver, address _hs) {\r\n        owner = _owner;\r\n        hs = _hs;\r\n        bnbReceiver = _bnbReceiver;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"not owner\");\r\n        _;\r\n    }\r\n\r\n    function emergencyWithdraw(address to) public onlyOwner {\r\n        payable(to).transfer(address(this).balance);\r\n    }\r\n\r\n    function setBnbReceiver(address _bnbReceiver) public onlyOwner {\r\n        bnbReceiver = _bnbReceiver;\r\n    }\r\n\r\n    function setReinverstBNB(uint256 _bnbs) public onlyOwner {\r\n        reinverstBNBs = _bnbs;\r\n    }\r\n\r\n    function setOutsBNB(uint256 _bnbs) public onlyOwner {\r\n        outsBNBs = _bnbs;\r\n    }\r\n\r\n    function setMinHolder(uint256 _bnbs) public onlyOwner {\r\n        hsMinHolder = _bnbs;\r\n    }\r\n\r\n    function claimReward() public {\r\n        require(\r\n            IERC20(hs).balanceOf(msg.sender) >= hsMinHolder,\r\n            \"need hold hs tokens\"\r\n        );\r\n        uint256[] memory idxs = nft.getIdxs(msg.sender);\r\n        for (uint i = 0; i < idxs.length; i++) {\r\n            payable(msg.sender).transfer(pendingNFTRewards[idxs[i]]);\r\n            claimedNFTRewards[idxs[i]] =\r\n                claimedNFTRewards[idxs[i]] +\r\n                pendingNFTRewards[idxs[i]];\r\n            pendingNFTRewards[idxs[i]] = 0;\r\n        }\r\n    }\r\n\r\n    function inverst(uint256 idx) public payable {\r\n        require(msg.value == reinverstBNBs, \"ppp\");\r\n        payable(bnbReceiver).transfer(msg.value);\r\n        claimedNFTRewards[idx] = 0;\r\n    }\r\n\r\n    function addNftRewards() external payable {\r\n        totalNFTRewards += msg.value;\r\n        uint256 totalNFTs = nft.totalSupply();\r\n        if (totalNFTs > 0) {\r\n            uint256 totalLeft;\r\n            uint256 shareAmount = msg.value / totalNFTs;\r\n            for (uint i = 0; i < totalNFTs; i++) {\r\n                if (claimedNFTRewards[i] + pendingNFTRewards[i] <= outsBNBs) {\r\n                    pendingNFTRewards[i] = pendingNFTRewards[i] + shareAmount;\r\n                } else {\r\n                    totalLeft += shareAmount;\r\n                }\r\n            }\r\n            if (totalLeft > 0) {\r\n                payable(bnbReceiver).transfer(totalLeft);\r\n            }\r\n        }\r\n    }\r\n\r\n    receive() external payable {}\r\n}\r\n\r\ncontract TokenDistribute {\r\n    address public owner;\r\n\r\n    address public hsPair;\r\n    address public hs;\r\n\r\n    constructor(address _owner, address _hs, address _hsPair) {\r\n        owner = _owner;\r\n        hs = _hs;\r\n        hsPair = _hsPair;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"not owner\");\r\n        _;\r\n    }\r\n\r\n    function emergencyWithdraw(address _token, address to) public onlyOwner {\r\n        IERC20(_token).transfer(to, IERC20(_token).balanceOf(address(this)));\r\n    }\r\n\r\n    function emergencyWithdrawBNB(address to) public onlyOwner {\r\n        payable(to).transfer(address(this).balance);\r\n    }\r\n\r\n    uint256 public currentIndex;\r\n    uint256 public holderRewardCondition = 1 ether;\r\n    uint256 public progressRewardBlock;\r\n    uint256 public progressRewardBlockDebt = 1;\r\n    mapping(address => bool) public excludeHolders;\r\n\r\n    function setHolderRewardCondition(\r\n        uint256 _holderRewardCondition\r\n    ) public onlyOwner {\r\n        holderRewardCondition = _holderRewardCondition;\r\n    }\r\n\r\n    function setExcludeHolder(address _acc, bool status) public onlyOwner {\r\n        excludeHolders[_acc] = status;\r\n    }\r\n\r\n    function process(uint256 gas) external {\r\n        uint256 blockNum = block.number;\r\n        if (progressRewardBlock + progressRewardBlockDebt > blockNum) {\r\n            return;\r\n        }\r\n        uint256 balance = address(this).balance;\r\n        if (balance < holderRewardCondition) {\r\n            return;\r\n        }\r\n        balance = holderRewardCondition;\r\n\r\n        IERC20 holdToken = IERC20(hsPair);\r\n        uint holdTokenTotal = holdToken.totalSupply();\r\n        if (holdTokenTotal == 0) {\r\n            return;\r\n        }\r\n\r\n        address shareHolder;\r\n        uint256 tokenBalance;\r\n        uint256 amount;\r\n        uint256 shareholderCount = HSToken(hs).getLPProviderLength();\r\n\r\n        uint256 gasUsed = 0;\r\n        uint256 iterations = 0;\r\n        uint256 gasLeft = gasleft();\r\n\r\n        while (gasUsed < gas && iterations < shareholderCount) {\r\n            if (currentIndex >= shareholderCount) {\r\n                currentIndex = 0;\r\n            }\r\n            shareHolder = HSToken(hs).lpProviders(currentIndex);\r\n            if (!excludeHolders[shareHolder]) {\r\n                tokenBalance = holdToken.balanceOf(shareHolder);\r\n                amount = (balance * tokenBalance) / holdTokenTotal;\r\n                if (amount > 0) {\r\n                    payable(shareHolder).transfer(amount);\r\n                }\r\n            }\r\n            gasUsed = gasUsed + (gasLeft - gasleft());\r\n            gasLeft = gasleft();\r\n            currentIndex++;\r\n            iterations++;\r\n        }\r\n\r\n        progressRewardBlock = blockNum;\r\n    }\r\n\r\n    receive() external payable {}\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"HS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HSPAIR\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WBNB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_feeWhiteList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ancestors\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bnbReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyDays\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"claimToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dayTs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dev\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"envAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"envRates\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"envs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"genesisAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"groupMinCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"groupTotalInverstBNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"groupTotalRecommendAcount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hsReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastClaimedBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastPriceTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mainPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxDepth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minInvestBNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minerAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"minerRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftRewards\",\"outputs\":[{\"internalType\":\"contract NFTRewards\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nodeSellPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nodes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pumpPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"referRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_refer\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"returnPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addList\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setFeeWhiteList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_groupMinCount\",\"type\":\"uint256\"}],\"name\":\"setGroupMinCount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minInvestBNB\",\"type\":\"uint256\"}],\"name\":\"setMinInvestBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minerAmount\",\"type\":\"uint256\"}],\"name\":\"setMinerAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nodeSellPrice\",\"type\":\"uint256\"}],\"name\":\"setNodeSellPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addList\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setNodes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_percent\",\"type\":\"uint256\"}],\"name\":\"setPumpPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_returnPercent\",\"type\":\"uint256\"}],\"name\":\"setReturnPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lastPriceTimestamp\",\"type\":\"uint256\"}],\"name\":\"setlastPriceTimestamp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenDistribute\",\"outputs\":[{\"internalType\":\"contract TokenDistribute\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalInverstBNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userBuybackCounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userClaimedBNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInvestBNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userPendingGroupAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userPendingReferAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userPerDayBuyBNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userReferBNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userRefers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userRefersCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userTotalClaimedBNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userTotalInvestBNB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Token", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b817e4fa273ef647e398ffda4e4540d3d837a795c63d0ee116e61884e6538e4d"}