{"SourceCode": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\r\n\r\npragma solidity ^0.8.1;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(\r\n            address(this).balance >= amount,\r\n            \"Address: insufficient balance\"\r\n        );\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(\r\n            success,\r\n            \"Address: unable to send value, recipient may have reverted\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data)\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        return\r\n            functionCallWithValue(\r\n                target,\r\n                data,\r\n                0,\r\n                \"Address: low-level call failed\"\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return\r\n            functionCallWithValue(\r\n                target,\r\n                data,\r\n                value,\r\n                \"Address: low-level call with value failed\"\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(\r\n            address(this).balance >= value,\r\n            \"Address: insufficient balance for call\"\r\n        );\r\n        (bool success, bytes memory returndata) = target.call{value: value}(\r\n            data\r\n        );\r\n        return\r\n            verifyCallResultFromTarget(\r\n                target,\r\n                success,\r\n                returndata,\r\n                errorMessage\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data)\r\n        internal\r\n        view\r\n        returns (bytes memory)\r\n    {\r\n        return\r\n            functionStaticCall(\r\n                target,\r\n                data,\r\n                \"Address: low-level static call failed\"\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return\r\n            verifyCallResultFromTarget(\r\n                target,\r\n                success,\r\n                returndata,\r\n                errorMessage\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data)\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        return\r\n            functionDelegateCall(\r\n                target,\r\n                data,\r\n                \"Address: low-level delegate call failed\"\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return\r\n            verifyCallResultFromTarget(\r\n                target,\r\n                success,\r\n                returndata,\r\n                errorMessage\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\r\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\r\n     *\r\n     * _Available since v4.8._\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                // only check isContract if the call was successful and the return data is empty\r\n                // otherwise we already know that it was a contract\r\n                require(isContract(target), \"Address: call to non-contract\");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason or using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function _revert(bytes memory returndata, string memory errorMessage)\r\n        private\r\n        pure\r\n    {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n}\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transfer.selector, to, value)\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.approve.selector, spender, value)\r\n        );\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(\r\n                token.approve.selector,\r\n                spender,\r\n                newAllowance\r\n            )\r\n        );\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(\r\n                oldAllowance >= value,\r\n                \"SafeERC20: decreased allowance below zero\"\r\n            );\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(\r\n                token,\r\n                abi.encodeWithSelector(\r\n                    token.approve.selector,\r\n                    spender,\r\n                    newAllowance\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(\r\n            data,\r\n            \"SafeERC20: low-level call failed\"\r\n        );\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(\r\n                abi.decode(returndata, (bool)),\r\n                \"SafeERC20: ERC20 operation did not succeed\"\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\npragma solidity ^0.8.7;\r\n\r\nabstract contract PausableControl {\r\n    mapping(bytes32 => bool) private _pausedRoles;\r\n\r\n    bytes32 public constant PAUSE_ALL_ROLE = 0x00;\r\n\r\n    event Paused(bytes32 role);\r\n    event Unpaused(bytes32 role);\r\n\r\n    modifier whenNotPaused(bytes32 role) {\r\n        require(\r\n            !paused(role) && !paused(PAUSE_ALL_ROLE),\r\n            \"PausableControl: paused\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused(bytes32 role) {\r\n        require(\r\n            paused(role) || paused(PAUSE_ALL_ROLE),\r\n            \"PausableControl: not paused\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function paused(bytes32 role) public view virtual returns (bool) {\r\n        return _pausedRoles[role];\r\n    }\r\n\r\n    function _pause(bytes32 role) internal virtual whenNotPaused(role) {\r\n        _pausedRoles[role] = true;\r\n        emit Paused(role);\r\n    }\r\n\r\n    function _unpause(bytes32 role) internal virtual whenPaused(role) {\r\n        _pausedRoles[role] = false;\r\n        emit Unpaused(role);\r\n    }\r\n}\r\n\r\n\r\n\r\npragma solidity ^0.8.7;\r\n\r\nabstract contract AdminControl {\r\n    address public admin;\r\n    address public pendingAdmin;\r\n\r\n    event ChangeAdmin(address indexed _old, address indexed _new);\r\n    event ApplyAdmin(address indexed _old, address indexed _new);\r\n\r\n    constructor(address _admin) {\r\n        require(_admin != address(0), \"AdminControl: address(0)\");\r\n        admin = _admin;\r\n        emit ChangeAdmin(address(0), _admin);\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"AdminControl: not admin\");\r\n        _;\r\n    }\r\n\r\n    function changeAdmin(address _admin) external onlyAdmin {\r\n        require(_admin != address(0), \"AdminControl: address(0)\");\r\n        pendingAdmin = _admin;\r\n        emit ChangeAdmin(admin, _admin);\r\n    }\r\n\r\n    function applyAdmin() external {\r\n        require(msg.sender == pendingAdmin, \"AdminControl: Forbidden\");\r\n        emit ApplyAdmin(admin, pendingAdmin);\r\n        admin = pendingAdmin;\r\n        pendingAdmin = address(0);\r\n    }\r\n}\r\n\r\n\r\n\r\npragma solidity ^0.8.7;\r\n\r\n\r\nabstract contract AdminPausableControl is AdminControl, PausableControl {\r\n    constructor(address _admin) AdminControl(_admin) {}\r\n\r\n    function pause(bytes32 role) external onlyAdmin {\r\n        _pause(role);\r\n    }\r\n\r\n    function unpause(bytes32 role) external onlyAdmin {\r\n        _unpause(role);\r\n    }\r\n}\r\n\r\n\r\n\r\npragma solidity ^0.8.6;\r\n\r\n\r\n\r\n/// three level architecture\r\n/// top level is the `AnycallClient` which the users interact with (through UI or tools)\r\n/// middle level is `AnyswapToken` which works as handlers and vaults for tokens\r\n/// bottom level is the `AnycallProxy` which complete the cross-chain interaction\r\n\r\ninterface IApp {\r\n    function anyExecute(bytes calldata _data)\r\n        external\r\n        returns (bool success, bytes memory result);\r\n}\r\n\r\ninterface IAnyswapToken {\r\n    function mint(address to, uint256 amount) external returns (bool);\r\n\r\n    function burn(address from, uint256 amount) external returns (bool);\r\n    \r\n    function withdraw(uint256 amount, address to) external returns (uint256);\r\n   \r\n}\r\n\r\ninterface IAnycallExecutor {\r\n    function context()\r\n        external\r\n        returns (\r\n            address from,\r\n            uint256 fromChainID,\r\n            uint256 nonce\r\n        );\r\n}\r\n\r\ninterface IAnycallV6Proxy {\r\n    function executor() external view returns (address);\r\n\r\n    function anyCall(\r\n        address _to,\r\n        bytes calldata _data,\r\n        address _fallback,\r\n        uint256 _toChainID,\r\n        uint256 _flags\r\n    ) external payable;\r\n}\r\n\r\nabstract contract AnycallClientBase is IApp, AdminPausableControl {\r\n    address public callProxy;\r\n    address public executor;\r\n\r\n    // associated client app on each chain\r\n    mapping(uint256 => address) public clientPeers; // key is chainId\r\n\r\n    modifier onlyExecutor() {\r\n        require(msg.sender == executor, \"AnycallClient: onlyExecutor\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _admin, address _callProxy)\r\n        AdminPausableControl(_admin)\r\n    {\r\n        require(_callProxy != address(0));\r\n        callProxy = _callProxy;\r\n        executor = IAnycallV6Proxy(callProxy).executor();\r\n    }\r\n\r\n    receive() external payable {\r\n        require(\r\n            msg.sender == callProxy,\r\n            \"AnycallClient: receive from forbidden sender\"\r\n        );\r\n    }\r\n\r\n    function setCallProxy(address _callProxy) external onlyAdmin {\r\n        require(_callProxy != address(0));\r\n        callProxy = _callProxy;\r\n        executor = IAnycallV6Proxy(callProxy).executor();\r\n    }\r\n\r\n    function setClientPeers(\r\n        uint256[] calldata _chainIds,\r\n        address[] calldata _peers\r\n    ) external onlyAdmin {\r\n        require(_chainIds.length == _peers.length);\r\n        for (uint256 i = 0; i < _chainIds.length; i++) {\r\n            clientPeers[_chainIds[i]] = _peers[i];\r\n        }\r\n    }\r\n}\r\n\r\ncontract AnyswapTokenAnycallClient is AnycallClientBase {\r\n    using SafeERC20 for IERC20;\r\n\r\n    // pausable control roles\r\n    bytes32 public constant PAUSE_SWAPOUT_ROLE =\r\n        keccak256(\"PAUSE_SWAPOUT_ROLE\");\r\n    bytes32 public constant PAUSE_SWAPIN_ROLE = keccak256(\"PAUSE_SWAPIN_ROLE\");\r\n    bytes32 public constant PAUSE_FALLBACK_ROLE =\r\n        keccak256(\"PAUSE_FALLBACK_ROLE\");\r\n\r\n    // associated tokens on each chain\r\n    mapping(address => mapping(uint256 => address)) public tokenPeers;\r\n\r\n    event LogSwapout(\r\n        address indexed token,\r\n        address indexed sender,\r\n        address indexed receiver,\r\n        uint256 amount,\r\n        uint256 toChainId\r\n    );\r\n    event LogSwapin(\r\n        address indexed token,\r\n        address indexed sender,\r\n        address indexed receiver,\r\n        uint256 amount,\r\n        uint256 fromChainId\r\n    );\r\n    event LogSwapoutFail(\r\n        address indexed token,\r\n        address indexed sender,\r\n        address indexed receiver,\r\n        uint256 amount,\r\n        uint256 toChainId\r\n    );\r\n\r\n    constructor(address _admin, address _callProxy)\r\n        AnycallClientBase(_admin, _callProxy)\r\n    {}\r\n\r\n    function setTokenPeers(\r\n        address srcToken,\r\n        uint256[] calldata chainIds,\r\n        address[] calldata dstTokens\r\n    ) external onlyAdmin {\r\n        require(chainIds.length == dstTokens.length);\r\n        for (uint256 i = 0; i < chainIds.length; i++) {\r\n            tokenPeers[srcToken][chainIds[i]] = dstTokens[i];\r\n        }\r\n    }\r\n\r\n    /// @dev Call by the user to submit a request for a cross chain interaction\r\n    function swapout(\r\n        address token,\r\n        uint256 amount,\r\n        address receiver,\r\n        uint256 toChainId,\r\n        uint256 flags\r\n    ) external payable whenNotPaused(PAUSE_SWAPOUT_ROLE) {\r\n        address clientPeer = clientPeers[toChainId];\r\n        require(clientPeer != address(0), \"AnycallClient: no dest client\");\r\n\r\n        address dstToken = tokenPeers[token][toChainId];\r\n        require(dstToken != address(0), \"AnycallClient: no dest token\");\r\n\r\n        uint256 oldCoinBalance;\r\n        if (msg.value > 0) {\r\n            oldCoinBalance = address(this).balance - msg.value;\r\n        }\r\n\r\n        address _underlying = _getUnderlying(token);\r\n\r\n        if (\r\n            _underlying != address(0) &&\r\n            IERC20(token).balanceOf(msg.sender) < amount\r\n        ) {\r\n            uint256 old_balance = IERC20(_underlying).balanceOf(token);\r\n            IERC20(_underlying).safeTransferFrom(msg.sender, token, amount);\r\n            uint256 new_balance = IERC20(_underlying).balanceOf(token);\r\n            require(\r\n                new_balance >= old_balance &&\r\n                    new_balance <= old_balance + amount\r\n            );\r\n            // update amount to real balance increasement (some token may deduct fees)\r\n            amount = new_balance - old_balance;\r\n        } else {\r\n            assert(IAnyswapToken(token).burn(msg.sender, amount));\r\n        }\r\n\r\n        bytes memory data = abi.encodeWithSelector(\r\n            this.anyExecute.selector,\r\n            token,\r\n            dstToken,\r\n            amount,\r\n            msg.sender,\r\n            receiver,\r\n            toChainId\r\n        );\r\n        IAnycallV6Proxy(callProxy).anyCall{value: msg.value}(\r\n            clientPeer,\r\n            data,\r\n            address(this),\r\n            toChainId,\r\n            flags\r\n        );\r\n\r\n        if (msg.value > 0) {\r\n            uint256 newCoinBalance = address(this).balance;\r\n            if (newCoinBalance > oldCoinBalance) {\r\n                // return remaining fees\r\n                (bool success, ) = msg.sender.call{\r\n                    value: newCoinBalance - oldCoinBalance\r\n                }(\"\");\r\n                require(success);\r\n            }\r\n        }\r\n\r\n        emit LogSwapout(token, msg.sender, receiver, amount, toChainId);\r\n    }\r\n\r\n    /// @notice Call by `AnycallProxy` to execute a cross chain interaction on the destination chain\r\n    function anyExecute(bytes calldata data)\r\n        external\r\n        override\r\n        onlyExecutor\r\n        whenNotPaused(PAUSE_SWAPIN_ROLE)\r\n        returns (bool success, bytes memory result)\r\n    {\r\n        bytes4 selector = bytes4(data[:4]);\r\n        if (selector == this.anyExecute.selector) {\r\n            (\r\n                address srcToken,\r\n                address dstToken,\r\n                uint256 amount,\r\n                address sender,\r\n                address receiver, //uint256 toChainId\r\n\r\n            ) = abi.decode(\r\n                    data[4:],\r\n                    (address, address, uint256, address, address, uint256)\r\n                );\r\n\r\n            (address from, uint256 fromChainId, ) = IAnycallExecutor(executor)\r\n                .context();\r\n            require(\r\n                clientPeers[fromChainId] == from,\r\n                \"AnycallClient: wrong context\"\r\n            );\r\n            require(\r\n                tokenPeers[dstToken][fromChainId] == srcToken,\r\n                \"AnycallClient: mismatch source token\"\r\n            );\r\n\r\n            address _underlying = _getUnderlying(dstToken);\r\n\r\n            if (\r\n                _underlying != address(0) &&\r\n                (IERC20(_underlying).balanceOf(dstToken) >= amount)\r\n            ) {\r\n                IAnyswapToken(dstToken).mint(address(this), amount);\r\n                IAnyswapToken(dstToken).withdraw(amount, receiver);\r\n            } else {\r\n                assert(IAnyswapToken(dstToken).mint(receiver, amount));\r\n            }\r\n\r\n            emit LogSwapin(dstToken, sender, receiver, amount, fromChainId);\r\n        } else if (selector == 0xa35fe8bf) {\r\n            // bytes4(keccak256('anyFallback(address,bytes)'))\r\n            (address _to, bytes memory _data) = abi.decode(\r\n                data[4:],\r\n                (address, bytes)\r\n            );\r\n            anyFallback(_to, _data);\r\n        } else {\r\n            return (false, \"unknown selector\");\r\n        }\r\n        return (true, \"\");\r\n    }\r\n\r\n    /// @dev Call back by `AnycallProxy` on the originating chain if the cross chain interaction fails\r\n    function anyFallback(address to, bytes memory data)\r\n        internal\r\n        whenNotPaused(PAUSE_FALLBACK_ROLE)\r\n    {\r\n        (address _from, , ) = IAnycallExecutor(executor).context();\r\n        require(_from == address(this), \"AnycallClient: wrong context\");\r\n\r\n        (\r\n            bytes4 selector,\r\n            address srcToken,\r\n            address dstToken,\r\n            uint256 amount,\r\n            address from,\r\n            address receiver,\r\n            uint256 toChainId\r\n        ) = abi.decode(\r\n                data,\r\n                (bytes4, address, address, uint256, address, address, uint256)\r\n            );\r\n\r\n        require(\r\n            selector == this.anyExecute.selector,\r\n            \"AnycallClient: wrong fallback data\"\r\n        );\r\n        require(\r\n            clientPeers[toChainId] == to,\r\n            \"AnycallClient: mismatch dest client\"\r\n        );\r\n        require(\r\n            tokenPeers[srcToken][toChainId] == dstToken,\r\n            \"AnycallClient: mismatch dest token\"\r\n        );\r\n\r\n        address _underlying = _getUnderlying(srcToken);\r\n\r\n        if (\r\n            _underlying != address(0) &&\r\n            (IERC20(srcToken).balanceOf(address(this)) >= amount)\r\n        ) {\r\n            IERC20(_underlying).safeTransferFrom(address(this), from, amount);\r\n        } else {\r\n            assert(IAnyswapToken(srcToken).mint(from, amount));\r\n        }\r\n\r\n        emit LogSwapoutFail(srcToken, from, receiver, amount, toChainId);\r\n    }\r\n\r\n    function _getUnderlying(address token) internal returns (address) {\r\n        (bool success, bytes memory returndata) = token.call(\r\n            abi.encodeWithSelector(0x6f307dc3)\r\n        );\r\n        if (success && returndata.length > 0) {\r\n            address _underlying = abi.decode(returndata, (address));\r\n            return _underlying;\r\n        }\r\n        return address(0);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_callProxy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_old\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"ApplyAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_old\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_new\",\"type\":\"address\"}],\"name\":\"ChangeAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromChainId\",\"type\":\"uint256\"}],\"name\":\"LogSwapin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toChainId\",\"type\":\"uint256\"}],\"name\":\"LogSwapout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toChainId\",\"type\":\"uint256\"}],\"name\":\"LogSwapoutFail\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"PAUSE_ALL_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PAUSE_FALLBACK_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PAUSE_SWAPIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PAUSE_SWAPOUT_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"anyExecute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"result\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"applyAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"callProxy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"clientPeers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"executor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_callProxy\",\"type\":\"address\"}],\"name\":\"setCallProxy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_chainIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"_peers\",\"type\":\"address[]\"}],\"name\":\"setClientPeers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"chainIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"dstTokens\",\"type\":\"address[]\"}],\"name\":\"setTokenPeers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"toChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"flags\",\"type\":\"uint256\"}],\"name\":\"swapout\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenPeers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "AnyswapTokenAnycallClient", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000a48174ed840010fbd9aa3fd8bdb6f38834258c88000000000000000000000000c10ef9f491c9b59f936957026020c321651ac078", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://67db7eba544c7ad31076f595274c0fe4927699b30aefe865cf235acc8896b7e3"}