{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.21;\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\r\ninterface IERC721Receiver {\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n \r\n\r\n// File: @openzeppelin\\contracts\\utils\\introspection\\IERC165.sol\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n// File: @openzeppelin\\contracts\\token\\ERC721\\IERC721.sol\r\ninterface IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n    function approve(address to, uint256 tokenId) external;\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin\\contracts\\token\\ERC20\\IERC20.sol\r\ninterface IERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\n// File: @openzeppelin\\contracts\\token\\ERC20\\extensions\\IERC20Metadata.sol\r\ninterface IERC20Metadata is IERC20 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n// File: @openzeppelin\\contracts\\utils\\Context.sol\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin\\contracts\\token\\ERC20\\ERC20.sol\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n    uint256 private _totalSupply;\r\n    string private _name;\r\n    string private _symbol;\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        unchecked {\r\n            _approve(owner, spender, currentAllowance - subtractedValue);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address from, address to, uint256 amount) internal virtual {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\"); \r\n        _beforeTokenTransfer(from, to, amount);\r\n        uint256 fromBalance = _balances[from];\r\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        unchecked {\r\n            _balances[from] = fromBalance - amount;\r\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\r\n            // decrementing then incrementing.\r\n            _balances[to] += amount;\r\n        }\r\n        emit Transfer(from, to, amount);\r\n        _afterTokenTransfer(from, to, amount);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n        _totalSupply += amount;\r\n        unchecked {\r\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\r\n            _balances[account] += amount;\r\n        }\r\n        emit Transfer(address(0), account, amount);\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\r\n            _totalSupply -= amount;\r\n        }\r\n        emit Transfer(account, address(0), amount);\r\n        _afterTokenTransfer(account, address(0), amount);\r\n    }\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\r\n            unchecked {\r\n                _approve(owner, spender, currentAllowance - amount);\r\n            }\r\n        }\r\n    }\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\r\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\r\n}\r\n\r\n// File: @openzeppelin\\contracts\\token\\ERC20\\extensions\\ERC20Burnable.sol\r\nabstract contract ERC20Burnable is Context, ERC20 {\r\n   \r\n    function burn(uint256 amount) public virtual {\r\n        _burn(_msgSender(), amount);\r\n    }\r\n    function burnFrom(address account, uint256 amount) public virtual {\r\n        _spendAllowance(account, _msgSender(), amount);\r\n        _burn(account, amount);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin\\contracts\\access\\Ownable.sol\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n \r\n\r\n\r\n    // import \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\r\n    // import \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\n    // import \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\r\n    // import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n    // import \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\r\n    // import \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\n\r\n\r\n    contract ORG is ERC20 , Ownable , ERC20Burnable , IERC721Receiver  {\r\n   \r\n    function onERC721Received(\r\n            address,\r\n            address,\r\n            uint256,\r\n            bytes calldata\r\n        ) external pure override returns (bytes4) {\r\n            return IERC721Receiver.onERC721Received.selector;\r\n        }\r\n\r\n   \r\n    mapping(uint256 => address) public NFT;\r\n   \r\n \r\n  \r\n    uint256[] public max_reward_persecond;\r\n    uint256[] config_timelock=[7890000,15780000,31560000,47340000,63120000,94680000]; //3,6,12,18,24,36 months\r\n    uint256 constant   config_referral_percent = 10;\r\n    uint256 public unMint = 2e24;\r\n    uint256 public LastUseDeFi;\r\n    uint256 constant   YearlyDistributionDeFi = 5;\r\n    uint256 constant   YearlyDistributionStaking = 5;\r\n    uint256 constant   secondperyears = 31560000;\r\n    address public DeFiContract;\r\n    bool    public DeFiIsFix = false;\r\n    \r\n   \r\n   \r\n    mapping(address => address) public upline;\r\n   \r\n    //log staking\r\n    struct staking {\r\n            address addr;\r\n            uint256 tokenid;\r\n            uint256 timestamp;\r\n            uint256 pid;\r\n            bool thisIn;\r\n        }\r\n      \r\n    staking[] public stakings;\r\n    \r\n     //log staking\r\n    struct nft_log {\r\n            address addr;\r\n            address upline;\r\n            uint256 nft;\r\n            uint256 timestamp;\r\n            uint256 lastclaim;\r\n            uint256 rewardpersecond;\r\n            uint256 pid;\r\n        }\r\n     mapping(uint256 => nft_log) public nft_logs;\r\n\r\n\r\n    //log staking user\r\n    struct nft_users {\r\n            uint256 timestamp;\r\n            uint256 tokenId;\r\n            bool thisIn;\r\n        }\r\n     mapping(address => nft_users[]) public nftlogs;\r\n     uint256 public CountLockedNftFloor = 0;\r\n\r\n  \r\n    constructor() ERC20(\"ONERICH GROUP\", \"ORG\") {\r\n\r\n         _limit_mint(msg.sender, 2e23); //initial mint\r\n        max_reward_persecond =[1e10,1e10,1e10,1e10,1e10,1e10];\r\n        LastUseDeFi = block.timestamp;\r\n     \r\n\r\n        NFT[100]=0xdB92bE5d6ef6136c3e8d54e161A10E83E4F4A113;\r\n        NFT[1000]=0xAE2650dFD2b0D435fc395EeDf2fd14e30AF9A354;\r\n        NFT[10000]=0x909a73b84C5D394d8fFbf1af87a6686dBdD814Ec;\r\n        NFT[100000]=0x891a9b49c02bD3c87b89e7d0fAd209A4f5f7f440;\r\n\r\n    }\r\n\r\n    event Stake(address addr, address nft , uint256 tokenId, uint256 pid);\r\n    event Unstake(address addr, address nft , uint256 tokenId, uint256 pid);\r\n    event Claim(address addr, uint256 tokenId, uint256 amount);\r\n    event Affiliate(address addr, uint256 tokenId, uint256 amount);\r\n    event SendToDefi(uint256 time, uint256 amount);\r\n    \r\n\r\n    //protector max suply\r\n    function  _limit_mint(address a,uint256 b) internal {\r\n        if(unMint<b) return; \r\n        _mint(a, b);\r\n        unMint = unMint - b;\r\n    }\r\n\r\n     function maxSupply() public view returns(uint256) {\r\n       return unMint + totalSupply();\r\n    }\r\n\r\n \r\n   //reconfig reward per second to set max APR\r\n    function reconfig_reward(uint256  reward1,uint256  reward2,uint256  reward3,uint256  reward4,uint256  reward5,uint256  reward6) public onlyOwner  {\r\n        if(reward1>0)max_reward_persecond[0] = reward1;//unable set to zero\r\n        if(reward2>0)max_reward_persecond[1] = reward2;//unable set to zero\r\n        if(reward3>0)max_reward_persecond[2] = reward3;//unable set to zero\r\n        if(reward4>0)max_reward_persecond[3] = reward4;//unable set to zero\r\n        if(reward5>0)max_reward_persecond[4] = reward5;//unable set to zero\r\n        if(reward6>0)max_reward_persecond[5] = reward6;//unable set to zero\r\n        \r\n    }\r\n\r\n   //stakeing nft \r\n    function stake( address Upline,uint256 tokenId,uint256 nft,uint256 pid) public {\r\n        require(tokenId>0,\"Require nft id\");\r\n        require(Upline != msg.sender,\"Upline invalid\");\r\n        require(pid <=5 ,\"Invalid pid\");\r\n        require(NFT[nft] != address(0),\"Require valid nft\");\r\n\r\n        nft_log storage nftdata = nft_logs[tokenId];      \r\n        IERC721(NFT[nft]).safeTransferFrom(msg.sender, address(this), tokenId);\r\n\r\n\r\n        if(upline[msg.sender] != address(0)) Upline = upline[msg.sender];\r\n        else upline[msg.sender] = Upline;\r\n        \r\n        //Note the data of staking at contract   \r\n        nftdata.addr        = msg.sender;\r\n        nftdata.upline      = Upline;\r\n        nftdata.timestamp   = block.timestamp + config_timelock[pid];\r\n        nftdata.lastclaim   = block.timestamp;\r\n        nftdata.rewardpersecond = max_reward_persecond[pid];\r\n        nftdata.pid = pid;\r\n        nftdata.nft = nft;\r\n\r\n        CountLockedNftFloor=CountLockedNftFloor + nft;\r\n\r\n        \r\n        //log the staking data in array\r\n        stakings.push(staking({\r\n            addr:msg.sender,\r\n            tokenid:tokenId,\r\n            timestamp:block.timestamp,\r\n            pid:pid,\r\n            thisIn:true\r\n        }));\r\n\r\n        //Log users staking In+Out\r\n        nftlogs[msg.sender].push(nft_users({\r\n            tokenId:tokenId,\r\n            timestamp: nftdata.timestamp,\r\n            thisIn:true\r\n        }));\r\n        \r\n        \r\n    emit Stake(msg.sender, NFT[nft] ,tokenId,pid);\r\n    \r\n    }\r\n\r\n    function stakings_length() public view returns(uint256) {\r\n         return stakings.length;\r\n     }\r\n    function user_stakings_length(address _user) public view returns(uint256) {\r\n         return nftlogs[_user].length;\r\n    }\r\n\r\n \r\n    // Staking distribution limit | YearlyDistributionStaking\r\n    function pendingreward(uint256 tokenId) public view returns(uint256) {\r\n        if(nft_logs[tokenId].addr==address(0)) return 0;\r\n        uint256 persecond = (((YearlyDistributionStaking * unMint * nft_logs[tokenId].nft)/100)/secondperyears)/CountLockedNftFloor;\r\n        uint256 diverent = (block.timestamp - nft_logs[tokenId].lastclaim) * persecond;\r\n        uint256 unMintAfterDiverent = unMint - diverent ; //Math.min(unmintbefore,unmintafter)\r\n        uint256 floor_persecond  = (((YearlyDistributionStaking * unMintAfterDiverent * nft_logs[tokenId].nft) / 100) / secondperyears)/CountLockedNftFloor;\r\n        uint256 AvailableReward  = (block.timestamp - nft_logs[tokenId].lastclaim) * floor_persecond;\r\n        uint256 MaxReward = (block.timestamp - nft_logs[tokenId].lastclaim) * nft_logs[tokenId].rewardpersecond * nft_logs[tokenId].nft;\r\n        if(MaxReward>AvailableReward)MaxReward = AvailableReward;\r\n        return  MaxReward ;\r\n     }\r\n\r\n\r\n\r\n    // anyone can help to process claim reward \r\n    function claim_staking_reward(uint256 tokenId) public  {\r\n       uint256 pending = pendingreward(tokenId);\r\n       nft_log storage nftdata = nft_logs[tokenId];\r\n          if(pending>0){\r\n              if(nftdata.upline != address(0)){\r\n                uint256 affReward  = (pending * config_referral_percent) / 100;\r\n                _limit_mint(nftdata.upline, affReward);  \r\n                emit Affiliate(nftdata.upline, tokenId, affReward);\r\n    \r\n              }\r\n               _limit_mint(nftdata.addr, pending);     \r\n          }\r\n        nftdata.lastclaim = block.timestamp;\r\n        nftdata.rewardpersecond = max_reward_persecond[nftdata.pid];\r\n      \r\n        emit Claim(nftdata.addr,tokenId,pending);\r\n    \r\n     }\r\n\r\n\r\n    function configinfo_reward() public view returns(uint256,uint256,uint256,uint256,uint256,uint256) {\r\n      return (\r\n           max_reward_persecond[0]>0?max_reward_persecond[0]:0,\r\n           max_reward_persecond[1]>0?max_reward_persecond[1]:0,\r\n           max_reward_persecond[2]>0?max_reward_persecond[2]:0,\r\n           max_reward_persecond[3]>0?max_reward_persecond[3]:0,\r\n           max_reward_persecond[4]>0?max_reward_persecond[4]:0,\r\n           max_reward_persecond[5]>0?max_reward_persecond[5]:0\r\n       );\r\n\r\n    }\r\n\r\n \r\n    function unstake(uint256 tokenId ,bool is_emergency) public {\r\n        require(tokenId>0,\"Require tokenId\");\r\n        if(!is_emergency){\r\n        claim_staking_reward(tokenId);\r\n        }\r\n        nft_log storage nftdata = nft_logs[tokenId];\r\n        if(nftdata.timestamp<=block.timestamp && nftdata.addr==msg.sender){\r\n            IERC721(NFT[nftdata.nft]).safeTransferFrom(address(this),msg.sender, tokenId);\r\n\r\n            emit Unstake(nftdata.addr,nftdata.addr ,   tokenId, nftdata.pid);\r\n   \r\n\r\n            //reset data after unstaking\r\n            nftdata.addr = address(0);\r\n            nftdata.timestamp = 0;\r\n            nftdata.lastclaim = 0;\r\n\r\n            CountLockedNftFloor=CountLockedNftFloor - nftdata.nft;\r\n\r\n            stakings.push(staking({\r\n                addr:msg.sender,\r\n                tokenid:tokenId,\r\n                timestamp:block.timestamp,\r\n                pid : nftdata.pid,\r\n                thisIn:false\r\n            }));\r\n\r\n            nftlogs[msg.sender].push(nft_users({\r\n                tokenId:tokenId,\r\n                timestamp: nftdata.timestamp,\r\n                thisIn:false\r\n            })); \r\n\r\n          \r\n         }\r\n        \r\n      \r\n    \r\n      }\r\n     \r\n \r\n\r\n      // DeFi FUNCTION\r\n      // DeFi distribution limit | YearlyDistributionDeFi\r\n    function defiPool() public view returns(uint256) {\r\n        uint256 persecond = ((YearlyDistributionDeFi * unMint) / 100) / secondperyears;\r\n        uint256 diverent = (block.timestamp - LastUseDeFi) * persecond;\r\n        uint256 unMintAfterDiverent = unMint - diverent;\r\n        uint256 floor_persecond = ((YearlyDistributionDeFi * unMintAfterDiverent) / 100) / secondperyears;\r\n        uint256 unUseDeFiPool = (block.timestamp - LastUseDeFi) * floor_persecond;\r\n        return unUseDeFiPool;\r\n    }\r\n\r\n    // unable to change contract after fix\r\n    function setContract(address defi) public onlyOwner {\r\n         require(!DeFiIsFix,\"Unable to change DeFi contract\");\r\n         require(defi != address(0),\"Unable to change DeFi contract\");\r\n         DeFiContract = defi;\r\n    }\r\n\r\n    // onetime setup , unable to undo\r\n    function SetFixDefi() public onlyOwner { \r\n         require(DeFiContract != address(0),\"Unable to change DeFi contract\");\r\n         DeFiIsFix = true;\r\n    }\r\n    \r\n    // move reward alocation to DeFi contract\r\n    function moveToDefi() public {\r\n        require(DeFiContract != address(0),\"Unset DeFi Contract\");\r\n        uint256 amount = defiPool();\r\n        if(amount>0)_limit_mint(DeFiContract,amount);\r\n        LastUseDeFi =block.timestamp;\r\n        emit SendToDefi(LastUseDeFi ,  amount);\r\n    \r\n        \r\n    }\r\n\r\n     \r\n }", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Affiliate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SendToDefi\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"}],\"name\":\"Unstake\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CountLockedNftFloor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DeFiContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DeFiIsFix\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LastUseDeFi\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"NFT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SetFixDefi\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"claim_staking_reward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"configinfo_reward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defiPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"max_reward_persecond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"moveToDefi\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nft_logs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"upline\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nft\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastclaim\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardpersecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nftlogs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"thisIn\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"pendingreward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"reward1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward4\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward5\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward6\",\"type\":\"uint256\"}],\"name\":\"reconfig_reward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"defi\",\"type\":\"address\"}],\"name\":\"setContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Upline\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nft\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakings\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"thisIn\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakings_length\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"is_emergency\",\"type\":\"bool\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"upline\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"user_stakings_length\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ORG", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://aa181518016905b42080dc2d2c9c5a3c0e0b47a59fd3a9aed12c68356601195a"}