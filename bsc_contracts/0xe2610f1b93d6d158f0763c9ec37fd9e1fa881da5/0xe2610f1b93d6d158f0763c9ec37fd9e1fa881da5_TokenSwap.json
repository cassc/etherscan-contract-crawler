{"SourceCode": "{\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n// CAUTION\\r\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\r\\n// because it relies on the compiler\\u0027s built in overflow checks.\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations.\\r\\n *\\r\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\r\\n * now has built in overflow checking.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            uint256 c = a + b;\\r\\n            if (c \\u003c a) return (false, 0);\\r\\n            return (true, c);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b \\u003e a) return (false, 0);\\r\\n            return (true, a - b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n            // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n            if (a == 0) return (true, 0);\\r\\n            uint256 c = a * b;\\r\\n            if (c / a != b) return (false, 0);\\r\\n            return (true, c);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b == 0) return (false, 0);\\r\\n            return (true, a / b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\r\\n     *\\r\\n     * _Available since v3.4._\\r\\n     */\\r\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n        unchecked {\\r\\n            if (b == 0) return (false, 0);\\r\\n            return (true, a % b);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a + b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a * b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * reverting when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a % b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\r\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(b \\u003c= a, errorMessage);\\r\\n            return a - b;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(b \\u003e 0, errorMessage);\\r\\n            return a / b;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * reverting with custom message when dividing by zero.\\r\\n     *\\r\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\r\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        unchecked {\\r\\n            require(b \\u003e 0, errorMessage);\\r\\n            return a % b;\\r\\n        }\\r\\n    }\\r\\n}\"},\"SwapContract.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\n\\r\\n\\r\\ninterface call {\\r\\n    function Updateuser(address adr)external view returns(uint256);\\r\\n    \\r\\n}\\r\\n\\r\\ninterface IERC20 {\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n    function transfer(address to, uint256 value) external returns (bool);\\r\\n    function burn(uint256 _amount,address user) external returns(bool);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n}\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        this; \\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    constructor() {\\r\\n        _setOwner(_msgSender());\\r\\n    }\\r\\n\\r\\n    function Owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(Owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _setOwner(address(0));\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        _setOwner(newOwner);\\r\\n    }\\r\\n\\r\\n    function _setOwner(address newOwner) private {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract TokenSwap is Ownable {\\r\\n    uint256 public sponsorPercentage = 2;\\r\\n    uint256 public developerPercentage = 5;\\r\\n    using SafeMath for uint256;\\r\\n    uint256 private key;\\r\\n    address public developer;\\r\\n    address public owner;\\r\\n    uint256 public flag;\\r\\n    address public tokenAddress;  // Address of your token contract\\r\\n    address public usdtAddress;   // Address of the USDT contract\\r\\n    uint256 public exchangeRate;   // Exchange rate between your token and USDT\\r\\n    uint256 private updateTime;\\r\\n    uint256 private limit;\\r\\n    bool public open = true;\\r\\n    uint256 public denominator = 100000;\\r\\n     call private calls;\\r\\n\\r\\n\\r\\n    \\r\\n    constructor(address _tokenAddress, address _usdtAddress, uint256 Exchangerate,uint256 _time,uint256 _limit) {\\r\\n        tokenAddress = _tokenAddress;\\r\\n        usdtAddress = _usdtAddress;\\r\\n        exchangeRate = Exchangerate;\\r\\n        updateTime = _time;\\r\\n        calls = call(_tokenAddress);\\r\\n        limit = _limit;\\r\\n\\r\\n    }\\r\\n   \\r\\n\\r\\n       modifier onlyaddress() {    \\r\\n        require(getUserActive(_msgSender()) \\u003e 0, \\\"Only valid address call this method\\\");\\r\\n        _;\\r\\n    }\\r\\n     function getUserActive(address adr) public view returns(uint256 value){\\r\\n        value = calls.Updateuser(adr);\\r\\n     }\\r\\n \\r\\n    function setExchangeRate(uint256 newRate) external onlyOwner {\\r\\n        exchangeRate = newRate;\\r\\n    }\\r\\n    function setusdtAddress(address _address)external onlyOwner{\\r\\n        usdtAddress = _address;\\r\\n    }\\r\\n       function setTokenAddress(address _address)external onlyOwner{\\r\\n        tokenAddress = _address;\\r\\n    }\\r\\n        function setDeveloperAddress(address developerAddress)external  onlyOwner{\\r\\n        developer = developerAddress;\\r\\n    }\\r\\n    \\r\\n    function swapTokens(uint256 _amount,address sponsor, uint256 _key) external onlyaddress {\\r\\n        require(getKey() == _key,\\\"You not call directly\\\");\\r\\n        require(open,\\\"At a movement swap is closed\\\");\\r\\n        IERC20 token = IERC20(tokenAddress);\\r\\n        require(_amount \\u003c= token.balanceOf(_msgSender()),\\\"please enter valid amount\\\");\\r\\n        if(updateTime + 1 days \\u003c getCurrentTime()) {\\r\\n            updateTime = block.timestamp;\\r\\n            flag = 0;\\r\\n        }\\r\\n        require(flag \\u003c 100*10**18,\\\"Please try for sometime\\\");\\r\\n        require(_amount \\u003e 0, \\\"Token amount must be greater than 0\\\");\\r\\n        IERC20 usdt = IERC20(usdtAddress);\\r\\n        require(token.transferFrom(_msgSender(), address(this), _amount), \\\"Token transfer failed\\\");\\r\\n        uint256 usdtAmT = (_amount.mul(exchangeRate)).div(denominator);\\r\\n        require(usdtAmT \\u003c limit*10**18,\\\"You are try more than the limit\\\");\\r\\n        uint256 sponsorReward = (usdtAmT.mul(sponsorPercentage)).div(100);\\r\\n        uint256 developerReward = (usdtAmT.mul(developerPercentage)).div(100);\\r\\n        uint256 usdtAmount = usdtAmT - developerReward - sponsorReward ;\\r\\n        uint256 val=  (usdtAmT.mul(100)).div(limit);\\r\\n        require( val \\u003e 0 \\u0026\\u0026 100*10**18 - flag \\u003e= val,\\\"\\\");\\r\\n        flag += val;\\r\\n        (token).burn(_amount,address(this));\\r\\n\\r\\n       \\r\\n        require(usdt.transfer(_msgSender(), usdtAmount), \\\"USDT transfer failed\\\");\\r\\n        require(usdt.transfer(developer,developerReward), \\\"USDT transfer failed\\\");\\r\\n        require(usdt.transfer(sponsor, sponsorReward), \\\"USDT transfer failed\\\");\\r\\n    }   \\r\\n\\r\\n    function setOpen(bool status)external onlyOwner{\\r\\n        open = status;\\r\\n    }\\r\\n    \\r\\n      function setKey(uint256 _key)external onlyOwner{\\r\\n         key = _key;\\r\\n     }\\r\\n     function getKey()private view returns(uint256) {\\r\\n        return key;\\r\\n    }\\r\\n    function setlimit(uint256 set)external onlyOwner{\\r\\n        limit = set;\\r\\n    }\\r\\n    \\r\\n     function RescueAmountMHTtoken(address reciver, uint256 amount)external onlyOwner{\\r\\n        IERC20 token = IERC20(tokenAddress);\\r\\n        require(amount \\u003c= token.balanceOf(address(this)),\\\"please enter valid amount\\\");\\r\\n        require(token.transfer(reciver, amount),\\\"transaction failed\\\");\\r\\n    }\\r\\n\\r\\n       function _RescueAmountusdt(address reciver, uint256 amount)external onlyOwner{\\r\\n        IERC20 token = IERC20(usdtAddress);\\r\\n        require(amount \\u003c= token.balanceOf(address(this)),\\\"please enter valid amount\\\");\\r\\n        require(token.transfer(reciver, amount),\\\"transaction failed\\\");\\r\\n    }\\r\\n\\r\\n    function getCurrentTime()internal view  returns(uint256){\\r\\n        return block.timestamp;\\r\\n    }\\r\\n\\r\\n\\r\\n}\\r\\n\\r\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_usdtAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"Exchangerate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_limit\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"Owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"reciver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RescueAmountMHTtoken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"reciver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"_RescueAmountusdt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"denominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"developer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"developerPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flag\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"getUserActive\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"open\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"developerAddress\",\"type\":\"address\"}],\"name\":\"setDeveloperAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"setExchangeRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_key\",\"type\":\"uint256\"}],\"name\":\"setKey\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setOpen\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setTokenAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"set\",\"type\":\"uint256\"}],\"name\":\"setlimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setusdtAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sponsorPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_key\",\"type\":\"uint256\"}],\"name\":\"swapTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdtAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "TokenSwap", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000ca21f7f9c1f44b768a63c54893269ed3bdba641f00000000000000000000000055d398326f99059ff775485246999027b3197955000000000000000000000000000000000000000000000000000000000000271000000000000000000000000000000000000000000000000000000000653b6ffe00000000000000000000000000000000000000000000000000000000000000c8", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d692046eebb646c2dd7a50f95039996180eb094fe4dfb62a7ed115260a94fcce"}