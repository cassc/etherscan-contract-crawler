{"SourceCode": "// \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588    \u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588      \u2588\u2588    \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588    \u2588\u2588\r\n// \u2588\u2588   \u2588\u2588 \u2588\u2588      \u2588\u2588    \u2588\u2588 \u2588\u2588    \u2588\u2588 \u2588\u2588      \u2588\u2588    \u2588\u2588     \u2588\u2588  \u2588\u2588 \u2588\u2588    \u2588\u2588 \u2588\u2588\u2588\u2588   \u2588\u2588\r\n// \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588   \u2588\u2588    \u2588\u2588 \u2588\u2588    \u2588\u2588 \u2588\u2588      \u2588\u2588    \u2588\u2588   \u2588\u2588    \u2588\u2588 \u2588\u2588    \u2588\u2588 \u2588\u2588 \u2588\u2588  \u2588\u2588\r\n// \u2588\u2588   \u2588\u2588 \u2588\u2588       \u2588\u2588  \u2588\u2588  \u2588\u2588    \u2588\u2588 \u2588\u2588      \u2588\u2588    \u2588\u2588  \u2588\u2588     \u2588\u2588 \u2588\u2588    \u2588\u2588 \u2588\u2588  \u2588\u2588 \u2588\u2588\r\n// \u2588\u2588   \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588    \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588  \u2588\u2588   \u2588\u2588\u2588\u2588\r\n\r\n// CONTRACT DEVELOPED BY REVOLUZION\r\n\r\n//Revoluzion Ecosystem\r\n//WEB: https://revoluzion.io\r\n//DAPP: https://revoluzion.app\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.18;\r\n\r\n/********************************************************************************************\r\n  INTERFACE\r\n********************************************************************************************/\r\n\r\ninterface IERC20 {\r\n    // EVENT\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    // FUNCTION\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\ninterface IRouter {\r\n    // FUNCTION\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function factory() external pure returns (address);\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable;\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\r\n}\r\n\r\ninterface IAuthError {\r\n    // ERROR\r\n\r\n    error InvalidOwner(address account);\r\n\r\n    error UnauthorizedAccount(address account);\r\n\r\n    error InvalidAuthorizedAccount(address account);\r\n\r\n    error CurrentAuthorizedState(address account, bool state);\r\n}\r\n\r\ninterface ICommonError {\r\n    // ERROR\r\n\r\n    error CannotUseCurrentAddress(address current);\r\n\r\n    error CannotUseCurrentValue(uint256 current);\r\n\r\n    error CannotUseCurrentState(bool current);\r\n\r\n    error InvalidAddress(address invalid);\r\n\r\n    error InvalidValue(uint256 invalid);\r\n}\r\n\r\ninterface IStaking {\r\n    // DATA\r\n\r\n    struct Leaderboard {\r\n        uint256 stakeAmount;\r\n        address user;\r\n    }\r\n\r\n    // FUNCTION\r\n\r\n    function isWDYMStaking() external pure returns (bool);\r\n\r\n    function stake(uint256 amount, uint256 stakeTypeId) external;\r\n\r\n    function unstake(uint256 amount, uint256 stakeId) external;\r\n\r\n    function userTotalStakes(address user) external returns (uint256);\r\n\r\n    function getStakeTypeRewardMaxRatio() external view returns (uint256);\r\n\r\n    function getLeaderboard() external view returns (Leaderboard[] memory);\r\n\r\n    function deposit() external payable;\r\n\r\n    function depositStuckedBNB() external;\r\n\r\n    function depositBUSD(uint256 amount) external;\r\n\r\n    function depositStuckedBUSD(uint256 amount) external;\r\n}\r\n\r\ninterface IWDYM is IERC20 {\r\n    // FUNCTION\r\n\r\n    function isWDYM() external pure returns (bool);\r\n}\r\n\r\n/********************************************************************************************\r\n  ACCESS\r\n********************************************************************************************/\r\n\r\nabstract contract Auth is IAuthError {\r\n    // DATA\r\n\r\n    address private _owner;\r\n\r\n    // MAPPING\r\n\r\n    mapping(address => bool) public authorization;\r\n\r\n    // MODIFIER\r\n\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    modifier authorized() {\r\n        _checkAuthorized();\r\n        _;\r\n    }\r\n\r\n    // CONSTRUCCTOR\r\n\r\n    constructor(address initialOwner) {\r\n        _transferOwnership(initialOwner);\r\n        authorize(initialOwner);\r\n        if (initialOwner != msg.sender) {\r\n            authorize(msg.sender);\r\n        }\r\n    }\r\n\r\n    // EVENT\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    event UpdateAuthorizedAccount(\r\n        address authorizedAccount,\r\n        address caller,\r\n        bool state,\r\n        uint256 timestamp\r\n    );\r\n\r\n    // FUNCTION\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function _checkOwner() internal view virtual {\r\n        if (owner() != msg.sender) {\r\n            revert UnauthorizedAccount(msg.sender);\r\n        }\r\n    }\r\n\r\n    function _checkAuthorized() internal view virtual {\r\n        if (!authorization[msg.sender]) {\r\n            revert UnauthorizedAccount(msg.sender);\r\n        }\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        if (newOwner == address(0)) {\r\n            revert InvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function authorize(address account) public virtual onlyOwner {\r\n        if (account == address(0) || account == address(0xdead)) {\r\n            revert InvalidAuthorizedAccount(account);\r\n        }\r\n        _authorization(account, msg.sender, true);\r\n    }\r\n\r\n    function unauthorize(address account) public virtual onlyOwner {\r\n        if (account == address(0) || account == address(0xdead)) {\r\n            revert InvalidAuthorizedAccount(account);\r\n        }\r\n        _authorization(account, msg.sender, false);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n\r\n    function _authorization(\r\n        address account,\r\n        address caller,\r\n        bool state\r\n    ) internal virtual {\r\n        if (authorization[account] == state) {\r\n            revert CurrentAuthorizedState(account, state);\r\n        }\r\n        authorization[account] = state;\r\n        emit UpdateAuthorizedAccount(account, caller, state, block.timestamp);\r\n    }\r\n}\r\n\r\n/********************************************************************************************\r\n  SECURITY\r\n********************************************************************************************/\r\n\r\nabstract contract Pausable {\r\n    // DATA\r\n\r\n    bool private _paused;\r\n\r\n    // ERROR\r\n\r\n    error EnforcedPause();\r\n\r\n    error ExpectedPause();\r\n\r\n    // MODIFIER\r\n\r\n    modifier whenNotPaused() {\r\n        _requireNotPaused();\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused() {\r\n        _requirePaused();\r\n        _;\r\n    }\r\n\r\n    // CONSTRUCTOR\r\n\r\n    constructor() {\r\n        _paused = false;\r\n    }\r\n\r\n    // EVENT\r\n\r\n    event Paused(address account);\r\n\r\n    event Unpaused(address account);\r\n\r\n    // FUNCTION\r\n\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    function pause() external virtual whenNotPaused {\r\n        _pause();\r\n    }\r\n\r\n    function unpause() external virtual whenPaused {\r\n        _unpause();\r\n    }\r\n\r\n    function _requireNotPaused() internal view virtual {\r\n        if (paused()) {\r\n            revert EnforcedPause();\r\n        }\r\n    }\r\n\r\n    function _requirePaused() internal view virtual {\r\n        if (!paused()) {\r\n            revert ExpectedPause();\r\n        }\r\n    }\r\n\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(msg.sender);\r\n    }\r\n\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(msg.sender);\r\n    }\r\n}\r\n\r\n/********************************************************************************************\r\n  STAKING\r\n********************************************************************************************/\r\n\r\ncontract WhatDoYouMemeStaking is Auth, Pausable, ICommonError, IStaking {\r\n    // DATA\r\n\r\n    struct RewardPool {\r\n        uint256 id;\r\n        uint256 amountAdded;\r\n        uint256 amountClaimed;\r\n        uint256 rewardsPerStake;\r\n        uint256 timestamp;\r\n    }\r\n\r\n    struct Stake {\r\n        uint256 stakeType;\r\n        uint256 amount;\r\n        uint256 timestamp;\r\n        uint256 startPoolIndex;\r\n        uint256 totalExcluded;\r\n        uint256 totalRealised;\r\n    }\r\n\r\n    IRouter public router;\r\n\r\n    IERC20 public constant REWARD =\r\n        IERC20(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\r\n    IWDYM public constant TOKEN =\r\n        IWDYM(0x769c6F0C5c2BcD1B76638BD58e5350f5c94128F3);\r\n\r\n    RewardPool[] public rewardPools;\r\n\r\n    uint256 public constant DENOMINATOR = 10_000;\r\n\r\n    uint256 public immutable rewardsPerStakeAccuracyFactor;\r\n\r\n    uint256 public amountToRedistribute = 0;\r\n    uint256 public penaltyPercentage = 0;\r\n    uint256 public totalStaked = 0;\r\n    uint256 public totalRewards = 0;\r\n    uint256 public totalDistributed = 0;\r\n    uint256 public rewardsPerStake = 0;\r\n    uint256 public currentPoolIndex = 0;\r\n    uint256 public stakeType = 3;\r\n\r\n    uint256[] public rewardRatio = [100, 150, 300];\r\n\r\n    address private constant DEAD = address(0xdead);\r\n    address private constant ZERO = address(0);\r\n\r\n    address public penaltyReceiver;\r\n\r\n    address[] public stakers;\r\n\r\n    bool private constant ISWDYM_STAKING = true;\r\n\r\n    bool public takePenalty = false;\r\n    bool public emergencyWithdraw = false;\r\n\r\n    // MAPPING\r\n\r\n    mapping(uint256 => uint256) public stakeTypeToDuration;\r\n    mapping(address => uint256) public stakerIndexes;\r\n    mapping(address => uint256) public userTotalStakes;\r\n    mapping(address => uint256) public userStaking;\r\n    mapping(address => uint256) public userActiveStaking;\r\n    mapping(address => uint256) public userInactiveStaking;\r\n    mapping(address => mapping(uint256 => Stake)) public userStakes;\r\n\r\n    // ERROR\r\n\r\n    error InvalidRewardPoolId();\r\n\r\n    error InvalidStakeId();\r\n\r\n    error EmergencyWithdrawDisabled();\r\n\r\n    error NoStakingRewards();\r\n\r\n    error NotTimeToUnstake(uint256 unstakeTime, uint256 timeNow);\r\n\r\n    error ExceedUserStakeId(uint256 maxIdValue);\r\n\r\n    error ExceedStakeBalance(uint256 balance);\r\n\r\n    error ExceedStakeTypeRange(uint256 maxRange);\r\n\r\n    error ExceedStuckedBalance(uint256 balance);\r\n\r\n    // CONSTRUCTOR\r\n\r\n    constructor(\r\n        address routerAddress,\r\n        address penaltyReceiverAddress\r\n    ) Auth(msg.sender) {\r\n        if (penaltyReceiverAddress == ZERO || penaltyReceiverAddress == DEAD) {\r\n            revert InvalidAddress(penaltyReceiverAddress);\r\n        }\r\n        router = IRouter(routerAddress);\r\n        penaltyReceiver = penaltyReceiverAddress;\r\n        rewardsPerStakeAccuracyFactor = 1 ether * 1 ether;\r\n        stakeTypeToDuration[1] = 90 days;\r\n        stakeTypeToDuration[2] = 180 days;\r\n        stakeTypeToDuration[3] = 365 days;\r\n    }\r\n\r\n    // EVENT\r\n\r\n    event UpdateRouter(\r\n        IRouter oldRouter,\r\n        IRouter newRouter,\r\n        address sender,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event UpdatePenaltyReceiver(\r\n        address oldReceiver,\r\n        address newReceiver,\r\n        address sender,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event UpdatePenalty(\r\n        uint256 oldPenalty,\r\n        uint256 newPenalty,\r\n        address sender,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event UpdateTakePenalty(\r\n        bool oldState,\r\n        bool newState,\r\n        address sender,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event UpdateEmergencyWithdraw(\r\n        bool oldState,\r\n        bool newState,\r\n        address sender,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event RewardDistribution(\r\n        uint256 balance,\r\n        uint256 distributed,\r\n        address sender,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event RewardRescued(\r\n        uint256 balance,\r\n        uint256 distributed,\r\n        address sender,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event Staked(address indexed staker, uint256 amount);\r\n\r\n    event Unstaked(address indexed staker, uint256 amount);\r\n\r\n    // FUNCTION\r\n\r\n    /* General */\r\n\r\n    receive() external payable {}\r\n\r\n    function isWDYMStaking() external pure returns (bool) {\r\n        return ISWDYM_STAKING;\r\n    }\r\n\r\n    /* Update */\r\n\r\n    function addStakeType(uint256 duration, uint256 ratio) external authorized {\r\n        if (duration <= 0) {\r\n            revert InvalidValue(duration);\r\n        }\r\n        stakeType += 1;\r\n        stakeTypeToDuration[stakeType] = duration;\r\n        rewardRatio.push(ratio);\r\n    }\r\n\r\n    function removeStakeType(uint256 amount) external authorized {\r\n        if (amount <= 0) {\r\n            revert InvalidValue(amount);\r\n        }\r\n        if (amount > stakeType) {\r\n            revert ExceedStakeTypeRange(stakeType);\r\n        }\r\n        for (uint256 i = stakeType; i > stakeType - amount; i--) {\r\n            stakeTypeToDuration[i] = 0;\r\n            rewardRatio.pop();\r\n        }\r\n        stakeType -= amount;\r\n    }\r\n\r\n    function modifyStakeType(\r\n        uint256 index,\r\n        uint256 duration,\r\n        uint256 ratio\r\n    ) external authorized {\r\n        if (duration <= 0) {\r\n            revert InvalidValue(duration);\r\n        }\r\n        if (index <= 0) {\r\n            revert InvalidValue(index);\r\n        }\r\n        if (index > stakeType) {\r\n            revert ExceedStakeTypeRange(stakeType);\r\n        }\r\n        stakeTypeToDuration[index] = duration;\r\n        rewardRatio[index - 1] = ratio;\r\n    }\r\n\r\n    function updateRouter(IRouter newRouter) external authorized {\r\n        if (newRouter == router) {\r\n            revert CannotUseCurrentAddress(address(newRouter));\r\n        }\r\n        IRouter oldRouter = router;\r\n        router = newRouter;\r\n        emit UpdateRouter(oldRouter, newRouter, msg.sender, block.timestamp);\r\n    }\r\n\r\n    function updatePenaltyReceiver(address newReceiver) external authorized {\r\n        if (newReceiver == penaltyReceiver) {\r\n            revert CannotUseCurrentAddress(newReceiver);\r\n        }\r\n        if (newReceiver == ZERO) {\r\n            revert InvalidAddress(newReceiver);\r\n        }\r\n        if (newReceiver == DEAD) {\r\n            revert InvalidAddress(newReceiver);\r\n        }\r\n        address oldReceiver = penaltyReceiver;\r\n        penaltyReceiver = newReceiver;\r\n        emit UpdatePenaltyReceiver(\r\n            oldReceiver,\r\n            newReceiver,\r\n            msg.sender,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function updatePenalty(uint256 newPenalty) external authorized {\r\n        if (newPenalty == penaltyPercentage) {\r\n            revert CannotUseCurrentValue(newPenalty);\r\n        }\r\n        if (penaltyPercentage > 2_000) {\r\n            revert InvalidValue(newPenalty);\r\n        }\r\n        uint256 oldPenalty = penaltyPercentage;\r\n        penaltyPercentage = newPenalty;\r\n        emit UpdatePenalty(oldPenalty, newPenalty, msg.sender, block.timestamp);\r\n    }\r\n\r\n    function updateTakePenalty(bool newState) external authorized {\r\n        if (newState == takePenalty) {\r\n            revert CannotUseCurrentState(newState);\r\n        }\r\n        bool oldState = takePenalty;\r\n        takePenalty = newState;\r\n        emit UpdateTakePenalty(oldState, newState, msg.sender, block.timestamp);\r\n    }\r\n\r\n    function updateEmergencyWithdraw(bool newState) external authorized {\r\n        if (newState == emergencyWithdraw) {\r\n            revert CannotUseCurrentState(newState);\r\n        }\r\n        bool oldState = emergencyWithdraw;\r\n        emergencyWithdraw = newState;\r\n        emit UpdateEmergencyWithdraw(\r\n            oldState,\r\n            newState,\r\n            msg.sender,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    /* Check */\r\n\r\n    function getStakeTypeRewardMaxRatio()\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        uint256 maxRatio = 0;\r\n        for (uint256 i = 0; i < rewardRatio.length; i++) {\r\n            if (maxRatio < rewardRatio[i]) {\r\n                maxRatio = rewardRatio[i];\r\n            }\r\n        }\r\n        return maxRatio;\r\n    }\r\n\r\n    function getLeaderboard()\r\n        external\r\n        view\r\n        override\r\n        returns (Leaderboard[] memory)\r\n    {\r\n        Leaderboard[] memory board = new Leaderboard[](stakers.length);\r\n        for (uint256 i = 0; i < stakers.length; i++) {\r\n            address user = stakers[i];\r\n            Leaderboard memory item = Leaderboard({\r\n                stakeAmount: userTotalStakes[user],\r\n                user: user\r\n            });\r\n            board[i] = item;\r\n        }\r\n\r\n        for (uint256 i = 0; i < board.length - 1; i++) {\r\n            for (uint256 j = 0; j < board.length - i - 1; j++) {\r\n                if (board[j].stakeAmount <= board[j + 1].stakeAmount) {\r\n                    Leaderboard memory temp = board[j];\r\n                    board[j] = board[j + 1];\r\n                    board[j + 1] = temp;\r\n                }\r\n            }\r\n        }\r\n        return board;\r\n    }\r\n\r\n    function getCumulativeRewards(\r\n        uint256 amount,\r\n        uint256 poolId\r\n    ) public view returns (uint256) {\r\n        if (poolId <= 0) {\r\n            revert InvalidValue(poolId);\r\n        }\r\n        if (poolId > rewardPools.length) {\r\n            revert InvalidRewardPoolId();\r\n        }\r\n        return\r\n            (amount * rewardPools[poolId - 1].rewardsPerStake) /\r\n            rewardsPerStakeAccuracyFactor;\r\n    }\r\n\r\n    function getUnpaidEarnings(\r\n        address staker,\r\n        uint256 stakeId,\r\n        uint256 poolId\r\n    ) public view returns (uint256) {\r\n        if (poolId <= 0) {\r\n            revert InvalidValue(poolId);\r\n        }\r\n        if (stakeId <= 0) {\r\n            revert InvalidValue(stakeId);\r\n        }\r\n        if (poolId > rewardPools.length) {\r\n            revert InvalidRewardPoolId();\r\n        }\r\n        if (stakeId > userStaking[staker]) {\r\n            revert InvalidStakeId();\r\n        }\r\n\r\n        if (userTotalStakes[staker] == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 stakerTotalRewards = getCumulativeRewards(\r\n            userStakes[staker][stakeId].amount,\r\n            poolId\r\n        );\r\n        uint256 stakerTotalExcluded = userStakes[staker][stakeId].totalExcluded;\r\n\r\n        if (stakerTotalRewards <= stakerTotalExcluded) {\r\n            return 0;\r\n        }\r\n\r\n        return stakerTotalRewards - stakerTotalExcluded;\r\n    }\r\n\r\n    /* Staking */\r\n\r\n    function stake(\r\n        uint256 amount,\r\n        uint256 stakeTypeId\r\n    ) external override whenNotPaused {\r\n        if (stakeTypeId <= 0 || stakeTypeId > stakeType) {\r\n            revert InvalidValue(stakeTypeId);\r\n        }\r\n        if (userTotalStakes[msg.sender] == 0) {\r\n            _addStaker(msg.sender);\r\n        }\r\n\r\n        uint256 unpaidEarning = _handleDistribution(msg.sender);\r\n\r\n        uint256 index = userStaking[msg.sender];\r\n        uint256 excluded = 0;\r\n\r\n        if (rewardPools.length > 0) {\r\n            excluded = getCumulativeRewards(amount, rewardPools.length);\r\n        }\r\n\r\n        Stake memory newStake = Stake({\r\n            stakeType: stakeTypeId,\r\n            amount: amount,\r\n            timestamp: block.timestamp,\r\n            startPoolIndex: rewardPools.length + 1,\r\n            totalExcluded: excluded,\r\n            totalRealised: 0\r\n        });\r\n\r\n        userActiveStaking[msg.sender] += 1;\r\n        userStaking[msg.sender] = index + 1;\r\n        userStakes[msg.sender][index + 1] = newStake;\r\n        userTotalStakes[msg.sender] += amount;\r\n        totalStaked += amount;\r\n\r\n        emit Staked(msg.sender, amount);\r\n\r\n        if (unpaidEarning > 0) {\r\n            totalDistributed += unpaidEarning;\r\n            require(\r\n                REWARD.transfer(msg.sender, unpaidEarning),\r\n                \"Stake: There's something wrong with the transfer.\"\r\n            );\r\n        }\r\n\r\n        require(\r\n            TOKEN.transferFrom(msg.sender, address(this), amount),\r\n            \"Stake: There's something wrong with the transfer.\"\r\n        );\r\n    }\r\n\r\n    function unstake(\r\n        uint256 amount,\r\n        uint256 stakeId\r\n    ) external override whenNotPaused {\r\n        uint256 unstakeTime = userStakes[msg.sender][stakeId].timestamp +\r\n            stakeTypeToDuration[userStakes[msg.sender][stakeId].stakeType];\r\n        if (unstakeTime > block.timestamp) {\r\n            revert NotTimeToUnstake(unstakeTime, block.timestamp);\r\n        }\r\n        _unstake(amount, stakeId, false);\r\n    }\r\n\r\n    function emergencyWithdrawStaking(uint256 amount, uint256 index) external {\r\n        if (!emergencyWithdraw) {\r\n            revert EmergencyWithdrawDisabled();\r\n        }\r\n        _unstake(amount, index, takePenalty);\r\n    }\r\n\r\n    function _unstake(uint256 amount, uint256 stakeId, bool penalty) internal {\r\n        if (amount <= 0) {\r\n            revert InvalidValue(amount);\r\n        }\r\n        if (stakeId <= 0) {\r\n            revert InvalidStakeId();\r\n        }\r\n        if (stakeId > userStaking[msg.sender]) {\r\n            revert ExceedUserStakeId(userStaking[msg.sender]);\r\n        }\r\n        if (userStakes[msg.sender][stakeId].amount < amount) {\r\n            revert ExceedStakeBalance(userStakes[msg.sender][stakeId].amount);\r\n        }\r\n\r\n        if (rewardPools.length > 0) {\r\n            for (uint256 i = 1; i <= rewardPools.length; i++) {\r\n                if (getUnpaidEarnings(msg.sender, stakeId, i) > 0) {\r\n                    claimRewards(stakeId, i);\r\n                }\r\n            }\r\n        }\r\n\r\n        userStakes[msg.sender][stakeId].amount -= amount;\r\n        userTotalStakes[msg.sender] -= amount;\r\n        totalStaked -= amount;\r\n\r\n        if (userStakes[msg.sender][stakeId].amount == 0) {\r\n            userActiveStaking[msg.sender] -= 1;\r\n            userInactiveStaking[msg.sender] += 1;\r\n        }\r\n\r\n        if (userTotalStakes[msg.sender] == 0) {\r\n            _removeStaker(msg.sender);\r\n        }\r\n\r\n        emit Unstaked(msg.sender, amount);\r\n\r\n        uint256 penaltyAmount = 0;\r\n\r\n        if (penaltyPercentage > 0) {\r\n            penaltyAmount = (amount * penaltyPercentage) / DENOMINATOR;\r\n        }\r\n\r\n        if (penalty) {\r\n            require(\r\n                TOKEN.transfer(msg.sender, amount - penaltyAmount),\r\n                \"Unstake: There's something wrong with the transfer.\"\r\n            );\r\n            require(\r\n                TOKEN.transfer(penaltyReceiver, penaltyAmount),\r\n                \"Unstake: There's something wrong with the penalty transfer.\"\r\n            );\r\n        } else {\r\n            require(\r\n                TOKEN.transfer(msg.sender, amount),\r\n                \"Unstake: There's something wrong with the transfer.\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /* Claim */\r\n\r\n    function claimRewards(uint256 stakeId, uint256 poolId) public {\r\n        if (userTotalStakes[msg.sender] <= 0) {\r\n            revert NoStakingRewards();\r\n        }\r\n        if (stakeId <= 0 || stakeId > userStaking[msg.sender]) {\r\n            revert InvalidStakeId();\r\n        }\r\n        if (poolId <= 0 || poolId > rewardPools.length) {\r\n            revert InvalidRewardPoolId();\r\n        }\r\n\r\n        uint256 unpaidEarning = 0;\r\n\r\n        if (\r\n            userStakes[msg.sender][stakeId].amount > 0 &&\r\n            rewardPools[poolId - 1].amountAdded !=\r\n            rewardPools[poolId - 1].amountClaimed\r\n        ) {\r\n            uint256 unpaidEarningRaw = getUnpaidEarnings(\r\n                msg.sender,\r\n                stakeId,\r\n                poolId\r\n            );\r\n            unpaidEarning =\r\n                (unpaidEarningRaw *\r\n                    rewardRatio[\r\n                        userStakes[msg.sender][stakeId].stakeType - 1\r\n                    ]) /\r\n                getStakeTypeRewardMaxRatio();\r\n            uint256 unpaidEarningRedistribute = unpaidEarningRaw -\r\n                unpaidEarning;\r\n            amountToRedistribute += unpaidEarningRedistribute;\r\n            userStakes[msg.sender][stakeId].totalRealised += unpaidEarning;\r\n            userStakes[msg.sender][stakeId]\r\n                .totalExcluded = getCumulativeRewards(\r\n                userStakes[msg.sender][stakeId].amount,\r\n                poolId\r\n            );\r\n            rewardPools[poolId - 1].amountClaimed += unpaidEarning;\r\n        }\r\n\r\n        if (unpaidEarning > 0) {\r\n            totalDistributed += unpaidEarning;\r\n            require(\r\n                REWARD.transfer(msg.sender, unpaidEarning),\r\n                \"Claim Rewards: There's something wrong with the transfer.\"\r\n            );\r\n        } else {\r\n            revert NoStakingRewards();\r\n        }\r\n    }\r\n\r\n    function claimAllRewards() external {\r\n        if (userTotalStakes[msg.sender] <= 0) {\r\n            revert NoStakingRewards();\r\n        }\r\n\r\n        if (userStaking[msg.sender] > 0 && rewardPools.length > 0) {\r\n            for (uint256 i = 1; i <= userStaking[msg.sender]; i++) {\r\n                for (uint256 j = 1; j <= rewardPools.length; j++) {\r\n                    if (getUnpaidEarnings(msg.sender, i, j) > 0) {\r\n                        claimRewards(i, j);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            revert NoStakingRewards();\r\n        }\r\n    }\r\n\r\n    /* Deposit */\r\n\r\n    function deposit() external payable override whenNotPaused {\r\n        _handleDeposits(msg.value);\r\n    }\r\n\r\n    function depositStuckedBNB() external override whenNotPaused {\r\n        uint256 amount = address(this).balance;\r\n        _handleDeposits(amount);\r\n    }\r\n\r\n    function depositBUSD(uint256 amount) external override whenNotPaused {\r\n        uint256 initialRewardBalance = REWARD.balanceOf(address(this));\r\n\r\n        require(\r\n            REWARD.transferFrom(msg.sender, address(this), amount),\r\n            \"Deposit BUSD: There's something wrong with the transfer.\"\r\n        );\r\n\r\n        uint256 added = REWARD.balanceOf(address(this)) - initialRewardBalance;\r\n        _updateRewardInfo(added);\r\n    }\r\n\r\n    function depositStuckedBUSD(\r\n        uint256 amount\r\n    ) external override whenNotPaused {\r\n        if (amount > amountToRedistribute) {\r\n            revert ExceedStuckedBalance(amountToRedistribute);\r\n        }\r\n        if (amountToRedistribute <= 0) {\r\n            revert InvalidValue(amountToRedistribute);\r\n        }\r\n        if (amount <= 0) {\r\n            revert InvalidValue(amount);\r\n        }\r\n        _updateRewardInfo(amount);\r\n        amountToRedistribute -= amount;\r\n        emit RewardDistribution(\r\n            amountToRedistribute,\r\n            amountToRedistribute - amount,\r\n            msg.sender,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    /* Rescue */\r\n\r\n    function wTokens(uint256 amount, address tokenAddress) external onlyOwner {\r\n        uint256 wAmount = amount;\r\n\r\n        if (tokenAddress == ZERO) {\r\n            if (amount == 0) {\r\n                wAmount = address(this).balance;\r\n            }\r\n            require(\r\n                wAmount <= address(this).balance,\r\n                \"WithdrawTokens: Insufficient balance.\"\r\n            );\r\n            payable(msg.sender).transfer(wAmount);\r\n            return;\r\n        }\r\n\r\n        if (amount == 0) {\r\n            if (IERC20(tokenAddress) == REWARD) {\r\n                wAmount = amountToRedistribute;\r\n            } else {\r\n                wAmount = IERC20(tokenAddress).balanceOf(address(this));\r\n            }\r\n        }\r\n\r\n        if (IERC20(tokenAddress) == REWARD) {\r\n            require(\r\n                wAmount <= amountToRedistribute,\r\n                \"WithdrawTokens: Insufficient balance to redistribute.\"\r\n            );\r\n            amountToRedistribute -= wAmount;\r\n            emit RewardRescued(\r\n                amountToRedistribute,\r\n                wAmount,\r\n                msg.sender,\r\n                block.timestamp\r\n            );\r\n        }\r\n        require(\r\n            wAmount <= IERC20(tokenAddress).balanceOf(address(this)),\r\n            \"WithdrawTokens: Insufficient balance.\"\r\n        );\r\n\r\n        require(\r\n            IERC20(tokenAddress).transfer(msg.sender, wAmount),\r\n            \"WithdrawTokens: Transfer transaction might fail.\"\r\n        );\r\n    }\r\n\r\n    /* Internal */\r\n\r\n    function _handleDistribution(address staker) internal returns (uint256) {\r\n        uint256 unpaidEarning = 0;\r\n        uint256 totalUserStakes = userStaking[staker];\r\n\r\n        if (userStaking[staker] > 0 && rewardPools.length > 0) {\r\n            for (uint256 i = 1; i <= totalUserStakes; i++) {\r\n                for (uint256 j = 1; j <= rewardPools.length; j++) {\r\n                    if (\r\n                        userStakes[staker][i].amount > 0 &&\r\n                        userStakes[staker][i].startPoolIndex <= j &&\r\n                        rewardPools[j - 1].amountAdded >\r\n                        rewardPools[j - 1].amountClaimed\r\n                    ) {\r\n                        uint256 unpaidEarningRaw = getUnpaidEarnings(\r\n                            staker,\r\n                            i,\r\n                            j\r\n                        );\r\n                        uint256 unpaidEarningRedistribute = (unpaidEarningRaw *\r\n                            rewardRatio[\r\n                                userStakes[msg.sender][i].stakeType - 1\r\n                            ]) / getStakeTypeRewardMaxRatio();\r\n                        uint256 unpaid = unpaidEarningRaw -\r\n                            unpaidEarningRedistribute;\r\n                        amountToRedistribute += unpaidEarningRedistribute;\r\n                        userStakes[staker][i].totalRealised += unpaid;\r\n                        userStakes[staker][i]\r\n                            .totalExcluded = getCumulativeRewards(\r\n                            userStakes[staker][i].amount,\r\n                            j\r\n                        );\r\n                        rewardPools[j - 1].amountClaimed += unpaid;\r\n                        unpaidEarning += unpaid;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return unpaidEarning;\r\n    }\r\n\r\n    function _handleDeposits(uint256 amount) internal {\r\n        address[] memory path = new address[](2);\r\n        path[0] = router.WETH();\r\n        path[1] = address(REWARD);\r\n\r\n        uint256 initialRewardBalance = REWARD.balanceOf(address(this));\r\n\r\n        router.swapExactETHForTokensSupportingFeeOnTransferTokens{\r\n            value: amount\r\n        }(0, path, address(this), block.timestamp);\r\n\r\n        uint256 added = REWARD.balanceOf(address(this)) - initialRewardBalance;\r\n        _updateRewardInfo(added);\r\n    }\r\n\r\n    function _updateRewardInfo(uint256 added) internal {\r\n        if (added > 0) {\r\n            totalRewards += added;\r\n            rewardsPerStake +=\r\n                (rewardsPerStakeAccuracyFactor * added) /\r\n                totalStaked;\r\n            currentPoolIndex += 1;\r\n            RewardPool memory newPool = RewardPool({\r\n                id: currentPoolIndex,\r\n                amountAdded: added,\r\n                amountClaimed: 0,\r\n                rewardsPerStake: rewardsPerStake,\r\n                timestamp: block.timestamp\r\n            });\r\n            rewardPools.push(newPool);\r\n        }\r\n    }\r\n\r\n    function _addStaker(address staker) internal {\r\n        stakerIndexes[staker] = stakers.length;\r\n        stakers.push(staker);\r\n    }\r\n\r\n    function _removeStaker(address staker) internal {\r\n        if (stakers.length > 1) {\r\n            stakers[stakerIndexes[staker]] = stakers[stakers.length - 1];\r\n            stakerIndexes[stakers[stakers.length - 1]] = stakerIndexes[staker];\r\n        }\r\n        stakers.pop();\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"routerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"penaltyReceiverAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"current\",\"type\":\"address\"}],\"name\":\"CannotUseCurrentAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"current\",\"type\":\"bool\"}],\"name\":\"CannotUseCurrentState\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"current\",\"type\":\"uint256\"}],\"name\":\"CannotUseCurrentValue\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"CurrentAuthorizedState\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EmergencyWithdrawDisabled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EnforcedPause\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"ExceedStakeBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxRange\",\"type\":\"uint256\"}],\"name\":\"ExceedStakeTypeRange\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"ExceedStuckedBalance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxIdValue\",\"type\":\"uint256\"}],\"name\":\"ExceedUserStakeId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExpectedPause\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"invalid\",\"type\":\"address\"}],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"InvalidAuthorizedAccount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"InvalidOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRewardPoolId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidStakeId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"invalid\",\"type\":\"uint256\"}],\"name\":\"InvalidValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoStakingRewards\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"unstakeTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeNow\",\"type\":\"uint256\"}],\"name\":\"NotTimeToUnstake\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"UnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"distributed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"RewardDistribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"distributed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"RewardRescued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"authorizedAccount\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"UpdateAuthorizedAccount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"oldState\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"newState\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"UpdateEmergencyWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldPenalty\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPenalty\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"UpdatePenalty\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldReceiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newReceiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"UpdatePenaltyReceiver\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IRouter\",\"name\":\"oldRouter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract IRouter\",\"name\":\"newRouter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"UpdateRouter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"oldState\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"newState\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"UpdateTakePenalty\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DENOMINATOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REWARD\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN\",\"outputs\":[{\"internalType\":\"contract IWDYM\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"name\":\"addStakeType\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amountToRedistribute\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorization\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAllRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentPoolIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositBUSD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositStuckedBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositStuckedBUSD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"emergencyWithdrawStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"getCumulativeRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLeaderboard\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"internalType\":\"struct IStaking.Leaderboard[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakeTypeRewardMaxRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolId\",\"type\":\"uint256\"}],\"name\":\"getUnpaidEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isWDYMStaking\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"name\":\"modifyStakeType\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"penaltyPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"penaltyReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"removeStakeType\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardPools\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAdded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountClaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardsPerStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsPerStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsPerStakeAccuracyFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeTypeId\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakeTypeToDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakerIndexes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"takePenalty\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"unauthorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeId\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"newState\",\"type\":\"bool\"}],\"name\":\"updateEmergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPenalty\",\"type\":\"uint256\"}],\"name\":\"updatePenalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newReceiver\",\"type\":\"address\"}],\"name\":\"updatePenaltyReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IRouter\",\"name\":\"newRouter\",\"type\":\"address\"}],\"name\":\"updateRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"newState\",\"type\":\"bool\"}],\"name\":\"updateTakePenalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userActiveStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInactiveStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userStakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startPoolIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalExcluded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRealised\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userTotalStakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"wTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "WhatDoYouMemeStaking", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "9999", "ConstructorArguments": "00000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e0000000000000000000000000603ac447682a1a3537d2c396d7eb86d0b3e225b", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d51e0d31ddf0cca7605709769aaf4c54427c6081403031033e6d8df1e2328b65"}