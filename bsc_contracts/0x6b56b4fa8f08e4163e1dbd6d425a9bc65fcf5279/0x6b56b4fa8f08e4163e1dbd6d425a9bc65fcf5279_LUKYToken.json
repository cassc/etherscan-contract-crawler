{"SourceCode": "pragma solidity ^0.8.11;\r\n//SPDX-License-Identifier: UNLICENSED\r\n\r\n\r\nlibrary AddressAddressKeyIterableMapping {\r\n    struct Record {\r\n        bool exists; // this feels like a waste of storage...\r\n        uint256 index;\r\n    }\r\n\r\n    struct Store {\r\n        mapping(address => Record) map;\r\n        address[] keys;\r\n    }\r\n\r\n    function keyCount(Store storage store) internal view returns (uint256 count) {\r\n        count = store.keys.length;\r\n    }\r\n\r\n    function keyAt(Store storage store, uint256 index) internal view returns (address key) {\r\n        key = store.keys[index];\r\n    }\r\n\r\n    function allKeys(Store storage store) internal view returns (address[] memory keys) {\r\n        keys = store.keys;\r\n    }\r\n\r\n    function get(Store storage store, address key) internal view returns (bool exists) {\r\n        Record storage rec = store.map[key];\r\n        exists = rec.exists;\r\n    }\r\n\r\n    function put(Store storage store, address key) internal returns (bool replaced) {\r\n        replaced = false;\r\n        if (store.map[key].exists) {\r\n            removeFromArray(store, key);\r\n            // we have to change the array, can't just overwrite the fields\r\n            replaced = true;\r\n        }\r\n        store.keys.push(key);\r\n        Record storage rec = store.map[key];\r\n        rec.exists = true;\r\n        rec.index = store.keys.length - 1;\r\n    }\r\n\r\n    function remove(Store storage store, address key) internal returns (bool deleted) {\r\n        if (store.map[key].exists) {\r\n            removeFromArray(store, key);\r\n            // we have to change the array, can't just overwrite the fields\r\n            delete store.map[key];\r\n            deleted = true;\r\n        }\r\n        else {\r\n            deleted = false;\r\n        }\r\n    }\r\n\r\n    function removeFromArray(Store storage store, address key) private {\r\n        uint256 index = store.map[key].index;\r\n        uint256 lastIndex = store.keys.length - 1;\r\n        if (index != lastIndex) {\r\n            require(store.keys[index] == key);\r\n            address lastKey = store.keys[store.keys.length - 1];\r\n            Record storage last = store.map[lastKey];\r\n            store.keys[index] = lastKey;\r\n            last.index = index;\r\n        }\r\n        store.keys.pop();\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n\r\n    function allPairs(uint) external view returns (address pair);\r\n\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\n\r\ncontract LUKYToken {\r\n    string public name = \"LUKY token\";\r\n    string public symbol = \"LUKY\";\r\n    uint256 public totalSupply;\r\n    uint256 public detectiontime;\r\n    uint256 public unlockingtime;\r\n    uint256 public unlockingtime2;\r\n    uint256 public unlockingtime3;\r\n    mapping(address => uint256) public balanceOf;\r\n    mapping(address => bool) public isExcludedFromFee;\r\n    mapping(address => bool) public isPairCon;\r\n    uint8 public decimals = 18;\r\n\r\n    uint8 public levleMax;\r\n    uint8 public fee;\r\n    uint8 public burnfee;\r\n    uint8 public fundpoolWalletfee;\r\n    uint8 public foundersWalletfee;\r\n    uint8 public communityWalletfee;\r\n    uint8 public marketingWalletfee;\r\n    uint8 public liquiditycontributionfee;\r\n    uint8 public founderWalletfee;\r\n    uint8 public marketingfee;\r\n    uint8 public fundWalletfee;\r\n\r\n    address public fundpoolWalletAddr = address(0x34C1841c5DC9F7390A556305Bb1f0d67Fbe9947F);\r\n    address public foundersWalletAddr = address(0xfe4242864F982171Cb86cd3A95540Dc77A621a46);\r\n    address public communityWalletAddr = address(0xabBC351682aA1Fe5B15522aE3Bc616f6448eaD6F);\r\n    address public marketingWalletAddr = address(0xE864EC0406FEa97699e00acBEbA3d06028d7984b);\r\n    address public liquiditycontributionAddr = address(0x4b413d8ABfDedd8BDfc6Db81c9C261C586071509);\r\n    address public founderWalletAddr = address(0xEAD5a825Cb86092B02cbF44B0AA38596b356f915);\r\n    address public fundWalletAddr = address(0x56FF3197d952a79a0ea76bb01422cf2674811E5d);\r\n    address public lockaccountAddr = address(0x08C2D41512c8fcF888c98910a66b424BA25bE7e9);\r\n    address public lockaccountAddr2 = address(0xC31C1A8C484CBbE5128C9e3C6a862A422D2D32f8);\r\n    address public lockaccountAddr3 = address(0x4b413d8ABfDedd8BDfc6Db81c9C261C586071509);\r\n\r\n\r\n\r\n    address public Deployer;\r\n    address _burnaddr = address(0x000000000000000000000000000000000000dEaD);\r\n    address private USDTaddr = address(0x55d398326f99059fF775485246999027B3197955);\r\n    IUniswapV2Router02 public immutable uniswapV2Router;\r\n    address public immutable uniswapV2Pair;\r\n\r\n    mapping(address => bool)public botlist;\r\n    mapping(uint8 => uint8)public levelTofee;\r\n    mapping(address => address)public upOneLevel;\r\n    mapping(address => bool)public isregister;\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    AddressAddressKeyIterableMapping.Store private LpAddressList;\r\n\r\n    IERC20 public uniswapV2Paircontract;\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n    constructor(){\r\n        unlockingtime = block.timestamp + 7776000;\r\n        unlockingtime2 = block.timestamp + 5184000;\r\n        unlockingtime3 = block.timestamp + 1296000;\r\n        Deployer = address(0x880c522bF14AC4Ed6075F57572E66062d5DE8DEA);\r\n        totalSupply = 21000 * 10 ** uint256(decimals);\r\n        balanceOf[Deployer] = 5250 * 10 ** uint256(decimals);\r\n        balanceOf[lockaccountAddr] = 10500 * 10 ** uint256(decimals);\r\n        balanceOf[lockaccountAddr2] = 3150 * 10 ** uint256(decimals);\r\n        balanceOf[lockaccountAddr3] = 2100 * 10 ** uint256(decimals);\r\n        isExcludedFromFee[Deployer] = true;\r\n        isExcludedFromFee[lockaccountAddr] = true;\r\n        isExcludedFromFee[lockaccountAddr2] = true;\r\n        isExcludedFromFee[lockaccountAddr3] = true;\r\n        isExcludedFromFee[address(this)] = true;\r\n        isExcludedFromFee[fundpoolWalletAddr] = true;\r\n        isExcludedFromFee[foundersWalletAddr] = true;\r\n        isExcludedFromFee[communityWalletAddr] = true;\r\n        isExcludedFromFee[marketingWalletAddr] = true;\r\n        isExcludedFromFee[liquiditycontributionAddr] = true;\r\n        isExcludedFromFee[founderWalletAddr] = true;\r\n        isExcludedFromFee[fundWalletAddr] = true;\r\n\r\n\r\n        levelTofee[1] = 15;\r\n        levelTofee[2] = 25;\r\n        levelTofee[3] = 10;\r\n        levelTofee[4] = 10;\r\n        levelTofee[5] = 10;\r\n        levelTofee[6] = 10;\r\n        levelTofee[7] = 10;\r\n        levelTofee[8] = 10;\r\n        levleMax = 8;\r\n        fee = 10;\r\n\r\n        burnfee = 5;\r\n        fundpoolWalletfee = 10;\r\n        foundersWalletfee = 9;\r\n        communityWalletfee = 9;\r\n        marketingWalletfee = 8;\r\n        liquiditycontributionfee = 13;\r\n        founderWalletfee = 6;\r\n        marketingfee = 30;\r\n        fundWalletfee = 10;\r\n\r\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n        // Create a uniswap pair for this new token\r\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), address(USDTaddr));\r\n        isPairCon[uniswapV2Pair] = true;\r\n        uniswapV2Router = _uniswapV2Router;\r\n        uniswapV2Paircontract = IERC20(uniswapV2Pair);\r\n        emit Transfer(address(0), Deployer, 5250 * 10 ** uint256(decimals));\r\n        emit Transfer(address(0), lockaccountAddr, 10500 * 10 ** uint256(decimals));\r\n        emit Transfer(address(0), lockaccountAddr2, 3150 * 10 ** uint256(decimals));\r\n        emit Transfer(address(0), lockaccountAddr3, 2100 * 10 ** uint256(decimals));\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        _transfer(msg.sender, _to, _value);\r\n        if (!isContract(msg.sender) && !isContract(_to)) {\r\n            _registerLogic(msg.sender, _to);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function _registerLogic(address _from, address _to) private {\r\n        if (isExcludedFromFee[_from] && !isregister[_to]) {\r\n            isregister[_to] = true;\r\n        } else if (isregister[_from] && !isregister[_to]) {\r\n            upOneLevel[_to] = _from;\r\n            isregister[_to] = true;\r\n        }\r\n    }\r\n    bool public regularWay;\r\n\r\n    function UPregularWay()external {\r\n        require(Deployer==msg.sender);\r\n        if(regularWay){\r\n            regularWay = false;\r\n        }else{\r\n            regularWay = true;\r\n        }\r\n    }\r\n\r\n    \r\n\r\n    function _transfer(address _from, address _to, uint256 _value) private returns (bool) {\r\n        require(_from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(_to != address(0), \"ERC20: transfer to the zero address\");\r\n        require(_value > 0, \"err:_value <= 0\");\r\n        require(balanceOf[_from] >= _value, \"err:balanceOf[_from] < _value\");\r\n        require(balanceOf[_to] + _value > balanceOf[_to], \"err:balanceOf[_to] + _value <= balanceOf[_to]\");\r\n        if(regularWay){\r\n            balanceOf[_from] = balanceOf[_from] - _value;\r\n            balanceOf[_to] = balanceOf[_to] + _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        }\r\n\r\n        require(!botlist[_from] && !botlist[_to], \"err:from or to is bot!\");\r\n\r\n        if (_from == lockaccountAddr) {\r\n            require(unlockingtime <= block.timestamp);\r\n        }else if (_from == lockaccountAddr2) {\r\n            require(unlockingtime2 <= block.timestamp);\r\n        }else if (_from == lockaccountAddr3) {\r\n            require(unlockingtime3 <= block.timestamp);\r\n        }\r\n\r\n        if (detectiontime == 0) {\r\n            detectiontime = block.timestamp + 1;\r\n        }\r\n        if (block.timestamp <= detectiontime && !isExcludedFromFee[_from] && !isExcludedFromFee[_to]) {\r\n            botlist[_to] = true;\r\n        }\r\n        if (!isExcludedFromFee[_from] && !isExcludedFromFee[_to]) {\r\n            if(!isPairCon[_to]){\r\n                require(balanceOf[_to] + _value <= 5 * 10 ** 18, \"err:balanceOf[_to]>5 token\");\r\n            }\r\n            \r\n            require(_value <= 10 ** 18, \"err:value>1 token\");\r\n        }\r\n\r\n        if (!isContract(_to) && !isContract(_from)) {\r\n            balanceOf[_from] = balanceOf[_from] - _value;\r\n            balanceOf[_to] = balanceOf[_to] + _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        }\r\n\r\n\r\n        if (isExcludedFromFee[_from] || isExcludedFromFee[_to]) {\r\n            balanceOf[_from] = balanceOf[_from] - _value;\r\n            balanceOf[_to] = balanceOf[_to] + _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        }\r\n        if (!isExcludedFromFee[_from] && !isExcludedFromFee[_to]) {\r\n            balanceOf[_from] = balanceOf[_from] - _value;\r\n            uint256 value_ = _value * fee / 100;\r\n            uint256 amount_ = _value - value_;\r\n            balanceOf[_to] += amount_;\r\n            balanceOf[address(this)] += value_;\r\n            emit Transfer(_from, _to, amount_);\r\n            emit Transfer(_from, address(this), value_);\r\n\r\n            uint256 Sum;\r\n            Sum += (balanceOf[address(this)] * burnfee / 100);\r\n            balanceOf[_burnaddr] += (balanceOf[address(this)] * burnfee / 100);\r\n            emit Transfer(address(this), _burnaddr, balanceOf[address(this)] * burnfee / 100);\r\n            Sum += (balanceOf[address(this)] * fundpoolWalletfee / 100);\r\n            balanceOf[fundpoolWalletAddr] += (balanceOf[address(this)] * fundpoolWalletfee / 100);\r\n            emit Transfer(address(this), fundpoolWalletAddr, (balanceOf[address(this)] * fundpoolWalletfee / 100));\r\n            Sum += (balanceOf[address(this)] * foundersWalletfee / 100);\r\n            balanceOf[foundersWalletAddr] += (balanceOf[address(this)] * foundersWalletfee / 100);\r\n            emit Transfer(address(this), foundersWalletAddr, (balanceOf[address(this)] * foundersWalletfee / 100));\r\n            Sum += (balanceOf[address(this)] * communityWalletfee / 100);\r\n            balanceOf[communityWalletAddr] += (balanceOf[address(this)] * communityWalletfee / 100);\r\n            emit Transfer(address(this), communityWalletAddr, (balanceOf[address(this)] * communityWalletfee / 100));\r\n            Sum += (balanceOf[address(this)] * marketingWalletfee / 100);\r\n            balanceOf[marketingWalletAddr] += (balanceOf[address(this)] * marketingWalletfee / 100);\r\n            emit Transfer(address(this), marketingWalletAddr, (balanceOf[address(this)] * marketingWalletfee / 100));\r\n            Sum += (balanceOf[address(this)] * liquiditycontributionfee / 100);\r\n            balanceOf[liquiditycontributionAddr] += (balanceOf[address(this)] * liquiditycontributionfee / 100);\r\n            emit Transfer(address(this), liquiditycontributionAddr, (balanceOf[address(this)] * liquiditycontributionfee / 100));\r\n            Sum += (balanceOf[address(this)] * founderWalletfee / 100);\r\n            balanceOf[founderWalletAddr] += (balanceOf[address(this)] * founderWalletfee / 100);\r\n            emit Transfer(address(this), founderWalletAddr, (balanceOf[address(this)] * founderWalletfee / 100));\r\n            Sum += (balanceOf[address(this)] * fundWalletfee / 100);\r\n            balanceOf[fundWalletAddr] += (balanceOf[address(this)] * fundWalletfee / 100);\r\n            emit Transfer(address(this), fundWalletAddr, (balanceOf[address(this)] * fundWalletfee / 100));\r\n            balanceOf[address(this)] -= Sum;\r\n\r\n            if (isContract(_from) && !isContract(_to)) {\r\n                if (isregister[_to] && upOneLevel[_to] != address(0)) {\r\n                    address _temporary = _to;\r\n                    uint256 this_balance = balanceOf[address(this)];\r\n                    for (uint8 i = 1; i <= levleMax; i++) {\r\n                        if (upOneLevel[_temporary] == address(0)) {\r\n                            break;\r\n                        } else {\r\n                            uint256 _v = levelTofee[i] * balanceOf[address(this)] / 100;\r\n                            if (this_balance >= _v) {\r\n                                this_balance -= _v;\r\n                                balanceOf[upOneLevel[_temporary]] += _v;\r\n                                emit Transfer(address(this), upOneLevel[_temporary], _v);\r\n                                _temporary = upOneLevel[_temporary];\r\n                            } else {\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    balanceOf[address(this)] = this_balance;\r\n                    if (balanceOf[address(this)] > 0) {\r\n                        balanceOf[marketingWalletAddr] += balanceOf[address(this)];\r\n                        emit Transfer(address(this), marketingWalletAddr, balanceOf[address(this)]);\r\n                        balanceOf[address(this)] = 0;\r\n                    }\r\n\r\n                } else {\r\n                    balanceOf[marketingWalletAddr] += balanceOf[address(this)];\r\n                    emit Transfer(address(this), marketingWalletAddr, balanceOf[address(this)]);\r\n                    balanceOf[address(this)] = 0;\r\n                    isregister[_to] = true;\r\n                }\r\n                if (AddressAddressKeyIterableMapping.get(LpAddressList, _to)) {\r\n                    if (uniswapV2Paircontract.balanceOf(_to) * 100 / uniswapV2Paircontract.totalSupply() < 5) {\r\n                        AddressAddressKeyIterableMapping.remove(LpAddressList, _to);\r\n                    }\r\n                } else {\r\n                    if (uniswapV2Paircontract.balanceOf(_to) * 100 / uniswapV2Paircontract.totalSupply() >= 5) {\r\n                        AddressAddressKeyIterableMapping.put(LpAddressList, _to);\r\n                    }\r\n                }\r\n\r\n            } else if (!isContract(_from) && isContract(_to)) {\r\n                if (isregister[_from] && upOneLevel[_from] != address(0)) {\r\n                    address _temporary = _from;\r\n                    uint256 this_balance = balanceOf[address(this)];\r\n                    for (uint8 i = 1; i <= levleMax; i++) {\r\n                        if (upOneLevel[_temporary] == address(0)) {\r\n                            break;\r\n                        } else {\r\n                            uint256 _v = levelTofee[i] * balanceOf[address(this)] / 100;\r\n                            if (this_balance >= _v) {\r\n                                this_balance -= _v;\r\n                                balanceOf[upOneLevel[_temporary]] += _v;\r\n                                emit Transfer(address(this), upOneLevel[_temporary], _v);\r\n                                _temporary = upOneLevel[_temporary];\r\n                            } else {\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    balanceOf[address(this)] = this_balance;\r\n                    if (balanceOf[address(this)] > 0) {\r\n                        balanceOf[marketingWalletAddr] += balanceOf[address(this)];\r\n                        emit Transfer(address(this), marketingWalletAddr, balanceOf[address(this)]);\r\n                        balanceOf[address(this)] = 0;\r\n                    }\r\n                } else {\r\n                    balanceOf[marketingWalletAddr] += balanceOf[address(this)];\r\n                    emit Transfer(address(this), marketingWalletAddr, balanceOf[address(this)]);\r\n                    balanceOf[address(this)] = 0;\r\n                    isregister[_from] = true;\r\n                }\r\n                if (AddressAddressKeyIterableMapping.get(LpAddressList, _from)) {\r\n                    if (uniswapV2Paircontract.balanceOf(_from) * 100 / uniswapV2Paircontract.totalSupply() < 5) {\r\n                        AddressAddressKeyIterableMapping.remove(LpAddressList, _from);\r\n                    }\r\n                }\r\n            } else {\r\n                if (balanceOf[address(this)] > 0) {\r\n                    balanceOf[marketingWalletAddr] += balanceOf[address(this)];\r\n                    emit Transfer(address(this), marketingWalletAddr, balanceOf[address(this)]);\r\n                    balanceOf[address(this)] = 0;\r\n                }\r\n            }\r\n\r\n            if (balanceOf[address(liquiditycontributionAddr)] >= 20000 * 10 ** 18) {\r\n                uint256 count = AddressAddressKeyIterableMapping.keyCount(LpAddressList);\r\n                uint256 liquiditycontributionAddr_amount = balanceOf[address(liquiditycontributionAddr)];\r\n                uint256 sumLP;\r\n                for (uint256 n = 0;n < count; n++){\r\n                    sumLP += uniswapV2Paircontract.balanceOf(AddressAddressKeyIterableMapping.keyAt(LpAddressList, n));\r\n                }\r\n                for (uint256 j = 0; j < count; j++) {\r\n                    uint256 Value = (uniswapV2Paircontract.balanceOf(AddressAddressKeyIterableMapping.keyAt(LpAddressList, j)) * balanceOf[address(liquiditycontributionAddr)] / sumLP);\r\n                    liquiditycontributionAddr_amount -= Value;\r\n                    balanceOf[address(AddressAddressKeyIterableMapping.keyAt(LpAddressList, j))] += Value;\r\n                    emit Transfer(address(this), address(AddressAddressKeyIterableMapping.keyAt(LpAddressList, j)), Value);\r\n                }\r\n                balanceOf[address(liquiditycontributionAddr)] = liquiditycontributionAddr_amount;\r\n            }\r\n            return true;\r\n        } else {\r\n            balanceOf[_from] = balanceOf[_from] - _value;\r\n            balanceOf[_to] = balanceOf[_to] + _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        }\r\n\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        require(_value <= allowance[_from][msg.sender]);\r\n        _transfer(_from, _to, _value);\r\n        allowance[_from][msg.sender] = allowance[_from][msg.sender] - _value;\r\n        return true;\r\n    }\r\n\r\n    function _approve(\r\n        address _send,\r\n        address _spender,\r\n        uint256 _amount\r\n    ) internal virtual {\r\n        require(_send != address(0), \"ERC20: approve from the zero address\");\r\n        require(_spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        allowance[_send][_spender] = _amount;\r\n        emit Approval(_send, _spender, _amount);\r\n    }\r\n\r\n    function approve(address _spender, uint256 _amount) public returns (bool) {\r\n        address _send = msg.sender;\r\n        _approve(_send, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address _spender, uint256 _addedValue) public returns (bool) {\r\n        address _send = msg.sender;\r\n        _approve(_send, _spender, allowance[_send][_spender] + _addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) public returns (bool) {\r\n        address _send = msg.sender;\r\n        uint256 currentAllowance = allowance[_send][_spender];\r\n        require(currentAllowance >= _subtractedValue, \"ERC20: decreased allowance below zero\");\r\n    unchecked {\r\n        _approve(_send, _spender, currentAllowance - _subtractedValue);\r\n    }\r\n        return true;\r\n    }\r\n\r\n    receive() external payable {\r\n\r\n    }\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n    \r\n    function InvitationInfo(address _addr)public view returns(uint256,uint256){\r\n        uint256 NumberOfPeople;\r\n        uint256 total;\r\n        if (isregister[_addr] && upOneLevel[_addr] != address(0)) {\r\n            address _temporary = _addr;\r\n            for (uint8 i = 1; i <= levleMax; i++) {\r\n                if (upOneLevel[_temporary] == address(0)) {\r\n                    break;\r\n                } else {\r\n                    total += balanceOf[upOneLevel[_temporary]];\r\n                    NumberOfPeople += 1;\r\n                    _temporary = upOneLevel[_temporary];\r\n                }\r\n            }\r\n        }\r\n        return (NumberOfPeople,total);\r\n    }\r\n\r\n    function UpdateBotlistStatus(address _addr)external{\r\n        require(Deployer==msg.sender);\r\n        if(botlist[_addr]){\r\n            botlist[_addr]=false;\r\n        }else{\r\n            botlist[_addr]=true;\r\n        }\r\n    }\r\n\r\n    function UpdateExcludedFromFee(address _addr)external{\r\n        require(Deployer==msg.sender);\r\n        if(isExcludedFromFee[_addr]){\r\n            isExcludedFromFee[_addr]=false;\r\n        }else{\r\n            isExcludedFromFee[_addr]=true;\r\n        }\r\n    }\r\n    \r\n    function UpdatePairCon(address _pair) external{\r\n        require(Deployer==msg.sender);\r\n        if(isPairCon[_pair]){\r\n            isPairCon[_pair] = false;\r\n        }else{\r\n            isPairCon[_pair] = true;\r\n        }\r\n    }\r\n\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"Deployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"InvitationInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UPregularWay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"UpdateBotlistStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"UpdateExcludedFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"}],\"name\":\"UpdatePairCon\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"botlist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnfee\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"communityWalletAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"communityWalletfee\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"detectiontime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"founderWalletAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"founderWalletfee\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"foundersWalletAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"foundersWalletfee\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundWalletAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundWalletfee\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundpoolWalletAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundpoolWalletfee\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isExcludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isPairCon\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isregister\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"levelTofee\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"levleMax\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquiditycontributionAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquiditycontributionfee\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockaccountAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockaccountAddr2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockaccountAddr3\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingWalletAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingWalletfee\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingfee\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"regularWay\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Paircontract\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlockingtime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlockingtime2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlockingtime3\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"upOneLevel\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "LUKYToken", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://9f058aa4bf6e8da0f168c1bf4c51c2790d7ba8e1c76c4ddba8f3851e4361a5bc"}