{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Presale.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nimport \\\"./interfaces/IRouter.sol\\\";\\nimport \\\"./interfaces/IStaking.sol\\\";\\nimport \\\"./pancake-swap/libraries/TransferHelper.sol\\\";\\n\\nimport \\\"@chainlink/contracts/src/v0.8/VRFConsumerBase.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\ncontract Presale is Context, ReentrancyGuard, VRFConsumerBase {\\n    uint256 private constant DENOMINATOR = 100;\\n    uint256[9] private POOL_WEIGHT = [\\n        50,\\n        100,\\n        250,\\n        550,\\n        1200,\\n        1900,\\n        2600,\\n        7000,\\n        15000\\n    ];\\n    uint256[9] private WINNING_CHANCE = [\\n        15,\\n        35,\\n        80,\\n        100,\\n        100,\\n        100,\\n        100,\\n        100,\\n        100\\n    ];\\n    uint256[4] private DIAMOND_COEFFICIENTS = [30, 90, 200, 300];\\n\\n    IStaking public immutable STAKING;\\n    address public immutable BUSD;\\n    address public immutable BACKEND;\\n    address public immutable DEX;\\n    address public immutable FEE_RECEIVER;\\n\\n    PresaleInfo public generalInfo;\\n    VestingInfo public vestingInfo;\\n    PresaleDexInfo public dexInfo;\\n    IntermediateVariables public intermediate;\\n    VotingParams public votingParams;\\n\\n    uint256 feePercent;\\n\\n    bool private requested;\\n    bool private expandCalled;\\n    uint256 private random;\\n    bytes32 private immutable keyHash;\\n    uint256 private immutable fee;\\n    uint256 private tokenMagnitude;\\n\\n    address[] private tier1;\\n    address[] private tier2;\\n    address[] private tier3;\\n\\n    mapping(uint8 => mapping(uint256 => uint256)) public roundTokenAllocation; //round => (level => token amount)\\n    mapping(uint256 => uint256) public levelsCounter;\\n    mapping(address => Investor) public registerLevels;\\n    mapping(address => Investment) public investments; // total wei invested per address\\n    mapping(address => bool) public lotteryWhitelist;\\n\\n    mapping(address => bool) private _voteSent;\\n    mapping(address => mapping(uint8 => mapping(uint8 => uint256)))\\n        private _roundInvestments; //user -> round -> stage -> bought tokens;\\n\\n    struct PresaleInfo {\\n        address creator;\\n        address tokenAddress;\\n        uint256 tokenPrice;\\n        uint256 hardCap;\\n        uint256 softCap;\\n        uint256 openTime;\\n        uint256 closeTime;\\n        address unsoldTokenToAddress;\\n    }\\n\\n    struct PresaleDexInfo {\\n        uint256 listingPrice;\\n        uint256 lpTokensLockDurationInDays;\\n        uint8 liquidityPercentageAllocation;\\n        uint256 liquidityAllocationTime;\\n    }\\n\\n    struct VestingInfo {\\n        uint8 vestingPerc1;\\n        uint8 vestingPerc2;\\n        uint256 vestingPeriod;\\n    }\\n\\n    struct IntermediateVariables {\\n        Votes votes;\\n        bool initialized;\\n        bool withdrawedFunds;\\n        uint256 closeTimeVoting;\\n        address lpAddress;\\n        uint256 usdToLiq;\\n        uint256 lpUnlockTime;\\n        uint256 tokensForSaleLeft;\\n        uint256 tokensForLiquidityLeft;\\n        uint256 raisedAmount;\\n        uint256 eachPoolShare;\\n    }\\n\\n    struct Investment {\\n        uint256 amountEth;\\n        uint256 amountTokens;\\n        uint256 amountClaimed;\\n    }\\n\\n    struct Votes {\\n        uint256 yes;\\n        uint256 no;\\n    }\\n\\n    struct VotingParams {\\n        uint256 minimum;\\n        uint256 threshold;\\n    }\\n\\n    struct Investor {\\n        uint256 level;\\n        bool lock;\\n    }\\n\\n    modifier timing() {\\n        require(\\n            generalInfo.closeTime > block.timestamp &&\\n                block.timestamp >= generalInfo.openTime,\\n            \\\"TIME\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier liquidityAdded() {\\n        require(intermediate.lpAddress != address(0), \\\"LIQ\\\");\\n        _;\\n    }\\n\\n    modifier onlyPresaleCreator() {\\n        require(_msgSender() == generalInfo.creator, \\\"CREATOR\\\");\\n        _;\\n    }\\n\\n    modifier notCreator() {\\n        require(_msgSender() != generalInfo.creator, \\\"NOT CREATOR\\\");\\n        _;\\n    }\\n\\n    modifier initialized() {\\n        require(intermediate.initialized, \\\"INIT\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        address staking,\\n        address busd,\\n        address back,\\n        address dex,\\n        address fReceiver,\\n        address _VRFCoordinator,\\n        address _LINK_ADDRESS,\\n        bytes32 _keyHash,\\n        uint256 _fee,\\n        PresaleInfo memory _info,\\n        PresaleDexInfo memory _dexInfo,\\n        VestingInfo memory _vestInfo\\n    ) VRFConsumerBase(_VRFCoordinator, _LINK_ADDRESS) {\\n        require(\\n            _info.openTime >= block.timestamp + /* 2 weeks + */ 48 hours &&\\n                _info.openTime + 9 hours <= _info.closeTime &&\\n                _info.closeTime < _dexInfo.liquidityAllocationTime,\\n            \\\"TIME\\\"\\n        );\\n        require(\\n            _info.softCap <= _info.hardCap &&\\n                _info.softCap > 0 &&\\n                _info.hardCap >= _info.tokenPrice &&\\n                _dexInfo.listingPrice > 0 &&\\n                _info.tokenPrice > 0 &&\\n                _dexInfo.lpTokensLockDurationInDays > 0 &&\\n                _dexInfo.liquidityPercentageAllocation > 0 &&\\n                _vestInfo.vestingPerc1 + _vestInfo.vestingPerc2 <=\\n                DENOMINATOR &&\\n                _vestInfo.vestingPeriod > 0,\\n            \\\"AMOUNTS\\\"\\n        );\\n        if (_vestInfo.vestingPerc1 < DENOMINATOR)\\n            require(_vestInfo.vestingPerc2 > 0, \\\"VESTING\\\");\\n        require(\\n            _info.creator != address(0) &&\\n                _info.unsoldTokenToAddress != address(0) &&\\n                dex != address(0) &&\\n                _info.tokenAddress != address(0) &&\\n                staking != address(0) &&\\n                busd != address(0) &&\\n                fReceiver != address(0) &&\\n                back != address(0),\\n            \\\"ADDRESSES\\\"\\n        );\\n\\n        keyHash = _keyHash;\\n        fee = _fee;\\n        STAKING = IStaking(staking);\\n        BUSD = busd;\\n        DEX = dex;\\n        BACKEND = back;\\n        FEE_RECEIVER = fReceiver;\\n\\n        votingParams = VotingParams((10**10) * (10**9), 2 * (10**5));\\n\\n        tokenMagnitude = 10**IERC20Metadata(_info.tokenAddress).decimals();\\n\\n        //intermediate.closeTimeVoting = block.timestamp + 2 weeks;\\n        intermediate.tokensForSaleLeft =\\n            (_info.hardCap * tokenMagnitude) /\\n            _info.tokenPrice;\\n        intermediate.tokensForLiquidityLeft =\\n            (_info.hardCap *\\n                _dexInfo.liquidityPercentageAllocation *\\n                tokenMagnitude) /\\n            (DENOMINATOR * _dexInfo.listingPrice);\\n\\n        generalInfo = _info;\\n        dexInfo = _dexInfo;\\n        vestingInfo = _vestInfo;\\n    }\\n\\n    /** @dev Function to activate presale and send tokens\\n     * @notice Creator only\\n     */\\n    function initialize() external nonReentrant onlyPresaleCreator {\\n        require(!intermediate.initialized, \\\"ONCE\\\");\\n        intermediate.initialized = true;\\n        TransferHelper.safeTransferFrom(\\n            generalInfo.tokenAddress,\\n            generalInfo.creator,\\n            address(this),\\n            intermediate.tokensForSaleLeft + intermediate.tokensForLiquidityLeft\\n        );\\n        TransferHelper.safeTransferFrom(\\n            address(LINK),\\n            generalInfo.creator,\\n            address(this),\\n            fee\\n        );\\n    }\\n\\n    /** @dev Function to set investor's fee percent\\n     * @notice Creator or fee receiver only\\n     * @param perc new fee percent\\n     */\\n    function setFeePerc(uint256 perc) external {\\n        address sender = _msgSender();\\n        require(\\n            (sender == FEE_RECEIVER ||\\n                sender == generalInfo.creator) && perc < DENOMINATOR\\n        );\\n        feePercent = perc;\\n    }\\n\\n    /** @dev Funtion to vote-up or vote-down for presale\\n     * @notice Staker above or equal level 1 only\\n     * @param yes vote-up or vote-down bool\\n     */\\n    function vote(bool yes) external initialized notCreator {\\n        revert(\\\"Passed\\\");\\n        /* require(intermediate.closeTimeVoting >= block.timestamp, \\\"TIME\\\");\\n        address sender = _msgSender();\\n        (uint256 level, uint256 amount, , , , , , , ) = STAKING.stakeForUser(\\n            sender,\\n            0\\n        );\\n        amount /= votingParams.minimum;\\n        require(level > 0 && !_voteSent[sender] && amount > 0, \\\"WRONG LEVEL\\\");\\n\\n        _voteSent[sender] = true;\\n        if (yes) intermediate.votes.yes += amount;\\n        else intermediate.votes.no += amount; */\\n    }\\n\\n    /** @dev Registration function\\n     * @notice Staker above or equal level 1 only\\n     */\\n    function register() external initialized notCreator {\\n        /* require(\\n            intermediate.votes.yes >=\\n                intermediate.votes.no + votingParams.threshold,\\n            \\\"NOT PASSED\\\"\\n        ); */\\n        uint256 currentTime = block.timestamp;\\n        require(\\n            generalInfo.openTime <= currentTime + 48 hours &&\\n                generalInfo.openTime > currentTime + 12 hours,\\n            \\\"TIME\\\"\\n        );\\n        address sender = _msgSender();\\n        (\\n            uint256 level,\\n            ,\\n            bool lock7,\\n            bool lock14,\\n            bool lock30,\\n            bool lock90,\\n            ,\\n            ,\\n\\n        ) = STAKING.stakeForUser(sender, 0);\\n        require(level > 0 && registerLevels[sender].level == 0, \\\"WRONG LEVEL\\\");\\n\\n        registerLevels[sender] = Investor(level, lock30 || lock90);\\n\\n        levelsCounter[level]++;\\n        if (lock30 || lock90) levelsCounter[10 + level]++;\\n\\n        if (level == 1) tier1.push(sender);\\n        if (level == 2) tier2.push(sender);\\n        if (level == 3) tier3.push(sender);\\n\\n        if (lock7 || lock14 || lock30) STAKING.addReLock(sender);\\n\\n        if (!requested && LINK.balanceOf(address(this)) >= fee) {\\n            requested = true;\\n            requestRandomness(keyHash, fee);\\n        }\\n    }\\n\\n    /** @dev Fuction for backend to calculate lottery results\\n     */\\n    function calculateLotteryResults() external {\\n        uint256 currentTime = block.timestamp;\\n        require(\\n            random > 0 &&\\n                !expandCalled &&\\n                generalInfo.openTime <= currentTime + 12 hours &&\\n                _msgSender() == BACKEND,\\n            \\\"WRONG PARAMS\\\"\\n        );\\n        _expand();\\n    }\\n\\n    /** @dev Funtion to invest (BUSD and buy sale tokens)\\n     * @notice Registered only\\n     * @param payAmount amount of BUSD that you invest\\n     */\\n    function invest(uint256 payAmount)\\n        external\\n        timing\\n        nonReentrant\\n        initialized\\n        notCreator\\n    {\\n        if (!expandCalled && random > 0) _expand();\\n\\n        require(payAmount > 0, \\\"ZERO\\\");\\n\\n        address sender1 = _msgSender();\\n        Investor memory sender = registerLevels[sender1];\\n        Investment storage investor = investments[sender1];\\n\\n        uint8 round = getRound();\\n\\n        uint256 tokenAmount = _getTokenAmount(payAmount);\\n        uint256 userPart;\\n        uint8 stage;\\n\\n        if (round == 0) {\\n            //MOON ROUND\\n\\n            require(sender.level > 0 && sender.level < 10, \\\"Not available\\\");\\n            if (sender.level > 0 && sender.level < 4) {\\n                if (expandCalled) require(lotteryWhitelist[sender1], \\\"LOOSE\\\");\\n            }\\n            if (roundTokenAllocation[round][10] == 0)\\n                _getTokenAllocation(round);\\n\\n            userPart =\\n                (intermediate.eachPoolShare * POOL_WEIGHT[sender.level - 1]) /\\n                DENOMINATOR -\\n                _roundInvestments[sender1][round][0];\\n        } else if (round == 1) {\\n            //DIAMOND ROUND\\n            stage = getStage();\\n\\n            require(sender.lock, \\\"Not available\\\");\\n            if (sender.level > 0 && sender.level < 4) {\\n                if (expandCalled) require(lotteryWhitelist[sender1], \\\"LOOSE\\\");\\n            }\\n            if (roundTokenAllocation[round][10] == 0)\\n                _getTokenAllocation(round);\\n\\n            userPart =\\n                (((intermediate.eachPoolShare * POOL_WEIGHT[sender.level - 1]) /\\n                    DENOMINATOR) * DIAMOND_COEFFICIENTS[stage]) /\\n                DENOMINATOR -\\n                _roundInvestments[sender1][round][stage];\\n            if (userPart > intermediate.tokensForSaleLeft)\\n                userPart = intermediate.tokensForSaleLeft;\\n        } else if (round == 2) {\\n            //PAPER ROUND\\n\\n            (uint256 level, , , , , , , , ) = STAKING.stakeForUser(sender1, 0);\\n            require(level > 0, \\\"Not available\\\");\\n\\n            if (roundTokenAllocation[round][10] == 0)\\n                roundTokenAllocation[round][10] = intermediate\\n                    .tokensForSaleLeft;\\n            userPart =\\n                (roundTokenAllocation[round][10] * 10) /\\n                DENOMINATOR -\\n                _roundInvestments[sender1][round][0];\\n            if (userPart > intermediate.tokensForSaleLeft)\\n                userPart = intermediate.tokensForSaleLeft;\\n        } else revert(\\\"REST\\\");\\n\\n        if (userPart < tokenAmount) {\\n            tokenAmount = userPart;\\n            payAmount = _getPayAmount(tokenAmount);\\n            require(payAmount > 0, \\\"ZERO\\\");\\n        }\\n\\n        uint256 investmentFee;\\n        if (feePercent > 0) {\\n            investmentFee = (payAmount * feePercent) / DENOMINATOR;\\n        }\\n\\n        require(\\n            intermediate.tokensForSaleLeft >= tokenAmount && tokenAmount > 0,\\n            \\\"WRONG TOKEN AMOUNT\\\"\\n        );\\n\\n        if (round == 0)\\n            roundTokenAllocation[round][sender.level] -= tokenAmount;\\n\\n        _roundInvestments[sender1][round][stage] += tokenAmount;\\n        intermediate.tokensForSaleLeft -= tokenAmount;\\n        investor.amountEth += payAmount;\\n        investor.amountTokens += tokenAmount;\\n        intermediate.raisedAmount += payAmount;\\n\\n        if (_isClosingAvailable(round)) {\\n            _closePresale();\\n        }\\n\\n        TransferHelper.safeTransferFrom(\\n            BUSD,\\n            sender1,\\n            address(this),\\n            payAmount\\n        );\\n        if (investmentFee > 0) {\\n            TransferHelper.safeTransferFrom(\\n                BUSD,\\n                sender1,\\n                FEE_RECEIVER,\\n                investmentFee\\n            );\\n        }\\n    }\\n\\n    /** @dev Function to add liquidity in paymentToken-saleToken pair\\n     * @notice Creator only\\n     */\\n    function addLiquidity()\\n        external\\n        nonReentrant\\n        onlyPresaleCreator\\n        initialized\\n    {\\n        uint256 currentTime = block.timestamp;\\n        require(\\n            intermediate.raisedAmount >= generalInfo.softCap &&\\n                currentTime >= dexInfo.liquidityAllocationTime,\\n            \\\"TIME/SOFTCAP\\\"\\n        );\\n\\n        IRouter router = IRouter(DEX);\\n        IFactory factory = IFactory(router.factory());\\n\\n        uint256 paymentAmount = (intermediate.raisedAmount *\\n            dexInfo.liquidityPercentageAllocation) / DENOMINATOR;\\n        uint256 tokenAmount = (paymentAmount * tokenMagnitude) /\\n            dexInfo.listingPrice;\\n        require(\\n            paymentAmount > 0 &&\\n                tokenAmount <= intermediate.tokensForLiquidityLeft,\\n            \\\"WRONG PAYMENT/TOKEN AMOUNT\\\"\\n        );\\n\\n        TransferHelper.safeApprove(\\n            generalInfo.tokenAddress,\\n            DEX,\\n            tokenAmount\\n        );\\n\\n        uint256 amountEth;\\n        uint256 amountToken;\\n\\n        intermediate.lpUnlockTime =\\n            currentTime +\\n            dexInfo.lpTokensLockDurationInDays *\\n            1 days;\\n        TransferHelper.safeApprove(BUSD, DEX, paymentAmount);\\n\\n        (amountEth, amountToken, ) = router.addLiquidity(\\n            BUSD,\\n            generalInfo.tokenAddress,\\n            paymentAmount,\\n            tokenAmount,\\n            0,\\n            0,\\n            address(this),\\n            currentTime\\n        );\\n\\n        intermediate.lpAddress = factory.getPair(\\n            BUSD,\\n            generalInfo.tokenAddress\\n        );\\n\\n        intermediate.usdToLiq = amountEth;\\n        intermediate.raisedAmount -= amountEth;\\n        intermediate.tokensForLiquidityLeft -= amountToken;\\n    }\\n\\n    /** @dev Function to claim sale tokens\\n     * @notice Investor only\\n     */\\n    function claimTokens()\\n        external\\n        nonReentrant\\n        liquidityAdded\\n        initialized\\n        notCreator\\n    {\\n        address sender = _msgSender();\\n        Investment storage investor = investments[sender];\\n        require(\\n            investor.amountTokens > 0 &&\\n                investor.amountClaimed < investor.amountTokens,\\n            \\\"NTHNG 2 CLAIM\\\"\\n        );\\n\\n        if (vestingInfo.vestingPerc1 == DENOMINATOR) {\\n            investor.amountClaimed = investor.amountTokens;\\n            TransferHelper.safeTransfer(\\n                generalInfo.tokenAddress,\\n                sender,\\n                investor.amountTokens\\n            );\\n        } else {\\n            uint256 amount = (investor.amountTokens *\\n                vestingInfo.vestingPerc1) / DENOMINATOR;\\n            uint256 beginingTime = intermediate.lpUnlockTime -\\n                dexInfo.lpTokensLockDurationInDays *\\n                1 days;\\n            uint256 numOfParts = (block.timestamp - beginingTime) /\\n                vestingInfo.vestingPeriod;\\n            uint256 part = (investor.amountTokens * vestingInfo.vestingPerc2) /\\n                DENOMINATOR;\\n\\n            amount += numOfParts * part;\\n            amount -= investor.amountClaimed;\\n            require(amount > 0, \\\"0\\\");\\n            if (amount + investor.amountClaimed > investor.amountTokens)\\n                amount = investor.amountTokens - investor.amountClaimed;\\n            investor.amountClaimed += amount;\\n\\n            TransferHelper.safeTransfer(\\n                generalInfo.tokenAddress,\\n                sender,\\n                amount\\n            );\\n        }\\n    }\\n\\n    /** @dev Function to claim earning funds\\n     * @notice Creator only\\n     */\\n    function claimRaisedFunds()\\n        external\\n        nonReentrant\\n        onlyPresaleCreator\\n        liquidityAdded\\n        initialized\\n    {\\n        require(!intermediate.withdrawedFunds, \\\"WITHDRAWED\\\");\\n        intermediate.withdrawedFunds = true;\\n\\n        address sender = _msgSender();\\n        uint256 unsoldTokensAmount = intermediate.tokensForSaleLeft +\\n            intermediate.tokensForLiquidityLeft;\\n\\n        if (unsoldTokensAmount > 0) {\\n            TransferHelper.safeTransfer(\\n                generalInfo.tokenAddress,\\n                generalInfo.unsoldTokenToAddress,\\n                unsoldTokensAmount\\n            );\\n        }\\n\\n        TransferHelper.safeTransfer(BUSD, sender, intermediate.raisedAmount);\\n    }\\n\\n    /** @dev Function to claim LP-tokens\\n     * @notice Creator only\\n     */\\n    function claimLps()\\n        external\\n        nonReentrant\\n        onlyPresaleCreator\\n        liquidityAdded\\n    {\\n        uint256 amount = IERC20(intermediate.lpAddress).balanceOf(\\n            address(this)\\n        );\\n        require(\\n            intermediate.lpUnlockTime <= block.timestamp && amount > 0,\\n            \\\"WRONG PARAMS\\\"\\n        );\\n        TransferHelper.safeTransfer(\\n            intermediate.lpAddress,\\n            _msgSender(),\\n            amount\\n        );\\n    }\\n\\n    /** @dev Function for presale closing\\n     * @notice Creator only\\n     */\\n    function closePresale() external initialized onlyPresaleCreator timing {\\n        _closePresale();\\n    }\\n\\n    //UNSUCCESSFUL SCENARIO----------------------------------------\\n    /** @dev Function to withdraw your investments if presale is failed\\n     * @notice Investor only\\n     */\\n    function withdrawInvestment() external nonReentrant initialized notCreator {\\n        require(\\n            block.timestamp > generalInfo.closeTime &&\\n                intermediate.lpAddress == address(0) &&\\n                intermediate.raisedAmount < generalInfo.softCap,\\n            \\\"WRONG PARAMS\\\"\\n        );\\n\\n        address sender = _msgSender();\\n        uint256 investmentAmount = investments[sender].amountEth;\\n        require(investmentAmount > 0, \\\"ZERO\\\");\\n\\n        delete (investments[sender]);\\n\\n        TransferHelper.safeTransfer(BUSD, sender, investmentAmount);\\n    }\\n\\n    /** @dev Function to withdraw sale tokens if presale is failed\\n     * @notice Creator only\\n     */\\n    function withdrawTokens()\\n        external\\n        nonReentrant\\n        onlyPresaleCreator\\n        initialized\\n    {\\n        require(\\n            block.timestamp > generalInfo.closeTime &&\\n                intermediate.lpAddress == address(0) &&\\n                intermediate.raisedAmount < generalInfo.softCap,\\n            \\\"WRONG PARAMS\\\"\\n        );\\n\\n        intermediate.tokensForLiquidityLeft = 0;\\n        intermediate.tokensForSaleLeft = 0;\\n\\n        uint256 amount = IERC20(generalInfo.tokenAddress).balanceOf(\\n            address(this)\\n        );\\n        require(amount > 0, \\\"ZERO\\\");\\n        TransferHelper.safeTransfer(\\n            generalInfo.tokenAddress,\\n            generalInfo.creator,\\n            amount\\n        );\\n        amount = LINK.balanceOf(address(this));\\n        if (amount > 0) {\\n            TransferHelper.safeTransfer(\\n                address(LINK),\\n                generalInfo.creator,\\n                amount\\n            );\\n        }\\n    }\\n\\n    /** @dev View function that returns total registered users number\\n     */\\n    function getTotalRegistered() external view returns (uint256 participants) {\\n        for (uint256 i = 1; i < 10; i++) {\\n            participants += levelsCounter[i];\\n        }\\n    }\\n\\n    /** @dev View function that returns yes/no votes amount\\n     */\\n    function getVotes() external view returns (uint256, uint256) {\\n        return (intermediate.votes.yes, intermediate.votes.no);\\n    }\\n\\n    /** @dev View function that returns user voting status\\n     * @param user user address\\n     */\\n    function isUserVoted(address user) external view returns (bool) {\\n        return _voteSent[user];\\n    }\\n\\n    /** @dev View function that returns correct raised amount before and after liquidity allocation\\n     */\\n    function getRaisedAmount() external view returns (uint256) {\\n        if (intermediate.lpAddress != address(0)) {\\n            return intermediate.raisedAmount + intermediate.usdToLiq;\\n        } else return intermediate.raisedAmount;\\n    }\\n\\n    /** @dev View function that returns round number (if time between rounds || before openTime || after closeTime => returns 3)\\n     */\\n    function getRound() public view returns (uint8) {\\n        uint256 currentTime = block.timestamp;\\n        if (currentTime >= generalInfo.closeTime) return 3;\\n        if (\\n            currentTime < generalInfo.openTime + 2 hours &&\\n            currentTime >= generalInfo.openTime\\n        ) {\\n            //MOON ROUND\\n            return 0;\\n        } else if (\\n            currentTime >= generalInfo.openTime + 4 hours &&\\n            currentTime < generalInfo.openTime + 6 hours\\n        ) {\\n            //DIAMOND ROUND\\n            return 1;\\n        } else if (\\n            currentTime >= generalInfo.openTime + 8 hours &&\\n            currentTime < generalInfo.closeTime\\n        ) {\\n            //PAPER ROUND\\n            return 2;\\n        } else return 3;\\n    }\\n\\n    /** @dev View function that returns stage number in Diamond round (if time is not in the Diamond round returns 4)\\n     */\\n    function getStage() public view returns (uint8) {\\n        uint256 currentTime = block.timestamp;\\n        if (\\n            currentTime < generalInfo.openTime ||\\n            currentTime >= generalInfo.closeTime\\n        ) return 4;\\n        if (\\n            currentTime >= generalInfo.openTime + 4 hours &&\\n            currentTime < generalInfo.openTime + 4 hours + 30 minutes\\n        ) return 0;\\n        else if (\\n            currentTime >= generalInfo.openTime + 4 hours + 30 minutes &&\\n            currentTime < generalInfo.openTime + 5 hours\\n        ) return 1;\\n        else if (\\n            currentTime >= generalInfo.openTime + 5 hours &&\\n            currentTime < generalInfo.openTime + 5 hours + 30 minutes\\n        ) return 2;\\n        else if (\\n            currentTime >= generalInfo.openTime + 5 hours + 30 minutes &&\\n            currentTime < generalInfo.openTime + 6 hours\\n        ) return 3;\\n        else return 4;\\n    }\\n\\n    /** @dev View function that returns max user investment\\n     */\\n    function getMaxInvestment(address user) external view returns (uint256) {\\n        uint8 round = getRound();\\n        uint8 stage;\\n        uint256 i;\\n        uint256 n;\\n        uint256 totalShares;\\n        Investor memory sender = registerLevels[user];\\n        if (round == 0) {\\n            if (sender.level == 0) return 0;\\n            if (\\n                (sender.level > 0 && sender.level < 4) &&\\n                expandCalled &&\\n                !lotteryWhitelist[user]\\n            ) return 0;\\n            if (roundTokenAllocation[round][10] == 1) {\\n                return\\n                    (intermediate.eachPoolShare *\\n                        POOL_WEIGHT[sender.level - 1]) /\\n                    DENOMINATOR -\\n                    _roundInvestments[user][round][0];\\n            } else {\\n                for (i = 1; i < 4; i++) {\\n                    n =\\n                        (levelsCounter[i] * WINNING_CHANCE[i - 1]) /\\n                        DENOMINATOR;\\n                    if (n == 0) {\\n                        totalShares += (levelsCounter[i] * POOL_WEIGHT[i - 1]);\\n                    } else {\\n                        totalShares += n * POOL_WEIGHT[i - 1];\\n                    }\\n                }\\n\\n                for (i = 4; i < 10; i++) {\\n                    totalShares += (levelsCounter[i] * POOL_WEIGHT[i - 1]);\\n                }\\n\\n                return\\n                    (((intermediate.tokensForSaleLeft * DENOMINATOR) /\\n                        totalShares) * POOL_WEIGHT[sender.level - 1]) /\\n                    DENOMINATOR;\\n            }\\n        } else if (round == 1) {\\n            if (!sender.lock || sender.level == 0) return 0;\\n            if (\\n                (sender.level > 0 && sender.level < 4) &&\\n                expandCalled &&\\n                !lotteryWhitelist[user]\\n            ) return 0;\\n            stage = getStage();\\n            uint256 userPart;\\n            if (roundTokenAllocation[round][10] == 1) {\\n                userPart =\\n                    (((intermediate.eachPoolShare *\\n                        POOL_WEIGHT[sender.level - 1]) / DENOMINATOR) *\\n                        DIAMOND_COEFFICIENTS[stage]) /\\n                    DENOMINATOR -\\n                    _roundInvestments[user][round][stage];\\n                if (userPart > intermediate.tokensForSaleLeft)\\n                    userPart = intermediate.tokensForSaleLeft;\\n                return userPart;\\n            } else {\\n                for (i = 1; i < 4; i++) {\\n                    n =\\n                        (levelsCounter[10 + i] * WINNING_CHANCE[i - 1]) /\\n                        DENOMINATOR;\\n                    if (n == 0) {\\n                        totalShares += (levelsCounter[10 + i] *\\n                            POOL_WEIGHT[i - 1]);\\n                    } else {\\n                        totalShares += n * POOL_WEIGHT[i - 1];\\n                    }\\n                }\\n\\n                for (i = 4; i < 10; i++) {\\n                    totalShares += (levelsCounter[i + 10] * POOL_WEIGHT[i - 1]);\\n                }\\n\\n                userPart =\\n                    (((((intermediate.tokensForSaleLeft * DENOMINATOR) /\\n                        totalShares) * POOL_WEIGHT[sender.level - 1]) /\\n                        DENOMINATOR) * DIAMOND_COEFFICIENTS[stage]) /\\n                    DENOMINATOR;\\n                if (userPart > intermediate.tokensForSaleLeft)\\n                    userPart = intermediate.tokensForSaleLeft;\\n                return userPart;\\n            }\\n        } else if (round == 2) {\\n            (uint256 level, , , , , , , , ) = STAKING.stakeForUser(user, 0);\\n            if (level == 0) return 0;\\n            if (roundTokenAllocation[round][10] == 0) {\\n                return\\n                    (intermediate.tokensForSaleLeft * 10) /\\n                    DENOMINATOR -\\n                    _roundInvestments[user][round][0];\\n            } else\\n                return\\n                    (roundTokenAllocation[round][10] * 10) /\\n                    DENOMINATOR -\\n                    _roundInvestments[user][round][0];\\n        } else return 0;\\n    }\\n\\n    /** @dev View function that returns random request status\\n     */\\n    function randomRequested() external view returns (bool) {\\n        if (random > 0) return true;\\n        else return false;\\n    }\\n\\n    /** @dev Request for Chainlink\\n     */\\n    function fulfillRandomness(bytes32 requestId, uint256 randomness)\\n        internal\\n        override\\n    {\\n        require(random == 0 && !expandCalled, \\\"REQUESTED\\\");\\n        random = randomness + 1;\\n    }\\n\\n    function _closePresale() private {\\n        uint256 currentTime = block.timestamp;\\n        dexInfo.liquidityAllocationTime =\\n            currentTime +\\n            (dexInfo.liquidityAllocationTime - generalInfo.closeTime);\\n        generalInfo.closeTime = currentTime;\\n    }\\n\\n    function _expand() private {\\n        expandCalled = true;\\n\\n        uint256 i;\\n        uint256 index;\\n        uint256 n = (levelsCounter[1] * 15) / DENOMINATOR;\\n        if (n == 0) {\\n            for (i; i < tier1.length; i++) {\\n                lotteryWhitelist[tier1[i]] = true;\\n            }\\n        } else {\\n            for (i; i < n; i++) {\\n                index = uint256(keccak256(abi.encode(random, i)));\\n                index = (index % levelsCounter[1]);\\n                while (lotteryWhitelist[tier1[index]] && index < tier1.length) {\\n                    index++;\\n                    if (index == tier1.length) index = 0;\\n                }\\n                lotteryWhitelist[tier1[index]] = true;\\n            }\\n        }\\n\\n        n = (levelsCounter[2] * 35) / DENOMINATOR;\\n        if (n == 0) {\\n            for (i = 0; i < tier2.length; i++) {\\n                lotteryWhitelist[tier2[i]] = true;\\n            }\\n        } else {\\n            for (i = 0; i < n; i++) {\\n                index = uint256(keccak256(abi.encode(random, i)));\\n                index = (index % levelsCounter[2]);\\n                while (lotteryWhitelist[tier2[index]] && index < tier2.length) {\\n                    index++;\\n                    if (index == tier2.length) index = 0;\\n                }\\n                lotteryWhitelist[tier2[index]] = true;\\n            }\\n        }\\n\\n        n = (levelsCounter[3] * 80) / DENOMINATOR;\\n        if (n == 0) {\\n            for (i = 0; i < tier3.length; i++) {\\n                lotteryWhitelist[tier3[i]] = true;\\n            }\\n        } else {\\n            for (i = 0; i < n; i++) {\\n                index = uint256(keccak256(abi.encode(random, i)));\\n                index = (index % levelsCounter[3]);\\n                while (lotteryWhitelist[tier3[index]] && index < tier3.length) {\\n                    index++;\\n                    if (index == tier3.length) index = 0;\\n                }\\n                lotteryWhitelist[tier3[index]] = true;\\n            }\\n        }\\n\\n        random = 0;\\n    }\\n\\n    function _getTokenAllocation(uint8 _round) private {\\n        uint256 totalShares;\\n        uint256 i;\\n\\n        if (_round == 0) {\\n            //set flag\\n            roundTokenAllocation[_round][10] = 1;\\n\\n            uint256 n;\\n            for (i = 1; i < 4; i++) {\\n                n = (levelsCounter[i] * WINNING_CHANCE[i - 1]) / DENOMINATOR;\\n                if (n == 0) {\\n                    totalShares += (levelsCounter[i] * POOL_WEIGHT[i - 1]);\\n                } else {\\n                    totalShares += n * POOL_WEIGHT[i-1];\\n                }\\n            }\\n\\n            for (i = 4; i < 10; i++) {\\n                totalShares += (levelsCounter[i] * POOL_WEIGHT[i - 1]);\\n            }\\n\\n            intermediate.eachPoolShare =\\n                (intermediate.tokensForSaleLeft * DENOMINATOR) /\\n                totalShares;\\n\\n            for (i = 1; i < 4; i++) {\\n                n = (levelsCounter[i] * WINNING_CHANCE[i - 1]) / DENOMINATOR;\\n                if (n == 0) {\\n                    roundTokenAllocation[_round][i] =\\n                        (levelsCounter[i] *\\n                            intermediate.eachPoolShare *\\n                            POOL_WEIGHT[i - 1]) /\\n                        DENOMINATOR;\\n                } else {\\n                    roundTokenAllocation[_round][i] =\\n                        (intermediate.eachPoolShare *\\n                            POOL_WEIGHT[i - 1] *\\n                            n) /\\n                        (DENOMINATOR);\\n                }\\n            }\\n\\n            for (i = 4; i < 10; i++) {\\n                roundTokenAllocation[_round][i] =\\n                    (intermediate.eachPoolShare *\\n                        POOL_WEIGHT[i - 1] *\\n                        levelsCounter[i]) /\\n                    DENOMINATOR;\\n            }\\n        } else if (_round == 1) {\\n            //set flag\\n            roundTokenAllocation[_round][10] = 1;\\n\\n            uint256 n;\\n            for (i = 1; i < 4; i++) {\\n                n =\\n                    (levelsCounter[10 + i] * WINNING_CHANCE[i - 1]) /\\n                    DENOMINATOR;\\n                if (n == 0) {\\n                    totalShares += (levelsCounter[10 + i] * POOL_WEIGHT[i - 1]);\\n                } else {\\n                    totalShares += n * POOL_WEIGHT[i - 1];\\n                }\\n            }\\n\\n            for (i = 4; i < 10; i++) {\\n                totalShares += (levelsCounter[10 + i] * POOL_WEIGHT[i - 1]);\\n            }\\n\\n            intermediate.eachPoolShare =\\n                (intermediate.tokensForSaleLeft * DENOMINATOR) /\\n                totalShares;\\n\\n            for (i = 1; i < 4; i++) {\\n                n =\\n                    (levelsCounter[10 + i] * WINNING_CHANCE[i - 1]) /\\n                    DENOMINATOR;\\n                if (n == 0) {\\n                    roundTokenAllocation[_round][i] =\\n                        (levelsCounter[i + 10] *\\n                            (intermediate.eachPoolShare * POOL_WEIGHT[i - 1])) /\\n                        DENOMINATOR;\\n                } else {\\n                    roundTokenAllocation[_round][i] =\\n                        (intermediate.eachPoolShare *\\n                            POOL_WEIGHT[i - 1] *\\n                            n) /\\n                        (DENOMINATOR);\\n                }\\n            }\\n\\n            for (i = 4; i < 10; i++) {\\n                roundTokenAllocation[_round][i] =\\n                    ((intermediate.eachPoolShare * POOL_WEIGHT[i - 1]) /\\n                        DENOMINATOR) *\\n                    levelsCounter[i + 10];\\n            }\\n        }\\n    }\\n\\n    function _isClosingAvailable(uint8 round) private view returns (bool) {\\n        if (round == 0) {\\n            uint256 tokenAmount;\\n            for (uint256 i; i < 10; i++) {\\n                tokenAmount += roundTokenAllocation[round][i];\\n            }\\n            if (tokenAmount == 0) return true;\\n        }\\n        if (\\n            intermediate.tokensForSaleLeft == 0 ||\\n            intermediate.raisedAmount == generalInfo.hardCap\\n        ) return true;\\n        else return false;\\n    }\\n\\n    function _getTokenAmount(uint256 _weiAmount)\\n        private\\n        view\\n        returns (uint256)\\n    {\\n        return (_weiAmount * tokenMagnitude) / generalInfo.tokenPrice;\\n    }\\n\\n    function _getPayAmount(uint256 _tokenAmount)\\n        private\\n        view\\n        returns (uint256)\\n    {\\n        return (_tokenAmount * generalInfo.tokenPrice) / tokenMagnitude;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\ninterface IRouter {\\n    function factory() external view returns (address);\\n\\n    function WETH() external view returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        returns (\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 liquidity\\n        );\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256 amountToken,\\n            uint256 amountETH,\\n            uint256 liquidity\\n        );\\n}\\n\\ninterface IFactory {\\n    function getPair(address tokenA, address tokenB)\\n        external\\n        view\\n        returns (address pair);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\n\\ninterface IStaking{\\n    \\n    \\n    function stakeForUser(address user, uint256 lockUp) external view\\n        returns (\\n            uint256 level,\\n            uint256 totalStakedForUser,\\n            bool first_lock,\\n            bool second_lock,\\n            bool third_lock,\\n            bool fourth_lock,\\n            uint256 amountLock,\\n            uint256 rewardTaken,\\n            uint256 enteredAt\\n        );\\n\\n    function addPresale(address presale) external;\\n\\n    function addReLock(address user) external;\\n}\\n\"\r\n    },\r\n    \"contracts/pancake-swap/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) =\\n            token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"TransferHelper::safeApprove: approve failed\\\"\\n        );\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) =\\n            token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"TransferHelper::safeTransfer: transfer failed\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) =\\n            token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"TransferHelper::transferFrom: transferFrom failed\\\"\\n        );\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(\\n            success,\\n            \\\"TransferHelper::safeTransferETH: ETH transfer failed\\\"\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/VRFConsumerBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/LinkTokenInterface.sol\\\";\\n\\nimport \\\"./VRFRequestIDBase.sol\\\";\\n\\n/** ****************************************************************************\\n * @notice Interface for contracts using VRF randomness\\n * *****************************************************************************\\n * @dev PURPOSE\\n *\\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\\n * @dev making his output up to suit himself. Reggie provides Vera a public key\\n * @dev to which he knows the secret key. Each time Vera provides a seed to\\n * @dev Reggie, he gives back a value which is computed completely\\n * @dev deterministically from the seed and the secret key.\\n *\\n * @dev Reggie provides a proof by which Vera can verify that the output was\\n * @dev correctly computed once Reggie tells it to her, but without that proof,\\n * @dev the output is indistinguishable to her from a uniform random sample\\n * @dev from the output space.\\n *\\n * @dev The purpose of this contract is to make it easy for unrelated contracts\\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\\n * @dev simple access to a verifiable source of randomness.\\n * *****************************************************************************\\n * @dev USAGE\\n *\\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\\n * @dev initialize VRFConsumerBase's attributes in their constructor as\\n * @dev shown:\\n *\\n * @dev   contract VRFConsumer {\\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\\n * @dev       VRFConsumerBase(_vrfCoordinator, _link) public {\\n * @dev         <initialization with other arguments goes here>\\n * @dev       }\\n * @dev   }\\n *\\n * @dev The oracle will have given you an ID for the VRF keypair they have\\n * @dev committed to (let's call it keyHash), and have told you the minimum LINK\\n * @dev price for VRF service. Make sure your contract has sufficient LINK, and\\n * @dev call requestRandomness(keyHash, fee, seed), where seed is the input you\\n * @dev want to generate randomness from.\\n *\\n * @dev Once the VRFCoordinator has received and validated the oracle's response\\n * @dev to your request, it will call your contract's fulfillRandomness method.\\n *\\n * @dev The randomness argument to fulfillRandomness is the actual random value\\n * @dev generated from your seed.\\n *\\n * @dev The requestId argument is generated from the keyHash and the seed by\\n * @dev makeRequestId(keyHash, seed). If your contract could have concurrent\\n * @dev requests open, you can use the requestId to track which seed is\\n * @dev associated with which randomness. See VRFRequestIDBase.sol for more\\n * @dev details. (See \\\"SECURITY CONSIDERATIONS\\\" for principles to keep in mind,\\n * @dev if your contract could have multiple requests in flight simultaneously.)\\n *\\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\\n * @dev differ. (Which is critical to making unpredictable randomness! See the\\n * @dev next section.)\\n *\\n * *****************************************************************************\\n * @dev SECURITY CONSIDERATIONS\\n *\\n * @dev A method with the ability to call your fulfillRandomness method directly\\n * @dev could spoof a VRF response with any random value, so it's critical that\\n * @dev it cannot be directly called by anything other than this base contract\\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\\n *\\n * @dev For your users to trust that your contract's random behavior is free\\n * @dev from malicious interference, it's best if you can write it so that all\\n * @dev behaviors implied by a VRF response are executed *during* your\\n * @dev fulfillRandomness method. If your contract must store the response (or\\n * @dev anything derived from it) and use it later, you must ensure that any\\n * @dev user-significant behavior which depends on that stored value cannot be\\n * @dev manipulated by a subsequent VRF request.\\n *\\n * @dev Similarly, both miners and the VRF oracle itself have some influence\\n * @dev over the order in which VRF responses appear on the blockchain, so if\\n * @dev your contract could have multiple VRF requests in flight simultaneously,\\n * @dev you must ensure that the order in which the VRF responses arrive cannot\\n * @dev be used to manipulate your contract's user-significant behavior.\\n *\\n * @dev Since the ultimate input to the VRF is mixed with the block hash of the\\n * @dev block in which the request is made, user-provided seeds have no impact\\n * @dev on its economic security properties. They are only included for API\\n * @dev compatability with previous versions of this contract.\\n *\\n * @dev Since the block hash of the block which contains the requestRandomness\\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\\n * @dev miner could, in principle, fork the blockchain to evict the block\\n * @dev containing the request, forcing the request to be included in a\\n * @dev different block with a different hash, and therefore a different input\\n * @dev to the VRF. However, such an attack would incur a substantial economic\\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\\n * @dev until it calls responds to a request.\\n */\\nabstract contract VRFConsumerBase is VRFRequestIDBase {\\n  /**\\n   * @notice fulfillRandomness handles the VRF response. Your contract must\\n   * @notice implement it. See \\\"SECURITY CONSIDERATIONS\\\" above for important\\n   * @notice principles to keep in mind when implementing your fulfillRandomness\\n   * @notice method.\\n   *\\n   * @dev VRFConsumerBase expects its subcontracts to have a method with this\\n   * @dev signature, and will call it once it has verified the proof\\n   * @dev associated with the randomness. (It is triggered via a call to\\n   * @dev rawFulfillRandomness, below.)\\n   *\\n   * @param requestId The Id initially returned by requestRandomness\\n   * @param randomness the VRF output\\n   */\\n  function fulfillRandomness(bytes32 requestId, uint256 randomness) internal virtual;\\n\\n  /**\\n   * @dev In order to keep backwards compatibility we have kept the user\\n   * seed field around. We remove the use of it because given that the blockhash\\n   * enters later, it overrides whatever randomness the used seed provides.\\n   * Given that it adds no security, and can easily lead to misunderstandings,\\n   * we have removed it from usage and can now provide a simpler API.\\n   */\\n  uint256 private constant USER_SEED_PLACEHOLDER = 0;\\n\\n  /**\\n   * @notice requestRandomness initiates a request for VRF output given _seed\\n   *\\n   * @dev The fulfillRandomness method receives the output, once it's provided\\n   * @dev by the Oracle, and verified by the vrfCoordinator.\\n   *\\n   * @dev The _keyHash must already be registered with the VRFCoordinator, and\\n   * @dev the _fee must exceed the fee specified during registration of the\\n   * @dev _keyHash.\\n   *\\n   * @dev The _seed parameter is vestigial, and is kept only for API\\n   * @dev compatibility with older versions. It can't *hurt* to mix in some of\\n   * @dev your own randomness, here, but it's not necessary because the VRF\\n   * @dev oracle will mix the hash of the block containing your request into the\\n   * @dev VRF seed it ultimately uses.\\n   *\\n   * @param _keyHash ID of public key against which randomness is generated\\n   * @param _fee The amount of LINK to send with the request\\n   *\\n   * @return requestId unique ID for this request\\n   *\\n   * @dev The returned requestId can be used to distinguish responses to\\n   * @dev concurrent requests. It is passed as the first argument to\\n   * @dev fulfillRandomness.\\n   */\\n  function requestRandomness(bytes32 _keyHash, uint256 _fee) internal returns (bytes32 requestId) {\\n    LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, USER_SEED_PLACEHOLDER));\\n    // This is the seed passed to VRFCoordinator. The oracle will mix this with\\n    // the hash of the block containing this request to obtain the seed/input\\n    // which is finally passed to the VRF cryptographic machinery.\\n    uint256 vRFSeed = makeVRFInputSeed(_keyHash, USER_SEED_PLACEHOLDER, address(this), nonces[_keyHash]);\\n    // nonces[_keyHash] must stay in sync with\\n    // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above\\n    // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).\\n    // This provides protection against the user repeating their input seed,\\n    // which would result in a predictable/duplicate output, if multiple such\\n    // requests appeared in the same block.\\n    nonces[_keyHash] = nonces[_keyHash] + 1;\\n    return makeRequestId(_keyHash, vRFSeed);\\n  }\\n\\n  LinkTokenInterface internal immutable LINK;\\n  address private immutable vrfCoordinator;\\n\\n  // Nonces for each VRF key from which randomness has been requested.\\n  //\\n  // Must stay in sync with VRFCoordinator[_keyHash][this]\\n  mapping(bytes32 => uint256) /* keyHash */ /* nonce */\\n    private nonces;\\n\\n  /**\\n   * @param _vrfCoordinator address of VRFCoordinator contract\\n   * @param _link address of LINK token contract\\n   *\\n   * @dev https://docs.chain.link/docs/link-token-contracts\\n   */\\n  constructor(address _vrfCoordinator, address _link) {\\n    vrfCoordinator = _vrfCoordinator;\\n    LINK = LinkTokenInterface(_link);\\n  }\\n\\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\\n  // the origin of the call\\n  function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {\\n    require(msg.sender == vrfCoordinator, \\\"Only VRFCoordinator can fulfill\\\");\\n    fulfillRandomness(requestId, randomness);\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface LinkTokenInterface {\\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\\n\\n  function approve(address spender, uint256 value) external returns (bool success);\\n\\n  function balanceOf(address owner) external view returns (uint256 balance);\\n\\n  function decimals() external view returns (uint8 decimalPlaces);\\n\\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\\n\\n  function increaseApproval(address spender, uint256 subtractedValue) external;\\n\\n  function name() external view returns (string memory tokenName);\\n\\n  function symbol() external view returns (string memory tokenSymbol);\\n\\n  function totalSupply() external view returns (uint256 totalTokensIssued);\\n\\n  function transfer(address to, uint256 value) external returns (bool success);\\n\\n  function transferAndCall(\\n    address to,\\n    uint256 value,\\n    bytes calldata data\\n  ) external returns (bool success);\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  ) external returns (bool success);\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/VRFRequestIDBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ncontract VRFRequestIDBase {\\n  /**\\n   * @notice returns the seed which is actually input to the VRF coordinator\\n   *\\n   * @dev To prevent repetition of VRF output due to repetition of the\\n   * @dev user-supplied seed, that seed is combined in a hash with the\\n   * @dev user-specific nonce, and the address of the consuming contract. The\\n   * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in\\n   * @dev the final seed, but the nonce does protect against repetition in\\n   * @dev requests which are included in a single block.\\n   *\\n   * @param _userSeed VRF seed input provided by user\\n   * @param _requester Address of the requesting contract\\n   * @param _nonce User-specific nonce at the time of the request\\n   */\\n  function makeVRFInputSeed(\\n    bytes32 _keyHash,\\n    uint256 _userSeed,\\n    address _requester,\\n    uint256 _nonce\\n  ) internal pure returns (uint256) {\\n    return uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\\n  }\\n\\n  /**\\n   * @notice Returns the id for this request\\n   * @param _keyHash The serviceAgreement ID to be used for this request\\n   * @param _vRFInputSeed The seed to be passed directly to the VRF\\n   * @return The id for this request\\n   *\\n   * @dev Note that _vRFInputSeed is not the seed passed by the consuming\\n   * @dev contract, but the one generated by makeVRFInputSeed\\n   */\\n  function makeRequestId(bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staking\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"busd\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"back\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dex\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_VRFCoordinator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_LINK_ADDRESS\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_keyHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hardCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"softCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"openTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"closeTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"unsoldTokenToAddress\",\"type\":\"address\"}],\"internalType\":\"struct Presale.PresaleInfo\",\"name\":\"_info\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"listingPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpTokensLockDurationInDays\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"liquidityPercentageAllocation\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"liquidityAllocationTime\",\"type\":\"uint256\"}],\"internalType\":\"struct Presale.PresaleDexInfo\",\"name\":\"_dexInfo\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"vestingPerc1\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"vestingPerc2\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vestingPeriod\",\"type\":\"uint256\"}],\"internalType\":\"struct Presale.VestingInfo\",\"name\":\"_vestInfo\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"BACKEND\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BUSD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEX\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEE_RECEIVER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STAKING\",\"outputs\":[{\"internalType\":\"contract IStaking\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calculateLotteryResults\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimLps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRaisedFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"closePresale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dexInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"listingPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpTokensLockDurationInDays\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"liquidityPercentageAllocation\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"liquidityAllocationTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"generalInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hardCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"softCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"openTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"closeTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"unsoldTokenToAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getMaxInvestment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRaisedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRound\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStage\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalRegistered\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"participants\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"intermediate\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"yes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"no\",\"type\":\"uint256\"}],\"internalType\":\"struct Presale.Votes\",\"name\":\"votes\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"initialized\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"withdrawedFunds\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"closeTimeVoting\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lpAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"usdToLiq\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpUnlockTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokensForSaleLeft\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokensForLiquidityLeft\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"raisedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"eachPoolShare\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"payAmount\",\"type\":\"uint256\"}],\"name\":\"invest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"investments\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountClaimed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isUserVoted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"levelsCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lotteryWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"randomRequested\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"randomness\",\"type\":\"uint256\"}],\"name\":\"rawFulfillRandomness\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"registerLevels\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"lock\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"roundTokenAllocation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"perc\",\"type\":\"uint256\"}],\"name\":\"setFeePerc\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestingInfo\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"vestingPerc1\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"vestingPerc2\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vestingPeriod\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"yes\",\"type\":\"bool\"}],\"name\":\"vote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votingParams\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minimum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawInvestment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Presale", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "1", "ConstructorArguments": "00000000000000000000000024e1fb7a781d255edc40e80c89d9289dc61925f2000000000000000000000000e9e7cea3dedca5984780bafc599bd69add087d560000000000000000000000007dfe28294bed061f1f93f0f402ab2c6f6d21153000000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e0000000000000000000000002cb65436a0acbc46956c64e34cae045cdbea4b48000000000000000000000000747973a5a2a4ae1d3a8fdf5479f1514f65db9c31000000000000000000000000404460c6a5ede2d891e8297795264fde62adbb75c251acd21ec4fb7f31bb8868288bfdbaeb4fbfec2df3735ddbd4f7dc8d60103c00000000000000000000000000000000000000000000000002c68af0bb1400000000000000000000000000003136ade5c863b449b7018fa9ffe308cddf25decf0000000000000000000000001f7d905c0c495dca4c9e859c313b29179d272ca10000000000000000000000000000000000000000000000000001c6bf5263400000000000000000000000000000000000000000000000152d02c7e14af6800000000000000000000000000000000000000000000000000a968163f0a57b4000000000000000000000000000000000000000000000000000000000000062790240000000000000000000000000000000000000000000000000000000006279ab000000000000000000000000003136ade5c863b449b7018fa9ffe308cddf25decf00000000000000000000000000000000000000000000000000024f2beb1aa00000000000000000000000000000000000000000000000000000000000000000b4000000000000000000000000000000000000000000000000000000000000004e0000000000000000000000000000000000000000000000000000000062823cc0000000000000000000000000000000000000000000000000000000000000001900000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000093a80", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}