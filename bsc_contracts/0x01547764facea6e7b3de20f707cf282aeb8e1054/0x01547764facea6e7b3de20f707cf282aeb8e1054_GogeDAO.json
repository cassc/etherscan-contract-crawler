{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/GogeDao.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.6;\\r\\n\\r\\nimport { Owned } from \\\"./extensions/Owned.sol\\\";\\r\\nimport { IGogeERC20 } from \\\"./interfaces/IGogeERC20.sol\\\";\\r\\n\\r\\n/// @title Doge Day Son Dao Contract.\\r\\n/// @notice This contract is a governance contract which acts as a layer that sits on top of a governance token. This contract allows holders of the governance token\\r\\n///         to create proposals of a chosen pollType. Each pollType has unique parameters which, if passes quorum, will result in a function call to the governance token.\\r\\n/// @author chasebrownn\\r\\ncontract GogeDAO is Owned {\\r\\n\\r\\n    // ---------------\\r\\n    // State Variables\\r\\n    // ---------------\\r\\n\\r\\n    /// @notice Contract address of governance token.\\r\\n    address public governanceToken;\\r\\n    \\r\\n    /// @notice Unique identifier of each poll that is created.\\r\\n    uint256 public pollNum;\\r\\n    /// @notice The minimum time needed for a new poll -> default is 1 day.\\r\\n    uint256 public minPeriod = 1 days;\\r\\n    /// @notice The maximum time needed for a new poll -> default is 60 days.\\r\\n    uint256 public maxPeriod = 60 days;\\r\\n    /// @notice The minimum balance of governance tokens an author of a poll must be holding at the time of creation.\\r\\n    uint256 public minAuthorBal = 10_000_000 ether;\\r\\n    /// @notice The maximum number of polls an author can have active at any given time.\\r\\n    uint256 public maxPollsPerAuthor = 1;\\r\\n    /// @notice The threshold that must be met to pass a poll.\\r\\n    uint256 public quorum = 50;\\r\\n\\r\\n    /// @notice Amount of BNB held for marketing purposes.\\r\\n    uint256 public marketingBalance;\\r\\n    /// @notice Amount of BNB held for team pay.\\r\\n    uint256 public teamBalance;\\r\\n\\r\\n    /// @notice Bool if gatekeeping is enabled.\\r\\n    bool public gatekeeping = true;\\r\\n    /// @notice Bool if createPoll is callable.\\r\\n    bool public createPollEnabled;\\r\\n\\r\\n    /// @notice Array of team member addresses.\\r\\n    address[] public teamMembers;\\r\\n    /// @notice Array of active polls -> array of poll nums.\\r\\n    uint256[] public activePolls;\\r\\n    \\r\\n    /// @notice Double mapping of pollNum to amount of votes per voter.\\r\\n    mapping(uint256 => mapping(address => uint256)) public polls;\\r\\n    /// @notice Mapping of pollNum to array of addresses of voters.\\r\\n    mapping(uint256 => address[]) public voterLibrary;\\r\\n    /// @notice Mapping of pollNum to amount of total votes per poll.\\r\\n    mapping(uint256 => uint256) public pollVotes;\\r\\n    /// @notice Mapping of pollNum to poll author's address.\\r\\n    mapping(uint256 => address) public pollAuthor;\\r\\n\\r\\n    /// @notice Mapping of pollNum to whether or not a poll has been passed (bool).\\r\\n    mapping(uint256 => bool) public passed;\\r\\n    /// @notice Mapping of address to whether or not it is a gatekeeper.\\r\\n    mapping(address => bool) public gatekeeper;\\r\\n    \\r\\n    /// @notice Mapping of address to array of pollNums it advocated votes for.\\r\\n    mapping(address => uint256[]) public advocateFor;\\r\\n\\r\\n    /// @notice Mapping of pollNum to its specified PollType.\\r\\n    mapping(uint256 => PollType) public pollTypes;\\r\\n    /// @notice Mapping of pollNum to its specified Proposal.\\r\\n    mapping(uint256 => Proposal) public proposals;\\r\\n\\r\\n    /// @notice Proposal struct that supports every poll type.\\r\\n    /// @param amount uint256 amount input.                     \\r\\n    /// @param startTime unix timestamp of poll creation date.\\r\\n    /// @param endTime unix timestamp of poll expiration date.\\r\\n    /// @param fee1 uint8 rewardFee.\\r\\n    /// @param fee2 uint8 marketingFee.\\r\\n    /// @param fee3 uint8 buyBackFee.\\r\\n    /// @param fee4 uint8 teamFee.\\r\\n    /// @param status boolean input.\\r\\n    /// @param addr address input.\\r\\n    /// @param description proposal description.\\r\\n    struct Proposal {\\r\\n        uint256 amount;      // Slot 0 -> 32 bytes\\r\\n        uint256 startTime;   // Slot 1 -> 32 bytes\\r\\n        uint256 endTime;     // Slot 2 -> 32 bytes\\r\\n        uint8 fee1;\\r\\n        uint8 fee2;\\r\\n        uint8 fee3;\\r\\n        uint8 fee4;\\r\\n        bool status;\\r\\n        address addr;        // Slot 3 -> 25 bytes\\r\\n        string description;  // Slot 4+ -> 32 bytes+\\r\\n    }\\r\\n\\r\\n    /// @notice Enum containing all possible poll types.\\r\\n    enum PollType {\\r\\n        taxChange,\\r\\n        funding,\\r\\n        setGogeDao, \\r\\n        setCex,\\r\\n        setDex,\\r\\n        excludeFromCirculatingSupply,\\r\\n        updateDividendToken,\\r\\n        updateMarketingWallet,\\r\\n        updateTeamWallet,\\r\\n        updateTeamMember,\\r\\n        updateGatekeeper,\\r\\n        setGatekeeping,\\r\\n        setBuyBackEnabled,\\r\\n        setCakeDividendEnabled,\\r\\n        setMarketingEnabled,\\r\\n        setTeamEnabled,\\r\\n        excludeFromFees,\\r\\n        excludeFromDividends,\\r\\n        modifyBlacklist,\\r\\n        transferOwnership,\\r\\n        setQuorum,\\r\\n        updateGovernanceToken,\\r\\n        updateMaxPeriod,\\r\\n        updateMinAuthorBal,\\r\\n        other\\r\\n    }\\r\\n    \\r\\n\\r\\n    // -----------\\r\\n    // Constructor\\r\\n    // -----------\\r\\n\\r\\n    /// @notice Initializes GogeDao.sol.\\r\\n    /// @param _governanceToken address of governance token.\\r\\n    constructor(address _governanceToken) Owned(msg.sender) {\\r\\n        gatekeeper[owner] = true;\\r\\n        governanceToken = _governanceToken;\\r\\n    }\\r\\n\\r\\n\\r\\n    // ---------\\r\\n    // Modifiers\\r\\n    // ---------\\r\\n\\r\\n    /// @notice Modifier for permissioned functions where msg.sender must be governance token.\\r\\n    modifier onlyGovernanceToken() {\\r\\n        require(msg.sender == governanceToken, \\\"UNAUTHORIZED\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /// @notice Modifier for permissioned functions where msg.sender must be a gatekeeper.\\r\\n    modifier onlyGatekeeper() {\\r\\n        require(gatekeeper[msg.sender], \\\"UNAUTHORIZED\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n\\r\\n    // ------\\r\\n    // Events\\r\\n    // ------\\r\\n\\r\\n    /// @notice Emitted when a new poll is created.\\r\\n    event ProposalCreated(uint256 pollNum, PollType pollType, uint256 endTime);\\r\\n    \\r\\n    /// @notice Emitted when a poll has been passed.\\r\\n    event ProposalPassed(uint256 pollNum);\\r\\n\\r\\n\\r\\n    // ---------\\r\\n    // Functions\\r\\n    // ---------\\r\\n\\r\\n    /// @notice Utility function so this contract can accept BNB.\\r\\n    receive() payable external {}\\r\\n\\r\\n    /// @notice is used to create a new poll.\\r\\n    /// @param  _pollType enum type of poll being created.\\r\\n    /// @param  _change proposal information for the given poll type to be executed.\\r\\n    function createPoll(PollType _pollType, Proposal memory _change) external {        \\r\\n        require(createPollEnabled, \\\"GogeDao.sol::createPoll() Ability to create poll is disabled\\\");\\r\\n        if (msg.sender != owner) require(getActivePollsFromAuthor(msg.sender) < maxPollsPerAuthor, \\\"GogeDao.sol::createPoll() Exceeds maxPollsPerAuthor\\\");\\r\\n        require(block.timestamp < _change.endTime, \\\"GogeDao.sol::createPoll() End time must be later than start time\\\");\\r\\n        require(_change.endTime - block.timestamp >= minPeriod, \\\"GogeDao.sol::createPoll() Polling period must be greater than or equal to minPeriod\\\");\\r\\n        require(_change.endTime - block.timestamp <= maxPeriod, \\\"GogeDao.sol::createPoll() Polling period must be less than or equal to maxPeriod\\\");\\r\\n\\r\\n        uint256 _minBal = minAuthorBal;\\r\\n        uint256 _preBal = IGogeERC20(governanceToken).balanceOf(address(this));\\r\\n\\r\\n        require(IGogeERC20(governanceToken).balanceOf(msg.sender) >= _minBal, \\\"GogeDao.sol::createPoll() Insufficient balance of tokens\\\");\\r\\n        require(IGogeERC20(governanceToken).transferFrom(msg.sender, address(this), _minBal));\\r\\n        require(IGogeERC20(governanceToken).balanceOf(address(this)) == _preBal + _minBal, \\\"GogeDao.sol::createPoll() Full balance not received\\\");\\r\\n\\r\\n        uint256 _pollNum = ++pollNum;\\r\\n\\r\\n        emit ProposalCreated(_pollNum, _pollType, _change.endTime);\\r\\n\\r\\n        _addToVoterLibrary(_pollNum, msg.sender);\\r\\n        _addToAdvocateFor(_pollNum, msg.sender);\\r\\n\\r\\n        polls[_pollNum][msg.sender] += _minBal;\\r\\n        pollVotes[_pollNum]         += _minBal;\\r\\n\\r\\n        pollTypes[_pollNum]  = _pollType;\\r\\n        proposals[_pollNum]  = _change;\\r\\n        pollAuthor[_pollNum] = msg.sender;\\r\\n\\r\\n        activePolls.push(_pollNum);\\r\\n    }\\r\\n\\r\\n    /// @notice A method for a voter to add a vote to an existing poll.\\r\\n    /// @param  _pollNum Unique poll identifier.\\r\\n    /// @param  _numVotes The number of the votes to be added.\\r\\n    function addVote(uint256 _pollNum, uint256 _numVotes) external {\\r\\n        require(block.timestamp < proposals[_pollNum].endTime, \\\"GogeDao.sol::addVote() Poll Closed\\\");\\r\\n        require(block.timestamp - IGogeERC20(governanceToken).getLastReceived(msg.sender) >= (5 minutes), \\\"GogeDao.sol::addVote() Must wait 5 minutes after purchasing tokens to place any votes.\\\");\\r\\n        \\r\\n        uint256 _preBal = IGogeERC20(governanceToken).balanceOf(address(this));\\r\\n        require(IGogeERC20(governanceToken).balanceOf(msg.sender) >= _numVotes, \\\"GogeDao.sol::addVote() Exceeds Balance\\\");\\r\\n        require(IGogeERC20(governanceToken).transferFrom(msg.sender, address(this), _numVotes));\\r\\n        require(IGogeERC20(governanceToken).balanceOf(address(this)) == _preBal + _numVotes, \\\"GogeDao.sol::addVote() Full balance not received\\\");\\r\\n\\r\\n        _addToVoterLibrary(_pollNum, msg.sender);\\r\\n        _addToAdvocateFor(_pollNum, msg.sender);\\r\\n\\r\\n        polls[_pollNum][msg.sender] += _numVotes;\\r\\n        pollVotes[_pollNum]        += _numVotes;\\r\\n\\r\\n        if(!gatekeeping && getProportion(_pollNum) >= quorum) {\\r\\n            _executeProposal(_pollNum);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice A method for a voter to remove their votes from all active polls.\\r\\n    function removeAllVotes() external {\\r\\n        uint256 len = activePolls.length;\\r\\n        for (uint256 i; i < len;) {\\r\\n            _removeVote(activePolls[i]);\\r\\n            unchecked {\\r\\n                ++i;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice A method for a voter to remove their votes from a single poll.\\r\\n    /// @param _pollNum Unique poll identifier.\\r\\n    function removeVotesFromPoll(uint256 _pollNum) external {\\r\\n        _removeVote(_pollNum);\\r\\n    }\\r\\n\\r\\n    /// @notice Will take the BNB balance within teamBalance and pay team members.\\r\\n    function payTeam() public {\\r\\n        // ensures contract balance can support team balance\\r\\n        uint256 balance = teamBalance;\\r\\n        require(balance <= address(this).balance, \\\"GogeDao.sol::payTeam() Insufficient balance!\\\");\\r\\n\\r\\n        // ensures no division by zero.\\r\\n        uint256 length = teamMembers.length;\\r\\n        require(length > 0, \\\"GogeDao.sol::payTeam() No team members!\\\");\\r\\n\\r\\n        // ensures no payments are made if payment is not greater than zero\\r\\n        uint256 payment = balance / length;\\r\\n        require(payment > 0, \\\"GogeDao.sol::payTeam() Insufficient balance!\\\");\\r\\n\\r\\n        for(uint256 i; i < length;) {\\r\\n            (bool sent,) = teamMembers[i].call{value: payment}(\\\"\\\");\\r\\n            require(sent, \\\"GogeDao.sol::payTeam() Failed to send payment\\\");\\r\\n            unchecked {\\r\\n                ++i;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        teamBalance = balance % length;\\r\\n    }\\r\\n\\r\\n    /// @notice A method for querying all active poll end times, and if poll is expired, remove from activePolls.\\r\\n    /// @dev Should be called on a regular time interval using an external script.\\r\\n    ///      Solution: https://automation.chain.link/\\r\\n    function queryEndTime() external {\\r\\n        uint256 length = activePolls.length;\\r\\n        // iterate through activePolls\\r\\n        for (uint256 i; i < length;) {\\r\\n            uint256 endTime = proposals[activePolls[i]].endTime;\\r\\n            // check if poll has reached endTime\\r\\n            if (block.timestamp >= endTime) {\\r\\n                // refund voters\\r\\n                _refundVoters(activePolls[i]);\\r\\n                // remove poll\\r\\n                activePolls[i] = activePolls[--length];\\r\\n                activePolls.pop();                \\r\\n            }\\r\\n            else {\\r\\n                unchecked {\\r\\n                    ++i;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    // ------------------------\\r\\n    // Functions (Permissioned)\\r\\n    // ------------------------\\r\\n\\r\\n    // NOTE: onlyOwner\\r\\n\\r\\n    /// @notice An owner method for updating status of gatekeeping.\\r\\n    /// @param  _enabled Status of gatekeeping.\\r\\n    function setGatekeeping(bool _enabled) external onlyOwner {\\r\\n        _setGatekeeping(_enabled);\\r\\n    }\\r\\n\\r\\n    /// @notice An owner method for adding new team member.\\r\\n    /// @param  _account New team member address.\\r\\n    /// @param  _isMember Is a team member.\\r\\n    function setTeamMember(address _account, bool _isMember) external onlyOwner {\\r\\n        _setTeamMember(_account, _isMember);\\r\\n    }\\r\\n\\r\\n    /// @notice An owner method for updating quorum.\\r\\n    /// @param  _amount New quourum amount.\\r\\n    function updateQuorum(uint8 _amount) external onlyOwner {\\r\\n        _updateQuorum(_amount);\\r\\n    }\\r\\n\\r\\n    /// @notice An owner method for adding new gatekeeper addresses.\\r\\n    /// @param  _gatekeeper New gatekeeper address.\\r\\n    /// @param  _status Is a gatekeeper.\\r\\n    function updateGatekeeper(address _gatekeeper, bool _status) external onlyOwner {\\r\\n        _setGatekeeper(_gatekeeper, _status);\\r\\n    }\\r\\n\\r\\n    /// @notice An owner method for updating status of createPoll.\\r\\n    function toggleCreatePollEnabled() external onlyOwner {\\r\\n        require(IGogeERC20(governanceToken).isExcludedFromFees(address(this)), \\\"GogeDao.sol::toggleCreatePollEnabled() !isExcludedFromFees(address(this))\\\");\\r\\n        createPollEnabled = !createPollEnabled;\\r\\n    }\\r\\n\\r\\n    /// @notice An owner method for manually passing a poll.\\r\\n    /// @param  _pollNum Unique poll identifier.\\r\\n    /// @dev    Poll must be an active poll.\\r\\n    function passPoll(uint256 _pollNum) external onlyOwner {\\r\\n        require(block.timestamp < proposals[_pollNum].endTime, \\\"Poll Closed\\\");\\r\\n        _executeProposal(_pollNum);\\r\\n    }\\r\\n\\r\\n    /// @notice An owner method for manually ending a poll.\\r\\n    /// @param  _pollNum Unique poll identifier.\\r\\n    /// @dev    Poll must be an active poll.\\r\\n    ///         This function is also callable by the author of _pollNum.\\r\\n    function endPoll(uint256 _pollNum) external {\\r\\n        require(msg.sender == owner || msg.sender == pollAuthor[_pollNum], \\\"UNAUTHORIZED\\\");\\r\\n        require(block.timestamp < proposals[_pollNum].endTime, \\\"Poll Closed\\\");\\r\\n        _updateEndTime(_pollNum);\\r\\n        _removePoll(_pollNum);\\r\\n        _refundVoters(_pollNum);\\r\\n    }\\r\\n\\r\\n    /// @notice An owner method for updating minPeriod.\\r\\n    /// @param  _amountOfDays New minPeriod in days.\\r\\n    function updateMinPeriod(uint8 _amountOfDays) external onlyOwner {\\r\\n        require(_amountOfDays < maxPeriod, \\\"minPeriod must be less than maxPeriod\\\");\\r\\n        minPeriod = uint256(_amountOfDays) * 1 days;\\r\\n    }\\r\\n\\r\\n    /// @notice An owner method for updating maxPeriod.\\r\\n    /// @param  _amountOfDays New maxPeriod in days.\\r\\n    function updateMaxPeriod(uint8 _amountOfDays) external onlyOwner {\\r\\n        require(_amountOfDays > minPeriod, \\\"minPeriod must be greater than minPeriod\\\");\\r\\n        maxPeriod = uint256(_amountOfDays) * 1 days;\\r\\n    }\\r\\n\\r\\n    /// @notice An owner method for updating minAuthorBal.\\r\\n    /// @param  _amount New min balance of a poll author.\\r\\n    function updateMinAuthorBal(uint256 _amount) external onlyOwner {\\r\\n        minAuthorBal = _amount;\\r\\n    }\\r\\n\\r\\n    /// @notice An owner method for updating maxPollsPerAuthor.\\r\\n    /// @param  _limit Amount of active polls an author can have at any given time.\\r\\n    function updateMaxPollsPerAuthor(uint8 _limit) external onlyOwner {\\r\\n        maxPollsPerAuthor = uint256(_limit);\\r\\n    }\\r\\n\\r\\n    /// @notice An owner method to assign the governance token.\\r\\n    /// @param _token New governance token address.\\r\\n    function setGovernanceToken(address _token) external onlyOwner {\\r\\n        _setGovernanceToken(_token);\\r\\n    }\\r\\n\\r\\n    /// @notice Withdraws the entire ETH balance of this contract into the owner wallet.\\r\\n    /// @dev Call pattern adopted from the sendValue(address payable recipient, uint256 amount)\\r\\n    ///      function in OZ's utils/Address.sol contract. \\\"Please consider reentrancy potential\\\" - OZ.\\r\\n    function withdraw() external onlyOwner {\\r\\n        uint256 balance = address(this).balance - (marketingBalance + teamBalance);\\r\\n        require(balance > 0, \\\"Insufficient BNB balance\\\");\\r\\n\\r\\n        (bool success,) = owner.call{value: balance}(\\\"\\\");\\r\\n        require(success, \\\"Unable to withdraw funds, recipient may have reverted\\\");\\r\\n    }\\r\\n\\r\\n    /// @notice Withdraws any ERC20 token balance of this contract.\\r\\n    /// @param  _token Address of an ERC20 compliant token.\\r\\n    /// @dev    _token cannot be governance token address.\\r\\n    function withdrawERC20(address _token) external onlyOwner {\\r\\n        require(_token != governanceToken, \\\"Address cannot be governance token\\\");\\r\\n\\r\\n        uint256 balance = IGogeERC20(_token).balanceOf(address(this));\\r\\n        require(balance > 0, \\\"Insufficient token balance\\\");\\r\\n\\r\\n        require(IGogeERC20(_token).transfer(msg.sender, balance));\\r\\n    }\\r\\n\\r\\n\\r\\n    // NOTE: governanceToken\\r\\n\\r\\n    /// @notice A method for updating team balance.\\r\\n    /// @param  _amount Amount of BNB to add to teamBalance.\\r\\n    /// @dev    Only callable by governanceToken\\r\\n    function updateTeamBalance(uint256 _amount) external onlyGovernanceToken {\\r\\n        unchecked {\\r\\n            teamBalance += _amount;\\r\\n        }\\r\\n        require(address(this).balance >= (teamBalance + marketingBalance), \\\"Insufficient BNB balance in GogeDAO\\\");\\r\\n    }\\r\\n\\r\\n    /// @notice A method for updating marketing balance.\\r\\n    /// @param  _amount Amount of BNB to add to marketingBalanace.\\r\\n    /// @dev    Only callable by governanceToken\\r\\n    function updateMarketingBalance(uint256 _amount) external onlyGovernanceToken {\\r\\n        unchecked {\\r\\n            marketingBalance += _amount;\\r\\n        }\\r\\n        require(address(this).balance >= (teamBalance + marketingBalance), \\\"Insufficient BNB balance in GogeDAO\\\");\\r\\n    }\\r\\n\\r\\n    /// @notice A gatekeeper method for manually passing a poll.\\r\\n    /// @param  _pollNum Unique poll identifier.\\r\\n    /// @dev    Poll must be an active poll and have met quorum.\\r\\n    ///         If gatekeeping is enabled and a poll meets quorum it will stay in limbo\\r\\n    ///         until passed manually by a gatekeeper or it expires and is revoked.\\r\\n    function passPollAsGatekeeper(uint256 _pollNum) external onlyGatekeeper {\\r\\n        require(gatekeeping, \\\"Gatekeeping disabled\\\");\\r\\n        require(block.timestamp < proposals[_pollNum].endTime, \\\"Poll Closed\\\");\\r\\n        require(getProportion(_pollNum) >= quorum, \\\"Poll Quorum not met\\\");\\r\\n\\r\\n        _executeProposal(_pollNum);\\r\\n    }\\r\\n\\r\\n\\r\\n    // --------\\r\\n    // Internal\\r\\n    // --------\\r\\n\\r\\n    /// @notice Internal function for executing a poll.\\r\\n    /// @param _pollNum Unique poll identifier.\\r\\n    function _executeProposal(uint256 _pollNum) internal {\\r\\n\\r\\n        _updateEndTime(_pollNum);\\r\\n        \\r\\n        passed[_pollNum] = true;\\r\\n        PollType _pollType = pollTypes[_pollNum];\\r\\n\\r\\n        if (_pollType == PollType.taxChange) {\\r\\n            Proposal memory taxChange = proposals[_pollNum];\\r\\n            IGogeERC20(governanceToken).updateFees(taxChange.fee1, taxChange.fee2, taxChange.fee3, taxChange.fee4);\\r\\n        }\\r\\n        else if (_pollType == PollType.funding) {\\r\\n            Proposal memory funding = proposals[_pollNum];\\r\\n            require(funding.amount <= marketingBalance, \\\"Insufficient funds\\\");\\r\\n            marketingBalance -= funding.amount;\\r\\n            (bool funded,) = funding.addr.call{value: funding.amount}(\\\"\\\");\\r\\n            require(funded, \\\"Funding unsuccessful\\\");\\r\\n        }\\r\\n        else if (_pollType == PollType.setGogeDao) {\\r\\n            Proposal memory setGogeDao = proposals[_pollNum];\\r\\n            IGogeERC20(governanceToken).setGogeDao(setGogeDao.addr);\\r\\n        }\\r\\n        else if (_pollType == PollType.setCex) {\\r\\n            Proposal memory setCex = proposals[_pollNum];\\r\\n            IGogeERC20(governanceToken).addPartnerOrExchange(setCex.addr);\\r\\n        }\\r\\n        else if (_pollType == PollType.setDex) {\\r\\n            Proposal memory setDex = proposals[_pollNum];\\r\\n            IGogeERC20(governanceToken).setAutomatedMarketMakerPair(setDex.addr, setDex.status);\\r\\n        }\\r\\n        else if (_pollType == PollType.excludeFromCirculatingSupply) {\\r\\n            Proposal memory excludeFromCirculatingSupply = proposals[_pollNum];\\r\\n            IGogeERC20(governanceToken).excludeFromCirculatingSupply(excludeFromCirculatingSupply.addr, excludeFromCirculatingSupply.status);\\r\\n        }\\r\\n        else if (_pollType == PollType.updateDividendToken) {\\r\\n            Proposal memory updateDividendToken = proposals[_pollNum];\\r\\n            IGogeERC20(governanceToken).updateCakeDividendToken(updateDividendToken.addr);\\r\\n        }\\r\\n        else if (_pollType == PollType.updateMarketingWallet) {\\r\\n            Proposal memory updateMarketingWallet = proposals[_pollNum];\\r\\n            IGogeERC20(governanceToken).updateMarketingWallet(updateMarketingWallet.addr);\\r\\n        }\\r\\n        else if (_pollType == PollType.updateTeamWallet) {\\r\\n            Proposal memory updateTeamWallet = proposals[_pollNum];\\r\\n            IGogeERC20(governanceToken).updateTeamWallet(updateTeamWallet.addr);\\r\\n        }\\r\\n        else if (_pollType == PollType.updateTeamMember) {\\r\\n            Proposal memory updateTeamMember = proposals[_pollNum];\\r\\n            _setTeamMember(updateTeamMember.addr, updateTeamMember.status);\\r\\n        }\\r\\n        else if (_pollType == PollType.updateGatekeeper) {\\r\\n            Proposal memory modifyGateKeeper = proposals[_pollNum];\\r\\n            _setGatekeeper(modifyGateKeeper.addr, modifyGateKeeper.status);\\r\\n        }\\r\\n        else if (_pollType == PollType.setGatekeeping) {\\r\\n            Proposal memory modifyGateKeeping = proposals[_pollNum];\\r\\n            _setGatekeeping(modifyGateKeeping.status);\\r\\n        }\\r\\n        else if (_pollType == PollType.setBuyBackEnabled) {\\r\\n            Proposal memory setBuyBackEnabled = proposals[_pollNum];\\r\\n            IGogeERC20(governanceToken).setBuyBackEnabled(setBuyBackEnabled.status);\\r\\n        }\\r\\n        else if (_pollType == PollType.setCakeDividendEnabled) {\\r\\n            Proposal memory setCakeDividendEnabled = proposals[_pollNum];\\r\\n            IGogeERC20(governanceToken).setCakeDividendEnabled(setCakeDividendEnabled.status);\\r\\n        }\\r\\n        else if (_pollType == PollType.setMarketingEnabled) {\\r\\n            Proposal memory setMarketingEnabled = proposals[_pollNum];\\r\\n            IGogeERC20(governanceToken).setMarketingEnabled(setMarketingEnabled.status);\\r\\n        }\\r\\n        else if (_pollType == PollType.setTeamEnabled) {\\r\\n            Proposal memory setTeamEnabled = proposals[_pollNum];\\r\\n            IGogeERC20(governanceToken).setTeamEnabled(setTeamEnabled.status);\\r\\n        }\\r\\n        else if (_pollType == PollType.excludeFromFees) {\\r\\n            Proposal memory excludeFromFees = proposals[_pollNum];\\r\\n            IGogeERC20(governanceToken).excludeFromFees(excludeFromFees.addr, excludeFromFees.status);\\r\\n        }\\r\\n        else if (_pollType == PollType.excludeFromDividends) {\\r\\n            Proposal memory excludeFromDividends = proposals[_pollNum];\\r\\n            IGogeERC20(governanceToken).excludeFromDividend(excludeFromDividends.addr);\\r\\n        }\\r\\n        else if (_pollType == PollType.modifyBlacklist) {\\r\\n            Proposal memory modifyBlacklist = proposals[_pollNum];\\r\\n            IGogeERC20(governanceToken).modifyBlacklist(modifyBlacklist.addr, modifyBlacklist.status);\\r\\n        }\\r\\n        else if (_pollType == PollType.transferOwnership) {\\r\\n            Proposal memory transferOwnership = proposals[_pollNum];\\r\\n            IGogeERC20(governanceToken)._transferOwnership(transferOwnership.addr);\\r\\n        }\\r\\n        else if (_pollType == PollType.setQuorum) {\\r\\n            Proposal memory setQuorum = proposals[_pollNum];\\r\\n            _updateQuorum(uint8(setQuorum.amount));\\r\\n        }\\r\\n        else if (_pollType == PollType.updateMaxPeriod) {\\r\\n            Proposal memory _updateMaxPeriod = proposals[_pollNum];\\r\\n            maxPeriod = _updateMaxPeriod.amount * 1 days;\\r\\n        }\\r\\n        else if (_pollType == PollType.updateMinAuthorBal) {\\r\\n            Proposal memory _updateMinAuthorBal = proposals[_pollNum];\\r\\n            minAuthorBal = _updateMinAuthorBal.amount * 10**18;\\r\\n        }\\r\\n        else if (_pollType == PollType.updateGovernanceToken) {\\r\\n            Proposal memory updateGovernanceToken = proposals[_pollNum];\\r\\n\\r\\n            _removePoll(_pollNum);\\r\\n            _refundVoters(_pollNum);\\r\\n\\r\\n            _setGovernanceToken(updateGovernanceToken.addr);\\r\\n            emit ProposalPassed(_pollNum);\\r\\n\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        // remove poll from active polls and refund voters\\r\\n        _removePoll(_pollNum);\\r\\n        _refundVoters(_pollNum);\\r\\n\\r\\n        emit ProposalPassed(_pollNum);\\r\\n    }\\r\\n\\r\\n    /// @notice Internal method for adding voters to a poll's voter library.\\r\\n    /// @param  _pollNum Unique poll identifier.\\r\\n    /// @param  _voter Address to add to voterLibrary.\\r\\n    function _addToVoterLibrary(uint256 _pollNum, address _voter) internal {\\r\\n        uint256 length = voterLibrary[_pollNum].length;\\r\\n        for (uint256 i; i < length;) {\\r\\n            if (_voter == voterLibrary[_pollNum][i]) {\\r\\n                return;\\r\\n            }\\r\\n            unchecked {\\r\\n                ++i;\\r\\n            }\\r\\n        }\\r\\n        voterLibrary[_pollNum].push(_voter);\\r\\n    }\\r\\n\\r\\n    /// @notice Internal method for adding polls to a voter's advocate array.\\r\\n    /// @param  _pollNum Unique poll identifier.\\r\\n    /// @param  _advocate Address of advocate.\\r\\n    function _addToAdvocateFor(uint256 _pollNum, address _advocate) internal {\\r\\n        uint256 length = advocateFor[_advocate].length;\\r\\n        for (uint256 i; i < length;) {\\r\\n            if (_pollNum == advocateFor[_advocate][i]) {\\r\\n                return;\\r\\n            }\\r\\n            unchecked {\\r\\n                ++i;\\r\\n            }\\r\\n        }\\r\\n        advocateFor[_advocate].push(_pollNum);\\r\\n    }\\r\\n\\r\\n    /// @notice A method for a voter to remove their votes from a single poll.\\r\\n    /// @param  _pollNum Unique poll identifier.\\r\\n    function _removeVote(uint256 _pollNum) internal {\\r\\n        uint256 _numVotes = polls[_pollNum][msg.sender];\\r\\n        if(_numVotes > 0) {\\r\\n            polls[_pollNum][msg.sender] = 0;\\r\\n            pollVotes[_pollNum] -= _numVotes;\\r\\n\\r\\n            _refundVoter(msg.sender, _numVotes);\\r\\n            _removeAdvocate(msg.sender, _pollNum);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice A method for all voters to be refunded after a poll that they've voted on has been passed.\\r\\n    /// @param  _pollNum Unique poll identifier.\\r\\n    function _refundVoters(uint256 _pollNum) internal {\\r\\n        uint256 length = voterLibrary[_pollNum].length;\\r\\n        for (uint256 i = 0; i < length;) {\\r\\n\\r\\n            address voter  = voterLibrary[_pollNum][i];\\r\\n            uint256 amount = polls[_pollNum][voter];\\r\\n\\r\\n            _refundVoter(voter, amount);\\r\\n            _removeAdvocate(voter, _pollNum);\\r\\n            \\r\\n            unchecked {\\r\\n                ++i;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Internal method for transferring governance tokens to a voter.\\r\\n    /// @param  _voter Address of voter to be refunded.\\r\\n    /// @param _amount Amount of tokens to refund voter.\\r\\n    function _refundVoter(address _voter, uint256 _amount) internal {\\r\\n        require(IGogeERC20(governanceToken).transfer(_voter, _amount), \\\"Refund unsuccessful\\\");\\r\\n    }\\r\\n\\r\\n    /// @notice A method for removing polls from an address's advocatesFor mapped array.\\r\\n    /// @param _advocate Address of wallet that is removing advocacy.\\r\\n    /// @param _pollNum Unique poll identifier the address is no longer an advocate for.\\r\\n    function _removeAdvocate(address _advocate, uint256 _pollNum) internal {\\r\\n        uint256 length = advocateFor[_advocate].length;\\r\\n        for (uint256 i; i < length;) {\\r\\n            if (advocateFor[_advocate][i] == _pollNum) {\\r\\n                advocateFor[_advocate][i] = advocateFor[_advocate][--length];\\r\\n                advocateFor[_advocate].pop();\\r\\n                return;\\r\\n            }\\r\\n            unchecked {\\r\\n                ++i;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice An internal method for changing gatekeeping status.\\r\\n    /// @param _enabled Status of gatekeeping.\\r\\n    function _setGatekeeping(bool _enabled) internal {\\r\\n        gatekeeping = _enabled;\\r\\n    }\\r\\n\\r\\n    /// @notice An internal method for adding a team member address to the teamMembers array.\\r\\n    /// @param  _addr Address of team member.\\r\\n    /// @param  _value Is a team member.\\r\\n    function _setTeamMember(address _addr, bool _value) internal {\\r\\n        if (_value) {\\r\\n            (bool _isTeamMember,) = isTeamMember(_addr);\\r\\n            if(!_isTeamMember) teamMembers.push(_addr);\\r\\n        } else {\\r\\n            (bool _isTeamMember, uint8 s) = isTeamMember(_addr);\\r\\n            if(_isTeamMember) {\\r\\n                teamMembers[s] = teamMembers[teamMembers.length - 1];\\r\\n                teamMembers.pop();\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice An internal method for removing a poll from activePolls array.\\r\\n    /// @param _pollNum Unique poll identifier.\\r\\n    function _removePoll(uint256 _pollNum) internal {\\r\\n        uint256 length = activePolls.length;\\r\\n        for (uint256 i; i < length;) {\\r\\n            if (_pollNum == activePolls[i]) {\\r\\n                activePolls[i] = activePolls[--length];\\r\\n                activePolls.pop();\\r\\n                return;\\r\\n            }\\r\\n            unchecked {\\r\\n                ++i;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice An internal method for updating a poll's end timestamp to current block.timestamp.\\r\\n    /// @param  _pollNum Unique poll identifier.\\r\\n    function _updateEndTime(uint256 _pollNum) internal {\\r\\n        proposals[_pollNum].endTime = block.timestamp;\\r\\n    }\\r\\n\\r\\n    /// @notice An internal method for setting the status of a gatekeeper.\\r\\n    /// @param  _addr Address of gatekeeper.\\r\\n    /// @param  _status Is a gatekeeper.\\r\\n    function _setGatekeeper(address _addr, bool _status) internal {\\r\\n        gatekeeper[_addr] = _status;\\r\\n    }\\r\\n\\r\\n    /// @notice An internal method for updating quorum value.\\r\\n    /// @param  _amount Quorum value.\\r\\n    function _updateQuorum(uint8 _amount) internal {\\r\\n        require(_amount <= 100 && _amount > 0, \\\"_amount must be between 0 and 101\\\");\\r\\n        quorum = uint256(_amount);\\r\\n    }\\r\\n\\r\\n    /// @notice An internal method for updating governanceToken.\\r\\n    /// @param  _token New governance token address.\\r\\n    /// @dev _token cannot be the zero address.\\r\\n    function _setGovernanceToken(address _token) internal {\\r\\n        require(_token != address(0));\\r\\n        governanceToken = _token;\\r\\n    }\\r\\n\\r\\n\\r\\n    // ----\\r\\n    // View\\r\\n    // ----\\r\\n\\r\\n    /// @notice A view method for returning a poll's unique metadata.\\r\\n    /// @param _pollNum Unique poll identifier.\\r\\n    function getProposal(uint256 _pollNum) external view returns (Proposal memory) {\\r\\n        return proposals[_pollNum];\\r\\n    }\\r\\n\\r\\n    /// @notice A view method for returning a poll's current proportion of votes over circuating supply.\\r\\n    /// @param _pollNum Unique poll identifier.\\r\\n    function getProportion(uint256 _pollNum) public view returns (uint256) {\\r\\n        return pollVotes[_pollNum] * 100 / IGogeERC20(governanceToken).getCirculatingMinusReserve();\\r\\n    }\\r\\n\\r\\n    /// @notice A view method for returning the amount of active polls an author currently has.\\r\\n    /// @param  _account Address of poll author.\\r\\n    /// @return _num number of polls that are active, by author.\\r\\n    function getActivePollsFromAuthor(address _account) public view returns (uint256 _num) {\\r\\n        uint256 length = activePolls.length;\\r\\n        for (uint256 i = 0; i < length;){\\r\\n            if (pollAuthor[activePolls[i]] == _account) {\\r\\n                unchecked {\\r\\n                    ++_num;\\r\\n                }\\r\\n            }\\r\\n            unchecked {\\r\\n                ++i;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice A view method for returning whether a provided address is a team member.\\r\\n    /// @param  _account Address of potential team member.\\r\\n    /// @return bool Whether or not _account is inside teamMember array.\\r\\n    /// @return uint8 Index in teamMember array in which _account resides.\\r\\n    function isTeamMember(address _account) public view returns(bool, uint8) {\\r\\n        uint256 length = teamMembers.length;\\r\\n        for (uint8 i; i < length;){\\r\\n            if (_account == teamMembers[i]) {\\r\\n                return (true, i);\\r\\n            }\\r\\n            unchecked {\\r\\n                ++i;\\r\\n            }\\r\\n        }\\r\\n        return (false, 0);\\r\\n    }\\r\\n\\r\\n    /// @notice Returns activePolls array.\\r\\n    function getActivePolls() external view returns (uint256[] memory) {\\r\\n        return activePolls;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the voter array given a pollNum.\\r\\n    /// @param _pollNum Unique poll identifier.\\r\\n    function getVoterLibrary(uint256 _pollNum) external view returns (address[] memory) {\\r\\n        return voterLibrary[_pollNum];\\r\\n    }\\r\\n\\r\\n    /// @notice Returns an array of pollNum from advocateFor given _advocate.\\r\\n    /// @param _advocate Address to retrieve advocated polls for.\\r\\n    function getAdvocateFor(address _advocate) external view returns (uint256[] memory) {\\r\\n        return advocateFor[_advocate];\\r\\n    }\\r\\n\\r\\n    /// @notice Returns an array of address of all team members.\\r\\n    function getTeamMembers() external view returns (address[] memory) {\\r\\n        return teamMembers;\\r\\n    }\\r\\n    \\r\\n}\"\r\n    },\r\n    \"src/extensions/Owned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\n/// @notice Simple single owner authorization mixin that follows the EIP-173 standard.\\r\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\\r\\nabstract contract Owned {\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                                 EVENTS\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                            OWNERSHIP STORAGE\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    address public owner;\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                               CONSTRUCTOR\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    constructor(address _owner) {\\r\\n        owner = _owner;\\r\\n\\r\\n        emit OwnershipTransferred(address(0), _owner);\\r\\n    }\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                             OWNERSHIP LOGIC\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"ZERO ADDRESS\\\");\\r\\n\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        owner = newOwner;\\r\\n\\r\\n        emit OwnershipTransferred(msg.sender, newOwner); \\r\\n    }\\r\\n\\r\\n    function _onlyOwner() internal view virtual {\\r\\n        require(msg.sender == owner, \\\"UNAUTHORIZED\\\");\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        _onlyOwner();\\r\\n        _;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"src/interfaces/IGogeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\ninterface IGogeERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n    function getCirculatingMinusReserve() external view returns (uint256);\\r\\n    function getLastReceived(address voter) external view returns (uint256);\\r\\n    function updateFees(uint8 _rewardFee, uint8 _marketingFee, uint8 _buybackFee, uint8 _teamFee) external;\\r\\n    function setGogeDao(address _dao) external;\\r\\n    function whitelistPinkSale(address _presaleAddress) external;\\r\\n    function addPartnerOrExchange(address _partnerOrExchangeAddress) external;\\r\\n    function updateCakeDividendToken(address _newContract) external;\\r\\n    function updateTeamWallet(address _newWallet) external;\\r\\n    function updateMarketingWallet(address _newWallet) external;\\r\\n    function setSwapTokensAtAmount(uint256 _swapAmount) external;\\r\\n    function setBuyBackEnabled(bool _enabled) external;\\r\\n    function setCakeDividendEnabled(bool _enabled) external;\\r\\n    function setMarketingEnabled(bool _enabled) external;\\r\\n    function setTeamEnabled(bool _enabled) external;\\r\\n    function updateCakeDividendTracker(address newAddress) external;\\r\\n    function updateUniswapV2Router(address newAddress) external;\\r\\n    function excludeFromFees(address account, bool excluded) external;\\r\\n    function isExcludedFromFees(address account) external returns (bool);\\r\\n    function excludeFromDividend(address account) external;\\r\\n    function setAutomatedMarketMakerPair(address pair, bool value) external;\\r\\n    function excludeFromCirculatingSupply(address account, bool excluded) external;\\r\\n    function updateGasForProcessing(uint256 newValue) external;\\r\\n    function updateMinimumBalanceForDividends(uint256 newMinimumBalance) external;\\r\\n    function processDividendTracker() external;\\r\\n    function modifyBlacklist(address account, bool blacklisted) external;\\r\\n    function updatePairSwapped(bool swapped) external;   \\r\\n    function _transferOwnership(address newOwner) external;\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governanceToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pollNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum GogeDAO.PollType\",\"name\":\"pollType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"ProposalCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pollNum\",\"type\":\"uint256\"}],\"name\":\"ProposalPassed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"activePolls\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pollNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_numVotes\",\"type\":\"uint256\"}],\"name\":\"addVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"advocateFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum GogeDAO.PollType\",\"name\":\"_pollType\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"fee1\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"fee2\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"fee3\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"fee4\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"internalType\":\"struct GogeDAO.Proposal\",\"name\":\"_change\",\"type\":\"tuple\"}],\"name\":\"createPoll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createPollEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pollNum\",\"type\":\"uint256\"}],\"name\":\"endPoll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"gatekeeper\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gatekeeping\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getActivePolls\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getActivePollsFromAuthor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_num\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_advocate\",\"type\":\"address\"}],\"name\":\"getAdvocateFor\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pollNum\",\"type\":\"uint256\"}],\"name\":\"getProportion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pollNum\",\"type\":\"uint256\"}],\"name\":\"getProposal\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"fee1\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"fee2\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"fee3\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"fee4\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"internalType\":\"struct GogeDAO.Proposal\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTeamMembers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pollNum\",\"type\":\"uint256\"}],\"name\":\"getVoterLibrary\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governanceToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isTeamMember\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxPollsPerAuthor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minAuthorBal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pollNum\",\"type\":\"uint256\"}],\"name\":\"passPoll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pollNum\",\"type\":\"uint256\"}],\"name\":\"passPollAsGatekeeper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"passed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"payTeam\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pollAuthor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pollNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pollTypes\",\"outputs\":[{\"internalType\":\"enum GogeDAO.PollType\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pollVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"polls\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"fee1\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"fee2\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"fee3\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"fee4\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"queryEndTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"quorum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeAllVotes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pollNum\",\"type\":\"uint256\"}],\"name\":\"removeVotesFromPoll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setGatekeeping\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setGovernanceToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isMember\",\"type\":\"bool\"}],\"name\":\"setTeamMember\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"teamMembers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleCreatePollEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gatekeeper\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"updateGatekeeper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"updateMarketingBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_amountOfDays\",\"type\":\"uint8\"}],\"name\":\"updateMaxPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_limit\",\"type\":\"uint8\"}],\"name\":\"updateMaxPollsPerAuthor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"updateMinAuthorBal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_amountOfDays\",\"type\":\"uint8\"}],\"name\":\"updateMinPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_amount\",\"type\":\"uint8\"}],\"name\":\"updateQuorum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"updateTeamBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"voterLibrary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"withdrawERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "GogeDAO", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000040079f576625b764e191af9c38ecb2e19d69b675", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}