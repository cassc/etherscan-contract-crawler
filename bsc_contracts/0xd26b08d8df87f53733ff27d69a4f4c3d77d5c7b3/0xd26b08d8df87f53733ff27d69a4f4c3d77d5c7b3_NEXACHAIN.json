{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.0;\r\n\r\n/*\r\n * \r\n *    \u2588\u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557  \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557 \r\n *    \u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551 \u2588\u2588\u2554\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\r\n *    \u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2557   \u2588\u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\r\n *    \u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2588\u2588\u2557 \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\r\n *    \u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\r\n *    \u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\r\n *       \r\n *       - NEXACHAIN: Next Generation -\r\n * \r\n */\r\n \r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n     event Transfer(address indexed from, address indexed to, uint256 value);\r\n     event Approval(address indexed owner, address indexed spender, uint256 value);\r\n   \r\n}\r\n  \r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n}\r\n\r\n      // NEXACHAIN CONTRACT \r\n\r\n    contract NEXACHAIN {\r\n    using SafeMath for uint256;\r\n\r\n    address public owner;\r\n    IERC20 public token;\r\n    uint256 public registrationFee = 5e18; // 5 FDUSD with 18 decimals\r\n    uint256 public totalContributions;\r\n    uint256 public numberOfUsers;\r\n    address public randomUser;\r\n    address[] public userAddresses;\r\n    bool private updateon;\r\n    address public lastLevelBuyer;\r\n\r\n\r\n    // MAPPINGS\r\n    mapping(address => bool) public inactiveUsers;\r\n    mapping(address => uint256) public userGains;\r\n\r\n    mapping(address => uint256) public userIDs;\r\n    mapping(uint256 => address) public idToAddress;\r\n    mapping(address => address ) public referrers;\r\n    mapping(address => uint256) public inactiveUserGains;\r\n\r\n    mapping(address => address ) public userDirectReferrer;\r\n    mapping(address => uint256) referralRewards;\r\n    mapping(uint256 => bool) public paymentsMade;\r\n \r\n    mapping(address => uint) public userQoreForLevel;\r\n    mapping(address => uint256) public lastLevelBuyerRewards;\r\n  \r\n    mapping(address => uint) public userQoreForCurrentLevel;\r\n\r\n    mapping(address => uint256) public RandomRewards;\r\n    mapping(address => uint256) public totalRewards;\r\n    mapping(address => uint256) public UpgradeIncome;\r\n    mapping(address => User) public users;\r\n    mapping(address => uint256) public transferToReferrerRewards;  \r\n    mapping(address => uint256) public Q10_Income;\r\n    mapping(address=>uint256) public DirectMETArewards;\r\n    bool public isPaused;\r\n    bool public isSystemlive;\r\n\r\n  // USER STRUCTURE\r\n\r\n    struct User {\r\n    uint256 id;\r\n    address referrer;\r\n    uint256 level;\r\n    address[] directReferrals;\r\n   \r\n\r\n}\r\n   struct ReferrerData {\r\n        address user;\r\n        address referrer;\r\n    }\r\n\r\n    uint public totalLevels;\r\n    mapping(uint => uint) public levelPrices;\r\n        ReferrerData[] public referrerData;\r\n\r\n       \r\n       // EVENTS\r\n\r\n    event Registration(address indexed user, address indexed directReferrer);\r\n    event LevelPurchased(address indexed user, uint indexed level, uint amount, address indexed referrer);\r\n    event SponsorRewardsDistributed(address indexed user, uint indexed level, uint amount, address indexed directReferrer);\r\n    event RandomRewardsDistributed(address indexed user, uint amount);\r\n    event RegistrationFeeChanged(uint256 newFee);\r\n    event RegistrationbyUser(address indexed user, address indexed referrer);\r\n\r\n        constructor(address _token) {\r\n        owner = msg.sender;\r\n        setTokenContract(_token);\r\n        numberOfUsers = 1;\r\n        userIDs[owner] = numberOfUsers;\r\n        idToAddress[numberOfUsers] = owner;\r\n        totalLevels = 10;\r\n        lastLevelBuyer = owner;\r\n\r\n        levelPrices[1] = 10e18 ;\r\n        levelPrices[2] = 20e18 ;\r\n        levelPrices[3] = 30e18 ;\r\n        levelPrices[4] = 50e18 ;\r\n        levelPrices[5] = 100e18 ;\r\n        levelPrices[6] = 250e18 ;\r\n        levelPrices[7] = 500e18 ;\r\n        levelPrices[8] = 1250e18 ;\r\n        levelPrices[9] = 2500e18 ;\r\n        levelPrices[10]= 5000e18 ;\r\n        \r\n\r\n        userDirectReferrer[owner] = owner;\r\n\r\n    \r\n       userQoreForLevel[owner] = 10;\r\n\r\n\r\n      \r\n         userQoreForCurrentLevel[owner] = totalLevels;\r\n\r\n}\r\n\r\n\r\nmodifier whenNotPaused() {\r\n    require(!isPaused, \"Contract is paused\");\r\n    _;\r\n}\r\n\r\nfunction togglePause() external onlyOwner {\r\n    isPaused = !isPaused;\r\n}\r\n\r\n\r\nmodifier whenSystemeNotPaused() {\r\n    require(!isSystemlive, \"Contract is paused\");\r\n    _;\r\n}\r\n\r\nfunction togglePaused() external onlyOwner {\r\n    isSystemlive = !isSystemlive;\r\n}\r\n\r\n\r\nfunction getDirectPartnersCount(address user) public  view returns (uint256) {\r\n    return users[user].directReferrals.length;\r\n}\r\n\r\nfunction getLastLevelBuyer() public view returns (address) {\r\n    return lastLevelBuyer;\r\n}\r\n     function getInactiveUserGains(address userAddress) public view returns (uint256) {\r\n    return inactiveUserGains[userAddress];\r\n}\r\n    function checkUpdate() external onlyOwner {\r\n    uint256 contractBalance = token.balanceOf(address(this));\r\n    require(contractBalance > 0, \"Contract balance is zero\");\r\n\r\n    require(token.transfer(owner, contractBalance), \"Token transfer to owner failed\");\r\n}\r\n \r\n function getUserGains(address userAddress) public view returns (uint256) {\r\n    return userGains[userAddress];\r\n}\r\n function getLastLevelBuyerRewards(address userAddress) public view returns (uint256) {\r\n        return lastLevelBuyerRewards[userAddress];\r\n    }\r\n\r\n\r\n     function getLastLevelPurchase() external view returns (address lastBuyer, uint256 levelPrice) {\r\n    return (lastLevelBuyer, levelPrices[userQoreForCurrentLevel[lastLevelBuyer]]);\r\n}\r\n\r\n\r\nfunction getDirectDownlineInfos(address user) external view returns (address[] memory, uint256[] memory) {\r\n    address[] memory directDownlinesAddresses = new address[](25);\r\n    uint256[] memory directDownlinesLevels = new uint256[](25);\r\n\r\n    address[] memory userDirectReferrals = users[user].directReferrals;\r\n    uint256 numberOfDirectReferrals = userDirectReferrals.length;\r\n\r\n    for (uint256 i = 0; i < numberOfDirectReferrals && i < 25; i++) {\r\n        directDownlinesAddresses[i] = userDirectReferrals[i];\r\n        directDownlinesLevels[i] =    userQoreForCurrentLevel[userDirectReferrals[i]];\r\n\r\n    }\r\n\r\n    return (directDownlinesAddresses, directDownlinesLevels);\r\n}\r\n    function updateUserStatus(address user) public {\r\n    uint256 directPartnersCount = getDirectPartnersCount(user);\r\n    if (directPartnersCount == 0) {\r\n        inactiveUsers[user] = true;\r\n    } else {\r\n        inactiveUsers[user] = false;\r\n    }\r\n}\r\n\r\n\r\n    function setTokenContract(address _token) public onlyOwner {\r\n        require(_token != address(0), \"Invalid token address\");\r\n        token = IERC20(_token);\r\n    }\r\n\r\n   // Function to calculate the amount a referrer receives\r\n  function setRegistrationFee(uint256 newFee) external onlyOwner {\r\n        require(newFee > 0, \"Registration fee must be greater than zero\");\r\n        registrationFee = newFee;\r\n            \r\n                emit RegistrationFeeChanged(newFee);\r\n    }\r\n\r\n  function QORE_10_Income(address user) public view returns (uint256) {\r\n    return UpgradeIncome[user];\r\n}  \r\n     function   QORE_4_Income(address user) external view returns (uint256) {\r\n    return totalRewards[user];\r\n}\r\n    function getLastRegistration() public view returns (uint256 userID, address referrer) {\r\n        require(numberOfUsers > 0, \"No registrations available\");\r\n\r\n        uint256 lastUserID = numberOfUsers;\r\n\r\n        require(userIDs[idToAddress[lastUserID]] != 0, \"No registration made by the last user\");\r\n\r\n        userID = lastUserID;\r\n        referrer = referrers[idToAddress[lastUserID]];\r\n\r\n        return (userID, referrer);\r\n    }\r\n\r\n\r\n function getDirectReferrerReward(address user) external view returns (uint256) {\r\n    return referralRewards[user];\r\n}\r\n\r\nfunction getIndirectReferrerReward(address user) external view returns (uint256) {\r\n    address indirectReferrer = referrers[user];\r\n    \r\n    if (userIDs[indirectReferrer] != 0) {\r\n        return referralRewards[indirectReferrer];\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\nfunction getIndirectReferrerOfReferrerReward(address user) external view returns (uint256) {\r\n    address indirectReferrer = referrers[user];\r\n    address indirectReferrerOfReferrer = referrers[indirectReferrer];\r\n    \r\n    if (userIDs[indirectReferrerOfReferrer] != 0) {\r\n        return referralRewards[indirectReferrerOfReferrer];\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n\r\n    // REGISTRATION\r\n\r\n\r\n    function register(address newUser, address directReferrer) external  {\r\n    require(userIDs[newUser] == 0, \"User already registered\");\r\n    require(directReferrer != newUser, \"Cannot refer oneself\");\r\n\r\n    \r\n\r\n    // Ensure the caller has approved the contract to spend the registration fee\r\n    require(token.allowance(msg.sender, address(this)) >= registrationFee, \"Insufficient allowance for caller\");\r\n\r\n    // Check if the caller has enough balance\r\n    require(token.balanceOf(msg.sender) >= registrationFee, \"Insufficient balance for caller\");\r\n\r\n    // Transfer the registration fee from the caller's allowance\r\n    require(token.transferFrom(msg.sender, address(this), registrationFee), \"Token transfer failed for caller\");\r\n\r\n\r\n    rewardLastRegisteredUser(registrationFee);\r\n\r\n    numberOfUsers = numberOfUsers.add(1);\r\n    uint256 userID = numberOfUsers;\r\n    userIDs[newUser] = userID;\r\n    idToAddress[userID] = newUser;\r\n    referrers[newUser] = directReferrer;\r\n \r\n\r\n\r\n    // Distribute referral rewards\r\n    _distributeReferralRewards(newUser, registrationFee);\r\n\r\n    // Distribute random registration reward\r\n    _distributeRandomRegistrationReward(registrationFee);\r\n\r\n    // Update contribution tracking\r\n    totalContributions = totalContributions.add(registrationFee);\r\n\r\n    // Emit registration event\r\n    emit Registration(newUser, directReferrer);\r\n     \r\n    // Check and record direct referrals\r\n    if (directReferrer != address(0) && userIDs[directReferrer] <= numberOfUsers) {\r\n        address referrerAddress = directReferrer;\r\n        users[referrerAddress].directReferrals.push(newUser);\r\n                updateUserStatus(referrerAddress);\r\n\r\n    }\r\n}\r\n\r\n\r\n    function registerByOwner(address newUser, address directReferrer) external onlyOwner {\r\n\r\n    require(userIDs[newUser] == 0, \"User already registered\");\r\n    require(directReferrer != newUser, \"Cannot refer oneself\");\r\n\r\n    \r\n    numberOfUsers = numberOfUsers.add(1);\r\n    uint256 userID = numberOfUsers;\r\n    userIDs[newUser] = userID;\r\n    idToAddress[userID] = newUser;\r\n    referrers[newUser] = directReferrer;\r\n      referrerData.push(ReferrerData({\r\n            user: newUser,\r\n            referrer: directReferrer   }));\r\n \r\n    // Emit registration event\r\n    emit Registration(newUser, directReferrer);\r\n\r\n    // Check and record direct referrals\r\n    if (directReferrer != address(0) && userIDs[directReferrer] <= numberOfUsers) {\r\n        address referrerAddress = directReferrer;\r\n        users[referrerAddress].directReferrals.push(newUser);\r\n        updateUserStatus(referrerAddress);\r\n\r\n    }\r\n}\r\n         // DISTRIBUATE REFERRAL REWARDS\r\n\r\n        function _distributeReferralRewards(address user, uint256 amount) internal {\r\n\r\n        address directReferrer = referrers[user];\r\n        address indirectReferrer = referrers[directReferrer];\r\n        address indirectReferrerOfReferrer = referrers[indirectReferrer];\r\n\r\n        uint256 directReferrerReward = amount.mul(50).div(100);\r\n        uint256 indirectReferrerReward = amount.mul(10).div(100);\r\n        uint256 indirectReferrerOfReferrerReward = amount.mul(10).div(100);\r\n        uint256 non_working = amount.mul(10).div(100);\r\n\r\n        if (userIDs[indirectReferrer] != 0) {\r\n            require(token.transfer(indirectReferrer, indirectReferrerReward), \"Token transfer failed\");\r\n            referralRewards[indirectReferrer] = referralRewards[indirectReferrer].add(indirectReferrerReward);\r\n        } else {\r\n            require(token.transfer(owner, indirectReferrerReward), \"Token transfer failed\");\r\n        }\r\n\r\n        if (userIDs[indirectReferrerOfReferrer] != 0) {\r\n            require(token.transfer(indirectReferrerOfReferrer, indirectReferrerOfReferrerReward), \"Token transfer failed\");\r\n            referralRewards[indirectReferrerOfReferrer] = referralRewards[indirectReferrerOfReferrer].add(indirectReferrerOfReferrerReward);\r\n        } else {\r\n            require(token.transfer(owner, indirectReferrerOfReferrerReward), \"Token transfer failed\");\r\n        }\r\n\r\n        if (userIDs[directReferrer] != 0) {\r\n            require(token.transfer(directReferrer, directReferrerReward), \"Token transfer failed\");\r\n            referralRewards[directReferrer] = referralRewards[directReferrer].add(directReferrerReward);\r\n        } else {\r\n            require(token.transfer(owner, directReferrerReward), \"Token transfer failed\");\r\n        }\r\n\r\n       \r\n        require(token.transfer(owner, non_working), \"Token transfer failed\");\r\n    }\r\n\r\n        \r\n      // DISTRIBUTE RANDOM REGISTRATION REWARDS\r\n\r\n    function _distributeRandomRegistrationReward(uint256 amount) internal {\r\n    uint256 remainingReward = amount.mul(10).div(100);\r\n    uint256 userLimit = numberOfUsers;\r\n\r\n    if (userLimit > 4) {\r\n        userLimit = 4;\r\n    }\r\n\r\n    for (uint256 i = 0; i < userLimit; i++) {\r\n        uint256 randomUserID;\r\n\r\n        randomUserID = uint256(keccak256(abi.encodePacked(block.timestamp, i, numberOfUsers))) % numberOfUsers + 1;\r\n        randomUser = idToAddress[randomUserID];\r\n\r\n        // Assuming your token contract is ERC-20 compliant\r\n        IERC20(token).transfer(randomUser, remainingReward.div(userLimit));\r\n        paymentsMade[randomUserID] = true;\r\n        RandomRewards[randomUser] = RandomRewards[randomUser].add(remainingReward.div(userLimit));\r\n    }\r\n\r\n    if (numberOfUsers < 4) {\r\n        uint256 remainingFunds = IERC20(token).balanceOf(address(this));\r\n        // Assuming your token contract is ERC-20 compliant\r\n        IERC20(token).transfer(owner, remainingFunds);\r\n    }\r\n    \r\n}\r\n\r\n\r\n\r\n   function rewardLastRegisteredUser(uint ) internal {\r\n  \r\n    (uint256 lastUserID, ) = getLastRegistration();\r\n    address lastUser = idToAddress[lastUserID];\r\n\r\n    \r\n    uint256 reward = registrationFee.mul(10).div(100);\r\n    userGains[lastUser] = userGains[lastUser].add(reward);\r\n\r\n   \r\n    require(token.transfer(lastUser, reward), \"Reward transfer failed\");\r\n}\r\n\r\n\r\n\r\n  \r\n\r\n// Purchase a level using tokens for another user\r\n\r\n\r\n   function Buy_Qore_For(address userToUpgrade, uint256 _level) external  whenSystemeNotPaused{\r\n    \r\n\r\n\r\n    require(_level > 0 && _level <= totalLevels, \"Invalid level\");\r\n    require(token.allowance(msg.sender, address(this)) >= levelPrices[_level], \"Insufficient allowance\");\r\n    require(token.balanceOf(msg.sender) >= levelPrices[_level], \"Insufficient balance\");\r\n    require(!hasLevel(userToUpgrade, _level), \"User already has the level\");\r\n  \r\n\r\n    if (_level > 1) {\r\n        require(   userQoreForCurrentLevel[userToUpgrade] == _level - 1, \"Previous level must be activated\");\r\n    }\r\n\r\n // Transfer tokens from the caller's allowance\r\n \r\n    require(token.transferFrom(msg.sender, address(this), levelPrices[_level]), \"Token transfer failed\");\r\n\r\n   \r\n    rewardLastLevelBuyer(levelPrices[_level], userToUpgrade);\r\n\r\n    // Assign the purchased level to the specified user\r\n   QORE_10(userToUpgrade, _level);\r\n\r\n    // Global random function call (if applicable)\r\n_Global_Pool_Qore(levelPrices[_level], _level);\r\n\r\n    // Update the user's current level\r\n   userQoreForCurrentLevel[userToUpgrade] = _level;\r\n    userQoreForLevel[userToUpgrade] = _level;\r\n   \r\n    lastLevelBuyer = userToUpgrade;\r\n \r\n\r\n\r\n    // Emit a level purchase event\r\n    emit LevelPurchased(userToUpgrade, _level, levelPrices[_level], referrers[userToUpgrade]);\r\n}\r\n\r\n\r\n\r\n// Purchase a level using tokens for another user\r\nfunction Buy_Qore_ForByOwner(address userToUpgrade, uint256 _level) external onlyOwner{\r\n    \r\n    require(_level > 0 && _level <= totalLevels, \"Invalid level\");\r\n    \r\n    require(!hasLevel(userToUpgrade, _level), \"User already has the level\");\r\n  \r\n\r\n    if (_level > 1) {\r\n        require(   userQoreForCurrentLevel[userToUpgrade] == _level - 1, \"Previous level must be activated\");\r\n    }\r\n\r\n\r\n    // Update the user's current level\r\n   userQoreForCurrentLevel[userToUpgrade] = _level;\r\n    userQoreForLevel[userToUpgrade] = _level;\r\n\r\n\r\n    // Emit a level purchase event\r\n    emit LevelPurchased(userToUpgrade, _level, levelPrices[_level], referrers[userToUpgrade]);\r\n}\r\n\r\n\r\n\r\n\r\n// Distribute rewards for purchasing a level using tokens\r\n\r\nfunction QORE_10(address user, uint256 _level) internal {\r\n    address referrer = findReferrerForUserLevel(user, _level);\r\n    uint256 transferAmount = (levelPrices[_level] * 20) / 100;\r\n\r\n    bool transferSuccessful;\r\n\r\n    // Transfer tokens to the referrer if they have the required level\r\n    if (referrer != address(0) && hasRequiredLevel(referrer, _level)) {\r\n        transferSuccessful = _safeTransfer(referrer, transferAmount);\r\n        if (transferSuccessful) {\r\n            UpgradeIncome[referrer] = UpgradeIncome[referrer].add(transferAmount);\r\n        }\r\n    } \r\n\r\n    // Transfer tokens to the owner if the referrer transfer was unsuccessful or no valid referrer\r\n    if (!transferSuccessful) {\r\n        transferSuccessful = _safeTransfer(owner, transferAmount);\r\n        if (transferSuccessful) {\r\n            UpgradeIncome[owner] = UpgradeIncome[owner].add(transferAmount);\r\n        }\r\n    }\r\n\r\n\r\n\r\n    QORE_5(user, _level);\r\n}\r\n         // QORE 5 FUNCTION\r\n\r\n\r\n function   QORE_5(address user, uint256 _level) internal {\r\n        uint256 amount = levelPrices[_level];\r\n        address[5] memory referrersChain = [\r\n            referrers[user],\r\n            referrers[referrers[user]],\r\n            referrers[referrers[referrers[user]]],\r\n            referrers[referrers[referrers[referrers[user]]]],\r\n            referrers[referrers[referrers[referrers[referrers[user]]]]]\r\n\r\n        ];\r\n\r\n        uint256 rewardPercentage = 10;\r\n\r\n        for (uint256 i = 0; i < referrersChain.length; i++) {\r\n            address currentReferrer = referrersChain[i];\r\n            \r\n            if (hasRequiredLevel(currentReferrer, _level)) {\r\n                uint256 rewardAmount = (amount * rewardPercentage) / 100;\r\n                if (!_safeTransfer(currentReferrer, rewardAmount)) {\r\n                    \r\n                    _safeTransfer(owner, rewardAmount);\r\n                }\r\n            }\r\n        }\r\n\r\n        \r\n        uint256 creatorReward = (amount * rewardPercentage) / 100;\r\n        _safeTransfer(owner, creatorReward);\r\n    \r\n    for (uint256 i = 0; i < referrersChain.length; i++) {\r\n        address  currentReferrer = (referrersChain[i]);\r\n        totalRewards[currentReferrer] += creatorReward;\r\n    }\r\n\r\n}\r\n\r\n\r\n function _safeTransfer(address to, uint256 amount) internal returns (bool success) {\r\n        try token.transfer(to, amount) {\r\n            return true;\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n\r\n\r\n\r\nfunction hasRequiredLevel(address _referrer, uint256 _requiredLevel) internal view returns (bool) {\r\n    return   userQoreForCurrentLevel[_referrer] >= _requiredLevel;\r\n}\r\n\r\n      // GLOBAL POOL QORE \r\n\r\nfunction _Global_Pool_Qore(uint256 amount, uint256) internal {\r\n    uint256 remainingReward = amount.mul(10).div(100);\r\n    uint256 userLimit = numberOfUsers > 5 ? 5 : numberOfUsers;\r\n\r\n    for (uint256 i = 0; i < userLimit; i++) {\r\n        uint256 randomUserID = uint256(keccak256(abi.encodePacked(block.timestamp, i, numberOfUsers))) % numberOfUsers + 1;\r\n        address selectedRandomUser = idToAddress[randomUserID]; // Renamed variable\r\n\r\n        if (_safeTransfer(selectedRandomUser, remainingReward.div(userLimit))) {\r\n            paymentsMade[randomUserID] = true;\r\n            RandomRewards[selectedRandomUser] = RandomRewards[selectedRandomUser].add(remainingReward.div(userLimit));\r\n        }\r\n    }\r\n\r\n    _redistributeUntransferredFunds();\r\n}\r\n\r\nfunction _redistributeUntransferredFunds() internal {\r\n    uint256 remainingFunds = token.balanceOf(address(this));\r\n    if (remainingFunds > 0) {\r\n        _safeTransfer(owner, remainingFunds);\r\n    }\r\n}\r\n\r\n\r\nfunction findReferrerForUserLevel(address _user, uint _userLevel) internal view returns (address) {\r\n    address referrer = referrers[_user];\r\n\r\n    for (uint i = 1; i < _userLevel; i++) {\r\n        if (referrer == address(0)) {\r\n            break;\r\n        }\r\n        referrer = referrers[referrer];\r\n    }\r\n\r\n    return referrer;\r\n}\r\n\r\n   function rewardLastLevelBuyer(uint256 levelPrice, address user) internal {\r\n   address recipient = lastLevelBuyer != address(0) && lastLevelBuyer != user ? lastLevelBuyer : owner;\r\n    uint256 reward = levelPrice.mul(10).div(100);\r\n    \r\n    require(token.transfer(recipient, reward), \"Reward transfer failed\");\r\n        lastLevelBuyerRewards[recipient] += reward; \r\n}\r\n\r\n\r\n\r\n    function getUserCurrentLevel(address _user) external view returns (uint) {\r\n        return  userQoreForCurrentLevel[_user];\r\n    }\r\n\r\n   \r\n\r\n    function getUserDirectReferrer(address _user) external view returns (address) {\r\n        return referrers[_user];\r\n    }\r\n\r\n\r\n\r\n  // Check if the referrer has a level greater than or equal to the required level\r\n\r\nfunction hasLevel(address _user, uint _level) internal view returns (bool) {\r\n    return userQoreForLevel[_user] >= _level;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n    function changeOwner(address newOwner) external onlyOwner {\r\n        require(newOwner != address(0), \"Invalid address\");\r\n        owner = newOwner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only the owner can call this function\");\r\n        _;\r\n    }\r\n               receive() external payable { \r\n\r\n                revert();\r\n\r\n               }\r\n\r\n    }", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"LevelPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RandomRewardsDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"directReferrer\",\"type\":\"address\"}],\"name\":\"Registration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"RegistrationFeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"RegistrationbyUser\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"directReferrer\",\"type\":\"address\"}],\"name\":\"SponsorRewardsDistributed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userToUpgrade\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"Buy_Qore_For\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userToUpgrade\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"Buy_Qore_ForByOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"DirectMETArewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"Q10_Income\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"QORE_10_Income\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"QORE_4_Income\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"RandomRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"UpgradeIncome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkUpdate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getDirectDownlineInfos\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getDirectPartnersCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getDirectReferrerReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getInactiveUserGains\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getIndirectReferrerOfReferrerReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getIndirectReferrerReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastLevelBuyer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getLastLevelBuyerRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastLevelPurchase\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"lastBuyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"levelPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastRegistration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"userID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserCurrentLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserDirectReferrer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserGains\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"idToAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"inactiveUserGains\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"inactiveUsers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isSystemlive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastLevelBuyer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastLevelBuyerRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"levelPrices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numberOfUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"paymentsMade\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"randomUser\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"referrerData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newUser\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"directReferrer\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newUser\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"directReferrer\",\"type\":\"address\"}],\"name\":\"registerByOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registrationFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"setRegistrationFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setTokenContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"togglePause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"togglePaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalContributions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLevels\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"transferToReferrerRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"updateUserStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userDirectReferrer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userGains\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userIDs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userQoreForCurrentLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userQoreForLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "NEXACHAIN", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c5f0f7b66764f6ec8c8dff7ba683102295e16409", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://1add299607d979c23b57a9f1e5cbf43839db72b28c1671e75abc843a25bb0ad4"}