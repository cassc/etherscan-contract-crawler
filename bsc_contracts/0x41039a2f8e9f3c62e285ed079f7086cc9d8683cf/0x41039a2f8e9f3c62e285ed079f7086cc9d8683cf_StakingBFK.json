{"SourceCode": "// Sources flattened with hardhat v2.11.2 https://hardhat.org\r\n\r\n// File @openzeppelin/contracts/utils/Context.sol@v4.7.3\r\n\r\n// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/access/Ownable.sol@v4.7.3\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/security/ReentrancyGuard.sol@v4.7.3\r\n\r\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.7.3\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n\r\n// File contracts/BNBContract/StakingBFK.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\ncontract StakingBFK is ReentrancyGuard, Ownable {\r\n    struct Staking {\r\n        uint256 amount;\r\n        uint256 lockFrom;\r\n        uint256 lockTo;\r\n    }\r\n\r\n    struct Apr {\r\n        uint256 rate;\r\n        uint256 changedAt;\r\n    }\r\n\r\n    uint256 private daysSlotOne = 15;\r\n    uint256 private daysSlotTwo = 45;\r\n    uint256 private daysSlotThree = 90;\r\n    uint256 private feeBeforeLockingPeriodOver = 5000;\r\n    uint256 private feeAfterLockingPeriodOver = 400;\r\n    uint256 private constant PERCENTAGE_DENOMINATOR = 10000;\r\n    uint256 private constant YEAR_IN_SECONDS = 365 days; \r\n\r\n    uint256 public totalUsersAmount;\r\n    address private adminWallet;\r\n    IERC20 private token;\r\n\r\n    mapping(uint256 => Apr[]) private aprHistory;\r\n    mapping(address => Staking) private stakeHolders;\r\n\r\n    event Stake(\r\n        address user,\r\n        uint256 amount,\r\n        uint256 totalDays,\r\n        uint256 timestamp\r\n    );\r\n    event Unstake(address user, uint256 amount, uint256 timestamp);\r\n    event ChangeAPR(uint256 newApr, uint256 daysSlot);\r\n    event ChangeWithdrawBeforeLockingFee(uint256 oldFee, uint256 newFee);\r\n    event ChangeWithdrawAfterLockingFee(uint256 oldFee, uint256 newFee);\r\n    event ChangeStakingPeriod(uint256 oldDays, uint256 newDays);\r\n\r\n    constructor(address _adminWallet, IERC20 _token) {\r\n        require(_adminWallet != address(0), \"Invalid admin address!\");\r\n        require(address(_token) != address(0), \"Invalid token address\");\r\n        token = _token;\r\n        adminWallet = _adminWallet;\r\n\r\n        aprHistory[daysSlotOne].push(Apr(1100, block.timestamp));\r\n        aprHistory[daysSlotTwo].push(Apr(4320, block.timestamp));\r\n        aprHistory[daysSlotThree].push(Apr(10000, block.timestamp));\r\n    }\r\n\r\n    /**\r\n        @notice Owner can change the APR percentage\r\n        by the giving new value as an input. \r\n        */\r\n    function setAprInterest(uint256 _newApr, uint256 _daysSlot)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(\r\n            _daysSlot == daysSlotOne ||\r\n                _daysSlot == daysSlotTwo ||\r\n                _daysSlot == daysSlotThree,\r\n            \"Invalid days slot!\"\r\n        );\r\n        require(\r\n            _newApr >= 1000 && // 10% minimum\r\n                _newApr <= 250000, // 2500% maximum\r\n            \"Limit not met!\"\r\n        );\r\n        require(\r\n            _newApr !=\r\n                aprHistory[_daysSlot][aprHistory[_daysSlot].length - 1].rate,\r\n            \"APR already set!\"\r\n        );\r\n        aprHistory[_daysSlot].push(Apr(_newApr, block.timestamp));\r\n\r\n        emit ChangeAPR(_newApr, _daysSlot);\r\n    }\r\n\r\n    /**\r\n        @dev Owner can able to change the fee percentages by giving the new values\r\n        to the args and giving old values again if don't need any change.\r\n        */\r\n    function setFeePercentage(uint256 _newFeeBeforeLockingPeriodOver)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(\r\n            _newFeeBeforeLockingPeriodOver > 0 &&\r\n                _newFeeBeforeLockingPeriodOver <= 5000,\r\n            \"Invalid fee percentage!\"\r\n        );\r\n        require(\r\n            _newFeeBeforeLockingPeriodOver != feeBeforeLockingPeriodOver,\r\n            \"Fee already set\"\r\n        );\r\n\r\n        uint256 _oldFee = feeBeforeLockingPeriodOver;\r\n        feeBeforeLockingPeriodOver = _newFeeBeforeLockingPeriodOver;\r\n\r\n        emit ChangeWithdrawBeforeLockingFee(\r\n            _oldFee,\r\n            _newFeeBeforeLockingPeriodOver\r\n        );\r\n    }\r\n\r\n    /**\r\n        @notice Owner can change the 9% which is charged when user unstake\r\n        tokens after that staking period is over, Owner cannot change more than\r\n        the total of 4% fee.\r\n        */\r\n    function setFeeOnUnstake(uint256 _newFeeAfterLockingPeriodOver)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(\r\n            _newFeeAfterLockingPeriodOver > 0 &&\r\n                _newFeeAfterLockingPeriodOver <= 400,\r\n            \"Invalid fee allocation!\"\r\n        );\r\n        require(\r\n            _newFeeAfterLockingPeriodOver != feeAfterLockingPeriodOver,\r\n            \"Fee already set!\"\r\n        );\r\n        uint256 _oldFee = feeAfterLockingPeriodOver;\r\n        feeAfterLockingPeriodOver = _newFeeAfterLockingPeriodOver;\r\n\r\n        emit ChangeWithdrawAfterLockingFee(\r\n            _oldFee,\r\n            _newFeeAfterLockingPeriodOver\r\n        );\r\n    }\r\n\r\n    /**\r\n        @notice Owner can change the staking days\r\n        for all the three slots, Initally the slots are\r\n        of 7, 30 and 90 days.\r\n        */\r\n    function changeStakingPeriod(\r\n        uint256 _newDaysSlotOne,\r\n        uint256 _newDaysSlotTwo,\r\n        uint256 _newDaysSlotThree\r\n    ) external onlyOwner {\r\n        require(\r\n            _newDaysSlotOne != 0 &&\r\n                _newDaysSlotTwo != 0 &&\r\n                _newDaysSlotThree != 0,\r\n            \"Days should be non-zero!\"\r\n        );\r\n        require(\r\n            _newDaysSlotOne != daysSlotOne ||\r\n                _newDaysSlotTwo != daysSlotTwo ||\r\n                _newDaysSlotThree != daysSlotThree,\r\n            \"Values must be different!\"\r\n        );\r\n\r\n        uint256 _prevDays;\r\n        if (_newDaysSlotOne != daysSlotOne) {\r\n            _prevDays = daysSlotOne;\r\n            aprHistory[_newDaysSlotOne].push(\r\n                aprHistory[daysSlotOne][aprHistory[daysSlotOne].length - 1]\r\n            );\r\n            daysSlotOne = _newDaysSlotOne;\r\n\r\n            emit ChangeStakingPeriod(_prevDays, _newDaysSlotOne);\r\n        }\r\n        if (_newDaysSlotTwo != daysSlotTwo) {\r\n            _prevDays = daysSlotTwo;\r\n            aprHistory[_newDaysSlotTwo].push(\r\n                aprHistory[daysSlotTwo][aprHistory[daysSlotTwo].length - 1]\r\n            );\r\n            daysSlotTwo = _newDaysSlotTwo;\r\n\r\n            emit ChangeStakingPeriod(_prevDays, _newDaysSlotTwo);\r\n        }\r\n        if (_newDaysSlotThree != daysSlotThree) {\r\n            _prevDays = daysSlotThree;\r\n            aprHistory[_newDaysSlotThree].push(\r\n                aprHistory[daysSlotThree][aprHistory[daysSlotThree].length - 1]\r\n            );\r\n            daysSlotThree = _newDaysSlotThree;\r\n\r\n            emit ChangeStakingPeriod(_prevDays, _newDaysSlotThree);\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice User can stake their tokens by calling this function.\r\n        @param _amount Amount of tokens to stake\r\n        @param _days No. of days for staking, Eg -> 7, 30 or 90 days\r\n        */\r\n    function stake(uint256 _amount, uint256 _days) external nonReentrant {\r\n        require(_amount != 0, \"Cannot stake zero amount!\");\r\n        require(\r\n            _days == daysSlotOne ||\r\n                _days == daysSlotTwo ||\r\n                _days == daysSlotThree,\r\n            \"Invalid staking days!\"\r\n        );\r\n        address _caller = msg.sender;\r\n        require(stakeHolders[_caller].amount == 0, \"Already a stakeholder!\");\r\n\r\n        uint256 _startTime = block.timestamp;\r\n        uint256 _endTime = _startTime + (_days * 1 days);\r\n\r\n        totalUsersAmount += _amount;\r\n        stakeHolders[_caller] = Staking({\r\n            amount: _amount,\r\n            lockFrom: _startTime,\r\n            lockTo: _endTime\r\n        });\r\n\r\n        require(\r\n            token.transferFrom(_caller, address(this), _amount),\r\n            \"ERC20 operation did not succeed\"\r\n        );\r\n\r\n        emit Stake(_caller, _amount, _days, _startTime);\r\n    }\r\n\r\n    /**\r\n        @notice User can unstake their tokens by calling this function\r\n        The user may charged some fee based on the number of days he \r\n        has staked tokens to.\r\n        */\r\n    function unstake() external nonReentrant {\r\n        address _caller = msg.sender;\r\n        require(stakeHolders[_caller].amount != 0, \"Not a stakeholder!\");\r\n\r\n        Staking memory _userStaking = stakeHolders[_caller];\r\n        uint256 _userPayableAmount;\r\n\r\n        if (block.timestamp <= _userStaking.lockTo)\r\n            _userPayableAmount = _distributeFee(_userStaking.amount);\r\n        else _userPayableAmount = _unstake(_caller);\r\n\r\n        totalUsersAmount -= stakeHolders[_caller].amount;\r\n        delete stakeHolders[_caller];\r\n        _transferTokens(_caller, _userPayableAmount);\r\n\r\n        emit Unstake(_caller, _userPayableAmount, block.timestamp);\r\n    }\r\n\r\n    /**\r\n        @notice Users can view the details of staking by passing their address\r\n        @param _user Address of the user\r\n        */\r\n    function viewStake(address _user) external view returns (Staking memory) {\r\n        return stakeHolders[_user];\r\n    }\r\n\r\n    /**\r\n        @notice It will return the total tokens for rewards available \r\n        in the contract.\r\n        */\r\n    function totalRewards() external view returns (uint256) {\r\n        return (token.balanceOf(address(this)) - totalUsersAmount);\r\n    }\r\n\r\n    /**\r\n        @notice View the currently set APR for the specific days slot.\r\n        @param _daysSlot days slot for the current APR\r\n        */\r\n    function getCurrentAPR(uint256 _daysSlot) external view returns (uint256) {\r\n        require(\r\n            _daysSlot == daysSlotOne\r\n            || _daysSlot == daysSlotTwo\r\n            || _daysSlot == daysSlotThree,\r\n            \"Invalid days!\"\r\n        );\r\n        // require(aprHistory[_daysSlot].length > 0, \"Invalid days slot!\");\r\n        return aprHistory[_daysSlot][aprHistory[_daysSlot].length - 1].rate;\r\n    }\r\n\r\n    /// @dev Private function for unstake called the external 'stake()' function\r\n    function _unstake(address _user)\r\n        private\r\n        returns (\r\n            // ! Naming Convention\r\n            uint256 _amountToWithdraw\r\n        )\r\n    {\r\n        // Final amount to withdraw\r\n        uint256 _totalAmount = _getReturnGenerated(_user); /// Calculating Amount on APRs\r\n\r\n        // Deducting 4% fee on Unstaking\r\n        uint256 _feeAmount = (_totalAmount * feeAfterLockingPeriodOver) /\r\n            PERCENTAGE_DENOMINATOR;\r\n        _transferTokens(adminWallet, _feeAmount);\r\n\r\n        // Final payable amount to user\r\n        _amountToWithdraw = _totalAmount - _feeAmount;\r\n    }\r\n\r\n    /// @dev Private function for fee distribution\r\n    function _distributeFee(uint256 _amount)\r\n        private\r\n        returns (uint256 _userPayableAmount)\r\n    {\r\n        uint256 _feeAmount = (_amount * feeBeforeLockingPeriodOver) /\r\n            PERCENTAGE_DENOMINATOR;\r\n        _transferTokens(adminWallet, _feeAmount);\r\n\r\n        return (_amount - _feeAmount);\r\n    }\r\n\r\n    function _transferTokens(address _receiver, uint256 _amount) private {\r\n        require(\r\n            token.transfer(_receiver, _amount),\r\n            \"ERC20 operation did not succeed\"\r\n        );\r\n    }\r\n\r\n    function _getReturnGenerated(address _user) private view returns (uint256) {\r\n        Staking memory _stake = stakeHolders[_user];\r\n        uint256 _daysSlot = (_stake.lockTo - _stake.lockFrom) / (1 days); \r\n        uint256 _interest;\r\n        uint256 _length = aprHistory[_daysSlot].length;\r\n        uint256 _rewardPerSec;\r\n\r\n        if (_length == 1) {\r\n            _rewardPerSec =\r\n                ((_stake.amount * aprHistory[_daysSlot][0].rate) /\r\n                    PERCENTAGE_DENOMINATOR) /\r\n                YEAR_IN_SECONDS; \r\n            return\r\n                _stake.amount +\r\n                (_rewardPerSec * (_stake.lockTo - _stake.lockFrom));\r\n        }\r\n        if (_stake.lockFrom >= aprHistory[_daysSlot][_length - 1].changedAt) {\r\n            _rewardPerSec =\r\n                ((_stake.amount * aprHistory[_daysSlot][_length - 1].rate) /\r\n                    PERCENTAGE_DENOMINATOR) /\r\n                YEAR_IN_SECONDS; \r\n            return\r\n                _stake.amount +\r\n                (_rewardPerSec * (_stake.lockTo - _stake.lockFrom));\r\n        }\r\n\r\n        uint256 _timeDiff;\r\n        bool _flag;\r\n\r\n        for (uint256 index = 1; index < _length; index++) {\r\n            Apr memory _apr = aprHistory[_daysSlot][index];\r\n            Apr memory _prevApr = aprHistory[_daysSlot][index - 1];\r\n\r\n            if (_stake.lockFrom < _apr.changedAt) {\r\n                if (_stake.lockFrom >= _prevApr.changedAt) {\r\n                    if (_stake.lockTo <= _apr.changedAt) {\r\n                        _timeDiff = _stake.lockTo - _stake.lockFrom;\r\n                        _flag = true;\r\n                    } else {\r\n                        _timeDiff = _apr.changedAt - _stake.lockFrom;\r\n                        if (index == (_length - 1)) {\r\n                            _rewardPerSec =\r\n                                ((_stake.amount * _apr.rate) /\r\n                                    PERCENTAGE_DENOMINATOR) /\r\n                                YEAR_IN_SECONDS; \r\n                            _interest += ((_stake.lockTo - _apr.changedAt) *\r\n                                _rewardPerSec);\r\n                            _flag = true;\r\n                        }\r\n                    }\r\n                } else if (\r\n                    _stake.lockFrom < _prevApr.changedAt &&\r\n                    _stake.lockTo > _apr.changedAt\r\n                ) {\r\n                    _timeDiff = _apr.changedAt - _prevApr.changedAt;\r\n                    if (index == (_length - 1)) {\r\n                        _rewardPerSec =\r\n                            ((_stake.amount * _apr.rate) /\r\n                                PERCENTAGE_DENOMINATOR) /\r\n                            YEAR_IN_SECONDS;\r\n                        _interest += ((_stake.lockTo - _apr.changedAt) *\r\n                            _rewardPerSec);\r\n                        _flag = true;\r\n                    }\r\n                } else {\r\n                    _timeDiff = _stake.lockTo - _prevApr.changedAt;\r\n                    _flag = true;\r\n                }\r\n\r\n                _rewardPerSec =\r\n                    ((_stake.amount * _prevApr.rate) / PERCENTAGE_DENOMINATOR) /\r\n                    YEAR_IN_SECONDS;\r\n                _interest += (_timeDiff * _rewardPerSec);\r\n                if (_flag) break;\r\n            }\r\n        }\r\n        return _stake.amount + _interest;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_adminWallet\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newApr\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"daysSlot\",\"type\":\"uint256\"}],\"name\":\"ChangeAPR\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldDays\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDays\",\"type\":\"uint256\"}],\"name\":\"ChangeStakingPeriod\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"ChangeWithdrawAfterLockingFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"ChangeWithdrawBeforeLockingFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalDays\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Stake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Unstake\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newDaysSlotOne\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newDaysSlotTwo\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newDaysSlotThree\",\"type\":\"uint256\"}],\"name\":\"changeStakingPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_daysSlot\",\"type\":\"uint256\"}],\"name\":\"getCurrentAPR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newApr\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_daysSlot\",\"type\":\"uint256\"}],\"name\":\"setAprInterest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newFeeAfterLockingPeriodOver\",\"type\":\"uint256\"}],\"name\":\"setFeeOnUnstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newFeeBeforeLockingPeriodOver\",\"type\":\"uint256\"}],\"name\":\"setFeePercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_days\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUsersAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"viewStake\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockFrom\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockTo\",\"type\":\"uint256\"}],\"internalType\":\"struct StakingBFK.Staking\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "StakingBFK", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000002d0e28b294a0dc97a5ca64e7ed6d2e9aca24f7c2000000000000000000000000a5438df34698df262d5ed463f10387c998edc24a", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5734c30614161ec638154d6e71a697aa051eae3f823b0cdb6abba3b5eb4f5773"}