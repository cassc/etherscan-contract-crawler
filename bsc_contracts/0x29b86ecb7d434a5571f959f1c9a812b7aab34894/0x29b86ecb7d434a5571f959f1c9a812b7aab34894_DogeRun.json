{"SourceCode": "{\"DogeRun_v2.sol\":{\"content\":\"// https://twitter.com/DogeRunToken\\r\\n// https://www.dogeruntoken.com/\\r\\n// https://t.me/DogeRunToken\\r\\n\\r\\n// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\nimport \\\"./Libraries.sol\\\";\\r\\ncontract DogeRun is IBEP20, Ownable\\r\\n{\\r\\n  \\r\\n    mapping (address =\\u003e uint) private _balances;\\r\\n    mapping (address =\\u003e mapping (address =\\u003e uint)) private _allowances;\\r\\n    mapping(address =\\u003e bool) public excludedFromFees;\\r\\n    mapping(address=\\u003ebool) public isAMM;\\r\\n    //Token Info\\r\\n    string private constant _name = \\u0027Doge Run\\u0027;\\r\\n    string private constant _symbol = \\u0027DRUN\\u0027;\\r\\n    uint8 private constant _decimals = 18;\\r\\n    uint public constant InitialSupply= 100 * 10**9 * 10**_decimals;//equals 100.000.000.000 Token\\r\\n\\r\\n    uint private constant DefaultLiquidityLockTime=7 days;\\r\\n    //TODO: mainnet\\r\\n    //TestNet\\r\\n    // address private constant PancakeRouter=0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3;\\r\\n    //MainNet\\r\\n    address private constant PancakeRouter=0x10ED43C718714eb63d5aA57B78B54704E256024E;\\r\\n\\r\\n    //variables that track balanceLimit and sellLimit,\\r\\n    //can be updated based on circulating supply and Sell- and BalanceLimitDividers\\r\\n    uint private _circulatingSupply =InitialSupply;\\r\\n    \\r\\n    //Tracks the current Taxes, different Taxes can be applied for buy/sell/transfer\\r\\n    uint public buyTax = 110;\\r\\n    uint public sellTax = 110;\\r\\n    uint public transferTax = 0;\\r\\n    uint public gameRewardTax=182;\\r\\n    uint public liquidityTax=90;\\r\\n    uint public marketingTax=364;\\r\\n    uint public buyBackTax=182;\\r\\n    uint public gameDevTax=182;\\r\\n    uint constant TAX_DENOMINATOR=1000;\\r\\n    uint constant MAXTAXDENOMINATOR=9;\\r\\n    \\r\\n\\r\\n    address private _pancakePairAddress; \\r\\n    IPancakeRouter private  _pancakeRouter;\\r\\n    \\r\\n    \\r\\n    //TODO: marketingWallet\\r\\n    address public marketingWallet;\\r\\n    //Only marketingWallet can change marketingWallet\\r\\n    function ChangeMarketingWallet(address newWallet) public{\\r\\n        require(msg.sender==marketingWallet);\\r\\n        marketingWallet=newWallet;\\r\\n    }\\r\\n    //Only owner can change gameDevWallet\\r\\n    address public gameDevWallet;\\r\\n    function ChangeGameDevWallet(address newWallet) public{\\r\\n        require(msg.sender==owner());\\r\\n        gameDevWallet=newWallet;\\r\\n    }\\r\\n    //Only owner can change gameDevWallet\\r\\n    address public buyBackWallet;\\r\\n    function ChangeBuyBackWallet(address newWallet) public{\\r\\n        require(msg.sender==owner());\\r\\n        buyBackWallet=newWallet;\\r\\n    }\\r\\n    //Only owner can change gameRewardsWallet\\r\\n    address public gameRewardsWallet;\\r\\n    function ChangeGameRewardsWallet(address newWallet) public{\\r\\n        require(msg.sender==owner());\\r\\n        gameRewardsWallet=newWallet;\\r\\n    }\\r\\n    //modifier for functions only the team can call\\r\\n    modifier onlyTeam() {\\r\\n        require(_isTeam(msg.sender), \\\"Caller not Team or Owner\\\");\\r\\n        _;\\r\\n    }\\r\\n    //Checks if address is in Team, is needed to give Team access even if contract is renounced\\r\\n    //Team doesn\\u0027t have access to critical Functions that could turn this into a Rugpull(Exept liquidity unlocks)\\r\\n    function _isTeam(address addr) private view returns (bool){\\r\\n        return addr==owner()||addr==marketingWallet;\\r\\n    }\\r\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    //Constructor///////////////////////////////////////////////////////////////////////////////////////////\\r\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    constructor () {\\r\\n        uint deployerBalance=_circulatingSupply;\\r\\n        _balances[msg.sender] = deployerBalance;\\r\\n        emit Transfer(address(0), msg.sender, deployerBalance);\\r\\n\\r\\n        // Pancake Router\\r\\n        _pancakeRouter = IPancakeRouter(PancakeRouter);\\r\\n        //Creates a Pancake Pair\\r\\n        _pancakePairAddress = IPancakeFactory(_pancakeRouter.factory()).createPair(address(this), _pancakeRouter.WETH());\\r\\n        isAMM[_pancakePairAddress]=true;\\r\\n        \\r\\n        //contract creator is by default marketing wallet\\r\\n        marketingWallet=msg.sender;\\r\\n        gameDevWallet=msg.sender;\\r\\n        buyBackWallet=msg.sender;\\r\\n        gameRewardsWallet=msg.sender;\\r\\n        //owner pancake router and contract is excluded from Taxes\\r\\n        excludedFromFees[msg.sender]=true;\\r\\n        excludedFromFees[PancakeRouter]=true;\\r\\n        excludedFromFees[address(this)]=true;\\r\\n    }\\r\\n    \\r\\n\\r\\n\\r\\n\\r\\n\\r\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    //Transfer functionality////////////////////////////////////////////////////////////////////////////////\\r\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n\\r\\n    //transfer function, every transfer runs through this function\\r\\n    function _transfer(address sender, address recipient, uint amount) private{\\r\\n        require(sender != address(0), \\\"Transfer from zero\\\");\\r\\n        require(recipient != address(0), \\\"Transfer to zero\\\");\\r\\n\\r\\n\\r\\n        //Pick transfer\\r\\n        if(excludedFromFees[sender] || excludedFromFees[recipient])\\r\\n            _feelessTransfer(sender, recipient, amount);\\r\\n        else{ \\r\\n            //once trading is enabled, it can\\u0027t be turned off again\\r\\n            require(LaunchTimestamp\\u003e0,\\\"trading not yet enabled\\\");\\r\\n            _taxedTransfer(sender,recipient,amount);                  \\r\\n        }\\r\\n    }\\r\\n    //applies taxes, checks for limits, locks generates autoLP and stakingBNB, and autostakes\\r\\n    function _taxedTransfer(address sender, address recipient, uint amount) private{\\r\\n        uint senderBalance = _balances[sender];\\r\\n        require(senderBalance \\u003e= amount, \\\"Transfer exceeds balance\\\");\\r\\n\\r\\n        bool isBuy=isAMM[sender];\\r\\n        bool isSell=isAMM[recipient];\\r\\n\\r\\n        uint tax;\\r\\n        if(isSell){  \\r\\n            uint SellTaxDuration=1 hours;          \\r\\n            if(block.timestamp\\u003cLaunchTimestamp+SellTaxDuration){\\r\\n                tax=_getStartTax(SellTaxDuration,200);\\r\\n                }else tax=sellTax;\\r\\n            }\\r\\n        else if(isBuy){\\r\\n            uint BuyTaxDuration=20 seconds;\\r\\n            if(block.timestamp\\u003cLaunchTimestamp+BuyTaxDuration){\\r\\n                tax=_getStartTax(BuyTaxDuration,999);\\r\\n            }else tax=buyTax;\\r\\n        } else tax=transferTax;\\r\\n\\r\\n        if((sender!=_pancakePairAddress)\\u0026\\u0026(!manualSwap)\\u0026\\u0026(!_isSwappingContractModifier))\\r\\n            _swapContractToken(false);\\r\\n\\r\\n        //Calculates the exact token amount for each tax\\r\\n        uint tokensForGameRewards=_calculateFee(amount, tax, gameRewardTax);\\r\\n        //staking and liquidity Tax get treated the same, only during conversion they get split\\r\\n        uint contractToken=_calculateFee(amount, tax, marketingTax+liquidityTax+buyBackTax+gameDevTax);\\r\\n        //Subtract the Taxed Tokens from the amount\\r\\n        uint taxedAmount=amount-(tokensForGameRewards + contractToken);\\r\\n\\r\\n        _balances[sender]-=amount;\\r\\n        //Adds the taxed tokens to the contract wallet\\r\\n        _balances[address(this)] += contractToken;\\r\\n        //Game Rewards tokens\\r\\n        _balances[gameRewardsWallet]+=tokensForGameRewards;\\r\\n        _balances[recipient]+=taxedAmount;\\r\\n        \\r\\n        emit Transfer(sender,recipient,taxedAmount);\\r\\n    }\\r\\n    //Start tax drops depending on the time since launch, enables bot protection and Dump protection\\r\\n    function _getStartTax(uint duration, uint maxTax) private view returns (uint){\\r\\n        uint timeSinceLaunch=block.timestamp-LaunchTimestamp;\\r\\n        return maxTax-((maxTax-50)*timeSinceLaunch/duration);\\r\\n    }\\r\\n    //Calculates the token that should be taxed\\r\\n    function _calculateFee(uint amount, uint tax, uint taxPercent) private pure returns (uint) {\\r\\n        return (amount*tax*taxPercent) / (TAX_DENOMINATOR*TAX_DENOMINATOR);\\r\\n    }\\r\\n\\r\\n\\r\\n    //Feeless transfer only transfers and autostakes\\r\\n    function _feelessTransfer(address sender, address recipient, uint amount) private{\\r\\n        uint senderBalance = _balances[sender];\\r\\n        require(senderBalance \\u003e= amount, \\\"Transfer exceeds balance\\\");\\r\\n        _balances[sender]-=amount;\\r\\n        _balances[recipient]+=amount;      \\r\\n        emit Transfer(sender,recipient,amount);\\r\\n    }\\r\\n\\r\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    //Swap Contract Tokens//////////////////////////////////////////////////////////////////////////////////\\r\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    \\r\\n    //Locks the swap if already swapping\\r\\n    bool private _isSwappingContractModifier;\\r\\n    modifier lockTheSwap {\\r\\n        _isSwappingContractModifier = true;\\r\\n        _;\\r\\n        _isSwappingContractModifier = false;\\r\\n    }\\r\\n\\r\\n    //Sets the permille of pancake pair to trigger liquifying taxed token\\r\\n    uint public swapTreshold=2;\\r\\n    function setSwapTreshold(uint newSwapTresholdPermille) public onlyTeam{\\r\\n        require(newSwapTresholdPermille\\u003c=10);//MaxTreshold= 1%\\r\\n        swapTreshold=newSwapTresholdPermille;\\r\\n    }\\r\\n    //Sets the max Liquidity where swaps for Liquidity still happen\\r\\n    uint public overLiquifyTreshold=150;\\r\\n    function SetOverLiquifiedTreshold(uint newOverLiquifyTresholdPermille) public onlyTeam{\\r\\n        require(newOverLiquifyTresholdPermille\\u003c=1000);\\r\\n        overLiquifyTreshold=newOverLiquifyTresholdPermille;\\r\\n    }\\r\\n    //Sets the taxes Burn+marketing+liquidity tax needs to equal the TAX_DENOMINATOR (1000)\\r\\n    //buy, sell and transfer tax are limited by the MAXTAXDENOMINATOR\\r\\n    event OnSetTaxes(uint buy, uint sell, uint transfer_, uint reward, uint marketing,uint liquidity,uint dev, uint buyBack);\\r\\n    function SetTaxes(uint buy, uint sell, uint transfer_, uint reward, uint marketing,uint liquidity, uint dev, uint buyBack) public onlyTeam{\\r\\n        uint maxTax=TAX_DENOMINATOR/MAXTAXDENOMINATOR;\\r\\n        require(buy\\u003c=maxTax\\u0026\\u0026sell\\u003c=maxTax\\u0026\\u0026transfer_\\u003c=maxTax,\\\"Tax exceeds maxTax\\\");\\r\\n        require(reward+marketing+liquidity+dev+buyBack==TAX_DENOMINATOR,\\\"Taxes don\\u0027t add up to denominator\\\");\\r\\n        \\r\\n        buyTax=buy;\\r\\n        sellTax=sell;\\r\\n        transferTax=transfer_;\\r\\n        marketingTax=marketing;\\r\\n        liquidityTax=liquidity;\\r\\n        gameRewardTax=reward;\\r\\n        buyBackTax=buyBack;\\r\\n        gameDevTax=dev;\\r\\n        emit OnSetTaxes(buy, sell, transfer_, reward, marketing, liquidity, dev, buyBack);\\r\\n    }\\r\\n    \\r\\n    //If liquidity is over the treshold, convert 100% of Token to Marketing BNB to avoid overliquifying\\r\\n    function isOverLiquified() public view returns(bool){\\r\\n        return _balances[_pancakePairAddress]\\u003e_circulatingSupply*overLiquifyTreshold/1000;\\r\\n    }\\r\\n\\r\\n\\r\\n    //swaps the token on the contract for Marketing BNB and LP Token.\\r\\n    //always swaps a percentage of the LP pair balance to avoid price impact\\r\\n    function _swapContractToken(bool ignoreLimits) private lockTheSwap{\\r\\n        uint contractBalance=_balances[address(this)];\\r\\n        uint totalTax=liquidityTax+marketingTax+gameDevTax+buyBackTax;\\r\\n        //swaps each time it reaches swapTreshold of pancake pair to avoid large prize impact\\r\\n        uint tokenToSwap=_balances[_pancakePairAddress]*swapTreshold/1000;\\r\\n\\r\\n        //nothing to swap at no tax\\r\\n        if(totalTax==0)return;\\r\\n        //only swap if contractBalance is larger than tokenToSwap, and totalTax is unequal to 0\\r\\n        //Ignore limits swaps 100% of the contractBalance\\r\\n        if(ignoreLimits)\\r\\n            tokenToSwap=_balances[address(this)];\\r\\n        else if(contractBalance\\u003ctokenToSwap)\\r\\n            return;\\r\\n\\r\\n        //splits the token in TokenForLiquidity and tokenForMarketing\\r\\n        //if over liquified, 0 tokenForLiquidity\\r\\n        uint tokenForLiquidity=\\r\\n        isOverLiquified()?0\\r\\n        :(tokenToSwap*liquidityTax)/totalTax;\\r\\n        uint tokenForBuyBack=(tokenToSwap*buyBackTax)/totalTax;\\r\\n        uint tokenForGameDev=(tokenToSwap*gameDevTax)/totalTax;\\r\\n        uint tokenForMarketing=tokenToSwap-tokenForLiquidity-tokenForBuyBack-tokenForGameDev;\\r\\n\\r\\n        uint LiqHalf=tokenForLiquidity/2;\\r\\n        //swaps marktetingToken and the liquidity token half for BNB\\r\\n        uint swapToken=LiqHalf+tokenForMarketing+tokenForBuyBack+tokenForGameDev;\\r\\n        //Gets the initial BNB balance, so swap won\\u0027t touch any contract BNB\\r\\n        uint initialBNBBalance = address(this).balance;\\r\\n        _swapTokenForBNB(swapToken);\\r\\n        uint newBNB=(address(this).balance - initialBNBBalance);\\r\\n\\r\\n        //calculates the amount of BNB belonging to the LP-Pair and converts them to LP\\r\\n        if(tokenForLiquidity\\u003e0){\\r\\n            uint liqBNB = (newBNB*LiqHalf)/swapToken;\\r\\n            _addLiquidity(LiqHalf, liqBNB);\\r\\n        }\\r\\n        //Sends all the BNBS to the requred wallets\\r\\n        bool sent;\\r\\n        uint256 ContractBalance=address(this).balance;\\r\\n        (sent,)=marketingWallet.call{value:ContractBalance*50/100}(\\\"\\\");\\r\\n        (sent,)=gameDevWallet.call{value:ContractBalance*25/100}(\\\"\\\");\\r\\n        (sent,)=buyBackWallet.call{value:ContractBalance*25/100}(\\\"\\\");\\r\\n        sent=true;\\r\\n    }\\r\\n    //swaps tokens on the contract for BNB\\r\\n    function _swapTokenForBNB(uint amount) private {\\r\\n        _approve(address(this), address(_pancakeRouter), amount);\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = _pancakeRouter.WETH();\\r\\n\\r\\n        try _pancakeRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n            amount,\\r\\n            0,\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        ){}\\r\\n        catch{}\\r\\n    }\\r\\n    //Adds Liquidity directly to the contract where LP are locked\\r\\n    function _addLiquidity(uint tokenamount, uint bnbamount) private {\\r\\n        _approve(address(this), address(_pancakeRouter), tokenamount);\\r\\n        _pancakeRouter.addLiquidityETH{value: bnbamount}(\\r\\n            address(this),\\r\\n            tokenamount,\\r\\n            0,\\r\\n            0,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n\\r\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    //public functions /////////////////////////////////////////////////////////////////////////////////////\\r\\n    //////////////////////////////////////////////////////////////////////////////////////////////////////// \\r\\n    function getLiquidityReleaseTimeInSeconds() public view returns (uint){\\r\\n        if(block.timestamp\\u003c_liquidityUnlockTime)\\r\\n            return _liquidityUnlockTime-block.timestamp;\\r\\n        return 0;\\r\\n    }\\r\\n    function getBurnedTokens() public view returns(uint){\\r\\n        return (InitialSupply-_circulatingSupply)+_balances[address(0xdead)];\\r\\n    }\\r\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    //Settings//////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    //For AMM addresses buy and sell taxes apply\\r\\n    function SetAMM(address AMM, bool Add) public onlyTeam{\\r\\n        require(AMM!=_pancakePairAddress,\\\"can\\u0027t change pancake\\\");\\r\\n        isAMM[AMM]=Add;\\r\\n    }\\r\\n    \\r\\n    bool public manualSwap;\\r\\n    //switches autoLiquidity and marketing BNB generation during transfers\\r\\n    function SwitchManualSwap(bool manual) public onlyTeam{\\r\\n        manualSwap=manual;\\r\\n    }\\r\\n    //manually converts contract token to LP and staking BNB\\r\\n    function SwapContractToken() public onlyTeam{\\r\\n    _swapContractToken(true);\\r\\n    }\\r\\n    event ExcludeAccount(address account, bool exclude);\\r\\n    //Exclude/Include account from fees (eg. CEX)\\r\\n    function ExcludeAccountFromFees(address account, bool exclude) public onlyTeam{\\r\\n        require(account!=address(this),\\\"can\\u0027t Include the contract\\\");\\r\\n        excludedFromFees[account]=exclude;\\r\\n        emit ExcludeAccount(account,exclude);\\r\\n    }\\r\\n    //Enables trading. Sets the launch timestamp to the given Value\\r\\n    event OnEnableTrading();\\r\\n    uint public LaunchTimestamp;\\r\\n    function SetupEnableTrading() public onlyTeam{\\r\\n        require(LaunchTimestamp==0,\\\"AlreadyLaunched\\\");\\r\\n        LaunchTimestamp=block.timestamp;\\r\\n        emit OnEnableTrading();\\r\\n    }\\r\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    //Liquidity Lock////////////////////////////////////////////////////////////////////////////////////////\\r\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    //the timestamp when Liquidity unlocks\\r\\n    uint _liquidityUnlockTime;\\r\\n    bool public LPReleaseLimitedTo20Percent;\\r\\n    //Sets Liquidity Release to 20% at a time and prolongs liquidity Lock for a Week after Release. \\r\\n    //That way autoLiquidity can be slowly released \\r\\n    function limitLiquidityReleaseTo20Percent() public onlyTeam{\\r\\n        LPReleaseLimitedTo20Percent=true;\\r\\n    }\\r\\n    //Locks Liquidity for seconds. can only be prolonged\\r\\n    function LockLiquidityForSeconds(uint secondsUntilUnlock) public onlyTeam{\\r\\n        _prolongLiquidityLock(secondsUntilUnlock+block.timestamp);\\r\\n    }\\r\\n    event OnProlongLPLock(uint UnlockTimestamp);\\r\\n    function _prolongLiquidityLock(uint newUnlockTime) private{\\r\\n        // require new unlock time to be longer than old one\\r\\n        require(newUnlockTime\\u003e_liquidityUnlockTime);\\r\\n        _liquidityUnlockTime=newUnlockTime;\\r\\n        emit OnProlongLPLock(_liquidityUnlockTime);\\r\\n    }\\r\\n    event OnReleaseLP();\\r\\n    //Release Liquidity Tokens once unlock time is over\\r\\n    function LiquidityRelease() public onlyTeam {\\r\\n        //Only callable if liquidity Unlock time is over\\r\\n        require(block.timestamp \\u003e= _liquidityUnlockTime, \\\"Not yet unlocked\\\");\\r\\n\\r\\n        IBEP20 liquidityToken = IBEP20(_pancakePairAddress);\\r\\n        uint amount = liquidityToken.balanceOf(address(this));\\r\\n        if(LPReleaseLimitedTo20Percent)\\r\\n        {\\r\\n            _liquidityUnlockTime=block.timestamp+DefaultLiquidityLockTime;\\r\\n            //regular liquidity release, only releases 20% at a time and locks liquidity for another week\\r\\n            amount=amount*2/10;\\r\\n        }\\r\\n        liquidityToken.transfer(msg.sender, amount);\\r\\n        emit OnReleaseLP();\\r\\n    }\\r\\n\\r\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    //external//////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n    function getOwner() external view override returns (address) {\\r\\n        return owner();\\r\\n    }\\r\\n\\r\\n    function name() external pure override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    function symbol() external pure override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    function decimals() external pure override returns (uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n\\r\\n    function totalSupply() external view override returns (uint) {\\r\\n        return _circulatingSupply;\\r\\n    }\\r\\n\\r\\n    function balanceOf(address account) external view override returns (uint) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    function transfer(address recipient, uint amount) external override returns (bool) {\\r\\n        _transfer(msg.sender, recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function allowance(address _owner, address spender) external view override returns (uint) {\\r\\n        return _allowances[_owner][spender];\\r\\n    }\\r\\n\\r\\n    function approve(address spender, uint amount) external override returns (bool) {\\r\\n        _approve(msg.sender, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n    function _approve(address owner, address spender, uint amount) private {\\r\\n        require(owner != address(0), \\\"Approve from zero\\\");\\r\\n        require(spender != address(0), \\\"Approve to zero\\\");\\r\\n\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n    function transferFrom(address sender, address recipient, uint amount) external override returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n\\r\\n        uint currentAllowance = _allowances[sender][msg.sender];\\r\\n        require(currentAllowance \\u003e= amount, \\\"Transfer \\u003e allowance\\\");\\r\\n\\r\\n        _approve(sender, msg.sender, currentAllowance - amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // IBEP20 - Helpers\\r\\n\\r\\n    function increaseAllowance(address spender, uint addedValue) external returns (bool) {\\r\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function decreaseAllowance(address spender, uint subtractedValue) external returns (bool) {\\r\\n        uint currentAllowance = _allowances[msg.sender][spender];\\r\\n        require(currentAllowance \\u003e= subtractedValue, \\\"\\u003c0 allowance\\\");\\r\\n\\r\\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n}\"},\"Libraries.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\ninterface IBEP20 {\\r\\n  function totalSupply() external view returns (uint256);\\r\\n  function decimals() external view returns (uint8);\\r\\n  function symbol() external view returns (string memory);\\r\\n  function name() external view returns (string memory);\\r\\n  function getOwner() external view returns (address);\\r\\n  function balanceOf(address account) external view returns (uint256);\\r\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n  function allowance(address _owner, address spender) external view returns (uint256);\\r\\n  function approve(address spender, uint256 amount) external returns (bool);\\r\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\ninterface IPancakeFactory {\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n}\\r\\n\\r\\ninterface IPancakeRouter {\\r\\n   \\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external;\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n}\\r\\n\\r\\nabstract contract Ownable {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor () {\\r\\n        address msgSender = msg.sender;\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(owner() == msg.sender, \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"exclude\",\"type\":\"bool\"}],\"name\":\"ExcludeAccount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"OnEnableTrading\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"UnlockTimestamp\",\"type\":\"uint256\"}],\"name\":\"OnProlongLPLock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"OnReleaseLP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buy\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sell\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"transfer_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketing\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dev\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyBack\",\"type\":\"uint256\"}],\"name\":\"OnSetTaxes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"ChangeBuyBackWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"ChangeGameDevWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"ChangeGameRewardsWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"ChangeMarketingWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exclude\",\"type\":\"bool\"}],\"name\":\"ExcludeAccountFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"InitialSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LPReleaseLimitedTo20Percent\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LaunchTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LiquidityRelease\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"secondsUntilUnlock\",\"type\":\"uint256\"}],\"name\":\"LockLiquidityForSeconds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"AMM\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"Add\",\"type\":\"bool\"}],\"name\":\"SetAMM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newOverLiquifyTresholdPermille\",\"type\":\"uint256\"}],\"name\":\"SetOverLiquifiedTreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"buy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"transfer_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketing\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dev\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyBack\",\"type\":\"uint256\"}],\"name\":\"SetTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SetupEnableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SwapContractToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"manual\",\"type\":\"bool\"}],\"name\":\"SwitchManualSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyBackTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyBackWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"excludedFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gameDevTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gameDevWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gameRewardTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gameRewardsWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBurnedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLiquidityReleaseTimeInSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAMM\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOverLiquified\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"limitLiquidityReleaseTo20Percent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"overLiquifyTreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newSwapTresholdPermille\",\"type\":\"uint256\"}],\"name\":\"setSwapTreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DogeRun", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e6bafb7080aeb33439bcf129f41821b1f95f0271ae6f41eeab26e3407df28200"}