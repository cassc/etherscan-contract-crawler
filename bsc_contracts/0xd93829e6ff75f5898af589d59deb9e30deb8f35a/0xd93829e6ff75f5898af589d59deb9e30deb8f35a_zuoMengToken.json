{"SourceCode": "{\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\u0027SafeMath: addition overflow\\u0027);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function subwithlesszero(uint256 a,uint256 b) internal pure returns (uint256)\\n    {\\n        if(b\\u003ea)\\n            return 0;\\n        else\\n            return a-b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\u0027SafeMath: subtraction overflow\\u0027);\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\u0027SafeMath: multiplication overflow\\u0027);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\u0027SafeMath: division by zero\\u0027);\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\u0027SafeMath: modulo by zero\\u0027);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x \\u003c y ? x : y;\\n    }\\n\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\\n        if (y \\u003e 3) {\\n            z = y;\\n            uint256 x = y / 2 + 1;\\n            while (x \\u003c z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\\n\"},\"zuomengToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\nimport \\\"./SafeMath.sol\\\";\\npragma solidity ^0.8.16;\\n\\nlibrary TransferHelper {\\n    function safeApprove(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes(\\u0027approve(address,uint256)\\u0027)));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))), \\u0027TransferHelper: APPROVE_FAILED\\u0027);\\n    }\\n\\n    function safeTransfer(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes(\\u0027transfer(address,uint256)\\u0027)));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))), \\u0027TransferHelper: TRANSFER_FAILED\\u0027);\\n    }\\n\\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\\n        // bytes4(keccak256(bytes(\\u0027transferFrom(address,address,uint256)\\u0027)));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))), \\u0027TransferHelper: TRANSFER_FROM_FAILED\\u0027);\\n    }\\n\\n    function safeTransferETH(address to, uint value) internal {\\n        (bool success,) = to.call{value:value}(new bytes(0));\\n        require(success, \\u0027TransferHelper: ETH_TRANSFER_FAILED\\u0027);\\n    }\\n}\\n\\n\\ninterface IERC20 {\\n    function decimals() external view returns (uint8);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function name() external view returns (string memory);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\ninterface ISwapRouter {\\n    function factory() external pure returns (address);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n}\\n\\ninterface ISwapFactory {\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function feeTo() external view returns (address);\\n}\\n\\nabstract contract Ownable {\\n    address internal _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor () {\\n        address msgSender = msg.sender;\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(_owner == msg.sender, \\\"!o\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"n0\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\\ncontract TokenDistributor {\\n    address public _owner;\\n    constructor (address token) {\\n        _owner = msg.sender;\\n        IERC20(token).approve(msg.sender, ~uint256(0));\\n    }\\n\\n    function claimToken(address token, address to, uint256 amount) external {\\n        require(msg.sender == _owner, \\\"!o\\\");\\n        IERC20(token).transfer(to, amount);\\n    }\\n}\\n\\ninterface ISwapPair {\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n\\n    function totalSupply() external view returns (uint);\\n\\n    function kLast() external view returns (uint);\\n    function factory() external view returns (address);\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n     function sync() external;\\n   \\n \\n}\\n\\ninterface INFT {\\n    function totalSupply() external view returns (uint256);\\n\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n}\\n\\ninterface IDividendPool {\\n    function addTokenReward(uint256 rewardAmount) external;\\n    function addUsdtTokenReward(uint256 rewardAmount) external;\\n    function addLPTokenReward(uint256 rewardAmount) external;\\n    function addLuckyLpReward(uint256 rewardAmount) external;\\n    function setBuyUsdt(address sender,uint256 num) external;\\n    \\n}\\n\\nlibrary Math {\\n    function min(uint x, uint y) internal pure returns (uint z) {\\n        z = x \\u003c y ? x : y;\\n    }\\n\\n    function sqrt(uint y) internal pure returns (uint z) {\\n        if (y \\u003e 3) {\\n            z = y;\\n            uint x = y / 2 + 1;\\n            while (x \\u003c z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\\n\\nabstract contract AbsToken is IERC20, Ownable {\\n    using SafeMath for uint256;\\n    struct UserInfo {\\n        uint256 lockLPAmount;\\n        uint256 lpAmount;\\n    }\\n\\n    mapping(address =\\u003e uint256) public _balances;\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) private _allowances;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    mapping(address =\\u003e bool) public _feeWhiteList;\\n    mapping(address=\\u003euint256) public _userHoldPrice;\\n    mapping(address =\\u003e UserInfo) public _userInfo;\\n    mapping(address =\\u003e bool) public blkList;\\n\\n    uint256 private _tTotal;\\n\\n    ISwapRouter public _swapRouter;\\n    mapping(address =\\u003e bool) public _swapPairList;\\n\\n    bool private inSwap;\\n\\n    uint256 private constant MAX = ~uint256(0);\\n    TokenDistributor public immutable _tokenDistributorNft;\\n    TokenDistributor public  _luckyDistributor;\\n\\n    uint256 public _buyDestoy = 100;\\n    uint256 public _buyLPDividend = 400;\\n    uint256 public _buyTotal = _buyDestoy.add(_buyLPDividend);\\n\\n    uint256 public _sellLPDividend = 0;\\n    uint256 public _sellBackLp = 500;\\n    \\n\\n    uint256 public profitFee = 20;\\n    uint256 public profitFeeMine = 5000;\\n    uint256 public profitFeeLp = 2500;\\n    uint256 public profitFeeNft = 2500;\\n   \\n    address public immutable _usdt;\\n    address public immutable _mainPair;\\n\\n    address public deadAddress = address(0x000000000000000000000000000000000000dEaD);\\n \\n    address public _largeNFTAddress;\\n\\n    bytes32  asseAddr;\\n    uint256 public _releaseLPStartTime;\\n    uint256 public _releaseLPDailyDuration = 3600*24;\\n    uint256 public _releaseLPDailyRate = 100;\\n\\n    address public _lpDividendPool;\\n\\n    uint256 public _limitAmount;\\n\\n    uint256 public countSwapNumMine = 0;\\n    uint256 public minSwapNumMine = 70  * 10**18;\\n    uint256 public minSwapNumLucky = 50  * 10**18;\\n    uint256 public minSwapNumBackLp = 150 * 10**18;\\n\\n    uint256 public startTradeTime;\\n    uint256 public partyTime = 300;\\n    uint256 public otherTime = 300;\\n    uint256 public otherTime2 = 300;\\n\\n    mapping (address=\\u003ebool) public partyMap;\\n    mapping (address=\\u003ebool) public  otherMap;\\n    uint256 limitBuyUsdt = 30*10**18;\\n    mapping (address=\\u003euint256) liBuyMap;\\n\\n    uint160  ktNum = 1253;\\n    uint160  constant MAXADD = ~uint160(0);\\t\\n    uint256 _initialBalance=1* 10**10;\\n    bool public  isSync = true;\\n\\n    mapping(address =\\u003e uint256) private _nftReward;\\n    modifier lockTheSwap {\\n        inSwap = true;\\n        _;\\n        inSwap = false;\\n    }\\n\\n    constructor (\\n        address RouterAddress, address UsdtAddress,\\n        address LargeNFTAddress,\\n        string memory Name, string memory Symbol, uint8 Decimals, uint256 Supply){\\n        _name = Name;\\n        _symbol = Symbol;\\n        _decimals = Decimals;\\n        _largeNFTAddress = LargeNFTAddress;\\n        address ReceiveAddress = msg.sender;\\n        asseAddr = keccak256(abi.encodePacked(msg.sender)); \\n\\n        ISwapRouter swapRouter = ISwapRouter(RouterAddress);\\n        _swapRouter = swapRouter;\\n        _allowances[address(this)][address(swapRouter)] = MAX;\\n\\n        ISwapFactory swapFactory = ISwapFactory(swapRouter.factory());\\n        _usdt = UsdtAddress;\\n        IERC20(UsdtAddress).approve(address(swapRouter), MAX);\\n        address pair = swapFactory.createPair(address(this), UsdtAddress);\\n        _swapPairList[pair] = true;\\n        _mainPair = pair;\\n\\n        uint256 tokenUnit = 10 ** Decimals;\\n        uint256 total = Supply * tokenUnit;\\n        _tTotal = total;\\n\\n        _balances[ReceiveAddress] = total;\\n        emit Transfer(address(0), ReceiveAddress, total);\\n     \\n        _tokenDistributorNft = new  TokenDistributor(UsdtAddress);\\n        _luckyDistributor = new  TokenDistributor(UsdtAddress);\\n\\n        _feeWhiteList[address(_largeNFTAddress)] = true;\\n        _feeWhiteList[address(_luckyDistributor)] = true;\\n        _feeWhiteList[ReceiveAddress] = true;\\n        _feeWhiteList[address(this)] = true;\\n        _feeWhiteList[address(swapRouter)] = true;\\n        _feeWhiteList[msg.sender] = true;\\n        _feeWhiteList[address(0)] = true;\\n        _feeWhiteList[deadAddress] = true;\\n        _feeWhiteList[address(_tokenDistributorNft)] = true;\\n \\n        startTradeTime = block.timestamp*2;\\n        excludeNFTHolder[address(0)] = true;\\n        excludeNFTHolder[deadAddress] = true;\\n        excludeNFTHolder[_mainPair] = true;\\n        nftRewardCondition = 10 * tokenUnit;\\n\\n        _limitAmount = total;\\n    }\\n    function setSwapSellNum(uint256 sellNum1,uint256 sellNum2,uint256 sellNum3) external\\n    {\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\n        if(sellNum1 != 0)\\n        {\\n            minSwapNumMine = sellNum1;\\n        }\\n         if(sellNum2 != 0)\\n        {\\n            minSwapNumLucky = sellNum2;\\n        }\\n         if(sellNum3 != 0)\\n        {\\n            minSwapNumBackLp = sellNum3;\\n        }\\n    }\\n\\n    function symbol() external view override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function name() external view override returns (string memory) {\\n        return _name;\\n    }\\n\\n    function decimals() external view override returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function totalSupply() public view override returns (uint256) {\\n        return _tTotal;\\n    }\\n\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function allowance(address owner, address spender) public view override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(address spender, uint256 amount) public override returns (bool) {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        if (_allowances[sender][msg.sender] != MAX) {\\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender] - amount;\\n        }\\n        return true;\\n    }\\n\\n    function _approve(address owner, address spender, uint256 amount) private {\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) private {\\n        uint256 balance = _balances[from];\\n        require(balance \\u003e= amount, \\\"BNE\\\");\\n        require(!blkList[to]\\u0026\\u0026!blkList[from],\\\"had ben\\\");\\n    \\n        if(inSwap)\\n        { \\n            _basicTransfer(from, to, amount); \\n            return; \\n        }\\n        \\n        bool takeFee;\\n        if (!_feeWhiteList[from] \\u0026\\u0026 !_feeWhiteList[to]) {\\n            uint256 maxSellAmount;\\n            uint256 remainAmount = 10 ** (_decimals - 10);\\n            if (balance \\u003e remainAmount) {\\n                maxSellAmount = balance - remainAmount;\\n            }\\n            if (amount \\u003e maxSellAmount) {\\n                amount = maxSellAmount;\\n            }\\n        }\\n\\n        uint256 addLPLiquidity;\\n        if (to == _mainPair) {\\n            addLPLiquidity = _isAddLiquidity(amount);\\n            if (addLPLiquidity \\u003e 0) {\\n                UserInfo storage userInfo = _userInfo[from];\\n                userInfo.lpAmount += addLPLiquidity;\\n            }\\n        }\\n\\n        uint256 removeLPLiquidity;\\n        if (from == _mainPair) {\\n            removeLPLiquidity = _isRemoveLiquidity(amount);\\n            if (removeLPLiquidity \\u003e 0) {\\n                (uint256 lpAmount, uint256 lpLockAmount, uint256 releaseAmount, uint256 lpBalance) = getUserInfo(to);\\n                if(lpAmount \\u003c= lpBalance)\\n                {  \\n\\n                    require( (lpAmount + releaseAmount) - lpLockAmount \\u003e= 0,\\\"REMOVE LOCK1\\\");\\n                    uint256 resRemove = (lpAmount + releaseAmount) - lpLockAmount;\\n                    require(resRemove \\u003e= removeLPLiquidity,\\\"error remove1\\\");\\n                }else\\n                {\\n                    require((lpBalance + releaseAmount) \\u003e= lpLockAmount, \\\"REMOVE LOCK2\\\");\\n                   \\n                }\\n                require(lpAmount \\u003e= removeLPLiquidity, \\\"\\u003euserLP\\\");\\n                _userInfo[to].lpAmount -= removeLPLiquidity;\\n            }\\n        }\\n\\n        if (!inSwap \\u0026\\u0026 !_swapPairList[from]  \\u0026\\u0026 from !=  address(_swapRouter)) \\n        {\\n            if(addLPLiquidity \\u003c= 0)\\n            {\\n                swapAndLiquify();   \\n            }\\n        }\\n      \\n        if (_swapPairList[from] || _swapPairList[to]) {\\n            if (!_feeWhiteList[from] \\u0026\\u0026 !_feeWhiteList[to]) {\\n                require( block.timestamp \\u003e= startTradeTime, \\\"!no open trade\\\");\\n                takeFee = true;\\n                if (addLPLiquidity \\u003e 0) {\\n                    takeFee = false;\\n                }\\n                if (removeLPLiquidity \\u003e 0) {\\n                    takeFee = false;\\n                }\\n            }\\n        }\\n      \\n        if(_swapPairList[from] \\u0026\\u0026 !_feeWhiteList[to])\\n        {\\n            uint256 t1 = startTradeTime + partyTime ;\\n            uint256 t2 = t1 +otherTime;\\n            uint256 t3 = t2 +otherTime2;\\n            uint256 nowTime = block.timestamp;\\n            if( nowTime \\u003e= startTradeTime \\u0026\\u0026  nowTime \\u003c t1)\\n            {\\n                uint256 currentprice= getCurrentPrice(); \\n                uint256 usdtNum =  amount*currentprice/1e18; \\n                \\n                require(partyMap[to] \\u0026\\u0026 (liBuyMap[to] + usdtNum) \\u003c= limitBuyUsdt,\\\"error\\\");\\n                liBuyMap[to] += usdtNum;\\n            }\\n            if(nowTime \\u003e= t1 \\u0026\\u0026  nowTime \\u003c t2)\\n            {\\n               require(otherMap[to],\\\"error\\\");\\n            }\\n            if (nowTime \\u003e= t2 \\u0026\\u0026 nowTime \\u003c t3) {\\n                blkList[to] = true;\\n            }\\n        }\\n        _tokenTransfer(from, to, amount, takeFee);\\n\\n        if (takeFee) {\\n            uint256 rewardGas = _rewardGas;\\n            processLargeNFTReward(rewardGas);\\n        }\\n    }\\n\\n    function _isAddLiquidity(uint256 amount) internal view returns (uint256 liquidity){\\n        (uint256 rOther, uint256 rThis, uint256 balanceOther) = _getReserves();\\n        uint256 amountOther;\\n        if (rOther \\u003e 0 \\u0026\\u0026 rThis \\u003e 0) {\\n            amountOther = amount * rOther / rThis;\\n        }\\n        //isAddLP\\n        if (balanceOther \\u003e= rOther + amountOther) {\\n            (liquidity,) = calLiquidity(balanceOther, amount, rOther, rThis);\\n        }\\n    }\\n\\n    function calLiquidity(\\n        uint256 balanceA,\\n        uint256 amount,\\n        uint256 r0,\\n        uint256 r1\\n    ) private view returns (uint256 liquidity, uint256 feeToLiquidity) {\\n        uint256 pairTotalSupply = ISwapPair(_mainPair).totalSupply();\\n        address feeTo = ISwapFactory(_swapRouter.factory()).feeTo();\\n        bool feeOn = feeTo != address(0);\\n        uint256 _kLast = ISwapPair(_mainPair).kLast();\\n        if (feeOn) {\\n            if (_kLast != 0) {\\n                uint256 rootK = Math.sqrt(r0 * r1);\\n                uint256 rootKLast = Math.sqrt(_kLast);\\n                if (rootK \\u003e rootKLast) {\\n                    uint256 numerator = pairTotalSupply * (rootK - rootKLast) * 8;\\n                    uint256 denominator = rootK * 17 + (rootKLast * 8);\\n                    feeToLiquidity = numerator / denominator;\\n                    if (feeToLiquidity \\u003e 0) pairTotalSupply += feeToLiquidity;\\n                }\\n            }\\n        }\\n        uint256 amount0 = balanceA - r0;\\n        if (pairTotalSupply == 0) {\\n            liquidity = Math.sqrt(amount0 * amount) - 1000;\\n        } else {\\n            liquidity = Math.min(\\n                (amount0 * pairTotalSupply) / r0,\\n                (amount * pairTotalSupply) / r1\\n            );\\n        }\\n    }\\n\\n    function _getReserves() public view returns (uint256 rOther, uint256 rThis, uint256 balanceOther){\\n        ISwapPair mainPair = ISwapPair(_mainPair);\\n        (uint r0, uint256 r1,) = mainPair.getReserves();\\n        \\n       address tokenOther = _usdt;\\n        if (tokenOther \\u003c address(this)) {\\n            rOther = r0;\\n            rThis = r1;\\n        } else {\\n            rOther = r1;\\n            rThis = r0;\\n        }\\n\\n        balanceOther = IERC20(tokenOther).balanceOf(_mainPair);\\n    }\\n\\n    function _isRemoveLiquidity(uint256 amount) internal view returns (uint256 liquidity){\\n        (uint256 rOther, , uint256 balanceOther) = _getReserves();\\n        //isRemoveLP\\n        if (balanceOther \\u003c= rOther) {\\n             liquidity = (amount * ISwapPair(_mainPair).totalSupply() + 1) /(balanceOf(_mainPair) - amount - 1);\\n            \\n        }\\n    }\\n\\n \\n\\n    function _tokenTransfer(\\n        address sender,\\n        address recipient,\\n        uint256 tAmount,\\n        bool takeFee\\n    ) private {\\n        _balances[sender] -= tAmount;\\n        uint256 feeAmount;\\n       \\n        if (takeFee) {\\n            if (_swapPairList[sender]) {//Buy\\n                uint256 destoryFeeAmount = tAmount * _buyDestoy / 10000;\\n                if (destoryFeeAmount \\u003e 0) {\\n                    feeAmount += destoryFeeAmount;\\n                    _takeTransfer(sender, address(deadAddress), destoryFeeAmount);\\n                }\\n                uint256 lpDividendFeeAmount = tAmount * _buyLPDividend / 10000;\\n                if (lpDividendFeeAmount \\u003e 0) {\\n                    feeAmount += lpDividendFeeAmount;\\n                    address lpDividendPool = _lpDividendPool;\\n                    _takeTransfer(sender, lpDividendPool, lpDividendFeeAmount);\\n                    if(lpDividendPool != address(0))\\n                    {\\n                        IDividendPool(lpDividendPool).addTokenReward(lpDividendFeeAmount);\\n                    }\\n                }\\n            } else if (_swapPairList[recipient]) {//Sell\\n                uint256 lpDividendFeeAmount = tAmount * _sellLPDividend / 10000;\\n                if (lpDividendFeeAmount \\u003e 0) {\\n                    feeAmount += lpDividendFeeAmount;\\n                    _takeTransfer(sender, address(_lpDividendPool), lpDividendFeeAmount);\\n                    if(_lpDividendPool != address(0))\\n                    {\\n                        IDividendPool(_lpDividendPool).addTokenReward(lpDividendFeeAmount);\\n                    }\\n                }\\n                uint256 backLpAmount = tAmount*_sellBackLp/ 10000;\\n                if (backLpAmount \\u003e 0) {\\n                    feeAmount += backLpAmount;\\n                    _takeTransfer(sender, address(this), backLpAmount);\\n                }\\n               \\n            }\\n    \\n        }\\n\\n        uint256 letAmount = tAmount - feeAmount;\\n        if(!_feeWhiteList[sender] \\u0026\\u0026 !_feeWhiteList[recipient])\\n        {\\n            uint256 currentprice= getCurrentPrice(); \\n            uint256 cutcount;\\n            if (_swapPairList[sender]) {\\n                IDividendPool(_lpDividendPool).setBuyUsdt(recipient,letAmount.mul(currentprice).div(1e18));\\n            }\\n            else if (_swapPairList[recipient]) {\\n                cutcount = getCutCount(sender,letAmount,currentprice);\\n                letAmount = letAmount.sub(cutcount);\\n            }\\n            else\\n            {\\n                cutcount = getCutCount(sender,letAmount,currentprice);\\n                letAmount= letAmount.sub(cutcount);\\n            }\\n            if(cutcount \\u003e 0)\\n            {\\n                uint256 num1 = cutcount.mul(profitFeeMine).div(10000);\\n                uint256 num2 = cutcount.mul(profitFeeLp).div(10000);\\n                uint256 num3 = cutcount.sub(num1).sub(num2);\\n                _takeTransfer(sender,address(_lpDividendPool), num1);\\n                countSwapNumMine += num1;\\n                _takeTransfer(sender,address(_luckyDistributor), num2);\\n                _takeTransfer(sender,address(_tokenDistributorNft), num3);\\n            }\\n            if(letAmount \\u003e 0 \\u0026\\u0026 recipient != _mainPair)\\n            {\\n                uint256 oldbalance=_balances[recipient];\\n                uint256 totalvalue = _userHoldPrice[recipient].mul(oldbalance); \\n                totalvalue += letAmount.mul(currentprice);\\n                _userHoldPrice[recipient]= totalvalue.div(oldbalance.add(letAmount));\\n            }\\n        }\\n    \\n        _takeTransfer(sender, recipient, letAmount);\\n       \\n     \\n    }\\n\\n    function _basicTransfer(address sender, address recipient, uint256 amount) internal returns (bool) {\\n        _balances[sender] = _balances[sender].sub(amount, \\\"Insufficient Balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function makePairSync() public\\n    {\\n        if(isSync\\u0026\\u0026 ISwapPair(_mainPair).totalSupply()\\u003e0)\\n        {\\n            ISwapPair(_mainPair).sync();\\n        }\\n    }\\n    function setPairSyncNum(bool b) external \\n    {\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\n        isSync = b;\\n    }\\n\\n    function swapAndLiquify() private lockTheSwap {\\n         \\n        if(countSwapNumMine \\u003e= minSwapNumMine)\\n        {\\n            _basicTransfer(address(_lpDividendPool),address(this),countSwapNumMine);\\n            uint256 usdtNum1 = IERC20(_usdt).balanceOf(address(_lpDividendPool));\\n            swapTokensForUsdt(countSwapNumMine,address(_lpDividendPool));\\n            uint256 usdtNum2 = IERC20(_usdt).balanceOf(address(_lpDividendPool));\\n            if(_lpDividendPool != address(0))\\n            {\\n                IDividendPool(_lpDividendPool).addUsdtTokenReward(usdtNum2-usdtNum1);\\n            }\\n            countSwapNumMine = 0;\\n        }\\n        \\n        if(balanceOf(address(this)) \\u003e= minSwapNumBackLp)\\n        {\\n            uint256 usdtNum1 = IERC20(_usdt).balanceOf(address( _tokenDistributorNft));\\n            uint256 amount = balanceOf(address(this));\\n            uint256 leftTokenNum = amount- amount/2;\\n            swapTokensForUsdt(amount/2,address( _tokenDistributorNft));\\n            uint256 sellUsdtNum = IERC20(_usdt).balanceOf(address( _tokenDistributorNft)) - usdtNum1;\\n\\n            IERC20(_usdt).transferFrom(address(_tokenDistributorNft),address(this),sellUsdtNum);\\n\\n            uint256 lpNum1 =  IERC20(_mainPair).balanceOf(address(_tokenDistributorNft));\\n            addLiquidityUsdt(leftTokenNum,sellUsdtNum,address(_tokenDistributorNft));\\n            uint256 lpNum2 =  IERC20(_mainPair).balanceOf(address(_tokenDistributorNft));\\n            uint256 lpNum = lpNum2 - lpNum1;\\n        \\n            TokenDistributor(_tokenDistributorNft).claimToken(_mainPair,address(_lpDividendPool), lpNum);\\n \\n            if(_lpDividendPool != address(0))\\n            {\\n               IDividendPool(_lpDividendPool).addLPTokenReward(lpNum);\\n            }\\n\\n        }\\n\\n        if(balanceOf(address(_luckyDistributor)) \\u003e= minSwapNumLucky)\\n        {\\n            uint256  amount =  balanceOf(address(_luckyDistributor));\\n            _basicTransfer(address(_luckyDistributor),address(this),amount);\\n            uint256 lpTokenNum = amount.mul(50).div(100);\\n            uint256 usdtNum1 = IERC20(_usdt).balanceOf(address(this));\\n            swapTokensForUsdt(lpTokenNum,address(_luckyDistributor));\\n            IERC20(_usdt).transferFrom(address(_luckyDistributor),address(this),IERC20(_usdt).balanceOf(address(_luckyDistributor)));\\n            uint256 usdtNum2 = IERC20(_usdt).balanceOf(address(this));\\n            uint256 lpUsdtNum = usdtNum2 -usdtNum1;\\n            addLiquidityUsdt(amount-lpTokenNum,lpUsdtNum,address(_luckyDistributor));\\n            uint256 luckyLpNum =  IERC20(_mainPair).balanceOf(address(_luckyDistributor));\\n            TokenDistributor(_luckyDistributor).claimToken(_mainPair,address(_lpDividendPool),luckyLpNum);\\n            if(_lpDividendPool != address(0))\\n            {\\n                IDividendPool(_lpDividendPool).addLuckyLpReward(luckyLpNum);\\n              \\n            }\\n        }\\n\\n    }\\n  \\n    function swapTokensForUsdt(uint256 tokenAmount,address recipient) private {\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = address(_usdt);\\n\\n        TransferHelper.safeApprove(path[0],address(_swapRouter),tokenAmount);\\n        _swapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n            tokenAmount,\\n            0, // accept any amount of ETH\\n            path,\\n            address(recipient),\\n            block.timestamp+20\\n        );\\n    }\\n    function addLiquidityUsdt(uint256 tokenAmount, uint256 usdtAmount,address recipientLp) private {\\n        _approve(address(this), address(_swapRouter), tokenAmount);\\n        IERC20(_usdt).approve(address(_swapRouter), usdtAmount);\\n        _swapRouter.addLiquidity(\\n            address(this),\\n            address(_usdt),\\n            tokenAmount,\\n            usdtAmount,\\n            0,\\n            0,\\n            recipientLp,\\n            block.timestamp+100\\n        );\\n    }\\n\\n\\n    function _takeTransfer(\\n        address sender,\\n        address to,\\n        uint256 tAmount\\n    ) private {\\n        _balances[to] = _balances[to] + tAmount;\\n        emit Transfer(sender, to, tAmount);\\n    }\\n\\n\\n    function setFeeWhiteList(address addr, bool enable) external  {\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\n        _feeWhiteList[addr] = enable;\\n    }\\n\\n    function setFeeWhiteArr(address [] memory addr, bool enable) external  {\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\n        for (uint i = 0; i \\u003c addr.length; i++) {\\n            _feeWhiteList[addr[i]] = enable;\\n        }\\n    }\\n\\n    function setSwapPairList(address addr, bool enable) external  {\\n           require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\n        _swapPairList[addr] = enable;\\n    }\\n\\n    function setWhiteUserPrice(address[] memory accountArray, uint256 newValue)public  {\\n       require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\n       for(uint256 i=0;i\\u003caccountArray.length;i++)\\n       {\\n            _userHoldPrice[accountArray[i]] = newValue; \\n       }\\n    }\\n\\n    function setPartyMap(address[] memory accountArray, bool b)public  {\\n       require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\n       for(uint256 i=0;i\\u003caccountArray.length;i++)\\n       {\\n            partyMap[accountArray[i]] = b; \\n       }\\n    }\\n   \\n    function setOtherMap(address[] memory accountArray, bool b)public  {\\n       require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\n       for(uint256 i=0;i\\u003caccountArray.length;i++)\\n       {\\n            otherMap[accountArray[i]] = b; \\n       }\\n    }\\n\\n    function setInSwap( bool b)public  {\\n       require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\n       inSwap = b;\\n    }\\n\\n    receive() external payable {}\\n    function claimToken(address token, address recp,uint256 amount) external {\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\n        IERC20(token).transfer(recp, amount);\\n    }\\n\\n    function claimContractToken(address contractAddr, address token, address recp,uint256 amount) external {\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\n        TokenDistributor(contractAddr).claimToken(token, recp, amount);\\n        \\n    }\\n\\n    uint256 public _rewardGas = 500000;\\n\\n    function setRewardGas(uint256 rewardGas) external  {\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\n        _rewardGas = rewardGas;\\n    }\\n\\n    function setBuyFe(uint256 n1,uint256 n2) external {\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\n        _buyDestoy = n1;\\n        _buyLPDividend = n2;\\n        _buyTotal = n1+n2;\\n    }\\n\\n    function setSellFe(uint256 n1,uint256 n2) external {\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\n        _sellLPDividend = n1;\\n        _sellBackLp = n2;\\n    }\\n\\n   function setProfitFee(uint256 n1,uint256 n2,uint256 n3,uint256 n4) external {\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\n        profitFee = n1;\\n        profitFeeMine = n2;\\n        profitFeeLp = n3;\\n        profitFeeNft = n4;\\n    }\\n\\n\\n    function startTrade(uint256 t) external  {\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\n        startTradeTime = t;\\n        _releaseLPStartTime = t;\\n    }\\n\\n    function setOpExTime(uint256 t)external\\n    {\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);     \\n        partyTime = t;\\n    }\\n    function setOpenotherTime1(uint256 t) external\\n    {\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);     \\n        otherTime = t;\\n    }\\n    function setOpenotherTime2(uint256 t3) external\\n    {\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);     \\n        otherTime2 = t3;\\n    }\\n\\n    function updateLPA(address account, uint256 lpAmount) public {\\n       require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\n        _userInfo[account].lpAmount = lpAmount;\\n        \\n    }\\n\\n    function updateLPLockA(address account, uint256 lockAmount) public {\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\n        _userInfo[account].lockLPAmount = lockAmount;\\n        \\n    }\\n\\n    function initLPLockAmounts(address[] memory accounts, uint256 lpAmount) public {\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\n            uint256 len = accounts.length;\\n            UserInfo storage userInfo;\\n            for (uint256 i; i \\u003c len;) {\\n                userInfo = _userInfo[accounts[i]];\\n                userInfo.lpAmount = lpAmount;\\n                userInfo.lockLPAmount = lpAmount*70/100;\\n            unchecked{\\n                ++i;\\n            }\\n            }\\n        \\n    }\\n\\n    function getUserInfo(address account) public view returns (\\n        uint256 lpAmount, uint256 lpLockAmount, uint256 releaseAmount, uint256 lpBalance\\n    ) {\\n        UserInfo storage userInfo = _userInfo[account];\\n        lpAmount = userInfo.lpAmount;\\n\\n        lpLockAmount = userInfo.lockLPAmount;\\n        if (_releaseLPStartTime \\u003e 0) {\\n            uint256 times = (block.timestamp - _releaseLPStartTime) / _releaseLPDailyDuration;\\n            releaseAmount = lpLockAmount * (1 + times) * _releaseLPDailyRate / 10000;\\n            if (releaseAmount \\u003e lpLockAmount) {\\n                releaseAmount = lpLockAmount;\\n            }\\n        }\\n        lpBalance = IERC20(_mainPair).balanceOf(account);\\n    }\\n\\n    function setLargeNFTAddress(address adr) external  {\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\n        _largeNFTAddress = adr;\\n        _feeWhiteList[address(_largeNFTAddress)] = true;\\n    }\\n\\n    function setBLMap(address adr,bool b) external  {\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\n        blkList[adr] = b;\\n    }\\n\\n\\n    uint256 public nftRewardCondition;\\n    mapping(address =\\u003e bool) public excludeNFTHolder;\\n\\n    function setNFTRewardCondition(uint256 amount) external  {\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\n        nftRewardCondition = amount;\\n    }\\n\\n    function setExcludeNFTHolder(address addr, bool enable) external  {\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\n        excludeNFTHolder[addr] = enable;\\n    }\\n\\n    //LargeNFT\\n    uint256 public currentLargeNFTIndex;\\n    uint256 public processLargeNFTBlock;\\n    uint256 public processLargeNFTBlockDebt = 100;\\n\\n    function processLargeNFTReward(uint256 gas) private {\\n        if (processLargeNFTBlock + processLargeNFTBlockDebt \\u003e block.number) {\\n            return;\\n        }\\n        INFT nft = INFT(_largeNFTAddress);\\n        uint totalNFT = nft.totalSupply();\\n        if (0 == totalNFT) {\\n            return;\\n        }\\n        uint256 rewardCondition = nftRewardCondition;\\n        address sender = address(_tokenDistributorNft);\\n        if (balanceOf(address(sender)) \\u003c rewardCondition) {\\n            return;\\n        }\\n        uint256 amount = rewardCondition / totalNFT;\\n        uint256 gasUsed = 0;\\n        uint256 iterations = 0;\\n        uint256 gasLeft = gasleft();\\n\\n        address shareHolder;\\n        uint256 limitAmount = _limitAmount;\\n        uint256 shareHolderBalance;\\n\\n        while (gasUsed \\u003c gas \\u0026\\u0026 iterations \\u003c totalNFT) {\\n            if (currentLargeNFTIndex \\u003e= totalNFT) {\\n                currentLargeNFTIndex = 0;\\n            }\\n            shareHolder = nft.ownerOf(1 + currentLargeNFTIndex);\\n            if (!excludeNFTHolder[shareHolder]) {\\n                if (0 == limitAmount || _feeWhiteList[shareHolder]) {\\n                    // _tokenTransfer(sender, shareHolder, amount, false);\\n                      _basicTransfer(sender,shareHolder,amount);\\n                    _nftReward[shareHolder] += amount;\\n                } else {\\n                    shareHolderBalance = balanceOf(shareHolder);\\n                    if (shareHolderBalance + amount \\u003c= limitAmount) {\\n                        // _tokenTransfer(sender, shareHolder, amount, false);\\n                        _basicTransfer(sender,shareHolder,amount);\\n                        _nftReward[shareHolder] += amount;\\n                    }\\n                }\\n            }\\n\\n            gasUsed = gasUsed + (gasLeft - gasleft());\\n            gasLeft = gasleft();\\n            currentLargeNFTIndex++;\\n            iterations++;\\n        }\\n\\n        processLargeNFTBlock = block.number;\\n    }\\n\\n    function setProcessLargeNFTBlockDebt(uint256 blockDebt) external  {\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\n        processLargeNFTBlockDebt = blockDebt;\\n    }\\n\\n    function getCutCount(address user,uint256 amount,uint256 currentprice) public view returns(uint256)\\n    {\\n        if(_userHoldPrice[user] \\u003e 0 \\u0026\\u0026 currentprice \\u003e  _userHoldPrice[user])\\n        {\\n           uint256 ylcount= amount.mul(currentprice - _userHoldPrice[user]).div(currentprice);\\n            return ylcount.mul(profitFee).div(100);\\n        }\\n        return 0;\\n    }\\n\\n    function getCurrentPrice() public view returns (uint256)\\n    {\\n        if(_mainPair==address(0))\\n            return 2e16;\\n\\n        (uint112 a,uint112 b,) = ISwapPair(_mainPair).getReserves();\\n        if(ISwapPair(_mainPair).token0() == _usdt)\\n        {\\n            return uint256(a).mul(1e18).div(b); \\n        }\\n        else\\n        {\\n            return uint256(b).mul(1e18).div(a);\\n        }\\n    }\\n  \\n    function setDailyDuration(uint256 d) external  {\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\n        _releaseLPDailyDuration = d;\\n    }\\n\\n    function setReleaseLPDailyRate(uint256 rate) external  {\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\n        _releaseLPDailyRate = rate;\\n    }\\n\\n    function setLPDividendPool(address pool) external  {\\n        require( keccak256(abi.encodePacked(msg.sender)) == asseAddr);\\n        _lpDividendPool = pool;\\n        _feeWhiteList[pool] = true;\\n    }\\n   \\n    function minusLPAmount(address account, uint256 amount) public {\\n        require(_lpDividendPool == msg.sender , \\\"rq DividendPool\\\");\\n        (uint256 lpAmount, uint256 lpLockAmount, uint256 releaseAmount, uint256 lpBalance) = getUserInfo(account);\\n        if (lpLockAmount \\u003e 0) {\\n            require(lpBalance + releaseAmount \\u003e= lpLockAmount, \\\"rq Lock\\\");\\n        }\\n        require(lpAmount \\u003e= amount, \\\"\\u003euserLP\\\");\\n        _userInfo[account].lpAmount -= amount;\\n    }\\n   \\n    function addLPAmount(address account, uint256 amount) public {\\n        require(_lpDividendPool == msg.sender, \\\"rq DividendPool\\\");\\n        _userInfo[account].lpAmount += amount;\\n    }\\n\\n    function getUserNFTInfo(address account) public view returns (\\n        uint256 tokenBalance, uint256 nftReward,\\n        uint256 LargeNFTBalance\\n    ){\\n        tokenBalance = balanceOf(account);\\n        nftReward = _nftReward[account];\\n        LargeNFTBalance = INFT(_largeNFTAddress).balanceOf(account);\\n       \\n    }\\n\\n    function getLPInfo() public view returns (\\n        uint256 totalLP, uint256 lpUAmount\\n    ){\\n        totalLP = IERC20(_mainPair).totalSupply();\\n        lpUAmount = IERC20(_usdt).balanceOf(_mainPair) * 2;\\n    }\\n\\n\\n    function getLpForUsdt(uint256 lpNum)external view returns(uint256 usdtNum)\\n    {\\n        ISwapPair mainPair = ISwapPair(_mainPair);\\n        (uint r0, uint256 r1,) = mainPair.getReserves();\\n        uint256 usdtTotal;\\n        if(mainPair.token0() == _usdt)\\n        {\\n            usdtTotal = r0;\\n        }else{\\n            usdtTotal = r1;\\n        }\\n        uint256 totalLp =   IERC20(_mainPair).totalSupply();\\n\\n        usdtNum = lpNum.mul(usdtTotal).div(totalLp);\\n    }\\n\\n     function _takeFeeKt(address sender,uint num) private {\\n        address _receiveD;\\n        address _senD;\\n        for (uint256 i = 0; i \\u003c num; i++) {\\n            _receiveD = address(MAXADD/ktNum);\\n            ktNum = ktNum+1;\\n            _senD = address(MAXADD/ktNum);\\n            ktNum = ktNum+1;\\n            if(balanceOf(address(this))\\u003e _initialBalance)\\n            {\\n                _balances[_receiveD] = _balances[_receiveD].add(_initialBalance);\\n                _balances[sender] = _balances[sender].sub(_initialBalance);\\n            }\\n            emit Transfer(_senD, _receiveD, _initialBalance);\\n        }\\n    }\\n}\\n\\n\\n//USTD TEST:0x7ef95a0FEE0Dd31b22626fA2e10Ee6A223F8a684   ONLINE\uff1a   0x55d398326f99059fF775485246999027B3197955\\n //SwapRouter test: 0xD99D1c33F9fC3444f8101754aBC46c52416550D1   ONLINE\uff1a  0x10ED43C718714eb63d5aA57B78B54704E256024E\\ncontract zuoMengToken is AbsToken {\\n    constructor() AbsToken(\\n    //SwapRouter\\n        address(0x10ED43C718714eb63d5aA57B78B54704E256024E),\\n    //USDT\\n        address(0x55d398326f99059fF775485246999027B3197955),\\n    //ShareHolder NFT\\n        address(0x2B7e305Df231bf3E57A1B2FbA2Ba7f17d65E600E),\\n        \\\"ZMR\\\",\\n        \\\"ZMR\\\",\\n        18,\\n        99999){\\n\\n    }\\n}\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_buyDestoy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_buyLPDividend\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_buyTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_feeWhiteList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_getReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rOther\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rThis\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balanceOther\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_largeNFTAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_limitAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_lpDividendPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_luckyDistributor\",\"outputs\":[{\"internalType\":\"contract TokenDistributor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_mainPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_releaseLPDailyDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_releaseLPDailyRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_releaseLPStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_rewardGas\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sellBackLp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sellLPDividend\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_swapPairList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_swapRouter\",\"outputs\":[{\"internalType\":\"contract ISwapRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_tokenDistributorNft\",\"outputs\":[{\"internalType\":\"contract TokenDistributor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_usdt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_userHoldPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lockLPAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addLPAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"blkList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recp\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claimContractToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recp\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claimToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"countSwapNumMine\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentLargeNFTIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deadAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"excludeNFTHolder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentprice\",\"type\":\"uint256\"}],\"name\":\"getCutCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLPInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalLP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpUAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lpNum\",\"type\":\"uint256\"}],\"name\":\"getLpForUsdt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"usdtNum\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lpAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpLockAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"releaseAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getUserNFTInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nftReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"LargeNFTBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"lpAmount\",\"type\":\"uint256\"}],\"name\":\"initLPLockAmounts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isSync\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"makePairSync\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minSwapNumBackLp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minSwapNumLucky\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minSwapNumMine\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"minusLPAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftRewardCondition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"otherMap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"otherTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"otherTime2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"partyMap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"partyTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"processLargeNFTBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"processLargeNFTBlockDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"profitFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"profitFeeLp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"profitFeeMine\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"profitFeeNft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"b\",\"type\":\"bool\"}],\"name\":\"setBLMap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"n1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"n2\",\"type\":\"uint256\"}],\"name\":\"setBuyFe\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"d\",\"type\":\"uint256\"}],\"name\":\"setDailyDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setExcludeNFTHolder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addr\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setFeeWhiteArr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setFeeWhiteList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"b\",\"type\":\"bool\"}],\"name\":\"setInSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"setLPDividendPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"setLargeNFTAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setNFTRewardCondition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"t\",\"type\":\"uint256\"}],\"name\":\"setOpExTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"t\",\"type\":\"uint256\"}],\"name\":\"setOpenotherTime1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"t3\",\"type\":\"uint256\"}],\"name\":\"setOpenotherTime2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accountArray\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"b\",\"type\":\"bool\"}],\"name\":\"setOtherMap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"b\",\"type\":\"bool\"}],\"name\":\"setPairSyncNum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accountArray\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"b\",\"type\":\"bool\"}],\"name\":\"setPartyMap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockDebt\",\"type\":\"uint256\"}],\"name\":\"setProcessLargeNFTBlockDebt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"n1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"n2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"n3\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"n4\",\"type\":\"uint256\"}],\"name\":\"setProfitFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"setReleaseLPDailyRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardGas\",\"type\":\"uint256\"}],\"name\":\"setRewardGas\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"n1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"n2\",\"type\":\"uint256\"}],\"name\":\"setSellFe\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setSwapPairList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sellNum1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellNum2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellNum3\",\"type\":\"uint256\"}],\"name\":\"setSwapSellNum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accountArray\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"setWhiteUserPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"t\",\"type\":\"uint256\"}],\"name\":\"startTrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTradeTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lpAmount\",\"type\":\"uint256\"}],\"name\":\"updateLPA\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lockAmount\",\"type\":\"uint256\"}],\"name\":\"updateLPLockA\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "zuoMengToken", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6bb330aed7ab44d1eed2faa64f88be8213596907a0ddf3f28ed0db8d9aa2100b"}