{"SourceCode": "pragma solidity 0.8.12;\r\n\r\ninterface IPair {\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    function name() external pure returns (string memory);\r\n\r\n    function symbol() external pure returns (string memory);\r\n\r\n    function decimals() external pure returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\r\n    event Burn(\r\n        address indexed sender,\r\n        uint256 amount0,\r\n        uint256 amount1,\r\n        address indexed to\r\n    );\r\n    event Swap(\r\n        address indexed sender,\r\n        uint256 amount0In,\r\n        uint256 amount1In,\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\r\n\r\n    function factory() external view returns (address);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves()\r\n        external\r\n        view\r\n        returns (\r\n            uint112 reserve0,\r\n            uint112 reserve1,\r\n            uint32 blockTimestampLast\r\n        );\r\n\r\n    function price0CumulativeLast() external view returns (uint256);\r\n\r\n    function price1CumulativeLast() external view returns (uint256);\r\n\r\n    function kLast() external view returns (uint256);\r\n\r\n    function mint(address to) external returns (uint256 liquidity);\r\n\r\n    function burn(address to)\r\n        external\r\n        returns (uint256 amount0, uint256 amount1);\r\n\r\n    function swap(\r\n        uint256 amount0Out,\r\n        uint256 amount1Out,\r\n        address to,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function skim(address to) external;\r\n\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\nabstract contract OwnershipManager {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor(address initialOwner) {\r\n        _transferOwnership(initialOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(\r\n            owner() == msg.sender,\r\n            \"OwnershipManager: caller is not the owner\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"OwnershipManager: new owner is the zero address\"\r\n        );\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * ////IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\ninterface IQuintConventionalPool {\r\n    function userTokenStakeInfo(address _user)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 _amount,\r\n            uint256 _time,\r\n            uint256 _reward,\r\n            uint256 _startTime\r\n        );\r\n\r\n    function userLpStakeInfo(address _user)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 _lpAmount,\r\n            uint256 _amount,\r\n            uint256 _time,\r\n            uint256 _reward,\r\n            uint256 _startTime\r\n        );\r\n\r\n    function getUserInfo(address _user)\r\n        external\r\n        view\r\n        returns (\r\n            bool _isExists,\r\n            uint256 _stakeCount,\r\n            uint256 _totalStakedToken,\r\n            uint256 _totalStakedLp,\r\n            uint256 _totalWithdrawanToken,\r\n            uint256 _totalWithdrawanLp\r\n        );\r\n}\r\n\r\n/**\r\n * @notice Token staking pool enables users to stake their tokens,\r\n *         to earn % APY for providing their tokens to the staking pool.\r\n */\r\ncontract QuintStakingPool is OwnershipManager {\r\n    struct StakingDetails {\r\n        uint256 stakedAt;\r\n        uint256 tokenAmount;\r\n        uint256 rewardedAt;\r\n    }\r\n    // Tracking of internal account level staking details.\r\n    mapping(address => StakingDetails) public stakingDetails;\r\n\r\n    struct AccountDetails {\r\n        uint256 totalStakedTokens;\r\n        uint256 totalUnstakedTokens;\r\n        uint256 totalStakeEntries;\r\n        uint256 totalHarvestedRewards;\r\n    }\r\n    // Tracking of global account level staking details.\r\n    mapping(address => AccountDetails) public accountDetails;\r\n\r\n    // Tracking of account migrations.\r\n    mapping(address => bool) public isMigrated;\r\n\r\n    // Staking Pool token dependency.\r\n    IERC20 public immutable QUINT_TOKEN;\r\n    \r\n    // Staking pool migration dependency.\r\n    IQuintConventionalPool public legacyStakingPool;\r\n\r\n    // Tracking of staking pool details.\r\n    uint256 public totalStakedTokens;\r\n    uint256 public totalUniqueStakers;\r\n    uint256 public totalHarvestedRewards;\r\n    uint256 public totalUnstakedTokens;\r\n\r\n    // Staking pool % APY configurations.\r\n    uint256 public rewardMultiplier = 5262;\r\n    uint256 public rewardDivider = 1e12;\r\n\r\n    // Staking pool account requirements.\r\n    uint256 public minimumStakingAmount = 1e16;\r\n\r\n    // Staking pool taxation settings.\r\n    uint256 public unstakeTaxRemovedAt = 15 days;\r\n    uint256 public unstakeTaxPercentage = 20;\r\n\r\n    // Tracking of taxation exempts on accounts.\r\n    mapping(address => bool) public isExemptFromTaxation;\r\n\r\n    // Tracking of banned accounts\r\n    mapping(address => bool) public isBanned;\r\n\r\n    // Staking pool reward provisioning distributor endpoint.\r\n    address payable public rewardVault;\r\n\r\n    // Emergency state\r\n    bool public isPaused;\r\n    bool public isEmergencyWithdrawEnabled;\r\n\r\n    // Staking pool events to log core functionality.\r\n    event Migrated(address indexed staker, uint256 indexed amount);\r\n    event Staked(address indexed staker, uint256 amount);\r\n    event Unstaked(address indexed staker, uint256 amount);\r\n    event Harvested(address indexed staker, uint256 rewards);\r\n    event Exempted(address indexed staker, bool isExempt);\r\n    event Banned(address indexed staker, bool isBanned);\r\n    event Paused(bool isPaused);\r\n    event EmergencyWithdrawalEnabled(bool isEnabled);\r\n    event EmergencyWithdrawn(\r\n        address indexed staker,\r\n        uint256 tokenAmount,\r\n        uint256 stakedAt,\r\n        uint256 rewardedAt\r\n    );\r\n\r\n\r\n    modifier onlyIfNotPaused() {\r\n        require(!isPaused, \"QuintWBNBStakingPool: all actions are paused\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfNotBanned() {\r\n        require(!isBanned[msg.sender], \"QuintWBNBStakingPool: account banned\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Initialize contract by deploying a staking pool and setting\r\n     *      up external dependencies.\r\n     *\r\n     * @param initialOwner --> The manager of access restricted functionality.\r\n     * @param rewardToken --> The token that will be rewarded for staking in the pool.\r\n     * @param distributor --> The reward distribution endpoint that will do reward provisioning.\r\n     */\r\n    constructor(\r\n        address payable initialOwner,\r\n        address rewardToken,\r\n        address payable distributor,\r\n        address legacyPool\r\n    ) OwnershipManager(initialOwner) {\r\n        QUINT_TOKEN = IERC20(rewardToken);\r\n        rewardVault = distributor;\r\n        legacyStakingPool = IQuintConventionalPool(legacyPool); \r\n    }\r\n\r\n    /**\r\n     * @notice Set the staking pool APY configurations, the reward multiplier and\r\n     *         reward divider forms the % APY rewarded from the staking pool.\r\n     *\r\n     * @param newRewardMultiplier --> The multiplier used for reward calculations.\r\n     * @param newRewardDivider --> The divider used for reward calculations.\r\n     */\r\n    function SetPoolAPYSettings(\r\n        uint256 newRewardMultiplier,\r\n        uint256 newRewardDivider\r\n    ) external onlyOwner {\r\n        rewardMultiplier = newRewardMultiplier;\r\n        rewardDivider = newRewardDivider;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the minimum token staking requirement,\r\n     *         the account must comply with the minimum to stake.\r\n     *\r\n     * @param newMinimumStakingAmount --> The minimum token amount for entry.\r\n     */\r\n    function SetMinimumStakingAmount(uint256 newMinimumStakingAmount)\r\n        external\r\n        onlyOwner\r\n    {\r\n        minimumStakingAmount = newMinimumStakingAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Set exempt taxation on an account,\r\n     *         exempted accounts are not obligued to taxation.\r\n     *\r\n     * @param account --> The account to exempt from taxation.\r\n     * @param isExempt --> The exempt taxation state of an account.\r\n     */\r\n    function SetExemptFromTaxation(address account, bool isExempt)\r\n        external\r\n        onlyOwner\r\n    {\r\n        isExemptFromTaxation[account] = isExempt;\r\n        emit Exempted(account, isExempt);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the staking pool taxation settings, the staking pool\r\n     *         punishes premature withdrawal from the staking pool.\r\n     *\r\n     * @param newUnstakeTaxPercentage --> The new taxation percentage from unstaking.\r\n     * @param newUnstakeTaxRemovedAt --> The new duration for taxation of rewards.\r\n     */\r\n    function SetUnstakeTaxAndDuration(\r\n        uint256 newUnstakeTaxPercentage,\r\n        uint256 newUnstakeTaxRemovedAt\r\n    ) external onlyOwner {\r\n        unstakeTaxPercentage = newUnstakeTaxPercentage;\r\n        unstakeTaxRemovedAt = newUnstakeTaxRemovedAt;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the reward provisioning endpoint,\r\n     *         this should be the distributor that handle rewards.\r\n     *\r\n     * @param newRewardVault --> The new distributor for reward provisioning.\r\n     */\r\n    function setRewardVault(address payable newRewardVault) external onlyOwner {\r\n        rewardVault = newRewardVault;\r\n    }\r\n\r\n    /**\r\n     * @notice Set restrictions on an account.\r\n     *\r\n     * @param account --> The account to restrict.\r\n     * @param state --> The state of the restriction.\r\n     */\r\n    function setBanState(address account, bool state) external onlyOwner {\r\n        isBanned[account] = state;\r\n        emit Banned(account, state);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the staking pool in a pause.\r\n     *\r\n     * @param state --> The state of the staking pool.\r\n     */\r\n    function setPoolPauseState(bool state) external onlyOwner {\r\n        isPaused = state;\r\n        emit Paused(state);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the staking pool withdrawals into emergency.\r\n     *\r\n     * @param state --> The state of the emergency.\r\n     */\r\n    function setAllowEmergencyWithdraw(bool state) external onlyOwner {\r\n        isEmergencyWithdrawEnabled = state;\r\n        emit EmergencyWithdrawalEnabled(state);\r\n    }\r\n\r\n    /**\r\n     * @notice Migrate accumulated rewards from the legacy pool,\r\n     *         the account must not be migrated already.\r\n     */\r\n    function migrate() external onlyIfNotPaused onlyIfNotBanned {\r\n        address account = msg.sender;\r\n\r\n        // Fetch global staking state of account from legacy pool.\r\n        (bool isStaking, , , , , ) = legacyStakingPool.getUserInfo(account);\r\n        \r\n        // Check if account is staked in the legacy pool.\r\n        require(isStaking,\r\n        \"QuintConventionalPool: must be staking\"\r\n        );\r\n\r\n        // Check if the account is migrated already.\r\n        require(\r\n            !isMigrated[account], \r\n            \"QuintStakingPool: already migrated\"\r\n        );\r\n\r\n        // Check if the account is unique, if yes then add it to global tracking.\r\n        if (accountDetails[account].totalStakeEntries == 0)\r\n            totalUniqueStakers++;\r\n\r\n        uint256 rewards;\r\n\r\n        // Fetch legacy reward accumulations for account from legacy pool.\r\n        (uint256 tokenAmount, uint256 tokenTime, , ) = legacyStakingPool.userTokenStakeInfo(account);\r\n        \r\n        // Check if account is staked in the legacy pool.\r\n        if (tokenAmount > 0) {\r\n            uint256 rewardDuration = block.timestamp - tokenTime;\r\n            \r\n            // Calculate the reward rate of an account.\r\n            rewards =\r\n                (tokenAmount *\r\n                    rewardDuration *\r\n                    rewardMultiplier) /\r\n                rewardDivider;\r\n        }\r\n\r\n        // Check if the legacy rewards are larger than zero.\r\n        require(rewards > 0, \"QuintStakingPool: no rewards to migrate\");\r\n        QUINT_TOKEN.transferFrom(rewardVault, address(this), rewards);\r\n\r\n        // Update internal account staking details.\r\n        isMigrated[account] = true;\r\n        stakingDetails[account].tokenAmount += rewards;\r\n        stakingDetails[account].stakedAt = block.timestamp;\r\n        stakingDetails[account].rewardedAt = block.timestamp;\r\n\r\n        // Update global account staking details.\r\n        accountDetails[account].totalStakeEntries++;\r\n        accountDetails[account].totalStakedTokens += rewards;\r\n\r\n        // Update global staking pool details.\r\n        totalStakedTokens += rewards;\r\n        \r\n        // Log successful activity.\r\n        emit Migrated(account, rewards);\r\n    }\r\n\r\n    /**\r\n     * @notice Stake tokens to accumulate token rewards,\r\n     *         token reward accumulation is based on the % APY.\r\n     *\r\n     * @param amount --> The amount of tokens that the account wish,\r\n     *         to stake in the staking pool.\r\n     */\r\n    function stake(uint256 amount) external onlyIfNotPaused onlyIfNotBanned {\r\n        address account = msg.sender;\r\n\r\n        // Check that the staked amount complies with the minimum staking requirement.\r\n        require(\r\n            amount >= minimumStakingAmount,\r\n            \"QuintStakingPool: staking amount not sufficient\"\r\n        );\r\n\r\n        // Check if the account is unique, if yes then add it to global tracking.\r\n        if (accountDetails[account].totalStakeEntries == 0)\r\n            totalUniqueStakers++;\r\n\r\n        // Check if the account has any available rewards from previous entries,\r\n        // the available rewards must be larger than zero to harvest. If yes,\r\n        // then auto harvest the available rewards by transferring to account.\r\n        uint256 rewards = calculateTokenReward(account);\r\n        if (rewards > 0) {\r\n            bool beforeLockPeriodEnds = block.timestamp <\r\n                (stakingDetails[account].stakedAt + unstakeTaxRemovedAt);\r\n\r\n            if (beforeLockPeriodEnds && !isExemptFromTaxation[account]) {\r\n                uint256 taxAmount = (rewards * unstakeTaxPercentage) / 100;\r\n                rewards -= taxAmount;\r\n            }\r\n            QUINT_TOKEN.transferFrom(rewardVault, account, rewards);\r\n            accountDetails[account].totalHarvestedRewards += rewards;\r\n\r\n            // Log successful activity.\r\n            emit Harvested(account, rewards);\r\n        }\r\n\r\n        // Transfer the staked amount of tokens to the staking pool.\r\n        QUINT_TOKEN.transferFrom(account, address(this), amount);\r\n\r\n        // Update internal account staking details.\r\n        stakingDetails[account].tokenAmount += amount;\r\n        stakingDetails[account].stakedAt = block.timestamp;\r\n        stakingDetails[account].rewardedAt = block.timestamp;\r\n\r\n        // Update global account staking details.\r\n        accountDetails[account].totalStakeEntries++;\r\n        accountDetails[account].totalStakedTokens += amount;\r\n\r\n        // Update global staking pool details.\r\n        totalStakedTokens += amount;\r\n\r\n        // Log successful activity.\r\n        emit Staked(account, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Harvest available rewards from staking in the staking pool,\r\n     *         the rewards are transferred to the staking account.\r\n     */\r\n    function harvest() external onlyIfNotPaused onlyIfNotBanned {\r\n        address account = msg.sender;\r\n\r\n        // Check if the account has any available rewards from previous entries,\r\n        // the available rewards must be larger than zero to harvest. If yes,\r\n        // then harvest the available rewards by transferring to account.\r\n        uint256 rewards = calculateTokenReward(account);\r\n\r\n        require(rewards > 0, \"QuintStakingPool: no rewards to harvest\");\r\n\r\n        bool beforeLockPeriodEnds = block.timestamp <\r\n            (stakingDetails[account].stakedAt + unstakeTaxRemovedAt);\r\n\r\n        // Apply taxes if lock period not respected\r\n        if (beforeLockPeriodEnds && !isExemptFromTaxation[account]) {\r\n            uint256 taxAmount = (rewards * unstakeTaxPercentage) / 100;\r\n            rewards -= taxAmount;\r\n        }\r\n\r\n        QUINT_TOKEN.transferFrom(rewardVault, account, rewards);\r\n\r\n        // Update internal account staking details.\r\n        stakingDetails[account].rewardedAt = block.timestamp;\r\n\r\n        // Update global account staking details.\r\n        accountDetails[account].totalHarvestedRewards += rewards;\r\n\r\n        // Update global staking pool details.\r\n        totalHarvestedRewards += rewards;\r\n\r\n        // Log successful activity.\r\n        emit Harvested(account, rewards);\r\n    }\r\n\r\n    /**\r\n     * @notice Unstake tokens to withdraw your position from the staking pools,\r\n     *         available rewards are transferred to the staking account.\r\n     */\r\n    function unstake() external onlyIfNotPaused onlyIfNotBanned {\r\n        address account = msg.sender;\r\n\r\n        // Check if the account has any available rewards from previous entries,\r\n        // the available rewards must be larger than zero to harvest. If yes,\r\n        // then auto harvest the available rewards by transferring to account.\r\n        uint256 rewards = calculateTokenReward(account);\r\n        if (rewards > 0) {\r\n            bool beforeLockPeriodEnds = block.timestamp <\r\n                (stakingDetails[account].stakedAt + unstakeTaxRemovedAt);\r\n\r\n            if (beforeLockPeriodEnds && !isExemptFromTaxation[account]) {\r\n                uint256 taxAmount = (rewards * unstakeTaxPercentage) / 100;\r\n                rewards -= taxAmount;\r\n            }\r\n            QUINT_TOKEN.transferFrom(rewardVault, account, rewards);\r\n        }\r\n\r\n        // Update internal account staking details.\r\n        stakingDetails[account].rewardedAt = block.timestamp;\r\n\r\n        uint256 amount = stakingDetails[account].tokenAmount;\r\n        delete stakingDetails[account].tokenAmount;\r\n\r\n        // Transfer the staked amount of tokens back to the account.\r\n        QUINT_TOKEN.transfer(account, amount);\r\n\r\n        // Update global account staking details.\r\n        accountDetails[account].totalUnstakedTokens += amount;\r\n        accountDetails[account].totalHarvestedRewards += rewards;\r\n\r\n        // Update global staking pool details.\r\n        totalHarvestedRewards += rewards;\r\n        totalUnstakedTokens += amount;\r\n\r\n        // Log successful activity.\r\n        emit Unstaked(account, amount);\r\n        emit Harvested(account, rewards);\r\n    }\r\n\r\n    /**\r\n     * @notice Unstake partial amount of tokens from the staking pools,\r\n     *         available rewards are transferred to the staking account.\r\n     *\r\n     * @param amount --> The amount of tokens that the account wish to\r\n     *         withdraw from the staking pool.\r\n     */\r\n    function unstakePartial(uint256 amount)\r\n        external\r\n        onlyIfNotPaused\r\n        onlyIfNotBanned\r\n    {\r\n        address account = msg.sender;\r\n        uint256 stakedTokens = stakingDetails[account].tokenAmount;\r\n\r\n        // Check if the staking position is larger than the unstaked amount.\r\n        require(\r\n            stakedTokens >= amount,\r\n            \"QuintStakingPool: insufficient staked tokens\"\r\n        );\r\n\r\n        // Update internal account staking details.\r\n        stakingDetails[account].tokenAmount -= amount;\r\n\r\n        // Transfer the partial amount of staked tokens back to the account.\r\n        QUINT_TOKEN.transfer(account, amount);\r\n\r\n        // Update global account staking details.\r\n        accountDetails[account].totalUnstakedTokens += amount;\r\n\r\n        // Update global staking pool details.\r\n        totalUnstakedTokens += amount;\r\n\r\n        // Log successful activity.\r\n        emit Unstaked(account, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw your staking position in case of an emergency,\r\n     *         you will give up pending rewards.\r\n     */\r\n    function emergencyWithdraw() external {\r\n        require(\r\n            isEmergencyWithdrawEnabled,\r\n            \"QuintWBNBStakingPool: not enabled\"\r\n        );\r\n        uint256 tokenAmount = stakingDetails[msg.sender].tokenAmount;\r\n\r\n        require(tokenAmount > 0, \"QuintWBNBStakingPool: nothing to withdraw\");\r\n\r\n        delete stakingDetails[msg.sender].tokenAmount;\r\n\r\n        if (isBanned[msg.sender]) {\r\n            QUINT_TOKEN.transfer(owner(), tokenAmount);\r\n        } else {\r\n            QUINT_TOKEN.transfer(msg.sender, tokenAmount);\r\n        }\r\n\r\n        emit EmergencyWithdrawn(\r\n            msg.sender,\r\n            tokenAmount,\r\n            stakingDetails[msg.sender].stakedAt,\r\n            stakingDetails[msg.sender].rewardedAt\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the unsettled rewards for an account from staking\r\n     *         in the pool, rewards that has not been compounded yet.\r\n     *\r\n     * @param account --> The account to use for reward calculation.\r\n     */\r\n    function calculateTokenReward(address account)\r\n        public\r\n        view\r\n        returns (uint256 reward)\r\n    {\r\n        // Calculate the staking duration of an account.\r\n        uint256 rewardDuration = block.timestamp -\r\n            stakingDetails[account].rewardedAt;\r\n\r\n        // Calculate the reward rate of an account.\r\n        reward =\r\n            (stakingDetails[account].tokenAmount *\r\n                rewardDuration *\r\n                rewardMultiplier) /\r\n            rewardDivider;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"initialOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"distributor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"legacyPool\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isBanned\",\"type\":\"bool\"}],\"name\":\"Banned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"}],\"name\":\"EmergencyWithdrawalEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakedAt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardedAt\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExempt\",\"type\":\"bool\"}],\"name\":\"Exempted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"}],\"name\":\"Harvested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Migrated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isPaused\",\"type\":\"bool\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"QUINT_TOKEN\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isExempt\",\"type\":\"bool\"}],\"name\":\"SetExemptFromTaxation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMinimumStakingAmount\",\"type\":\"uint256\"}],\"name\":\"SetMinimumStakingAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newRewardMultiplier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newRewardDivider\",\"type\":\"uint256\"}],\"name\":\"SetPoolAPYSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newUnstakeTaxPercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newUnstakeTaxRemovedAt\",\"type\":\"uint256\"}],\"name\":\"SetUnstakeTaxAndDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accountDetails\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalStakedTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalUnstakedTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStakeEntries\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalHarvestedRewards\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"calculateTokenReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isBanned\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isEmergencyWithdrawEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isExemptFromTaxation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isMigrated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"legacyStakingPool\",\"outputs\":[{\"internalType\":\"contract IQuintConventionalPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumStakingAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardDivider\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardVault\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setAllowEmergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setBanState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setPoolPauseState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newRewardVault\",\"type\":\"address\"}],\"name\":\"setRewardVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakingDetails\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardedAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalHarvestedRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStakedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUniqueStakers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUnstakedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unstakePartial\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstakeTaxPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstakeTaxRemovedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "QuintStakingPool", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000008ff2b9a2759bb1e4e960f6e200549eae2ca8e4cb00000000000000000000000064619f611248256f7f4b72fe83872f89d5d60d64000000000000000000000000bb45834bde1c557c1f1c4483bf15604d4467f6530000000000000000000000008fd50c8886dc91111e52bbfcb2685368c29bdc8d", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://2df29924949d61f72052cf593ee125b2e1e8f57a5ca92d645b8b57663076d90d"}