{"SourceCode": "pragma solidity ^0.8.0;\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n      if (a == 0) {\r\n        return 0;\r\n      }\r\n      c = a * b;\r\n      assert(c / a == b);\r\n      return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n      return a / b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n      assert(b <= a);\r\n      return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n      c = a + b;\r\n      assert(c >= a);\r\n      return c;\r\n    }\r\n}\r\n\r\ninterface TOKEN {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ncontract LPFarm {\r\n    using SafeMath for uint256;\r\n\r\n    modifier hasDripped {\r\n        if (dividendPool > 0) {\r\n          uint256 secondsPassed = SafeMath.sub(block.timestamp, lastDripTime);\r\n          uint256 dividends = secondsPassed.mul(dividendPool).div(dailyRate);\r\n\r\n          if (dividends > dividendPool) {\r\n            dividends = dividendPool;\r\n          }\r\n\r\n          profitPerShare = SafeMath.add(profitPerShare, (dividends * magnitude) / tokenSupply);\r\n          dividendPool = dividendPool.sub(dividends);\r\n          lastDripTime = block.timestamp;\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyTokenHolders {\r\n        require(myShares() > 0);\r\n        _;\r\n    }\r\n\r\n    modifier onlyDivis {\r\n        require(myRewards() > 0);\r\n        _;\r\n    }\r\n\r\n    event onDonation(\r\n        address indexed userAddress,\r\n        uint256 tokens\r\n    );\r\n\r\n    event onStake(\r\n        address indexed userAddress,\r\n        uint256 incomingTokens,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event onUnstake(\r\n        address indexed customerAddress,\r\n        uint256 tokenRemoved,\r\n        uint256 timestamp\r\n    );\r\n\r\n    event onReinvest(\r\n        address indexed customerAddress,\r\n        uint256 tokensReinvested\r\n    );\r\n\r\n    event onWithdraw(\r\n        address indexed customerAddress,\r\n        uint256 tokensWithdrawn\r\n    );\r\n\r\n\r\n    uint256 constant private magnitude = 2 ** 64;\r\n    uint32 constant private dailyRate = 11520000; //0.75% a day\r\n    uint8 constant private buyInFee = 75;\r\n    uint8 constant private sellOutFee = 75;\r\n    uint8 constant private vaultFee = 25;\r\n\r\n    mapping(address => uint256) private tokenBalanceLedger;\r\n    mapping(address => int256) private payoutsTo;\r\n\r\n    uint256 public dividendPool = 0;\r\n    uint256 public lastDripTime = block.timestamp;\r\n    uint256 public totalDonation = 0;\r\n    uint256 public totalVaultFundReceived = 0;\r\n    uint256 public totalVaultFundCollected = 0;\r\n\r\n    uint256 private tokenSupply = 0;\r\n    uint256 private profitPerShare = 0;\r\n\r\n    address public vaultAddress;\r\n    TOKEN bep20;\r\n\r\n    constructor() {\r\n        vaultAddress = address(0x6bEee53eFa847ec426707693c83836E359E92609); //vault address\r\n        bep20 = TOKEN(address(0x6F547381e6594C177A4C56Bc818b599cc78A8c16)); //pair token\r\n    }\r\n\r\n    fallback() external payable {\r\n        revert();\r\n    }\r\n\r\n    receive() external payable {\r\n        revert();\r\n    }\r\n\r\n    function checkAndTransfer(uint256 _amount) private {\r\n        require(bep20.transferFrom(msg.sender, address(this), _amount) == true, \"transfer must succeed\");\r\n    }\r\n\r\n    function donateToPool(uint256 _amount) public {\r\n        require(_amount > 0 && tokenSupply > 0, \"must be a positive value and have supply\");\r\n        checkAndTransfer(_amount);\r\n        totalDonation += _amount;\r\n        dividendPool = dividendPool.add(_amount);\r\n        emit onDonation(msg.sender, _amount);\r\n    }\r\n\r\n    function payVault() public {\r\n        uint256 _tokensToPay = tokensToPay();\r\n        require(_tokensToPay > 0);\r\n        bep20.transfer(vaultAddress, _tokensToPay);\r\n        totalVaultFundReceived = totalVaultFundReceived.add(_tokensToPay);\r\n    }\r\n\r\n    function reinvest() hasDripped onlyDivis public {\r\n        address _customerAddress = msg.sender;\r\n        uint256 _dividends = myRewards();\r\n        payoutsTo[_customerAddress] +=  (int256) (_dividends.mul(magnitude));\r\n        uint256 _tokens = purchaseTokens(_customerAddress, _dividends);\r\n        emit onReinvest(_customerAddress, _tokens);\r\n    }\r\n\r\n    function withdraw() hasDripped onlyDivis public {\r\n        address _customerAddress = msg.sender;\r\n        uint256 _dividends = myRewards();\r\n        payoutsTo[_customerAddress] += (int256) (_dividends.mul(magnitude));\r\n        bep20.transfer(_customerAddress, _dividends);\r\n        emit onWithdraw(_customerAddress, _dividends);\r\n    }\r\n\r\n    function deposit(uint256 _amount) hasDripped public returns (uint256) {\r\n        checkAndTransfer(_amount);\r\n        return purchaseTokens(msg.sender, _amount);\r\n    }\r\n\r\n    function _purchaseTokens(address _customerAddress, uint256 _incomingTokens) private returns(uint256) {\r\n        uint256 _amountOfTokens = _incomingTokens;\r\n\r\n        require(_amountOfTokens > 0 && _amountOfTokens.add(tokenSupply) > tokenSupply);\r\n\r\n        tokenSupply = tokenSupply.add(_amountOfTokens);\r\n        tokenBalanceLedger[_customerAddress] =  tokenBalanceLedger[_customerAddress].add(_amountOfTokens);\r\n\r\n        int256 _updatedPayouts = (int256) (profitPerShare.mul(_amountOfTokens));\r\n        payoutsTo[_customerAddress] += _updatedPayouts;\r\n\r\n        return _amountOfTokens;\r\n    }\r\n\r\n    function purchaseTokens(address _customerAddress, uint256 _incomingTokens) private returns (uint256) {\r\n        require(_incomingTokens > 0);\r\n\r\n        uint256 _dividendFee = _incomingTokens.mul(buyInFee).div(1000);\r\n\r\n        uint256 _vaultFee = _incomingTokens.mul(vaultFee).div(1000);\r\n\r\n        uint256 _entryFee = _incomingTokens.mul(100).div(1000);\r\n        uint256 _taxedTokens = _incomingTokens.sub(_entryFee);\r\n\r\n        uint256 _amountOfTokens = _purchaseTokens(_customerAddress, _taxedTokens);\r\n\r\n        dividendPool = dividendPool.add(_dividendFee);\r\n        totalVaultFundCollected = totalVaultFundCollected.add(_vaultFee);\r\n\r\n        emit onStake(_customerAddress, _amountOfTokens, block.timestamp);\r\n\r\n        return _amountOfTokens;\r\n    }\r\n\r\n    function remove(uint256 _amountOfTokens) hasDripped onlyTokenHolders public {\r\n        address _customerAddress = msg.sender;\r\n        require(_amountOfTokens > 0 && _amountOfTokens <= tokenBalanceLedger[_customerAddress]);\r\n\r\n        uint256 _dividendFee = _amountOfTokens.mul(sellOutFee).div(1000);\r\n        uint256 _vaultFee = _amountOfTokens.mul(vaultFee).div(1000);\r\n        uint256 _taxedTokens = _amountOfTokens.sub(_dividendFee).sub(_vaultFee);\r\n\r\n        tokenSupply = tokenSupply.sub(_amountOfTokens);\r\n        tokenBalanceLedger[_customerAddress] = tokenBalanceLedger[_customerAddress].sub(_amountOfTokens);\r\n\r\n        int256 _updatedPayouts = (int256) ((profitPerShare.mul(_amountOfTokens)).add(_taxedTokens.mul(magnitude)));\r\n        payoutsTo[_customerAddress] -= _updatedPayouts;\r\n\r\n        dividendPool = dividendPool.add(_dividendFee);\r\n        totalVaultFundCollected = totalVaultFundCollected.add(_vaultFee);\r\n          \r\n        emit onUnstake(_customerAddress, _taxedTokens, block.timestamp);\r\n    }\r\n\r\n    function totalTokenBalance() public view returns (uint256) {\r\n        return bep20.balanceOf(address(this));\r\n    }\r\n\r\n    function totalSupply() public view returns(uint256) {\r\n        return tokenSupply;\r\n    }\r\n\r\n    function myShares() public view returns (uint256) {\r\n        address _customerAddress = msg.sender;\r\n        return sharesOf(_customerAddress);\r\n    }\r\n\r\n    function myEstimateRewards() public view returns (uint256) {\r\n        address _customerAddress = msg.sender;\r\n        return estimateRewardsOf(_customerAddress);\r\n    }\r\n\r\n    function estimateRewardsOf(address _customerAddress) public view returns (uint256) {\r\n        uint256 _profitPerShare = profitPerShare;\r\n\r\n        if (dividendPool > 0) {\r\n          uint256 secondsPassed = 0;\r\n       \r\n          secondsPassed = SafeMath.sub(block.timestamp, lastDripTime);\r\n\r\n          uint256 dividends = secondsPassed.mul(dividendPool).div(dailyRate);\r\n\r\n          if (dividends > dividendPool) {\r\n            dividends = dividendPool;\r\n          }\r\n\r\n          _profitPerShare = SafeMath.add(_profitPerShare, (dividends * magnitude) / tokenSupply);\r\n        }\r\n\r\n        return (uint256) ((int256) (_profitPerShare * tokenBalanceLedger[_customerAddress]) - payoutsTo[_customerAddress]) / magnitude;\r\n    }\r\n\r\n    function myRewards() public view returns (uint256) {\r\n        address _customerAddress = msg.sender;\r\n        return rewardsOf(_customerAddress) ;\r\n    }\r\n\r\n    function rewardsOf(address _customerAddress) public view returns (uint256) {\r\n        return (uint256) ((int256) (profitPerShare * tokenBalanceLedger[_customerAddress]) - payoutsTo[_customerAddress]) / magnitude;\r\n    }\r\n\r\n    function sharesOf(address _customerAddress) public view returns (uint256) {\r\n        return tokenBalanceLedger[_customerAddress];\r\n    }\r\n\r\n    function tokensToPay() public view returns(uint256) {\r\n        return totalVaultFundCollected.sub(totalVaultFundReceived);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"onDonation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensReinvested\",\"type\":\"uint256\"}],\"name\":\"onReinvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"incomingTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenRemoved\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onUnstake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensWithdrawn\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"donateToPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"estimateRewardsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastDripTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myEstimateRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"payVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reinvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"remove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"rewardsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"sharesOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensToPay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDonation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalVaultFundCollected\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalVaultFundReceived\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "LPFarm", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://eaab1262908298fdd74c0f1458e18cfb298639b3416510e8eb1dfe92077dccfc"}