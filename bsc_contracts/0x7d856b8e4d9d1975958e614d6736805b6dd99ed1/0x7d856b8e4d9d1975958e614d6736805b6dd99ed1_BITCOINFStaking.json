{"SourceCode": "// SPDX-License-Identifier: GPL-2.0\r\n\r\npragma solidity 0.8.17;\r\n\r\ninterface IBEP20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function getOwner() external view returns (address);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract BITCOINFStaking {\r\n    struct StakeItem {\r\n        uint256 counter;\r\n        address beneficiary;\r\n        uint32 liquidated;\r\n        uint256 term;//in minutes: 1 day = 1,440.00 mins\r\n        uint256 stakedRate;\r\n        uint256 amount;\r\n        uint256 claimAmount;//Cumulative Claimed Amount;\r\n        uint256 startDate;\r\n        uint256 lastClaim;\r\n    }\r\n\r\n    IBEP20 private stakeToken;\r\n    uint256 private stakeCounter;\r\n    address private immutable owner;\r\n    uint256 private pauseState; //1-off | 0-on\r\n    uint256 private frozenAmount;\r\n\r\n    mapping(uint256 => StakeItem) private stakeList;\r\n    mapping(address => uint256[]) private holderCounterList;\r\n    mapping(uint256 => mapping(uint256 => uint256)) private terms;\r\n    \r\n    //time constants: SECONDSINDAY = 86400, DAYSINYEAR = 365;\r\n    uint256 private constant INDEX_RATE = 1;\r\n    uint256 private constant INDEX_MINAMOUNT = 2;\r\n\r\n    event Staked(uint256 counter);\r\n    event Unstaked(uint256 counter, bool soon);\r\n    event InterestClaimed(uint256 counter);\r\n    event Refunded(uint256 amount);\r\n\r\n    modifier onlyOwner {\r\n      require(msg.sender == owner, \"Only for owner\");\r\n      _;\r\n    }\r\n\r\n    modifier contractInitialized {\r\n      require(pauseState == 0, \"contract is not ready\");\r\n      _;\r\n    }\r\n\r\n    constructor(address _stakeToken) {        \r\n        owner = msg.sender;\r\n        stakeToken = IBEP20 (_stakeToken);\r\n    }\r\n\r\n    function setTerm(uint256 term, uint256 rate, uint256 amount) external onlyOwner {\r\n        //rate: //100 => 1%.\r\n        //rates[term] = rate;\r\n        //minAmounts[term] = amount;\r\n        terms[term][INDEX_RATE] = rate;\r\n        terms[term][INDEX_MINAMOUNT] = amount;\r\n    }\r\n\r\n    function getTerm(uint256 term) external view returns (uint256 rate, uint256 minAmount) {\r\n        return (terms[term][INDEX_RATE], terms[term][INDEX_MINAMOUNT]);\r\n    }\r\n\r\n    function getContractConfigurations() external view returns (address _owner, address _stakeToken, uint256 _pausedState, uint256 _stakeCounter, uint256 _frozenAmount) {\r\n        return (owner, address(stakeToken), pauseState, stakeCounter, frozenAmount);\r\n    }\r\n \r\n    function setContractState(uint256 state) external onlyOwner {\r\n        require(state == 1 || state == 0, \"wrong state\");\r\n        pauseState = state;\r\n    }\r\n    \r\n    //only applicable on testnet\r\n    function setTokenAddress(address _stakeToken) external onlyOwner {\r\n        stakeToken = IBEP20 (_stakeToken);\r\n    }\r\n    \r\n    function calculateInterest(uint256 counter) public view returns (uint256) {\r\n        StakeItem memory item = stakeList[counter];\r\n        // seconds from last withdraw until now => (block.timestamp - item.lastClaim);\r\n        uint256 maxTimestamp = item.startDate + (item.term * 60);\r\n        uint256 lastClaim = item.lastClaim > maxTimestamp ? maxTimestamp : item.lastClaim;\r\n        uint256 availableSeconds = block.timestamp - lastClaim;\r\n        uint256 maxSeconds = (item.startDate + (item.term * 60)) - lastClaim;\r\n        if(availableSeconds > maxSeconds) {\r\n            availableSeconds = maxSeconds;\r\n        }\r\n        //interest = amount * seconds from last withdraw * 1 second interest rate\r\n        return _perAnnual(item.amount * (availableSeconds) * item.stakedRate);        \r\n    }\r\n\r\n    function _perAnnual(uint256 amount) internal pure returns(uint256) {\r\n        return amount / 365 / 86400 / 10000;\r\n    }\r\n    \r\n    function getStakeItem(uint256 counter) external view returns (StakeItem memory) {\r\n        return stakeList[counter];\r\n    }\r\n\r\n    /*\r\n    *   all old and current stakes\r\n    */\r\n    function getStakeCounterByHolder(address holder) external view returns (uint256[] memory) {\r\n        return holderCounterList[holder];\r\n    }\r\n\r\n    /*\r\n    *   get all stake items from a holder with liquidated status\r\n    *   0: being staked, not liquidated yet\r\n    *   1: unstaked, already liquidated\r\n    *   2: both\r\n    */\r\n    function getStakeItemsByHolder(address holder, uint32 status) external view returns (StakeItem[] memory) {\r\n        require(status == 0 || status == 1 || status == 2, \"wrong status\");\r\n        uint256 stakeCount = holderCounterList[holder].length;\r\n        uint256 selectedStakeCount = 0;\r\n        uint256 selectedIndex = 0;\r\n\r\n        //first loop: populate array size\r\n        for (uint256 i = 0; i < stakeCount; i++) {\r\n            if(status == 2 || stakeList[holderCounterList[holder][i]].liquidated == status) {\r\n                selectedStakeCount++;              \r\n            }\r\n        }\r\n        //second loop: memory allocation\r\n        StakeItem[] memory list = new StakeItem[](selectedStakeCount);\r\n        for (uint256 i = 0; i < stakeCount; i++) {\r\n            if(status == 2 || stakeList[holderCounterList[holder][i]].liquidated == status) {\r\n                list[selectedIndex++] = stakeList[holderCounterList[holder][i]];                          \r\n            }\r\n        }\r\n        return list;\r\n    }\r\n\r\n    function _maxInterest(uint256 amount, uint256 term /*minute*/, uint256 rate /*annual value*/) internal pure returns (uint256) {\r\n        return _perAnnual(amount * (term * 60) * rate);\r\n    }\r\n\r\n    /*\r\n    * user safety protection:\r\n    *  - any user who has enough minimum amount can join the program\r\n    *  - but the contract must have enough fund to pay interest\r\n    *  - it could happen a small discrepancy in amount calculation as of block timestamp algorithm\r\n    */\r\n    function stake(uint256 amount, uint256 term) external contractInitialized returns (uint256 counter) {\r\n        require(terms[term][INDEX_RATE] > 0, \"term not available\");\r\n        require(amount >= terms[term][INDEX_MINAMOUNT], \"stake amount too low\");\r\n        uint256 maxInterest = _maxInterest(amount, term, terms[term][INDEX_RATE]);\r\n        require(stakeToken.balanceOf(address(this)) - frozenAmount >= maxInterest, \"contract runs out of fund\");\r\n        stakeToken.transferFrom(msg.sender, address(this), amount);\r\n        stakeCounter++;\r\n        stakeList[stakeCounter] = StakeItem({\r\n            counter: stakeCounter,\r\n            beneficiary: msg.sender,\r\n            liquidated: 0,\r\n            term: term,\r\n            stakedRate: terms[term][INDEX_RATE],\r\n            amount: amount,\r\n            claimAmount: 0,\r\n            startDate: block.timestamp,\r\n            lastClaim: block.timestamp\r\n        });\r\n        holderCounterList[msg.sender].push(stakeCounter);\r\n        //freeze user's funds\r\n        _freeze(amount + maxInterest);\r\n        emit Staked(stakeCounter);\r\n        return stakeCounter;\r\n    }\r\n\r\n    function _freeze(uint256 amount) internal {\r\n        frozenAmount += amount;\r\n    }\r\n\r\n    function _unfreeze(uint256 amount) internal {\r\n        frozenAmount -= amount;\r\n    }\r\n    \r\n    function _checkValidItem(StakeItem memory item) internal view {\r\n        require(msg.sender == item.beneficiary, \"wrong beneficiary\");\r\n        require(item.liquidated == 0, \"counter already unstaked\");\r\n    }\r\n\r\n    /*\r\n    *   soon allow users unstake before term period\r\n    *   need to refund all claimed interest\r\n    */\r\n    function unstake(uint256 counter) external {\r\n        StakeItem storage item = stakeList[counter];\r\n        _checkValidItem(item);\r\n        uint256 transferAmount;\r\n        bool soon = (item.startDate + (item.term * 60) <= block.timestamp) ? false : true;\r\n\r\n        if(soon) {\r\n            //calculate full interest\r\n            uint256 maxInterest = _maxInterest(item.amount, item.term, item.stakedRate); \r\n            //deduct claimed amount\r\n            transferAmount = item.amount - item.claimAmount;\r\n            //unfreeze amount\r\n            _unfreeze(item.amount + maxInterest - item.claimAmount);\r\n        } else {\r\n            //withdraw both interest and original amount\r\n            uint256 interest = calculateInterest(counter);\r\n            transferAmount = item.amount + interest;\r\n            item.claimAmount += interest;\r\n            //unfreeze amount\r\n            _unfreeze(transferAmount);\r\n        }\r\n\r\n        item.lastClaim = block.timestamp;\r\n        item.liquidated = 1;\r\n        stakeToken.transfer(item.beneficiary, transferAmount);\r\n        emit Unstaked(counter, soon);\r\n    }\r\n\r\n    function claimInterest(uint256 counter) external {\r\n        StakeItem storage item = stakeList[counter];\r\n        _checkValidItem(item);\r\n        uint256 transferAmount = calculateInterest(counter);\r\n        require(transferAmount > 0, \"no interest to claim\");\r\n        stakeToken.transfer(item.beneficiary, transferAmount);\r\n        item.lastClaim = block.timestamp;\r\n        item.claimAmount += transferAmount;\r\n        //unfreeze claimed amount\r\n        _unfreeze(transferAmount);\r\n        emit InterestClaimed(counter);\r\n    }\r\n\r\n    /*\r\n    * owner can only withdraw extra amount\r\n    */\r\n    function refund(uint256 amount) external onlyOwner {\r\n        require(amount <= stakeToken.balanceOf(address(this)) - frozenAmount, \"not enough amount to refund\");\r\n        stakeToken.transfer(msg.sender, amount);\r\n        emit Refunded(amount);\r\n    }\r\n\r\n    /*\r\n    *   clear tokens accidentially dropped to the vault\r\n    */\r\n    function clearVisitingToken(address _visitingToken) external onlyOwner {\r\n        require(_visitingToken != address(stakeToken), \"only available for visiting token\");\r\n        uint256 amount = IBEP20(_visitingToken).balanceOf(address(this));\r\n        IBEP20(_visitingToken).transfer(msg.sender, amount);\r\n    }\r\n}\r\n\r\n\r\n/*\r\n    *           *   * * * * * * *   *       *\r\n    * *       * *         *         *     *  \r\n    *   *   *   *         *         *   *    \r\n    *     *     *         *         * *      \r\n    *           *         *         *   *    \r\n    *           *         *         *     *  \r\n    *           *         *         *       *\r\n   contact @mtkungfu on telegram for suggestions\r\n */", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakeToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"counter\",\"type\":\"uint256\"}],\"name\":\"InterestClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Refunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"counter\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"counter\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"soon\",\"type\":\"bool\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"counter\",\"type\":\"uint256\"}],\"name\":\"calculateInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"counter\",\"type\":\"uint256\"}],\"name\":\"claimInterest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_visitingToken\",\"type\":\"address\"}],\"name\":\"clearVisitingToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractConfigurations\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stakeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pausedState\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stakeCounter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_frozenAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"getStakeCounterByHolder\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"counter\",\"type\":\"uint256\"}],\"name\":\"getStakeItem\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"counter\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"liquidated\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"term\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakedRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastClaim\",\"type\":\"uint256\"}],\"internalType\":\"struct BITCOINFStaking.StakeItem\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"status\",\"type\":\"uint32\"}],\"name\":\"getStakeItemsByHolder\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"counter\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"liquidated\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"term\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakedRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastClaim\",\"type\":\"uint256\"}],\"internalType\":\"struct BITCOINFStaking.StakeItem[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"term\",\"type\":\"uint256\"}],\"name\":\"getTerm\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"refund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"state\",\"type\":\"uint256\"}],\"name\":\"setContractState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"term\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setTerm\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakeToken\",\"type\":\"address\"}],\"name\":\"setTokenAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"term\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"counter\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"counter\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BITCOINFStaking", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000003aab7905e114980475827db0c60e1d50695d6f17", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv2", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f9153c3068fbca9a60e7dd951c22a9cdaa42a0fcf6fc45517f82a2aef839bb58"}