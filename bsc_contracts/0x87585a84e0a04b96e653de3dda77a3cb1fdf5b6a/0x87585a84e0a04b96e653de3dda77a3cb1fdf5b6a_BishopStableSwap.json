{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/fund/FundRolesV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"../interfaces/ITrancheIndexV2.sol\\\";\\n\\nabstract contract FundRolesV2 is ITrancheIndexV2 {\\n    event PrimaryMarketUpdateProposed(\\n        address indexed newPrimaryMarket,\\n        uint256 minTimestamp,\\n        uint256 maxTimestamp\\n    );\\n    event PrimaryMarketUpdated(\\n        address indexed previousPrimaryMarket,\\n        address indexed newPrimaryMarket\\n    );\\n    event StrategyUpdateProposed(\\n        address indexed newStrategy,\\n        uint256 minTimestamp,\\n        uint256 maxTimestamp\\n    );\\n    event StrategyUpdated(address indexed previousStrategy, address indexed newStrategy);\\n\\n    uint256 private constant ROLE_UPDATE_MIN_DELAY = 3 days;\\n    uint256 private constant ROLE_UPDATE_MAX_DELAY = 15 days;\\n\\n    address internal immutable _tokenQ;\\n    address internal immutable _tokenB;\\n    address internal immutable _tokenR;\\n\\n    address internal _primaryMarket;\\n    address internal _proposedPrimaryMarket;\\n    uint256 internal _proposedPrimaryMarketTimestamp;\\n\\n    address internal _strategy;\\n    address internal _proposedStrategy;\\n    uint256 internal _proposedStrategyTimestamp;\\n\\n    constructor(\\n        address tokenQ_,\\n        address tokenB_,\\n        address tokenR_,\\n        address primaryMarket_,\\n        address strategy_\\n    ) public {\\n        _tokenQ = tokenQ_;\\n        _tokenB = tokenB_;\\n        _tokenR = tokenR_;\\n        _primaryMarket = primaryMarket_;\\n        _strategy = strategy_;\\n        emit PrimaryMarketUpdated(address(0), primaryMarket_);\\n        emit StrategyUpdated(address(0), strategy_);\\n    }\\n\\n    function _getTranche(address share) internal view returns (uint256) {\\n        if (share == _tokenQ) {\\n            return TRANCHE_Q;\\n        } else if (share == _tokenB) {\\n            return TRANCHE_B;\\n        } else if (share == _tokenR) {\\n            return TRANCHE_R;\\n        } else {\\n            revert(\\\"Only share\\\");\\n        }\\n    }\\n\\n    function _getShare(uint256 tranche) internal view returns (address) {\\n        if (tranche == TRANCHE_Q) {\\n            return _tokenQ;\\n        } else if (tranche == TRANCHE_B) {\\n            return _tokenB;\\n        } else if (tranche == TRANCHE_R) {\\n            return _tokenR;\\n        } else {\\n            revert(\\\"Invalid tranche\\\");\\n        }\\n    }\\n\\n    modifier onlyPrimaryMarket() {\\n        require(msg.sender == _primaryMarket, \\\"Only primary market\\\");\\n        _;\\n    }\\n\\n    function _proposePrimaryMarketUpdate(address newPrimaryMarket) internal {\\n        require(newPrimaryMarket != _primaryMarket);\\n        _proposedPrimaryMarket = newPrimaryMarket;\\n        _proposedPrimaryMarketTimestamp = block.timestamp;\\n        emit PrimaryMarketUpdateProposed(\\n            newPrimaryMarket,\\n            block.timestamp + ROLE_UPDATE_MIN_DELAY,\\n            block.timestamp + ROLE_UPDATE_MAX_DELAY\\n        );\\n    }\\n\\n    function _applyPrimaryMarketUpdate(address newPrimaryMarket) internal {\\n        require(_proposedPrimaryMarket == newPrimaryMarket, \\\"Proposed address mismatch\\\");\\n        require(\\n            block.timestamp >= _proposedPrimaryMarketTimestamp + ROLE_UPDATE_MIN_DELAY &&\\n                block.timestamp < _proposedPrimaryMarketTimestamp + ROLE_UPDATE_MAX_DELAY,\\n            \\\"Not ready to update\\\"\\n        );\\n        emit PrimaryMarketUpdated(_primaryMarket, newPrimaryMarket);\\n        _primaryMarket = newPrimaryMarket;\\n        _proposedPrimaryMarket = address(0);\\n        _proposedPrimaryMarketTimestamp = 0;\\n    }\\n\\n    modifier onlyStrategy() {\\n        require(msg.sender == _strategy, \\\"Only strategy\\\");\\n        _;\\n    }\\n\\n    function _proposeStrategyUpdate(address newStrategy) internal {\\n        require(newStrategy != _strategy);\\n        _proposedStrategy = newStrategy;\\n        _proposedStrategyTimestamp = block.timestamp;\\n        emit StrategyUpdateProposed(\\n            newStrategy,\\n            block.timestamp + ROLE_UPDATE_MIN_DELAY,\\n            block.timestamp + ROLE_UPDATE_MAX_DELAY\\n        );\\n    }\\n\\n    function _applyStrategyUpdate(address newStrategy) internal {\\n        require(_proposedStrategy == newStrategy, \\\"Proposed address mismatch\\\");\\n        require(\\n            block.timestamp >= _proposedStrategyTimestamp + ROLE_UPDATE_MIN_DELAY &&\\n                block.timestamp < _proposedStrategyTimestamp + ROLE_UPDATE_MAX_DELAY,\\n            \\\"Not ready to update\\\"\\n        );\\n        emit StrategyUpdated(_strategy, newStrategy);\\n        _strategy = newStrategy;\\n        _proposedStrategy = address(0);\\n        _proposedStrategyTimestamp = 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITrancheIndexV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\n/// @notice Amounts of QUEEN, BISHOP and ROOK are sometimes stored in a `uint256[3]` array.\\n///         This contract defines index of each tranche in this array.\\n///\\n///         Solidity does not allow constants to be defined in interfaces. So this contract follows\\n///         the naming convention of interfaces but is implemented as an `abstract contract`.\\nabstract contract ITrancheIndexV2 {\\n    uint256 internal constant TRANCHE_Q = 0;\\n    uint256 internal constant TRANCHE_B = 1;\\n    uint256 internal constant TRANCHE_R = 2;\\n\\n    uint256 internal constant TRANCHE_COUNT = 3;\\n}\\n\"\r\n    },\r\n    \"contracts/fund/FundV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\n\\nimport \\\"../utils/SafeDecimalMath.sol\\\";\\nimport \\\"../utils/CoreUtility.sol\\\";\\n\\nimport \\\"../interfaces/IPrimaryMarketV3.sol\\\";\\nimport \\\"../interfaces/IFundV3.sol\\\";\\nimport \\\"../interfaces/IShareV2.sol\\\";\\nimport \\\"../interfaces/ITwapOracleV2.sol\\\";\\nimport \\\"../interfaces/IAprOracle.sol\\\";\\nimport \\\"../interfaces/IBallot.sol\\\";\\nimport \\\"../interfaces/IVotingEscrow.sol\\\";\\n\\nimport \\\"./FundRolesV2.sol\\\";\\n\\ncontract FundV3 is IFundV3, Ownable, ReentrancyGuard, FundRolesV2, CoreUtility {\\n    using Math for uint256;\\n    using SafeMath for uint256;\\n    using SafeDecimalMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    event ProfitReported(uint256 profit, uint256 performanceFee);\\n    event LossReported(uint256 loss);\\n    event DailyProtocolFeeRateUpdated(uint256 newDailyProtocolFeeRate);\\n    event TwapOracleUpdated(address newTwapOracle);\\n    event AprOracleUpdated(address newAprOracle);\\n    event BallotUpdated(address newBallot);\\n    event FeeCollectorUpdated(address newFeeCollector);\\n    event ActivityDelayTimeUpdated(uint256 delayTime);\\n    event SplitRatioUpdated(uint256 newSplitRatio);\\n    event FeeDebtPaid(uint256 amount);\\n    event TotalDebtUpdated(uint256 newTotalDebt);\\n\\n    uint256 private constant UNIT = 1e18;\\n    uint256 private constant MAX_INTEREST_RATE = 0.2e18; // 20% daily\\n    uint256 private constant MAX_DAILY_PROTOCOL_FEE_RATE = 0.05e18; // 5% daily rate\\n\\n    /// @notice Upper bound of `NAV_R / NAV_B` to trigger a rebalance.\\n    uint256 public immutable upperRebalanceThreshold;\\n\\n    /// @notice Lower bound of `NAV_R / NAV_B` to trigger a rebalance.\\n    uint256 public immutable lowerRebalanceThreshold;\\n\\n    /// @notice Address of the underlying token.\\n    address public immutable override tokenUnderlying;\\n\\n    /// @notice A multipler that normalizes an underlying balance to 18 decimal places.\\n    uint256 public immutable override underlyingDecimalMultiplier;\\n\\n    /// @notice Daily protocol fee rate.\\n    uint256 public dailyProtocolFeeRate;\\n\\n    /// @notice TwapOracle address for the underlying asset.\\n    ITwapOracleV2 public override twapOracle;\\n\\n    /// @notice AprOracle address.\\n    IAprOracle public aprOracle;\\n\\n    /// @notice Address of the interest rate ballot.\\n    IBallot public ballot;\\n\\n    /// @notice Fee Collector address.\\n    address public override feeCollector;\\n\\n    /// @notice End timestamp of the current trading day.\\n    ///         A trading day starts at UTC time `SETTLEMENT_TIME` of a day (inclusive)\\n    ///         and ends at the same time of the next day (exclusive).\\n    uint256 public override currentDay;\\n\\n    /// @notice The amount of BISHOP received by splitting one QUEEN.\\n    ///         This ratio changes on every rebalance.\\n    uint256 public override splitRatio;\\n\\n    /// @dev Mapping of rebalance version => splitRatio.\\n    mapping(uint256 => uint256) private _historicalSplitRatio;\\n\\n    /// @notice Start timestamp of the current primary market activity window.\\n    uint256 public override fundActivityStartTime;\\n\\n    uint256 public activityDelayTimeAfterRebalance;\\n\\n    /// @dev Historical rebalances. Rebalances are often accessed in loops with bounds checking.\\n    ///      So we store them in a fixed-length array, in order to make compiler-generated\\n    ///      bounds checking on every access cheaper. The actual length of this array is stored in\\n    ///      `_rebalanceSize` and should be explicitly checked when necessary.\\n    Rebalance[65535] private _rebalances;\\n\\n    /// @dev Historical rebalance count.\\n    uint256 private _rebalanceSize;\\n\\n    /// @dev Total share supply of the three tranches. They are always rebalanced to the latest\\n    ///      version.\\n    uint256[TRANCHE_COUNT] private _totalSupplies;\\n\\n    /// @dev Mapping of account => share balance of the three tranches.\\n    ///      Rebalance versions are stored in a separate mapping `_balanceVersions`.\\n    mapping(address => uint256[TRANCHE_COUNT]) private _balances;\\n\\n    /// @dev Rebalance version mapping for `_balances`.\\n    mapping(address => uint256) private _balanceVersions;\\n\\n    /// @dev Mapping of owner => spender => share allowance of the three tranches.\\n    ///      Rebalance versions are stored in a separate mapping `_allowanceVersions`.\\n    mapping(address => mapping(address => uint256[TRANCHE_COUNT])) private _allowances;\\n\\n    /// @dev Rebalance version mapping for `_allowances`.\\n    mapping(address => mapping(address => uint256)) private _allowanceVersions;\\n\\n    /// @dev Mapping of trading day => NAV of BISHOP.\\n    mapping(uint256 => uint256) private _historicalNavB;\\n\\n    /// @dev Mapping of trading day => NAV of ROOK.\\n    mapping(uint256 => uint256) private _historicalNavR;\\n\\n    /// @notice Mapping of trading day => equivalent BISHOP supply.\\n    ///\\n    ///         Key is the end timestamp of a trading day. Value is the total supply of BISHOP,\\n    ///         as if all QUEEN are split.\\n    mapping(uint256 => uint256) public override historicalEquivalentTotalB;\\n\\n    /// @notice Mapping of trading day => underlying assets in the fund.\\n    ///\\n    ///         Key is the end timestamp of a trading day. Value is the underlying assets in\\n    ///         the fund after settlement of that trading day.\\n    mapping(uint256 => uint256) public override historicalUnderlying;\\n\\n    /// @notice Mapping of trading week => interest rate of BISHOP.\\n    ///\\n    ///         Key is the end timestamp of a trading day. Value is the interest rate captured\\n    ///         after settlement of that day, which will be effective in the following trading day.\\n    mapping(uint256 => uint256) public historicalInterestRate;\\n\\n    /// @notice Amount of fee not transfered to the fee collector yet.\\n    uint256 public feeDebt;\\n\\n    /// @notice Amount of redemption underlying that the fund owes the primary market\\n    uint256 public redemptionDebt;\\n\\n    /// @dev Sum of the fee debt and redemption debts of all primary markets.\\n    uint256 private _totalDebt;\\n\\n    uint256 private _strategyUnderlying;\\n\\n    struct ConstructorParameters {\\n        address tokenUnderlying;\\n        uint256 underlyingDecimals;\\n        address tokenQ;\\n        address tokenB;\\n        address tokenR;\\n        address primaryMarket;\\n        address strategy;\\n        uint256 dailyProtocolFeeRate;\\n        uint256 upperRebalanceThreshold;\\n        uint256 lowerRebalanceThreshold;\\n        address twapOracle;\\n        address aprOracle;\\n        address ballot;\\n        address feeCollector;\\n    }\\n\\n    constructor(ConstructorParameters memory params)\\n        public\\n        Ownable()\\n        FundRolesV2(\\n            params.tokenQ,\\n            params.tokenB,\\n            params.tokenR,\\n            params.primaryMarket,\\n            params.strategy\\n        )\\n    {\\n        tokenUnderlying = params.tokenUnderlying;\\n        require(params.underlyingDecimals <= 18, \\\"Underlying decimals larger than 18\\\");\\n        underlyingDecimalMultiplier = 10**(18 - params.underlyingDecimals);\\n        _updateDailyProtocolFeeRate(params.dailyProtocolFeeRate);\\n        upperRebalanceThreshold = params.upperRebalanceThreshold;\\n        lowerRebalanceThreshold = params.lowerRebalanceThreshold;\\n        _updateTwapOracle(params.twapOracle);\\n        _updateAprOracle(params.aprOracle);\\n        _updateBallot(params.ballot);\\n        _updateFeeCollector(params.feeCollector);\\n        _updateActivityDelayTime(30 minutes);\\n    }\\n\\n    function initialize(\\n        uint256 newSplitRatio,\\n        uint256 lastNavB,\\n        uint256 lastNavR,\\n        uint256 strategyUnderlying\\n    ) external onlyOwner {\\n        require(splitRatio == 0 && currentDay == 0, \\\"Already initialized\\\");\\n        require(\\n            newSplitRatio != 0 && lastNavB >= UNIT && !_shouldTriggerRebalance(lastNavB, lastNavR),\\n            \\\"Invalid parameters\\\"\\n        );\\n        currentDay = endOfDay(block.timestamp);\\n        splitRatio = newSplitRatio;\\n        _historicalSplitRatio[0] = newSplitRatio;\\n        emit SplitRatioUpdated(newSplitRatio);\\n        uint256 lastDay = currentDay - 1 days;\\n        uint256 lastDayPrice = twapOracle.getTwap(lastDay);\\n        require(lastDayPrice != 0, \\\"Price not available\\\"); // required to do the first creation\\n        _historicalNavB[lastDay] = lastNavB;\\n        _historicalNavR[lastDay] = lastNavR;\\n        _strategyUnderlying = strategyUnderlying;\\n        uint256 lastInterestRate = _updateInterestRate(lastDay);\\n        historicalInterestRate[lastDay] = lastInterestRate;\\n        emit Settled(lastDay, lastNavB, lastNavR, lastInterestRate);\\n        fundActivityStartTime = lastDay;\\n    }\\n\\n    /// @notice UTC time of a day when the fund settles.\\n    function settlementTime() external pure returns (uint256) {\\n        return SETTLEMENT_TIME;\\n    }\\n\\n    /// @notice Return end timestamp of the trading day containing a given timestamp.\\n    ///\\n    ///         A trading day starts at UTC time `SETTLEMENT_TIME` of a day (inclusive)\\n    ///         and ends at the same time of the next day (exclusive).\\n    /// @param timestamp The given timestamp\\n    /// @return End timestamp of the trading day.\\n    function endOfDay(uint256 timestamp) public pure override returns (uint256) {\\n        return ((timestamp.add(1 days) - SETTLEMENT_TIME) / 1 days) * 1 days + SETTLEMENT_TIME;\\n    }\\n\\n    /// @notice Return end timestamp of the trading week containing a given timestamp.\\n    ///\\n    ///         A trading week starts at UTC time `SETTLEMENT_TIME` on a Thursday (inclusive)\\n    ///         and ends at the same time of the next Thursday (exclusive).\\n    /// @param timestamp The given timestamp\\n    /// @return End timestamp of the trading week.\\n    function endOfWeek(uint256 timestamp) external pure returns (uint256) {\\n        return _endOfWeek(timestamp);\\n    }\\n\\n    function tokenQ() external view override returns (address) {\\n        return _tokenQ;\\n    }\\n\\n    function tokenB() external view override returns (address) {\\n        return _tokenB;\\n    }\\n\\n    function tokenR() external view override returns (address) {\\n        return _tokenR;\\n    }\\n\\n    function tokenShare(uint256 tranche) external view override returns (address) {\\n        return _getShare(tranche);\\n    }\\n\\n    function primaryMarket() external view override returns (address) {\\n        return _primaryMarket;\\n    }\\n\\n    function primaryMarketUpdateProposal() external view override returns (address, uint256) {\\n        return (_proposedPrimaryMarket, _proposedPrimaryMarketTimestamp);\\n    }\\n\\n    function strategy() external view override returns (address) {\\n        return _strategy;\\n    }\\n\\n    function strategyUpdateProposal() external view override returns (address, uint256) {\\n        return (_proposedStrategy, _proposedStrategyTimestamp);\\n    }\\n\\n    /// @notice Return the status of the fund contract.\\n    /// @param timestamp Timestamp to assess\\n    /// @return True if the fund contract is active\\n    function isFundActive(uint256 timestamp) public view override returns (bool) {\\n        return timestamp >= fundActivityStartTime;\\n    }\\n\\n    function getTotalUnderlying() public view override returns (uint256) {\\n        uint256 hot = IERC20(tokenUnderlying).balanceOf(address(this));\\n        return hot.add(_strategyUnderlying).sub(_totalDebt);\\n    }\\n\\n    function getStrategyUnderlying() external view override returns (uint256) {\\n        return _strategyUnderlying;\\n    }\\n\\n    function getTotalDebt() external view override returns (uint256) {\\n        return _totalDebt;\\n    }\\n\\n    /// @notice Equivalent BISHOP supply, as if all QUEEN are split.\\n    function getEquivalentTotalB() public view override returns (uint256) {\\n        return _totalSupplies[TRANCHE_Q].multiplyDecimal(splitRatio).add(_totalSupplies[TRANCHE_B]);\\n    }\\n\\n    /// @notice Equivalent QUEEN supply, as if all BISHOP and ROOK are merged.\\n    function getEquivalentTotalQ() external view override returns (uint256) {\\n        return _totalSupplies[TRANCHE_B].divideDecimal(splitRatio).add(_totalSupplies[TRANCHE_Q]);\\n    }\\n\\n    /// @notice Return the rebalance matrix at a given index. A zero struct is returned\\n    ///         if `index` is out of bound.\\n    /// @param index Rebalance index\\n    /// @return A rebalance matrix\\n    function getRebalance(uint256 index) external view override returns (Rebalance memory) {\\n        return _rebalances[index];\\n    }\\n\\n    /// @notice Return timestamp of the transaction triggering the rebalance at a given index.\\n    ///         Zero is returned if `index` is out of bound.\\n    /// @param index Rebalance index\\n    /// @return Timestamp of the rebalance\\n    function getRebalanceTimestamp(uint256 index) external view override returns (uint256) {\\n        return _rebalances[index].timestamp;\\n    }\\n\\n    /// @notice Return the number of historical rebalances.\\n    function getRebalanceSize() external view override returns (uint256) {\\n        return _rebalanceSize;\\n    }\\n\\n    /// @notice Return split ratio at a given version.\\n    ///         Zero is returned if `version` is invalid.\\n    /// @param version Rebalance version\\n    /// @return Split ratio of the version\\n    function historicalSplitRatio(uint256 version) external view override returns (uint256) {\\n        return _historicalSplitRatio[version];\\n    }\\n\\n    /// @notice Return NAV of BISHOP and ROOK of the given trading day.\\n    /// @param day End timestamp of a trading day\\n    /// @return navB NAV of BISHOP\\n    /// @return navR NAV of ROOK\\n    function historicalNavs(uint256 day)\\n        external\\n        view\\n        override\\n        returns (uint256 navB, uint256 navR)\\n    {\\n        return (_historicalNavB[day], _historicalNavR[day]);\\n    }\\n\\n    /// @notice Estimate the current NAV of all tranches, considering underlying price change,\\n    ///         accrued protocol fee and accrued interest since the previous settlement.\\n    ///\\n    ///         The extrapolation uses simple interest instead of daily compound interest in\\n    ///         calculating protocol fee and BISHOP's interest. There may be significant error\\n    ///         in the returned values when `timestamp` is far beyond the last settlement.\\n    /// @param price Price of the underlying asset (18 decimal places)\\n    /// @return navSum Sum of the estimated NAV of BISHOP and ROOK\\n    /// @return navB Estimated NAV of BISHOP\\n    /// @return navROrZero Estimated NAV of ROOK, or zero if the NAV is negative\\n    function extrapolateNav(uint256 price)\\n        external\\n        view\\n        override\\n        returns (\\n            uint256 navSum,\\n            uint256 navB,\\n            uint256 navROrZero\\n        )\\n    {\\n        uint256 settledDay = currentDay - 1 days;\\n        uint256 underlying = getTotalUnderlying();\\n        uint256 protocolFee =\\n            underlying.multiplyDecimal(dailyProtocolFeeRate).mul(block.timestamp - settledDay).div(\\n                1 days\\n            );\\n        underlying = underlying.sub(protocolFee);\\n        return\\n            _extrapolateNav(block.timestamp, settledDay, price, getEquivalentTotalB(), underlying);\\n    }\\n\\n    function _extrapolateNav(\\n        uint256 timestamp,\\n        uint256 settledDay,\\n        uint256 price,\\n        uint256 equivalentTotalB,\\n        uint256 underlying\\n    )\\n        private\\n        view\\n        returns (\\n            uint256 navSum,\\n            uint256 navB,\\n            uint256 navROrZero\\n        )\\n    {\\n        navB = _historicalNavB[settledDay];\\n        if (equivalentTotalB > 0) {\\n            navSum = price.mul(underlying.mul(underlyingDecimalMultiplier)).div(equivalentTotalB);\\n            navB = navB.multiplyDecimal(\\n                historicalInterestRate[settledDay].mul(timestamp - settledDay).div(1 days).add(UNIT)\\n            );\\n            navROrZero = navSum >= navB ? navSum - navB : 0;\\n        } else {\\n            // If the fund is empty, use NAV in the last day\\n            navROrZero = _historicalNavR[settledDay];\\n            navSum = navB + navROrZero;\\n        }\\n    }\\n\\n    /// @notice Transform share amounts according to the rebalance at a given index.\\n    ///         This function performs no bounds checking on the given index. A non-existent\\n    ///         rebalance transforms anything to a zero vector.\\n    /// @param amountQ Amount of QUEEN before the rebalance\\n    /// @param amountB Amount of BISHOP before the rebalance\\n    /// @param amountR Amount of ROOK before the rebalance\\n    /// @param index Rebalance index\\n    /// @return newAmountQ Amount of QUEEN after the rebalance\\n    /// @return newAmountB Amount of BISHOP after the rebalance\\n    /// @return newAmountR Amount of ROOK after the rebalance\\n    function doRebalance(\\n        uint256 amountQ,\\n        uint256 amountB,\\n        uint256 amountR,\\n        uint256 index\\n    )\\n        public\\n        view\\n        override\\n        returns (\\n            uint256 newAmountQ,\\n            uint256 newAmountB,\\n            uint256 newAmountR\\n        )\\n    {\\n        Rebalance storage rebalance = _rebalances[index];\\n        newAmountQ = amountQ.add(amountB.multiplyDecimal(rebalance.ratioB2Q)).add(\\n            amountR.multiplyDecimal(rebalance.ratioR2Q)\\n        );\\n        uint256 ratioBR = rebalance.ratioBR; // Gas saver\\n        newAmountB = amountB.multiplyDecimal(ratioBR);\\n        newAmountR = amountR.multiplyDecimal(ratioBR);\\n    }\\n\\n    /// @notice Transform share amounts according to rebalances in a given index range,\\n    ///         This function performs no bounds checking on the given indices. The original amounts\\n    ///         are returned if `fromIndex` is no less than `toIndex`. A zero vector is returned\\n    ///         if `toIndex` is greater than the number of existing rebalances.\\n    /// @param amountQ Amount of QUEEN before the rebalance\\n    /// @param amountB Amount of BISHOP before the rebalance\\n    /// @param amountR Amount of ROOK before the rebalance\\n    /// @param fromIndex Starting of the rebalance index range, inclusive\\n    /// @param toIndex End of the rebalance index range, exclusive\\n    /// @return newAmountQ Amount of QUEEN after the rebalance\\n    /// @return newAmountB Amount of BISHOP after the rebalance\\n    /// @return newAmountR Amount of ROOK after the rebalance\\n    function batchRebalance(\\n        uint256 amountQ,\\n        uint256 amountB,\\n        uint256 amountR,\\n        uint256 fromIndex,\\n        uint256 toIndex\\n    )\\n        external\\n        view\\n        override\\n        returns (\\n            uint256 newAmountQ,\\n            uint256 newAmountB,\\n            uint256 newAmountR\\n        )\\n    {\\n        for (uint256 i = fromIndex; i < toIndex; i++) {\\n            (amountQ, amountB, amountR) = doRebalance(amountQ, amountB, amountR, i);\\n        }\\n        newAmountQ = amountQ;\\n        newAmountB = amountB;\\n        newAmountR = amountR;\\n    }\\n\\n    /// @notice Transform share balance to a given rebalance version, or to the latest version\\n    ///         if `targetVersion` is zero.\\n    /// @param account Account of the balance to rebalance\\n    /// @param targetVersion The target rebalance version, or zero for the latest version\\n    function refreshBalance(address account, uint256 targetVersion) external override {\\n        if (targetVersion > 0) {\\n            require(targetVersion <= _rebalanceSize, \\\"Target version out of bound\\\");\\n        }\\n        _refreshBalance(account, targetVersion);\\n    }\\n\\n    /// @notice Transform allowance to a given rebalance version, or to the latest version\\n    ///         if `targetVersion` is zero.\\n    /// @param owner Owner of the allowance to rebalance\\n    /// @param spender Spender of the allowance to rebalance\\n    /// @param targetVersion The target rebalance version, or zero for the latest version\\n    function refreshAllowance(\\n        address owner,\\n        address spender,\\n        uint256 targetVersion\\n    ) external override {\\n        if (targetVersion > 0) {\\n            require(targetVersion <= _rebalanceSize, \\\"Target version out of bound\\\");\\n        }\\n        _refreshAllowance(owner, spender, targetVersion);\\n    }\\n\\n    function trancheBalanceOf(uint256 tranche, address account)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        uint256 amountQ = _balances[account][TRANCHE_Q];\\n        uint256 amountB = _balances[account][TRANCHE_B];\\n        uint256 amountR = _balances[account][TRANCHE_R];\\n\\n        if (tranche == TRANCHE_Q) {\\n            if (amountQ == 0 && amountB == 0 && amountR == 0) return 0;\\n        } else if (tranche == TRANCHE_B) {\\n            if (amountB == 0) return 0;\\n        } else {\\n            if (amountR == 0) return 0;\\n        }\\n\\n        uint256 size = _rebalanceSize; // Gas saver\\n        for (uint256 i = _balanceVersions[account]; i < size; i++) {\\n            (amountQ, amountB, amountR) = doRebalance(amountQ, amountB, amountR, i);\\n        }\\n\\n        if (tranche == TRANCHE_Q) {\\n            return amountQ;\\n        } else if (tranche == TRANCHE_B) {\\n            return amountB;\\n        } else {\\n            return amountR;\\n        }\\n    }\\n\\n    /// @notice Return all three share balances transformed to the latest rebalance version.\\n    /// @param account Owner of the shares\\n    function trancheAllBalanceOf(address account)\\n        external\\n        view\\n        override\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256 amountQ = _balances[account][TRANCHE_Q];\\n        uint256 amountB = _balances[account][TRANCHE_B];\\n        uint256 amountR = _balances[account][TRANCHE_R];\\n\\n        uint256 size = _rebalanceSize; // Gas saver\\n        for (uint256 i = _balanceVersions[account]; i < size; i++) {\\n            (amountQ, amountB, amountR) = doRebalance(amountQ, amountB, amountR, i);\\n        }\\n\\n        return (amountQ, amountB, amountR);\\n    }\\n\\n    function trancheBalanceVersion(address account) external view override returns (uint256) {\\n        return _balanceVersions[account];\\n    }\\n\\n    function trancheAllowance(\\n        uint256 tranche,\\n        address owner,\\n        address spender\\n    ) external view override returns (uint256) {\\n        uint256 allowanceQ = _allowances[owner][spender][TRANCHE_Q];\\n        uint256 allowanceB = _allowances[owner][spender][TRANCHE_B];\\n        uint256 allowanceR = _allowances[owner][spender][TRANCHE_R];\\n\\n        if (tranche == TRANCHE_Q) {\\n            if (allowanceQ == 0) return 0;\\n        } else if (tranche == TRANCHE_B) {\\n            if (allowanceB == 0) return 0;\\n        } else {\\n            if (allowanceR == 0) return 0;\\n        }\\n\\n        uint256 size = _rebalanceSize; // Gas saver\\n        for (uint256 i = _allowanceVersions[owner][spender]; i < size; i++) {\\n            (allowanceQ, allowanceB, allowanceR) = _rebalanceAllowance(\\n                allowanceQ,\\n                allowanceB,\\n                allowanceR,\\n                i\\n            );\\n        }\\n\\n        if (tranche == TRANCHE_Q) {\\n            return allowanceQ;\\n        } else if (tranche == TRANCHE_B) {\\n            return allowanceB;\\n        } else {\\n            return allowanceR;\\n        }\\n    }\\n\\n    function trancheAllowanceVersion(address owner, address spender)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _allowanceVersions[owner][spender];\\n    }\\n\\n    function trancheTransfer(\\n        uint256 tranche,\\n        address recipient,\\n        uint256 amount,\\n        uint256 version\\n    ) external override onlyCurrentVersion(version) {\\n        _refreshBalance(msg.sender, version);\\n        _refreshBalance(recipient, version);\\n        _transfer(tranche, msg.sender, recipient, amount);\\n    }\\n\\n    function trancheTransferFrom(\\n        uint256 tranche,\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        uint256 version\\n    ) external override onlyCurrentVersion(version) {\\n        _refreshAllowance(sender, msg.sender, version);\\n        uint256 newAllowance =\\n            _allowances[sender][msg.sender][tranche].sub(\\n                amount,\\n                \\\"ERC20: transfer amount exceeds allowance\\\"\\n            );\\n        _approve(tranche, sender, msg.sender, newAllowance);\\n        _refreshBalance(sender, version);\\n        _refreshBalance(recipient, version);\\n        _transfer(tranche, sender, recipient, amount);\\n    }\\n\\n    function trancheApprove(\\n        uint256 tranche,\\n        address spender,\\n        uint256 amount,\\n        uint256 version\\n    ) external override onlyCurrentVersion(version) {\\n        _refreshAllowance(msg.sender, spender, version);\\n        _approve(tranche, msg.sender, spender, amount);\\n    }\\n\\n    function trancheTotalSupply(uint256 tranche) external view override returns (uint256) {\\n        return _totalSupplies[tranche];\\n    }\\n\\n    function primaryMarketMint(\\n        uint256 tranche,\\n        address account,\\n        uint256 amount,\\n        uint256 version\\n    ) external override onlyPrimaryMarket onlyCurrentVersion(version) {\\n        _refreshBalance(account, version);\\n        _mint(tranche, account, amount);\\n    }\\n\\n    function primaryMarketBurn(\\n        uint256 tranche,\\n        address account,\\n        uint256 amount,\\n        uint256 version\\n    ) external override onlyPrimaryMarket onlyCurrentVersion(version) {\\n        _refreshBalance(account, version);\\n        _burn(tranche, account, amount);\\n    }\\n\\n    function shareTransfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public override {\\n        uint256 tranche = _getTranche(msg.sender);\\n        if (tranche != TRANCHE_Q) {\\n            require(isFundActive(block.timestamp), \\\"Transfer is inactive\\\");\\n        }\\n        _refreshBalance(sender, _rebalanceSize);\\n        _refreshBalance(recipient, _rebalanceSize);\\n        _transfer(tranche, sender, recipient, amount);\\n    }\\n\\n    function shareTransferFrom(\\n        address spender,\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external override returns (uint256 newAllowance) {\\n        uint256 tranche = _getTranche(msg.sender);\\n        shareTransfer(sender, recipient, amount);\\n        _refreshAllowance(sender, spender, _rebalanceSize);\\n        newAllowance = _allowances[sender][spender][tranche].sub(\\n            amount,\\n            \\\"ERC20: transfer amount exceeds allowance\\\"\\n        );\\n        _approve(tranche, sender, spender, newAllowance);\\n    }\\n\\n    function shareApprove(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) external override {\\n        uint256 tranche = _getTranche(msg.sender);\\n        _refreshAllowance(owner, spender, _rebalanceSize);\\n        _approve(tranche, owner, spender, amount);\\n    }\\n\\n    function shareIncreaseAllowance(\\n        address sender,\\n        address spender,\\n        uint256 addedValue\\n    ) external override returns (uint256 newAllowance) {\\n        uint256 tranche = _getTranche(msg.sender);\\n        _refreshAllowance(sender, spender, _rebalanceSize);\\n        newAllowance = _allowances[sender][spender][tranche].add(addedValue);\\n        _approve(tranche, sender, spender, newAllowance);\\n    }\\n\\n    function shareDecreaseAllowance(\\n        address sender,\\n        address spender,\\n        uint256 subtractedValue\\n    ) external override returns (uint256 newAllowance) {\\n        uint256 tranche = _getTranche(msg.sender);\\n        _refreshAllowance(sender, spender, _rebalanceSize);\\n        newAllowance = _allowances[sender][spender][tranche].sub(subtractedValue);\\n        _approve(tranche, sender, spender, newAllowance);\\n    }\\n\\n    function _transfer(\\n        uint256 tranche,\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) private {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n        _balances[sender][tranche] = _balances[sender][tranche].sub(\\n            amount,\\n            \\\"ERC20: transfer amount exceeds balance\\\"\\n        );\\n        _balances[recipient][tranche] = _balances[recipient][tranche].add(amount);\\n        IShareV2(_getShare(tranche)).fundEmitTransfer(sender, recipient, amount);\\n    }\\n\\n    function _mint(\\n        uint256 tranche,\\n        address account,\\n        uint256 amount\\n    ) private {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n        _totalSupplies[tranche] = _totalSupplies[tranche].add(amount);\\n        _balances[account][tranche] = _balances[account][tranche].add(amount);\\n        IShareV2(_getShare(tranche)).fundEmitTransfer(address(0), account, amount);\\n    }\\n\\n    function _burn(\\n        uint256 tranche,\\n        address account,\\n        uint256 amount\\n    ) private {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n        _balances[account][tranche] = _balances[account][tranche].sub(\\n            amount,\\n            \\\"ERC20: burn amount exceeds balance\\\"\\n        );\\n        _totalSupplies[tranche] = _totalSupplies[tranche].sub(amount);\\n        IShareV2(_getShare(tranche)).fundEmitTransfer(account, address(0), amount);\\n    }\\n\\n    function _approve(\\n        uint256 tranche,\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) private {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n        _allowances[owner][spender][tranche] = amount;\\n        IShareV2(_getShare(tranche)).fundEmitApproval(owner, spender, amount);\\n    }\\n\\n    /// @notice Settle the current trading day. Settlement includes the following changes\\n    ///         to the fund.\\n    ///\\n    ///         1. Charge protocol fee of the day.\\n    ///         2. Settle all pending creations and redemptions from the primary market.\\n    ///         3. Calculate NAV of the day and trigger rebalance if necessary.\\n    ///         4. Capture new interest rate for BISHOP.\\n    function settle() external nonReentrant {\\n        uint256 day = currentDay;\\n        require(day != 0, \\\"Not initialized\\\");\\n        require(block.timestamp >= day, \\\"The current trading day does not end yet\\\");\\n        uint256 price = twapOracle.getTwap(day);\\n        require(price != 0, \\\"Underlying price for settlement is not ready yet\\\");\\n\\n        _collectFee();\\n\\n        IPrimaryMarketV3(_primaryMarket).settle(day);\\n\\n        _payFeeDebt();\\n\\n        // Calculate NAV\\n        uint256 equivalentTotalB = getEquivalentTotalB();\\n        uint256 underlying = getTotalUnderlying();\\n        (uint256 navSum, uint256 navB, uint256 navR) =\\n            _extrapolateNav(day, day - 1 days, price, equivalentTotalB, underlying);\\n\\n        if (_shouldTriggerRebalance(navB, navR)) {\\n            uint256 newSplitRatio = splitRatio.multiplyDecimal(navSum) / 2;\\n            _triggerRebalance(day, navSum, navB, navR, newSplitRatio);\\n            navB = UNIT;\\n            navR = UNIT;\\n            equivalentTotalB = getEquivalentTotalB();\\n            fundActivityStartTime = day + activityDelayTimeAfterRebalance;\\n        } else {\\n            fundActivityStartTime = day;\\n        }\\n\\n        uint256 interestRate = _updateInterestRate(day);\\n        historicalInterestRate[day] = interestRate;\\n\\n        historicalEquivalentTotalB[day] = equivalentTotalB;\\n        historicalUnderlying[day] = underlying;\\n        _historicalNavB[day] = navB;\\n        _historicalNavR[day] = navR;\\n        currentDay = day + 1 days;\\n\\n        emit Settled(day, navB, navR, interestRate);\\n    }\\n\\n    function transferToStrategy(uint256 amount) external override onlyStrategy {\\n        _strategyUnderlying = _strategyUnderlying.add(amount);\\n        IERC20(tokenUnderlying).safeTransfer(_strategy, amount);\\n    }\\n\\n    function transferFromStrategy(uint256 amount) external override onlyStrategy {\\n        _strategyUnderlying = _strategyUnderlying.sub(amount);\\n        IERC20(tokenUnderlying).safeTransferFrom(_strategy, address(this), amount);\\n        _payFeeDebt();\\n    }\\n\\n    function primaryMarketTransferUnderlying(\\n        address recipient,\\n        uint256 amount,\\n        uint256 fee\\n    ) external override onlyPrimaryMarket {\\n        IERC20(tokenUnderlying).safeTransfer(recipient, amount);\\n        feeDebt = feeDebt.add(fee);\\n        _updateTotalDebt(_totalDebt.add(fee));\\n    }\\n\\n    function primaryMarketAddDebt(uint256 amount, uint256 fee) external override onlyPrimaryMarket {\\n        redemptionDebt = redemptionDebt.add(amount);\\n        feeDebt = feeDebt.add(fee);\\n        _updateTotalDebt(_totalDebt.add(amount).add(fee));\\n    }\\n\\n    function primaryMarketPayDebt(uint256 amount) external override onlyPrimaryMarket {\\n        redemptionDebt = redemptionDebt.sub(amount);\\n        _updateTotalDebt(_totalDebt.sub(amount));\\n        IERC20(tokenUnderlying).safeTransfer(msg.sender, amount);\\n    }\\n\\n    function reportProfit(uint256 profit, uint256 performanceFee) external override onlyStrategy {\\n        require(profit >= performanceFee, \\\"Performance fee cannot exceed profit\\\");\\n        _strategyUnderlying = _strategyUnderlying.add(profit);\\n        feeDebt = feeDebt.add(performanceFee);\\n        _updateTotalDebt(_totalDebt.add(performanceFee));\\n        emit ProfitReported(profit, performanceFee);\\n    }\\n\\n    function reportLoss(uint256 loss) external override onlyStrategy {\\n        _strategyUnderlying = _strategyUnderlying.sub(loss);\\n        emit LossReported(loss);\\n    }\\n\\n    function proposePrimaryMarketUpdate(address newPrimaryMarket) external onlyOwner {\\n        _proposePrimaryMarketUpdate(newPrimaryMarket);\\n    }\\n\\n    function applyPrimaryMarketUpdate(address newPrimaryMarket) external onlyOwner {\\n        require(\\n            IPrimaryMarketV3(_primaryMarket).canBeRemovedFromFund(),\\n            \\\"Cannot update primary market\\\"\\n        );\\n        _applyPrimaryMarketUpdate(newPrimaryMarket);\\n    }\\n\\n    function proposeStrategyUpdate(address newStrategy) external onlyOwner {\\n        _proposeStrategyUpdate(newStrategy);\\n    }\\n\\n    function applyStrategyUpdate(address newStrategy) external onlyOwner {\\n        require(_totalDebt == 0, \\\"Cannot update strategy with debt\\\");\\n        _applyStrategyUpdate(newStrategy);\\n    }\\n\\n    function _updateDailyProtocolFeeRate(uint256 newDailyProtocolFeeRate) private {\\n        require(\\n            newDailyProtocolFeeRate <= MAX_DAILY_PROTOCOL_FEE_RATE,\\n            \\\"Exceed max protocol fee rate\\\"\\n        );\\n        dailyProtocolFeeRate = newDailyProtocolFeeRate;\\n        emit DailyProtocolFeeRateUpdated(newDailyProtocolFeeRate);\\n    }\\n\\n    function updateDailyProtocolFeeRate(uint256 newDailyProtocolFeeRate) external onlyOwner {\\n        _updateDailyProtocolFeeRate(newDailyProtocolFeeRate);\\n    }\\n\\n    function _updateTwapOracle(address newTwapOracle) private {\\n        twapOracle = ITwapOracleV2(newTwapOracle);\\n        emit TwapOracleUpdated(newTwapOracle);\\n    }\\n\\n    function updateTwapOracle(address newTwapOracle) external onlyOwner {\\n        _updateTwapOracle(newTwapOracle);\\n    }\\n\\n    function _updateAprOracle(address newAprOracle) private {\\n        aprOracle = IAprOracle(newAprOracle);\\n        emit AprOracleUpdated(newAprOracle);\\n    }\\n\\n    function updateAprOracle(address newAprOracle) external onlyOwner {\\n        _updateAprOracle(newAprOracle);\\n    }\\n\\n    function _updateBallot(address newBallot) private {\\n        ballot = IBallot(newBallot);\\n        emit BallotUpdated(newBallot);\\n    }\\n\\n    function updateBallot(address newBallot) external onlyOwner {\\n        _updateBallot(newBallot);\\n    }\\n\\n    function _updateFeeCollector(address newFeeCollector) private {\\n        feeCollector = newFeeCollector;\\n        emit FeeCollectorUpdated(newFeeCollector);\\n    }\\n\\n    function updateFeeCollector(address newFeeCollector) external onlyOwner {\\n        _updateFeeCollector(newFeeCollector);\\n    }\\n\\n    function _updateActivityDelayTime(uint256 delayTime) private {\\n        require(\\n            delayTime >= 30 minutes && delayTime <= 12 hours,\\n            \\\"Exceed allowed delay time range\\\"\\n        );\\n        activityDelayTimeAfterRebalance = delayTime;\\n        emit ActivityDelayTimeUpdated(delayTime);\\n    }\\n\\n    function updateActivityDelayTime(uint256 delayTime) external onlyOwner {\\n        _updateActivityDelayTime(delayTime);\\n    }\\n\\n    /// @dev Transfer protocol fee of the current trading day to the fee collector.\\n    ///      This function should be called before creation and redemption on the same day\\n    ///      are settled.\\n    function _collectFee() private {\\n        uint256 currentUnderlying = getTotalUnderlying();\\n        uint256 fee = currentUnderlying.multiplyDecimal(dailyProtocolFeeRate);\\n        if (fee > 0) {\\n            feeDebt = feeDebt.add(fee);\\n            _updateTotalDebt(_totalDebt.add(fee));\\n        }\\n    }\\n\\n    function _payFeeDebt() private {\\n        uint256 total = _totalDebt;\\n        if (total == 0) {\\n            return;\\n        }\\n        uint256 hot = IERC20(tokenUnderlying).balanceOf(address(this));\\n        if (hot == 0) {\\n            return;\\n        }\\n        uint256 fee = feeDebt;\\n        if (fee > 0) {\\n            uint256 amount = hot.min(fee);\\n            feeDebt = fee - amount;\\n            _updateTotalDebt(total - amount);\\n            // Call `feeCollector.checkpoint()` without errors.\\n            // This is a intended behavior because `feeCollector` may not have `checkpoint()`.\\n            (bool success, ) = feeCollector.call(abi.encodeWithSignature(\\\"checkpoint()\\\"));\\n            if (!success) {\\n                // ignore\\n            }\\n            IERC20(tokenUnderlying).safeTransfer(feeCollector, amount);\\n            emit FeeDebtPaid(amount);\\n        }\\n    }\\n\\n    /// @dev Check whether a new rebalance should be triggered. Rebalance is triggered if\\n    ///      ROOK's NAV over BISHOP's NAV is greater than the upper threshold or\\n    ///      less than the lower threshold.\\n    /// @param navB BISHOP's NAV before the rebalance\\n    /// @param navROrZero ROOK's NAV before the rebalance or zero if the NAV is negative\\n    /// @return Whether a new rebalance should be triggered\\n    function _shouldTriggerRebalance(uint256 navB, uint256 navROrZero) private view returns (bool) {\\n        uint256 rOverB = navROrZero.divideDecimal(navB);\\n        return rOverB < lowerRebalanceThreshold || rOverB > upperRebalanceThreshold;\\n    }\\n\\n    /// @dev Create a new rebalance that resets NAV of all tranches to 1. Total supplies are\\n    ///      rebalanced immediately.\\n    /// @param day Trading day that triggers this rebalance\\n    /// @param navSum Sum of BISHOP and ROOK's NAV\\n    /// @param navB BISHOP's NAV before this rebalance\\n    /// @param navROrZero ROOK's NAV before this rebalance or zero if the NAV is negative\\n    /// @param newSplitRatio The new split ratio after this rebalance\\n    function _triggerRebalance(\\n        uint256 day,\\n        uint256 navSum,\\n        uint256 navB,\\n        uint256 navROrZero,\\n        uint256 newSplitRatio\\n    ) private {\\n        Rebalance memory rebalance = _calculateRebalance(navSum, navB, navROrZero, newSplitRatio);\\n        uint256 oldSize = _rebalanceSize;\\n        splitRatio = newSplitRatio;\\n        _historicalSplitRatio[oldSize + 1] = newSplitRatio;\\n        emit SplitRatioUpdated(newSplitRatio);\\n        _rebalances[oldSize] = rebalance;\\n        _rebalanceSize = oldSize + 1;\\n        emit RebalanceTriggered(\\n            oldSize,\\n            day,\\n            navSum,\\n            navB,\\n            navROrZero,\\n            rebalance.ratioB2Q,\\n            rebalance.ratioR2Q,\\n            rebalance.ratioBR\\n        );\\n\\n        (\\n            _totalSupplies[TRANCHE_Q],\\n            _totalSupplies[TRANCHE_B],\\n            _totalSupplies[TRANCHE_R]\\n        ) = doRebalance(\\n            _totalSupplies[TRANCHE_Q],\\n            _totalSupplies[TRANCHE_B],\\n            _totalSupplies[TRANCHE_R],\\n            oldSize\\n        );\\n        _refreshBalance(address(this), oldSize + 1);\\n    }\\n\\n    /// @dev Create a new rebalance matrix that resets given NAVs to (1, 1).\\n    ///\\n    ///      Note that ROOK's NAV can be negative before the rebalance when the underlying price\\n    ///      drops dramatically in a single trading day, in which case zero should be passed to\\n    ///      this function instead of the negative NAV.\\n    /// @param navSum Sum of BISHOP and ROOK's NAV\\n    /// @param navB BISHOP's NAV before the rebalance\\n    /// @param navROrZero ROOK's NAV before the rebalance or zero if the NAV is negative\\n    /// @param newSplitRatio The new split ratio after this rebalance\\n    /// @return The rebalance matrix\\n    function _calculateRebalance(\\n        uint256 navSum,\\n        uint256 navB,\\n        uint256 navROrZero,\\n        uint256 newSplitRatio\\n    ) private view returns (Rebalance memory) {\\n        uint256 ratioBR;\\n        uint256 ratioB2Q;\\n        uint256 ratioR2Q;\\n        if (navROrZero <= navB) {\\n            // Lower rebalance\\n            ratioBR = navROrZero;\\n            ratioB2Q = (navSum / 2 - navROrZero).divideDecimal(newSplitRatio);\\n            ratioR2Q = 0;\\n        } else {\\n            // Upper rebalance\\n            ratioBR = UNIT;\\n            ratioB2Q = (navB - UNIT).divideDecimal(newSplitRatio) / 2;\\n            ratioR2Q = (navROrZero - UNIT).divideDecimal(newSplitRatio) / 2;\\n        }\\n        return\\n            Rebalance({\\n                ratioB2Q: ratioB2Q,\\n                ratioR2Q: ratioR2Q,\\n                ratioBR: ratioBR,\\n                timestamp: block.timestamp\\n            });\\n    }\\n\\n    function _updateInterestRate(uint256 week) private returns (uint256) {\\n        uint256 baseInterestRate = MAX_INTEREST_RATE.min(aprOracle.capture());\\n        uint256 floatingInterestRate = ballot.count(week).div(365);\\n        uint256 rate = baseInterestRate.add(floatingInterestRate);\\n\\n        emit InterestRateUpdated(baseInterestRate, floatingInterestRate);\\n\\n        return rate;\\n    }\\n\\n    function _updateTotalDebt(uint256 newTotalDebt) private {\\n        _totalDebt = newTotalDebt;\\n        emit TotalDebtUpdated(newTotalDebt);\\n    }\\n\\n    /// @dev Transform share balance to a given rebalance version, or to the latest version\\n    ///      if `targetVersion` is zero. This function does no bound check on `targetVersion`.\\n    /// @param account Account of the balance to rebalance\\n    /// @param targetVersion The target rebalance version, or zero for the latest version\\n    function _refreshBalance(address account, uint256 targetVersion) private {\\n        if (targetVersion == 0) {\\n            targetVersion = _rebalanceSize;\\n        }\\n        uint256 oldVersion = _balanceVersions[account];\\n        if (oldVersion >= targetVersion) {\\n            return;\\n        }\\n\\n        uint256[TRANCHE_COUNT] storage balanceTuple = _balances[account];\\n        uint256 balanceQ = balanceTuple[TRANCHE_Q];\\n        uint256 balanceB = balanceTuple[TRANCHE_B];\\n        uint256 balanceR = balanceTuple[TRANCHE_R];\\n        _balanceVersions[account] = targetVersion;\\n\\n        if (balanceQ == 0 && balanceB == 0 && balanceR == 0) {\\n            // Fast path for an empty account\\n            return;\\n        }\\n\\n        for (uint256 i = oldVersion; i < targetVersion; i++) {\\n            (balanceQ, balanceB, balanceR) = doRebalance(balanceQ, balanceB, balanceR, i);\\n        }\\n        balanceTuple[TRANCHE_Q] = balanceQ;\\n        balanceTuple[TRANCHE_B] = balanceB;\\n        balanceTuple[TRANCHE_R] = balanceR;\\n\\n        emit BalancesRebalanced(account, targetVersion, balanceQ, balanceB, balanceR);\\n    }\\n\\n    /// @dev Transform allowance to a given rebalance version, or to the latest version\\n    ///      if `targetVersion` is zero. This function does no bound check on `targetVersion`.\\n    /// @param owner Owner of the allowance to rebalance\\n    /// @param spender Spender of the allowance to rebalance\\n    /// @param targetVersion The target rebalance version, or zero for the latest version\\n    function _refreshAllowance(\\n        address owner,\\n        address spender,\\n        uint256 targetVersion\\n    ) private {\\n        if (targetVersion == 0) {\\n            targetVersion = _rebalanceSize;\\n        }\\n        uint256 oldVersion = _allowanceVersions[owner][spender];\\n        if (oldVersion >= targetVersion) {\\n            return;\\n        }\\n\\n        uint256[TRANCHE_COUNT] storage allowanceTuple = _allowances[owner][spender];\\n        uint256 allowanceQ = allowanceTuple[TRANCHE_Q];\\n        uint256 allowanceB = allowanceTuple[TRANCHE_B];\\n        uint256 allowanceR = allowanceTuple[TRANCHE_R];\\n        _allowanceVersions[owner][spender] = targetVersion;\\n\\n        if (allowanceQ == 0 && allowanceB == 0 && allowanceR == 0) {\\n            // Fast path for an empty allowance\\n            return;\\n        }\\n\\n        for (uint256 i = oldVersion; i < targetVersion; i++) {\\n            (allowanceQ, allowanceB, allowanceR) = _rebalanceAllowance(\\n                allowanceQ,\\n                allowanceB,\\n                allowanceR,\\n                i\\n            );\\n        }\\n        allowanceTuple[TRANCHE_Q] = allowanceQ;\\n        allowanceTuple[TRANCHE_B] = allowanceB;\\n        allowanceTuple[TRANCHE_R] = allowanceR;\\n\\n        emit AllowancesRebalanced(\\n            owner,\\n            spender,\\n            targetVersion,\\n            allowanceQ,\\n            allowanceB,\\n            allowanceR\\n        );\\n    }\\n\\n    function _rebalanceAllowance(\\n        uint256 allowanceQ,\\n        uint256 allowanceB,\\n        uint256 allowanceR,\\n        uint256 index\\n    )\\n        private\\n        view\\n        returns (\\n            uint256 newAllowanceQ,\\n            uint256 newAllowanceB,\\n            uint256 newAllowanceR\\n        )\\n    {\\n        Rebalance storage rebalance = _rebalances[index];\\n\\n        /// @dev using saturating arithmetic to avoid unconscious overflow revert\\n        newAllowanceQ = allowanceQ;\\n        newAllowanceB = allowanceB.saturatingMultiplyDecimal(rebalance.ratioBR);\\n        newAllowanceR = allowanceR.saturatingMultiplyDecimal(rebalance.ratioBR);\\n    }\\n\\n    modifier onlyCurrentVersion(uint256 version) {\\n        require(_rebalanceSize == version, \\\"Only current version\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/SafeDecimalMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nlibrary SafeDecimalMath {\\n    using SafeMath for uint256;\\n\\n    /* Number of decimal places in the representations. */\\n    uint256 private constant decimals = 18;\\n    uint256 private constant highPrecisionDecimals = 27;\\n\\n    /* The number representing 1.0. */\\n    uint256 private constant UNIT = 10**uint256(decimals);\\n\\n    /* The number representing 1.0 for higher fidelity numbers. */\\n    uint256 private constant PRECISE_UNIT = 10**uint256(highPrecisionDecimals);\\n    uint256 private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR =\\n        10**uint256(highPrecisionDecimals - decimals);\\n\\n    /**\\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\\n     * decimals.\\n     *\\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\\n     * so that product must be less than 2**256. As this is an integer division,\\n     * the internal division always rounds down. This helps save on gas. Rounding\\n     * is more expensive on gas.\\n     */\\n    function multiplyDecimal(uint256 x, uint256 y) internal pure returns (uint256) {\\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\\n        return x.mul(y).div(UNIT);\\n    }\\n\\n    function multiplyDecimalPrecise(uint256 x, uint256 y) internal pure returns (uint256) {\\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\\n        return x.mul(y).div(PRECISE_UNIT);\\n    }\\n\\n    /**\\n     * @return The result of safely dividing x and y. The return value is a high\\n     * precision decimal.\\n     *\\n     * @dev y is divided after the product of x and the standard precision unit\\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\\n     * this is an integer division, the result is always rounded down.\\n     * This helps save on gas. Rounding is more expensive on gas.\\n     */\\n    function divideDecimal(uint256 x, uint256 y) internal pure returns (uint256) {\\n        /* Reintroduce the UNIT factor that will be divided out by y. */\\n        return x.mul(UNIT).div(y);\\n    }\\n\\n    function divideDecimalPrecise(uint256 x, uint256 y) internal pure returns (uint256) {\\n        /* Reintroduce the UNIT factor that will be divided out by y. */\\n        return x.mul(PRECISE_UNIT).div(y);\\n    }\\n\\n    /**\\n     * @dev Convert a standard decimal representation to a high precision one.\\n     */\\n    function decimalToPreciseDecimal(uint256 i) internal pure returns (uint256) {\\n        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\\n    }\\n\\n    /**\\n     * @dev Convert a high precision decimal to a standard decimal representation.\\n     */\\n    function preciseDecimalToDecimal(uint256 i) internal pure returns (uint256) {\\n        uint256 quotientTimesTen = i.mul(10).div(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\\n\\n        if (quotientTimesTen % 10 >= 5) {\\n            quotientTimesTen = quotientTimesTen.add(10);\\n        }\\n\\n        return quotientTimesTen.div(10);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, and the max value of\\n     * uint256 on overflow.\\n     */\\n    function saturatingMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n        uint256 c = a * b;\\n        return c / a != b ? type(uint256).max : c;\\n    }\\n\\n    function saturatingMultiplyDecimal(uint256 x, uint256 y) internal pure returns (uint256) {\\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\\n        return saturatingMul(x, y).div(UNIT);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/CoreUtility.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nabstract contract CoreUtility {\\n    using SafeMath for uint256;\\n\\n    /// @dev UTC time of a day when the fund settles.\\n    uint256 internal constant SETTLEMENT_TIME = 14 hours;\\n\\n    /// @dev Return end timestamp of the trading week containing a given timestamp.\\n    ///\\n    ///      A trading week starts at UTC time `SETTLEMENT_TIME` on a Thursday (inclusive)\\n    ///      and ends at the same time of the next Thursday (exclusive).\\n    /// @param timestamp The given timestamp\\n    /// @return End timestamp of the trading week.\\n    function _endOfWeek(uint256 timestamp) internal pure returns (uint256) {\\n        return ((timestamp.add(1 weeks) - SETTLEMENT_TIME) / 1 weeks) * 1 weeks + SETTLEMENT_TIME;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPrimaryMarketV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"./IFundV3.sol\\\";\\n\\ninterface IPrimaryMarketV3 {\\n    function fund() external view returns (IFundV3);\\n\\n    function getCreation(uint256 underlying) external view returns (uint256 outQ);\\n\\n    function getCreationForQ(uint256 minOutQ) external view returns (uint256 underlying);\\n\\n    function getRedemption(uint256 inQ) external view returns (uint256 underlying, uint256 fee);\\n\\n    function getRedemptionForUnderlying(uint256 minUnderlying) external view returns (uint256 inQ);\\n\\n    function getSplit(uint256 inQ) external view returns (uint256 outB);\\n\\n    function getSplitForB(uint256 minOutB) external view returns (uint256 inQ);\\n\\n    function getMerge(uint256 inB) external view returns (uint256 outQ, uint256 feeQ);\\n\\n    function getMergeForQ(uint256 minOutQ) external view returns (uint256 inB);\\n\\n    function canBeRemovedFromFund() external view returns (bool);\\n\\n    function create(\\n        address recipient,\\n        uint256 minOutQ,\\n        uint256 version\\n    ) external returns (uint256 outQ);\\n\\n    function redeem(\\n        address recipient,\\n        uint256 inQ,\\n        uint256 minUnderlying,\\n        uint256 version\\n    ) external returns (uint256 underlying);\\n\\n    function redeemAndUnwrap(\\n        address recipient,\\n        uint256 inQ,\\n        uint256 minUnderlying,\\n        uint256 version\\n    ) external returns (uint256 underlying);\\n\\n    function queueRedemption(\\n        address recipient,\\n        uint256 inQ,\\n        uint256 minUnderlying,\\n        uint256 version\\n    ) external returns (uint256 underlying, uint256 index);\\n\\n    function claimRedemptions(address account, uint256[] calldata indices)\\n        external\\n        returns (uint256 underlying);\\n\\n    function claimRedemptionsAndUnwrap(address account, uint256[] calldata indices)\\n        external\\n        returns (uint256 underlying);\\n\\n    function split(\\n        address recipient,\\n        uint256 inQ,\\n        uint256 version\\n    ) external returns (uint256 outB);\\n\\n    function merge(\\n        address recipient,\\n        uint256 inB,\\n        uint256 version\\n    ) external returns (uint256 outQ);\\n\\n    function settle(uint256 day) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFundV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ITwapOracleV2.sol\\\";\\n\\ninterface IFundV3 {\\n    /// @notice A linear transformation matrix that represents a rebalance.\\n    ///\\n    ///         ```\\n    ///             [        1        0        0 ]\\n    ///         R = [ ratioB2Q  ratioBR        0 ]\\n    ///             [ ratioR2Q        0  ratioBR ]\\n    ///         ```\\n    ///\\n    ///         Amounts of the three tranches `q`, `b` and `r` can be rebalanced by multiplying the matrix:\\n    ///\\n    ///         ```\\n    ///         [ q', b', r' ] = [ q, b, r ] * R\\n    ///         ```\\n    struct Rebalance {\\n        uint256 ratioB2Q;\\n        uint256 ratioR2Q;\\n        uint256 ratioBR;\\n        uint256 timestamp;\\n    }\\n\\n    function tokenUnderlying() external view returns (address);\\n\\n    function tokenQ() external view returns (address);\\n\\n    function tokenB() external view returns (address);\\n\\n    function tokenR() external view returns (address);\\n\\n    function tokenShare(uint256 tranche) external view returns (address);\\n\\n    function primaryMarket() external view returns (address);\\n\\n    function primaryMarketUpdateProposal() external view returns (address, uint256);\\n\\n    function strategy() external view returns (address);\\n\\n    function strategyUpdateProposal() external view returns (address, uint256);\\n\\n    function underlyingDecimalMultiplier() external view returns (uint256);\\n\\n    function twapOracle() external view returns (ITwapOracleV2);\\n\\n    function feeCollector() external view returns (address);\\n\\n    function endOfDay(uint256 timestamp) external pure returns (uint256);\\n\\n    function trancheTotalSupply(uint256 tranche) external view returns (uint256);\\n\\n    function trancheBalanceOf(uint256 tranche, address account) external view returns (uint256);\\n\\n    function trancheAllBalanceOf(address account)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function trancheBalanceVersion(address account) external view returns (uint256);\\n\\n    function trancheAllowance(\\n        uint256 tranche,\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    function trancheAllowanceVersion(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function trancheTransfer(\\n        uint256 tranche,\\n        address recipient,\\n        uint256 amount,\\n        uint256 version\\n    ) external;\\n\\n    function trancheTransferFrom(\\n        uint256 tranche,\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        uint256 version\\n    ) external;\\n\\n    function trancheApprove(\\n        uint256 tranche,\\n        address spender,\\n        uint256 amount,\\n        uint256 version\\n    ) external;\\n\\n    function getRebalanceSize() external view returns (uint256);\\n\\n    function getRebalance(uint256 index) external view returns (Rebalance memory);\\n\\n    function getRebalanceTimestamp(uint256 index) external view returns (uint256);\\n\\n    function currentDay() external view returns (uint256);\\n\\n    function splitRatio() external view returns (uint256);\\n\\n    function historicalSplitRatio(uint256 version) external view returns (uint256);\\n\\n    function fundActivityStartTime() external view returns (uint256);\\n\\n    function isFundActive(uint256 timestamp) external view returns (bool);\\n\\n    function getEquivalentTotalB() external view returns (uint256);\\n\\n    function getEquivalentTotalQ() external view returns (uint256);\\n\\n    function historicalEquivalentTotalB(uint256 timestamp) external view returns (uint256);\\n\\n    function historicalNavs(uint256 timestamp) external view returns (uint256 navB, uint256 navR);\\n\\n    function extrapolateNav(uint256 price)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function doRebalance(\\n        uint256 amountQ,\\n        uint256 amountB,\\n        uint256 amountR,\\n        uint256 index\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 newAmountQ,\\n            uint256 newAmountB,\\n            uint256 newAmountR\\n        );\\n\\n    function batchRebalance(\\n        uint256 amountQ,\\n        uint256 amountB,\\n        uint256 amountR,\\n        uint256 fromIndex,\\n        uint256 toIndex\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 newAmountQ,\\n            uint256 newAmountB,\\n            uint256 newAmountR\\n        );\\n\\n    function refreshBalance(address account, uint256 targetVersion) external;\\n\\n    function refreshAllowance(\\n        address owner,\\n        address spender,\\n        uint256 targetVersion\\n    ) external;\\n\\n    function primaryMarketMint(\\n        uint256 tranche,\\n        address account,\\n        uint256 amount,\\n        uint256 version\\n    ) external;\\n\\n    function primaryMarketBurn(\\n        uint256 tranche,\\n        address account,\\n        uint256 amount,\\n        uint256 version\\n    ) external;\\n\\n    function shareTransfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external;\\n\\n    function shareTransferFrom(\\n        address spender,\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (uint256 newAllowance);\\n\\n    function shareIncreaseAllowance(\\n        address sender,\\n        address spender,\\n        uint256 addedValue\\n    ) external returns (uint256 newAllowance);\\n\\n    function shareDecreaseAllowance(\\n        address sender,\\n        address spender,\\n        uint256 subtractedValue\\n    ) external returns (uint256 newAllowance);\\n\\n    function shareApprove(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) external;\\n\\n    function historicalUnderlying(uint256 timestamp) external view returns (uint256);\\n\\n    function getTotalUnderlying() external view returns (uint256);\\n\\n    function getStrategyUnderlying() external view returns (uint256);\\n\\n    function getTotalDebt() external view returns (uint256);\\n\\n    function transferToStrategy(uint256 amount) external;\\n\\n    function transferFromStrategy(uint256 amount) external;\\n\\n    function reportProfit(uint256 profit, uint256 performanceFee) external;\\n\\n    function reportLoss(uint256 loss) external;\\n\\n    function primaryMarketTransferUnderlying(\\n        address recipient,\\n        uint256 amount,\\n        uint256 fee\\n    ) external;\\n\\n    function primaryMarketAddDebt(uint256 amount, uint256 fee) external;\\n\\n    function primaryMarketPayDebt(uint256 amount) external;\\n\\n    event RebalanceTriggered(\\n        uint256 indexed index,\\n        uint256 indexed day,\\n        uint256 navSum,\\n        uint256 navB,\\n        uint256 navROrZero,\\n        uint256 ratioB2Q,\\n        uint256 ratioR2Q,\\n        uint256 ratioBR\\n    );\\n    event Settled(uint256 indexed day, uint256 navB, uint256 navR, uint256 interestRate);\\n    event InterestRateUpdated(uint256 baseInterestRate, uint256 floatingInterestRate);\\n    event BalancesRebalanced(\\n        address indexed account,\\n        uint256 version,\\n        uint256 balanceQ,\\n        uint256 balanceB,\\n        uint256 balanceR\\n    );\\n    event AllowancesRebalanced(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 version,\\n        uint256 allowanceQ,\\n        uint256 allowanceB,\\n        uint256 allowanceR\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IShareV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IShareV2 is IERC20 {\\n    function fundEmitTransfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external;\\n\\n    function fundEmitApproval(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITwapOracleV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"./ITwapOracle.sol\\\";\\n\\ninterface ITwapOracleV2 is ITwapOracle {\\n    function getLatest() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAprOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\ninterface IAprOracle {\\n    function capture() external returns (uint256 dailyRate);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBallot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\ninterface IBallot {\\n    struct Voter {\\n        uint256 amount;\\n        uint256 unlockTime;\\n        uint256 weight;\\n    }\\n\\n    function count(uint256 timestamp) external view returns (uint256);\\n\\n    function syncWithVotingEscrow(address account) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVotingEscrow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\ninterface IVotingEscrow {\\n    struct LockedBalance {\\n        uint256 amount;\\n        uint256 unlockTime;\\n    }\\n\\n    function token() external view returns (address);\\n\\n    function maxTime() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOfAtTimestamp(address account, uint256 timestamp)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getTimestampDropBelow(address account, uint256 threshold)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getLockedBalance(address account) external view returns (LockedBalance memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITwapOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\ninterface ITwapOracle {\\n    enum UpdateType {PRIMARY, SECONDARY, OWNER, CHAINLINK, UNISWAP_V2}\\n\\n    function getTwap(uint256 timestamp) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/upgrade/UpgradeTool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\nimport \\\"../../utils/SafeDecimalMath.sol\\\";\\nimport \\\"../../utils/CoreUtility.sol\\\";\\nimport \\\"../interfaces/IFundV2.sol\\\";\\nimport \\\"../../fund/FundV3.sol\\\";\\nimport \\\"../../fund/ShareStaking.sol\\\";\\nimport \\\"../interfaces/IPrimaryMarketV2.sol\\\";\\nimport \\\"../../interfaces/ITwapOracle.sol\\\";\\nimport \\\"../../interfaces/IAprOracle.sol\\\";\\nimport \\\"../../interfaces/IBallot.sol\\\";\\nimport \\\"../interfaces/ITrancheIndex.sol\\\";\\n\\ninterface IOldExchange {\\n    function protocolUpgrade(address account)\\n        external\\n        returns (\\n            uint256 amountM,\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 claimedRewards\\n        );\\n}\\n\\ninterface IDailyProtocolFeeRate {\\n    function dailyProtocolFeeRate() external view returns (uint256);\\n}\\n\\n/// @notice This is the core contract for the upgrade to Tranchess V2. It replaces the following\\n///         contracts of the Tranchess protocol during the upgrade process:\\n///\\n///         * TwapOracle of the old Fund\\n///         * PrimaryMarket of the old Fund\\n///         * PrimaryMarket of the new Fund\\n/// @dev The upgrade procedure consists of the following stages:\\n///\\n///      *STAGE_START*. The owner of the old Fund changes both primary market and TWAP oracle\\n///      to this contract. As a primary market, it records the old tranche tokens' total supplies\\n///      and asks the old Fund to transfer all underlying tokens but one unit to this contract when\\n///      the old Fund settles. As a TWAP oracle, it returns a special value to ensure the total value\\n///      of the old Fund does not change after almost all underlying tokens are transferred out,\\n///      so that no rebalance is triggered.\\n///\\n///      * Change Fund's primary market to this contract\\ncontract UpgradeTool is\\n    ITwapOracle,\\n    IAprOracle,\\n    IBallot,\\n    IPrimaryMarketV2,\\n    ITrancheIndex,\\n    CoreUtility,\\n    Ownable\\n{\\n    using SafeMath for uint256;\\n    using SafeDecimalMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    event Upgraded(\\n        address account,\\n        uint256 oldM,\\n        uint256 oldA,\\n        uint256 oldB,\\n        uint256 newM,\\n        uint256 newA,\\n        uint256 newB,\\n        uint256 claimedRewards\\n    );\\n\\n    uint256 private constant STAGE_START = 0;\\n    uint256 private constant STAGE_SETTLED = 1;\\n    uint256 private constant STAGE_UPGRADED = 2;\\n\\n    IFund public immutable oldFund;\\n    ITwapOracle public immutable originTwapOracle;\\n    IERC20 public immutable tokenUnderlying;\\n    IERC20 public immutable oldTokenM;\\n    IERC20 public immutable oldTokenA;\\n    IERC20 public immutable oldTokenB;\\n    uint256 public immutable oldFundVersion;\\n\\n    IOldExchange public immutable oldExchange;\\n\\n    FundV3 public immutable newFund;\\n    ShareStaking public immutable newStaking;\\n\\n    uint256 public immutable upgradeTimestamp;\\n\\n    uint256 public stage;\\n\\n    /// @notice Total amount of underlying tokens managed by the old Fund right before this upgrade.\\n    uint256 public upgradeUnderlying;\\n\\n    /// @notice Initial split ratio of the new Fund.\\n    uint256 public initialSplitRatio;\\n\\n    constructor(\\n        address oldFund_,\\n        uint256 oldFundVersion_,\\n        address oldExchange_,\\n        address newFund_,\\n        address newStaking_,\\n        uint256 upgradeTimestamp_\\n    ) public {\\n        oldFund = IFund(oldFund_);\\n        originTwapOracle = ITwapOracle(IFund(oldFund_).twapOracle());\\n        tokenUnderlying = IERC20(IFund(oldFund_).tokenUnderlying());\\n        oldTokenM = IERC20(IFund(oldFund_).tokenM());\\n        oldTokenA = IERC20(IFund(oldFund_).tokenA());\\n        oldTokenB = IERC20(IFund(oldFund_).tokenB());\\n        oldFundVersion = oldFundVersion_;\\n\\n        oldExchange = IOldExchange(oldExchange_);\\n\\n        newFund = FundV3(newFund_);\\n        require(IFund(oldFund_).tokenUnderlying() == IFund(newFund_).tokenUnderlying());\\n        newStaking = ShareStaking(newStaking_);\\n        require(address(ShareStaking(newStaking_).fund()) == newFund_);\\n\\n        require(upgradeTimestamp_ + 1 weeks == _endOfWeek(upgradeTimestamp_));\\n        upgradeTimestamp = upgradeTimestamp_;\\n    }\\n\\n    modifier onlyStage(uint256 expectedStage) {\\n        require(stage == expectedStage, \\\"Incorrect stage\\\");\\n        _;\\n    }\\n\\n    /// @dev This is used by 3rd-party tools to calculate TVL in the SETTLED stage.\\n    function currentCreatingUnderlying() external view returns (uint256) {\\n        return\\n            stage <= STAGE_SETTLED ? upgradeUnderlying : tokenUnderlying.balanceOf(address(this));\\n    }\\n\\n    /// @notice As a special TWAP oracle of the old Fund, it returns the same value as the original\\n    ///         oracle before the protocol upgrade. After the upgrade, it constantly returns the\\n    ///         total value of the Fund at the time of the upgrade, which keeps NAV of the Fund\\n    ///         constant forever.\\n    function getTwap(uint256 timestamp) external view override returns (uint256) {\\n        if (timestamp < upgradeTimestamp) {\\n            return originTwapOracle.getTwap(timestamp);\\n        } else {\\n            uint256 underlying = upgradeUnderlying;\\n            if (underlying == 0) {\\n                // We are in stage STAGE_START and all underlying tokens are still in the old Fund.\\n                underlying = oldFundVersion == 2\\n                    ? IFundV2(address(oldFund)).getTotalUnderlying()\\n                    : tokenUnderlying.balanceOf(address(oldFund));\\n                uint256 protocolFee =\\n                    underlying.multiplyDecimal(\\n                        IDailyProtocolFeeRate(address(oldFund)).dailyProtocolFeeRate()\\n                    );\\n                underlying = underlying.sub(protocolFee);\\n            }\\n            return originTwapOracle.getTwap(upgradeTimestamp).mul(underlying);\\n        }\\n    }\\n\\n    /// @notice As a special APR oracle of the old Fund, it always returns zero to keep\\n    ///         Tranche A's NAV unchanged.\\n    function capture() external override returns (uint256) {\\n        return 0;\\n    }\\n\\n    /// @notice As a special interest rate ballot of the old Fund, it always returns zero to keep\\n    ///         Tranche A's NAV unchanged.\\n    function count(uint256) external view override returns (uint256) {\\n        return 0;\\n    }\\n\\n    /// @dev For IBallot.\\n    function syncWithVotingEscrow(address account) external override {}\\n\\n    /// @dev For IPrimaryMarketV2.\\n    function claim(address) external override returns (uint256, uint256) {\\n        revert(\\\"Not allowed\\\");\\n    }\\n\\n    /// @dev For IPrimaryMarketV2.\\n    function claimAndUnwrap(address) external override returns (uint256, uint256) {\\n        revert(\\\"Not allowed\\\");\\n    }\\n\\n    /// @dev For IPrimaryMarketV2.\\n    function updateDelayedRedemptionDay() external override {}\\n\\n    /// @dev For IPrimaryMarketV3.\\n    function canBeRemovedFromFund() external view returns (bool) {\\n        return stage == STAGE_UPGRADED;\\n    }\\n\\n    /// @dev For IPrimaryMarketV3.\\n    function settle(uint256) external {}\\n\\n    function settle(\\n        uint256 day,\\n        uint256, // fundTotalShares\\n        uint256 fundUnderlying,\\n        uint256, // underlyingPrice\\n        uint256 // previousNav\\n    )\\n        external\\n        override\\n        returns (\\n            uint256 sharesToMint,\\n            uint256 sharesToBurn,\\n            uint256 creationUnderlying,\\n            uint256 redemptionUnderlying,\\n            uint256 fee\\n        )\\n    {\\n        require(oldFund.twapOracle() == this, \\\"Not TWAP oracle of the old fund\\\");\\n        require(msg.sender == address(oldFund), \\\"Only old fund\\\");\\n        if (day < upgradeTimestamp) {\\n            return (0, 0, 0, 0, 0);\\n        }\\n        if (stage == STAGE_START) {\\n            upgradeUnderlying = fundUnderlying;\\n            stage = STAGE_SETTLED;\\n        }\\n\\n        // Fetch all but 1 unit of underlying tokens from the Fund. This guarantees that there's\\n        // only 1 unit of underlying token left in the old Fund at each settlement after the upgrade,\\n        // so that the NAVs remain the same and no rebalance will be triggered. In case that someone\\n        // transfers underlying tokens directly to the old Fund, these tokens will be transferred to\\n        // and forever locked in this contract.\\n        redemptionUnderlying = fundUnderlying.sub(1);\\n    }\\n\\n    /// @notice Transfer all underlying tokens to the new Fund and mint all new tranche tokens.\\n    ///         When this function is called, this contract should be the primary market of the\\n    ///         new Fund and the new Fund should be empty.\\n    function createNewTokens() external onlyOwner onlyStage(STAGE_SETTLED) {\\n        (, uint256 navA, uint256 navB) = oldFund.historicalNavs(upgradeTimestamp);\\n        uint256 splitRatio =\\n            originTwapOracle.getTwap(upgradeTimestamp).divideDecimal(navA.add(navB));\\n        initialSplitRatio = splitRatio;\\n        uint256 hotBalance = tokenUnderlying.balanceOf(address(this));\\n        newFund.initialize(splitRatio, navA, navB, upgradeUnderlying.sub(hotBalance));\\n        newFund.transferOwnership(owner());\\n\\n        tokenUnderlying.safeTransfer(address(newFund), hotBalance);\\n        newFund.primaryMarketMint(\\n            TRANCHE_M,\\n            address(this),\\n            oldFund.shareTotalSupply(TRANCHE_M).divideDecimal(splitRatio.mul(2)),\\n            0\\n        );\\n        newFund.primaryMarketMint(TRANCHE_A, address(this), oldFund.shareTotalSupply(TRANCHE_A), 0);\\n        newFund.primaryMarketMint(TRANCHE_B, address(this), oldFund.shareTotalSupply(TRANCHE_B), 0);\\n        stage = STAGE_UPGRADED;\\n    }\\n\\n    /// @notice Transfer all underlying tokens back to the old Fund in case of emergency rollback.\\n    function rollback() external onlyOwner onlyStage(STAGE_SETTLED) {\\n        tokenUnderlying.safeTransfer(address(oldFund), tokenUnderlying.balanceOf(address(this)));\\n    }\\n\\n    /// @notice Transfer the new fund's ownership back to admin in case that `createNewTokens()`\\n    ///         fails unexpectedly.\\n    function transferNewFundOwnership() external onlyOwner {\\n        newFund.transferOwnership(owner());\\n    }\\n\\n    function protocolUpgrade(address account)\\n        external\\n        onlyStage(STAGE_UPGRADED)\\n        returns (\\n            uint256 amountM,\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 claimedRewards\\n        )\\n    {\\n        if (Address.isContract(account)) {\\n            // It is unsafe to upgrade for a smart contract. Such operation is only allowed by\\n            // the contract itself or the owner.\\n            require(\\n                msg.sender == account || msg.sender == owner(),\\n                \\\"Smart contracts can only be upgraded by itself or admin\\\"\\n            );\\n        }\\n\\n        // Burn unstaked old tokens\\n        (uint256 oldBalanceM, uint256 oldBalanceA, uint256 oldBalanceB) =\\n            oldFund.allShareBalanceOf(account);\\n        if (oldBalanceM > 0) {\\n            oldFund.burn(TRANCHE_M, account, oldBalanceM);\\n        }\\n        if (oldBalanceA > 0) {\\n            oldFund.burn(TRANCHE_A, account, oldBalanceA);\\n        }\\n        if (oldBalanceB > 0) {\\n            oldFund.burn(TRANCHE_B, account, oldBalanceB);\\n        }\\n\\n        // Burn staked old tokens\\n        {\\n            uint256 stakedM;\\n            uint256 stakedA;\\n            uint256 stakedB;\\n            (stakedM, stakedA, stakedB, claimedRewards) = oldExchange.protocolUpgrade(account);\\n            if (stakedM > 0) {\\n                oldFund.burn(TRANCHE_M, address(oldExchange), stakedM);\\n                oldBalanceM = oldBalanceM.add(stakedM);\\n            }\\n            if (stakedA > 0) {\\n                oldFund.burn(TRANCHE_A, address(oldExchange), stakedA);\\n                oldBalanceA = oldBalanceA.add(stakedA);\\n            }\\n            if (stakedB > 0) {\\n                oldFund.burn(TRANCHE_B, address(oldExchange), stakedB);\\n                oldBalanceB = oldBalanceB.add(stakedB);\\n            }\\n        }\\n\\n        // Mint all collected old tokens so that their total supplies do not change\\n        if (oldBalanceM > 0) {\\n            oldFund.mint(TRANCHE_M, address(this), oldBalanceM);\\n        }\\n        if (oldBalanceA > 0) {\\n            oldFund.mint(TRANCHE_A, address(this), oldBalanceA);\\n        }\\n        if (oldBalanceB > 0) {\\n            oldFund.mint(TRANCHE_B, address(this), oldBalanceB);\\n        }\\n\\n        uint256 newVersion = newFund.getRebalanceSize();\\n        amountM = oldBalanceM.divideDecimal(initialSplitRatio.mul(2));\\n        amountA = oldBalanceA;\\n        amountB = oldBalanceB;\\n        if (newVersion > 0) {\\n            (amountM, amountA, amountB) = newFund.batchRebalance(\\n                amountM,\\n                amountA,\\n                amountB,\\n                0,\\n                newVersion\\n            );\\n        }\\n\\n        newFund.trancheTransfer(TRANCHE_M, address(newStaking), amountM, newVersion);\\n        newStaking.deposit(TRANCHE_M, amountM, account, newVersion);\\n        newFund.trancheTransfer(TRANCHE_A, address(newStaking), amountA, newVersion);\\n        newStaking.deposit(TRANCHE_A, amountA, account, newVersion);\\n        newFund.trancheTransfer(TRANCHE_B, address(newStaking), amountB, newVersion);\\n        newStaking.deposit(TRANCHE_B, amountB, account, newVersion);\\n\\n        emit Upgraded(\\n            account,\\n            oldBalanceM,\\n            oldBalanceA,\\n            oldBalanceB,\\n            amountM,\\n            amountA,\\n            amountB,\\n            claimedRewards\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/interfaces/IFundV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./IFund.sol\\\";\\n\\ninterface IFundV2 is IFund {\\n    function historicalUnderlying(uint256 timestamp) external view returns (uint256);\\n\\n    function getTotalUnderlying() external view returns (uint256);\\n\\n    function getStrategyUnderlying() external view returns (uint256);\\n\\n    function getTotalDebt() external view returns (uint256);\\n\\n    function transferToStrategy(uint256 amount) external;\\n\\n    function transferFromStrategy(uint256 amount) external;\\n\\n    function reportProfit(uint256 profit, uint256 performanceFee) external;\\n\\n    function reportLoss(uint256 loss) external;\\n}\\n\"\r\n    },\r\n    \"contracts/fund/ShareStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\nimport \\\"../utils/SafeDecimalMath.sol\\\";\\nimport \\\"../utils/CoreUtility.sol\\\";\\n\\nimport \\\"../interfaces/IFundV3.sol\\\";\\nimport \\\"../interfaces/IChessController.sol\\\";\\nimport \\\"../interfaces/IChessSchedule.sol\\\";\\nimport \\\"../interfaces/ITrancheIndexV2.sol\\\";\\nimport \\\"../interfaces/IVotingEscrow.sol\\\";\\n\\ncontract ShareStaking is ITrancheIndexV2, CoreUtility {\\n    using Math for uint256;\\n    using SafeMath for uint256;\\n    using SafeDecimalMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    event Deposited(uint256 tranche, address account, uint256 amount);\\n    event Withdrawn(uint256 tranche, address account, uint256 amount);\\n\\n    uint256 private constant MAX_ITERATIONS = 500;\\n\\n    uint256 private constant REWARD_WEIGHT_B = 2;\\n    uint256 private constant REWARD_WEIGHT_R = 1;\\n    uint256 private constant REWARD_WEIGHT_Q = 3;\\n    uint256 private constant MAX_BOOSTING_FACTOR = 3e18;\\n    uint256 private constant MAX_BOOSTING_FACTOR_MINUS_ONE = MAX_BOOSTING_FACTOR - 1e18;\\n\\n    IFundV3 public immutable fund;\\n\\n    /// @notice The Chess release schedule contract.\\n    IChessSchedule public immutable chessSchedule;\\n\\n    /// @notice The controller contract.\\n    IChessController public immutable chessController;\\n\\n    IVotingEscrow private immutable _votingEscrow;\\n\\n    /// @notice Timestamp when rewards start.\\n    uint256 public immutable rewardStartTimestamp;\\n\\n    /// @dev Per-fund CHESS emission rate. The product of CHESS emission rate\\n    ///      and weekly percentage of the fund\\n    uint256 private _rate;\\n\\n    /// @dev Total amount of user shares, i.e. sum of all entries in `_balances`.\\n    uint256[TRANCHE_COUNT] private _totalSupplies;\\n\\n    /// @dev Rebalance version of `_totalSupplies`.\\n    uint256 private _totalSupplyVersion;\\n\\n    /// @dev Amount of shares staked by each user.\\n    mapping(address => uint256[TRANCHE_COUNT]) private _balances;\\n\\n    /// @dev Rebalance version mapping for `_balances`.\\n    mapping(address => uint256) private _balanceVersions;\\n\\n    /// @dev Mapping of rebalance version => split ratio.\\n    mapping(uint256 => uint256) private _historicalSplitRatio;\\n\\n    /// @dev 1e27 * \u222b(rate(t) / totalWeight(t) dt) from the latest rebalance till checkpoint.\\n    uint256 private _invTotalWeightIntegral;\\n\\n    /// @dev Final `_invTotalWeightIntegral` before each rebalance.\\n    ///      These values are accessed in a loop in `_userCheckpoint()` with bounds checking.\\n    ///      So we store them in a fixed-length array, in order to make compiler-generated\\n    ///      bounds checking on every access cheaper. The actual length of this array is stored in\\n    ///      `_historicalIntegralSize` and should be explicitly checked when necessary.\\n    uint256[65535] private _historicalIntegrals;\\n\\n    /// @dev Actual length of the `_historicalIntegrals` array, which always equals to the number of\\n    ///      historical rebalances after `checkpoint()` is called.\\n    uint256 private _historicalIntegralSize;\\n\\n    /// @dev Timestamp when checkpoint() is called.\\n    uint256 private _checkpointTimestamp;\\n\\n    /// @dev Snapshot of `_invTotalWeightIntegral` per user.\\n    mapping(address => uint256) private _userIntegrals;\\n\\n    /// @dev Mapping of account => claimable rewards.\\n    mapping(address => uint256) private _claimableRewards;\\n\\n    uint256 private _workingSupply;\\n    mapping(address => uint256) private _workingBalances;\\n\\n    constructor(\\n        address fund_,\\n        address chessSchedule_,\\n        address chessController_,\\n        address votingEscrow_,\\n        uint256 rewardStartTimestamp_\\n    ) public {\\n        fund = IFundV3(fund_);\\n        chessSchedule = IChessSchedule(chessSchedule_);\\n        chessController = IChessController(chessController_);\\n        _votingEscrow = IVotingEscrow(votingEscrow_);\\n        rewardStartTimestamp = rewardStartTimestamp_;\\n        _checkpointTimestamp = block.timestamp;\\n    }\\n\\n    function getRate() external view returns (uint256) {\\n        return _rate / 1e18;\\n    }\\n\\n    /// @notice Return weight of given balance with respect to rewards.\\n    /// @param amountQ Amount of QUEEN\\n    /// @param amountB Amount of BISHOP\\n    /// @param amountR Amount of ROOK\\n    /// @param splitRatio Split ratio\\n    /// @return Rewarding weight of the balance\\n    function weightedBalance(\\n        uint256 amountQ,\\n        uint256 amountB,\\n        uint256 amountR,\\n        uint256 splitRatio\\n    ) public pure returns (uint256) {\\n        return\\n            amountQ\\n                .mul(REWARD_WEIGHT_Q)\\n                .multiplyDecimal(splitRatio)\\n                .add(amountB.mul(REWARD_WEIGHT_B))\\n                .add(amountR.mul(REWARD_WEIGHT_R))\\n                .div(REWARD_WEIGHT_Q);\\n    }\\n\\n    function totalSupply(uint256 tranche) external view returns (uint256) {\\n        uint256 totalSupplyQ = _totalSupplies[TRANCHE_Q];\\n        uint256 totalSupplyB = _totalSupplies[TRANCHE_B];\\n        uint256 totalSupplyR = _totalSupplies[TRANCHE_R];\\n\\n        uint256 version = _totalSupplyVersion;\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        if (version < rebalanceSize) {\\n            (totalSupplyQ, totalSupplyB, totalSupplyR) = _fundBatchRebalance(\\n                totalSupplyQ,\\n                totalSupplyB,\\n                totalSupplyR,\\n                version,\\n                rebalanceSize\\n            );\\n        }\\n\\n        if (tranche == TRANCHE_Q) {\\n            return totalSupplyQ;\\n        } else if (tranche == TRANCHE_B) {\\n            return totalSupplyB;\\n        } else {\\n            return totalSupplyR;\\n        }\\n    }\\n\\n    function trancheBalanceOf(uint256 tranche, address account) external view returns (uint256) {\\n        uint256 amountQ = _balances[account][TRANCHE_Q];\\n        uint256 amountB = _balances[account][TRANCHE_B];\\n        uint256 amountR = _balances[account][TRANCHE_R];\\n\\n        if (tranche == TRANCHE_Q) {\\n            if (amountQ == 0 && amountB == 0 && amountR == 0) return 0;\\n        } else if (tranche == TRANCHE_B) {\\n            if (amountB == 0) return 0;\\n        } else {\\n            if (amountR == 0) return 0;\\n        }\\n\\n        uint256 version = _balanceVersions[account];\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        if (version < rebalanceSize) {\\n            (amountQ, amountB, amountR) = _fundBatchRebalance(\\n                amountQ,\\n                amountB,\\n                amountR,\\n                version,\\n                rebalanceSize\\n            );\\n        }\\n\\n        if (tranche == TRANCHE_Q) {\\n            return amountQ;\\n        } else if (tranche == TRANCHE_B) {\\n            return amountB;\\n        } else {\\n            return amountR;\\n        }\\n    }\\n\\n    function balanceVersion(address account) external view returns (uint256) {\\n        return _balanceVersions[account];\\n    }\\n\\n    function workingSupply() external view returns (uint256) {\\n        uint256 version = _totalSupplyVersion;\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        if (version < rebalanceSize) {\\n            (uint256 totalSupplyQ, uint256 totalSupplyB, uint256 totalSupplyR) =\\n                _fundBatchRebalance(\\n                    _totalSupplies[TRANCHE_Q],\\n                    _totalSupplies[TRANCHE_B],\\n                    _totalSupplies[TRANCHE_R],\\n                    version,\\n                    rebalanceSize\\n                );\\n            return weightedBalance(totalSupplyQ, totalSupplyB, totalSupplyR, fund.splitRatio());\\n        } else {\\n            return _workingSupply;\\n        }\\n    }\\n\\n    function workingBalanceOf(address account) external view returns (uint256) {\\n        uint256 version = _balanceVersions[account];\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        uint256 workingBalance = _workingBalances[account]; // gas saver\\n        if (version < rebalanceSize || workingBalance == 0) {\\n            uint256[TRANCHE_COUNT] storage balance = _balances[account];\\n            uint256 amountQ = balance[TRANCHE_Q];\\n            uint256 amountB = balance[TRANCHE_B];\\n            uint256 amountR = balance[TRANCHE_R];\\n            if (version < rebalanceSize) {\\n                (amountQ, amountB, amountR) = _fundBatchRebalance(\\n                    amountQ,\\n                    amountB,\\n                    amountR,\\n                    version,\\n                    rebalanceSize\\n                );\\n            }\\n            return weightedBalance(amountQ, amountB, amountR, fund.splitRatio());\\n        } else {\\n            return workingBalance;\\n        }\\n    }\\n\\n    function _fundRebalanceSize() internal view returns (uint256) {\\n        return fund.getRebalanceSize();\\n    }\\n\\n    function _fundDoRebalance(\\n        uint256 amountQ,\\n        uint256 amountB,\\n        uint256 amountR,\\n        uint256 index\\n    )\\n        internal\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        return fund.doRebalance(amountQ, amountB, amountR, index);\\n    }\\n\\n    function _fundBatchRebalance(\\n        uint256 amountQ,\\n        uint256 amountB,\\n        uint256 amountR,\\n        uint256 fromIndex,\\n        uint256 toIndex\\n    )\\n        internal\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        return fund.batchRebalance(amountQ, amountB, amountR, fromIndex, toIndex);\\n    }\\n\\n    /// @dev Stake share tokens. A user could send QUEEN before deposit().\\n    ///      The contract first measures how much tranche share it has received,\\n    ///      then transfer the rest from the user\\n    /// @param tranche Tranche of the share\\n    /// @param amount The amount to deposit\\n    /// @param recipient Address that receives deposit\\n    /// @param version The current rebalance version\\n    function deposit(\\n        uint256 tranche,\\n        uint256 amount,\\n        address recipient,\\n        uint256 version\\n    ) external {\\n        _checkpoint(version);\\n        _userCheckpoint(recipient, version);\\n        _balances[recipient][tranche] = _balances[recipient][tranche].add(amount);\\n        uint256 oldTotalSupply = _totalSupplies[tranche];\\n        _totalSupplies[tranche] = oldTotalSupply.add(amount);\\n        _updateWorkingBalance(recipient, version);\\n        uint256 spareAmount = fund.trancheBalanceOf(tranche, address(this)).sub(oldTotalSupply);\\n        if (spareAmount < amount) {\\n            // Retain the rest of share token (version is checked by the fund)\\n            fund.trancheTransferFrom(\\n                tranche,\\n                msg.sender,\\n                address(this),\\n                amount - spareAmount,\\n                version\\n            );\\n        } else {\\n            require(version == _fundRebalanceSize(), \\\"Invalid version\\\");\\n        }\\n        emit Deposited(tranche, recipient, amount);\\n    }\\n\\n    /// @notice Unstake tranche tokens.\\n    /// @param tranche Tranche of the share\\n    /// @param amount The amount to withdraw\\n    /// @param version The current rebalance version\\n    function withdraw(\\n        uint256 tranche,\\n        uint256 amount,\\n        uint256 version\\n    ) external {\\n        _checkpoint(version);\\n        _userCheckpoint(msg.sender, version);\\n        _balances[msg.sender][tranche] = _balances[msg.sender][tranche].sub(\\n            amount,\\n            \\\"Insufficient balance to withdraw\\\"\\n        );\\n        _totalSupplies[tranche] = _totalSupplies[tranche].sub(amount);\\n        _updateWorkingBalance(msg.sender, version);\\n        // version is checked by the fund\\n        fund.trancheTransfer(tranche, msg.sender, amount, version);\\n        emit Withdrawn(tranche, msg.sender, amount);\\n    }\\n\\n    /// @notice Transform share balance to a given rebalance version, or to the latest version\\n    ///         if `targetVersion` is zero.\\n    /// @param account Account of the balance to rebalance\\n    /// @param targetVersion The target rebalance version, or zero for the latest version\\n    function refreshBalance(address account, uint256 targetVersion) external {\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        if (targetVersion == 0) {\\n            targetVersion = rebalanceSize;\\n        } else {\\n            require(targetVersion <= rebalanceSize, \\\"Target version out of bound\\\");\\n        }\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(account, targetVersion);\\n    }\\n\\n    /// @notice Return claimable rewards of an account till now.\\n    ///\\n    ///         This function should be call as a \\\"view\\\" function off-chain to get\\n    ///         the return value, e.g. using `contract.claimableRewards.call(account)` in web3\\n    ///         or `contract.callStatic.claimableRewards(account)` in ethers.js.\\n    /// @param account Address of an account\\n    /// @return Amount of claimable rewards\\n    function claimableRewards(address account) external returns (uint256) {\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(account, rebalanceSize);\\n        return _claimableRewards[account];\\n    }\\n\\n    /// @notice Claim the rewards for an account.\\n    /// @param account Account to claim its rewards\\n    function claimRewards(address account) external {\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(account, rebalanceSize);\\n        uint256 amount = _claimableRewards[account];\\n        _claimableRewards[account] = 0;\\n        chessSchedule.mint(account, amount);\\n        _updateWorkingBalance(account, rebalanceSize);\\n    }\\n\\n    /// @notice Synchronize an account's locked Chess with `VotingEscrow`\\n    ///         and update its working balance.\\n    /// @param account Address of the synchronized account\\n    function syncWithVotingEscrow(address account) external {\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(account, rebalanceSize);\\n        _updateWorkingBalance(account, rebalanceSize);\\n    }\\n\\n    /// @dev Transform total supplies to the latest rebalance version and make a global reward checkpoint.\\n    /// @param rebalanceSize The number of existing rebalances. It must be the same as\\n    ///                       `fund.getRebalanceSize()`.\\n    function _checkpoint(uint256 rebalanceSize) private {\\n        uint256 timestamp = _checkpointTimestamp;\\n        if (timestamp >= block.timestamp) {\\n            return;\\n        }\\n\\n        uint256 integral = _invTotalWeightIntegral;\\n        uint256 endWeek = _endOfWeek(timestamp);\\n        uint256 version = _totalSupplyVersion;\\n        uint256 rebalanceTimestamp;\\n        if (version < rebalanceSize) {\\n            rebalanceTimestamp = fund.getRebalanceTimestamp(version);\\n        } else {\\n            rebalanceTimestamp = type(uint256).max;\\n        }\\n        uint256 rate = _rate;\\n        uint256 totalSupplyQ = _totalSupplies[TRANCHE_Q];\\n        uint256 totalSupplyB = _totalSupplies[TRANCHE_B];\\n        uint256 totalSupplyR = _totalSupplies[TRANCHE_R];\\n        uint256 weight = _workingSupply;\\n        uint256 timestamp_ = timestamp; // avoid stack too deep\\n\\n        for (uint256 i = 0; i < MAX_ITERATIONS && timestamp_ < block.timestamp; i++) {\\n            uint256 endTimestamp = rebalanceTimestamp.min(endWeek).min(block.timestamp);\\n\\n            if (weight > 0 && endTimestamp > rewardStartTimestamp) {\\n                integral = integral.add(\\n                    rate\\n                        .mul(endTimestamp.sub(timestamp_.max(rewardStartTimestamp)))\\n                        .decimalToPreciseDecimal()\\n                        .div(weight)\\n                );\\n            }\\n\\n            if (endTimestamp == rebalanceTimestamp) {\\n                uint256 oldSize = _historicalIntegralSize;\\n                _historicalIntegrals[oldSize] = integral;\\n                _historicalIntegralSize = oldSize + 1;\\n\\n                integral = 0;\\n                (totalSupplyQ, totalSupplyB, totalSupplyR) = _fundDoRebalance(\\n                    totalSupplyQ,\\n                    totalSupplyB,\\n                    totalSupplyR,\\n                    version\\n                );\\n\\n                version++;\\n                {\\n                    // Reset total weight boosting after the first rebalance\\n                    uint256 splitRatio = fund.historicalSplitRatio(version);\\n                    weight = weightedBalance(totalSupplyQ, totalSupplyB, totalSupplyR, splitRatio);\\n                    _historicalSplitRatio[version] = splitRatio;\\n                }\\n\\n                if (version < rebalanceSize) {\\n                    rebalanceTimestamp = fund.getRebalanceTimestamp(version);\\n                } else {\\n                    rebalanceTimestamp = type(uint256).max;\\n                }\\n            }\\n            if (endTimestamp == endWeek) {\\n                rate = chessSchedule.getRate(endWeek).mul(\\n                    chessController.getFundRelativeWeight(address(this), endWeek)\\n                );\\n                if (endWeek < rewardStartTimestamp && endWeek + 1 weeks > rewardStartTimestamp) {\\n                    // Rewards start in the middle of the next week. We adjust the rate to\\n                    // compensate for the period between `endWeek` and `rewardStartTimestamp`.\\n                    rate = rate.mul(1 weeks).div(endWeek + 1 weeks - rewardStartTimestamp);\\n                }\\n                endWeek += 1 weeks;\\n            }\\n\\n            timestamp_ = endTimestamp;\\n        }\\n\\n        _checkpointTimestamp = block.timestamp;\\n        _invTotalWeightIntegral = integral;\\n        _rate = rate;\\n        if (_totalSupplyVersion != rebalanceSize) {\\n            _totalSupplies[TRANCHE_Q] = totalSupplyQ;\\n            _totalSupplies[TRANCHE_B] = totalSupplyB;\\n            _totalSupplies[TRANCHE_R] = totalSupplyR;\\n            _totalSupplyVersion = rebalanceSize;\\n            // Reset total working weight before any boosting if rebalance ever triggered\\n            _workingSupply = weight;\\n        }\\n    }\\n\\n    /// @dev Transform a user's balance to a given rebalance version and update this user's rewards.\\n    ///\\n    ///      In most cases, the target version is the latest version and this function cumulates\\n    ///      rewards till now. When this function is called from `refreshBalance()`,\\n    ///      `targetVersion` can be an older version, in which case rewards are cumulated till\\n    ///      the end of that version (i.e. timestamp of the transaction triggering the rebalance\\n    ///      with index `targetVersion`).\\n    ///\\n    ///      This function should always be called after `_checkpoint()` is called, so that\\n    ///      the global reward checkpoint is guarenteed up to date.\\n    /// @param account Account to update\\n    /// @param targetVersion The target rebalance version\\n    function _userCheckpoint(address account, uint256 targetVersion) private {\\n        uint256 oldVersion = _balanceVersions[account];\\n        if (oldVersion > targetVersion) {\\n            return;\\n        }\\n        uint256 userIntegral = _userIntegrals[account];\\n        uint256 integral;\\n        // This scope is to avoid the \\\"stack too deep\\\" error.\\n        {\\n            // We assume that this function is always called immediately after `_checkpoint()`,\\n            // which guarantees that `_historicalIntegralSize` equals to the number of historical\\n            // rebalances.\\n            uint256 rebalanceSize = _historicalIntegralSize;\\n            integral = targetVersion == rebalanceSize\\n                ? _invTotalWeightIntegral\\n                : _historicalIntegrals[targetVersion];\\n        }\\n        if (userIntegral == integral && oldVersion == targetVersion) {\\n            // Return immediately when the user's rewards have already been updated to\\n            // the target version.\\n            return;\\n        }\\n\\n        uint256 rewards = _claimableRewards[account];\\n        uint256[TRANCHE_COUNT] storage balance = _balances[account];\\n        uint256 weight = _workingBalances[account];\\n        uint256 balanceQ = balance[TRANCHE_Q];\\n        uint256 balanceB = balance[TRANCHE_B];\\n        uint256 balanceR = balance[TRANCHE_R];\\n        for (uint256 i = oldVersion; i < targetVersion; i++) {\\n            rewards = rewards.add(\\n                weight.multiplyDecimalPrecise(_historicalIntegrals[i].sub(userIntegral))\\n            );\\n            if (balanceQ != 0 || balanceB != 0 || balanceR != 0) {\\n                (balanceQ, balanceB, balanceR) = _fundDoRebalance(balanceQ, balanceB, balanceR, i);\\n            }\\n            userIntegral = 0;\\n\\n            // Reset per-user weight boosting after the first rebalance\\n            weight = weightedBalance(balanceQ, balanceB, balanceR, _historicalSplitRatio[i + 1]);\\n        }\\n        rewards = rewards.add(weight.multiplyDecimalPrecise(integral.sub(userIntegral)));\\n        address account_ = account; // Fix the \\\"stack too deep\\\" error\\n        _claimableRewards[account_] = rewards;\\n        _userIntegrals[account_] = integral;\\n\\n        if (oldVersion < targetVersion) {\\n            balance[TRANCHE_Q] = balanceQ;\\n            balance[TRANCHE_B] = balanceB;\\n            balance[TRANCHE_R] = balanceR;\\n            _balanceVersions[account_] = targetVersion;\\n            _workingBalances[account_] = weight;\\n        }\\n    }\\n\\n    /// @dev Calculate working balance, which depends on the amount of staked tokens and veCHESS.\\n    ///      Before this function is called, both `_checkpoint()` and `_userCheckpoint(account)`\\n    ///      should be called to update `_workingSupply` and `_workingBalances[account]` to\\n    ///      the latest rebalance version.\\n    /// @param account User address\\n    /// @param rebalanceSize The number of existing rebalances. It must be the same as\\n    ///                       `fund.getRebalanceSize()`.\\n    function _updateWorkingBalance(address account, uint256 rebalanceSize) private {\\n        uint256 splitRatio = _historicalSplitRatio[rebalanceSize];\\n        if (splitRatio == 0) {\\n            // Read it from the fund in case that it's not initialized yet, e.g. when we reach here\\n            // for the first time and `rebalanceSize` is zero.\\n            splitRatio = fund.historicalSplitRatio(rebalanceSize);\\n            _historicalSplitRatio[rebalanceSize] = splitRatio;\\n        }\\n        uint256 weightedSupply =\\n            weightedBalance(\\n                _totalSupplies[TRANCHE_Q],\\n                _totalSupplies[TRANCHE_B],\\n                _totalSupplies[TRANCHE_R],\\n                splitRatio\\n            );\\n        uint256[TRANCHE_COUNT] storage balance = _balances[account];\\n        uint256 newWorkingBalance =\\n            weightedBalance(balance[TRANCHE_Q], balance[TRANCHE_B], balance[TRANCHE_R], splitRatio);\\n        uint256 veBalance = _votingEscrow.balanceOf(account);\\n        if (veBalance > 0) {\\n            uint256 veTotalSupply = _votingEscrow.totalSupply();\\n            uint256 maxWorkingBalance = newWorkingBalance.multiplyDecimal(MAX_BOOSTING_FACTOR);\\n            uint256 boostedWorkingBalance =\\n                newWorkingBalance.add(\\n                    weightedSupply\\n                        .mul(veBalance)\\n                        .multiplyDecimal(MAX_BOOSTING_FACTOR_MINUS_ONE)\\n                        .div(veTotalSupply)\\n                );\\n            newWorkingBalance = maxWorkingBalance.min(boostedWorkingBalance);\\n        }\\n\\n        _workingSupply = _workingSupply.sub(_workingBalances[account]).add(newWorkingBalance);\\n        _workingBalances[account] = newWorkingBalance;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/interfaces/IPrimaryMarketV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"./IPrimaryMarket.sol\\\";\\n\\ninterface IPrimaryMarketV2 is IPrimaryMarket {\\n    function claimAndUnwrap(address account)\\n        external\\n        returns (uint256 createdShares, uint256 redeemedUnderlying);\\n\\n    function updateDelayedRedemptionDay() external;\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/interfaces/ITrancheIndex.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\n/// @notice Amounts of Token M, A and B are sometimes stored in a `uint256[3]` array. This contract\\n///         defines index of each tranche in this array.\\n///\\n///         Solidity does not allow constants to be defined in interfaces. So this contract follows\\n///         the naming convention of interfaces but is implemented as an `abstract contract`.\\nabstract contract ITrancheIndex {\\n    uint256 internal constant TRANCHE_M = 0;\\n    uint256 internal constant TRANCHE_A = 1;\\n    uint256 internal constant TRANCHE_B = 2;\\n\\n    uint256 internal constant TRANCHE_COUNT = 3;\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/interfaces/IFund.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../interfaces/ITwapOracle.sol\\\";\\n\\ninterface IFund {\\n    /// @notice A linear transformation matrix that represents a rebalance.\\n    ///\\n    ///         ```\\n    ///             [ ratioM          0        0 ]\\n    ///         R = [ ratioA2M  ratioAB        0 ]\\n    ///             [ ratioB2M        0  ratioAB ]\\n    ///         ```\\n    ///\\n    ///         Amounts of the three tranches `m`, `a` and `b` can be rebalanced by multiplying the matrix:\\n    ///\\n    ///         ```\\n    ///         [ m', a', b' ] = [ m, a, b ] * R\\n    ///         ```\\n    struct Rebalance {\\n        uint256 ratioM;\\n        uint256 ratioA2M;\\n        uint256 ratioB2M;\\n        uint256 ratioAB;\\n        uint256 timestamp;\\n    }\\n\\n    function trancheWeights() external pure returns (uint256 weightA, uint256 weightB);\\n\\n    function tokenUnderlying() external view returns (address);\\n\\n    function tokenM() external view returns (address);\\n\\n    function tokenA() external view returns (address);\\n\\n    function tokenB() external view returns (address);\\n\\n    function underlyingDecimalMultiplier() external view returns (uint256);\\n\\n    function twapOracle() external view returns (ITwapOracle);\\n\\n    function feeCollector() external view returns (address);\\n\\n    function endOfDay(uint256 timestamp) external pure returns (uint256);\\n\\n    function shareTotalSupply(uint256 tranche) external view returns (uint256);\\n\\n    function shareBalanceOf(uint256 tranche, address account) external view returns (uint256);\\n\\n    function allShareBalanceOf(address account)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function shareBalanceVersion(address account) external view returns (uint256);\\n\\n    function shareAllowance(\\n        uint256 tranche,\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    function shareAllowanceVersion(address owner, address spender) external view returns (uint256);\\n\\n    function getRebalanceSize() external view returns (uint256);\\n\\n    function getRebalance(uint256 index) external view returns (Rebalance memory);\\n\\n    function getRebalanceTimestamp(uint256 index) external view returns (uint256);\\n\\n    function currentDay() external view returns (uint256);\\n\\n    function fundActivityStartTime() external view returns (uint256);\\n\\n    function exchangeActivityStartTime() external view returns (uint256);\\n\\n    function isFundActive(uint256 timestamp) external view returns (bool);\\n\\n    function isPrimaryMarketActive(address primaryMarket, uint256 timestamp)\\n        external\\n        view\\n        returns (bool);\\n\\n    function isExchangeActive(uint256 timestamp) external view returns (bool);\\n\\n    function getTotalShares() external view returns (uint256);\\n\\n    function historicalTotalShares(uint256 timestamp) external view returns (uint256);\\n\\n    function historicalNavs(uint256 timestamp)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function extrapolateNav(uint256 timestamp, uint256 price)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function calculateNavB(uint256 navM, uint256 navA) external pure returns (uint256);\\n\\n    function doRebalance(\\n        uint256 amountM,\\n        uint256 amountA,\\n        uint256 amountB,\\n        uint256 index\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 newAmountM,\\n            uint256 newAmountA,\\n            uint256 newAmountB\\n        );\\n\\n    function batchRebalance(\\n        uint256 amountM,\\n        uint256 amountA,\\n        uint256 amountB,\\n        uint256 fromIndex,\\n        uint256 toIndex\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 newAmountM,\\n            uint256 newAmountA,\\n            uint256 newAmountB\\n        );\\n\\n    function refreshBalance(address account, uint256 targetVersion) external;\\n\\n    function refreshAllowance(\\n        address owner,\\n        address spender,\\n        uint256 targetVersion\\n    ) external;\\n\\n    function mint(\\n        uint256 tranche,\\n        address account,\\n        uint256 amount\\n    ) external;\\n\\n    function burn(\\n        uint256 tranche,\\n        address account,\\n        uint256 amount\\n    ) external;\\n\\n    function transfer(\\n        uint256 tranche,\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external;\\n\\n    function transferFrom(\\n        uint256 tranche,\\n        address spender,\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (uint256 newAllowance);\\n\\n    function increaseAllowance(\\n        uint256 tranche,\\n        address sender,\\n        address spender,\\n        uint256 addedValue\\n    ) external returns (uint256 newAllowance);\\n\\n    function decreaseAllowance(\\n        uint256 tranche,\\n        address sender,\\n        address spender,\\n        uint256 subtractedValue\\n    ) external returns (uint256 newAllowance);\\n\\n    function approve(\\n        uint256 tranche,\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) external;\\n\\n    event RebalanceTriggered(\\n        uint256 indexed index,\\n        uint256 indexed day,\\n        uint256 ratioM,\\n        uint256 ratioA2M,\\n        uint256 ratioB2M,\\n        uint256 ratioAB\\n    );\\n    event Settled(uint256 indexed day, uint256 navM, uint256 navA, uint256 navB);\\n    event InterestRateUpdated(uint256 baseInterestRate, uint256 floatingInterestRate);\\n    event Transfer(\\n        uint256 indexed tranche,\\n        address indexed from,\\n        address indexed to,\\n        uint256 amount\\n    );\\n    event Approval(\\n        uint256 indexed tranche,\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 amount\\n    );\\n    event BalancesRebalanced(\\n        address indexed account,\\n        uint256 version,\\n        uint256 balanceM,\\n        uint256 balanceA,\\n        uint256 balanceB\\n    );\\n    event AllowancesRebalanced(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 version,\\n        uint256 allowanceM,\\n        uint256 allowanceA,\\n        uint256 allowanceB\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IChessController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\ninterface IChessController {\\n    function getFundRelativeWeight(address account, uint256 timestamp) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IChessSchedule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\ninterface IChessSchedule {\\n    function getRate(uint256 timestamp) external view returns (uint256);\\n\\n    function mint(address account, uint256 amount) external;\\n\\n    function addMinter(address account) external;\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/interfaces/IPrimaryMarket.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\ninterface IPrimaryMarket {\\n    function claim(address account)\\n        external\\n        returns (uint256 createdShares, uint256 redeemedUnderlying);\\n\\n    function settle(\\n        uint256 day,\\n        uint256 fundTotalShares,\\n        uint256 fundUnderlying,\\n        uint256 underlyingPrice,\\n        uint256 previousNav\\n    )\\n        external\\n        returns (\\n            uint256 sharesToMint,\\n            uint256 sharesToBurn,\\n            uint256 creationUnderlying,\\n            uint256 redemptionUnderlying,\\n            uint256 fee\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/misc/ProtocolDataProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\\\";\\n\\nimport \\\"../interfaces/ITrancheIndex.sol\\\";\\nimport \\\"../../interfaces/IChessSchedule.sol\\\";\\nimport \\\"../../utils/CoreUtility.sol\\\";\\n\\nimport {UnsettledTrade} from \\\"../exchange/LibUnsettledTrade.sol\\\";\\nimport {VESnapshot} from \\\"../exchange/StakingV2.sol\\\";\\nimport \\\"../exchange/ExchangeV2.sol\\\";\\nimport \\\"../fund/Fund.sol\\\";\\nimport \\\"../fund/FundV2.sol\\\";\\nimport \\\"../fund/PrimaryMarket.sol\\\";\\nimport \\\"../fund/PrimaryMarketV2.sol\\\";\\nimport \\\"../../governance/InterestRateBallot.sol\\\";\\nimport \\\"../../governance/FeeDistributor.sol\\\";\\nimport \\\"../../governance/VotingEscrowV2.sol\\\";\\nimport \\\"../governance/ChessControllerV4.sol\\\";\\nimport \\\"../../governance/ControllerBallot.sol\\\";\\n\\ninterface IExchange {\\n    function chessSchedule() external view returns (IChessSchedule);\\n\\n    function unsettledTrades(\\n        address account,\\n        uint256 tranche,\\n        uint256 epoch\\n    ) external view returns (UnsettledTrade memory);\\n}\\n\\ncontract ProtocolDataProvider is ITrancheIndex, CoreUtility {\\n    struct ProtocolData {\\n        uint256 blockNumber;\\n        uint256 blockTimestamp;\\n        WalletData wallet;\\n        FundData fund;\\n        PrimaryMarketData primaryMarket;\\n        ExchangeData exchange;\\n        GovernanceData governance;\\n        SwapPairData pair;\\n    }\\n\\n    struct WalletData {\\n        WalletBalanceData balance;\\n        WalletAllowanceData allowance;\\n    }\\n\\n    struct WalletBalanceData {\\n        uint256 nativeCurrency;\\n        uint256 underlyingToken;\\n        uint256 quoteToken;\\n        uint256 tokenM;\\n        uint256 tokenA;\\n        uint256 tokenB;\\n        uint256 chess;\\n    }\\n\\n    struct WalletAllowanceData {\\n        uint256 primaryMarketUnderlying;\\n        WalletAllowanceExchangeData exchange;\\n        uint256 votingEscrowChess;\\n    }\\n\\n    struct WalletAllowanceExchangeData {\\n        uint256 quoteToken;\\n        uint256 tokenM;\\n        uint256 tokenA;\\n        uint256 tokenB;\\n    }\\n\\n    struct FundData {\\n        bool isFundActive;\\n        bool isPrimaryMarketActive;\\n        bool isExchangeActive;\\n        uint256 fundActivityStartTime;\\n        uint256 exchangeActivityStartTime;\\n        uint256 currentDay;\\n        uint256 currentWeek;\\n        uint256 dailyProtocolFeeRate;\\n        uint256 totalShares;\\n        uint256 totalUnderlying;\\n        uint256 rebalanceSize;\\n        uint256 currentInterestRate;\\n        Fund.Rebalance lastRebalance;\\n        uint256 relativeWeight;\\n        uint256 strategyUnderlying;\\n    }\\n\\n    struct PrimaryMarketData {\\n        uint256 currentCreatingUnderlying;\\n        uint256 currentRedeemingShares;\\n        uint256 fundCap;\\n        uint256 redemptionFeeRate;\\n        uint256 splitFeeRate;\\n        uint256 mergeFeeRate;\\n        uint256 minCreationUnderlying;\\n        PrimaryMarketAccountData account;\\n    }\\n\\n    struct PrimaryMarketAccountData {\\n        uint256 creatingUnderlying;\\n        uint256 redeemingShares;\\n        uint256 createdShares;\\n        uint256 redeemedUnderlying;\\n        uint256[16] recentDelayedRedemptions;\\n    }\\n\\n    struct ExchangeData {\\n        Shares totalDeposited;\\n        uint256 weightedSupply;\\n        uint256 workingSupply;\\n        uint256 minBidAmount;\\n        uint256 minAskAmount;\\n        ExchangeAccountData account;\\n    }\\n\\n    struct ExchangeAccountData {\\n        Shares available;\\n        Shares locked;\\n        uint256 weightedBalance;\\n        uint256 workingBalance;\\n        VESnapshot veSnapshot;\\n        bool isMaker;\\n        uint256 chessRewards;\\n    }\\n\\n    struct Shares {\\n        uint256 tokenM;\\n        uint256 tokenA;\\n        uint256 tokenB;\\n    }\\n\\n    struct GovernanceData {\\n        uint256 chessTotalSupply;\\n        uint256 chessRate;\\n        uint256 nextWeekChessRate;\\n        VotingEscrowData votingEscrow;\\n        BallotData interestRateBallot;\\n        ControllerBallotData controllerBallot;\\n        FeeDistributorData feeDistributor;\\n    }\\n\\n    struct VotingEscrowData {\\n        uint256 totalLocked;\\n        uint256 totalSupply;\\n        uint256 tradingWeekTotalSupply;\\n        IVotingEscrow.LockedBalance account;\\n    }\\n\\n    struct BallotData {\\n        uint256 tradingWeekTotalSupply;\\n        IBallot.Voter account;\\n    }\\n\\n    struct ControllerBallotData {\\n        address[] pools;\\n        uint256[] currentSums;\\n        ControllerBallotAccountData account;\\n    }\\n\\n    struct ControllerBallotAccountData {\\n        uint256 amount;\\n        uint256 unlockTime;\\n        uint256[] weights;\\n    }\\n\\n    struct FeeDistributorData {\\n        FeeDistributorAccountData account;\\n        uint256 currentRewards;\\n        uint256 currentSupply;\\n        uint256 tradingWeekTotalSupply;\\n        uint256 adminFeeRate;\\n    }\\n\\n    struct FeeDistributorAccountData {\\n        uint256 claimableRewards;\\n        uint256 currentBalance;\\n        uint256 amount;\\n        uint256 unlockTime;\\n    }\\n\\n    struct SwapPairData {\\n        uint112 reserve0;\\n        uint112 reserve1;\\n        address token0;\\n        address token1;\\n    }\\n\\n    string public constant VERSION = \\\"2.0.0\\\";\\n\\n    VotingEscrowV2 public immutable votingEscrow;\\n    IChessSchedule public immutable chessSchedule;\\n    IERC20 public immutable chess;\\n    ControllerBallot public immutable controllerBallot;\\n    InterestRateBallot public immutable interestRateBallot;\\n\\n    constructor(\\n        VotingEscrowV2 votingEscrow_,\\n        IChessSchedule chessSchedule_,\\n        ControllerBallot controllerBallot_,\\n        InterestRateBallot interestRateBallot_\\n    ) public {\\n        votingEscrow = votingEscrow_;\\n        chessSchedule = chessSchedule_;\\n        chess = IERC20(votingEscrow_.token());\\n        controllerBallot = controllerBallot_;\\n        interestRateBallot = interestRateBallot_;\\n    }\\n\\n    /// @dev This function should be call as a \\\"view\\\" function off-chain to get the return value,\\n    ///      e.g. using `contract.getProtocolData.call()` in web3\\n    ///      or `contract.callStatic.getProtocolData()` in ethers.js.\\n    function getProtocolData(\\n        address primaryMarket,\\n        address exchange,\\n        address swapPair,\\n        address feeDistributor,\\n        address account,\\n        uint256 fundVersion\\n    ) external returns (ProtocolData memory data) {\\n        data.blockNumber = block.number;\\n        data.blockTimestamp = block.timestamp;\\n\\n        data.wallet = getWalletData(primaryMarket, exchange, account);\\n\\n        data.fund = getFundData(primaryMarket, exchange, fundVersion);\\n\\n        data.primaryMarket = getPrimaryMarketData(primaryMarket, account, fundVersion);\\n\\n        data.exchange = getExchangeData(exchange, account);\\n\\n        data.governance = getGovernanceData(exchange, feeDistributor, account);\\n\\n        data.pair = getSwapPairData(swapPair);\\n    }\\n\\n    function getWalletData(\\n        address primaryMarket,\\n        address exchange,\\n        address account\\n    ) public view returns (WalletData memory data) {\\n        Fund fund = Fund(address(ExchangeV2(exchange).fund()));\\n        IERC20 underlyingToken = IERC20(fund.tokenUnderlying());\\n        IERC20 quoteToken = IERC20(ExchangeV2(exchange).quoteAssetAddress());\\n\\n        data.balance.nativeCurrency = account.balance;\\n        data.balance.underlyingToken = underlyingToken.balanceOf(account);\\n        data.balance.quoteToken = quoteToken.balanceOf(account);\\n        (data.balance.tokenM, data.balance.tokenA, data.balance.tokenB) = fund.allShareBalanceOf(\\n            account\\n        );\\n        data.balance.chess = chess.balanceOf(account);\\n\\n        data.allowance.primaryMarketUnderlying = underlyingToken.allowance(account, primaryMarket);\\n        data.allowance.exchange.quoteToken = quoteToken.allowance(account, exchange);\\n        data.allowance.exchange.tokenM = fund.shareAllowance(TRANCHE_M, account, exchange);\\n        data.allowance.exchange.tokenA = fund.shareAllowance(TRANCHE_A, account, exchange);\\n        data.allowance.exchange.tokenB = fund.shareAllowance(TRANCHE_B, account, exchange);\\n        data.allowance.votingEscrowChess = chess.allowance(account, address(votingEscrow));\\n    }\\n\\n    function getFundData(\\n        address primaryMarket,\\n        address exchange,\\n        uint256 fundVersion\\n    ) public returns (FundData memory data) {\\n        Fund fund = Fund(address(ExchangeV2(exchange).fund()));\\n        data.isFundActive = fund.isFundActive(block.timestamp);\\n        data.isPrimaryMarketActive = fund.isPrimaryMarketActive(primaryMarket, block.timestamp);\\n        data.isExchangeActive = fund.isExchangeActive(block.timestamp);\\n        data.fundActivityStartTime = fund.fundActivityStartTime();\\n        data.exchangeActivityStartTime = fund.exchangeActivityStartTime();\\n        data.currentDay = fund.currentDay();\\n        data.currentWeek = _endOfWeek(data.currentDay - 1 days);\\n        data.dailyProtocolFeeRate = fund.dailyProtocolFeeRate();\\n        data.totalShares = fund.getTotalShares();\\n        data.rebalanceSize = fund.getRebalanceSize();\\n        data.currentInterestRate = fund.historicalInterestRate(data.currentWeek);\\n        uint256 rebalanceSize = fund.getRebalanceSize();\\n        data.lastRebalance = fund.getRebalance(rebalanceSize == 0 ? 0 : rebalanceSize - 1);\\n        ExchangeV2(exchange).refreshBalance(address(0), 0); // Trigger checkpoint\\n        data.relativeWeight = ExchangeV2(exchange).chessController().getFundRelativeWeight(\\n            address(fund),\\n            block.timestamp\\n        );\\n        if (fundVersion < 2) {\\n            IERC20 underlyingToken = IERC20(fund.tokenUnderlying());\\n            data.totalUnderlying = underlyingToken.balanceOf(address(fund));\\n        } else {\\n            data.totalUnderlying = FundV2(address(fund)).getTotalUnderlying();\\n            data.strategyUnderlying = FundV2(address(fund)).getStrategyUnderlying();\\n        }\\n    }\\n\\n    function getPrimaryMarketData(\\n        address primaryMarket,\\n        address account,\\n        uint256 fundVersion\\n    ) public returns (PrimaryMarketData memory data) {\\n        PrimaryMarketV2 primaryMarket_ = PrimaryMarketV2(payable(primaryMarket));\\n        data.currentCreatingUnderlying = primaryMarket_.currentCreatingUnderlying();\\n        data.currentRedeemingShares = primaryMarket_.currentRedeemingShares();\\n        data.redemptionFeeRate = primaryMarket_.redemptionFeeRate();\\n        data.splitFeeRate = primaryMarket_.splitFeeRate();\\n        data.mergeFeeRate = primaryMarket_.mergeFeeRate();\\n        data.minCreationUnderlying = primaryMarket_.minCreationUnderlying();\\n        PrimaryMarketV2.CreationRedemption memory cr = primaryMarket_.creationRedemptionOf(account);\\n        data.account.creatingUnderlying = cr.creatingUnderlying;\\n        data.account.redeemingShares = cr.redeemingShares;\\n        data.account.createdShares = cr.createdShares;\\n        data.account.redeemedUnderlying = cr.redeemedUnderlying;\\n        if (fundVersion >= 2) {\\n            data.fundCap = primaryMarket_.fundCap();\\n            uint256 currentDay = primaryMarket_.currentDay();\\n            for (uint256 i = 0; i < 16; i++) {\\n                (data.account.recentDelayedRedemptions[i], ) = primaryMarket_.getDelayedRedemption(\\n                    account,\\n                    currentDay - (i + 1) * 1 days\\n                );\\n            }\\n        }\\n    }\\n\\n    function getExchangeData(address exchange, address account)\\n        public\\n        returns (ExchangeData memory data)\\n    {\\n        ExchangeV2 exchangeContract = ExchangeV2(exchange);\\n        data.totalDeposited.tokenM = exchangeContract.totalSupply(TRANCHE_M);\\n        data.totalDeposited.tokenA = exchangeContract.totalSupply(TRANCHE_A);\\n        data.totalDeposited.tokenB = exchangeContract.totalSupply(TRANCHE_B);\\n        data.weightedSupply = exchangeContract.weightedBalance(\\n            data.totalDeposited.tokenM,\\n            data.totalDeposited.tokenA,\\n            data.totalDeposited.tokenB\\n        );\\n        data.workingSupply = exchangeContract.workingSupply();\\n        data.minBidAmount = exchangeContract.minBidAmount();\\n        data.minAskAmount = exchangeContract.minAskAmount();\\n        data.account.available.tokenM = exchangeContract.availableBalanceOf(TRANCHE_M, account);\\n        data.account.available.tokenA = exchangeContract.availableBalanceOf(TRANCHE_A, account);\\n        data.account.available.tokenB = exchangeContract.availableBalanceOf(TRANCHE_B, account);\\n        data.account.locked.tokenM = exchangeContract.lockedBalanceOf(TRANCHE_M, account);\\n        data.account.locked.tokenA = exchangeContract.lockedBalanceOf(TRANCHE_A, account);\\n        data.account.locked.tokenB = exchangeContract.lockedBalanceOf(TRANCHE_B, account);\\n        data.account.weightedBalance = exchangeContract.weightedBalance(\\n            data.account.available.tokenM + data.account.locked.tokenM,\\n            data.account.available.tokenA + data.account.locked.tokenA,\\n            data.account.available.tokenB + data.account.locked.tokenB\\n        );\\n        data.account.workingBalance = exchangeContract.workingBalanceOf(account);\\n        data.account.veSnapshot = exchangeContract.veSnapshotOf(account);\\n        data.account.isMaker = exchangeContract.isMaker(account);\\n        data.account.chessRewards = exchangeContract.claimableRewards(account);\\n    }\\n\\n    function getGovernanceData(\\n        address exchange,\\n        address feeDistributor,\\n        address account\\n    ) public returns (GovernanceData memory data) {\\n        uint256 blockCurrentWeek = _endOfWeek(block.timestamp);\\n        data.chessTotalSupply = chess.totalSupply();\\n        data.chessRate = chessSchedule.getRate(block.timestamp);\\n        data.nextWeekChessRate = chessSchedule.getRate(block.timestamp + 7 days);\\n        data.votingEscrow.totalLocked = votingEscrow.totalLocked();\\n        data.votingEscrow.totalSupply = votingEscrow.totalSupply();\\n        data.votingEscrow.tradingWeekTotalSupply = votingEscrow.totalSupplyAtTimestamp(\\n            blockCurrentWeek\\n        );\\n        data.votingEscrow.account = votingEscrow.getLockedBalance(account);\\n        data.interestRateBallot.tradingWeekTotalSupply = interestRateBallot.totalSupplyAtTimestamp(\\n            blockCurrentWeek\\n        );\\n        data.interestRateBallot.account = interestRateBallot.getReceipt(account);\\n\\n        data.controllerBallot = getControllerBallotData(exchange, account);\\n\\n        if (feeDistributor != address(0)) {\\n            FeeDistributor feeDistributor_ = FeeDistributor(payable(feeDistributor));\\n            data.feeDistributor.account.claimableRewards = feeDistributor_.userCheckpoint(account);\\n            data.feeDistributor.account.currentBalance = feeDistributor_.userLastBalances(account);\\n            (\\n                data.feeDistributor.account.amount,\\n                data.feeDistributor.account.unlockTime\\n            ) = feeDistributor_.userLockedBalances(account);\\n            data.feeDistributor.currentRewards = feeDistributor_.rewardsPerWeek(\\n                blockCurrentWeek - 1 weeks\\n            );\\n            data.feeDistributor.currentSupply = feeDistributor_.veSupplyPerWeek(\\n                blockCurrentWeek - 1 weeks\\n            );\\n            data.feeDistributor.tradingWeekTotalSupply = feeDistributor_.totalSupplyAtTimestamp(\\n                blockCurrentWeek\\n            );\\n            data.feeDistributor.adminFeeRate = feeDistributor_.adminFeeRate();\\n        }\\n    }\\n\\n    function getControllerBallotData(address, address account)\\n        public\\n        view\\n        returns (ControllerBallotData memory data)\\n    {\\n        data.pools = controllerBallot.getPools();\\n        data.currentSums = new uint256[](data.pools.length);\\n        (data.account.amount, data.account.unlockTime) = controllerBallot.userLockedBalances(\\n            account\\n        );\\n        data.account.weights = new uint256[](data.pools.length);\\n        for (uint256 i = 0; i < data.pools.length; i++) {\\n            address pool = data.pools[i];\\n            data.currentSums[i] = controllerBallot.sumAtTimestamp(pool, block.timestamp);\\n            data.account.weights[i] = controllerBallot.userWeights(account, pool);\\n        }\\n    }\\n\\n    function getSwapPairData(address swapPair) public view returns (SwapPairData memory data) {\\n        IUniswapV2Pair pair = IUniswapV2Pair(swapPair);\\n        data.token0 = pair.token0();\\n        data.token1 = pair.token1();\\n        (data.reserve0, data.reserve1, ) = pair.getReserves();\\n    }\\n\\n    function getUnsettledTrades(\\n        address exchangeAddress,\\n        address account,\\n        uint256[] memory epochs\\n    )\\n        external\\n        view\\n        returns (\\n            UnsettledTrade[] memory unsettledTradeM,\\n            UnsettledTrade[] memory unsettledTradeA,\\n            UnsettledTrade[] memory unsettledTradeB\\n        )\\n    {\\n        IExchange exchange = IExchange(exchangeAddress);\\n        unsettledTradeM = new UnsettledTrade[](epochs.length);\\n        unsettledTradeA = new UnsettledTrade[](epochs.length);\\n        unsettledTradeB = new UnsettledTrade[](epochs.length);\\n        for (uint256 i = 0; i < epochs.length; i++) {\\n            unsettledTradeM[i] = exchange.unsettledTrades(account, TRANCHE_M, epochs[i]);\\n            unsettledTradeA[i] = exchange.unsettledTrades(account, TRANCHE_A, epochs[i]);\\n            unsettledTradeB[i] = exchange.unsettledTrades(account, TRANCHE_B, epochs[i]);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/exchange/LibUnsettledTrade.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\n/// @notice Unsettled trade of a taker buy order or a maker sell order\\n/// @param frozenQuote Amount of quote assets from the taker\\n/// @param effectiveQuote Effective amount of quote assets at zero premium-discount\\n/// @param reservedBase Reserved amount of base assets from the maker\\nstruct UnsettledBuyTrade {\\n    uint256 frozenQuote;\\n    uint256 effectiveQuote;\\n    uint256 reservedBase;\\n}\\n\\n/// @notice Unsettled trade of a taker sell order or a maker buy order\\n/// @param frozenBase Amount of base assets from the taker\\n/// @param effectiveBase Effective amount of base assets at zero premium-discount\\n/// @param reservedQuote Reserved amount of quote assets from the maker\\nstruct UnsettledSellTrade {\\n    uint256 frozenBase;\\n    uint256 effectiveBase;\\n    uint256 reservedQuote;\\n}\\n\\n/// @notice Unsettled trades of an account in a single epoch\\n/// @param takerBuy Trade by taker buy orders\\n/// @param takerSell Trade by taker sell orders\\n/// @param makerBuy Trade by maker buy orders\\n/// @param makerSell Trade by maker sell orders\\nstruct UnsettledTrade {\\n    UnsettledBuyTrade takerBuy;\\n    UnsettledSellTrade takerSell;\\n    UnsettledSellTrade makerBuy;\\n    UnsettledBuyTrade makerSell;\\n}\\n\\nlibrary LibUnsettledBuyTrade {\\n    using SafeMath for uint256;\\n\\n    /// @dev Accumulate buy trades\\n    /// @param self Trade to update\\n    /// @param other New trade to be added to storage\\n    function add(UnsettledBuyTrade storage self, UnsettledBuyTrade memory other) internal {\\n        self.frozenQuote = self.frozenQuote.add(other.frozenQuote);\\n        self.effectiveQuote = self.effectiveQuote.add(other.effectiveQuote);\\n        self.reservedBase = self.reservedBase.add(other.reservedBase);\\n    }\\n}\\n\\nlibrary LibUnsettledSellTrade {\\n    using SafeMath for uint256;\\n\\n    /// @dev Accumulate sell trades\\n    /// @param self Trade to update\\n    /// @param other New trade to be added to storage\\n    function add(UnsettledSellTrade storage self, UnsettledSellTrade memory other) internal {\\n        self.frozenBase = self.frozenBase.add(other.frozenBase);\\n        self.effectiveBase = self.effectiveBase.add(other.effectiveBase);\\n        self.reservedQuote = self.reservedQuote.add(other.reservedQuote);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/exchange/StakingV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\nimport \\\"../../utils/SafeDecimalMath.sol\\\";\\nimport \\\"../../utils/CoreUtility.sol\\\";\\nimport \\\"../../utils/ManagedPausable.sol\\\";\\n\\nimport \\\"../interfaces/IFund.sol\\\";\\nimport \\\"../../interfaces/IChessController.sol\\\";\\nimport \\\"../../interfaces/IChessSchedule.sol\\\";\\nimport \\\"../interfaces/ITrancheIndex.sol\\\";\\nimport \\\"../interfaces/IPrimaryMarketV2.sol\\\";\\nimport \\\"../../interfaces/IVotingEscrow.sol\\\";\\n\\n/// @notice Chess locking snapshot used in calculating working balance of an account.\\n/// @param veProportion The account's veCHESS divided by the total veCHESS supply.\\n/// @param veLocked Locked CHESS and unlock time, which is synchronized from VotingEscrow.\\nstruct VESnapshot {\\n    uint256 veProportion;\\n    IVotingEscrow.LockedBalance veLocked;\\n}\\n\\nabstract contract StakingV2 is ITrancheIndex, CoreUtility, ManagedPausable {\\n    /// @dev Reserved storage slots for future sibling contract upgrades\\n    uint256[29] private _reservedSlots;\\n\\n    using Math for uint256;\\n    using SafeMath for uint256;\\n    using SafeDecimalMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    event Deposited(uint256 tranche, address account, uint256 amount);\\n    event Withdrawn(uint256 tranche, address account, uint256 amount);\\n\\n    uint256 private constant MAX_ITERATIONS = 500;\\n\\n    uint256 private constant REWARD_WEIGHT_A = 4;\\n    uint256 private constant REWARD_WEIGHT_B = 2;\\n    uint256 private constant REWARD_WEIGHT_M = 3;\\n    uint256 private constant MAX_BOOSTING_FACTOR = 3e18;\\n    uint256 private constant MAX_BOOSTING_FACTOR_MINUS_ONE = MAX_BOOSTING_FACTOR - 1e18;\\n\\n    /// @dev Maximum fraction of veCHESS that can be used to boost Token M.\\n    uint256 private constant MAX_BOOSTING_POWER_M = 0.5e18;\\n\\n    IFund public immutable fund;\\n    IERC20 private immutable tokenM;\\n    IERC20 private immutable tokenA;\\n    IERC20 private immutable tokenB;\\n\\n    /// @notice The Chess release schedule contract.\\n    IChessSchedule public immutable chessSchedule;\\n\\n    uint256 public immutable guardedLaunchStart;\\n\\n    uint256 private _rate;\\n\\n    /// @notice The controller contract.\\n    IChessController public immutable chessController;\\n\\n    /// @notice Quote asset for the exchange. Each exchange only handles one quote asset\\n    address public immutable quoteAssetAddress;\\n\\n    /// @dev Total amount of user shares, i.e. sum of all entries in `_availableBalances` and\\n    ///      `_lockedBalances`. Note that these values can be smaller than the amount of\\n    ///      share tokens held by this contract, because shares locked in unsettled trades\\n    ///      are not included in total supplies or any user's balance.\\n    uint256[TRANCHE_COUNT] private _totalSupplies;\\n\\n    /// @dev Rebalance version of `_totalSupplies`.\\n    uint256 private _totalSupplyVersion;\\n\\n    /// @dev Amount of shares that can be withdrawn or traded by each user.\\n    mapping(address => uint256[TRANCHE_COUNT]) private _availableBalances;\\n\\n    /// @dev Amount of shares that are locked in ask orders.\\n    mapping(address => uint256[TRANCHE_COUNT]) private _lockedBalances;\\n\\n    /// @dev Rebalance version mapping for `_availableBalances`.\\n    mapping(address => uint256) private _balanceVersions;\\n\\n    /// @dev 1e27 * \u222b(rate(t) / totalWeight(t) dt) from the latest rebalance till checkpoint.\\n    uint256 private _invTotalWeightIntegral;\\n\\n    /// @dev Final `_invTotalWeightIntegral` before each rebalance.\\n    ///      These values are accessed in a loop in `_userCheckpoint()` with bounds checking.\\n    ///      So we store them in a fixed-length array, in order to make compiler-generated\\n    ///      bounds checking on every access cheaper. The actual length of this array is stored in\\n    ///      `_historicalIntegralSize` and should be explicitly checked when necessary.\\n    uint256[65535] private _historicalIntegrals;\\n\\n    /// @dev Actual length of the `_historicalIntegrals` array, which always equals to the number of\\n    ///      historical rebalances after `checkpoint()` is called.\\n    uint256 private _historicalIntegralSize;\\n\\n    /// @dev Timestamp when checkpoint() is called.\\n    uint256 private _checkpointTimestamp;\\n\\n    /// @dev Snapshot of `_invTotalWeightIntegral` per user.\\n    mapping(address => uint256) private _userIntegrals;\\n\\n    /// @dev Mapping of account => claimable rewards.\\n    mapping(address => uint256) private _claimableRewards;\\n\\n    IVotingEscrow private immutable _votingEscrow;\\n    uint256 private _workingSupply;\\n    mapping(address => uint256) private _workingBalances;\\n    mapping(address => VESnapshot) private _veSnapshots;\\n\\n    constructor(\\n        address fund_,\\n        address chessSchedule_,\\n        address chessController_,\\n        address quoteAssetAddress_,\\n        uint256 guardedLaunchStart_,\\n        address votingEscrow_\\n    ) public {\\n        fund = IFund(fund_);\\n        tokenM = IERC20(IFund(fund_).tokenM());\\n        tokenA = IERC20(IFund(fund_).tokenA());\\n        tokenB = IERC20(IFund(fund_).tokenB());\\n        chessSchedule = IChessSchedule(chessSchedule_);\\n        chessController = IChessController(chessController_);\\n        quoteAssetAddress = quoteAssetAddress_;\\n        guardedLaunchStart = guardedLaunchStart_;\\n        _votingEscrow = IVotingEscrow(votingEscrow_);\\n    }\\n\\n    function _initializeStaking() internal {\\n        require(_checkpointTimestamp == 0);\\n        _checkpointTimestamp = block.timestamp;\\n        _rate = IChessSchedule(chessSchedule).getRate(block.timestamp);\\n    }\\n\\n    function _initializeStakingV2(address pauser_) internal {\\n        _initializeManagedPausable(pauser_);\\n        // The contract was just upgraded from an old version without boosting\\n        _workingSupply = weightedBalance(\\n            _totalSupplies[TRANCHE_M],\\n            _totalSupplies[TRANCHE_A],\\n            _totalSupplies[TRANCHE_B]\\n        );\\n    }\\n\\n    /// @notice Return weight of given balance with respect to rewards.\\n    /// @param amountM Amount of Token M\\n    /// @param amountA Amount of Token A\\n    /// @param amountB Amount of Token B\\n    /// @return Rewarding weight of the balance\\n    function weightedBalance(\\n        uint256 amountM,\\n        uint256 amountA,\\n        uint256 amountB\\n    ) public pure returns (uint256) {\\n        return\\n            amountM.mul(REWARD_WEIGHT_M).add(amountA.mul(REWARD_WEIGHT_A)).add(\\n                amountB.mul(REWARD_WEIGHT_B)\\n            ) / REWARD_WEIGHT_M;\\n    }\\n\\n    function totalSupply(uint256 tranche) external view returns (uint256) {\\n        uint256 totalSupplyM = _totalSupplies[TRANCHE_M];\\n        uint256 totalSupplyA = _totalSupplies[TRANCHE_A];\\n        uint256 totalSupplyB = _totalSupplies[TRANCHE_B];\\n\\n        uint256 version = _totalSupplyVersion;\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        if (version < rebalanceSize) {\\n            (totalSupplyM, totalSupplyA, totalSupplyB) = _fundBatchRebalance(\\n                totalSupplyM,\\n                totalSupplyA,\\n                totalSupplyB,\\n                version,\\n                rebalanceSize\\n            );\\n        }\\n\\n        if (tranche == TRANCHE_M) {\\n            return totalSupplyM;\\n        } else if (tranche == TRANCHE_A) {\\n            return totalSupplyA;\\n        } else {\\n            return totalSupplyB;\\n        }\\n    }\\n\\n    function availableBalanceOf(uint256 tranche, address account) external view returns (uint256) {\\n        uint256 amountM = _availableBalances[account][TRANCHE_M];\\n        uint256 amountA = _availableBalances[account][TRANCHE_A];\\n        uint256 amountB = _availableBalances[account][TRANCHE_B];\\n\\n        if (tranche == TRANCHE_M) {\\n            if (amountM == 0 && amountA == 0 && amountB == 0) return 0;\\n        } else if (tranche == TRANCHE_A) {\\n            if (amountA == 0) return 0;\\n        } else {\\n            if (amountB == 0) return 0;\\n        }\\n\\n        uint256 version = _balanceVersions[account];\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        if (version < rebalanceSize) {\\n            (amountM, amountA, amountB) = _fundBatchRebalance(\\n                amountM,\\n                amountA,\\n                amountB,\\n                version,\\n                rebalanceSize\\n            );\\n        }\\n\\n        if (tranche == TRANCHE_M) {\\n            return amountM;\\n        } else if (tranche == TRANCHE_A) {\\n            return amountA;\\n        } else {\\n            return amountB;\\n        }\\n    }\\n\\n    function lockedBalanceOf(uint256 tranche, address account) external view returns (uint256) {\\n        uint256 amountM = _lockedBalances[account][TRANCHE_M];\\n        uint256 amountA = _lockedBalances[account][TRANCHE_A];\\n        uint256 amountB = _lockedBalances[account][TRANCHE_B];\\n\\n        if (tranche == TRANCHE_M) {\\n            if (amountM == 0 && amountA == 0 && amountB == 0) return 0;\\n        } else if (tranche == TRANCHE_A) {\\n            if (amountA == 0) return 0;\\n        } else {\\n            if (amountB == 0) return 0;\\n        }\\n\\n        uint256 version = _balanceVersions[account];\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        if (version < rebalanceSize) {\\n            (amountM, amountA, amountB) = _fundBatchRebalance(\\n                amountM,\\n                amountA,\\n                amountB,\\n                version,\\n                rebalanceSize\\n            );\\n        }\\n\\n        if (tranche == TRANCHE_M) {\\n            return amountM;\\n        } else if (tranche == TRANCHE_A) {\\n            return amountA;\\n        } else {\\n            return amountB;\\n        }\\n    }\\n\\n    function balanceVersion(address account) external view returns (uint256) {\\n        return _balanceVersions[account];\\n    }\\n\\n    function workingSupply() external view returns (uint256) {\\n        uint256 version = _totalSupplyVersion;\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        if (version < rebalanceSize) {\\n            (uint256 totalSupplyM, uint256 totalSupplyA, uint256 totalSupplyB) =\\n                _fundBatchRebalance(\\n                    _totalSupplies[TRANCHE_M],\\n                    _totalSupplies[TRANCHE_A],\\n                    _totalSupplies[TRANCHE_B],\\n                    version,\\n                    rebalanceSize\\n                );\\n            return weightedBalance(totalSupplyM, totalSupplyA, totalSupplyB);\\n        } else {\\n            return _workingSupply;\\n        }\\n    }\\n\\n    function workingBalanceOf(address account) external view returns (uint256) {\\n        uint256 version = _balanceVersions[account];\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        uint256 workingBalance = _workingBalances[account]; // gas saver\\n        if (version < rebalanceSize || workingBalance == 0) {\\n            uint256[TRANCHE_COUNT] storage available = _availableBalances[account];\\n            uint256[TRANCHE_COUNT] storage locked = _lockedBalances[account];\\n            uint256 amountM = available[TRANCHE_M].add(locked[TRANCHE_M]);\\n            uint256 amountA = available[TRANCHE_A].add(locked[TRANCHE_A]);\\n            uint256 amountB = available[TRANCHE_B].add(locked[TRANCHE_B]);\\n            if (version < rebalanceSize) {\\n                (amountM, amountA, amountB) = _fundBatchRebalance(\\n                    amountM,\\n                    amountA,\\n                    amountB,\\n                    version,\\n                    rebalanceSize\\n                );\\n            }\\n            return weightedBalance(amountM, amountA, amountB);\\n        } else {\\n            return workingBalance;\\n        }\\n    }\\n\\n    function veSnapshotOf(address account) external view returns (VESnapshot memory) {\\n        return _veSnapshots[account];\\n    }\\n\\n    function _fundRebalanceSize() internal view returns (uint256) {\\n        return fund.getRebalanceSize();\\n    }\\n\\n    function _fundDoRebalance(\\n        uint256 amountM,\\n        uint256 amountA,\\n        uint256 amountB,\\n        uint256 index\\n    )\\n        internal\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        return fund.doRebalance(amountM, amountA, amountB, index);\\n    }\\n\\n    function _fundBatchRebalance(\\n        uint256 amountM,\\n        uint256 amountA,\\n        uint256 amountB,\\n        uint256 fromIndex,\\n        uint256 toIndex\\n    )\\n        internal\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        return fund.batchRebalance(amountM, amountA, amountB, fromIndex, toIndex);\\n    }\\n\\n    /// @dev Deposit to get rewards\\n    /// @param tranche Tranche of the share\\n    /// @param amount The amount to deposit\\n    function deposit(uint256 tranche, uint256 amount) public whenNotPaused {\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(msg.sender, rebalanceSize);\\n        _availableBalances[msg.sender][tranche] = _availableBalances[msg.sender][tranche].add(\\n            amount\\n        );\\n        _totalSupplies[tranche] = _totalSupplies[tranche].add(amount);\\n        _updateWorkingBalance(msg.sender);\\n\\n        if (tranche == TRANCHE_M) {\\n            tokenM.safeTransferFrom(msg.sender, address(this), amount);\\n        } else if (tranche == TRANCHE_A) {\\n            tokenA.safeTransferFrom(msg.sender, address(this), amount);\\n        } else {\\n            tokenB.safeTransferFrom(msg.sender, address(this), amount);\\n        }\\n\\n        emit Deposited(tranche, msg.sender, amount);\\n    }\\n\\n    /// @dev Claim settled Token M from the primary market and deposit to get rewards\\n    /// @param primaryMarket The primary market to claim shares from\\n    function claimAndDeposit(address primaryMarket) external {\\n        (uint256 createdShares, ) = IPrimaryMarketV2(primaryMarket).claim(msg.sender);\\n        deposit(TRANCHE_M, createdShares);\\n    }\\n\\n    function claimAndUnwrapAndDeposit(address primaryMarket) external {\\n        (uint256 createdShares, ) = IPrimaryMarketV2(primaryMarket).claimAndUnwrap(msg.sender);\\n        deposit(TRANCHE_M, createdShares);\\n    }\\n\\n    /// @dev Withdraw\\n    /// @param tranche Tranche of the share\\n    /// @param amount The amount to deposit\\n    function withdraw(uint256 tranche, uint256 amount) external whenNotPaused {\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(msg.sender, rebalanceSize);\\n        _availableBalances[msg.sender][tranche] = _availableBalances[msg.sender][tranche].sub(\\n            amount,\\n            \\\"Insufficient balance to withdraw\\\"\\n        );\\n        _totalSupplies[tranche] = _totalSupplies[tranche].sub(amount);\\n        _updateWorkingBalance(msg.sender);\\n\\n        if (tranche == TRANCHE_M) {\\n            tokenM.safeTransfer(msg.sender, amount);\\n        } else if (tranche == TRANCHE_A) {\\n            tokenA.safeTransfer(msg.sender, amount);\\n        } else {\\n            tokenB.safeTransfer(msg.sender, amount);\\n        }\\n\\n        emit Withdrawn(tranche, msg.sender, amount);\\n    }\\n\\n    /// @notice Transform share balance to a given rebalance version, or to the latest version\\n    ///         if `targetVersion` is zero.\\n    /// @param account Account of the balance to rebalance\\n    /// @param targetVersion The target rebalance version, or zero for the latest version\\n    function refreshBalance(address account, uint256 targetVersion) external {\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        if (targetVersion == 0) {\\n            targetVersion = rebalanceSize;\\n        } else {\\n            require(targetVersion <= rebalanceSize, \\\"Target version out of bound\\\");\\n        }\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(account, targetVersion);\\n    }\\n\\n    /// @notice Return claimable rewards of an account till now.\\n    ///\\n    ///         This function should be call as a \\\"view\\\" function off-chain to get\\n    ///         the return value, e.g. using `contract.claimableRewards.call(account)` in web3\\n    ///         or `contract.callStatic.claimableRewards(account)` in ethers.js.\\n    /// @param account Address of an account\\n    /// @return Amount of claimable rewards\\n    function claimableRewards(address account) external returns (uint256) {\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(account, rebalanceSize);\\n        return _claimableRewards[account];\\n    }\\n\\n    /// @notice Claim the rewards for an account.\\n    /// @param account Account to claim its rewards\\n    function claimRewards(address account) external whenNotPaused {\\n        require(\\n            block.timestamp >= guardedLaunchStart + 15 days,\\n            \\\"Cannot claim during guarded launch\\\"\\n        );\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(account, rebalanceSize);\\n        _claim(account);\\n    }\\n\\n    /// @notice Synchronize an account's locked Chess with `VotingEscrow`\\n    ///         and update its working balance.\\n    /// @param account Address of the synchronized account\\n    function syncWithVotingEscrow(address account) external {\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(account, rebalanceSize);\\n\\n        VESnapshot storage veSnapshot = _veSnapshots[account];\\n        IVotingEscrow.LockedBalance memory newLocked = _votingEscrow.getLockedBalance(account);\\n        if (\\n            newLocked.amount != veSnapshot.veLocked.amount ||\\n            newLocked.unlockTime != veSnapshot.veLocked.unlockTime ||\\n            newLocked.unlockTime < block.timestamp\\n        ) {\\n            veSnapshot.veLocked.amount = newLocked.amount;\\n            veSnapshot.veLocked.unlockTime = newLocked.unlockTime;\\n            veSnapshot.veProportion = _votingEscrow.balanceOf(account).divideDecimal(\\n                _votingEscrow.totalSupply()\\n            );\\n        }\\n\\n        _updateWorkingBalance(account);\\n    }\\n\\n    /// @dev Transfer shares from the sender to the contract internally\\n    /// @param tranche Tranche of the share\\n    /// @param sender Sender address\\n    /// @param amount The amount to transfer\\n    function _tradeAvailable(\\n        uint256 tranche,\\n        address sender,\\n        uint256 amount\\n    ) internal {\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(sender, rebalanceSize);\\n        _availableBalances[sender][tranche] = _availableBalances[sender][tranche].sub(amount);\\n        _totalSupplies[tranche] = _totalSupplies[tranche].sub(amount);\\n        _updateWorkingBalance(sender);\\n    }\\n\\n    function _rebalanceAndClearTrade(\\n        address account,\\n        uint256 amountM,\\n        uint256 amountA,\\n        uint256 amountB,\\n        uint256 amountVersion\\n    )\\n        internal\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(account, rebalanceSize);\\n        if (amountVersion < rebalanceSize) {\\n            (amountM, amountA, amountB) = _fundBatchRebalance(\\n                amountM,\\n                amountA,\\n                amountB,\\n                amountVersion,\\n                rebalanceSize\\n            );\\n        }\\n        uint256[TRANCHE_COUNT] storage available = _availableBalances[account];\\n        if (amountM > 0) {\\n            available[TRANCHE_M] = available[TRANCHE_M].add(amountM);\\n            _totalSupplies[TRANCHE_M] = _totalSupplies[TRANCHE_M].add(amountM);\\n        }\\n        if (amountA > 0) {\\n            available[TRANCHE_A] = available[TRANCHE_A].add(amountA);\\n            _totalSupplies[TRANCHE_A] = _totalSupplies[TRANCHE_A].add(amountA);\\n        }\\n        if (amountB > 0) {\\n            available[TRANCHE_B] = available[TRANCHE_B].add(amountB);\\n            _totalSupplies[TRANCHE_B] = _totalSupplies[TRANCHE_B].add(amountB);\\n        }\\n        _updateWorkingBalance(account);\\n\\n        return (amountM, amountA, amountB);\\n    }\\n\\n    function _lock(\\n        uint256 tranche,\\n        address account,\\n        uint256 amount\\n    ) internal {\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(account, rebalanceSize);\\n        _availableBalances[account][tranche] = _availableBalances[account][tranche].sub(\\n            amount,\\n            \\\"Insufficient balance to lock\\\"\\n        );\\n        _lockedBalances[account][tranche] = _lockedBalances[account][tranche].add(amount);\\n    }\\n\\n    function _rebalanceAndUnlock(\\n        address account,\\n        uint256 amountM,\\n        uint256 amountA,\\n        uint256 amountB,\\n        uint256 amountVersion\\n    ) internal {\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(account, rebalanceSize);\\n        if (amountVersion < rebalanceSize) {\\n            (amountM, amountA, amountB) = _fundBatchRebalance(\\n                amountM,\\n                amountA,\\n                amountB,\\n                amountVersion,\\n                rebalanceSize\\n            );\\n        }\\n        uint256[TRANCHE_COUNT] storage available = _availableBalances[account];\\n        uint256[TRANCHE_COUNT] storage locked = _lockedBalances[account];\\n        if (amountM > 0) {\\n            available[TRANCHE_M] = available[TRANCHE_M].add(amountM);\\n            locked[TRANCHE_M] = locked[TRANCHE_M].sub(amountM);\\n        }\\n        if (amountA > 0) {\\n            available[TRANCHE_A] = available[TRANCHE_A].add(amountA);\\n            locked[TRANCHE_A] = locked[TRANCHE_A].sub(amountA);\\n        }\\n        if (amountB > 0) {\\n            available[TRANCHE_B] = available[TRANCHE_B].add(amountB);\\n            locked[TRANCHE_B] = locked[TRANCHE_B].sub(amountB);\\n        }\\n    }\\n\\n    function _tradeLocked(\\n        uint256 tranche,\\n        address account,\\n        uint256 amount\\n    ) internal {\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(account, rebalanceSize);\\n        _lockedBalances[account][tranche] = _lockedBalances[account][tranche].sub(amount);\\n        _totalSupplies[tranche] = _totalSupplies[tranche].sub(amount);\\n        _updateWorkingBalance(account);\\n    }\\n\\n    /// @dev Transfer claimable rewards to an account. Rewards since the last user checkpoint\\n    ///      is not included. This function should always be called after `_userCheckpoint()`,\\n    ///      in order for the user to get all rewards till now.\\n    /// @param account Address of the account\\n    function _claim(address account) internal {\\n        uint256 claimableReward = _claimableRewards[account];\\n        _claimableRewards[account] = 0;\\n        chessSchedule.mint(account, claimableReward);\\n    }\\n\\n    /// @dev Transform total supplies to the latest rebalance version and make a global reward checkpoint.\\n    /// @param rebalanceSize The number of existing rebalances. It must be the same as\\n    ///                       `fund.getRebalanceSize()`.\\n    function _checkpoint(uint256 rebalanceSize) private {\\n        uint256 timestamp = _checkpointTimestamp;\\n        if (timestamp >= block.timestamp) {\\n            return;\\n        }\\n\\n        uint256 integral = _invTotalWeightIntegral;\\n        uint256 endWeek = _endOfWeek(timestamp);\\n        uint256 weeklyPercentage =\\n            chessController.getFundRelativeWeight(address(fund), endWeek - 1 weeks);\\n        uint256 version = _totalSupplyVersion;\\n        uint256 rebalanceTimestamp;\\n        if (version < rebalanceSize) {\\n            rebalanceTimestamp = fund.getRebalanceTimestamp(version);\\n        } else {\\n            rebalanceTimestamp = type(uint256).max;\\n        }\\n        uint256 rate = _rate;\\n        uint256 totalSupplyM = _totalSupplies[TRANCHE_M];\\n        uint256 totalSupplyA = _totalSupplies[TRANCHE_A];\\n        uint256 totalSupplyB = _totalSupplies[TRANCHE_B];\\n        uint256 weight = _workingSupply;\\n        uint256 timestamp_ = timestamp; // avoid stack too deep\\n\\n        for (uint256 i = 0; i < MAX_ITERATIONS && timestamp_ < block.timestamp; i++) {\\n            uint256 endTimestamp = rebalanceTimestamp.min(endWeek).min(block.timestamp);\\n\\n            if (weight > 0) {\\n                integral = integral.add(\\n                    rate\\n                        .mul(endTimestamp.sub(timestamp_))\\n                        .multiplyDecimal(weeklyPercentage)\\n                        .divideDecimalPrecise(weight)\\n                );\\n            }\\n\\n            if (endTimestamp == rebalanceTimestamp) {\\n                uint256 oldSize = _historicalIntegralSize;\\n                _historicalIntegrals[oldSize] = integral;\\n                _historicalIntegralSize = oldSize + 1;\\n\\n                integral = 0;\\n                (totalSupplyM, totalSupplyA, totalSupplyB) = _fundDoRebalance(\\n                    totalSupplyM,\\n                    totalSupplyA,\\n                    totalSupplyB,\\n                    version\\n                );\\n\\n                version++;\\n                // Reset total weight boosting after the first rebalance\\n                weight = weightedBalance(totalSupplyM, totalSupplyA, totalSupplyB);\\n\\n                if (version < rebalanceSize) {\\n                    rebalanceTimestamp = fund.getRebalanceTimestamp(version);\\n                } else {\\n                    rebalanceTimestamp = type(uint256).max;\\n                }\\n            }\\n            if (endTimestamp == endWeek) {\\n                rate = chessSchedule.getRate(endWeek);\\n                weeklyPercentage = chessController.getFundRelativeWeight(address(fund), endWeek);\\n                endWeek += 1 weeks;\\n            }\\n\\n            timestamp_ = endTimestamp;\\n        }\\n\\n        _checkpointTimestamp = block.timestamp;\\n        _invTotalWeightIntegral = integral;\\n        if (_rate != rate) {\\n            _rate = rate;\\n        }\\n        if (_totalSupplyVersion != rebalanceSize) {\\n            _totalSupplies[TRANCHE_M] = totalSupplyM;\\n            _totalSupplies[TRANCHE_A] = totalSupplyA;\\n            _totalSupplies[TRANCHE_B] = totalSupplyB;\\n            _totalSupplyVersion = rebalanceSize;\\n            // Reset total working weight before any boosting if rebalance ever triggered\\n            _workingSupply = weight;\\n        }\\n    }\\n\\n    /// @dev Transform a user's balance to a given rebalance version and update this user's rewards.\\n    ///\\n    ///      In most cases, the target version is the latest version and this function cumulates\\n    ///      rewards till now. When this function is called from `refreshBalance()`,\\n    ///      `targetVersion` can be an older version, in which case rewards are cumulated till\\n    ///      the end of that version (i.e. timestamp of the transaction triggering the rebalance\\n    ///      with index `targetVersion`).\\n    ///\\n    ///      This function should always be called after `_checkpoint()` is called, so that\\n    ///      the global reward checkpoint is guarenteed up to date.\\n    /// @param account Account to update\\n    /// @param targetVersion The target rebalance version\\n    function _userCheckpoint(address account, uint256 targetVersion) private {\\n        uint256 oldVersion = _balanceVersions[account];\\n        if (oldVersion > targetVersion) {\\n            return;\\n        }\\n        uint256 userIntegral = _userIntegrals[account];\\n        uint256 integral;\\n        // This scope is to avoid the \\\"stack too deep\\\" error.\\n        {\\n            // We assume that this function is always called immediately after `_checkpoint()`,\\n            // which guarantees that `_historicalIntegralSize` equals to the number of historical\\n            // rebalances.\\n            uint256 rebalanceSize = _historicalIntegralSize;\\n            integral = targetVersion == rebalanceSize\\n                ? _invTotalWeightIntegral\\n                : _historicalIntegrals[targetVersion];\\n        }\\n        if (userIntegral == integral && oldVersion == targetVersion) {\\n            // Return immediately when the user's rewards have already been updated to\\n            // the target version.\\n            return;\\n        }\\n\\n        uint256 rewards = _claimableRewards[account];\\n        uint256[TRANCHE_COUNT] storage available = _availableBalances[account];\\n        uint256[TRANCHE_COUNT] storage locked = _lockedBalances[account];\\n        uint256 weight = _workingBalances[account];\\n        if (weight == 0) {\\n            // Loading available and locked is repeated to avoid \\\"stake too deep\\\" error.\\n            weight = weightedBalance(\\n                available[TRANCHE_M].add(locked[TRANCHE_M]),\\n                available[TRANCHE_A].add(locked[TRANCHE_A]),\\n                available[TRANCHE_B].add(locked[TRANCHE_B])\\n            );\\n            if (weight > 0) {\\n                // The contract was just upgraded from an old version without boosting\\n                _workingBalances[account] = weight;\\n            }\\n        }\\n        uint256 availableM = available[TRANCHE_M];\\n        uint256 availableA = available[TRANCHE_A];\\n        uint256 availableB = available[TRANCHE_B];\\n        uint256 lockedM = locked[TRANCHE_M];\\n        uint256 lockedA = locked[TRANCHE_A];\\n        uint256 lockedB = locked[TRANCHE_B];\\n        for (uint256 i = oldVersion; i < targetVersion; i++) {\\n            rewards = rewards.add(\\n                weight.multiplyDecimalPrecise(_historicalIntegrals[i].sub(userIntegral))\\n            );\\n            if (availableM != 0 || availableA != 0 || availableB != 0) {\\n                (availableM, availableA, availableB) = _fundDoRebalance(\\n                    availableM,\\n                    availableA,\\n                    availableB,\\n                    i\\n                );\\n            }\\n            if (lockedM != 0 || lockedA != 0 || lockedB != 0) {\\n                (lockedM, lockedA, lockedB) = _fundDoRebalance(lockedM, lockedA, lockedB, i);\\n            }\\n            userIntegral = 0;\\n\\n            // Reset per-user weight boosting after the first rebalance\\n            weight = weightedBalance(\\n                availableM.add(lockedM),\\n                availableA.add(lockedA),\\n                availableB.add(lockedB)\\n            );\\n        }\\n        rewards = rewards.add(weight.multiplyDecimalPrecise(integral.sub(userIntegral)));\\n        address account_ = account; // Fix the \\\"stack too deep\\\" error\\n        _claimableRewards[account_] = rewards;\\n        _userIntegrals[account_] = integral;\\n\\n        if (oldVersion < targetVersion) {\\n            if (available[TRANCHE_M] != availableM) {\\n                available[TRANCHE_M] = availableM;\\n            }\\n            if (available[TRANCHE_A] != availableA) {\\n                available[TRANCHE_A] = availableA;\\n            }\\n            if (available[TRANCHE_B] != availableB) {\\n                available[TRANCHE_B] = availableB;\\n            }\\n            if (locked[TRANCHE_M] != lockedM) {\\n                locked[TRANCHE_M] = lockedM;\\n            }\\n            if (locked[TRANCHE_A] != lockedA) {\\n                locked[TRANCHE_A] = lockedA;\\n            }\\n            if (locked[TRANCHE_B] != lockedB) {\\n                locked[TRANCHE_B] = lockedB;\\n            }\\n            _balanceVersions[account_] = targetVersion;\\n            _workingBalances[account_] = weight;\\n        }\\n    }\\n\\n    /// @dev Calculate working balance, which depends on the amount of staked tokens and veCHESS.\\n    ///      Before this function is called, both `_checkpoint()` and `_userCheckpoint(account)`\\n    ///      should be called to update `_workingSupply` and `_workingBalances[account]` to\\n    ///      the latest rebalance version.\\n    /// @param account User address\\n    function _updateWorkingBalance(address account) private {\\n        uint256 weightedSupply =\\n            weightedBalance(\\n                _totalSupplies[TRANCHE_M],\\n                _totalSupplies[TRANCHE_A],\\n                _totalSupplies[TRANCHE_B]\\n            );\\n        uint256[TRANCHE_COUNT] storage available = _availableBalances[account];\\n        uint256[TRANCHE_COUNT] storage locked = _lockedBalances[account];\\n        // Assume weightedBalance(x, 0, 0) always equal to x\\n        uint256 weightedM = available[TRANCHE_M].add(locked[TRANCHE_M]);\\n        uint256 weightedAB =\\n            weightedBalance(\\n                0,\\n                available[TRANCHE_A].add(locked[TRANCHE_A]),\\n                available[TRANCHE_B].add(locked[TRANCHE_B])\\n            );\\n\\n        uint256 newWorkingBalance = weightedAB.add(weightedM);\\n        uint256 veProportion = _veSnapshots[account].veProportion;\\n        if (veProportion > 0 && _veSnapshots[account].veLocked.unlockTime > block.timestamp) {\\n            uint256 boostingPower = weightedSupply.multiplyDecimal(veProportion);\\n            if (boostingPower <= weightedAB) {\\n                newWorkingBalance = newWorkingBalance.add(\\n                    boostingPower.multiplyDecimal(MAX_BOOSTING_FACTOR_MINUS_ONE)\\n                );\\n            } else {\\n                uint256 boostingPowerM =\\n                    (boostingPower - weightedAB)\\n                        .min(boostingPower.multiplyDecimal(MAX_BOOSTING_POWER_M))\\n                        .min(weightedM);\\n                newWorkingBalance = newWorkingBalance.add(\\n                    weightedAB.add(boostingPowerM).multiplyDecimal(MAX_BOOSTING_FACTOR_MINUS_ONE)\\n                );\\n            }\\n        }\\n\\n        _workingSupply = _workingSupply.sub(_workingBalances[account]).add(newWorkingBalance);\\n        _workingBalances[account] = newWorkingBalance;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/exchange/ExchangeV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\nimport \\\"../../utils/SafeDecimalMath.sol\\\";\\nimport \\\"../../utils/ProxyUtility.sol\\\";\\n\\nimport {Order, OrderQueue, LibOrderQueue} from \\\"./LibOrderQueue.sol\\\";\\nimport {\\n    UnsettledBuyTrade,\\n    UnsettledSellTrade,\\n    UnsettledTrade,\\n    LibUnsettledBuyTrade,\\n    LibUnsettledSellTrade\\n} from \\\"./LibUnsettledTrade.sol\\\";\\n\\nimport \\\"./ExchangeRoles.sol\\\";\\nimport \\\"./StakingV2.sol\\\";\\n\\n/// @title Tranchess's Exchange Contract\\n/// @notice A decentralized exchange to match premium-discount orders and clear trades\\n/// @author Tranchess\\ncontract ExchangeV2 is ExchangeRoles, StakingV2, ProxyUtility {\\n    /// @dev Reserved storage slots for future base contract upgrades\\n    uint256[29] private _reservedSlots;\\n\\n    using SafeDecimalMath for uint256;\\n    using LibOrderQueue for OrderQueue;\\n    using SafeERC20 for IERC20;\\n    using LibUnsettledBuyTrade for UnsettledBuyTrade;\\n    using LibUnsettledSellTrade for UnsettledSellTrade;\\n\\n    /// @notice A maker bid order is placed.\\n    /// @param maker Account placing the order\\n    /// @param tranche Tranche of the share to buy\\n    /// @param pdLevel Premium-discount level\\n    /// @param quoteAmount Amount of quote asset in the order, rounding precision to 18\\n    ///                    for quote assets with precision other than 18 decimal places\\n    /// @param version The latest rebalance version when the order is placed\\n    /// @param orderIndex Index of the order in the order queue\\n    event BidOrderPlaced(\\n        address indexed maker,\\n        uint256 indexed tranche,\\n        uint256 pdLevel,\\n        uint256 quoteAmount,\\n        uint256 version,\\n        uint256 orderIndex\\n    );\\n\\n    /// @notice A maker ask order is placed.\\n    /// @param maker Account placing the order\\n    /// @param tranche Tranche of the share to sell\\n    /// @param pdLevel Premium-discount level\\n    /// @param baseAmount Amount of base asset in the order\\n    /// @param version The latest rebalance version when the order is placed\\n    /// @param orderIndex Index of the order in the order queue\\n    event AskOrderPlaced(\\n        address indexed maker,\\n        uint256 indexed tranche,\\n        uint256 pdLevel,\\n        uint256 baseAmount,\\n        uint256 version,\\n        uint256 orderIndex\\n    );\\n\\n    /// @notice A maker bid order is canceled.\\n    /// @param maker Account placing the order\\n    /// @param tranche Tranche of the share\\n    /// @param pdLevel Premium-discount level\\n    /// @param quoteAmount Original amount of quote asset in the order, rounding precision to 18\\n    ///                    for quote assets with precision other than 18 decimal places\\n    /// @param version The latest rebalance version when the order is placed\\n    /// @param orderIndex Index of the order in the order queue\\n    /// @param fillable Unfilled amount when the order is canceled, rounding precision to 18 for\\n    ///                 quote assets with precision other than 18 decimal places\\n    event BidOrderCanceled(\\n        address indexed maker,\\n        uint256 indexed tranche,\\n        uint256 pdLevel,\\n        uint256 quoteAmount,\\n        uint256 version,\\n        uint256 orderIndex,\\n        uint256 fillable\\n    );\\n\\n    /// @notice A maker ask order is canceled.\\n    /// @param maker Account placing the order\\n    /// @param tranche Tranche of the share to sell\\n    /// @param pdLevel Premium-discount level\\n    /// @param baseAmount Original amount of base asset in the order\\n    /// @param version The latest rebalance version when the order is placed\\n    /// @param orderIndex Index of the order in the order queue\\n    /// @param fillable Unfilled amount when the order is canceled\\n    event AskOrderCanceled(\\n        address indexed maker,\\n        uint256 indexed tranche,\\n        uint256 pdLevel,\\n        uint256 baseAmount,\\n        uint256 version,\\n        uint256 orderIndex,\\n        uint256 fillable\\n    );\\n\\n    /// @notice Matching result of a taker bid order.\\n    /// @param taker Account placing the order\\n    /// @param tranche Tranche of the share\\n    /// @param quoteAmount Matched amount of quote asset, rounding precision to 18 for quote assets\\n    ///                    with precision other than 18 decimal places\\n    /// @param version Rebalance version of this trade\\n    /// @param lastMatchedPDLevel Premium-discount level of the last matched maker order\\n    /// @param lastMatchedOrderIndex Index of the last matched maker order in its order queue\\n    /// @param lastMatchedBaseAmount Matched base asset amount of the last matched maker order\\n    event BuyTrade(\\n        address indexed taker,\\n        uint256 indexed tranche,\\n        uint256 quoteAmount,\\n        uint256 version,\\n        uint256 lastMatchedPDLevel,\\n        uint256 lastMatchedOrderIndex,\\n        uint256 lastMatchedBaseAmount\\n    );\\n\\n    /// @notice Matching result of a taker ask order.\\n    /// @param taker Account placing the order\\n    /// @param tranche Tranche of the share\\n    /// @param baseAmount Matched amount of base asset\\n    /// @param version Rebalance version of this trade\\n    /// @param lastMatchedPDLevel Premium-discount level of the last matched maker order\\n    /// @param lastMatchedOrderIndex Index of the last matched maker order in its order queue\\n    /// @param lastMatchedQuoteAmount Matched quote asset amount of the last matched maker order,\\n    ///                               rounding precision to 18 for quote assets with precision\\n    ///                               other than 18 decimal places\\n    event SellTrade(\\n        address indexed taker,\\n        uint256 indexed tranche,\\n        uint256 baseAmount,\\n        uint256 version,\\n        uint256 lastMatchedPDLevel,\\n        uint256 lastMatchedOrderIndex,\\n        uint256 lastMatchedQuoteAmount\\n    );\\n\\n    /// @notice Settlement of unsettled trades of maker orders.\\n    /// @param account Account placing the related maker orders\\n    /// @param epoch Epoch of the settled trades\\n    /// @param amountM Amount of Token M added to the account's available balance\\n    /// @param amountA Amount of Token A added to the account's available balance\\n    /// @param amountB Amount of Token B added to the account's available balance\\n    /// @param quoteAmount Amount of quote asset transfered to the account, rounding precision to 18\\n    ///                    for quote assets with precision other than 18 decimal places\\n    event MakerSettled(\\n        address indexed account,\\n        uint256 epoch,\\n        uint256 amountM,\\n        uint256 amountA,\\n        uint256 amountB,\\n        uint256 quoteAmount\\n    );\\n\\n    /// @notice Settlement of unsettled trades of taker orders.\\n    /// @param account Account placing the related taker orders\\n    /// @param epoch Epoch of the settled trades\\n    /// @param amountM Amount of Token M added to the account's available balance\\n    /// @param amountA Amount of Token A added to the account's available balance\\n    /// @param amountB Amount of Token B added to the account's available balance\\n    /// @param quoteAmount Amount of quote asset transfered to the account, rounding precision to 18\\n    ///                    for quote assets with precision other than 18 decimal places\\n    event TakerSettled(\\n        address indexed account,\\n        uint256 epoch,\\n        uint256 amountM,\\n        uint256 amountA,\\n        uint256 amountB,\\n        uint256 quoteAmount\\n    );\\n\\n    uint256 private constant EPOCH = 30 minutes; // An exchange epoch is 30 minutes long\\n\\n    /// @dev Maker reserves 105% of Token M they want to trade, which would stop\\n    ///      losses for makers when the net asset values turn out volatile\\n    uint256 private constant MAKER_RESERVE_RATIO_M = 1.05e18;\\n\\n    /// @dev Maker reserves 100.1% of Token A they want to trade, which would stop\\n    ///      losses for makers when the net asset values turn out volatile\\n    uint256 private constant MAKER_RESERVE_RATIO_A = 1.001e18;\\n\\n    /// @dev Maker reserves 110% of Token B they want to trade, which would stop\\n    ///      losses for makers when the net asset values turn out volatile\\n    uint256 private constant MAKER_RESERVE_RATIO_B = 1.1e18;\\n\\n    /// @dev Premium-discount level ranges from -10% to 10% with 0.25% as step size\\n    uint256 private constant PD_TICK = 0.0025e18;\\n\\n    uint256 private constant MIN_PD = 0.9e18;\\n    uint256 private constant MAX_PD = 1.1e18;\\n    uint256 private constant PD_START = MIN_PD - PD_TICK;\\n    uint256 private constant PD_LEVEL_COUNT = (MAX_PD - MIN_PD) / PD_TICK + 1;\\n\\n    /// @notice Minumum quote amount of maker bid orders with 18 decimal places\\n    uint256 public immutable minBidAmount;\\n\\n    /// @notice Minumum base amount of maker ask orders\\n    uint256 public immutable minAskAmount;\\n\\n    /// @notice Minumum base or quote amount of maker orders during guarded launch\\n    uint256 public immutable guardedLaunchMinOrderAmount;\\n\\n    /// @dev A multipler that normalizes a quote asset balance to 18 decimal places.\\n    uint256 private immutable _quoteDecimalMultiplier;\\n\\n    /// @notice Mapping of rebalance version => tranche => an array of order queues\\n    mapping(uint256 => mapping(uint256 => OrderQueue[PD_LEVEL_COUNT + 1])) public bids;\\n    mapping(uint256 => mapping(uint256 => OrderQueue[PD_LEVEL_COUNT + 1])) public asks;\\n\\n    /// @notice Mapping of rebalance version => best bid premium-discount level of the three tranches.\\n    ///         Zero indicates that there is no bid order.\\n    mapping(uint256 => uint256[TRANCHE_COUNT]) public bestBids;\\n\\n    /// @notice Mapping of rebalance version => best ask premium-discount level of the three tranches.\\n    ///         Zero or `PD_LEVEL_COUNT + 1` indicates that there is no ask order.\\n    mapping(uint256 => uint256[TRANCHE_COUNT]) public bestAsks;\\n\\n    /// @notice Mapping of account => tranche => epoch => unsettled trade\\n    mapping(address => mapping(uint256 => mapping(uint256 => UnsettledTrade)))\\n        public unsettledTrades;\\n\\n    /// @dev Mapping of epoch => rebalance version\\n    mapping(uint256 => uint256) private _epochVersions;\\n\\n    constructor(\\n        address fund_,\\n        address chessSchedule_,\\n        address chessController_,\\n        address quoteAssetAddress_,\\n        uint256 quoteDecimals_,\\n        address votingEscrow_,\\n        uint256 minBidAmount_,\\n        uint256 minAskAmount_,\\n        uint256 makerRequirement_,\\n        uint256 guardedLaunchStart_,\\n        uint256 guardedLaunchMinOrderAmount_\\n    )\\n        public\\n        ExchangeRoles(votingEscrow_, makerRequirement_)\\n        StakingV2(\\n            fund_,\\n            chessSchedule_,\\n            chessController_,\\n            quoteAssetAddress_,\\n            guardedLaunchStart_,\\n            votingEscrow_\\n        )\\n    {\\n        minBidAmount = minBidAmount_;\\n        minAskAmount = minAskAmount_;\\n        guardedLaunchMinOrderAmount = guardedLaunchMinOrderAmount_;\\n        require(quoteDecimals_ <= 18, \\\"Quote asset decimals larger than 18\\\");\\n        _quoteDecimalMultiplier = 10**(18 - quoteDecimals_);\\n    }\\n\\n    /// @dev Initialize the contract. The contract is designed to be used with OpenZeppelin's\\n    ///      `TransparentUpgradeableProxy`. This function should be called by the proxy's\\n    ///      constructor (via the `_data` argument).\\n    function initialize() external {\\n        _initializeStaking();\\n        _initializeV2(msg.sender);\\n    }\\n\\n    /// @dev Initialize the part added in V2. If this contract is upgraded from the previous\\n    ///      version, call `upgradeToAndCall` of the proxy and put a call to this function\\n    ///      in the `data` argument.\\n    function initializeV2(address pauser_) external onlyProxyAdmin {\\n        _initializeV2(pauser_);\\n    }\\n\\n    function _initializeV2(address pauser_) private {\\n        _initializeStakingV2(pauser_);\\n    }\\n\\n    /// @notice Return end timestamp of the epoch containing a given timestamp.\\n    /// @param timestamp Timestamp within a given epoch\\n    /// @return The closest ending timestamp\\n    function endOfEpoch(uint256 timestamp) public pure returns (uint256) {\\n        return (timestamp / EPOCH) * EPOCH + EPOCH;\\n    }\\n\\n    function getMakerReserveRatio(uint256 tranche) public pure returns (uint256) {\\n        if (tranche == TRANCHE_M) {\\n            return MAKER_RESERVE_RATIO_M;\\n        } else if (tranche == TRANCHE_A) {\\n            return MAKER_RESERVE_RATIO_A;\\n        } else {\\n            return MAKER_RESERVE_RATIO_B;\\n        }\\n    }\\n\\n    function getBidOrder(\\n        uint256 version,\\n        uint256 tranche,\\n        uint256 pdLevel,\\n        uint256 index\\n    )\\n        external\\n        view\\n        returns (\\n            address maker,\\n            uint256 amount,\\n            uint256 fillable\\n        )\\n    {\\n        Order storage order = bids[version][tranche][pdLevel].list[index];\\n        maker = order.maker;\\n        amount = order.amount;\\n        fillable = order.fillable;\\n    }\\n\\n    function getAskOrder(\\n        uint256 version,\\n        uint256 tranche,\\n        uint256 pdLevel,\\n        uint256 index\\n    )\\n        external\\n        view\\n        returns (\\n            address maker,\\n            uint256 amount,\\n            uint256 fillable\\n        )\\n    {\\n        Order storage order = asks[version][tranche][pdLevel].list[index];\\n        maker = order.maker;\\n        amount = order.amount;\\n        fillable = order.fillable;\\n    }\\n\\n    /// @notice Get all tranches' net asset values of a given time\\n    /// @param timestamp Timestamp of the net asset value\\n    /// @return estimatedNavM Token M's net asset value\\n    /// @return estimatedNavA Token A's net asset value\\n    /// @return estimatedNavB Token B's net asset value\\n    function estimateNavs(uint256 timestamp)\\n        public\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256 price = fund.twapOracle().getTwap(timestamp);\\n        require(price != 0, \\\"Price is not available\\\");\\n        return fund.extrapolateNav(timestamp, price);\\n    }\\n\\n    /// @notice Place a bid order for makers\\n    /// @param tranche Tranche of the base asset\\n    /// @param pdLevel Premium-discount level\\n    /// @param quoteAmount Quote asset amount with 18 decimal places\\n    /// @param version Current rebalance version. Revert if it is not the latest version.\\n    function placeBid(\\n        uint256 tranche,\\n        uint256 pdLevel,\\n        uint256 quoteAmount,\\n        uint256 version\\n    ) external onlyMaker whenNotPaused {\\n        require(block.timestamp >= guardedLaunchStart + 8 days, \\\"Guarded launch: market closed\\\");\\n        if (block.timestamp < guardedLaunchStart + 4 weeks) {\\n            require(quoteAmount >= guardedLaunchMinOrderAmount, \\\"Guarded launch: amount too low\\\");\\n        } else {\\n            require(quoteAmount >= minBidAmount, \\\"Quote amount too low\\\");\\n        }\\n        uint256 bestAsk = bestAsks[version][tranche];\\n        require(\\n            pdLevel > 0 && pdLevel < (bestAsk == 0 ? PD_LEVEL_COUNT + 1 : bestAsk),\\n            \\\"Invalid premium-discount level\\\"\\n        );\\n        require(version == _fundRebalanceSize(), \\\"Invalid version\\\");\\n\\n        uint256 index = bids[version][tranche][pdLevel].append(msg.sender, quoteAmount, version);\\n        if (bestBids[version][tranche] < pdLevel) {\\n            bestBids[version][tranche] = pdLevel;\\n        }\\n\\n        _transferQuoteFrom(msg.sender, quoteAmount);\\n\\n        emit BidOrderPlaced(msg.sender, tranche, pdLevel, quoteAmount, version, index);\\n    }\\n\\n    /// @notice Place an ask order for makers\\n    /// @param tranche Tranche of the base asset\\n    /// @param pdLevel Premium-discount level\\n    /// @param baseAmount Base asset amount\\n    /// @param version Current rebalance version. Revert if it is not the latest version.\\n    function placeAsk(\\n        uint256 tranche,\\n        uint256 pdLevel,\\n        uint256 baseAmount,\\n        uint256 version\\n    ) external onlyMaker whenNotPaused {\\n        require(block.timestamp >= guardedLaunchStart + 8 days, \\\"Guarded launch: market closed\\\");\\n        if (block.timestamp < guardedLaunchStart + 4 weeks) {\\n            require(baseAmount >= guardedLaunchMinOrderAmount, \\\"Guarded launch: amount too low\\\");\\n        } else {\\n            require(baseAmount >= minAskAmount, \\\"Base amount too low\\\");\\n        }\\n        require(\\n            pdLevel > bestBids[version][tranche] && pdLevel <= PD_LEVEL_COUNT,\\n            \\\"Invalid premium-discount level\\\"\\n        );\\n        require(version == _fundRebalanceSize(), \\\"Invalid version\\\");\\n\\n        _lock(tranche, msg.sender, baseAmount);\\n        uint256 index = asks[version][tranche][pdLevel].append(msg.sender, baseAmount, version);\\n        uint256 oldBestAsk = bestAsks[version][tranche];\\n        if (oldBestAsk > pdLevel || oldBestAsk == 0) {\\n            bestAsks[version][tranche] = pdLevel;\\n        }\\n\\n        emit AskOrderPlaced(msg.sender, tranche, pdLevel, baseAmount, version, index);\\n    }\\n\\n    /// @notice Cancel a bid order\\n    /// @param version Order's rebalance version\\n    /// @param tranche Tranche of the order's base asset\\n    /// @param pdLevel Order's premium-discount level\\n    /// @param index Order's index in the order queue\\n    function cancelBid(\\n        uint256 version,\\n        uint256 tranche,\\n        uint256 pdLevel,\\n        uint256 index\\n    ) external whenNotPaused {\\n        OrderQueue storage orderQueue = bids[version][tranche][pdLevel];\\n        Order storage order = orderQueue.list[index];\\n        require(order.maker == msg.sender, \\\"Maker address mismatched\\\");\\n\\n        uint256 fillable = order.fillable;\\n        emit BidOrderCanceled(msg.sender, tranche, pdLevel, order.amount, version, index, fillable);\\n        orderQueue.cancel(index);\\n\\n        // Update bestBid\\n        if (bestBids[version][tranche] == pdLevel) {\\n            uint256 newBestBid = pdLevel;\\n            while (newBestBid > 0 && bids[version][tranche][newBestBid].isEmpty()) {\\n                newBestBid--;\\n            }\\n            bestBids[version][tranche] = newBestBid;\\n        }\\n\\n        _transferQuote(msg.sender, fillable);\\n    }\\n\\n    /// @notice Cancel an ask order\\n    /// @param version Order's rebalance version\\n    /// @param tranche Tranche of the order's base asset\\n    /// @param pdLevel Order's premium-discount level\\n    /// @param index Order's index in the order queue\\n    function cancelAsk(\\n        uint256 version,\\n        uint256 tranche,\\n        uint256 pdLevel,\\n        uint256 index\\n    ) external whenNotPaused {\\n        OrderQueue storage orderQueue = asks[version][tranche][pdLevel];\\n        Order storage order = orderQueue.list[index];\\n        require(order.maker == msg.sender, \\\"Maker address mismatched\\\");\\n\\n        uint256 fillable = order.fillable;\\n        emit AskOrderCanceled(msg.sender, tranche, pdLevel, order.amount, version, index, fillable);\\n        orderQueue.cancel(index);\\n\\n        // Update bestAsk\\n        if (bestAsks[version][tranche] == pdLevel) {\\n            uint256 newBestAsk = pdLevel;\\n            while (newBestAsk <= PD_LEVEL_COUNT && asks[version][tranche][newBestAsk].isEmpty()) {\\n                newBestAsk++;\\n            }\\n            bestAsks[version][tranche] = newBestAsk;\\n        }\\n\\n        if (tranche == TRANCHE_M) {\\n            _rebalanceAndUnlock(msg.sender, fillable, 0, 0, version);\\n        } else if (tranche == TRANCHE_A) {\\n            _rebalanceAndUnlock(msg.sender, 0, fillable, 0, version);\\n        } else {\\n            _rebalanceAndUnlock(msg.sender, 0, 0, fillable, version);\\n        }\\n    }\\n\\n    /// @notice Buy Token M\\n    /// @param version Current rebalance version. Revert if it is not the latest version.\\n    /// @param maxPDLevel Maximal premium-discount level accepted\\n    /// @param quoteAmount Amount of quote assets (with 18 decimal places) willing to trade\\n    function buyM(\\n        uint256 version,\\n        uint256 maxPDLevel,\\n        uint256 quoteAmount\\n    ) external {\\n        (uint256 estimatedNav, , ) = estimateNavs(endOfEpoch(block.timestamp) - 2 * EPOCH);\\n        _buy(version, TRANCHE_M, maxPDLevel, estimatedNav, quoteAmount);\\n    }\\n\\n    /// @notice Buy Token A\\n    /// @param version Current rebalance version. Revert if it is not the latest version.\\n    /// @param maxPDLevel Maximal premium-discount level accepted\\n    /// @param quoteAmount Amount of quote assets (with 18 decimal places) willing to trade\\n    function buyA(\\n        uint256 version,\\n        uint256 maxPDLevel,\\n        uint256 quoteAmount\\n    ) external {\\n        (, uint256 estimatedNav, ) = estimateNavs(endOfEpoch(block.timestamp) - 2 * EPOCH);\\n        _buy(version, TRANCHE_A, maxPDLevel, estimatedNav, quoteAmount);\\n    }\\n\\n    /// @notice Buy Token B\\n    /// @param version Current rebalance version. Revert if it is not the latest version.\\n    /// @param maxPDLevel Maximal premium-discount level accepted\\n    /// @param quoteAmount Amount of quote assets (with 18 decimal places) willing to trade\\n    function buyB(\\n        uint256 version,\\n        uint256 maxPDLevel,\\n        uint256 quoteAmount\\n    ) external {\\n        (, , uint256 estimatedNav) = estimateNavs(endOfEpoch(block.timestamp) - 2 * EPOCH);\\n        _buy(version, TRANCHE_B, maxPDLevel, estimatedNav, quoteAmount);\\n    }\\n\\n    /// @notice Sell Token M\\n    /// @param version Current rebalance version. Revert if it is not the latest version.\\n    /// @param minPDLevel Minimal premium-discount level accepted\\n    /// @param baseAmount Amount of Token M willing to trade\\n    function sellM(\\n        uint256 version,\\n        uint256 minPDLevel,\\n        uint256 baseAmount\\n    ) external {\\n        (uint256 estimatedNav, , ) = estimateNavs(endOfEpoch(block.timestamp) - 2 * EPOCH);\\n        _sell(version, TRANCHE_M, minPDLevel, estimatedNav, baseAmount);\\n    }\\n\\n    /// @notice Sell Token A\\n    /// @param version Current rebalance version. Revert if it is not the latest version.\\n    /// @param minPDLevel Minimal premium-discount level accepted\\n    /// @param baseAmount Amount of Token A willing to trade\\n    function sellA(\\n        uint256 version,\\n        uint256 minPDLevel,\\n        uint256 baseAmount\\n    ) external {\\n        (, uint256 estimatedNav, ) = estimateNavs(endOfEpoch(block.timestamp) - 2 * EPOCH);\\n        _sell(version, TRANCHE_A, minPDLevel, estimatedNav, baseAmount);\\n    }\\n\\n    /// @notice Sell Token B\\n    /// @param version Current rebalance version. Revert if it is not the latest version.\\n    /// @param minPDLevel Minimal premium-discount level accepted\\n    /// @param baseAmount Amount of Token B willing to trade\\n    function sellB(\\n        uint256 version,\\n        uint256 minPDLevel,\\n        uint256 baseAmount\\n    ) external {\\n        (, , uint256 estimatedNav) = estimateNavs(endOfEpoch(block.timestamp) - 2 * EPOCH);\\n        _sell(version, TRANCHE_B, minPDLevel, estimatedNav, baseAmount);\\n    }\\n\\n    /// @notice Settle trades of a specified epoch for makers\\n    /// @param account Address of the maker\\n    /// @param epoch A specified epoch's end timestamp\\n    /// @return amountM Token M amount added to msg.sender's available balance\\n    /// @return amountA Token A amount added to msg.sender's available balance\\n    /// @return amountB Token B amount added to msg.sender's available balance\\n    /// @return quoteAmount Quote asset amount transfered to msg.sender, rounding precison to 18\\n    ///                     for quote assets with precision other than 18 decimal places\\n    function settleMaker(address account, uint256 epoch)\\n        external\\n        whenNotPaused\\n        returns (\\n            uint256 amountM,\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 quoteAmount\\n        )\\n    {\\n        (uint256 estimatedNavM, uint256 estimatedNavA, uint256 estimatedNavB) =\\n            estimateNavs(epoch.add(EPOCH));\\n\\n        uint256 quoteAmountM;\\n        uint256 quoteAmountA;\\n        uint256 quoteAmountB;\\n        (amountM, quoteAmountM) = _settleMaker(account, TRANCHE_M, estimatedNavM, epoch);\\n        (amountA, quoteAmountA) = _settleMaker(account, TRANCHE_A, estimatedNavA, epoch);\\n        (amountB, quoteAmountB) = _settleMaker(account, TRANCHE_B, estimatedNavB, epoch);\\n\\n        uint256 version = _epochVersions[epoch];\\n        (amountM, amountA, amountB) = _rebalanceAndClearTrade(\\n            account,\\n            amountM,\\n            amountA,\\n            amountB,\\n            version\\n        );\\n        quoteAmount = quoteAmountM.add(quoteAmountA).add(quoteAmountB);\\n        _transferQuote(account, quoteAmount);\\n\\n        emit MakerSettled(account, epoch, amountM, amountA, amountB, quoteAmount);\\n    }\\n\\n    /// @notice Settle trades of a specified epoch for takers\\n    /// @param account Address of the maker\\n    /// @param epoch A specified epoch's end timestamp\\n    /// @return amountM Token M amount added to msg.sender's available balance\\n    /// @return amountA Token A amount added to msg.sender's available balance\\n    /// @return amountB Token B amount added to msg.sender's available balance\\n    /// @return quoteAmount Quote asset amount transfered to msg.sender, rounding precison to 18\\n    ///                     for quote assets with precision other than 18 decimal places\\n    function settleTaker(address account, uint256 epoch)\\n        external\\n        whenNotPaused\\n        returns (\\n            uint256 amountM,\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 quoteAmount\\n        )\\n    {\\n        (uint256 estimatedNavM, uint256 estimatedNavA, uint256 estimatedNavB) =\\n            estimateNavs(epoch.add(EPOCH));\\n\\n        uint256 quoteAmountM;\\n        uint256 quoteAmountA;\\n        uint256 quoteAmountB;\\n        (amountM, quoteAmountM) = _settleTaker(account, TRANCHE_M, estimatedNavM, epoch);\\n        (amountA, quoteAmountA) = _settleTaker(account, TRANCHE_A, estimatedNavA, epoch);\\n        (amountB, quoteAmountB) = _settleTaker(account, TRANCHE_B, estimatedNavB, epoch);\\n\\n        uint256 version = _epochVersions[epoch];\\n        (amountM, amountA, amountB) = _rebalanceAndClearTrade(\\n            account,\\n            amountM,\\n            amountA,\\n            amountB,\\n            version\\n        );\\n        quoteAmount = quoteAmountM.add(quoteAmountA).add(quoteAmountB);\\n        _transferQuote(account, quoteAmount);\\n\\n        emit TakerSettled(account, epoch, amountM, amountA, amountB, quoteAmount);\\n    }\\n\\n    /// @dev Buy share\\n    /// @param version Current rebalance version. Revert if it is not the latest version.\\n    /// @param tranche Tranche of the base asset\\n    /// @param maxPDLevel Maximal premium-discount level accepted\\n    /// @param estimatedNav Estimated net asset value of the base asset\\n    /// @param quoteAmount Amount of quote assets willing to trade with 18 decimal places\\n    function _buy(\\n        uint256 version,\\n        uint256 tranche,\\n        uint256 maxPDLevel,\\n        uint256 estimatedNav,\\n        uint256 quoteAmount\\n    ) internal onlyActive whenNotPaused {\\n        require(maxPDLevel > 0 && maxPDLevel <= PD_LEVEL_COUNT, \\\"Invalid premium-discount level\\\");\\n        require(version == _fundRebalanceSize(), \\\"Invalid version\\\");\\n        require(estimatedNav > 0, \\\"Zero estimated NAV\\\");\\n\\n        UnsettledBuyTrade memory totalTrade;\\n        uint256 epoch = endOfEpoch(block.timestamp);\\n\\n        // Record rebalance version in the first transaction in the epoch\\n        if (_epochVersions[epoch] == 0) {\\n            _epochVersions[epoch] = version;\\n        }\\n\\n        UnsettledBuyTrade memory currentTrade;\\n        uint256 orderIndex = 0;\\n        uint256 pdLevel = bestAsks[version][tranche];\\n        if (pdLevel == 0) {\\n            // Zero best ask indicates that no ask order is ever placed.\\n            // We set pdLevel beyond the largest valid level, forcing the following loop\\n            // to exit immediately.\\n            pdLevel = PD_LEVEL_COUNT + 1;\\n        }\\n        for (; pdLevel <= maxPDLevel; pdLevel++) {\\n            uint256 price = pdLevel.mul(PD_TICK).add(PD_START).multiplyDecimal(estimatedNav);\\n            OrderQueue storage orderQueue = asks[version][tranche][pdLevel];\\n            orderIndex = orderQueue.head;\\n            while (orderIndex != 0) {\\n                Order storage order = orderQueue.list[orderIndex];\\n\\n                // If the order initiator is no longer qualified for maker,\\n                // we skip the order and the linked-list-based order queue\\n                // would never traverse the order again\\n                if (!isMaker(order.maker)) {\\n                    orderIndex = order.next;\\n                    continue;\\n                }\\n\\n                // Scope to avoid \\\"stack too deep\\\"\\n                {\\n                    // Calculate the current trade assuming that the taker would be completely filled.\\n                    uint256 makerReserveRatio = getMakerReserveRatio(tranche);\\n                    currentTrade.frozenQuote = quoteAmount.sub(totalTrade.frozenQuote);\\n                    currentTrade.reservedBase = currentTrade.frozenQuote.mul(makerReserveRatio).div(\\n                        price\\n                    );\\n\\n                    if (currentTrade.reservedBase < order.fillable) {\\n                        // Taker is completely filled.\\n                        currentTrade.effectiveQuote = currentTrade.frozenQuote.divideDecimal(\\n                            pdLevel.mul(PD_TICK).add(PD_START)\\n                        );\\n                    } else {\\n                        // Maker is completely filled. Recalculate the current trade.\\n                        currentTrade.frozenQuote = order.fillable.mul(price).div(makerReserveRatio);\\n                        currentTrade.effectiveQuote = order.fillable.mul(estimatedNav).div(\\n                            makerReserveRatio\\n                        );\\n                        currentTrade.reservedBase = order.fillable;\\n                    }\\n                }\\n                totalTrade.frozenQuote = totalTrade.frozenQuote.add(currentTrade.frozenQuote);\\n                totalTrade.effectiveQuote = totalTrade.effectiveQuote.add(\\n                    currentTrade.effectiveQuote\\n                );\\n                totalTrade.reservedBase = totalTrade.reservedBase.add(currentTrade.reservedBase);\\n                unsettledTrades[order.maker][tranche][epoch].makerSell.add(currentTrade);\\n\\n                // There is no need to rebalance for maker; the fact that the order could\\n                // be filled here indicates that the maker is in the latest version\\n                _tradeLocked(tranche, order.maker, currentTrade.reservedBase);\\n\\n                uint256 orderNewFillable = order.fillable.sub(currentTrade.reservedBase);\\n                if (orderNewFillable > 0) {\\n                    // Maker is not completely filled. Matching ends here.\\n                    order.fillable = orderNewFillable;\\n                    break;\\n                } else {\\n                    // Delete the completely filled maker order.\\n                    orderIndex = orderQueue.fill(orderIndex);\\n                }\\n            }\\n\\n            orderQueue.updateHead(orderIndex);\\n            if (orderIndex != 0) {\\n                // This premium-discount level is not completely filled. Matching ends here.\\n                if (bestAsks[version][tranche] != pdLevel) {\\n                    bestAsks[version][tranche] = pdLevel;\\n                }\\n                break;\\n            }\\n        }\\n        emit BuyTrade(\\n            msg.sender,\\n            tranche,\\n            totalTrade.frozenQuote,\\n            version,\\n            pdLevel,\\n            orderIndex,\\n            orderIndex == 0 ? 0 : currentTrade.reservedBase\\n        );\\n        if (orderIndex == 0) {\\n            // Matching ends by completely filling all orders at and below the specified\\n            // premium-discount level `maxPDLevel`.\\n            // Find the new best ask beyond that level.\\n            for (; pdLevel <= PD_LEVEL_COUNT; pdLevel++) {\\n                if (!asks[version][tranche][pdLevel].isEmpty()) {\\n                    break;\\n                }\\n            }\\n            bestAsks[version][tranche] = pdLevel;\\n        }\\n\\n        require(\\n            totalTrade.frozenQuote > 0,\\n            \\\"Nothing can be bought at the given premium-discount level\\\"\\n        );\\n        unsettledTrades[msg.sender][tranche][epoch].takerBuy.add(totalTrade);\\n        _transferQuoteFrom(msg.sender, totalTrade.frozenQuote);\\n    }\\n\\n    /// @dev Sell share\\n    /// @param version Current rebalance version. Revert if it is not the latest version.\\n    /// @param tranche Tranche of the base asset\\n    /// @param minPDLevel Minimal premium-discount level accepted\\n    /// @param estimatedNav Estimated net asset value of the base asset\\n    /// @param baseAmount Amount of base assets willing to trade\\n    function _sell(\\n        uint256 version,\\n        uint256 tranche,\\n        uint256 minPDLevel,\\n        uint256 estimatedNav,\\n        uint256 baseAmount\\n    ) internal onlyActive whenNotPaused {\\n        require(minPDLevel > 0 && minPDLevel <= PD_LEVEL_COUNT, \\\"Invalid premium-discount level\\\");\\n        require(version == _fundRebalanceSize(), \\\"Invalid version\\\");\\n        require(estimatedNav > 0, \\\"Zero estimated NAV\\\");\\n\\n        UnsettledSellTrade memory totalTrade;\\n        uint256 epoch = endOfEpoch(block.timestamp);\\n\\n        // Record rebalance version in the first transaction in the epoch\\n        if (_epochVersions[epoch] == 0) {\\n            _epochVersions[epoch] = version;\\n        }\\n\\n        UnsettledSellTrade memory currentTrade;\\n        uint256 orderIndex;\\n        uint256 pdLevel = bestBids[version][tranche];\\n        for (; pdLevel >= minPDLevel; pdLevel--) {\\n            uint256 price = pdLevel.mul(PD_TICK).add(PD_START).multiplyDecimal(estimatedNav);\\n            OrderQueue storage orderQueue = bids[version][tranche][pdLevel];\\n            orderIndex = orderQueue.head;\\n            while (orderIndex != 0) {\\n                Order storage order = orderQueue.list[orderIndex];\\n\\n                // If the order initiator is no longer qualified for maker,\\n                // we skip the order and the linked-list-based order queue\\n                // would never traverse the order again\\n                if (!isMaker(order.maker)) {\\n                    orderIndex = order.next;\\n                    continue;\\n                }\\n\\n                // Scope to avoid \\\"stack too deep\\\"\\n                {\\n                    // Calculate the current trade assuming that the taker would be completely filled.\\n                    uint256 makerReserveRatio = getMakerReserveRatio(tranche);\\n                    currentTrade.frozenBase = baseAmount.sub(totalTrade.frozenBase);\\n                    currentTrade.reservedQuote = currentTrade\\n                        .frozenBase\\n                        .multiplyDecimal(makerReserveRatio)\\n                        .multiplyDecimal(price);\\n\\n                    if (currentTrade.reservedQuote < order.fillable) {\\n                        // Taker is completely filled\\n                        currentTrade.effectiveBase = currentTrade.frozenBase.multiplyDecimal(\\n                            pdLevel.mul(PD_TICK).add(PD_START)\\n                        );\\n                    } else {\\n                        // Maker is completely filled. Recalculate the current trade.\\n                        currentTrade.frozenBase = order.fillable.divideDecimal(price).divideDecimal(\\n                            makerReserveRatio\\n                        );\\n                        currentTrade.effectiveBase = order\\n                            .fillable\\n                            .divideDecimal(estimatedNav)\\n                            .divideDecimal(makerReserveRatio);\\n                        currentTrade.reservedQuote = order.fillable;\\n                    }\\n                }\\n                totalTrade.frozenBase = totalTrade.frozenBase.add(currentTrade.frozenBase);\\n                totalTrade.effectiveBase = totalTrade.effectiveBase.add(currentTrade.effectiveBase);\\n                totalTrade.reservedQuote = totalTrade.reservedQuote.add(currentTrade.reservedQuote);\\n                unsettledTrades[order.maker][tranche][epoch].makerBuy.add(currentTrade);\\n\\n                uint256 orderNewFillable = order.fillable.sub(currentTrade.reservedQuote);\\n                if (orderNewFillable > 0) {\\n                    // Maker is not completely filled. Matching ends here.\\n                    order.fillable = orderNewFillable;\\n                    break;\\n                } else {\\n                    // Delete the completely filled maker order.\\n                    orderIndex = orderQueue.fill(orderIndex);\\n                }\\n            }\\n\\n            orderQueue.updateHead(orderIndex);\\n            if (orderIndex != 0) {\\n                // This premium-discount level is not completely filled. Matching ends here.\\n                if (bestBids[version][tranche] != pdLevel) {\\n                    bestBids[version][tranche] = pdLevel;\\n                }\\n                break;\\n            }\\n        }\\n        emit SellTrade(\\n            msg.sender,\\n            tranche,\\n            totalTrade.frozenBase,\\n            version,\\n            pdLevel,\\n            orderIndex,\\n            orderIndex == 0 ? 0 : currentTrade.reservedQuote\\n        );\\n        if (orderIndex == 0) {\\n            // Matching ends by completely filling all orders at and above the specified\\n            // premium-discount level `minPDLevel`.\\n            // Find the new best bid beyond that level.\\n            for (; pdLevel > 0; pdLevel--) {\\n                if (!bids[version][tranche][pdLevel].isEmpty()) {\\n                    break;\\n                }\\n            }\\n            bestBids[version][tranche] = pdLevel;\\n        }\\n\\n        require(\\n            totalTrade.frozenBase > 0,\\n            \\\"Nothing can be sold at the given premium-discount level\\\"\\n        );\\n        _tradeAvailable(tranche, msg.sender, totalTrade.frozenBase);\\n        unsettledTrades[msg.sender][tranche][epoch].takerSell.add(totalTrade);\\n    }\\n\\n    /// @dev Settle both buy and sell trades of a specified epoch for takers\\n    /// @param account Taker address\\n    /// @param tranche Tranche of the base asset\\n    /// @param estimatedNav Estimated net asset value for the base asset\\n    /// @param epoch The epoch's end timestamp\\n    function _settleTaker(\\n        address account,\\n        uint256 tranche,\\n        uint256 estimatedNav,\\n        uint256 epoch\\n    ) internal returns (uint256 baseAmount, uint256 quoteAmount) {\\n        UnsettledTrade storage unsettledTrade = unsettledTrades[account][tranche][epoch];\\n\\n        // Settle buy trade\\n        UnsettledBuyTrade memory takerBuy = unsettledTrade.takerBuy;\\n        if (takerBuy.frozenQuote > 0) {\\n            (uint256 executionQuote, uint256 executionBase) =\\n                _buyTradeResult(takerBuy, estimatedNav);\\n            baseAmount = executionBase;\\n            quoteAmount = takerBuy.frozenQuote.sub(executionQuote);\\n            delete unsettledTrade.takerBuy;\\n        }\\n\\n        // Settle sell trade\\n        UnsettledSellTrade memory takerSell = unsettledTrade.takerSell;\\n        if (takerSell.frozenBase > 0) {\\n            (uint256 executionQuote, uint256 executionBase) =\\n                _sellTradeResult(takerSell, estimatedNav);\\n            quoteAmount = quoteAmount.add(executionQuote);\\n            baseAmount = baseAmount.add(takerSell.frozenBase.sub(executionBase));\\n            delete unsettledTrade.takerSell;\\n        }\\n    }\\n\\n    /// @dev Settle both buy and sell trades of a specified epoch for makers\\n    /// @param account Maker address\\n    /// @param tranche Tranche of the base asset\\n    /// @param estimatedNav Estimated net asset value for the base asset\\n    /// @param epoch The epoch's end timestamp\\n    function _settleMaker(\\n        address account,\\n        uint256 tranche,\\n        uint256 estimatedNav,\\n        uint256 epoch\\n    ) internal returns (uint256 baseAmount, uint256 quoteAmount) {\\n        UnsettledTrade storage unsettledTrade = unsettledTrades[account][tranche][epoch];\\n\\n        // Settle buy trade\\n        UnsettledSellTrade memory makerBuy = unsettledTrade.makerBuy;\\n        if (makerBuy.frozenBase > 0) {\\n            (uint256 executionQuote, uint256 executionBase) =\\n                _sellTradeResult(makerBuy, estimatedNav);\\n            baseAmount = executionBase;\\n            quoteAmount = makerBuy.reservedQuote.sub(executionQuote);\\n            delete unsettledTrade.makerBuy;\\n        }\\n\\n        // Settle sell trade\\n        UnsettledBuyTrade memory makerSell = unsettledTrade.makerSell;\\n        if (makerSell.frozenQuote > 0) {\\n            (uint256 executionQuote, uint256 executionBase) =\\n                _buyTradeResult(makerSell, estimatedNav);\\n            quoteAmount = quoteAmount.add(executionQuote);\\n            baseAmount = baseAmount.add(makerSell.reservedBase.sub(executionBase));\\n            delete unsettledTrade.makerSell;\\n        }\\n    }\\n\\n    /// @dev Calculate the result of an unsettled buy trade with a given NAV\\n    /// @param buyTrade Buy trade result of this particular epoch\\n    /// @param nav Net asset value for the base asset\\n    /// @return executionQuote Real amount of quote asset waiting for settlment\\n    /// @return executionBase Real amount of base asset waiting for settlment\\n    function _buyTradeResult(UnsettledBuyTrade memory buyTrade, uint256 nav)\\n        internal\\n        pure\\n        returns (uint256 executionQuote, uint256 executionBase)\\n    {\\n        uint256 reservedBase = buyTrade.reservedBase;\\n        uint256 reservedQuote = reservedBase.multiplyDecimal(nav);\\n        uint256 effectiveQuote = buyTrade.effectiveQuote;\\n        if (effectiveQuote < reservedQuote) {\\n            // Reserved base is enough to execute the trade.\\n            // nav is always positive here\\n            return (buyTrade.frozenQuote, effectiveQuote.divideDecimal(nav));\\n        } else {\\n            // Reserved base is not enough. The trade is partially executed\\n            // and a fraction of frozenQuote is returned to the taker.\\n            return (buyTrade.frozenQuote.mul(reservedQuote).div(effectiveQuote), reservedBase);\\n        }\\n    }\\n\\n    /// @dev Calculate the result of an unsettled sell trade with a given NAV\\n    /// @param sellTrade Sell trade result of this particular epoch\\n    /// @param nav Net asset value for the base asset\\n    /// @return executionQuote Real amount of quote asset waiting for settlment\\n    /// @return executionBase Real amount of base asset waiting for settlment\\n    function _sellTradeResult(UnsettledSellTrade memory sellTrade, uint256 nav)\\n        internal\\n        pure\\n        returns (uint256 executionQuote, uint256 executionBase)\\n    {\\n        uint256 reservedQuote = sellTrade.reservedQuote;\\n        uint256 effectiveQuote = sellTrade.effectiveBase.multiplyDecimal(nav);\\n        if (effectiveQuote < reservedQuote) {\\n            // Reserved quote is enough to execute the trade.\\n            return (effectiveQuote, sellTrade.frozenBase);\\n        } else {\\n            // Reserved quote is not enough. The trade is partially executed\\n            // and a fraction of frozenBase is returned to the taker.\\n            return (reservedQuote, sellTrade.frozenBase.mul(reservedQuote).div(effectiveQuote));\\n        }\\n    }\\n\\n    /// @dev Transfer quote asset to an account. Transfered amount is rounded down.\\n    /// @param account Recipient address\\n    /// @param amount Amount to transfer with 18 decimal places\\n    function _transferQuote(address account, uint256 amount) private {\\n        uint256 amountToTransfer = amount / _quoteDecimalMultiplier;\\n        if (amountToTransfer == 0) {\\n            return;\\n        }\\n        IERC20(quoteAssetAddress).safeTransfer(account, amountToTransfer);\\n    }\\n\\n    /// @dev Transfer quote asset from an account. Transfered amount is rounded up.\\n    /// @param account Sender address\\n    /// @param amount Amount to transfer with 18 decimal places\\n    function _transferQuoteFrom(address account, uint256 amount) private {\\n        uint256 amountToTransfer =\\n            amount.add(_quoteDecimalMultiplier - 1) / _quoteDecimalMultiplier;\\n        IERC20(quoteAssetAddress).safeTransferFrom(account, address(this), amountToTransfer);\\n    }\\n\\n    modifier onlyActive() {\\n        require(fund.isExchangeActive(block.timestamp), \\\"Exchange is inactive\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/fund/Fund.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\n\\nimport \\\"../../utils/SafeDecimalMath.sol\\\";\\nimport \\\"../../utils/CoreUtility.sol\\\";\\n\\nimport \\\"../interfaces/IPrimaryMarket.sol\\\";\\nimport \\\"../interfaces/IFund.sol\\\";\\nimport \\\"../../interfaces/ITwapOracle.sol\\\";\\nimport \\\"../../interfaces/IAprOracle.sol\\\";\\nimport \\\"../../interfaces/IBallot.sol\\\";\\nimport \\\"../../interfaces/IVotingEscrow.sol\\\";\\nimport \\\"../interfaces/ITrancheIndex.sol\\\";\\n\\nimport \\\"./FundRoles.sol\\\";\\n\\ncontract Fund is IFund, Ownable, ReentrancyGuard, FundRoles, CoreUtility, ITrancheIndex {\\n    using Math for uint256;\\n    using SafeMath for uint256;\\n    using SafeDecimalMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    uint256 private constant UNIT = 1e18;\\n    uint256 private constant MAX_INTEREST_RATE = 0.2e18; // 20% daily\\n    uint256 private constant MAX_DAILY_PROTOCOL_FEE_RATE = 0.05e18; // 5% daily rate\\n\\n    uint256 private constant WEIGHT_A = 1;\\n    uint256 private constant WEIGHT_B = 1;\\n    uint256 private constant WEIGHT_M = WEIGHT_A + WEIGHT_B;\\n\\n    /// @notice Upper bound of `NAV_B / NAV_A` to trigger a rebalance.\\n    uint256 public immutable upperRebalanceThreshold;\\n\\n    /// @notice Lower bound of `NAV_B / NAV_A` to trigger a rebalance.\\n    uint256 public immutable lowerRebalanceThreshold;\\n\\n    /// @notice Address of the underlying token.\\n    address public immutable override tokenUnderlying;\\n\\n    /// @notice A multipler that normalizes an underlying balance to 18 decimal places.\\n    uint256 public immutable override underlyingDecimalMultiplier;\\n\\n    /// @notice Daily protocol fee rate.\\n    uint256 public dailyProtocolFeeRate;\\n\\n    /// @notice TwapOracle address for the underlying asset.\\n    ITwapOracle public override twapOracle;\\n\\n    /// @notice AprOracle address.\\n    IAprOracle public aprOracle;\\n\\n    /// @notice Address of the interest rate ballot.\\n    IBallot public ballot;\\n\\n    /// @notice Fee Collector address.\\n    address public override feeCollector;\\n\\n    /// @notice Address of Token M.\\n    address public override tokenM;\\n\\n    /// @notice Address of Token A.\\n    address public override tokenA;\\n\\n    /// @notice Address of Token B.\\n    address public override tokenB;\\n\\n    /// @notice End timestamp of the current trading day.\\n    ///         A trading day starts at UTC time `SETTLEMENT_TIME` of a day (inclusive)\\n    ///         and ends at the same time of the next day (exclusive).\\n    uint256 public override currentDay;\\n\\n    /// @notice Start timestamp of the current primary market activity window.\\n    uint256 public override fundActivityStartTime;\\n\\n    /// @notice Start timestamp of the current exchange activity window.\\n    uint256 public override exchangeActivityStartTime;\\n\\n    uint256 public activityDelayTimeAfterRebalance;\\n\\n    /// @dev Historical rebalances. Rebalances are often accessed in loops with bounds checking.\\n    ///      So we store them in a fixed-length array, in order to make compiler-generated\\n    ///      bounds checking on every access cheaper. The actual length of this array is stored in\\n    ///      `_rebalanceSize` and should be explicitly checked when necessary.\\n    Rebalance[65535] private _rebalances;\\n\\n    /// @dev Historical rebalance count.\\n    uint256 private _rebalanceSize;\\n\\n    /// @dev Total share supply of the three tranches. They are always rebalanced to the latest\\n    ///      version.\\n    uint256[TRANCHE_COUNT] private _totalSupplies;\\n\\n    /// @dev Mapping of account => share balance of the three tranches.\\n    ///      Rebalance versions are stored in a separate mapping `_balanceVersions`.\\n    mapping(address => uint256[TRANCHE_COUNT]) private _balances;\\n\\n    /// @dev Rebalance version mapping for `_balances`.\\n    mapping(address => uint256) private _balanceVersions;\\n\\n    /// @dev Mapping of owner => spender => share allowance of the three tranches.\\n    ///      Rebalance versions are stored in a separate mapping `_allowanceVersions`.\\n    mapping(address => mapping(address => uint256[TRANCHE_COUNT])) private _allowances;\\n\\n    /// @dev Rebalance version mapping for `_allowances`.\\n    mapping(address => mapping(address => uint256)) private _allowanceVersions;\\n\\n    /// @dev Mapping of trading day => NAV tuple.\\n    mapping(uint256 => uint256[TRANCHE_COUNT]) private _historicalNavs;\\n\\n    /// @notice Mapping of trading day => total fund shares.\\n    ///\\n    ///         Key is the end timestamp of a trading day. Value is the total fund shares after\\n    ///         settlement of that trading day, as if all Token A and B are merged.\\n    mapping(uint256 => uint256) public override historicalTotalShares;\\n\\n    /// @notice Mapping of trading day => underlying assets in the fund.\\n    ///\\n    ///         Key is the end timestamp of a trading day. Value is the underlying assets in\\n    ///         the fund after settlement of that trading day.\\n    mapping(uint256 => uint256) public historicalUnderlying;\\n\\n    /// @notice Mapping of trading week => interest rate of Token A.\\n    ///\\n    ///         Key is the end timestamp of a trading week. Value is the interest rate captured\\n    ///         after settlement of the last day of the previous trading week.\\n    mapping(uint256 => uint256) public historicalInterestRate;\\n\\n    address[] private obsoletePrimaryMarkets;\\n    address[] private newPrimaryMarkets;\\n\\n    constructor(\\n        address tokenUnderlying_,\\n        uint256 underlyingDecimals_,\\n        uint256 dailyProtocolFeeRate_,\\n        uint256 upperRebalanceThreshold_,\\n        uint256 lowerRebalanceThreshold_,\\n        address twapOracle_,\\n        address aprOracle_,\\n        address ballot_,\\n        address feeCollector_\\n    ) public Ownable() FundRoles() {\\n        tokenUnderlying = tokenUnderlying_;\\n        require(underlyingDecimals_ <= 18, \\\"Underlying decimals larger than 18\\\");\\n        underlyingDecimalMultiplier = 10**(18 - underlyingDecimals_);\\n        require(\\n            dailyProtocolFeeRate_ <= MAX_DAILY_PROTOCOL_FEE_RATE,\\n            \\\"Exceed max protocol fee rate\\\"\\n        );\\n        dailyProtocolFeeRate = dailyProtocolFeeRate_;\\n        upperRebalanceThreshold = upperRebalanceThreshold_;\\n        lowerRebalanceThreshold = lowerRebalanceThreshold_;\\n        twapOracle = ITwapOracle(twapOracle_);\\n        aprOracle = IAprOracle(aprOracle_);\\n        ballot = IBallot(ballot_);\\n        feeCollector = feeCollector_;\\n\\n        currentDay = endOfDay(block.timestamp);\\n        uint256 lastDay = currentDay - 1 days;\\n        uint256 currentPrice = twapOracle.getTwap(lastDay);\\n        require(currentPrice != 0, \\\"Price not available\\\");\\n        _historicalNavs[lastDay][TRANCHE_M] = UNIT;\\n        _historicalNavs[lastDay][TRANCHE_A] = UNIT;\\n        _historicalNavs[lastDay][TRANCHE_B] = UNIT;\\n        historicalInterestRate[_endOfWeek(lastDay)] = MAX_INTEREST_RATE.min(aprOracle.capture());\\n        fundActivityStartTime = lastDay;\\n        exchangeActivityStartTime = lastDay + 30 minutes;\\n        activityDelayTimeAfterRebalance = 12 hours;\\n    }\\n\\n    function initialize(\\n        address tokenM_,\\n        address tokenA_,\\n        address tokenB_,\\n        address primaryMarket_\\n    ) external onlyOwner {\\n        require(tokenM == address(0) && tokenM_ != address(0), \\\"Already initialized\\\");\\n        tokenM = tokenM_;\\n        tokenA = tokenA_;\\n        tokenB = tokenB_;\\n        _initializeRoles(tokenM_, tokenA_, tokenB_, primaryMarket_);\\n    }\\n\\n    /// @notice Return weights of Token A and B when splitting Token M.\\n    /// @return weightA Weight of Token A\\n    /// @return weightB Weight of Token B\\n    function trancheWeights() external pure override returns (uint256 weightA, uint256 weightB) {\\n        return (WEIGHT_A, WEIGHT_B);\\n    }\\n\\n    /// @notice UTC time of a day when the fund settles.\\n    function settlementTime() external pure returns (uint256) {\\n        return SETTLEMENT_TIME;\\n    }\\n\\n    /// @notice Return end timestamp of the trading day containing a given timestamp.\\n    ///\\n    ///         A trading day starts at UTC time `SETTLEMENT_TIME` of a day (inclusive)\\n    ///         and ends at the same time of the next day (exclusive).\\n    /// @param timestamp The given timestamp\\n    /// @return End timestamp of the trading day.\\n    function endOfDay(uint256 timestamp) public pure override returns (uint256) {\\n        return ((timestamp.add(1 days) - SETTLEMENT_TIME) / 1 days) * 1 days + SETTLEMENT_TIME;\\n    }\\n\\n    /// @notice Return end timestamp of the trading week containing a given timestamp.\\n    ///\\n    ///         A trading week starts at UTC time `SETTLEMENT_TIME` on a Thursday (inclusive)\\n    ///         and ends at the same time of the next Thursday (exclusive).\\n    /// @param timestamp The given timestamp\\n    /// @return End timestamp of the trading week.\\n    function endOfWeek(uint256 timestamp) external pure returns (uint256) {\\n        return _endOfWeek(timestamp);\\n    }\\n\\n    /// @notice Return the status of the fund contract.\\n    /// @param timestamp Timestamp to assess\\n    /// @return True if the fund contract is active\\n    function isFundActive(uint256 timestamp) public view override returns (bool) {\\n        return timestamp >= fundActivityStartTime;\\n    }\\n\\n    /// @notice Return the status of a given primary market contract.\\n    /// @param primaryMarket The primary market contract address\\n    /// @param timestamp Timestamp to assess\\n    /// @return True if the primary market contract is active\\n    function isPrimaryMarketActive(address primaryMarket, uint256 timestamp)\\n        public\\n        view\\n        override\\n        returns (bool)\\n    {\\n        return\\n            isPrimaryMarket(primaryMarket) &&\\n            timestamp >= fundActivityStartTime &&\\n            timestamp < currentDay;\\n    }\\n\\n    /// @notice Return the status of the exchange. Unlike the primary market, exchange is\\n    ///         anonymous to fund\\n    /// @param timestamp Timestamp to assess\\n    /// @return True if the exchange contract is active\\n    function isExchangeActive(uint256 timestamp) public view override returns (bool) {\\n        return (timestamp >= exchangeActivityStartTime && timestamp < (currentDay - 60 minutes));\\n    }\\n\\n    /// @notice Total shares of the fund, as if all Token A and B are merged.\\n    function getTotalShares() public view override returns (uint256) {\\n        return\\n            _totalSupplies[TRANCHE_M].add(_totalSupplies[TRANCHE_A]).add(_totalSupplies[TRANCHE_B]);\\n    }\\n\\n    /// @notice Return the rebalance matrix at a given index. A zero struct is returned\\n    ///         if `index` is out of bound.\\n    /// @param index Rebalance index\\n    /// @return A rebalance matrix\\n    function getRebalance(uint256 index) external view override returns (Rebalance memory) {\\n        return _rebalances[index];\\n    }\\n\\n    /// @notice Return timestamp of the transaction triggering the rebalance at a given index.\\n    ///         Zero is returned if `index` is out of bound.\\n    /// @param index Rebalance index\\n    /// @return Timestamp of the rebalance\\n    function getRebalanceTimestamp(uint256 index) external view override returns (uint256) {\\n        return _rebalances[index].timestamp;\\n    }\\n\\n    /// @notice Return the number of historical rebalances.\\n    function getRebalanceSize() external view override returns (uint256) {\\n        return _rebalanceSize;\\n    }\\n\\n    /// @notice Return NAV of Token M, A and B of the given trading day.\\n    /// @param day End timestamp of a trading day\\n    /// @return NAV of Token M, A and B\\n    function historicalNavs(uint256 day)\\n        external\\n        view\\n        override\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        return (\\n            _historicalNavs[day][TRANCHE_M],\\n            _historicalNavs[day][TRANCHE_A],\\n            _historicalNavs[day][TRANCHE_B]\\n        );\\n    }\\n\\n    /// @notice Estimate NAV of all tranches at a given timestamp, considering underlying price\\n    ///         change, accrued protocol fee and accrued interest since the previous settlement.\\n    ///\\n    ///         The extrapolation uses simple interest instead of daily compound interest in\\n    ///         calculating protocol fee and Token A's interest. There may be significant error\\n    ///         in the returned values when `timestamp` is far beyond the last settlement.\\n    /// @param timestamp Timestamp to estimate\\n    /// @param price Price of the underlying asset (18 decimal places)\\n    /// @return Estimated NAV of all tranches\\n    function extrapolateNav(uint256 timestamp, uint256 price)\\n        external\\n        view\\n        override\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        // Find the last settled trading day before the given timestamp.\\n        uint256 previousDay = currentDay - 1 days;\\n        if (previousDay > timestamp) {\\n            previousDay = endOfDay(timestamp) - 1 days;\\n        }\\n        uint256 previousShares = historicalTotalShares[previousDay];\\n        uint256 navM = _extrapolateNavM(previousDay, previousShares, timestamp, price);\\n        uint256 navA = _extrapolateNavA(previousDay, previousShares, timestamp);\\n        uint256 navB = calculateNavB(navM, navA);\\n        return (navM, navA, navB);\\n    }\\n\\n    function _extrapolateNavM(\\n        uint256 previousDay,\\n        uint256 previousShares,\\n        uint256 timestamp,\\n        uint256 price\\n    ) private view returns (uint256) {\\n        uint256 navM;\\n        if (previousShares == 0) {\\n            // The fund is empty. Just return the previous recorded NAV.\\n            navM = _historicalNavs[previousDay][TRANCHE_M];\\n            if (navM == 0) {\\n                // No NAV is recorded because the given timestamp is before the fund launches.\\n                return UNIT;\\n            } else {\\n                return navM;\\n            }\\n        }\\n        uint256 totalValue =\\n            price.mul(historicalUnderlying[previousDay].mul(underlyingDecimalMultiplier));\\n        uint256 accruedFee =\\n            totalValue.multiplyDecimal(dailyProtocolFeeRate).mul(timestamp - previousDay).div(\\n                1 days\\n            );\\n        navM = (totalValue - accruedFee).div(previousShares);\\n        return navM;\\n    }\\n\\n    function _extrapolateNavA(\\n        uint256 previousDay,\\n        uint256 previousShares,\\n        uint256 timestamp\\n    ) private view returns (uint256) {\\n        uint256 navA = _historicalNavs[previousDay][TRANCHE_A];\\n        if (previousShares == 0) {\\n            // The fund is empty. Just return the previous recorded NAV.\\n            if (navA == 0) {\\n                // No NAV is recorded because the given timestamp is before the fund launches.\\n                return UNIT;\\n            } else {\\n                return navA;\\n            }\\n        }\\n\\n        uint256 week = _endOfWeek(previousDay);\\n        uint256 newNavA =\\n            navA\\n                .multiplyDecimal(\\n                UNIT.sub(dailyProtocolFeeRate.mul(timestamp - previousDay).div(1 days))\\n            )\\n                .multiplyDecimal(\\n                UNIT.add(historicalInterestRate[week].mul(timestamp - previousDay).div(1 days))\\n            );\\n        return newNavA > navA ? newNavA : navA;\\n    }\\n\\n    function calculateNavB(uint256 navM, uint256 navA) public pure override returns (uint256) {\\n        // Using unchecked multiplications because they are unlikely to overflow\\n        if (navM * WEIGHT_M >= navA * WEIGHT_A) {\\n            return (navM * WEIGHT_M - navA * WEIGHT_A) / WEIGHT_B;\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    /// @notice Transform share amounts according to the rebalance at a given index.\\n    ///         This function performs no bounds checking on the given index. A non-existent\\n    ///         rebalance transforms anything to a zero vector.\\n    /// @param amountM Amount of Token M before the rebalance\\n    /// @param amountA Amount of Token A before the rebalance\\n    /// @param amountB Amount of Token B before the rebalance\\n    /// @param index Rebalance index\\n    /// @return newAmountM Amount of Token M after the rebalance\\n    /// @return newAmountA Amount of Token A after the rebalance\\n    /// @return newAmountB Amount of Token B after the rebalance\\n    function doRebalance(\\n        uint256 amountM,\\n        uint256 amountA,\\n        uint256 amountB,\\n        uint256 index\\n    )\\n        public\\n        view\\n        override\\n        returns (\\n            uint256 newAmountM,\\n            uint256 newAmountA,\\n            uint256 newAmountB\\n        )\\n    {\\n        Rebalance storage rebalance = _rebalances[index];\\n        newAmountM = amountM\\n            .multiplyDecimal(rebalance.ratioM)\\n            .add(amountA.multiplyDecimal(rebalance.ratioA2M))\\n            .add(amountB.multiplyDecimal(rebalance.ratioB2M));\\n        uint256 ratioAB = rebalance.ratioAB; // Gas saver\\n        newAmountA = amountA.multiplyDecimal(ratioAB);\\n        newAmountB = amountB.multiplyDecimal(ratioAB);\\n    }\\n\\n    /// @notice Transform share amounts according to rebalances in a given index range,\\n    ///         This function performs no bounds checking on the given indices. The original amounts\\n    ///         are returned if `fromIndex` is no less than `toIndex`. A zero vector is returned\\n    ///         if `toIndex` is greater than the number of existing rebalances.\\n    /// @param amountM Amount of Token M before the rebalance\\n    /// @param amountA Amount of Token A before the rebalance\\n    /// @param amountB Amount of Token B before the rebalance\\n    /// @param fromIndex Starting of the rebalance index range, inclusive\\n    /// @param toIndex End of the rebalance index range, exclusive\\n    /// @return newAmountM Amount of Token M after the rebalance\\n    /// @return newAmountA Amount of Token A after the rebalance\\n    /// @return newAmountB Amount of Token B after the rebalance\\n    function batchRebalance(\\n        uint256 amountM,\\n        uint256 amountA,\\n        uint256 amountB,\\n        uint256 fromIndex,\\n        uint256 toIndex\\n    )\\n        external\\n        view\\n        override\\n        returns (\\n            uint256 newAmountM,\\n            uint256 newAmountA,\\n            uint256 newAmountB\\n        )\\n    {\\n        for (uint256 i = fromIndex; i < toIndex; i++) {\\n            (amountM, amountA, amountB) = doRebalance(amountM, amountA, amountB, i);\\n        }\\n        newAmountM = amountM;\\n        newAmountA = amountA;\\n        newAmountB = amountB;\\n    }\\n\\n    /// @notice Transform share balance to a given rebalance version, or to the latest version\\n    ///         if `targetVersion` is zero.\\n    /// @param account Account of the balance to rebalance\\n    /// @param targetVersion The target rebalance version, or zero for the latest version\\n    function refreshBalance(address account, uint256 targetVersion) external override {\\n        if (targetVersion > 0) {\\n            require(targetVersion <= _rebalanceSize, \\\"Target version out of bound\\\");\\n        }\\n        _refreshBalance(account, targetVersion);\\n    }\\n\\n    /// @notice Transform allowance to a given rebalance version, or to the latest version\\n    ///         if `targetVersion` is zero.\\n    /// @param owner Owner of the allowance to rebalance\\n    /// @param spender Spender of the allowance to rebalance\\n    /// @param targetVersion The target rebalance version, or zero for the latest version\\n    function refreshAllowance(\\n        address owner,\\n        address spender,\\n        uint256 targetVersion\\n    ) external override {\\n        if (targetVersion > 0) {\\n            require(targetVersion <= _rebalanceSize, \\\"Target version out of bound\\\");\\n        }\\n        _refreshAllowance(owner, spender, targetVersion);\\n    }\\n\\n    function shareBalanceOf(uint256 tranche, address account)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        uint256 amountM = _balances[account][TRANCHE_M];\\n        uint256 amountA = _balances[account][TRANCHE_A];\\n        uint256 amountB = _balances[account][TRANCHE_B];\\n\\n        if (tranche == TRANCHE_M) {\\n            if (amountM == 0 && amountA == 0 && amountB == 0) return 0;\\n        } else if (tranche == TRANCHE_A) {\\n            if (amountA == 0) return 0;\\n        } else {\\n            if (amountB == 0) return 0;\\n        }\\n\\n        uint256 size = _rebalanceSize; // Gas saver\\n        for (uint256 i = _balanceVersions[account]; i < size; i++) {\\n            (amountM, amountA, amountB) = doRebalance(amountM, amountA, amountB, i);\\n        }\\n\\n        if (tranche == TRANCHE_M) {\\n            return amountM;\\n        } else if (tranche == TRANCHE_A) {\\n            return amountA;\\n        } else {\\n            return amountB;\\n        }\\n    }\\n\\n    /// @notice Return all three share balances transformed to the latest rebalance version.\\n    /// @param account Owner of the shares\\n    function allShareBalanceOf(address account)\\n        external\\n        view\\n        override\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256 amountM = _balances[account][TRANCHE_M];\\n        uint256 amountA = _balances[account][TRANCHE_A];\\n        uint256 amountB = _balances[account][TRANCHE_B];\\n\\n        uint256 size = _rebalanceSize; // Gas saver\\n        for (uint256 i = _balanceVersions[account]; i < size; i++) {\\n            (amountM, amountA, amountB) = doRebalance(amountM, amountA, amountB, i);\\n        }\\n\\n        return (amountM, amountA, amountB);\\n    }\\n\\n    function shareBalanceVersion(address account) external view override returns (uint256) {\\n        return _balanceVersions[account];\\n    }\\n\\n    function shareAllowance(\\n        uint256 tranche,\\n        address owner,\\n        address spender\\n    ) external view override returns (uint256) {\\n        uint256 allowanceM = _allowances[owner][spender][TRANCHE_M];\\n        uint256 allowanceA = _allowances[owner][spender][TRANCHE_A];\\n        uint256 allowanceB = _allowances[owner][spender][TRANCHE_B];\\n\\n        if (tranche == TRANCHE_M) {\\n            if (allowanceM == 0) return 0;\\n        } else if (tranche == TRANCHE_A) {\\n            if (allowanceA == 0) return 0;\\n        } else {\\n            if (allowanceB == 0) return 0;\\n        }\\n\\n        uint256 size = _rebalanceSize; // Gas saver\\n        for (uint256 i = _allowanceVersions[owner][spender]; i < size; i++) {\\n            (allowanceM, allowanceA, allowanceB) = _rebalanceAllowance(\\n                allowanceM,\\n                allowanceA,\\n                allowanceB,\\n                i\\n            );\\n        }\\n\\n        if (tranche == TRANCHE_M) {\\n            return allowanceM;\\n        } else if (tranche == TRANCHE_A) {\\n            return allowanceA;\\n        } else {\\n            return allowanceB;\\n        }\\n    }\\n\\n    function shareAllowanceVersion(address owner, address spender)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _allowanceVersions[owner][spender];\\n    }\\n\\n    function shareTotalSupply(uint256 tranche) external view override returns (uint256) {\\n        return _totalSupplies[tranche];\\n    }\\n\\n    function mint(\\n        uint256 tranche,\\n        address account,\\n        uint256 amount\\n    ) external override onlyPrimaryMarket {\\n        _refreshBalance(account, _rebalanceSize);\\n        _mint(tranche, account, amount);\\n    }\\n\\n    function burn(\\n        uint256 tranche,\\n        address account,\\n        uint256 amount\\n    ) external override onlyPrimaryMarket {\\n        _refreshBalance(account, _rebalanceSize);\\n        _burn(tranche, account, amount);\\n    }\\n\\n    function transfer(\\n        uint256 tranche,\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public override onlyShare {\\n        require(isFundActive(block.timestamp), \\\"Transfer is inactive\\\");\\n        _refreshBalance(sender, _rebalanceSize);\\n        _refreshBalance(recipient, _rebalanceSize);\\n        _transfer(tranche, sender, recipient, amount);\\n    }\\n\\n    function transferFrom(\\n        uint256 tranche,\\n        address spender,\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external override onlyShare returns (uint256 newAllowance) {\\n        transfer(tranche, sender, recipient, amount);\\n\\n        _refreshAllowance(sender, spender, _rebalanceSize);\\n        newAllowance = _allowances[sender][spender][tranche].sub(\\n            amount,\\n            \\\"ERC20: transfer amount exceeds allowance\\\"\\n        );\\n        _approve(tranche, sender, spender, newAllowance);\\n    }\\n\\n    function approve(\\n        uint256 tranche,\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) external override onlyShare {\\n        _refreshAllowance(owner, spender, _rebalanceSize);\\n        _approve(tranche, owner, spender, amount);\\n    }\\n\\n    function increaseAllowance(\\n        uint256 tranche,\\n        address sender,\\n        address spender,\\n        uint256 addedValue\\n    ) external override onlyShare returns (uint256 newAllowance) {\\n        _refreshAllowance(sender, spender, _rebalanceSize);\\n        newAllowance = _allowances[sender][spender][tranche].add(addedValue);\\n        _approve(tranche, sender, spender, newAllowance);\\n    }\\n\\n    function decreaseAllowance(\\n        uint256 tranche,\\n        address sender,\\n        address spender,\\n        uint256 subtractedValue\\n    ) external override onlyShare returns (uint256 newAllowance) {\\n        _refreshAllowance(sender, spender, _rebalanceSize);\\n        newAllowance = _allowances[sender][spender][tranche].sub(subtractedValue);\\n        _approve(tranche, sender, spender, newAllowance);\\n    }\\n\\n    function _transfer(\\n        uint256 tranche,\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) private {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _balances[sender][tranche] = _balances[sender][tranche].sub(\\n            amount,\\n            \\\"ERC20: transfer amount exceeds balance\\\"\\n        );\\n        _balances[recipient][tranche] = _balances[recipient][tranche].add(amount);\\n\\n        emit Transfer(tranche, sender, recipient, amount);\\n    }\\n\\n    function _mint(\\n        uint256 tranche,\\n        address account,\\n        uint256 amount\\n    ) private {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _totalSupplies[tranche] = _totalSupplies[tranche].add(amount);\\n        _balances[account][tranche] = _balances[account][tranche].add(amount);\\n\\n        emit Transfer(tranche, address(0), account, amount);\\n    }\\n\\n    function _burn(\\n        uint256 tranche,\\n        address account,\\n        uint256 amount\\n    ) private {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _balances[account][tranche] = _balances[account][tranche].sub(\\n            amount,\\n            \\\"ERC20: burn amount exceeds balance\\\"\\n        );\\n        _totalSupplies[tranche] = _totalSupplies[tranche].sub(amount);\\n\\n        emit Transfer(tranche, account, address(0), amount);\\n    }\\n\\n    function _approve(\\n        uint256 tranche,\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) private {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender][tranche] = amount;\\n\\n        emit Approval(tranche, owner, spender, amount);\\n    }\\n\\n    /// @notice Settle the current trading day. Settlement includes the following changes\\n    ///         to the fund.\\n    ///\\n    ///         1. Transfer protocol fee of the day to the fee collector.\\n    ///         2. Settle all pending creations and redemptions from all primary markets.\\n    ///         3. Calculate NAV of the day and trigger rebalance if necessary.\\n    ///         4. Capture new interest rate for Token A.\\n    function settle() external nonReentrant {\\n        uint256 day = currentDay;\\n        uint256 currentWeek = _endOfWeek(day - 1 days);\\n        require(block.timestamp >= day, \\\"The current trading day does not end yet\\\");\\n        uint256 price = twapOracle.getTwap(day);\\n        require(price != 0, \\\"Underlying price for settlement is not ready yet\\\");\\n\\n        _collectFee();\\n\\n        _settlePrimaryMarkets(day, price);\\n\\n        // Calculate NAV\\n        uint256 totalShares = getTotalShares();\\n        uint256 underlying = IERC20(tokenUnderlying).balanceOf(address(this));\\n        uint256 navA = _historicalNavs[day - 1 days][TRANCHE_A];\\n        uint256 navM;\\n        if (totalShares > 0) {\\n            navM = price.mul(underlying.mul(underlyingDecimalMultiplier)).div(totalShares);\\n            if (historicalTotalShares[day - 1 days] > 0) {\\n                // Update NAV of Token A only when the fund is non-empty both before and after\\n                // this settlement\\n                uint256 newNavA =\\n                    navA.multiplyDecimal(UNIT.sub(dailyProtocolFeeRate)).multiplyDecimal(\\n                        historicalInterestRate[currentWeek].add(UNIT)\\n                    );\\n                if (navA < newNavA) {\\n                    navA = newNavA;\\n                }\\n            }\\n        } else {\\n            // If the fund is empty, use NAV of Token M in the last day\\n            navM = _historicalNavs[day - 1 days][TRANCHE_M];\\n        }\\n        uint256 navB = calculateNavB(navM, navA);\\n\\n        if (_shouldTriggerRebalance(navA, navB)) {\\n            _triggerRebalance(day, navM, navA, navB);\\n            navM = UNIT;\\n            navA = UNIT;\\n            navB = UNIT;\\n            totalShares = getTotalShares();\\n            fundActivityStartTime = day + activityDelayTimeAfterRebalance;\\n            exchangeActivityStartTime = day + activityDelayTimeAfterRebalance;\\n        } else {\\n            fundActivityStartTime = day;\\n            exchangeActivityStartTime = day + 30 minutes;\\n        }\\n\\n        if (currentDay == currentWeek) {\\n            historicalInterestRate[currentWeek + 1 weeks] = _updateInterestRate(currentWeek);\\n        }\\n\\n        historicalTotalShares[day] = totalShares;\\n        historicalUnderlying[day] = underlying;\\n        _historicalNavs[day][TRANCHE_M] = navM;\\n        _historicalNavs[day][TRANCHE_A] = navA;\\n        _historicalNavs[day][TRANCHE_B] = navB;\\n        currentDay = day + 1 days;\\n\\n        if (obsoletePrimaryMarkets.length > 0) {\\n            for (uint256 i = 0; i < obsoletePrimaryMarkets.length; i++) {\\n                _removePrimaryMarket(obsoletePrimaryMarkets[i]);\\n            }\\n            delete obsoletePrimaryMarkets;\\n        }\\n\\n        if (newPrimaryMarkets.length > 0) {\\n            for (uint256 i = 0; i < newPrimaryMarkets.length; i++) {\\n                _addPrimaryMarket(newPrimaryMarkets[i]);\\n            }\\n            delete newPrimaryMarkets;\\n        }\\n\\n        emit Settled(day, navM, navA, navB);\\n    }\\n\\n    function addObsoletePrimaryMarket(address obsoletePrimaryMarket) external onlyOwner {\\n        require(isPrimaryMarket(obsoletePrimaryMarket), \\\"The address is not a primary market\\\");\\n        obsoletePrimaryMarkets.push(obsoletePrimaryMarket);\\n    }\\n\\n    function addNewPrimaryMarket(address newPrimaryMarket) external onlyOwner {\\n        require(!isPrimaryMarket(newPrimaryMarket), \\\"The address is already a primary market\\\");\\n        newPrimaryMarkets.push(newPrimaryMarket);\\n    }\\n\\n    function updateDailyProtocolFeeRate(uint256 newDailyProtocolFeeRate) external onlyOwner {\\n        require(\\n            newDailyProtocolFeeRate <= MAX_DAILY_PROTOCOL_FEE_RATE,\\n            \\\"Exceed max protocol fee rate\\\"\\n        );\\n        dailyProtocolFeeRate = newDailyProtocolFeeRate;\\n    }\\n\\n    function updateTwapOracle(address newTwapOracle) external onlyOwner {\\n        twapOracle = ITwapOracle(newTwapOracle);\\n    }\\n\\n    function updateAprOracle(address newAprOracle) external onlyOwner {\\n        aprOracle = IAprOracle(newAprOracle);\\n    }\\n\\n    function updateBallot(address newBallot) external onlyOwner {\\n        ballot = IBallot(newBallot);\\n    }\\n\\n    function updateFeeCollector(address newFeeCollector) external onlyOwner {\\n        feeCollector = newFeeCollector;\\n    }\\n\\n    function updateActivityDelayTime(uint256 delayTime) external onlyOwner {\\n        require(\\n            delayTime >= 30 minutes && delayTime <= 12 hours,\\n            \\\"Exceed allowed delay time range\\\"\\n        );\\n        activityDelayTimeAfterRebalance = delayTime;\\n    }\\n\\n    /// @dev Transfer protocol fee of the current trading day to the fee collector.\\n    ///      This function should be called before creation and redemption on the same day\\n    ///      are settled.\\n    function _collectFee() private {\\n        uint256 currentUnderlying = IERC20(tokenUnderlying).balanceOf(address(this));\\n        uint256 fee = currentUnderlying.multiplyDecimal(dailyProtocolFeeRate);\\n        if (fee > 0) {\\n            IERC20(tokenUnderlying).safeTransfer(address(feeCollector), fee);\\n        }\\n    }\\n\\n    /// @dev Settle primary market operations in every PrimaryMarket contract.\\n    function _settlePrimaryMarkets(uint256 day, uint256 price) private {\\n        uint256 totalShares = getTotalShares();\\n        uint256 underlying = IERC20(tokenUnderlying).balanceOf(address(this));\\n        uint256 prevNavM = _historicalNavs[day - 1 days][TRANCHE_M];\\n        uint256 primaryMarketCount = getPrimaryMarketCount();\\n        for (uint256 i = 0; i < primaryMarketCount; i++) {\\n            uint256 price_ = price; // Fix the \\\"stack too deep\\\" error\\n            IPrimaryMarket pm = IPrimaryMarket(getPrimaryMarketMember(i));\\n            (\\n                uint256 sharesToMint,\\n                uint256 sharesToBurn,\\n                uint256 creationUnderlying,\\n                uint256 redemptionUnderlying,\\n                uint256 fee\\n            ) = pm.settle(day, totalShares, underlying, price_, prevNavM);\\n            if (sharesToMint > sharesToBurn) {\\n                _mint(TRANCHE_M, address(pm), sharesToMint - sharesToBurn);\\n            } else if (sharesToBurn > sharesToMint) {\\n                _burn(TRANCHE_M, address(pm), sharesToBurn - sharesToMint);\\n            }\\n            if (creationUnderlying > redemptionUnderlying) {\\n                IERC20(tokenUnderlying).safeTransferFrom(\\n                    address(pm),\\n                    address(this),\\n                    creationUnderlying - redemptionUnderlying\\n                );\\n            } else if (redemptionUnderlying > creationUnderlying) {\\n                IERC20(tokenUnderlying).safeTransfer(\\n                    address(pm),\\n                    redemptionUnderlying - creationUnderlying\\n                );\\n            }\\n            if (fee > 0) {\\n                IERC20(tokenUnderlying).safeTransfer(address(feeCollector), fee);\\n            }\\n        }\\n    }\\n\\n    /// @dev Check whether a new rebalance should be triggered. Rebalance is triggered if\\n    ///      NAV of Token B over NAV of Token A is greater than the upper threshold or\\n    ///      less than the lower threshold.\\n    /// @param navA NAV of Token A before the rebalance\\n    /// @param navBOrZero NAV of Token B before the rebalance or zero if the NAV is negative\\n    /// @return Whether a new rebalance should be triggered\\n    function _shouldTriggerRebalance(uint256 navA, uint256 navBOrZero) private view returns (bool) {\\n        uint256 bOverA = navBOrZero.divideDecimal(navA);\\n        return bOverA < lowerRebalanceThreshold || bOverA > upperRebalanceThreshold;\\n    }\\n\\n    /// @dev Create a new rebalance that resets NAV of all tranches to 1. Total supplies are\\n    ///      rebalanced immediately.\\n    /// @param day Trading day that triggers this rebalance\\n    /// @param navM NAV of Token M before this rebalance\\n    /// @param navA NAV of Token A before this rebalance\\n    /// @param navBOrZero NAV of Token B before this rebalance or zero if the NAV is negative\\n    function _triggerRebalance(\\n        uint256 day,\\n        uint256 navM,\\n        uint256 navA,\\n        uint256 navBOrZero\\n    ) private {\\n        Rebalance memory rebalance = _calculateRebalance(navM, navA, navBOrZero);\\n        uint256 oldSize = _rebalanceSize;\\n        _rebalances[oldSize] = rebalance;\\n        _rebalanceSize = oldSize + 1;\\n        emit RebalanceTriggered(\\n            oldSize,\\n            day,\\n            rebalance.ratioM,\\n            rebalance.ratioA2M,\\n            rebalance.ratioB2M,\\n            rebalance.ratioAB\\n        );\\n\\n        (\\n            _totalSupplies[TRANCHE_M],\\n            _totalSupplies[TRANCHE_A],\\n            _totalSupplies[TRANCHE_B]\\n        ) = doRebalance(\\n            _totalSupplies[TRANCHE_M],\\n            _totalSupplies[TRANCHE_A],\\n            _totalSupplies[TRANCHE_B],\\n            oldSize\\n        );\\n        _refreshBalance(address(this), oldSize + 1);\\n    }\\n\\n    /// @dev Create a new rebalance matrix that resets given NAVs to (1, 1, 1).\\n    ///\\n    ///      Note that NAV of Token B can be negative before the rebalance when the underlying price\\n    ///      drops dramatically in a single trading day, in which case zero should be passed to\\n    ///      this function instead of the negative NAV.\\n    /// @param navM NAV of Token M before the rebalance\\n    /// @param navA NAV of Token A before the rebalance\\n    /// @param navBOrZero NAV of Token B before the rebalance or zero if the NAV is negative\\n    /// @return The rebalance matrix\\n    function _calculateRebalance(\\n        uint256 navM,\\n        uint256 navA,\\n        uint256 navBOrZero\\n    ) private view returns (Rebalance memory) {\\n        uint256 ratioAB;\\n        uint256 ratioA2M;\\n        uint256 ratioB2M;\\n        if (navBOrZero <= navA) {\\n            // Lower rebalance\\n            ratioAB = navBOrZero;\\n            ratioA2M = ((navM - navBOrZero) * WEIGHT_M) / WEIGHT_A;\\n            ratioB2M = 0;\\n        } else {\\n            // Upper rebalance\\n            ratioAB = UNIT;\\n            ratioA2M = navA - UNIT;\\n            ratioB2M = navBOrZero - UNIT;\\n        }\\n        return\\n            Rebalance({\\n                ratioM: navM,\\n                ratioA2M: ratioA2M,\\n                ratioB2M: ratioB2M,\\n                ratioAB: ratioAB,\\n                timestamp: block.timestamp\\n            });\\n    }\\n\\n    function _updateInterestRate(uint256 week) private returns (uint256) {\\n        uint256 baseInterestRate = MAX_INTEREST_RATE.min(aprOracle.capture());\\n        uint256 floatingInterestRate = ballot.count(week).div(365);\\n        uint256 rate = baseInterestRate.add(floatingInterestRate);\\n\\n        emit InterestRateUpdated(baseInterestRate, floatingInterestRate);\\n\\n        return rate;\\n    }\\n\\n    /// @dev Transform share balance to a given rebalance version, or to the latest version\\n    ///      if `targetVersion` is zero. This function does no bound check on `targetVersion`.\\n    /// @param account Account of the balance to rebalance\\n    /// @param targetVersion The target rebalance version, or zero for the latest version\\n    function _refreshBalance(address account, uint256 targetVersion) private {\\n        if (targetVersion == 0) {\\n            targetVersion = _rebalanceSize;\\n        }\\n        uint256 oldVersion = _balanceVersions[account];\\n        if (oldVersion >= targetVersion) {\\n            return;\\n        }\\n\\n        uint256[TRANCHE_COUNT] storage balanceTuple = _balances[account];\\n        uint256 balanceM = balanceTuple[TRANCHE_M];\\n        uint256 balanceA = balanceTuple[TRANCHE_A];\\n        uint256 balanceB = balanceTuple[TRANCHE_B];\\n        _balanceVersions[account] = targetVersion;\\n\\n        if (balanceM == 0 && balanceA == 0 && balanceB == 0) {\\n            // Fast path for an empty account\\n            return;\\n        }\\n\\n        for (uint256 i = oldVersion; i < targetVersion; i++) {\\n            (balanceM, balanceA, balanceB) = doRebalance(balanceM, balanceA, balanceB, i);\\n        }\\n        balanceTuple[TRANCHE_M] = balanceM;\\n        balanceTuple[TRANCHE_A] = balanceA;\\n        balanceTuple[TRANCHE_B] = balanceB;\\n\\n        emit BalancesRebalanced(account, targetVersion, balanceM, balanceA, balanceB);\\n    }\\n\\n    /// @dev Transform allowance to a given rebalance version, or to the latest version\\n    ///      if `targetVersion` is zero. This function does no bound check on `targetVersion`.\\n    /// @param owner Owner of the allowance to rebalance\\n    /// @param spender Spender of the allowance to rebalance\\n    /// @param targetVersion The target rebalance version, or zero for the latest version\\n    function _refreshAllowance(\\n        address owner,\\n        address spender,\\n        uint256 targetVersion\\n    ) private {\\n        if (targetVersion == 0) {\\n            targetVersion = _rebalanceSize;\\n        }\\n        uint256 oldVersion = _allowanceVersions[owner][spender];\\n        if (oldVersion >= targetVersion) {\\n            return;\\n        }\\n\\n        uint256[TRANCHE_COUNT] storage allowanceTuple = _allowances[owner][spender];\\n        uint256 allowanceM = allowanceTuple[TRANCHE_M];\\n        uint256 allowanceA = allowanceTuple[TRANCHE_A];\\n        uint256 allowanceB = allowanceTuple[TRANCHE_B];\\n        _allowanceVersions[owner][spender] = targetVersion;\\n\\n        if (allowanceM == 0 && allowanceA == 0 && allowanceB == 0) {\\n            // Fast path for an empty allowance\\n            return;\\n        }\\n\\n        for (uint256 i = oldVersion; i < targetVersion; i++) {\\n            (allowanceM, allowanceA, allowanceB) = _rebalanceAllowance(\\n                allowanceM,\\n                allowanceA,\\n                allowanceB,\\n                i\\n            );\\n        }\\n        allowanceTuple[TRANCHE_M] = allowanceM;\\n        allowanceTuple[TRANCHE_A] = allowanceA;\\n        allowanceTuple[TRANCHE_B] = allowanceB;\\n\\n        emit AllowancesRebalanced(\\n            owner,\\n            spender,\\n            targetVersion,\\n            allowanceM,\\n            allowanceA,\\n            allowanceB\\n        );\\n    }\\n\\n    function _rebalanceAllowance(\\n        uint256 allowanceM,\\n        uint256 allowanceA,\\n        uint256 allowanceB,\\n        uint256 index\\n    )\\n        private\\n        view\\n        returns (\\n            uint256 newAllowanceM,\\n            uint256 newAllowanceA,\\n            uint256 newAllowanceB\\n        )\\n    {\\n        Rebalance storage rebalance = _rebalances[index];\\n\\n        /// @dev using saturating arithmetic to avoid unconscious overflow revert\\n        newAllowanceM = allowanceM.saturatingMultiplyDecimal(rebalance.ratioM);\\n        newAllowanceA = allowanceA.saturatingMultiplyDecimal(rebalance.ratioAB);\\n        newAllowanceB = allowanceB.saturatingMultiplyDecimal(rebalance.ratioAB);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/fund/FundV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\n\\nimport \\\"../../utils/SafeDecimalMath.sol\\\";\\nimport \\\"../../utils/CoreUtility.sol\\\";\\n\\nimport \\\"../interfaces/IPrimaryMarketV2.sol\\\";\\nimport \\\"../interfaces/IFundV2.sol\\\";\\nimport \\\"../../interfaces/ITwapOracle.sol\\\";\\nimport \\\"../../interfaces/IAprOracle.sol\\\";\\nimport \\\"../../interfaces/IBallot.sol\\\";\\nimport \\\"../../interfaces/IVotingEscrow.sol\\\";\\nimport \\\"../interfaces/ITrancheIndex.sol\\\";\\n\\nimport \\\"./FundRoles.sol\\\";\\n\\ncontract FundV2 is IFundV2, Ownable, ReentrancyGuard, FundRoles, CoreUtility, ITrancheIndex {\\n    using Math for uint256;\\n    using SafeMath for uint256;\\n    using SafeDecimalMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    event StrategyUpdateProposed(\\n        address indexed newStrategy,\\n        uint256 minTimestamp,\\n        uint256 maxTimestamp\\n    );\\n    event StrategyUpdated(address indexed previousStrategy, address indexed newStrategy);\\n    event ProfitReported(uint256 profit, uint256 performanceFee);\\n    event LossReported(uint256 loss);\\n    event ObsoletePrimaryMarketAdded(address obsoletePrimaryMarket);\\n    event NewPrimaryMarketAdded(address newPrimaryMarket);\\n    event DailyProtocolFeeRateUpdated(uint256 newDailyProtocolFeeRate);\\n    event TwapOracleUpdated(address newTwapOracle);\\n    event AprOracleUpdated(address newAprOracle);\\n    event BallotUpdated(address newBallot);\\n    event FeeCollectorUpdated(address newFeeCollector);\\n    event ActivityDelayTimeUpdated(uint256 delayTime);\\n\\n    uint256 private constant UNIT = 1e18;\\n    uint256 private constant MAX_INTEREST_RATE = 0.2e18; // 20% daily\\n    uint256 private constant MAX_DAILY_PROTOCOL_FEE_RATE = 0.05e18; // 5% daily rate\\n\\n    uint256 private constant WEIGHT_A = 1;\\n    uint256 private constant WEIGHT_B = 1;\\n    uint256 private constant WEIGHT_M = WEIGHT_A + WEIGHT_B;\\n\\n    uint256 private constant STRATEGY_UPDATE_MIN_DELAY = 3 days;\\n    uint256 private constant STRATEGY_UPDATE_MAX_DELAY = 7 days;\\n\\n    /// @notice Upper bound of `NAV_B / NAV_A` to trigger a rebalance.\\n    uint256 public immutable upperRebalanceThreshold;\\n\\n    /// @notice Lower bound of `NAV_B / NAV_A` to trigger a rebalance.\\n    uint256 public immutable lowerRebalanceThreshold;\\n\\n    /// @notice Address of the underlying token.\\n    address public immutable override tokenUnderlying;\\n\\n    /// @notice A multipler that normalizes an underlying balance to 18 decimal places.\\n    uint256 public immutable override underlyingDecimalMultiplier;\\n\\n    /// @notice Daily protocol fee rate.\\n    uint256 public dailyProtocolFeeRate;\\n\\n    /// @notice TwapOracle address for the underlying asset.\\n    ITwapOracle public override twapOracle;\\n\\n    /// @notice AprOracle address.\\n    IAprOracle public aprOracle;\\n\\n    /// @notice Address of the interest rate ballot.\\n    IBallot public ballot;\\n\\n    /// @notice Fee Collector address.\\n    address public override feeCollector;\\n\\n    /// @notice Address of Token M.\\n    address public override tokenM;\\n\\n    /// @notice Address of Token A.\\n    address public override tokenA;\\n\\n    /// @notice Address of Token B.\\n    address public override tokenB;\\n\\n    /// @notice End timestamp of the current trading day.\\n    ///         A trading day starts at UTC time `SETTLEMENT_TIME` of a day (inclusive)\\n    ///         and ends at the same time of the next day (exclusive).\\n    uint256 public override currentDay;\\n\\n    /// @notice Start timestamp of the current primary market activity window.\\n    uint256 public override fundActivityStartTime;\\n\\n    /// @notice Start timestamp of the current exchange activity window.\\n    uint256 public override exchangeActivityStartTime;\\n\\n    uint256 public activityDelayTimeAfterRebalance;\\n\\n    /// @dev Historical rebalances. Rebalances are often accessed in loops with bounds checking.\\n    ///      So we store them in a fixed-length array, in order to make compiler-generated\\n    ///      bounds checking on every access cheaper. The actual length of this array is stored in\\n    ///      `_rebalanceSize` and should be explicitly checked when necessary.\\n    Rebalance[65535] private _rebalances;\\n\\n    /// @dev Historical rebalance count.\\n    uint256 private _rebalanceSize;\\n\\n    /// @dev Total share supply of the three tranches. They are always rebalanced to the latest\\n    ///      version.\\n    uint256[TRANCHE_COUNT] private _totalSupplies;\\n\\n    /// @dev Mapping of account => share balance of the three tranches.\\n    ///      Rebalance versions are stored in a separate mapping `_balanceVersions`.\\n    mapping(address => uint256[TRANCHE_COUNT]) private _balances;\\n\\n    /// @dev Rebalance version mapping for `_balances`.\\n    mapping(address => uint256) private _balanceVersions;\\n\\n    /// @dev Mapping of owner => spender => share allowance of the three tranches.\\n    ///      Rebalance versions are stored in a separate mapping `_allowanceVersions`.\\n    mapping(address => mapping(address => uint256[TRANCHE_COUNT])) private _allowances;\\n\\n    /// @dev Rebalance version mapping for `_allowances`.\\n    mapping(address => mapping(address => uint256)) private _allowanceVersions;\\n\\n    /// @dev Mapping of trading day => NAV tuple.\\n    mapping(uint256 => uint256[TRANCHE_COUNT]) private _historicalNavs;\\n\\n    /// @notice Mapping of trading day => total fund shares.\\n    ///\\n    ///         Key is the end timestamp of a trading day. Value is the total fund shares after\\n    ///         settlement of that trading day, as if all Token A and B are merged.\\n    mapping(uint256 => uint256) public override historicalTotalShares;\\n\\n    /// @notice Mapping of trading day => underlying assets in the fund.\\n    ///\\n    ///         Key is the end timestamp of a trading day. Value is the underlying assets in\\n    ///         the fund after settlement of that trading day.\\n    mapping(uint256 => uint256) public override historicalUnderlying;\\n\\n    /// @notice Mapping of trading week => interest rate of Token A.\\n    ///\\n    ///         Key is the end timestamp of a trading week. Value is the interest rate captured\\n    ///         after settlement of the last day of the previous trading week.\\n    mapping(uint256 => uint256) public historicalInterestRate;\\n\\n    address[] private obsoletePrimaryMarkets;\\n    address[] private newPrimaryMarkets;\\n\\n    /// @notice Amount of fee not transfered to the fee collector yet.\\n    uint256 public feeDebt;\\n\\n    /// @dev Mapping of primary market => Amount of redemption underlying that the fund owes\\n    ///      the primary market\\n    mapping(address => uint256) public redemptionDebts;\\n\\n    /// @dev Sum of the fee debt and redemption debts of all primary markets.\\n    uint256 private _totalDebt;\\n\\n    address public strategy;\\n\\n    address public proposedStrategy;\\n\\n    uint256 private _proposedStrategyTimestamp;\\n\\n    uint256 private _strategyUnderlying;\\n\\n    constructor(\\n        address tokenUnderlying_,\\n        uint256 underlyingDecimals_,\\n        uint256 dailyProtocolFeeRate_,\\n        uint256 upperRebalanceThreshold_,\\n        uint256 lowerRebalanceThreshold_,\\n        address twapOracle_,\\n        address aprOracle_,\\n        address ballot_,\\n        address feeCollector_\\n    ) public Ownable() FundRoles() {\\n        tokenUnderlying = tokenUnderlying_;\\n        require(underlyingDecimals_ <= 18, \\\"Underlying decimals larger than 18\\\");\\n        underlyingDecimalMultiplier = 10**(18 - underlyingDecimals_);\\n        require(\\n            dailyProtocolFeeRate_ <= MAX_DAILY_PROTOCOL_FEE_RATE,\\n            \\\"Exceed max protocol fee rate\\\"\\n        );\\n        dailyProtocolFeeRate = dailyProtocolFeeRate_;\\n        upperRebalanceThreshold = upperRebalanceThreshold_;\\n        lowerRebalanceThreshold = lowerRebalanceThreshold_;\\n        twapOracle = ITwapOracle(twapOracle_);\\n        aprOracle = IAprOracle(aprOracle_);\\n        ballot = IBallot(ballot_);\\n        feeCollector = feeCollector_;\\n\\n        currentDay = endOfDay(block.timestamp);\\n        uint256 lastDay = currentDay - 1 days;\\n        uint256 currentPrice = twapOracle.getTwap(lastDay);\\n        require(currentPrice != 0, \\\"Price not available\\\");\\n        _historicalNavs[lastDay][TRANCHE_M] = UNIT;\\n        _historicalNavs[lastDay][TRANCHE_A] = UNIT;\\n        _historicalNavs[lastDay][TRANCHE_B] = UNIT;\\n        historicalInterestRate[_endOfWeek(lastDay)] = MAX_INTEREST_RATE.min(aprOracle.capture());\\n        fundActivityStartTime = lastDay;\\n        exchangeActivityStartTime = lastDay + 30 minutes;\\n        activityDelayTimeAfterRebalance = 12 hours;\\n    }\\n\\n    function initialize(\\n        address tokenM_,\\n        address tokenA_,\\n        address tokenB_,\\n        address primaryMarket_,\\n        address strategy_\\n    ) external onlyOwner {\\n        require(tokenM == address(0) && tokenM_ != address(0), \\\"Already initialized\\\");\\n        tokenM = tokenM_;\\n        tokenA = tokenA_;\\n        tokenB = tokenB_;\\n        _initializeRoles(tokenM_, tokenA_, tokenB_, primaryMarket_);\\n        emit StrategyUpdated(strategy, strategy_);\\n        strategy = strategy_;\\n    }\\n\\n    /// @notice Return weights of Token A and B when splitting Token M.\\n    /// @return weightA Weight of Token A\\n    /// @return weightB Weight of Token B\\n    function trancheWeights() external pure override returns (uint256 weightA, uint256 weightB) {\\n        return (WEIGHT_A, WEIGHT_B);\\n    }\\n\\n    /// @notice UTC time of a day when the fund settles.\\n    function settlementTime() external pure returns (uint256) {\\n        return SETTLEMENT_TIME;\\n    }\\n\\n    /// @notice Return end timestamp of the trading day containing a given timestamp.\\n    ///\\n    ///         A trading day starts at UTC time `SETTLEMENT_TIME` of a day (inclusive)\\n    ///         and ends at the same time of the next day (exclusive).\\n    /// @param timestamp The given timestamp\\n    /// @return End timestamp of the trading day.\\n    function endOfDay(uint256 timestamp) public pure override returns (uint256) {\\n        return ((timestamp.add(1 days) - SETTLEMENT_TIME) / 1 days) * 1 days + SETTLEMENT_TIME;\\n    }\\n\\n    /// @notice Return end timestamp of the trading week containing a given timestamp.\\n    ///\\n    ///         A trading week starts at UTC time `SETTLEMENT_TIME` on a Thursday (inclusive)\\n    ///         and ends at the same time of the next Thursday (exclusive).\\n    /// @param timestamp The given timestamp\\n    /// @return End timestamp of the trading week.\\n    function endOfWeek(uint256 timestamp) external pure returns (uint256) {\\n        return _endOfWeek(timestamp);\\n    }\\n\\n    /// @notice Return the status of the fund contract.\\n    /// @param timestamp Timestamp to assess\\n    /// @return True if the fund contract is active\\n    function isFundActive(uint256 timestamp) public view override returns (bool) {\\n        return timestamp >= fundActivityStartTime;\\n    }\\n\\n    /// @notice Return the status of a given primary market contract.\\n    /// @param primaryMarket The primary market contract address\\n    /// @param timestamp Timestamp to assess\\n    /// @return True if the primary market contract is active\\n    function isPrimaryMarketActive(address primaryMarket, uint256 timestamp)\\n        public\\n        view\\n        override\\n        returns (bool)\\n    {\\n        return\\n            isPrimaryMarket(primaryMarket) &&\\n            timestamp >= fundActivityStartTime &&\\n            timestamp < currentDay;\\n    }\\n\\n    /// @notice Return the status of the exchange. Unlike the primary market, exchange is\\n    ///         anonymous to fund\\n    /// @param timestamp Timestamp to assess\\n    /// @return True if the exchange contract is active\\n    function isExchangeActive(uint256 timestamp) public view override returns (bool) {\\n        return (timestamp >= exchangeActivityStartTime && timestamp < (currentDay - 60 minutes));\\n    }\\n\\n    function getTotalUnderlying() public view override returns (uint256) {\\n        uint256 hot = IERC20(tokenUnderlying).balanceOf(address(this));\\n        return hot.add(_strategyUnderlying).sub(_totalDebt);\\n    }\\n\\n    function getStrategyUnderlying() external view override returns (uint256) {\\n        return _strategyUnderlying;\\n    }\\n\\n    function getTotalDebt() external view override returns (uint256) {\\n        return _totalDebt;\\n    }\\n\\n    /// @notice Total shares of the fund, as if all Token A and B are merged.\\n    function getTotalShares() public view override returns (uint256) {\\n        return\\n            _totalSupplies[TRANCHE_M].add(_totalSupplies[TRANCHE_A]).add(_totalSupplies[TRANCHE_B]);\\n    }\\n\\n    /// @notice Return the rebalance matrix at a given index. A zero struct is returned\\n    ///         if `index` is out of bound.\\n    /// @param index Rebalance index\\n    /// @return A rebalance matrix\\n    function getRebalance(uint256 index) external view override returns (Rebalance memory) {\\n        return _rebalances[index];\\n    }\\n\\n    /// @notice Return timestamp of the transaction triggering the rebalance at a given index.\\n    ///         Zero is returned if `index` is out of bound.\\n    /// @param index Rebalance index\\n    /// @return Timestamp of the rebalance\\n    function getRebalanceTimestamp(uint256 index) external view override returns (uint256) {\\n        return _rebalances[index].timestamp;\\n    }\\n\\n    /// @notice Return the number of historical rebalances.\\n    function getRebalanceSize() external view override returns (uint256) {\\n        return _rebalanceSize;\\n    }\\n\\n    /// @notice Return NAV of Token M, A and B of the given trading day.\\n    /// @param day End timestamp of a trading day\\n    /// @return NAV of Token M, A and B\\n    function historicalNavs(uint256 day)\\n        external\\n        view\\n        override\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        return (\\n            _historicalNavs[day][TRANCHE_M],\\n            _historicalNavs[day][TRANCHE_A],\\n            _historicalNavs[day][TRANCHE_B]\\n        );\\n    }\\n\\n    /// @notice Estimate NAV of all tranches at a given timestamp, considering underlying price\\n    ///         change, accrued protocol fee and accrued interest since the previous settlement.\\n    ///\\n    ///         The extrapolation uses simple interest instead of daily compound interest in\\n    ///         calculating protocol fee and Token A's interest. There may be significant error\\n    ///         in the returned values when `timestamp` is far beyond the last settlement.\\n    /// @param timestamp Timestamp to estimate\\n    /// @param price Price of the underlying asset (18 decimal places)\\n    /// @return Estimated NAV of all tranches\\n    function extrapolateNav(uint256 timestamp, uint256 price)\\n        external\\n        view\\n        override\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        // Find the last settled trading day before the given timestamp.\\n        uint256 previousDay = currentDay - 1 days;\\n        if (previousDay > timestamp) {\\n            previousDay = endOfDay(timestamp) - 1 days;\\n        }\\n        uint256 previousShares = historicalTotalShares[previousDay];\\n        uint256 navM = _extrapolateNavM(previousDay, previousShares, timestamp, price);\\n        uint256 navA = _extrapolateNavA(previousDay, previousShares, timestamp);\\n        uint256 navB = calculateNavB(navM, navA);\\n        return (navM, navA, navB);\\n    }\\n\\n    function _extrapolateNavM(\\n        uint256 previousDay,\\n        uint256 previousShares,\\n        uint256 timestamp,\\n        uint256 price\\n    ) private view returns (uint256) {\\n        uint256 navM;\\n        if (previousShares == 0) {\\n            // The fund is empty. Just return the previous recorded NAV.\\n            navM = _historicalNavs[previousDay][TRANCHE_M];\\n            if (navM == 0) {\\n                // No NAV is recorded because the given timestamp is before the fund launches.\\n                return UNIT;\\n            } else {\\n                return navM;\\n            }\\n        }\\n        uint256 totalValue =\\n            price.mul(historicalUnderlying[previousDay].mul(underlyingDecimalMultiplier));\\n        uint256 accruedFee =\\n            totalValue.multiplyDecimal(dailyProtocolFeeRate).mul(timestamp - previousDay).div(\\n                1 days\\n            );\\n        navM = (totalValue - accruedFee).div(previousShares);\\n        return navM;\\n    }\\n\\n    function _extrapolateNavA(\\n        uint256 previousDay,\\n        uint256 previousShares,\\n        uint256 timestamp\\n    ) private view returns (uint256) {\\n        uint256 navA = _historicalNavs[previousDay][TRANCHE_A];\\n        if (previousShares == 0) {\\n            // The fund is empty. Just return the previous recorded NAV.\\n            if (navA == 0) {\\n                // No NAV is recorded because the given timestamp is before the fund launches.\\n                return UNIT;\\n            } else {\\n                return navA;\\n            }\\n        }\\n\\n        uint256 week = _endOfWeek(previousDay);\\n        uint256 newNavA =\\n            navA\\n                .multiplyDecimal(\\n                UNIT.sub(dailyProtocolFeeRate.mul(timestamp - previousDay).div(1 days))\\n            )\\n                .multiplyDecimal(\\n                UNIT.add(historicalInterestRate[week].mul(timestamp - previousDay).div(1 days))\\n            );\\n        return newNavA > navA ? newNavA : navA;\\n    }\\n\\n    function calculateNavB(uint256 navM, uint256 navA) public pure override returns (uint256) {\\n        // Using unchecked multiplications because they are unlikely to overflow\\n        if (navM * WEIGHT_M >= navA * WEIGHT_A) {\\n            return (navM * WEIGHT_M - navA * WEIGHT_A) / WEIGHT_B;\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    /// @notice Transform share amounts according to the rebalance at a given index.\\n    ///         This function performs no bounds checking on the given index. A non-existent\\n    ///         rebalance transforms anything to a zero vector.\\n    /// @param amountM Amount of Token M before the rebalance\\n    /// @param amountA Amount of Token A before the rebalance\\n    /// @param amountB Amount of Token B before the rebalance\\n    /// @param index Rebalance index\\n    /// @return newAmountM Amount of Token M after the rebalance\\n    /// @return newAmountA Amount of Token A after the rebalance\\n    /// @return newAmountB Amount of Token B after the rebalance\\n    function doRebalance(\\n        uint256 amountM,\\n        uint256 amountA,\\n        uint256 amountB,\\n        uint256 index\\n    )\\n        public\\n        view\\n        override\\n        returns (\\n            uint256 newAmountM,\\n            uint256 newAmountA,\\n            uint256 newAmountB\\n        )\\n    {\\n        Rebalance storage rebalance = _rebalances[index];\\n        newAmountM = amountM\\n            .multiplyDecimal(rebalance.ratioM)\\n            .add(amountA.multiplyDecimal(rebalance.ratioA2M))\\n            .add(amountB.multiplyDecimal(rebalance.ratioB2M));\\n        uint256 ratioAB = rebalance.ratioAB; // Gas saver\\n        newAmountA = amountA.multiplyDecimal(ratioAB);\\n        newAmountB = amountB.multiplyDecimal(ratioAB);\\n    }\\n\\n    /// @notice Transform share amounts according to rebalances in a given index range,\\n    ///         This function performs no bounds checking on the given indices. The original amounts\\n    ///         are returned if `fromIndex` is no less than `toIndex`. A zero vector is returned\\n    ///         if `toIndex` is greater than the number of existing rebalances.\\n    /// @param amountM Amount of Token M before the rebalance\\n    /// @param amountA Amount of Token A before the rebalance\\n    /// @param amountB Amount of Token B before the rebalance\\n    /// @param fromIndex Starting of the rebalance index range, inclusive\\n    /// @param toIndex End of the rebalance index range, exclusive\\n    /// @return newAmountM Amount of Token M after the rebalance\\n    /// @return newAmountA Amount of Token A after the rebalance\\n    /// @return newAmountB Amount of Token B after the rebalance\\n    function batchRebalance(\\n        uint256 amountM,\\n        uint256 amountA,\\n        uint256 amountB,\\n        uint256 fromIndex,\\n        uint256 toIndex\\n    )\\n        external\\n        view\\n        override\\n        returns (\\n            uint256 newAmountM,\\n            uint256 newAmountA,\\n            uint256 newAmountB\\n        )\\n    {\\n        for (uint256 i = fromIndex; i < toIndex; i++) {\\n            (amountM, amountA, amountB) = doRebalance(amountM, amountA, amountB, i);\\n        }\\n        newAmountM = amountM;\\n        newAmountA = amountA;\\n        newAmountB = amountB;\\n    }\\n\\n    /// @notice Transform share balance to a given rebalance version, or to the latest version\\n    ///         if `targetVersion` is zero.\\n    /// @param account Account of the balance to rebalance\\n    /// @param targetVersion The target rebalance version, or zero for the latest version\\n    function refreshBalance(address account, uint256 targetVersion) external override {\\n        if (targetVersion > 0) {\\n            require(targetVersion <= _rebalanceSize, \\\"Target version out of bound\\\");\\n        }\\n        _refreshBalance(account, targetVersion);\\n    }\\n\\n    /// @notice Transform allowance to a given rebalance version, or to the latest version\\n    ///         if `targetVersion` is zero.\\n    /// @param owner Owner of the allowance to rebalance\\n    /// @param spender Spender of the allowance to rebalance\\n    /// @param targetVersion The target rebalance version, or zero for the latest version\\n    function refreshAllowance(\\n        address owner,\\n        address spender,\\n        uint256 targetVersion\\n    ) external override {\\n        if (targetVersion > 0) {\\n            require(targetVersion <= _rebalanceSize, \\\"Target version out of bound\\\");\\n        }\\n        _refreshAllowance(owner, spender, targetVersion);\\n    }\\n\\n    function shareBalanceOf(uint256 tranche, address account)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        uint256 amountM = _balances[account][TRANCHE_M];\\n        uint256 amountA = _balances[account][TRANCHE_A];\\n        uint256 amountB = _balances[account][TRANCHE_B];\\n\\n        if (tranche == TRANCHE_M) {\\n            if (amountM == 0 && amountA == 0 && amountB == 0) return 0;\\n        } else if (tranche == TRANCHE_A) {\\n            if (amountA == 0) return 0;\\n        } else {\\n            if (amountB == 0) return 0;\\n        }\\n\\n        uint256 size = _rebalanceSize; // Gas saver\\n        for (uint256 i = _balanceVersions[account]; i < size; i++) {\\n            (amountM, amountA, amountB) = doRebalance(amountM, amountA, amountB, i);\\n        }\\n\\n        if (tranche == TRANCHE_M) {\\n            return amountM;\\n        } else if (tranche == TRANCHE_A) {\\n            return amountA;\\n        } else {\\n            return amountB;\\n        }\\n    }\\n\\n    /// @notice Return all three share balances transformed to the latest rebalance version.\\n    /// @param account Owner of the shares\\n    function allShareBalanceOf(address account)\\n        external\\n        view\\n        override\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256 amountM = _balances[account][TRANCHE_M];\\n        uint256 amountA = _balances[account][TRANCHE_A];\\n        uint256 amountB = _balances[account][TRANCHE_B];\\n\\n        uint256 size = _rebalanceSize; // Gas saver\\n        for (uint256 i = _balanceVersions[account]; i < size; i++) {\\n            (amountM, amountA, amountB) = doRebalance(amountM, amountA, amountB, i);\\n        }\\n\\n        return (amountM, amountA, amountB);\\n    }\\n\\n    function shareBalanceVersion(address account) external view override returns (uint256) {\\n        return _balanceVersions[account];\\n    }\\n\\n    function shareAllowance(\\n        uint256 tranche,\\n        address owner,\\n        address spender\\n    ) external view override returns (uint256) {\\n        uint256 allowanceM = _allowances[owner][spender][TRANCHE_M];\\n        uint256 allowanceA = _allowances[owner][spender][TRANCHE_A];\\n        uint256 allowanceB = _allowances[owner][spender][TRANCHE_B];\\n\\n        if (tranche == TRANCHE_M) {\\n            if (allowanceM == 0) return 0;\\n        } else if (tranche == TRANCHE_A) {\\n            if (allowanceA == 0) return 0;\\n        } else {\\n            if (allowanceB == 0) return 0;\\n        }\\n\\n        uint256 size = _rebalanceSize; // Gas saver\\n        for (uint256 i = _allowanceVersions[owner][spender]; i < size; i++) {\\n            (allowanceM, allowanceA, allowanceB) = _rebalanceAllowance(\\n                allowanceM,\\n                allowanceA,\\n                allowanceB,\\n                i\\n            );\\n        }\\n\\n        if (tranche == TRANCHE_M) {\\n            return allowanceM;\\n        } else if (tranche == TRANCHE_A) {\\n            return allowanceA;\\n        } else {\\n            return allowanceB;\\n        }\\n    }\\n\\n    function shareAllowanceVersion(address owner, address spender)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _allowanceVersions[owner][spender];\\n    }\\n\\n    function shareTotalSupply(uint256 tranche) external view override returns (uint256) {\\n        return _totalSupplies[tranche];\\n    }\\n\\n    function mint(\\n        uint256 tranche,\\n        address account,\\n        uint256 amount\\n    ) external override onlyPrimaryMarket {\\n        _refreshBalance(account, _rebalanceSize);\\n        _mint(tranche, account, amount);\\n    }\\n\\n    function burn(\\n        uint256 tranche,\\n        address account,\\n        uint256 amount\\n    ) external override onlyPrimaryMarket {\\n        _refreshBalance(account, _rebalanceSize);\\n        _burn(tranche, account, amount);\\n    }\\n\\n    function transfer(\\n        uint256 tranche,\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public override onlyShare {\\n        require(isFundActive(block.timestamp), \\\"Transfer is inactive\\\");\\n        _refreshBalance(sender, _rebalanceSize);\\n        _refreshBalance(recipient, _rebalanceSize);\\n        _transfer(tranche, sender, recipient, amount);\\n    }\\n\\n    function transferFrom(\\n        uint256 tranche,\\n        address spender,\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external override onlyShare returns (uint256 newAllowance) {\\n        transfer(tranche, sender, recipient, amount);\\n\\n        _refreshAllowance(sender, spender, _rebalanceSize);\\n        newAllowance = _allowances[sender][spender][tranche].sub(\\n            amount,\\n            \\\"ERC20: transfer amount exceeds allowance\\\"\\n        );\\n        _approve(tranche, sender, spender, newAllowance);\\n    }\\n\\n    function approve(\\n        uint256 tranche,\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) external override onlyShare {\\n        _refreshAllowance(owner, spender, _rebalanceSize);\\n        _approve(tranche, owner, spender, amount);\\n    }\\n\\n    function increaseAllowance(\\n        uint256 tranche,\\n        address sender,\\n        address spender,\\n        uint256 addedValue\\n    ) external override onlyShare returns (uint256 newAllowance) {\\n        _refreshAllowance(sender, spender, _rebalanceSize);\\n        newAllowance = _allowances[sender][spender][tranche].add(addedValue);\\n        _approve(tranche, sender, spender, newAllowance);\\n    }\\n\\n    function decreaseAllowance(\\n        uint256 tranche,\\n        address sender,\\n        address spender,\\n        uint256 subtractedValue\\n    ) external override onlyShare returns (uint256 newAllowance) {\\n        _refreshAllowance(sender, spender, _rebalanceSize);\\n        newAllowance = _allowances[sender][spender][tranche].sub(subtractedValue);\\n        _approve(tranche, sender, spender, newAllowance);\\n    }\\n\\n    function _transfer(\\n        uint256 tranche,\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) private {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _balances[sender][tranche] = _balances[sender][tranche].sub(\\n            amount,\\n            \\\"ERC20: transfer amount exceeds balance\\\"\\n        );\\n        _balances[recipient][tranche] = _balances[recipient][tranche].add(amount);\\n\\n        emit Transfer(tranche, sender, recipient, amount);\\n    }\\n\\n    function _mint(\\n        uint256 tranche,\\n        address account,\\n        uint256 amount\\n    ) private {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _totalSupplies[tranche] = _totalSupplies[tranche].add(amount);\\n        _balances[account][tranche] = _balances[account][tranche].add(amount);\\n\\n        emit Transfer(tranche, address(0), account, amount);\\n    }\\n\\n    function _burn(\\n        uint256 tranche,\\n        address account,\\n        uint256 amount\\n    ) private {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _balances[account][tranche] = _balances[account][tranche].sub(\\n            amount,\\n            \\\"ERC20: burn amount exceeds balance\\\"\\n        );\\n        _totalSupplies[tranche] = _totalSupplies[tranche].sub(amount);\\n\\n        emit Transfer(tranche, account, address(0), amount);\\n    }\\n\\n    function _approve(\\n        uint256 tranche,\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) private {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender][tranche] = amount;\\n\\n        emit Approval(tranche, owner, spender, amount);\\n    }\\n\\n    /// @notice Settle the current trading day. Settlement includes the following changes\\n    ///         to the fund.\\n    ///\\n    ///         1. Charge protocol fee of the day.\\n    ///         2. Settle all pending creations and redemptions from all primary markets.\\n    ///         3. Calculate NAV of the day and trigger rebalance if necessary.\\n    ///         4. Capture new interest rate for Token A.\\n    function settle() external nonReentrant {\\n        uint256 day = currentDay;\\n        uint256 currentWeek = _endOfWeek(day - 1 days);\\n        require(block.timestamp >= day, \\\"The current trading day does not end yet\\\");\\n        uint256 price = twapOracle.getTwap(day);\\n        require(price != 0, \\\"Underlying price for settlement is not ready yet\\\");\\n\\n        _collectFee();\\n\\n        _settlePrimaryMarkets(day, price);\\n\\n        _payDebt();\\n\\n        // Calculate NAV\\n        uint256 totalShares = getTotalShares();\\n        uint256 underlying = getTotalUnderlying();\\n        uint256 navA = _historicalNavs[day - 1 days][TRANCHE_A];\\n        uint256 navM;\\n        if (totalShares > 0) {\\n            navM = price.mul(underlying.mul(underlyingDecimalMultiplier)).div(totalShares);\\n            if (historicalTotalShares[day - 1 days] > 0) {\\n                // Update NAV of Token A only when the fund is non-empty both before and after\\n                // this settlement\\n                uint256 newNavA =\\n                    navA.multiplyDecimal(UNIT.sub(dailyProtocolFeeRate)).multiplyDecimal(\\n                        historicalInterestRate[currentWeek].add(UNIT)\\n                    );\\n                if (navA < newNavA) {\\n                    navA = newNavA;\\n                }\\n            }\\n        } else {\\n            // If the fund is empty, use NAV of Token M in the last day\\n            navM = _historicalNavs[day - 1 days][TRANCHE_M];\\n        }\\n        uint256 navB = calculateNavB(navM, navA);\\n\\n        if (_shouldTriggerRebalance(navA, navB)) {\\n            _triggerRebalance(day, navM, navA, navB);\\n            navM = UNIT;\\n            navA = UNIT;\\n            navB = UNIT;\\n            totalShares = getTotalShares();\\n            fundActivityStartTime = day + activityDelayTimeAfterRebalance;\\n            exchangeActivityStartTime = day + activityDelayTimeAfterRebalance;\\n        } else {\\n            fundActivityStartTime = day;\\n            exchangeActivityStartTime = day + 30 minutes;\\n        }\\n\\n        if (day == currentWeek) {\\n            historicalInterestRate[currentWeek + 1 weeks] = _updateInterestRate(currentWeek);\\n        }\\n\\n        historicalTotalShares[day] = totalShares;\\n        historicalUnderlying[day] = underlying;\\n        _historicalNavs[day][TRANCHE_M] = navM;\\n        _historicalNavs[day][TRANCHE_A] = navA;\\n        _historicalNavs[day][TRANCHE_B] = navB;\\n        currentDay = day + 1 days;\\n\\n        if (obsoletePrimaryMarkets.length > 0) {\\n            for (uint256 i = 0; i < obsoletePrimaryMarkets.length; i++) {\\n                _removePrimaryMarket(obsoletePrimaryMarkets[i]);\\n            }\\n            delete obsoletePrimaryMarkets;\\n        }\\n\\n        if (newPrimaryMarkets.length > 0) {\\n            for (uint256 i = 0; i < newPrimaryMarkets.length; i++) {\\n                _addPrimaryMarket(newPrimaryMarkets[i]);\\n            }\\n            delete newPrimaryMarkets;\\n        }\\n\\n        emit Settled(day, navM, navA, navB);\\n    }\\n\\n    modifier onlyStrategy() {\\n        require(msg.sender == strategy, \\\"Only strategy\\\");\\n        _;\\n    }\\n\\n    function transferToStrategy(uint256 amount) external override onlyStrategy {\\n        _strategyUnderlying = _strategyUnderlying.add(amount);\\n        IERC20(tokenUnderlying).safeTransfer(strategy, amount);\\n    }\\n\\n    function transferFromStrategy(uint256 amount) external override onlyStrategy {\\n        _strategyUnderlying = _strategyUnderlying.sub(amount);\\n        IERC20(tokenUnderlying).safeTransferFrom(strategy, address(this), amount);\\n        _payDebt();\\n    }\\n\\n    function reportProfit(uint256 profit, uint256 performanceFee) external override onlyStrategy {\\n        require(profit >= performanceFee, \\\"Performance fee cannot exceed profit\\\");\\n        _strategyUnderlying = _strategyUnderlying.add(profit);\\n        feeDebt = feeDebt.add(performanceFee);\\n        _totalDebt = _totalDebt.add(performanceFee);\\n        emit ProfitReported(profit, performanceFee);\\n    }\\n\\n    function reportLoss(uint256 loss) external override onlyStrategy {\\n        _strategyUnderlying = _strategyUnderlying.sub(loss);\\n        emit LossReported(loss);\\n    }\\n\\n    function proposeStrategyUpdate(address newStrategy) external onlyOwner {\\n        require(newStrategy != strategy);\\n        proposedStrategy = newStrategy;\\n        _proposedStrategyTimestamp = block.timestamp;\\n        emit StrategyUpdateProposed(\\n            newStrategy,\\n            block.timestamp + STRATEGY_UPDATE_MIN_DELAY,\\n            block.timestamp + STRATEGY_UPDATE_MAX_DELAY\\n        );\\n    }\\n\\n    function applyStrategyUpdate(address newStrategy) external onlyOwner {\\n        require(proposedStrategy == newStrategy, \\\"Proposed strategy mismatch\\\");\\n        require(\\n            block.timestamp >= _proposedStrategyTimestamp + STRATEGY_UPDATE_MIN_DELAY &&\\n                block.timestamp < _proposedStrategyTimestamp + STRATEGY_UPDATE_MAX_DELAY,\\n            \\\"Not ready to update strategy\\\"\\n        );\\n        require(_totalDebt == 0, \\\"Cannot update strategy with debt\\\");\\n        emit StrategyUpdated(strategy, newStrategy);\\n        strategy = newStrategy;\\n        proposedStrategy = address(0);\\n        _proposedStrategyTimestamp = 0;\\n    }\\n\\n    function addObsoletePrimaryMarket(address obsoletePrimaryMarket) external onlyOwner {\\n        require(isPrimaryMarket(obsoletePrimaryMarket), \\\"The address is not a primary market\\\");\\n        obsoletePrimaryMarkets.push(obsoletePrimaryMarket);\\n        emit ObsoletePrimaryMarketAdded(obsoletePrimaryMarket);\\n    }\\n\\n    function addNewPrimaryMarket(address newPrimaryMarket) external onlyOwner {\\n        require(!isPrimaryMarket(newPrimaryMarket), \\\"The address is already a primary market\\\");\\n        newPrimaryMarkets.push(newPrimaryMarket);\\n        emit NewPrimaryMarketAdded(newPrimaryMarket);\\n    }\\n\\n    function updateDailyProtocolFeeRate(uint256 newDailyProtocolFeeRate) external onlyOwner {\\n        require(\\n            newDailyProtocolFeeRate <= MAX_DAILY_PROTOCOL_FEE_RATE,\\n            \\\"Exceed max protocol fee rate\\\"\\n        );\\n        dailyProtocolFeeRate = newDailyProtocolFeeRate;\\n        emit DailyProtocolFeeRateUpdated(newDailyProtocolFeeRate);\\n    }\\n\\n    function updateTwapOracle(address newTwapOracle) external onlyOwner {\\n        twapOracle = ITwapOracle(newTwapOracle);\\n        emit TwapOracleUpdated(newTwapOracle);\\n    }\\n\\n    function updateAprOracle(address newAprOracle) external onlyOwner {\\n        aprOracle = IAprOracle(newAprOracle);\\n        emit AprOracleUpdated(newAprOracle);\\n    }\\n\\n    function updateBallot(address newBallot) external onlyOwner {\\n        ballot = IBallot(newBallot);\\n        emit BallotUpdated(newBallot);\\n    }\\n\\n    function updateFeeCollector(address newFeeCollector) external onlyOwner {\\n        feeCollector = newFeeCollector;\\n        emit FeeCollectorUpdated(newFeeCollector);\\n    }\\n\\n    function updateActivityDelayTime(uint256 delayTime) external onlyOwner {\\n        require(\\n            delayTime >= 30 minutes && delayTime <= 12 hours,\\n            \\\"Exceed allowed delay time range\\\"\\n        );\\n        activityDelayTimeAfterRebalance = delayTime;\\n        emit ActivityDelayTimeUpdated(delayTime);\\n    }\\n\\n    /// @dev Transfer protocol fee of the current trading day to the fee collector.\\n    ///      This function should be called before creation and redemption on the same day\\n    ///      are settled.\\n    function _collectFee() private {\\n        uint256 currentUnderlying = getTotalUnderlying();\\n        uint256 fee = currentUnderlying.multiplyDecimal(dailyProtocolFeeRate);\\n        if (fee > 0) {\\n            feeDebt = feeDebt.add(fee);\\n            _totalDebt = _totalDebt.add(fee);\\n        }\\n    }\\n\\n    /// @dev Settle primary market operations in every PrimaryMarket contract.\\n    function _settlePrimaryMarkets(uint256 day, uint256 price) private {\\n        uint256 day_ = day; // Fix the \\\"stack too deep\\\" error\\n        uint256 totalShares = getTotalShares();\\n        uint256 underlying = getTotalUnderlying();\\n        uint256 primaryMarketCount = getPrimaryMarketCount();\\n        uint256 prevNavM = _historicalNavs[day - 1 days][TRANCHE_M];\\n        uint256 newTotalDebt = _totalDebt;\\n        for (uint256 i = 0; i < primaryMarketCount; i++) {\\n            uint256 price_ = price; // Fix the \\\"stack too deep\\\" error\\n            IPrimaryMarketV2 pm = IPrimaryMarketV2(getPrimaryMarketMember(i));\\n            (\\n                uint256 sharesToMint,\\n                uint256 sharesToBurn,\\n                uint256 creationUnderlying,\\n                uint256 redemptionUnderlying,\\n                uint256 fee\\n            ) = pm.settle(day_, totalShares, underlying, price_, prevNavM);\\n            if (sharesToMint > sharesToBurn) {\\n                _mint(TRANCHE_M, address(pm), sharesToMint - sharesToBurn);\\n            } else if (sharesToBurn > sharesToMint) {\\n                _burn(TRANCHE_M, address(pm), sharesToBurn - sharesToMint);\\n            }\\n            uint256 debt = redemptionDebts[address(pm)];\\n            uint256 redemptionAndDebt = redemptionUnderlying.add(debt);\\n            if (creationUnderlying > redemptionAndDebt) {\\n                IERC20(tokenUnderlying).safeTransferFrom(\\n                    address(pm),\\n                    address(this),\\n                    creationUnderlying - redemptionAndDebt\\n                );\\n                redemptionDebts[address(pm)] = 0;\\n                newTotalDebt -= debt;\\n            } else {\\n                uint256 newDebt = redemptionAndDebt - creationUnderlying;\\n                redemptionDebts[address(pm)] = newDebt;\\n                newTotalDebt = newTotalDebt.sub(debt).add(newDebt);\\n            }\\n            if (fee > 0) {\\n                feeDebt = feeDebt.add(fee);\\n                newTotalDebt = newTotalDebt.add(fee);\\n            }\\n        }\\n        _totalDebt = newTotalDebt;\\n    }\\n\\n    function _payDebt() private {\\n        uint256 total = _totalDebt;\\n        if (total == 0) {\\n            return;\\n        }\\n        uint256 hot = IERC20(tokenUnderlying).balanceOf(address(this));\\n        if (hot == 0) {\\n            return;\\n        }\\n        uint256 fee = feeDebt;\\n        if (fee > 0) {\\n            uint256 amount = hot.min(fee);\\n            feeDebt = fee - amount;\\n            total -= amount;\\n            hot -= amount;\\n            IERC20(tokenUnderlying).safeTransfer(feeCollector, amount);\\n        }\\n        uint256 primaryMarketCount = getPrimaryMarketCount();\\n        for (uint256 i = 0; i < primaryMarketCount && hot > 0 && total > 0; i++) {\\n            address pm = getPrimaryMarketMember(i);\\n            uint256 redemption = redemptionDebts[pm];\\n            if (redemption > 0) {\\n                uint256 amount = hot.min(redemption);\\n                redemptionDebts[pm] = redemption - amount;\\n                total -= amount;\\n                hot -= amount;\\n                IERC20(tokenUnderlying).safeTransfer(pm, amount);\\n                IPrimaryMarketV2(pm).updateDelayedRedemptionDay();\\n            }\\n        }\\n        _totalDebt = total;\\n    }\\n\\n    /// @dev Check whether a new rebalance should be triggered. Rebalance is triggered if\\n    ///      NAV of Token B over NAV of Token A is greater than the upper threshold or\\n    ///      less than the lower threshold.\\n    /// @param navA NAV of Token A before the rebalance\\n    /// @param navBOrZero NAV of Token B before the rebalance or zero if the NAV is negative\\n    /// @return Whether a new rebalance should be triggered\\n    function _shouldTriggerRebalance(uint256 navA, uint256 navBOrZero) private view returns (bool) {\\n        uint256 bOverA = navBOrZero.divideDecimal(navA);\\n        return bOverA < lowerRebalanceThreshold || bOverA > upperRebalanceThreshold;\\n    }\\n\\n    /// @dev Create a new rebalance that resets NAV of all tranches to 1. Total supplies are\\n    ///      rebalanced immediately.\\n    /// @param day Trading day that triggers this rebalance\\n    /// @param navM NAV of Token M before this rebalance\\n    /// @param navA NAV of Token A before this rebalance\\n    /// @param navBOrZero NAV of Token B before this rebalance or zero if the NAV is negative\\n    function _triggerRebalance(\\n        uint256 day,\\n        uint256 navM,\\n        uint256 navA,\\n        uint256 navBOrZero\\n    ) private {\\n        Rebalance memory rebalance = _calculateRebalance(navM, navA, navBOrZero);\\n        uint256 oldSize = _rebalanceSize;\\n        _rebalances[oldSize] = rebalance;\\n        _rebalanceSize = oldSize + 1;\\n        emit RebalanceTriggered(\\n            oldSize,\\n            day,\\n            rebalance.ratioM,\\n            rebalance.ratioA2M,\\n            rebalance.ratioB2M,\\n            rebalance.ratioAB\\n        );\\n\\n        (\\n            _totalSupplies[TRANCHE_M],\\n            _totalSupplies[TRANCHE_A],\\n            _totalSupplies[TRANCHE_B]\\n        ) = doRebalance(\\n            _totalSupplies[TRANCHE_M],\\n            _totalSupplies[TRANCHE_A],\\n            _totalSupplies[TRANCHE_B],\\n            oldSize\\n        );\\n        _refreshBalance(address(this), oldSize + 1);\\n    }\\n\\n    /// @dev Create a new rebalance matrix that resets given NAVs to (1, 1, 1).\\n    ///\\n    ///      Note that NAV of Token B can be negative before the rebalance when the underlying price\\n    ///      drops dramatically in a single trading day, in which case zero should be passed to\\n    ///      this function instead of the negative NAV.\\n    /// @param navM NAV of Token M before the rebalance\\n    /// @param navA NAV of Token A before the rebalance\\n    /// @param navBOrZero NAV of Token B before the rebalance or zero if the NAV is negative\\n    /// @return The rebalance matrix\\n    function _calculateRebalance(\\n        uint256 navM,\\n        uint256 navA,\\n        uint256 navBOrZero\\n    ) private view returns (Rebalance memory) {\\n        uint256 ratioAB;\\n        uint256 ratioA2M;\\n        uint256 ratioB2M;\\n        if (navBOrZero <= navA) {\\n            // Lower rebalance\\n            ratioAB = navBOrZero;\\n            ratioA2M = ((navM - navBOrZero) * WEIGHT_M) / WEIGHT_A;\\n            ratioB2M = 0;\\n        } else {\\n            // Upper rebalance\\n            ratioAB = UNIT;\\n            ratioA2M = navA - UNIT;\\n            ratioB2M = navBOrZero - UNIT;\\n        }\\n        return\\n            Rebalance({\\n                ratioM: navM,\\n                ratioA2M: ratioA2M,\\n                ratioB2M: ratioB2M,\\n                ratioAB: ratioAB,\\n                timestamp: block.timestamp\\n            });\\n    }\\n\\n    function _updateInterestRate(uint256 week) private returns (uint256) {\\n        uint256 baseInterestRate = MAX_INTEREST_RATE.min(aprOracle.capture());\\n        uint256 floatingInterestRate = ballot.count(week).div(365);\\n        uint256 rate = baseInterestRate.add(floatingInterestRate);\\n\\n        emit InterestRateUpdated(baseInterestRate, floatingInterestRate);\\n\\n        return rate;\\n    }\\n\\n    /// @dev Transform share balance to a given rebalance version, or to the latest version\\n    ///      if `targetVersion` is zero. This function does no bound check on `targetVersion`.\\n    /// @param account Account of the balance to rebalance\\n    /// @param targetVersion The target rebalance version, or zero for the latest version\\n    function _refreshBalance(address account, uint256 targetVersion) private {\\n        if (targetVersion == 0) {\\n            targetVersion = _rebalanceSize;\\n        }\\n        uint256 oldVersion = _balanceVersions[account];\\n        if (oldVersion >= targetVersion) {\\n            return;\\n        }\\n\\n        uint256[TRANCHE_COUNT] storage balanceTuple = _balances[account];\\n        uint256 balanceM = balanceTuple[TRANCHE_M];\\n        uint256 balanceA = balanceTuple[TRANCHE_A];\\n        uint256 balanceB = balanceTuple[TRANCHE_B];\\n        _balanceVersions[account] = targetVersion;\\n\\n        if (balanceM == 0 && balanceA == 0 && balanceB == 0) {\\n            // Fast path for an empty account\\n            return;\\n        }\\n\\n        for (uint256 i = oldVersion; i < targetVersion; i++) {\\n            (balanceM, balanceA, balanceB) = doRebalance(balanceM, balanceA, balanceB, i);\\n        }\\n        balanceTuple[TRANCHE_M] = balanceM;\\n        balanceTuple[TRANCHE_A] = balanceA;\\n        balanceTuple[TRANCHE_B] = balanceB;\\n\\n        emit BalancesRebalanced(account, targetVersion, balanceM, balanceA, balanceB);\\n    }\\n\\n    /// @dev Transform allowance to a given rebalance version, or to the latest version\\n    ///      if `targetVersion` is zero. This function does no bound check on `targetVersion`.\\n    /// @param owner Owner of the allowance to rebalance\\n    /// @param spender Spender of the allowance to rebalance\\n    /// @param targetVersion The target rebalance version, or zero for the latest version\\n    function _refreshAllowance(\\n        address owner,\\n        address spender,\\n        uint256 targetVersion\\n    ) private {\\n        if (targetVersion == 0) {\\n            targetVersion = _rebalanceSize;\\n        }\\n        uint256 oldVersion = _allowanceVersions[owner][spender];\\n        if (oldVersion >= targetVersion) {\\n            return;\\n        }\\n\\n        uint256[TRANCHE_COUNT] storage allowanceTuple = _allowances[owner][spender];\\n        uint256 allowanceM = allowanceTuple[TRANCHE_M];\\n        uint256 allowanceA = allowanceTuple[TRANCHE_A];\\n        uint256 allowanceB = allowanceTuple[TRANCHE_B];\\n        _allowanceVersions[owner][spender] = targetVersion;\\n\\n        if (allowanceM == 0 && allowanceA == 0 && allowanceB == 0) {\\n            // Fast path for an empty allowance\\n            return;\\n        }\\n\\n        for (uint256 i = oldVersion; i < targetVersion; i++) {\\n            (allowanceM, allowanceA, allowanceB) = _rebalanceAllowance(\\n                allowanceM,\\n                allowanceA,\\n                allowanceB,\\n                i\\n            );\\n        }\\n        allowanceTuple[TRANCHE_M] = allowanceM;\\n        allowanceTuple[TRANCHE_A] = allowanceA;\\n        allowanceTuple[TRANCHE_B] = allowanceB;\\n\\n        emit AllowancesRebalanced(\\n            owner,\\n            spender,\\n            targetVersion,\\n            allowanceM,\\n            allowanceA,\\n            allowanceB\\n        );\\n    }\\n\\n    function _rebalanceAllowance(\\n        uint256 allowanceM,\\n        uint256 allowanceA,\\n        uint256 allowanceB,\\n        uint256 index\\n    )\\n        private\\n        view\\n        returns (\\n            uint256 newAllowanceM,\\n            uint256 newAllowanceA,\\n            uint256 newAllowanceB\\n        )\\n    {\\n        Rebalance storage rebalance = _rebalances[index];\\n\\n        /// @dev using saturating arithmetic to avoid unconscious overflow revert\\n        newAllowanceM = allowanceM.saturatingMultiplyDecimal(rebalance.ratioM);\\n        newAllowanceA = allowanceA.saturatingMultiplyDecimal(rebalance.ratioAB);\\n        newAllowanceB = allowanceB.saturatingMultiplyDecimal(rebalance.ratioAB);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/fund/PrimaryMarket.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"../../utils/SafeDecimalMath.sol\\\";\\n\\nimport \\\"../interfaces/IPrimaryMarket.sol\\\";\\nimport \\\"../interfaces/IFund.sol\\\";\\nimport \\\"../interfaces/ITrancheIndex.sol\\\";\\n\\ncontract PrimaryMarket is IPrimaryMarket, ReentrancyGuard, ITrancheIndex, Ownable {\\n    event Created(address indexed account, uint256 underlying);\\n    event Redeemed(address indexed account, uint256 shares);\\n    event Split(address indexed account, uint256 inM, uint256 outA, uint256 outB);\\n    event Merged(address indexed account, uint256 outM, uint256 inA, uint256 inB);\\n    event Claimed(address indexed account, uint256 createdShares, uint256 redeemedUnderlying);\\n    event Settled(\\n        uint256 indexed day,\\n        uint256 sharesToMint,\\n        uint256 sharesToBurn,\\n        uint256 creationUnderlying,\\n        uint256 redemptionUnderlying,\\n        uint256 fee\\n    );\\n\\n    using SafeMath for uint256;\\n    using SafeDecimalMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    /// @dev Creation and redemption of a single account.\\n    /// @param day Day of the last creation or redemption request.\\n    /// @param creatingUnderlying Underlying that will be used for creation at the end of this day.\\n    /// @param redeemingShares Shares that will be redeemed at the end of this day.\\n    /// @param createdShares Shares already created in previous days.\\n    /// @param redeemedUnderlying Underlying already redeemed in previous days.\\n    /// @param version Rebalance version before the end of this trading day.\\n    struct CreationRedemption {\\n        uint256 day;\\n        uint256 creatingUnderlying;\\n        uint256 redeemingShares;\\n        uint256 createdShares;\\n        uint256 redeemedUnderlying;\\n        uint256 version;\\n    }\\n\\n    uint256 private constant MAX_REDEMPTION_FEE_RATE = 0.01e18;\\n    uint256 private constant MAX_SPLIT_FEE_RATE = 0.01e18;\\n    uint256 private constant MAX_MERGE_FEE_RATE = 0.01e18;\\n\\n    uint256 public immutable guardedLaunchStart;\\n    uint256 public guardedLaunchTotalCap;\\n    uint256 public guardedLaunchIndividualCap;\\n    mapping(address => uint256) public guardedLaunchCreations;\\n\\n    IFund public fund;\\n\\n    uint256 public redemptionFeeRate;\\n    uint256 public splitFeeRate;\\n    uint256 public mergeFeeRate;\\n    uint256 public minCreationUnderlying;\\n\\n    mapping(address => CreationRedemption) private _creationRedemptions;\\n\\n    uint256 public currentDay;\\n    uint256 public currentCreatingUnderlying;\\n    uint256 public currentRedeemingShares;\\n    uint256 public currentFeeInShares;\\n\\n    mapping(uint256 => uint256) private _historicalCreationRate;\\n    mapping(uint256 => uint256) private _historicalRedemptionRate;\\n\\n    constructor(\\n        address fund_,\\n        uint256 guardedLaunchStart_,\\n        uint256 redemptionFeeRate_,\\n        uint256 splitFeeRate_,\\n        uint256 mergeFeeRate_,\\n        uint256 minCreationUnderlying_\\n    ) public Ownable() {\\n        require(redemptionFeeRate_ <= MAX_REDEMPTION_FEE_RATE, \\\"Exceed max redemption fee rate\\\");\\n        require(splitFeeRate_ <= MAX_SPLIT_FEE_RATE, \\\"Exceed max split fee rate\\\");\\n        require(mergeFeeRate_ <= MAX_MERGE_FEE_RATE, \\\"Exceed max merge fee rate\\\");\\n        fund = IFund(fund_);\\n        guardedLaunchStart = guardedLaunchStart_;\\n        redemptionFeeRate = redemptionFeeRate_;\\n        splitFeeRate = splitFeeRate_;\\n        mergeFeeRate = mergeFeeRate_;\\n        minCreationUnderlying = minCreationUnderlying_;\\n        currentDay = fund.currentDay();\\n    }\\n\\n    function creationRedemptionOf(address account)\\n        external\\n        view\\n        returns (CreationRedemption memory)\\n    {\\n        return _currentCreationRedemption(account);\\n    }\\n\\n    function create(uint256 underlying) external nonReentrant onlyActive {\\n        require(underlying >= minCreationUnderlying, \\\"Min amount\\\");\\n        IERC20(fund.tokenUnderlying()).safeTransferFrom(msg.sender, address(this), underlying);\\n\\n        CreationRedemption memory cr = _currentCreationRedemption(msg.sender);\\n        cr.creatingUnderlying = cr.creatingUnderlying.add(underlying);\\n        _updateCreationRedemption(msg.sender, cr);\\n\\n        currentCreatingUnderlying = currentCreatingUnderlying.add(underlying);\\n\\n        if (block.timestamp < guardedLaunchStart + 4 weeks) {\\n            guardedLaunchCreations[msg.sender] = guardedLaunchCreations[msg.sender].add(underlying);\\n            require(\\n                IERC20(fund.tokenUnderlying()).balanceOf(address(fund)).add(\\n                    currentCreatingUnderlying\\n                ) <= guardedLaunchTotalCap,\\n                \\\"Guarded launch: exceed total cap\\\"\\n            );\\n            require(\\n                guardedLaunchCreations[msg.sender] <= guardedLaunchIndividualCap,\\n                \\\"Guarded launch: exceed individual cap\\\"\\n            );\\n        }\\n\\n        emit Created(msg.sender, underlying);\\n    }\\n\\n    function redeem(uint256 shares) external onlyActive {\\n        require(shares != 0, \\\"Zero shares\\\");\\n        // Use burn and mint to simulate a transfer, so that we don't need a special transferFrom()\\n        fund.burn(TRANCHE_M, msg.sender, shares);\\n        fund.mint(TRANCHE_M, address(this), shares);\\n\\n        CreationRedemption memory cr = _currentCreationRedemption(msg.sender);\\n        cr.redeemingShares = cr.redeemingShares.add(shares);\\n        _updateCreationRedemption(msg.sender, cr);\\n\\n        currentRedeemingShares = currentRedeemingShares.add(shares);\\n        emit Redeemed(msg.sender, shares);\\n    }\\n\\n    function claim(address account)\\n        external\\n        override\\n        nonReentrant\\n        returns (uint256 createdShares, uint256 redeemedUnderlying)\\n    {\\n        CreationRedemption memory cr = _currentCreationRedemption(account);\\n        createdShares = cr.createdShares;\\n        redeemedUnderlying = cr.redeemedUnderlying;\\n\\n        if (createdShares > 0) {\\n            IERC20(fund.tokenM()).safeTransfer(account, createdShares);\\n            cr.createdShares = 0;\\n        }\\n        if (redeemedUnderlying > 0) {\\n            IERC20(fund.tokenUnderlying()).safeTransfer(account, redeemedUnderlying);\\n            cr.redeemedUnderlying = 0;\\n        }\\n        _updateCreationRedemption(account, cr);\\n\\n        emit Claimed(account, createdShares, redeemedUnderlying);\\n    }\\n\\n    function split(uint256 inM) external onlyActive {\\n        require(\\n            block.timestamp >= guardedLaunchStart + 2 weeks,\\n            \\\"Guarded launch: split not ready yet\\\"\\n        );\\n        (uint256 weightA, uint256 weightB) = fund.trancheWeights();\\n        // Charge splitting fee and round it to a multiple of (weightA + weightB)\\n        uint256 unit = inM.sub(inM.multiplyDecimal(splitFeeRate)) / (weightA + weightB);\\n        require(unit > 0, \\\"Too little to split\\\");\\n        uint256 inMAfterFee = unit * (weightA + weightB);\\n        uint256 outA = unit * weightA;\\n        uint256 outB = inMAfterFee - outA;\\n        uint256 feeM = inM - inMAfterFee;\\n\\n        fund.burn(TRANCHE_M, msg.sender, inM);\\n        fund.mint(TRANCHE_A, msg.sender, outA);\\n        fund.mint(TRANCHE_B, msg.sender, outB);\\n        fund.mint(TRANCHE_M, address(this), feeM);\\n\\n        currentFeeInShares = currentFeeInShares.add(feeM);\\n        emit Split(msg.sender, inM, outA, outB);\\n    }\\n\\n    function merge(uint256 inA) external onlyActive {\\n        (uint256 weightA, uint256 weightB) = fund.trancheWeights();\\n        // Round to tranche weights\\n        uint256 unit = inA / weightA;\\n        require(unit > 0, \\\"Too little to merge\\\");\\n        // Keep unmergable Token A unchanged.\\n        inA = unit * weightA;\\n        uint256 inB = unit.mul(weightB);\\n        uint256 outMBeforeFee = inA.add(inB);\\n        uint256 feeM = outMBeforeFee.multiplyDecimal(mergeFeeRate);\\n        uint256 outM = outMBeforeFee.sub(feeM);\\n\\n        fund.burn(TRANCHE_A, msg.sender, inA);\\n        fund.burn(TRANCHE_B, msg.sender, inB);\\n        fund.mint(TRANCHE_M, msg.sender, outM);\\n        fund.mint(TRANCHE_M, address(this), feeM);\\n\\n        currentFeeInShares = currentFeeInShares.add(feeM);\\n        emit Merged(msg.sender, outM, inA, inB);\\n    }\\n\\n    /// @notice Settle ongoing creations and redemptions and also split and merge fees.\\n    ///\\n    ///         Creations and redemptions are settled according to the current shares and\\n    ///         underlying assets in the fund. Split and merge fee charged as Token M are also\\n    ///         redeemed at the same rate (without redemption fee).\\n    ///\\n    ///         This function does not mint or burn shares, nor transfer underlying assets.\\n    ///         It returns the following changes that should be done by the fund:\\n    ///\\n    ///         1. Mint or burn net shares (creations v.s. redemptions + split/merge fee).\\n    ///         2. Transfer underlying to or from this contract (creations v.s. redemptions).\\n    ///         3. Transfer fee in underlying assets to the governance address.\\n    ///\\n    ///         This function can only be called from the Fund contract. It should be called\\n    ///         after protocol fee is collected and before rebalance is triggered for the same\\n    ///         trading day.\\n    /// @param day The trading day to settle\\n    /// @param fundTotalShares Total shares of the fund (as if all Token A and B are merged)\\n    /// @param fundUnderlying Underlying assets in the fund\\n    /// @param underlyingPrice Price of the underlying assets at the end of the trading day\\n    /// @param previousNav NAV of Token M of the previous trading day\\n    /// @return sharesToMint Amount of Token M to mint for creations\\n    /// @return sharesToBurn Amount of Token M to burn for redemptions and split/merge fee\\n    /// @return creationUnderlying Underlying assets received for creations (including creation fee)\\n    /// @return redemptionUnderlying Underlying assets to be redeemed (excluding redemption fee)\\n    /// @return fee Total fee in underlying assets for the fund to transfer to the governance address,\\n    ///         inlucding creation fee, redemption fee and split/merge fee\\n    function settle(\\n        uint256 day,\\n        uint256 fundTotalShares,\\n        uint256 fundUnderlying,\\n        uint256 underlyingPrice,\\n        uint256 previousNav\\n    )\\n        external\\n        override\\n        nonReentrant\\n        onlyFund\\n        returns (\\n            uint256 sharesToMint,\\n            uint256 sharesToBurn,\\n            uint256 creationUnderlying,\\n            uint256 redemptionUnderlying,\\n            uint256 fee\\n        )\\n    {\\n        require(day >= currentDay, \\\"Already settled\\\");\\n\\n        // Creation\\n        creationUnderlying = currentCreatingUnderlying;\\n        if (creationUnderlying > 0) {\\n            if (fundUnderlying > 0) {\\n                sharesToMint = creationUnderlying.mul(fundTotalShares).div(fundUnderlying);\\n            } else {\\n                // NAV is rounded down. Computing creations using NAV results in rounded up shares,\\n                // which is unfair to existing share holders. We only do that when there are\\n                // no shares before.\\n                require(\\n                    fundTotalShares == 0,\\n                    \\\"Cannot create shares for fund with shares but no underlying\\\"\\n                );\\n                require(previousNav > 0, \\\"Cannot create shares at zero NAV\\\");\\n                sharesToMint = creationUnderlying\\n                    .mul(underlyingPrice)\\n                    .mul(fund.underlyingDecimalMultiplier())\\n                    .div(previousNav);\\n            }\\n            _historicalCreationRate[day] = sharesToMint.divideDecimal(creationUnderlying);\\n        }\\n\\n        // Redemption\\n        sharesToBurn = currentRedeemingShares;\\n        if (sharesToBurn > 0) {\\n            uint256 underlying = sharesToBurn.mul(fundUnderlying).div(fundTotalShares);\\n            uint256 redemptionFee = underlying.multiplyDecimal(redemptionFeeRate);\\n            redemptionUnderlying = underlying.sub(redemptionFee);\\n            _historicalRedemptionRate[day] = redemptionUnderlying.divideDecimal(sharesToBurn);\\n            fee = redemptionFee;\\n        }\\n\\n        // Redeem split and merge fee\\n        uint256 feeInShares = currentFeeInShares;\\n        if (feeInShares > 0) {\\n            sharesToBurn = sharesToBurn.add(feeInShares);\\n            fee = fee.add(feeInShares.mul(fundUnderlying).div(fundTotalShares));\\n        }\\n\\n        // Approve the fund to take underlying if creation is more than redemption.\\n        // Instead of directly transfering underlying to the fund, this implementation\\n        // makes testing much easier.\\n        if (creationUnderlying > redemptionUnderlying) {\\n            IERC20(fund.tokenUnderlying()).safeApprove(\\n                address(fund),\\n                creationUnderlying - redemptionUnderlying\\n            );\\n        }\\n\\n        // This loop should never execute, because this function is called by Fund\\n        // for every day. We fill the gap just in case that something goes wrong in Fund.\\n        for (uint256 t = currentDay; t < day; t += 1 days) {\\n            _historicalCreationRate[t] = _historicalCreationRate[day];\\n            _historicalRedemptionRate[t] = _historicalRedemptionRate[day];\\n        }\\n\\n        currentDay = day + 1 days;\\n        currentCreatingUnderlying = 0;\\n        currentRedeemingShares = 0;\\n        currentFeeInShares = 0;\\n        emit Settled(\\n            day,\\n            sharesToMint,\\n            sharesToBurn,\\n            creationUnderlying,\\n            redemptionUnderlying,\\n            fee\\n        );\\n    }\\n\\n    function updateGuardedLaunchCap(uint256 newTotalCap, uint256 newIndividualCap)\\n        external\\n        onlyOwner\\n    {\\n        guardedLaunchTotalCap = newTotalCap;\\n        guardedLaunchIndividualCap = newIndividualCap;\\n    }\\n\\n    function updateRedemptionFeeRate(uint256 newRedemptionFeeRate) external onlyOwner {\\n        require(newRedemptionFeeRate <= MAX_REDEMPTION_FEE_RATE, \\\"Exceed max redemption fee rate\\\");\\n        redemptionFeeRate = newRedemptionFeeRate;\\n    }\\n\\n    function updateSplitFeeRate(uint256 newSplitFeeRate) external onlyOwner {\\n        require(newSplitFeeRate <= MAX_SPLIT_FEE_RATE, \\\"Exceed max split fee rate\\\");\\n        splitFeeRate = newSplitFeeRate;\\n    }\\n\\n    function updateMergeFeeRate(uint256 newMergeFeeRate) external onlyOwner {\\n        require(newMergeFeeRate <= MAX_MERGE_FEE_RATE, \\\"Exceed max merge fee rate\\\");\\n        mergeFeeRate = newMergeFeeRate;\\n    }\\n\\n    function updateMinCreationUnderlying(uint256 newMinCreationUnderlying) external onlyOwner {\\n        minCreationUnderlying = newMinCreationUnderlying;\\n    }\\n\\n    function _currentCreationRedemption(address account)\\n        private\\n        view\\n        returns (CreationRedemption memory cr)\\n    {\\n        cr = _creationRedemptions[account];\\n        uint256 oldDay = cr.day;\\n        if (oldDay < currentDay) {\\n            if (cr.creatingUnderlying > 0) {\\n                cr.createdShares = cr.createdShares.add(\\n                    cr.creatingUnderlying.multiplyDecimal(_historicalCreationRate[oldDay])\\n                );\\n                cr.creatingUnderlying = 0;\\n            }\\n            uint256 rebalanceSize = fund.getRebalanceSize();\\n            if (cr.version < rebalanceSize) {\\n                if (cr.createdShares > 0) {\\n                    (cr.createdShares, , ) = fund.batchRebalance(\\n                        cr.createdShares,\\n                        0,\\n                        0,\\n                        cr.version,\\n                        rebalanceSize\\n                    );\\n                }\\n                cr.version = rebalanceSize;\\n            }\\n            if (cr.redeemingShares > 0) {\\n                cr.redeemedUnderlying = cr.redeemedUnderlying.add(\\n                    cr.redeemingShares.multiplyDecimal(_historicalRedemptionRate[oldDay])\\n                );\\n                cr.redeemingShares = 0;\\n            }\\n            cr.day = currentDay;\\n        }\\n    }\\n\\n    function _updateCreationRedemption(address account, CreationRedemption memory cr) private {\\n        CreationRedemption storage old = _creationRedemptions[account];\\n        if (old.day != cr.day) {\\n            old.day = cr.day;\\n        }\\n        if (old.creatingUnderlying != cr.creatingUnderlying) {\\n            old.creatingUnderlying = cr.creatingUnderlying;\\n        }\\n        if (old.redeemingShares != cr.redeemingShares) {\\n            old.redeemingShares = cr.redeemingShares;\\n        }\\n        if (old.createdShares != cr.createdShares) {\\n            old.createdShares = cr.createdShares;\\n        }\\n        if (old.redeemedUnderlying != cr.redeemedUnderlying) {\\n            old.redeemedUnderlying = cr.redeemedUnderlying;\\n        }\\n        if (old.version != cr.version) {\\n            old.version = cr.version;\\n        }\\n    }\\n\\n    modifier onlyActive() {\\n        require(fund.isPrimaryMarketActive(address(this), block.timestamp), \\\"Only when active\\\");\\n        _;\\n    }\\n\\n    modifier onlyFund() {\\n        require(msg.sender == address(fund), \\\"Only fund\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/fund/PrimaryMarketV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"../../utils/SafeDecimalMath.sol\\\";\\n\\nimport {DelayedRedemption, LibDelayedRedemption} from \\\"./LibDelayedRedemption.sol\\\";\\n\\nimport \\\"../interfaces/IPrimaryMarketV2.sol\\\";\\nimport \\\"../interfaces/IFundV2.sol\\\";\\nimport \\\"../interfaces/ITrancheIndex.sol\\\";\\nimport \\\"../../interfaces/IWrappedERC20.sol\\\";\\n\\ncontract PrimaryMarketV2 is IPrimaryMarketV2, ReentrancyGuard, ITrancheIndex, Ownable {\\n    event Created(address indexed account, uint256 underlying);\\n    event Redeemed(address indexed account, uint256 shares);\\n    event Split(address indexed account, uint256 inM, uint256 outA, uint256 outB);\\n    event Merged(address indexed account, uint256 outM, uint256 inA, uint256 inB);\\n    event Claimed(address indexed account, uint256 createdShares, uint256 redeemedUnderlying);\\n    event Settled(\\n        uint256 indexed day,\\n        uint256 sharesToMint,\\n        uint256 sharesToBurn,\\n        uint256 creationUnderlying,\\n        uint256 redemptionUnderlying,\\n        uint256 fee\\n    );\\n    event RedemptionClaimable(uint256 indexed day);\\n    event FundCapUpdated(uint256 newCap);\\n    event RedemptionFeeRateUpdated(uint256 newRedemptionFeeRate);\\n    event SplitFeeRateUpdated(uint256 newSplitFeeRate);\\n    event MergeFeeRateUpdated(uint256 newMergeFeeRate);\\n    event MinCreationUnderlyingUpdated(uint256 newMinCreationUnderlying);\\n\\n    using SafeMath for uint256;\\n    using SafeDecimalMath for uint256;\\n    using SafeERC20 for IERC20;\\n    using LibDelayedRedemption for DelayedRedemption;\\n\\n    /// @dev Creation and redemption of a single account.\\n    /// @param day Day of the last creation or redemption request.\\n    /// @param creatingUnderlying Underlying that will be used for creation at the end of this day.\\n    /// @param redeemingShares Shares that will be redeemed at the end of this day.\\n    /// @param createdShares Shares already created in previous days.\\n    /// @param redeemedUnderlying Underlying already redeemed in previous days.\\n    /// @param version Rebalance version before the end of this trading day.\\n    struct CreationRedemption {\\n        uint256 day;\\n        uint256 creatingUnderlying;\\n        uint256 redeemingShares;\\n        uint256 createdShares;\\n        uint256 redeemedUnderlying;\\n        uint256 version;\\n    }\\n\\n    uint256 private constant MAX_REDEMPTION_FEE_RATE = 0.01e18;\\n    uint256 private constant MAX_SPLIT_FEE_RATE = 0.01e18;\\n    uint256 private constant MAX_MERGE_FEE_RATE = 0.01e18;\\n    uint256 private constant MAX_ITERATIONS = 500;\\n\\n    IFundV2 public immutable fund;\\n    IERC20 private immutable _tokenUnderlying;\\n\\n    uint256 public redemptionFeeRate;\\n    uint256 public splitFeeRate;\\n    uint256 public mergeFeeRate;\\n    uint256 public minCreationUnderlying;\\n\\n    mapping(address => CreationRedemption) private _creationRedemptions;\\n\\n    uint256 public currentDay;\\n    uint256 public currentCreatingUnderlying;\\n    uint256 public currentRedeemingShares;\\n    uint256 public currentFeeInShares;\\n\\n    mapping(uint256 => uint256) private _historicalCreationRate;\\n    mapping(uint256 => uint256) private _historicalRedemptionRate;\\n\\n    /// @notice The upper limit of underlying that the fund can hold. This contract rejects\\n    ///         creations that may break this limit.\\n    /// @dev This limit can be bypassed if the fund has multiple primary markets.\\n    ///\\n    ///      Set it to uint(-1) to skip the check and save gas.\\n    uint256 public fundCap;\\n\\n    /// @notice The first trading day on which redemptions cannot be claimed now.\\n    uint256 public delayedRedemptionDay;\\n\\n    /// @dev Mapping of trading day => total redeemed underlying if users cannot claim their\\n    ///      redemptions on that day, or zero otherwise.\\n    mapping(uint256 => uint256) private _delayedUnderlyings;\\n\\n    /// @dev The total amount of redeemed underlying that can be claimed by users.\\n    uint256 private _claimableUnderlying;\\n\\n    /// @dev Mapping of account => a list of redemptions that have been settled\\n    ///      but are not claimable yet.\\n    mapping(address => DelayedRedemption) private _delayedRedemptions;\\n\\n    constructor(\\n        address fund_,\\n        uint256 redemptionFeeRate_,\\n        uint256 splitFeeRate_,\\n        uint256 mergeFeeRate_,\\n        uint256 minCreationUnderlying_,\\n        uint256 fundCap_\\n    ) public Ownable() {\\n        require(redemptionFeeRate_ <= MAX_REDEMPTION_FEE_RATE, \\\"Exceed max redemption fee rate\\\");\\n        require(splitFeeRate_ <= MAX_SPLIT_FEE_RATE, \\\"Exceed max split fee rate\\\");\\n        require(mergeFeeRate_ <= MAX_MERGE_FEE_RATE, \\\"Exceed max merge fee rate\\\");\\n        fund = IFundV2(fund_);\\n        _tokenUnderlying = IERC20(IFund(fund_).tokenUnderlying());\\n        redemptionFeeRate = redemptionFeeRate_;\\n        splitFeeRate = splitFeeRate_;\\n        mergeFeeRate = mergeFeeRate_;\\n        minCreationUnderlying = minCreationUnderlying_;\\n        currentDay = IFund(fund_).currentDay();\\n        fundCap = fundCap_;\\n        delayedRedemptionDay = currentDay;\\n    }\\n\\n    /// @dev Unlike the previous version, this function updates states of the account and is not\\n    ///      \\\"view\\\" any more. To get the return value off-chain, please call this function\\n    ///      using `contract.creationRedemptionOf.call(account)` in web3\\n    ///      or `contract.callStatic.creationRedemptionOf(account)` in ethers.js.\\n    function creationRedemptionOf(address account) external returns (CreationRedemption memory) {\\n        _updateDelayedRedemptionDay();\\n        _updateUser(account);\\n        return _creationRedemptions[account];\\n    }\\n\\n    /// @notice Return delayed redemption of an account on a trading day.\\n    /// @param account Address of the account\\n    /// @param day A trading day\\n    /// @return underlying Redeemed underlying amount\\n    /// @return nextDay Trading day of the next delayed redemption, or zero if there's no\\n    ///                 delayed redemption on the given day or it is the last redemption\\n    function getDelayedRedemption(address account, uint256 day)\\n        external\\n        view\\n        returns (uint256 underlying, uint256 nextDay)\\n    {\\n        return _delayedRedemptions[account].get(day);\\n    }\\n\\n    /// @notice Return trading day of the first delayed redemption of an account.\\n    function getDelayedRedemptionHead(address account) external view returns (uint256) {\\n        return _delayedRedemptions[account].headTail.head;\\n    }\\n\\n    function updateDelayedRedemptionDay() external override nonReentrant {\\n        _updateDelayedRedemptionDay();\\n    }\\n\\n    function create(uint256 underlying) external nonReentrant {\\n        _tokenUnderlying.safeTransferFrom(msg.sender, address(this), underlying);\\n        _create(underlying);\\n    }\\n\\n    function wrapAndCreate() external payable nonReentrant {\\n        IWrappedERC20(address(_tokenUnderlying)).deposit{value: msg.value}();\\n        _create(msg.value);\\n    }\\n\\n    function _create(uint256 underlying) private onlyActive {\\n        require(underlying >= minCreationUnderlying, \\\"Min amount\\\");\\n\\n        // Do not call `_updateDelayedRedemptionDay()` because the latest `redeemedUnderlying`\\n        // is not used in this function.\\n        _updateUser(msg.sender);\\n        CreationRedemption storage cr = _creationRedemptions[msg.sender];\\n        cr.creatingUnderlying = cr.creatingUnderlying.add(underlying);\\n\\n        uint256 creatingUnderlying = currentCreatingUnderlying.add(underlying);\\n        currentCreatingUnderlying = creatingUnderlying;\\n\\n        uint256 cap = fundCap;\\n        if (cap != uint256(-1)) {\\n            require(\\n                fund.historicalUnderlying(currentDay - 1 days).add(creatingUnderlying) <= cap,\\n                \\\"Exceed fund cap\\\"\\n            );\\n        }\\n\\n        emit Created(msg.sender, underlying);\\n    }\\n\\n    function redeem(uint256 shares) external nonReentrant onlyActive {\\n        require(shares != 0, \\\"Zero shares\\\");\\n        // Use burn and mint to simulate a transfer, so that we don't need a special transferFrom()\\n        fund.burn(TRANCHE_M, msg.sender, shares);\\n        fund.mint(TRANCHE_M, address(this), shares);\\n\\n        // Do not call `_updateDelayedRedemptionDay()` because the latest `redeemedUnderlying`\\n        // is not used in this function.\\n        _updateUser(msg.sender);\\n        CreationRedemption storage cr = _creationRedemptions[msg.sender];\\n        cr.redeemingShares = cr.redeemingShares.add(shares);\\n\\n        currentRedeemingShares = currentRedeemingShares.add(shares);\\n        emit Redeemed(msg.sender, shares);\\n    }\\n\\n    function claim(address account)\\n        external\\n        override\\n        nonReentrant\\n        returns (uint256 createdShares, uint256 redeemedUnderlying)\\n    {\\n        (createdShares, redeemedUnderlying) = _claim(account);\\n        if (createdShares > 0) {\\n            IERC20(fund.tokenM()).safeTransfer(account, createdShares);\\n        }\\n        if (redeemedUnderlying > 0) {\\n            _tokenUnderlying.safeTransfer(account, redeemedUnderlying);\\n        }\\n    }\\n\\n    function claimAndUnwrap(address account)\\n        external\\n        override\\n        nonReentrant\\n        returns (uint256 createdShares, uint256 redeemedUnderlying)\\n    {\\n        (createdShares, redeemedUnderlying) = _claim(account);\\n        if (createdShares > 0) {\\n            IERC20(fund.tokenM()).safeTransfer(account, createdShares);\\n        }\\n        if (redeemedUnderlying > 0) {\\n            IWrappedERC20(address(_tokenUnderlying)).withdraw(redeemedUnderlying);\\n            (bool success, ) = account.call{value: redeemedUnderlying}(\\\"\\\");\\n            require(success, \\\"Transfer failed\\\");\\n        }\\n    }\\n\\n    function _claim(address account)\\n        private\\n        returns (uint256 createdShares, uint256 redeemedUnderlying)\\n    {\\n        _updateDelayedRedemptionDay();\\n        _updateUser(account);\\n        CreationRedemption storage cr = _creationRedemptions[account];\\n        createdShares = cr.createdShares;\\n        redeemedUnderlying = cr.redeemedUnderlying;\\n\\n        if (createdShares > 0) {\\n            cr.createdShares = 0;\\n        }\\n        if (redeemedUnderlying > 0) {\\n            _claimableUnderlying = _claimableUnderlying.sub(redeemedUnderlying);\\n            cr.redeemedUnderlying = 0;\\n        }\\n\\n        emit Claimed(account, createdShares, redeemedUnderlying);\\n        return (createdShares, redeemedUnderlying);\\n    }\\n\\n    function split(uint256 inM) external onlyActive {\\n        (uint256 weightA, uint256 weightB) = fund.trancheWeights();\\n        // Charge splitting fee and round it to a multiple of (weightA + weightB)\\n        uint256 unit = inM.sub(inM.multiplyDecimal(splitFeeRate)) / (weightA + weightB);\\n        require(unit > 0, \\\"Too little to split\\\");\\n        uint256 inMAfterFee = unit * (weightA + weightB);\\n        uint256 outA = unit * weightA;\\n        uint256 outB = inMAfterFee - outA;\\n        uint256 feeM = inM - inMAfterFee;\\n\\n        fund.burn(TRANCHE_M, msg.sender, inM);\\n        fund.mint(TRANCHE_A, msg.sender, outA);\\n        fund.mint(TRANCHE_B, msg.sender, outB);\\n        fund.mint(TRANCHE_M, address(this), feeM);\\n\\n        currentFeeInShares = currentFeeInShares.add(feeM);\\n        emit Split(msg.sender, inM, outA, outB);\\n    }\\n\\n    function merge(uint256 inA) external onlyActive {\\n        (uint256 weightA, uint256 weightB) = fund.trancheWeights();\\n        // Round to tranche weights\\n        uint256 unit = inA / weightA;\\n        require(unit > 0, \\\"Too little to merge\\\");\\n        // Keep unmergable Token A unchanged.\\n        inA = unit * weightA;\\n        uint256 inB = unit.mul(weightB);\\n        uint256 outMBeforeFee = inA.add(inB);\\n        uint256 feeM = outMBeforeFee.multiplyDecimal(mergeFeeRate);\\n        uint256 outM = outMBeforeFee.sub(feeM);\\n\\n        fund.burn(TRANCHE_A, msg.sender, inA);\\n        fund.burn(TRANCHE_B, msg.sender, inB);\\n        fund.mint(TRANCHE_M, msg.sender, outM);\\n        fund.mint(TRANCHE_M, address(this), feeM);\\n\\n        currentFeeInShares = currentFeeInShares.add(feeM);\\n        emit Merged(msg.sender, outM, inA, inB);\\n    }\\n\\n    /// @notice Settle ongoing creations and redemptions and also split and merge fees.\\n    ///\\n    ///         Creations and redemptions are settled according to the current shares and\\n    ///         underlying assets in the fund. Split and merge fee charged as Token M are also\\n    ///         redeemed at the same rate (without redemption fee).\\n    ///\\n    ///         This function does not mint or burn shares, nor transfer underlying assets.\\n    ///         It returns the following changes that should be done by the fund:\\n    ///\\n    ///         1. Mint or burn net shares (creations v.s. redemptions + split/merge fee).\\n    ///         2. Transfer underlying to or from this contract (creations v.s. redemptions).\\n    ///         3. Transfer fee in underlying assets to the governance address.\\n    ///\\n    ///         This function can only be called from the Fund contract. It should be called\\n    ///         after protocol fee is collected and before rebalance is triggered for the same\\n    ///         trading day.\\n    /// @param day The trading day to settle\\n    /// @param fundTotalShares Total shares of the fund (as if all Token A and B are merged)\\n    /// @param fundUnderlying Underlying assets in the fund\\n    /// @param underlyingPrice Price of the underlying assets at the end of the trading day\\n    /// @param previousNav NAV of Token M of the previous trading day\\n    /// @return sharesToMint Amount of Token M to mint for creations\\n    /// @return sharesToBurn Amount of Token M to burn for redemptions and split/merge fee\\n    /// @return creationUnderlying Underlying assets received for creations (including creation fee)\\n    /// @return redemptionUnderlying Underlying assets to be redeemed (excluding redemption fee)\\n    /// @return fee Total fee in underlying assets for the fund to transfer to the governance address,\\n    ///         inlucding creation fee, redemption fee and split/merge fee\\n    function settle(\\n        uint256 day,\\n        uint256 fundTotalShares,\\n        uint256 fundUnderlying,\\n        uint256 underlyingPrice,\\n        uint256 previousNav\\n    )\\n        external\\n        override\\n        nonReentrant\\n        onlyFund\\n        returns (\\n            uint256 sharesToMint,\\n            uint256 sharesToBurn,\\n            uint256 creationUnderlying,\\n            uint256 redemptionUnderlying,\\n            uint256 fee\\n        )\\n    {\\n        require(day >= currentDay, \\\"Already settled\\\");\\n\\n        // Creation\\n        creationUnderlying = currentCreatingUnderlying;\\n        if (creationUnderlying > 0) {\\n            if (fundUnderlying > 0) {\\n                sharesToMint = creationUnderlying.mul(fundTotalShares).div(fundUnderlying);\\n            } else {\\n                // NAV is rounded down. Computing creations using NAV results in rounded up shares,\\n                // which is unfair to existing share holders. We only do that when there are\\n                // no shares before.\\n                require(\\n                    fundTotalShares == 0,\\n                    \\\"Cannot create shares for fund with shares but no underlying\\\"\\n                );\\n                require(previousNav > 0, \\\"Cannot create shares at zero NAV\\\");\\n                sharesToMint = creationUnderlying\\n                    .mul(underlyingPrice)\\n                    .mul(fund.underlyingDecimalMultiplier())\\n                    .div(previousNav);\\n            }\\n            _historicalCreationRate[day] = sharesToMint.divideDecimal(creationUnderlying);\\n        }\\n\\n        // Redemption\\n        sharesToBurn = currentRedeemingShares;\\n        if (sharesToBurn > 0) {\\n            uint256 underlying = sharesToBurn.mul(fundUnderlying).div(fundTotalShares);\\n            uint256 redemptionFee = underlying.multiplyDecimal(redemptionFeeRate);\\n            redemptionUnderlying = underlying.sub(redemptionFee);\\n            _historicalRedemptionRate[day] = redemptionUnderlying.divideDecimal(sharesToBurn);\\n            fee = redemptionFee;\\n        }\\n\\n        // Redeem split and merge fee\\n        uint256 feeInShares = currentFeeInShares;\\n        if (feeInShares > 0) {\\n            sharesToBurn = sharesToBurn.add(feeInShares);\\n            fee = fee.add(feeInShares.mul(fundUnderlying).div(fundTotalShares));\\n        }\\n\\n        // Approve the fund to take underlying if creation is more than redemption.\\n        // Instead of directly transfering underlying to the fund, this implementation\\n        // makes testing much easier.\\n        if (creationUnderlying > redemptionUnderlying) {\\n            // Do not use `SafeERC20.safeApprove()` because the previous allowance\\n            // may be non-zero when there were some delayed redemptions.\\n            _tokenUnderlying.approve(address(fund), creationUnderlying - redemptionUnderlying);\\n        }\\n\\n        // This loop should never execute, because this function is called by Fund\\n        // for every day. We fill the gap just in case that something goes wrong in Fund.\\n        for (uint256 t = currentDay; t < day; t += 1 days) {\\n            _historicalCreationRate[t] = _historicalCreationRate[day];\\n            _historicalRedemptionRate[t] = _historicalRedemptionRate[day];\\n        }\\n\\n        _delayedUnderlyings[day] = redemptionUnderlying;\\n        currentDay = day + 1 days;\\n        currentCreatingUnderlying = 0;\\n        currentRedeemingShares = 0;\\n        currentFeeInShares = 0;\\n        emit Settled(\\n            day,\\n            sharesToMint,\\n            sharesToBurn,\\n            creationUnderlying,\\n            redemptionUnderlying,\\n            fee\\n        );\\n    }\\n\\n    function updateFundCap(uint256 newCap) external onlyOwner {\\n        fundCap = newCap;\\n        emit FundCapUpdated(newCap);\\n    }\\n\\n    function updateRedemptionFeeRate(uint256 newRedemptionFeeRate) external onlyOwner {\\n        require(newRedemptionFeeRate <= MAX_REDEMPTION_FEE_RATE, \\\"Exceed max redemption fee rate\\\");\\n        redemptionFeeRate = newRedemptionFeeRate;\\n        emit RedemptionFeeRateUpdated(newRedemptionFeeRate);\\n    }\\n\\n    function updateSplitFeeRate(uint256 newSplitFeeRate) external onlyOwner {\\n        require(newSplitFeeRate <= MAX_SPLIT_FEE_RATE, \\\"Exceed max split fee rate\\\");\\n        splitFeeRate = newSplitFeeRate;\\n        emit SplitFeeRateUpdated(newSplitFeeRate);\\n    }\\n\\n    function updateMergeFeeRate(uint256 newMergeFeeRate) external onlyOwner {\\n        require(newMergeFeeRate <= MAX_MERGE_FEE_RATE, \\\"Exceed max merge fee rate\\\");\\n        mergeFeeRate = newMergeFeeRate;\\n        emit MergeFeeRateUpdated(newMergeFeeRate);\\n    }\\n\\n    function updateMinCreationUnderlying(uint256 newMinCreationUnderlying) external onlyOwner {\\n        minCreationUnderlying = newMinCreationUnderlying;\\n        emit MinCreationUnderlyingUpdated(newMinCreationUnderlying);\\n    }\\n\\n    /// @dev Update the status of an account.\\n    ///      1. If there is a pending creation before the last settlement, calculate its result\\n    ///         and add it to `createdShares`.\\n    ///      2. If there is a pending redemption before the last settlement, calculate its result.\\n    ///         Add the result to `redeemedUnderlying` if it can be claimed now. Otherwise, append\\n    ///         the result to the account's delayed redemption list.\\n    ///      3. Check the account's delayed redemption list. Remove the redemptions that can be\\n    ///         claimed now from the list and add them to `redeemedUnderlying`. Note that\\n    ///         if `_updateDelayedRedemptionDay()` is not called before this function, some\\n    ///         claimable redemption may not be correctly recognized and `redeemedUnderlying` may\\n    ///         be smaller than the actual amount that the user can claim.\\n    function _updateUser(address account) private {\\n        CreationRedemption storage cr = _creationRedemptions[account];\\n        uint256 oldDay = cr.day;\\n        uint256 newDay = currentDay;\\n        if (oldDay < newDay) {\\n            cr.day = newDay;\\n            uint256 oldCreatingUnderlying = cr.creatingUnderlying;\\n            uint256 oldCreatedShares = cr.createdShares;\\n            uint256 newCreatedShares = oldCreatedShares;\\n            if (oldCreatingUnderlying > 0) {\\n                newCreatedShares = newCreatedShares.add(\\n                    oldCreatingUnderlying.multiplyDecimal(_historicalCreationRate[oldDay])\\n                );\\n                cr.creatingUnderlying = 0;\\n            }\\n            uint256 rebalanceSize = fund.getRebalanceSize();\\n            uint256 oldVersion = cr.version;\\n            if (oldVersion < rebalanceSize) {\\n                if (newCreatedShares > 0) {\\n                    (newCreatedShares, , ) = fund.batchRebalance(\\n                        newCreatedShares,\\n                        0,\\n                        0,\\n                        oldVersion,\\n                        rebalanceSize\\n                    );\\n                }\\n                cr.version = rebalanceSize;\\n            }\\n            if (newCreatedShares != oldCreatedShares) {\\n                cr.createdShares = newCreatedShares;\\n            }\\n\\n            uint256 oldRedeemingShares = cr.redeemingShares;\\n            if (oldRedeemingShares > 0) {\\n                uint256 underlying =\\n                    oldRedeemingShares.multiplyDecimal(_historicalRedemptionRate[oldDay]);\\n                cr.redeemingShares = 0;\\n                if (oldDay < delayedRedemptionDay) {\\n                    cr.redeemedUnderlying = cr.redeemedUnderlying.add(underlying);\\n                } else {\\n                    _delayedRedemptions[account].pushBack(underlying, oldDay);\\n                }\\n            }\\n        }\\n\\n        uint256 delayedUnderlying =\\n            _delayedRedemptions[account].popFrontUntil(delayedRedemptionDay - 1 days);\\n        if (delayedUnderlying > 0) {\\n            cr.redeemedUnderlying = cr.redeemedUnderlying.add(delayedUnderlying);\\n        }\\n    }\\n\\n    /// @dev Move `delayedRedemptionDay` forward when there are enough underlying tokens in\\n    ///      this contract.\\n    function _updateDelayedRedemptionDay() private returns (uint256) {\\n        uint256 oldDelayedRedemptionDay = delayedRedemptionDay;\\n        uint256 currentDay_ = currentDay;\\n        if (oldDelayedRedemptionDay >= currentDay_) {\\n            return oldDelayedRedemptionDay; // Fast path to return\\n        }\\n        uint256 newDelayedRedemptionDay = oldDelayedRedemptionDay;\\n        uint256 claimableUnderlying = _claimableUnderlying;\\n        uint256 balance = _tokenUnderlying.balanceOf(address(this)).sub(claimableUnderlying);\\n        for (uint256 i = 0; i < MAX_ITERATIONS && newDelayedRedemptionDay < currentDay_; i++) {\\n            uint256 underlying = _delayedUnderlyings[newDelayedRedemptionDay];\\n            if (underlying > balance) {\\n                break;\\n            }\\n            balance -= underlying;\\n            claimableUnderlying = claimableUnderlying.add(underlying);\\n            emit RedemptionClaimable(newDelayedRedemptionDay);\\n            newDelayedRedemptionDay += 1 days;\\n        }\\n        if (newDelayedRedemptionDay != oldDelayedRedemptionDay) {\\n            delayedRedemptionDay = newDelayedRedemptionDay;\\n            _claimableUnderlying = claimableUnderlying;\\n        }\\n        return newDelayedRedemptionDay;\\n    }\\n\\n    /// @notice Receive unwrapped transfer from the wrapped token.\\n    receive() external payable {}\\n\\n    modifier onlyActive() {\\n        require(fund.isPrimaryMarketActive(address(this), block.timestamp), \\\"Only when active\\\");\\n        _;\\n    }\\n\\n    modifier onlyFund() {\\n        require(msg.sender == address(fund), \\\"Only fund\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/governance/InterestRateBallot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"../utils/CoreUtility.sol\\\";\\n\\nimport \\\"../interfaces/IBallot.sol\\\";\\nimport \\\"../interfaces/IVotingEscrow.sol\\\";\\n\\ncontract InterestRateBallot is IBallot, CoreUtility {\\n    using SafeMath for uint256;\\n\\n    event Voted(\\n        address indexed account,\\n        uint256 oldAmount,\\n        uint256 oldUnlockTime,\\n        uint256 oldWeight,\\n        uint256 amount,\\n        uint256 indexed unlockTime,\\n        uint256 indexed weight\\n    );\\n\\n    uint256 private immutable _maxTime;\\n\\n    uint256 public constant stepSize = 0.02e18;\\n    uint256 public constant minRange = 0;\\n    uint256 public constant maxOption = 3;\\n\\n    IVotingEscrow public immutable votingEscrow;\\n\\n    mapping(address => Voter) public voters;\\n\\n    // unlockTime => amount that will be unlocked at unlockTime\\n    mapping(uint256 => uint256) public scheduledUnlock;\\n    mapping(uint256 => uint256) public scheduledWeightedUnlock;\\n\\n    constructor(address votingEscrow_) public {\\n        votingEscrow = IVotingEscrow(votingEscrow_);\\n        _maxTime = IVotingEscrow(votingEscrow_).maxTime();\\n    }\\n\\n    function getWeight(uint256 index) public pure returns (uint256) {\\n        uint256 delta = stepSize.mul(index);\\n        return minRange.add(delta);\\n    }\\n\\n    function getReceipt(address account) external view returns (Voter memory) {\\n        return voters[account];\\n    }\\n\\n    function balanceOf(address account) external view returns (uint256) {\\n        return _balanceOfAtTimestamp(account, block.timestamp);\\n    }\\n\\n    function totalSupply() external view returns (uint256) {\\n        return _totalSupplyAtTimestamp(block.timestamp);\\n    }\\n\\n    function balanceOfAtTimestamp(address account, uint256 timestamp)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return _balanceOfAtTimestamp(account, timestamp);\\n    }\\n\\n    function totalSupplyAtTimestamp(uint256 timestamp) external view returns (uint256) {\\n        return _totalSupplyAtTimestamp(timestamp);\\n    }\\n\\n    function sumAtTimestamp(uint256 timestamp) external view returns (uint256) {\\n        return _sumAtTimestamp(timestamp);\\n    }\\n\\n    function count(uint256 timestamp) external view override returns (uint256) {\\n        return _averageAtTimestamp(timestamp);\\n    }\\n\\n    function cast(uint256 option) external {\\n        require(option < maxOption, \\\"Invalid option\\\");\\n\\n        IVotingEscrow.LockedBalance memory lockedBalance =\\n            votingEscrow.getLockedBalance(msg.sender);\\n        Voter memory voter = voters[msg.sender];\\n        uint256 weight = getWeight(option);\\n        require(lockedBalance.amount > 0, \\\"Zero value\\\");\\n\\n        // update scheduled unlock\\n        scheduledUnlock[voter.unlockTime] = scheduledUnlock[voter.unlockTime].sub(voter.amount);\\n        scheduledUnlock[lockedBalance.unlockTime] = scheduledUnlock[lockedBalance.unlockTime].add(\\n            lockedBalance.amount\\n        );\\n\\n        scheduledWeightedUnlock[voter.unlockTime] = scheduledWeightedUnlock[voter.unlockTime].sub(\\n            voter.amount * voter.weight\\n        );\\n        scheduledWeightedUnlock[lockedBalance.unlockTime] = scheduledWeightedUnlock[\\n            lockedBalance.unlockTime\\n        ]\\n            .add(lockedBalance.amount * weight);\\n\\n        emit Voted(\\n            msg.sender,\\n            voter.amount,\\n            voter.unlockTime,\\n            voter.weight,\\n            lockedBalance.amount,\\n            lockedBalance.unlockTime,\\n            weight\\n        );\\n\\n        // update voter amount per account\\n        voters[msg.sender] = Voter({\\n            amount: lockedBalance.amount,\\n            unlockTime: lockedBalance.unlockTime,\\n            weight: weight\\n        });\\n    }\\n\\n    function syncWithVotingEscrow(address account) external override {\\n        Voter memory voter = voters[account];\\n        if (voter.amount == 0) {\\n            return; // The account did not voted before\\n        }\\n\\n        IVotingEscrow.LockedBalance memory lockedBalance = votingEscrow.getLockedBalance(account);\\n        if (lockedBalance.unlockTime <= block.timestamp) {\\n            return;\\n        }\\n\\n        // update scheduled unlock\\n        scheduledUnlock[voter.unlockTime] = scheduledUnlock[voter.unlockTime].sub(voter.amount);\\n        scheduledUnlock[lockedBalance.unlockTime] = scheduledUnlock[lockedBalance.unlockTime].add(\\n            lockedBalance.amount\\n        );\\n\\n        scheduledWeightedUnlock[voter.unlockTime] = scheduledWeightedUnlock[voter.unlockTime].sub(\\n            voter.amount * voter.weight\\n        );\\n        scheduledWeightedUnlock[lockedBalance.unlockTime] = scheduledWeightedUnlock[\\n            lockedBalance.unlockTime\\n        ]\\n            .add(lockedBalance.amount * voter.weight);\\n\\n        emit Voted(\\n            account,\\n            voter.amount,\\n            voter.unlockTime,\\n            voter.weight,\\n            lockedBalance.amount,\\n            lockedBalance.unlockTime,\\n            voter.weight\\n        );\\n\\n        // update voter amount per account\\n        voters[account].amount = lockedBalance.amount;\\n        voters[account].unlockTime = lockedBalance.unlockTime;\\n    }\\n\\n    function _balanceOfAtTimestamp(address account, uint256 timestamp)\\n        private\\n        view\\n        returns (uint256)\\n    {\\n        require(timestamp >= block.timestamp, \\\"Must be current or future time\\\");\\n        Voter memory voter = voters[account];\\n        if (timestamp > voter.unlockTime) {\\n            return 0;\\n        }\\n        return (voter.amount * (voter.unlockTime - timestamp)) / _maxTime;\\n    }\\n\\n    function _totalSupplyAtTimestamp(uint256 timestamp) private view returns (uint256) {\\n        uint256 total = 0;\\n        for (\\n            uint256 weekCursor = _endOfWeek(timestamp);\\n            weekCursor <= timestamp + _maxTime;\\n            weekCursor += 1 weeks\\n        ) {\\n            total += (scheduledUnlock[weekCursor] * (weekCursor - timestamp)) / _maxTime;\\n        }\\n\\n        return total;\\n    }\\n\\n    function _sumAtTimestamp(uint256 timestamp) private view returns (uint256) {\\n        uint256 sum = 0;\\n        for (\\n            uint256 weekCursor = _endOfWeek(timestamp);\\n            weekCursor <= timestamp + _maxTime;\\n            weekCursor += 1 weeks\\n        ) {\\n            sum += (scheduledWeightedUnlock[weekCursor] * (weekCursor - timestamp)) / _maxTime;\\n        }\\n\\n        return sum;\\n    }\\n\\n    function _averageAtTimestamp(uint256 timestamp) private view returns (uint256) {\\n        uint256 sum = 0;\\n        uint256 total = 0;\\n        for (\\n            uint256 weekCursor = _endOfWeek(timestamp);\\n            weekCursor <= timestamp + _maxTime;\\n            weekCursor += 1 weeks\\n        ) {\\n            sum += (scheduledWeightedUnlock[weekCursor] * (weekCursor - timestamp)) / _maxTime;\\n            total += (scheduledUnlock[weekCursor] * (weekCursor - timestamp)) / _maxTime;\\n        }\\n\\n        if (total == 0) {\\n            return getWeight(maxOption.sub(1) / 2);\\n        }\\n        return sum / total;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/governance/FeeDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"../utils/SafeDecimalMath.sol\\\";\\nimport \\\"../utils/CoreUtility.sol\\\";\\n\\nimport \\\"../interfaces/IVotingEscrow.sol\\\";\\nimport \\\"../interfaces/IWrappedERC20.sol\\\";\\n\\ncontract FeeDistributor is CoreUtility, Ownable {\\n    using SafeMath for uint256;\\n    using SafeDecimalMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    event AdminUpdated(address newAdmin);\\n    event AdminFeeRateUpdated(uint256 newAdminFeeRate);\\n\\n    /// @notice 60% as the max admin fee rate\\n    uint256 public constant MAX_ADMIN_FEE_RATE = 6e17;\\n\\n    uint256 private immutable _maxTime;\\n    IERC20 public immutable rewardToken;\\n    IVotingEscrow public immutable votingEscrow;\\n\\n    /// @notice Receiver for admin fee\\n    address public admin;\\n\\n    /// @notice Admin fee rate\\n    uint256 public adminFeeRate;\\n\\n    /// @notice Timestamp of the last checkpoint\\n    uint256 public checkpointTimestamp;\\n\\n    /// @notice Mapping of unlockTime => total amount that will be unlocked at unlockTime\\n    mapping(uint256 => uint256) public scheduledUnlock;\\n\\n    /// @notice Amount of Chess locked at the end of the last checkpoint's week\\n    uint256 public nextWeekLocked;\\n\\n    /// @notice Total veCHESS at the end of the last checkpoint's week\\n    uint256 public nextWeekSupply;\\n\\n    /// @notice Cumulative rewards received until the last checkpoint minus cumulative rewards\\n    ///         claimed until now\\n    uint256 public lastRewardBalance;\\n\\n    /// @notice Mapping of week => total rewards accumulated\\n    ///\\n    ///         Key is the start timestamp of a week on each Thursday. Value is\\n    ///         the rewards collected from the corresponding fund in rewardToken's unit\\n    mapping(uint256 => uint256) public rewardsPerWeek;\\n\\n    /// @notice Mapping of week => vote-locked chess total supplies\\n    ///\\n    ///         Key is the start timestamp of a week on each Thursday. Value is\\n    ///         vote-locked chess total supplies captured at the start of each week\\n    mapping(uint256 => uint256) public veSupplyPerWeek;\\n\\n    /// @notice Locked balance of an account, which is synchronized with `VotingEscrow` when\\n    ///         `syncWithVotingEscrow()` is called\\n    mapping(address => IVotingEscrow.LockedBalance) public userLockedBalances;\\n\\n    /// @notice Start timestamp of the week of a user's last checkpoint\\n    mapping(address => uint256) public userWeekCursors;\\n\\n    /// @notice An account's veCHESS amount at the beginning of the week of this user's\\n    ///         last checkpoint\\n    mapping(address => uint256) public userLastBalances;\\n\\n    /// @notice Mapping of account => amount of claimable Chess\\n    mapping(address => uint256) public claimableRewards;\\n\\n    event Synchronized(\\n        address indexed account,\\n        uint256 oldAmount,\\n        uint256 oldUnlockTime,\\n        uint256 newAmount,\\n        uint256 newUnlockTime\\n    );\\n\\n    constructor(\\n        address rewardToken_,\\n        address votingEscrow_,\\n        address admin_,\\n        uint256 adminFeeRate_\\n    ) public {\\n        rewardToken = IERC20(rewardToken_);\\n        votingEscrow = IVotingEscrow(votingEscrow_);\\n        _maxTime = IVotingEscrow(votingEscrow_).maxTime();\\n        _updateAdmin(admin_);\\n        _updateAdminFeeRate(adminFeeRate_);\\n        checkpointTimestamp = block.timestamp;\\n    }\\n\\n    function balanceOf(address account) external view returns (uint256) {\\n        return _balanceAtTimestamp(userLockedBalances[account], block.timestamp);\\n    }\\n\\n    function totalSupply() external view returns (uint256) {\\n        return _totalSupplyAtTimestamp(block.timestamp);\\n    }\\n\\n    function balanceOfAtTimestamp(address account, uint256 timestamp)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        require(timestamp >= checkpointTimestamp, \\\"Must be current or future time\\\");\\n        return _balanceAtTimestamp(userLockedBalances[account], timestamp);\\n    }\\n\\n    function totalSupplyAtTimestamp(uint256 timestamp) external view returns (uint256) {\\n        require(timestamp >= checkpointTimestamp, \\\"Must be current or future time\\\");\\n        return _totalSupplyAtTimestamp(timestamp);\\n    }\\n\\n    /// @dev Calculate the amount of veCHESS of a `LockedBalance` at a given timestamp\\n    function _balanceAtTimestamp(\\n        IVotingEscrow.LockedBalance memory lockedBalance,\\n        uint256 timestamp\\n    ) private view returns (uint256) {\\n        if (timestamp >= lockedBalance.unlockTime) {\\n            return 0;\\n        }\\n        return lockedBalance.amount.mul(lockedBalance.unlockTime - timestamp) / _maxTime;\\n    }\\n\\n    function _totalSupplyAtTimestamp(uint256 timestamp) private view returns (uint256) {\\n        uint256 total = 0;\\n        for (\\n            uint256 weekCursor = _endOfWeek(timestamp);\\n            weekCursor <= timestamp + _maxTime;\\n            weekCursor += 1 weeks\\n        ) {\\n            total = total.add((scheduledUnlock[weekCursor].mul(weekCursor - timestamp)) / _maxTime);\\n        }\\n        return total;\\n    }\\n\\n    /// @notice Synchronize an account's locked Chess with `VotingEscrow`.\\n    /// @param account Address of the synchronized account\\n    function syncWithVotingEscrow(address account) external {\\n        userCheckpoint(account);\\n\\n        uint256 nextWeek = _endOfWeek(block.timestamp);\\n        IVotingEscrow.LockedBalance memory newLockedBalance =\\n            votingEscrow.getLockedBalance(account);\\n        if (newLockedBalance.unlockTime <= nextWeek) {\\n            return;\\n        }\\n        IVotingEscrow.LockedBalance memory oldLockedBalance = userLockedBalances[account];\\n        uint256 newNextWeekLocked = nextWeekLocked;\\n        uint256 newNextWeekSupply = nextWeekSupply;\\n\\n        // Remove the old schedule if there is one\\n        if (oldLockedBalance.amount > 0 && oldLockedBalance.unlockTime > nextWeek) {\\n            scheduledUnlock[oldLockedBalance.unlockTime] = scheduledUnlock[\\n                oldLockedBalance.unlockTime\\n            ]\\n                .sub(oldLockedBalance.amount);\\n            newNextWeekLocked = newNextWeekLocked.sub(oldLockedBalance.amount);\\n            newNextWeekSupply = newNextWeekSupply.sub(\\n                oldLockedBalance.amount.mul(oldLockedBalance.unlockTime - nextWeek) / _maxTime\\n            );\\n        }\\n\\n        scheduledUnlock[newLockedBalance.unlockTime] = scheduledUnlock[newLockedBalance.unlockTime]\\n            .add(newLockedBalance.amount);\\n        nextWeekLocked = newNextWeekLocked.add(newLockedBalance.amount);\\n        // Round up on division when added to the total supply, so that the total supply is never\\n        // smaller than the sum of all accounts' veCHESS balance.\\n        nextWeekSupply = newNextWeekSupply.add(\\n            newLockedBalance.amount.mul(newLockedBalance.unlockTime - nextWeek).add(_maxTime - 1) /\\n                _maxTime\\n        );\\n        userLockedBalances[account] = newLockedBalance;\\n\\n        emit Synchronized(\\n            account,\\n            oldLockedBalance.amount,\\n            oldLockedBalance.unlockTime,\\n            newLockedBalance.amount,\\n            newLockedBalance.unlockTime\\n        );\\n    }\\n\\n    function userCheckpoint(address account) public returns (uint256 rewards) {\\n        checkpoint();\\n        rewards = claimableRewards[account].add(_rewardCheckpoint(account));\\n        claimableRewards[account] = rewards;\\n    }\\n\\n    function claimRewards(address account) external returns (uint256 rewards) {\\n        rewards = _claimRewards(account);\\n        rewardToken.safeTransfer(account, rewards);\\n    }\\n\\n    function claimRewardsAndUnwrap(address account) external returns (uint256 rewards) {\\n        rewards = _claimRewards(account);\\n        IWrappedERC20(address(rewardToken)).withdraw(rewards);\\n        (bool success, ) = account.call{value: rewards}(\\\"\\\");\\n        require(success, \\\"Transfer failed\\\");\\n    }\\n\\n    /// @notice Receive unwrapped transfer from the wrapped token.\\n    receive() external payable {}\\n\\n    function _claimRewards(address account) private returns (uint256 rewards) {\\n        checkpoint();\\n        rewards = claimableRewards[account].add(_rewardCheckpoint(account));\\n        claimableRewards[account] = 0;\\n        lastRewardBalance = lastRewardBalance.sub(rewards);\\n    }\\n\\n    /// @notice Make a global checkpoint. If the period since the last checkpoint spans over\\n    ///         multiple weeks, rewards received in this period are split into these weeks\\n    ///         proportional to the time in each week.\\n    /// @dev Post-conditions:\\n    ///\\n    ///      - `checkpointTimestamp == block.timestamp`\\n    ///      - `lastRewardBalance == rewardToken.balanceOf(address(this))`\\n    ///      - All `rewardsPerWeek[t]` are updated, where `t <= checkpointTimestamp`\\n    ///      - All `veSupplyPerWeek[t]` are set, where `t <= checkpointTimestamp`\\n    ///      - `nextWeekSupply` is the total veCHESS at the end of this week\\n    ///      - `nextWeekLocked` is the total locked Chess at the end of this week\\n    function checkpoint() public {\\n        uint256 tokenBalance = rewardToken.balanceOf(address(this));\\n        uint256 tokensToDistribute = tokenBalance.sub(lastRewardBalance);\\n        lastRewardBalance = tokenBalance;\\n\\n        uint256 adminFee = tokensToDistribute.multiplyDecimal(adminFeeRate);\\n        if (adminFee > 0) {\\n            claimableRewards[admin] = claimableRewards[admin].add(adminFee);\\n            tokensToDistribute = tokensToDistribute.sub(adminFee);\\n        }\\n        uint256 rewardTime = checkpointTimestamp;\\n        uint256 weekCursor = _endOfWeek(rewardTime) - 1 weeks;\\n        uint256 currentWeek = _endOfWeek(block.timestamp) - 1 weeks;\\n\\n        // Update veCHESS supply at the beginning of each week since the last checkpoint.\\n        if (weekCursor < currentWeek) {\\n            uint256 newLocked = nextWeekLocked;\\n            uint256 newSupply = nextWeekSupply;\\n            for (uint256 w = weekCursor + 1 weeks; w <= currentWeek; w += 1 weeks) {\\n                veSupplyPerWeek[w] = newSupply;\\n                // Calculate supply at the end of the next week.\\n                newSupply = newSupply.sub(newLocked.mul(1 weeks) / _maxTime);\\n                // Remove Chess unlocked at the end of the next week from total locked amount.\\n                newLocked = newLocked.sub(scheduledUnlock[w + 1 weeks]);\\n            }\\n            nextWeekLocked = newLocked;\\n            nextWeekSupply = newSupply;\\n        }\\n\\n        // Distribute rewards received since the last checkpoint.\\n        if (tokensToDistribute > 0) {\\n            if (weekCursor >= currentWeek) {\\n                rewardsPerWeek[weekCursor] = rewardsPerWeek[weekCursor].add(tokensToDistribute);\\n            } else {\\n                uint256 sinceLast = block.timestamp - rewardTime;\\n                // Calculate the fraction of rewards proportional to the time from\\n                // the last checkpoint to the end of that week.\\n                rewardsPerWeek[weekCursor] = rewardsPerWeek[weekCursor].add(\\n                    tokensToDistribute.mul(weekCursor + 1 weeks - rewardTime) / sinceLast\\n                );\\n                weekCursor += 1 weeks;\\n                // Calculate the fraction of rewards for intermediate whole weeks.\\n                while (weekCursor < currentWeek) {\\n                    rewardsPerWeek[weekCursor] = tokensToDistribute.mul(1 weeks) / sinceLast;\\n                    weekCursor += 1 weeks;\\n                }\\n                // Calculate the fraction of rewards proportional to the time from\\n                // the beginning of the current week to the current block timestamp.\\n                rewardsPerWeek[weekCursor] =\\n                    tokensToDistribute.mul(block.timestamp - weekCursor) /\\n                    sinceLast;\\n            }\\n        }\\n\\n        checkpointTimestamp = block.timestamp;\\n    }\\n\\n    function _updateAdmin(address newAdmin) private {\\n        admin = newAdmin;\\n        emit AdminUpdated(newAdmin);\\n    }\\n\\n    function updateAdmin(address newAdmin) external onlyOwner {\\n        _updateAdmin(newAdmin);\\n    }\\n\\n    function _updateAdminFeeRate(uint256 newAdminFeeRate) private {\\n        require(newAdminFeeRate <= MAX_ADMIN_FEE_RATE, \\\"Cannot exceed max admin fee rate\\\");\\n        adminFeeRate = newAdminFeeRate;\\n        emit AdminFeeRateUpdated(newAdminFeeRate);\\n    }\\n\\n    function updateAdminFeeRate(uint256 newAdminFeeRate) external onlyOwner {\\n        _updateAdminFeeRate(newAdminFeeRate);\\n    }\\n\\n    /// @dev Calculate rewards since a user's last checkpoint and make a new checkpoint.\\n    ///\\n    ///      Post-conditions:\\n    ///\\n    ///      - `userWeekCursor[account]` is the start timestamp of the current week\\n    ///      - `userLastBalances[account]` is amount of veCHESS at the beginning of the current week\\n    /// @param account Address of the account\\n    /// @return Rewards since the last checkpoint\\n    function _rewardCheckpoint(address account) private returns (uint256) {\\n        uint256 currentWeek = _endOfWeek(block.timestamp) - 1 weeks;\\n        uint256 weekCursor = userWeekCursors[account];\\n        if (weekCursor >= currentWeek) {\\n            return 0;\\n        }\\n        if (weekCursor == 0) {\\n            userWeekCursors[account] = currentWeek;\\n            return 0;\\n        }\\n\\n        // The week of the last user checkpoint has ended.\\n        uint256 lastBalance = userLastBalances[account];\\n        uint256 rewards =\\n            lastBalance > 0\\n                ? lastBalance.mul(rewardsPerWeek[weekCursor]) / veSupplyPerWeek[weekCursor]\\n                : 0;\\n        weekCursor += 1 weeks;\\n\\n        // Iterate over succeeding weeks and calculate rewards.\\n        IVotingEscrow.LockedBalance memory lockedBalance = userLockedBalances[account];\\n        while (weekCursor < currentWeek) {\\n            uint256 veChessBalance = _balanceAtTimestamp(lockedBalance, weekCursor);\\n            if (veChessBalance == 0) {\\n                break;\\n            }\\n            // A positive veChessBalance guarentees that veSupply of that week is also positive\\n            rewards = rewards.add(\\n                veChessBalance.mul(rewardsPerWeek[weekCursor]) / veSupplyPerWeek[weekCursor]\\n            );\\n            weekCursor += 1 weeks;\\n        }\\n\\n        userWeekCursors[account] = currentWeek;\\n        userLastBalances[account] = _balanceAtTimestamp(lockedBalance, currentWeek);\\n        return rewards;\\n    }\\n\\n    /// @notice Recalculate `nextWeekSupply` from scratch. This function eliminates accumulated\\n    ///         rounding errors in `nextWeekSupply`, which is incrementally updated in\\n    ///         `syncWithVotingEscrow()` and `checkpoint()`. It is almost never required.\\n    /// @dev See related test cases for details about the rounding errors.\\n    function calibrateSupply() external {\\n        uint256 nextWeek = _endOfWeek(checkpointTimestamp);\\n        nextWeekSupply = _totalSupplyAtTimestamp(nextWeek);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/governance/VotingEscrowV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\n\\nimport \\\"../utils/CoreUtility.sol\\\";\\nimport \\\"../utils/ManagedPausable.sol\\\";\\nimport \\\"../interfaces/IVotingEscrow.sol\\\";\\nimport \\\"../utils/ProxyUtility.sol\\\";\\n\\ninterface IAddressWhitelist {\\n    function check(address account) external view returns (bool);\\n}\\n\\ninterface IVotingEscrowCallback {\\n    function syncWithVotingEscrow(address account) external;\\n}\\n\\ncontract VotingEscrowV2 is\\n    IVotingEscrow,\\n    OwnableUpgradeable,\\n    ReentrancyGuard,\\n    CoreUtility,\\n    ManagedPausable,\\n    ProxyUtility\\n{\\n    /// @dev Reserved storage slots for future base contract upgrades\\n    uint256[29] private _reservedSlots;\\n\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    event LockCreated(address indexed account, uint256 amount, uint256 unlockTime);\\n\\n    event AmountIncreased(address indexed account, uint256 increasedAmount);\\n\\n    event UnlockTimeIncreased(address indexed account, uint256 newUnlockTime);\\n\\n    event Withdrawn(address indexed account, uint256 amount);\\n\\n    uint8 public constant decimals = 18;\\n\\n    uint256 public immutable override maxTime;\\n\\n    address public immutable override token;\\n\\n    string public name;\\n    string public symbol;\\n\\n    address public addressWhitelist;\\n\\n    mapping(address => LockedBalance) public locked;\\n\\n    /// @notice Mapping of unlockTime => total amount that will be unlocked at unlockTime\\n    mapping(uint256 => uint256) public scheduledUnlock;\\n\\n    /// @notice max lock time allowed at the moment\\n    uint256 public maxTimeAllowed;\\n\\n    /// @notice Contract to be call when an account's locked CHESS is updated\\n    address public callback;\\n\\n    /// @notice Amount of Chess locked now. Expired locks are not included.\\n    uint256 public totalLocked;\\n\\n    /// @notice Total veCHESS at the end of the last checkpoint's week\\n    uint256 public nextWeekSupply;\\n\\n    /// @notice Mapping of week => vote-locked chess total supplies\\n    ///\\n    ///         Key is the start timestamp of a week on each Thursday. Value is\\n    ///         vote-locked chess total supplies captured at the start of each week\\n    mapping(uint256 => uint256) public veSupplyPerWeek;\\n\\n    /// @notice Start timestamp of the trading week in which the last checkpoint is made\\n    uint256 public checkpointWeek;\\n\\n    constructor(address token_, uint256 maxTime_) public {\\n        token = token_;\\n        maxTime = maxTime_;\\n    }\\n\\n    /// @dev Initialize the contract. The contract is designed to be used with OpenZeppelin's\\n    ///      `TransparentUpgradeableProxy`. This function should be called by the proxy's\\n    ///      constructor (via the `_data` argument).\\n    function initialize(\\n        string memory name_,\\n        string memory symbol_,\\n        uint256 maxTimeAllowed_\\n    ) external initializer {\\n        __Ownable_init();\\n        require(maxTimeAllowed_ <= maxTime, \\\"Cannot exceed max time\\\");\\n        maxTimeAllowed = maxTimeAllowed_;\\n        _initializeV2(msg.sender, name_, symbol_);\\n    }\\n\\n    /// @dev Initialize the part added in V2. If this contract is upgraded from the previous\\n    ///      version, call `upgradeToAndCall` of the proxy and put a call to this function\\n    ///      in the `data` argument.\\n    ///\\n    ///      In the previous version, name and symbol were not correctly initialized via proxy.\\n    function initializeV2(\\n        address pauser_,\\n        string memory name_,\\n        string memory symbol_\\n    ) external onlyProxyAdmin {\\n        _initializeV2(pauser_, name_, symbol_);\\n    }\\n\\n    function _initializeV2(\\n        address pauser_,\\n        string memory name_,\\n        string memory symbol_\\n    ) private {\\n        _initializeManagedPausable(pauser_);\\n        require(bytes(name).length == 0 && bytes(symbol).length == 0);\\n        name = name_;\\n        symbol = symbol_;\\n\\n        // Initialize totalLocked, nextWeekSupply and checkpointWeek\\n        uint256 nextWeek = _endOfWeek(block.timestamp);\\n        uint256 totalLocked_ = 0;\\n        uint256 nextWeekSupply_ = 0;\\n        for (\\n            uint256 weekCursor = nextWeek;\\n            weekCursor <= nextWeek + maxTime;\\n            weekCursor += 1 weeks\\n        ) {\\n            totalLocked_ = totalLocked_.add(scheduledUnlock[weekCursor]);\\n            nextWeekSupply_ = nextWeekSupply_.add(\\n                (scheduledUnlock[weekCursor].mul(weekCursor - nextWeek)) / maxTime\\n            );\\n        }\\n        totalLocked = totalLocked_;\\n        nextWeekSupply = nextWeekSupply_;\\n        checkpointWeek = nextWeek - 1 weeks;\\n    }\\n\\n    function getTimestampDropBelow(address account, uint256 threshold)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        LockedBalance memory lockedBalance = locked[account];\\n        if (lockedBalance.amount == 0 || lockedBalance.amount < threshold) {\\n            return 0;\\n        }\\n        return lockedBalance.unlockTime.sub(threshold.mul(maxTime).div(lockedBalance.amount));\\n    }\\n\\n    function balanceOf(address account) external view override returns (uint256) {\\n        return _balanceOfAtTimestamp(account, block.timestamp);\\n    }\\n\\n    function totalSupply() external view override returns (uint256) {\\n        uint256 weekCursor = checkpointWeek;\\n        uint256 nextWeek = _endOfWeek(block.timestamp);\\n        uint256 currentWeek = nextWeek - 1 weeks;\\n        uint256 newNextWeekSupply = nextWeekSupply;\\n        uint256 newTotalLocked = totalLocked;\\n        if (weekCursor < currentWeek) {\\n            weekCursor += 1 weeks;\\n            for (; weekCursor < currentWeek; weekCursor += 1 weeks) {\\n                // Remove Chess unlocked at the beginning of the next week from total locked amount.\\n                newTotalLocked = newTotalLocked.sub(scheduledUnlock[weekCursor]);\\n                // Calculate supply at the end of the next week.\\n                newNextWeekSupply = newNextWeekSupply.sub(newTotalLocked.mul(1 weeks) / maxTime);\\n            }\\n            newTotalLocked = newTotalLocked.sub(scheduledUnlock[weekCursor]);\\n            newNextWeekSupply = newNextWeekSupply.sub(\\n                newTotalLocked.mul(block.timestamp - currentWeek) / maxTime\\n            );\\n        } else {\\n            newNextWeekSupply = newNextWeekSupply.add(\\n                newTotalLocked.mul(nextWeek - block.timestamp) / maxTime\\n            );\\n        }\\n\\n        return newNextWeekSupply;\\n    }\\n\\n    function getLockedBalance(address account)\\n        external\\n        view\\n        override\\n        returns (LockedBalance memory)\\n    {\\n        return locked[account];\\n    }\\n\\n    function balanceOfAtTimestamp(address account, uint256 timestamp)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _balanceOfAtTimestamp(account, timestamp);\\n    }\\n\\n    function totalSupplyAtTimestamp(uint256 timestamp) external view returns (uint256) {\\n        return _totalSupplyAtTimestamp(timestamp);\\n    }\\n\\n    function createLock(uint256 amount, uint256 unlockTime) external nonReentrant whenNotPaused {\\n        _assertNotContract();\\n        require(\\n            unlockTime + 1 weeks == _endOfWeek(unlockTime),\\n            \\\"Unlock time must be end of a week\\\"\\n        );\\n\\n        LockedBalance memory lockedBalance = locked[msg.sender];\\n\\n        require(amount > 0, \\\"Zero value\\\");\\n        require(lockedBalance.amount == 0, \\\"Withdraw old tokens first\\\");\\n        require(unlockTime > block.timestamp, \\\"Can only lock until time in the future\\\");\\n        require(\\n            unlockTime <= block.timestamp + maxTimeAllowed,\\n            \\\"Voting lock cannot exceed max lock time\\\"\\n        );\\n\\n        _checkpoint(lockedBalance.amount, lockedBalance.unlockTime, amount, unlockTime);\\n        scheduledUnlock[unlockTime] = scheduledUnlock[unlockTime].add(amount);\\n        locked[msg.sender].unlockTime = unlockTime;\\n        locked[msg.sender].amount = amount;\\n\\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\\n\\n        if (callback != address(0)) {\\n            IVotingEscrowCallback(callback).syncWithVotingEscrow(msg.sender);\\n        }\\n\\n        emit LockCreated(msg.sender, amount, unlockTime);\\n    }\\n\\n    function increaseAmount(address account, uint256 amount) external nonReentrant whenNotPaused {\\n        LockedBalance memory lockedBalance = locked[account];\\n\\n        require(amount > 0, \\\"Zero value\\\");\\n        require(lockedBalance.unlockTime > block.timestamp, \\\"Cannot add to expired lock\\\");\\n\\n        uint256 newAmount = lockedBalance.amount.add(amount);\\n        _checkpoint(\\n            lockedBalance.amount,\\n            lockedBalance.unlockTime,\\n            newAmount,\\n            lockedBalance.unlockTime\\n        );\\n        scheduledUnlock[lockedBalance.unlockTime] = scheduledUnlock[lockedBalance.unlockTime].add(\\n            amount\\n        );\\n        locked[account].amount = newAmount;\\n\\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\\n\\n        if (callback != address(0)) {\\n            IVotingEscrowCallback(callback).syncWithVotingEscrow(msg.sender);\\n        }\\n\\n        emit AmountIncreased(account, amount);\\n    }\\n\\n    function increaseUnlockTime(uint256 unlockTime) external nonReentrant whenNotPaused {\\n        require(\\n            unlockTime + 1 weeks == _endOfWeek(unlockTime),\\n            \\\"Unlock time must be end of a week\\\"\\n        );\\n        LockedBalance memory lockedBalance = locked[msg.sender];\\n\\n        require(lockedBalance.unlockTime > block.timestamp, \\\"Lock expired\\\");\\n        require(unlockTime > lockedBalance.unlockTime, \\\"Can only increase lock duration\\\");\\n        require(\\n            unlockTime <= block.timestamp + maxTimeAllowed,\\n            \\\"Voting lock cannot exceed max lock time\\\"\\n        );\\n\\n        _checkpoint(\\n            lockedBalance.amount,\\n            lockedBalance.unlockTime,\\n            lockedBalance.amount,\\n            unlockTime\\n        );\\n        scheduledUnlock[lockedBalance.unlockTime] = scheduledUnlock[lockedBalance.unlockTime].sub(\\n            lockedBalance.amount\\n        );\\n        scheduledUnlock[unlockTime] = scheduledUnlock[unlockTime].add(lockedBalance.amount);\\n        locked[msg.sender].unlockTime = unlockTime;\\n\\n        if (callback != address(0)) {\\n            IVotingEscrowCallback(callback).syncWithVotingEscrow(msg.sender);\\n        }\\n\\n        emit UnlockTimeIncreased(msg.sender, unlockTime);\\n    }\\n\\n    function withdraw() external nonReentrant {\\n        LockedBalance memory lockedBalance = locked[msg.sender];\\n        require(block.timestamp >= lockedBalance.unlockTime, \\\"The lock is not expired\\\");\\n        uint256 amount = uint256(lockedBalance.amount);\\n\\n        lockedBalance.unlockTime = 0;\\n        lockedBalance.amount = 0;\\n        locked[msg.sender] = lockedBalance;\\n\\n        IERC20(token).safeTransfer(msg.sender, amount);\\n\\n        emit Withdrawn(msg.sender, amount);\\n    }\\n\\n    function updateAddressWhitelist(address newWhitelist) external onlyOwner {\\n        require(\\n            newWhitelist == address(0) || Address.isContract(newWhitelist),\\n            \\\"Must be null or a contract\\\"\\n        );\\n        addressWhitelist = newWhitelist;\\n    }\\n\\n    function updateCallback(address newCallback) external onlyOwner {\\n        require(\\n            newCallback == address(0) || Address.isContract(newCallback),\\n            \\\"Must be null or a contract\\\"\\n        );\\n        callback = newCallback;\\n    }\\n\\n    function _assertNotContract() private view {\\n        if (msg.sender != tx.origin) {\\n            if (\\n                addressWhitelist != address(0) &&\\n                IAddressWhitelist(addressWhitelist).check(msg.sender)\\n            ) {\\n                return;\\n            }\\n            revert(\\\"Smart contract depositors not allowed\\\");\\n        }\\n    }\\n\\n    function _balanceOfAtTimestamp(address account, uint256 timestamp)\\n        private\\n        view\\n        returns (uint256)\\n    {\\n        require(timestamp >= block.timestamp, \\\"Must be current or future time\\\");\\n        LockedBalance memory lockedBalance = locked[account];\\n        if (timestamp > lockedBalance.unlockTime) {\\n            return 0;\\n        }\\n        return (lockedBalance.amount.mul(lockedBalance.unlockTime - timestamp)) / maxTime;\\n    }\\n\\n    function _totalSupplyAtTimestamp(uint256 timestamp) private view returns (uint256) {\\n        uint256 weekCursor = _endOfWeek(timestamp);\\n        uint256 total = 0;\\n        for (; weekCursor <= timestamp + maxTime; weekCursor += 1 weeks) {\\n            total = total.add((scheduledUnlock[weekCursor].mul(weekCursor - timestamp)) / maxTime);\\n        }\\n        return total;\\n    }\\n\\n    /// @dev Pre-conditions:\\n    ///\\n    ///      - `newAmount > 0`\\n    ///      - `newUnlockTime > block.timestamp`\\n    ///      - `newUnlockTime + 1 weeks == _endOfWeek(newUnlockTime)`, i.e. aligned to a trading week\\n    ///\\n    ///      The latter two conditions gaurantee that `newUnlockTime` is no smaller than the local\\n    ///      variable `nextWeek` in the function.\\n    function _checkpoint(\\n        uint256 oldAmount,\\n        uint256 oldUnlockTime,\\n        uint256 newAmount,\\n        uint256 newUnlockTime\\n    ) private {\\n        // Update veCHESS supply at the beginning of each week since the last checkpoint.\\n        uint256 weekCursor = checkpointWeek;\\n        uint256 nextWeek = _endOfWeek(block.timestamp);\\n        uint256 currentWeek = nextWeek - 1 weeks;\\n        uint256 newTotalLocked = totalLocked;\\n        uint256 newNextWeekSupply = nextWeekSupply;\\n        if (weekCursor < currentWeek) {\\n            for (uint256 w = weekCursor + 1 weeks; w <= currentWeek; w += 1 weeks) {\\n                veSupplyPerWeek[w] = newNextWeekSupply;\\n                // Remove Chess unlocked at the beginning of this week from total locked amount.\\n                newTotalLocked = newTotalLocked.sub(scheduledUnlock[w]);\\n                // Calculate supply at the end of the next week.\\n                newNextWeekSupply = newNextWeekSupply.sub(newTotalLocked.mul(1 weeks) / maxTime);\\n            }\\n            checkpointWeek = currentWeek;\\n        }\\n\\n        // Remove the old schedule if there is one\\n        if (oldAmount > 0 && oldUnlockTime >= nextWeek) {\\n            newTotalLocked = newTotalLocked.sub(oldAmount);\\n            newNextWeekSupply = newNextWeekSupply.sub(\\n                oldAmount.mul(oldUnlockTime - nextWeek) / maxTime\\n            );\\n        }\\n\\n        totalLocked = newTotalLocked.add(newAmount);\\n        // Round up on division when added to the total supply, so that the total supply is never\\n        // smaller than the sum of all accounts' veCHESS balance.\\n        nextWeekSupply = newNextWeekSupply.add(\\n            newAmount.mul(newUnlockTime - nextWeek).add(maxTime - 1) / maxTime\\n        );\\n    }\\n\\n    function updateMaxTimeAllowed(uint256 newMaxTimeAllowed) external onlyOwner {\\n        require(newMaxTimeAllowed <= maxTime, \\\"Cannot exceed max time\\\");\\n        require(newMaxTimeAllowed > maxTimeAllowed, \\\"Cannot shorten max time allowed\\\");\\n        maxTimeAllowed = newMaxTimeAllowed;\\n    }\\n\\n    /// @notice Recalculate `nextWeekSupply` from scratch. This function eliminates accumulated\\n    ///         rounding errors in `nextWeekSupply`, which is incrementally updated in\\n    ///         `createLock`, `increaseAmount` and `increaseUnlockTime`. It is almost\\n    ///         never required.\\n    /// @dev Search \\\"rounding error\\\" in test cases for details about the rounding errors.\\n    function calibrateSupply() external {\\n        uint256 nextWeek = checkpointWeek + 1 weeks;\\n        nextWeekSupply = _totalSupplyAtTimestamp(nextWeek);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/governance/ChessControllerV4.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"../../utils/CoreUtility.sol\\\";\\nimport \\\"../../utils/SafeDecimalMath.sol\\\";\\nimport \\\"../../interfaces/IChessController.sol\\\";\\nimport \\\"../interfaces/IFund.sol\\\";\\nimport \\\"../../interfaces/IControllerBallot.sol\\\";\\n\\ncontract ChessControllerV4 is IChessController, CoreUtility {\\n    /// @dev Reserved storage slots for future base contract upgrades\\n    uint256[192] private _reservedSlots;\\n\\n    using Math for uint256;\\n    using SafeMath for uint256;\\n    using SafeDecimalMath for uint256;\\n\\n    event WeightUpdated(address indexed fund, uint256 indexed timestamp, uint256 weight);\\n\\n    address public immutable fund0;\\n    uint256 public immutable guardedLaunchStart;\\n    address public immutable controllerBallot;\\n\\n    mapping(uint256 => mapping(address => uint256)) public weights;\\n\\n    /// @notice Start timestamp of the last trading week that has weights updated.\\n    uint256 public lastTimestamp;\\n\\n    constructor(\\n        address fund0_,\\n        uint256 guardedLaunchStart_,\\n        address controllerBallot_\\n    ) public {\\n        fund0 = fund0_;\\n        guardedLaunchStart = guardedLaunchStart_;\\n        require(_endOfWeek(guardedLaunchStart_) == guardedLaunchStart_ + 1 weeks);\\n        controllerBallot = controllerBallot_;\\n    }\\n\\n    /// @dev Initialize the part added in V4. The contract is designed to be used with OpenZeppelin's\\n    ///      `TransparentUpgradeableProxy`. If this contract is upgraded from the previous version,\\n    ///      call `upgradeToAndCall` of the proxy and put a call to this function in the `data`\\n    ///      argument with `lastTimestamp_` set to the last updated week. If this contract is\\n    ///      the first implementation of the proxy, This function should be called by the proxy's\\n    ///      constructor (via the `_data` argument) with `lastTimestamp_` set to one week before\\n    ///      `guardedLaunchStart`.\\n    function initializeV4(uint256 lastTimestamp_) external {\\n        require(lastTimestamp == 0, \\\"Already initialized\\\");\\n        require(\\n            _endOfWeek(lastTimestamp_) == lastTimestamp_ + 1 weeks &&\\n                lastTimestamp_ >= guardedLaunchStart - 1 weeks\\n        );\\n        require(weights[lastTimestamp_ + 1 weeks][fund0] == 0, \\\"Next week already updated\\\");\\n        if (lastTimestamp_ >= guardedLaunchStart) {\\n            require(weights[lastTimestamp_][fund0] > 0, \\\"Last week not updated\\\");\\n        }\\n        lastTimestamp = lastTimestamp_;\\n    }\\n\\n    /// @notice Get Fund relative weight (not more than 1.0) normalized to 1e18\\n    ///         (e.g. 1.0 == 1e18).\\n    /// @return weight Value of relative weight normalized to 1e18\\n    function getFundRelativeWeight(address fundAddress, uint256 timestamp)\\n        external\\n        override\\n        returns (uint256)\\n    {\\n        require(timestamp <= block.timestamp, \\\"Too soon\\\");\\n        if (timestamp < guardedLaunchStart) {\\n            return fundAddress == fund0 ? 1e18 : 0;\\n        }\\n        uint256 weekTimestamp = _endOfWeek(timestamp).sub(1 weeks);\\n        uint256 lastTimestamp_ = lastTimestamp; // gas saver\\n        require(weekTimestamp <= lastTimestamp_ + 1 weeks, \\\"Previous week is empty\\\");\\n        if (weekTimestamp <= lastTimestamp_) {\\n            return weights[weekTimestamp][fundAddress];\\n        }\\n        lastTimestamp = lastTimestamp_ + 1 weeks;\\n        return _updateFundWeight(weekTimestamp, fundAddress);\\n    }\\n\\n    function _updateFundWeight(uint256 weekTimestamp, address fundAddress)\\n        private\\n        returns (uint256 weight)\\n    {\\n        (uint256[] memory ballotWeights, address[] memory funds) =\\n            IControllerBallot(controllerBallot).count(weekTimestamp);\\n\\n        uint256 totalValueLocked;\\n        uint256[] memory fundValueLocked = new uint256[](ballotWeights.length);\\n        for (uint256 i = 0; i < ballotWeights.length; i++) {\\n            fundValueLocked[i] = getFundValueLocked(funds[i], weekTimestamp);\\n            totalValueLocked = totalValueLocked.add(fundValueLocked[i]);\\n        }\\n\\n        uint256 totalWeight;\\n        for (uint256 i = 0; i < ballotWeights.length; i++) {\\n            uint256 fundWeight = ballotWeights[i];\\n            if (totalValueLocked > 0) {\\n                fundWeight = fundWeight.add(fundValueLocked[i].divideDecimal(totalValueLocked)) / 2;\\n            }\\n            weights[weekTimestamp][funds[i]] = fundWeight;\\n            emit WeightUpdated(funds[i], weekTimestamp, fundWeight);\\n            if (funds[i] == fundAddress) {\\n                weight = fundWeight;\\n            }\\n            totalWeight = totalWeight.add(fundWeight);\\n        }\\n        require(totalWeight <= 1e18, \\\"Total weight exceeds 100%\\\");\\n    }\\n\\n    function getFundValueLocked(address fund, uint256 weekTimestamp) public view returns (uint256) {\\n        uint256 timestamp = (IFund(fund).currentDay() - 1 days).min(weekTimestamp);\\n        (uint256 navM, , ) = IFund(fund).historicalNavs(timestamp);\\n        return IFund(fund).historicalTotalShares(timestamp).multiplyDecimal(navM);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/governance/ControllerBallot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"../utils/CoreUtility.sol\\\";\\nimport \\\"../utils/SafeDecimalMath.sol\\\";\\n\\nimport {IVotingEscrowCallback} from \\\"../governance/VotingEscrowV2.sol\\\";\\nimport \\\"../interfaces/IControllerBallot.sol\\\";\\nimport \\\"../interfaces/IVotingEscrow.sol\\\";\\n\\ncontract ControllerBallot is IControllerBallot, IVotingEscrowCallback, Ownable, CoreUtility {\\n    using SafeMath for uint256;\\n    using SafeDecimalMath for uint256;\\n\\n    event PoolAdded(address pool);\\n    event PoolToggled(address indexed pool, bool isDisabled);\\n    event Voted(\\n        address indexed account,\\n        uint256 oldAmount,\\n        uint256 oldUnlockTime,\\n        uint256[] oldWeights,\\n        uint256 amount,\\n        uint256 unlockTime,\\n        uint256[] weights\\n    );\\n\\n    IVotingEscrow public immutable votingEscrow;\\n    uint256 private immutable _maxTime;\\n\\n    address[65535] private _pools;\\n    uint256 public poolSize;\\n    uint256 public disabledPoolSize;\\n\\n    /// @notice Locked balance of an account, which is synchronized with `VotingEscrow` when\\n    ///         `syncWithVotingEscrow()` is called\\n    mapping(address => IVotingEscrow.LockedBalance) public userLockedBalances;\\n\\n    /// @notice Mapping of account => pool => fraction of the user's veCHESS voted to the pool\\n    mapping(address => mapping(address => uint256)) public userWeights;\\n\\n    /// @notice Mapping of pool => unlockTime => CHESS amount voted to the pool that will be\\n    ///         unlocked at unlockTime\\n    mapping(address => mapping(uint256 => uint256)) public poolScheduledUnlock;\\n\\n    /// @notice Mapping of pool => status of the pool\\n    mapping(uint256 => bool) public disabledPools;\\n\\n    constructor(address votingEscrow_) public {\\n        votingEscrow = IVotingEscrow(votingEscrow_);\\n        _maxTime = IVotingEscrow(votingEscrow_).maxTime();\\n    }\\n\\n    function getPools() external view returns (address[] memory) {\\n        uint256 size = poolSize;\\n        address[] memory pools = new address[](size);\\n        for (uint256 i = 0; i < size; i++) {\\n            pools[i] = _pools[i];\\n        }\\n        return pools;\\n    }\\n\\n    function addPool(address newPool) external onlyOwner {\\n        uint256 size = poolSize;\\n        _pools[size] = newPool;\\n        poolSize = size + 1;\\n        emit PoolAdded(newPool);\\n    }\\n\\n    function togglePool(uint256 index) external onlyOwner {\\n        require(index < poolSize, \\\"Invalid index\\\");\\n        if (disabledPools[index]) {\\n            disabledPools[index] = false;\\n            disabledPoolSize--;\\n        } else {\\n            disabledPools[index] = true;\\n            disabledPoolSize++;\\n        }\\n        emit PoolToggled(_pools[index], disabledPools[index]);\\n    }\\n\\n    function balanceOf(address account) external view returns (uint256) {\\n        return balanceOfAtTimestamp(account, block.timestamp);\\n    }\\n\\n    function balanceOfAtTimestamp(address account, uint256 timestamp)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        require(timestamp >= block.timestamp, \\\"Must be current or future time\\\");\\n        IVotingEscrow.LockedBalance memory locked = userLockedBalances[account];\\n        if (timestamp >= locked.unlockTime) {\\n            return 0;\\n        }\\n        return locked.amount.mul(locked.unlockTime - timestamp) / _maxTime;\\n    }\\n\\n    function totalSupply() external view returns (uint256) {\\n        return totalSupplyAtTimestamp(block.timestamp);\\n    }\\n\\n    function totalSupplyAtTimestamp(uint256 timestamp) public view returns (uint256) {\\n        uint256 size = poolSize;\\n        uint256 total = 0;\\n        for (uint256 i = 0; i < size; i++) {\\n            total = total.add(sumAtTimestamp(_pools[i], timestamp));\\n        }\\n        return total;\\n    }\\n\\n    function sumAtTimestamp(address pool, uint256 timestamp) public view returns (uint256) {\\n        uint256 sum = 0;\\n        for (\\n            uint256 weekCursor = _endOfWeek(timestamp);\\n            weekCursor <= timestamp + _maxTime;\\n            weekCursor += 1 weeks\\n        ) {\\n            sum = sum.add(\\n                poolScheduledUnlock[pool][weekCursor].mul(weekCursor - timestamp) / _maxTime\\n            );\\n        }\\n        return sum;\\n    }\\n\\n    function count(uint256 timestamp)\\n        external\\n        view\\n        override\\n        returns (uint256[] memory weights, address[] memory pools)\\n    {\\n        uint256 poolSize_ = poolSize;\\n        uint256 size = poolSize_ - disabledPoolSize;\\n        pools = new address[](size);\\n        uint256 j = 0;\\n        for (uint256 i = 0; i < poolSize_ && j < size; i++) {\\n            address pool = _pools[i];\\n            if (!disabledPools[i]) pools[j++] = pool;\\n        }\\n\\n        uint256[] memory sums = new uint256[](size);\\n        uint256 total = 0;\\n        for (uint256 i = 0; i < size; i++) {\\n            uint256 sum = sumAtTimestamp(pools[i], timestamp);\\n            sums[i] = sum;\\n            total = total.add(sum);\\n        }\\n\\n        weights = new uint256[](size);\\n        if (total == 0) {\\n            for (uint256 i = 0; i < size; i++) {\\n                weights[i] = 1e18 / size;\\n            }\\n        } else {\\n            for (uint256 i = 0; i < size; i++) {\\n                weights[i] = sums[i].divideDecimal(total);\\n            }\\n        }\\n    }\\n\\n    function cast(uint256[] memory weights) external {\\n        uint256 size = poolSize;\\n        require(weights.length == size, \\\"Invalid number of weights\\\");\\n        uint256 totalWeight;\\n        for (uint256 i = 0; i < size; i++) {\\n            totalWeight = totalWeight.add(weights[i]);\\n        }\\n        require(totalWeight == 1e18, \\\"Invalid weights\\\");\\n\\n        uint256[] memory oldWeights = new uint256[](size);\\n        for (uint256 i = 0; i < size; i++) {\\n            oldWeights[i] = userWeights[msg.sender][_pools[i]];\\n        }\\n\\n        IVotingEscrow.LockedBalance memory oldLockedBalance = userLockedBalances[msg.sender];\\n        IVotingEscrow.LockedBalance memory lockedBalance =\\n            votingEscrow.getLockedBalance(msg.sender);\\n        require(\\n            lockedBalance.amount > 0 && lockedBalance.unlockTime > block.timestamp,\\n            \\\"No veCHESS\\\"\\n        );\\n\\n        _updateVoteStatus(msg.sender, size, oldWeights, weights, oldLockedBalance, lockedBalance);\\n    }\\n\\n    function syncWithVotingEscrow(address account) external override {\\n        IVotingEscrow.LockedBalance memory oldLockedBalance = userLockedBalances[account];\\n        if (oldLockedBalance.amount == 0) {\\n            return; // The account did not voted before\\n        }\\n        IVotingEscrow.LockedBalance memory lockedBalance = votingEscrow.getLockedBalance(account);\\n        if (lockedBalance.unlockTime <= block.timestamp) {\\n            return;\\n        }\\n\\n        uint256 size = poolSize;\\n        uint256[] memory weights = new uint256[](size);\\n        for (uint256 i = 0; i < size; i++) {\\n            weights[i] = userWeights[account][_pools[i]];\\n        }\\n\\n        _updateVoteStatus(account, size, weights, weights, oldLockedBalance, lockedBalance);\\n    }\\n\\n    function _updateVoteStatus(\\n        address account,\\n        uint256 size,\\n        uint256[] memory oldWeights,\\n        uint256[] memory weights,\\n        IVotingEscrow.LockedBalance memory oldLockedBalance,\\n        IVotingEscrow.LockedBalance memory lockedBalance\\n    ) private {\\n        for (uint256 i = 0; i < size; i++) {\\n            address pool = _pools[i];\\n            poolScheduledUnlock[pool][oldLockedBalance.unlockTime] = poolScheduledUnlock[pool][\\n                oldLockedBalance.unlockTime\\n            ]\\n                .sub(oldLockedBalance.amount.multiplyDecimal(oldWeights[i]));\\n\\n            poolScheduledUnlock[pool][lockedBalance.unlockTime] = poolScheduledUnlock[pool][\\n                lockedBalance.unlockTime\\n            ]\\n                .add(lockedBalance.amount.multiplyDecimal(weights[i]));\\n            userWeights[account][pool] = weights[i];\\n        }\\n        userLockedBalances[account] = lockedBalance;\\n        emit Voted(\\n            account,\\n            oldLockedBalance.amount,\\n            oldLockedBalance.unlockTime,\\n            oldWeights,\\n            lockedBalance.amount,\\n            lockedBalance.unlockTime,\\n            weights\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/ManagedPausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Contract of an emergency stop mechanism that can be triggered by an authorized account.\\n *\\n * This module is modified based on Pausable in OpenZeppelin v3.3.0, adding public functions to\\n * pause, unpause and manage the pauser role. It is also designed to be used by upgradable\\n * contracts, like PausableUpgradable but with compact storage slots and no dependencies.\\n */\\nabstract contract ManagedPausable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    event PauserRoleTransferred(address indexed previousPauser, address indexed newPauser);\\n\\n    uint256 private constant FALSE = 0;\\n    uint256 private constant TRUE = 1;\\n\\n    uint256 private _initialized;\\n\\n    uint256 private _paused;\\n\\n    address private _pauser;\\n\\n    function _initializeManagedPausable(address pauser_) internal {\\n        require(_initialized == FALSE);\\n        _initialized = TRUE;\\n        _paused = FALSE;\\n        _pauser = pauser_;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view returns (bool) {\\n        return _paused != FALSE;\\n    }\\n\\n    function pauser() public view returns (address) {\\n        return _pauser;\\n    }\\n\\n    function renouncePauserRole() external onlyPauser {\\n        emit PauserRoleTransferred(_pauser, address(0));\\n        _pauser = address(0);\\n    }\\n\\n    function transferPauserRole(address newPauser) external onlyPauser {\\n        require(newPauser != address(0));\\n        emit PauserRoleTransferred(_pauser, newPauser);\\n        _pauser = newPauser;\\n    }\\n\\n    modifier onlyPauser() {\\n        require(_pauser == msg.sender, \\\"Pausable: only pauser\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(_paused == FALSE, \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(_paused != FALSE, \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function pause() external onlyPauser whenNotPaused {\\n        _paused = TRUE;\\n        emit Paused(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function unpause() external onlyPauser whenPaused {\\n        _paused = FALSE;\\n        emit Unpaused(msg.sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/ProxyUtility.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nabstract contract ProxyUtility {\\n    /// @dev Storage slot with the admin of the contract.\\n    bytes32 private constant _ADMIN_SLOT = bytes32(uint256(keccak256(\\\"eip1967.proxy.admin\\\")) - 1);\\n\\n    /// @dev Revert if the proxy admin is not the caller\\n    modifier onlyProxyAdmin() {\\n        bytes32 slot = _ADMIN_SLOT;\\n        address proxyAdmin;\\n        assembly {\\n            proxyAdmin := sload(slot)\\n        }\\n        require(msg.sender == proxyAdmin, \\\"Only proxy admin\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/exchange/LibOrderQueue.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\n/// @notice A maker order\\n/// @param prev Index of the previous order at the same premium-discount level,\\n///             or zero if this is the first one\\n/// @param next Index of the next order at the same premium-discount level,\\n///             or zero if this is the last one\\n/// @param maker Account placing this order\\n/// @param amount Original amount of the order, which is amount of quote asset with 18 decimal places\\n///               for a bid order, or amount of base asset for an ask order\\n/// @param version Rebalance version when the order is placed\\n/// @param fillable Currently fillable amount\\nstruct Order {\\n    uint256 prev;\\n    uint256 next;\\n    address maker;\\n    uint256 amount;\\n    uint256 version;\\n    uint256 fillable;\\n}\\n\\n/// @notice A queue of orders with the same premium-discount level.\\n///\\n///         An order queue assigns a unique index to each order and stores the orders in a doubly\\n///         linked list. Orders can be removed from the queue by cancellation, expiration or trade.\\n/// @param list Mapping of order index => order\\n/// @param head Index of the first order in the queue, or zero if the queue is empty\\n/// @param tail Index of the last order in the queue, or zero if the queue is empty\\n/// @param counter The total number of orders that have been added to the queue, no matter whether\\n///                they are still active or not\\nstruct OrderQueue {\\n    mapping(uint256 => Order) list;\\n    uint256 head;\\n    uint256 tail;\\n    uint256 counter;\\n}\\n\\n/// @title Tranchess's Exchange Order Queue Contract\\n/// @notice Order queue struct and implementation using doubly linked list\\n/// @author Tranchess\\nlibrary LibOrderQueue {\\n    function isEmpty(OrderQueue storage queue) internal view returns (bool) {\\n        return queue.head == 0;\\n    }\\n\\n    /// @notice Append a new order to the queue\\n    /// @param queue Order queue\\n    /// @param maker Maker address\\n    /// @param amount Amount to place in the order with 18 decimal places\\n    /// @param version Current rebalance version\\n    /// @return Index of the order in the order queue\\n    function append(\\n        OrderQueue storage queue,\\n        address maker,\\n        uint256 amount,\\n        uint256 version\\n    ) internal returns (uint256) {\\n        uint256 index = queue.counter + 1;\\n        queue.counter = index;\\n        uint256 tail = queue.tail;\\n        queue.list[index] = Order({\\n            prev: tail,\\n            next: 0,\\n            maker: maker,\\n            amount: amount,\\n            version: version,\\n            fillable: amount\\n        });\\n        if (tail == 0) {\\n            // The queue was empty.\\n            queue.head = index;\\n        } else {\\n            // The queue was not empty.\\n            queue.list[tail].next = index;\\n        }\\n        queue.tail = index;\\n        return index;\\n    }\\n\\n    /// @dev Cancel an order from the queue.\\n    /// @param queue Order queue\\n    /// @param index Index of the order to be canceled\\n    function cancel(OrderQueue storage queue, uint256 index) internal {\\n        uint256 oldHead = queue.head;\\n        if (index >= oldHead && oldHead > 0) {\\n            // The order is still active.\\n            Order storage order = queue.list[index];\\n            uint256 prev = order.prev;\\n            uint256 next = order.next;\\n            if (prev == 0) {\\n                // This is the first but not the only order.\\n                queue.head = next;\\n            } else {\\n                queue.list[prev].next = next;\\n            }\\n            if (next == 0) {\\n                // This is the last but not the only order.\\n                queue.tail = prev;\\n            } else {\\n                queue.list[next].prev = prev;\\n            }\\n        }\\n        delete queue.list[index];\\n    }\\n\\n    /// @dev Remove an order that is completely filled in matching. Links of the previous\\n    ///      and next order are not updated here. Caller must call `updateHead` after finishing\\n    ///      the matching on this queue.\\n    /// @param queue Order queue\\n    /// @param index Index of the order to be removed\\n    /// @return nextIndex Index of the next order, or zero if the removed order is the last one\\n    function fill(OrderQueue storage queue, uint256 index) internal returns (uint256 nextIndex) {\\n        nextIndex = queue.list[index].next;\\n        delete queue.list[index];\\n    }\\n\\n    /// @dev Update head and tail of the queue. This function should be called after matching\\n    ///      a taker order with this order queue and all orders before the new head are either\\n    ///      completely filled or expired.\\n    /// @param queue Order queue\\n    /// @param newHead Index of the first order that is still active now,\\n    ///                or zero if the queue is empty\\n    function updateHead(OrderQueue storage queue, uint256 newHead) internal {\\n        queue.head = newHead;\\n        if (newHead == 0) {\\n            queue.tail = 0;\\n        } else {\\n            queue.list[newHead].prev = 0;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/exchange/ExchangeRoles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"../../interfaces/IVotingEscrow.sol\\\";\\n\\n/// @title Tranchess's Exchange Role Contract\\n/// @notice Exchange role management\\n/// @author Tranchess\\nabstract contract ExchangeRoles {\\n    event MakerApplied(address indexed account, uint256 expiration);\\n\\n    /// @notice Voting Escrow.\\n    IVotingEscrow public immutable votingEscrow;\\n\\n    /// @notice Minimum vote-locked governance token balance required to place maker orders.\\n    uint256 public immutable makerRequirement;\\n\\n    /// @dev Mapping of account => maker expiration timestamp\\n    mapping(address => uint256) internal _makerExpiration;\\n\\n    constructor(address votingEscrow_, uint256 makerRequirement_) public {\\n        votingEscrow = IVotingEscrow(votingEscrow_);\\n        makerRequirement = makerRequirement_;\\n    }\\n\\n    // ------------------------------ MAKER ------------------------------------\\n    /// @notice Functions with this modifer can only be invoked by makers\\n    modifier onlyMaker() {\\n        require(isMaker(msg.sender), \\\"Only maker\\\");\\n        _;\\n    }\\n\\n    /// @notice Returns maker expiration timestamp of an account.\\n    ///         When `makerRequirement` is zero, this function always returns\\n    ///         an extremely large timestamp (2500-01-01 00:00:00 UTC).\\n    function makerExpiration(address account) external view returns (uint256) {\\n        return makerRequirement > 0 ? _makerExpiration[account] : 16725225600;\\n    }\\n\\n    /// @notice Verify if the account is an active maker or not\\n    /// @param account Account address to verify\\n    /// @return True if the account is an active maker; else returns false\\n    function isMaker(address account) public view returns (bool) {\\n        return makerRequirement == 0 || _makerExpiration[account] > block.timestamp;\\n    }\\n\\n    /// @notice Apply for maker membership\\n    function applyForMaker() external {\\n        require(makerRequirement > 0, \\\"No need to apply for maker\\\");\\n        // The membership will be valid until the current vote-locked governance\\n        // token balance drop below the requirement.\\n        uint256 expiration = votingEscrow.getTimestampDropBelow(msg.sender, makerRequirement);\\n        _makerExpiration[msg.sender] = expiration;\\n        emit MakerApplied(msg.sender, expiration);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/fund/FundRoles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/EnumerableSet.sol\\\";\\n\\nabstract contract FundRoles {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    EnumerableSet.AddressSet private _primaryMarketMembers;\\n    mapping(address => bool) private _shareMembers;\\n\\n    event PrimaryMarketAdded(address indexed primaryMarket);\\n    event PrimaryMarketRemoved(address indexed primaryMarket);\\n\\n    function _initializeRoles(\\n        address tokenM_,\\n        address tokenA_,\\n        address tokenB_,\\n        address primaryMarket_\\n    ) internal {\\n        _shareMembers[tokenM_] = true;\\n        _shareMembers[tokenA_] = true;\\n        _shareMembers[tokenB_] = true;\\n\\n        _addPrimaryMarket(primaryMarket_);\\n    }\\n\\n    modifier onlyPrimaryMarket() {\\n        require(isPrimaryMarket(msg.sender), \\\"FundRoles: only primary market\\\");\\n        _;\\n    }\\n\\n    function isPrimaryMarket(address account) public view returns (bool) {\\n        return _primaryMarketMembers.contains(account);\\n    }\\n\\n    function getPrimaryMarketMember(uint256 index) public view returns (address) {\\n        return _primaryMarketMembers.at(index);\\n    }\\n\\n    function getPrimaryMarketCount() public view returns (uint256) {\\n        return _primaryMarketMembers.length();\\n    }\\n\\n    function _addPrimaryMarket(address primaryMarket) internal {\\n        if (_primaryMarketMembers.add(primaryMarket)) {\\n            emit PrimaryMarketAdded(primaryMarket);\\n        }\\n    }\\n\\n    function _removePrimaryMarket(address primaryMarket) internal {\\n        if (_primaryMarketMembers.remove(primaryMarket)) {\\n            emit PrimaryMarketRemoved(primaryMarket);\\n        }\\n    }\\n\\n    modifier onlyShare() {\\n        require(isShare(msg.sender), \\\"FundRoles: only share\\\");\\n        _;\\n    }\\n\\n    function isShare(address account) public view returns (bool) {\\n        return _shareMembers[account];\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/fund/LibDelayedRedemption.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nstruct DelayedRedemptionItem {\\n    uint192 underlying;\\n    uint64 next;\\n}\\n\\nstruct DelayedRedemptionHeadTail {\\n    uint64 head;\\n    uint64 tail;\\n}\\n\\n/// @notice Delayed redemption\\n/// @param frozenQuote Amount of quote assets from the taker\\n/// @param effectiveQuote Effective amount of quote assets at zero premium-discount\\n/// @param reservedBase Reserved amount of base assets from the maker\\nstruct DelayedRedemption {\\n    DelayedRedemptionHeadTail headTail;\\n    mapping(uint64 => DelayedRedemptionItem) list;\\n}\\n\\nlibrary LibDelayedRedemption {\\n    using SafeMath for uint256;\\n\\n    function get(DelayedRedemption storage self, uint256 day)\\n        internal\\n        view\\n        returns (uint256, uint256)\\n    {\\n        DelayedRedemptionItem memory item = self.list[uint64(day)];\\n        return (item.underlying, item.next);\\n    }\\n\\n    /// @dev Append an item to the list.\\n    /// @param self The list to update\\n    /// @param underlying Redemption underlying amount\\n    /// @param day Trading day of the redemption\\n    function pushBack(\\n        DelayedRedemption storage self,\\n        uint256 underlying,\\n        uint256 day\\n    ) internal {\\n        uint64 day64 = uint64(day);\\n        require(uint192(underlying) == underlying && day64 == day);\\n        self.list[day64].underlying = uint192(underlying);\\n        DelayedRedemptionHeadTail memory headTail = self.headTail;\\n        require(day64 > headTail.tail);\\n        if (headTail.tail == 0) {\\n            // The list was empty.\\n            headTail.head = day64;\\n            headTail.tail = day64;\\n        } else {\\n            self.list[headTail.tail].next = day64;\\n            headTail.tail = day64;\\n        }\\n        self.headTail = headTail;\\n    }\\n\\n    /// @dev Remove all items until a given trading day and return the sum of all items.\\n    /// @param self The list to update\\n    /// @param day Trading day\\n    /// @return Sum of all redemptions that are removed from the list\\n    function popFrontUntil(DelayedRedemption storage self, uint256 day) internal returns (uint256) {\\n        uint64 day64 = uint64(day);\\n        require(day64 == day);\\n        DelayedRedemptionHeadTail memory headTail = self.headTail;\\n        uint64 p = headTail.head;\\n        if (p > day64 || p == 0) {\\n            return 0; // Fast path with no SSTORE\\n        }\\n        uint256 underlying = 0;\\n        while (p != 0 && p <= day64) {\\n            underlying = underlying.add(uint256(self.list[p].underlying));\\n            uint64 nextP = self.list[p].next;\\n            delete self.list[p];\\n            p = nextP;\\n        }\\n        if (p == 0) {\\n            delete self.headTail; // Set both head and tail to zero\\n        } else {\\n            headTail.head = p;\\n            self.headTail = headTail;\\n        }\\n        return underlying;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWrappedERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IWrappedERC20 is IERC20 {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256 wad) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/Initializable.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\nimport \\\"../proxy/Initializable.sol\\\";\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n    }\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.4.24 <0.8.0;\\n\\nimport \\\"../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || _isConstructor() || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /// @dev Returns true if and only if the function is running in the constructor\\n    function _isConstructor() private view returns (bool) {\\n        return !AddressUpgradeable.isContract(address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IControllerBallot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\ninterface IControllerBallot {\\n    function count(uint256 timestamp)\\n        external\\n        view\\n        returns (uint256[] memory ratios, address[] memory funds);\\n}\\n\"\r\n    },\r\n    \"contracts/misc/DataAggregator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\\\";\\nimport \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\\\";\\n\\nimport \\\"../interfaces/ITrancheIndexV2.sol\\\";\\nimport \\\"../interfaces/IChessSchedule.sol\\\";\\nimport \\\"../utils/CoreUtility.sol\\\";\\n\\nimport \\\"../fund/FundV3.sol\\\";\\nimport \\\"../fund/PrimaryMarketV3.sol\\\";\\nimport \\\"../fund/PrimaryMarketRouter.sol\\\";\\nimport \\\"../fund/ShareStaking.sol\\\";\\nimport \\\"../swap/StableSwap.sol\\\";\\nimport \\\"../swap/LiquidityGauge.sol\\\";\\nimport \\\"../swap/SwapBonus.sol\\\";\\nimport \\\"../swap/SwapRouter.sol\\\";\\nimport \\\"../governance/InterestRateBallot.sol\\\";\\nimport \\\"../governance/FeeDistributor.sol\\\";\\nimport \\\"../governance/VotingEscrowV2.sol\\\";\\nimport \\\"../governance/ControllerBallot.sol\\\";\\n\\ncontract DataAggregator is ITrancheIndexV2, CoreUtility {\\n    struct Data {\\n        uint256 blockNumber;\\n        uint256 blockTimestamp;\\n        FundAllData[] funds;\\n        GovernanceData governance;\\n        FeeDistributorData[] feeDistributors;\\n        ExternalSwapData[] externalSwaps;\\n    }\\n\\n    struct FundAllData {\\n        FundData fund;\\n        PrimaryMarketData primaryMarket;\\n        ShareStakingData shareStaking;\\n        StableSwapData bishopStableSwap;\\n        StableSwapData queenStableSwap;\\n        FundAccountData account;\\n    }\\n\\n    struct FundData {\\n        bool isFundActive;\\n        uint256 fundActivityStartTime;\\n        uint256 activityDelayTimeAfterRebalance;\\n        uint256 currentDay;\\n        uint256 dailyProtocolFeeRate;\\n        uint256 totalSupplyQ;\\n        uint256 totalSupplyB;\\n        uint256 totalUnderlying;\\n        uint256 strategyUnderlying;\\n        uint256 rebalanceSize;\\n        uint256 upperRebalanceThreshold;\\n        uint256 lowerRebalanceThreshold;\\n        uint256 splitRatio;\\n        uint256 latestUnderlyingPrice;\\n        uint256 navB;\\n        uint256 navR;\\n        uint256 currentInterestRate;\\n        FundV3.Rebalance lastRebalance;\\n    }\\n\\n    struct PrimaryMarketData {\\n        uint256 fundCap;\\n        uint256 redemptionFeeRate;\\n        uint256 mergeFeeRate;\\n        uint256 redemptionQueueHead;\\n    }\\n\\n    struct ShareStakingData {\\n        uint256 totalSupplyQ;\\n        uint256 totalSupplyB;\\n        uint256 totalSupplyR;\\n        uint256 weightedSupply;\\n        uint256 workingSupply;\\n        uint256 chessRate;\\n        ShareStakingAccountData account;\\n    }\\n\\n    struct ShareStakingAccountData {\\n        uint256 balanceQ;\\n        uint256 balanceB;\\n        uint256 balanceR;\\n        uint256 weightedBalance;\\n        uint256 workingBalance;\\n        uint256 claimableChess;\\n    }\\n\\n    struct StableSwapData {\\n        uint256 feeRate;\\n        uint256 adminFeeRate;\\n        uint256 ampl;\\n        uint256 currentD;\\n        uint256 currentPrice;\\n        uint256 baseBalance;\\n        uint256 quoteBalance;\\n        uint256 oraclePrice;\\n        uint256 lpTotalSupply;\\n        uint256 lpWorkingSupply;\\n        uint256 chessRate;\\n        uint256 lastDistributionQ;\\n        uint256 lastDistributionB;\\n        uint256 lastDistributionR;\\n        uint256 lastDistributionQuote;\\n        uint256 lastDistributionTotalSupply;\\n        address bonusToken;\\n        uint256 bonusRate;\\n        StableSwapAccountData account;\\n    }\\n\\n    struct StableSwapAccountData {\\n        uint256 lpBalance;\\n        uint256 workingBalance;\\n        uint256 claimableChess;\\n        uint256 claimableBonus;\\n        uint256 claimableQ;\\n        uint256 claimableB;\\n        uint256 claimableR;\\n        uint256 claimableQuote;\\n    }\\n\\n    struct FundAccountData {\\n        FundAccountBalanceData balance;\\n        FundAccountAllowanceData allowance;\\n    }\\n\\n    struct FundAccountBalanceData {\\n        uint256 underlying;\\n        uint256 quote;\\n        uint256 trancheQ;\\n        uint256 trancheB;\\n        uint256 trancheR;\\n    }\\n\\n    struct FundAccountAllowanceData {\\n        uint256 primaryMarketRouterUnderlying;\\n        uint256 primaryMarketRouterTrancheQ;\\n        uint256 swapRouterUnderlying;\\n        uint256 swapRouterTrancheQ;\\n        uint256 swapRouterTrancheB;\\n        uint256 swapRouterQuote;\\n        uint256 flashSwapRouterTrancheR;\\n        uint256 flashSwapRouterQuote;\\n        uint256 shareStakingTrancheQ;\\n        uint256 shareStakingTrancheB;\\n        uint256 shareStakingTrancheR;\\n    }\\n\\n    struct GovernanceData {\\n        uint256 chessRate;\\n        uint256 nextWeekChessRate;\\n        VotingEscrowData votingEscrow;\\n        InterestRateBallotData interestRateBallot;\\n        ControllerBallotData controllerBallot;\\n        GovernanceAccountData account;\\n    }\\n\\n    struct VotingEscrowData {\\n        uint256 totalLocked;\\n        uint256 totalSupply;\\n        uint256 tradingWeekTotalSupply;\\n        IVotingEscrow.LockedBalance account;\\n    }\\n\\n    struct InterestRateBallotData {\\n        uint256 tradingWeekTotalSupply;\\n        IBallot.Voter account;\\n    }\\n\\n    struct ControllerBallotData {\\n        address[] pools;\\n        uint256[] currentSums;\\n        ControllerBallotAccountData account;\\n    }\\n\\n    struct ControllerBallotAccountData {\\n        uint256 amount;\\n        uint256 unlockTime;\\n        uint256[] weights;\\n    }\\n\\n    struct GovernanceAccountData {\\n        GovernanceAccountBalanceData balance;\\n        GovernanceAccountAllowanceData allowance;\\n    }\\n\\n    struct GovernanceAccountBalanceData {\\n        uint256 nativeCurrency;\\n        uint256 chess;\\n    }\\n\\n    struct GovernanceAccountAllowanceData {\\n        uint256 votingEscrowChess;\\n    }\\n\\n    struct FeeDistributorData {\\n        uint256 currentRewards;\\n        uint256 currentSupply;\\n        uint256 tradingWeekTotalSupply;\\n        uint256 adminFeeRate;\\n        FeeDistributorAccountData account;\\n    }\\n\\n    struct FeeDistributorAccountData {\\n        uint256 claimableRewards;\\n        uint256 currentBalance;\\n        uint256 amount;\\n        uint256 unlockTime;\\n    }\\n\\n    struct ExternalSwapData {\\n        string symbol0;\\n        string symbol1;\\n        uint112 reserve0;\\n        uint112 reserve1;\\n    }\\n\\n    string public constant VERSION = \\\"2.0.0\\\";\\n\\n    VotingEscrowV2 public immutable votingEscrow;\\n    IChessSchedule public immutable chessSchedule;\\n    IERC20 public immutable chess;\\n    ControllerBallot public immutable controllerBallot;\\n    InterestRateBallot public immutable interestRateBallot;\\n    SwapRouter public immutable swapRouter;\\n    address public immutable flashSwapRouter;\\n    IERC20 public immutable bishopQuoteToken;\\n\\n    constructor(\\n        VotingEscrowV2 votingEscrow_,\\n        IChessSchedule chessSchedule_,\\n        ControllerBallot controllerBallot_,\\n        InterestRateBallot interestRateBallot_,\\n        SwapRouter swapRouter_,\\n        address flashSwapRouter_,\\n        IERC20 bishopQuoteToken_\\n    ) public {\\n        votingEscrow = votingEscrow_;\\n        chessSchedule = chessSchedule_;\\n        chess = IERC20(votingEscrow_.token());\\n        controllerBallot = controllerBallot_;\\n        interestRateBallot = interestRateBallot_;\\n        swapRouter = swapRouter_;\\n        flashSwapRouter = flashSwapRouter_;\\n        bishopQuoteToken = bishopQuoteToken_;\\n    }\\n\\n    function getData(\\n        PrimaryMarketRouter[] calldata primaryMarketRouters,\\n        ShareStaking[] calldata shareStakings,\\n        FeeDistributor[] calldata feeDistributors,\\n        address[] calldata externalSwaps,\\n        address account\\n    ) public returns (Data memory data) {\\n        data.blockNumber = block.number;\\n        data.blockTimestamp = block.timestamp;\\n\\n        data.funds = new FundAllData[](primaryMarketRouters.length);\\n        for (uint256 i = 0; i < primaryMarketRouters.length; i++) {\\n            data.funds[i] = getFundAllData(primaryMarketRouters[i], shareStakings[i], account);\\n        }\\n\\n        data.governance = getGovernanceData(account);\\n\\n        data.feeDistributors = new FeeDistributorData[](feeDistributors.length);\\n        for (uint256 i = 0; i < feeDistributors.length; i++) {\\n            data.feeDistributors[i] = getFeeDistributorData(feeDistributors[i], account);\\n        }\\n\\n        data.externalSwaps = new ExternalSwapData[](externalSwaps.length / 3);\\n        for (uint256 i = 0; i < externalSwaps.length / 3; i++) {\\n            data.externalSwaps[i] = getExternalSwapData(\\n                IUniswapV2Router01(externalSwaps[i * 3]),\\n                externalSwaps[i * 3 + 1],\\n                externalSwaps[i * 3 + 2]\\n            );\\n        }\\n    }\\n\\n    function getFundAllData(\\n        PrimaryMarketRouter primaryMarketRouter,\\n        ShareStaking shareStaking,\\n        address account\\n    ) public returns (FundAllData memory data) {\\n        FundV3 fund = FundV3(address(primaryMarketRouter.fund()));\\n        data.fund = getFundData(fund);\\n\\n        PrimaryMarketV3 primaryMarket =\\n            PrimaryMarketV3(payable(address(primaryMarketRouter.primaryMarket())));\\n        data.primaryMarket = getPrimaryMarketData(primaryMarket);\\n\\n        data.shareStaking = getShareStakingData(shareStaking, data.fund.splitRatio, account);\\n\\n        StableSwap bishopStableSwap =\\n            StableSwap(\\n                payable(\\n                    address(\\n                        swapRouter.getSwap(fund.tokenShare(TRANCHE_B), address(bishopQuoteToken))\\n                    )\\n                )\\n            );\\n        data.bishopStableSwap = getStableSwapData(bishopStableSwap, account);\\n\\n        IERC20 underlyingToken = IERC20(fund.tokenUnderlying());\\n        StableSwap queenStableSwap =\\n            StableSwap(\\n                payable(\\n                    address(\\n                        swapRouter.getSwap(fund.tokenShare(TRANCHE_Q), address(underlyingToken))\\n                    )\\n                )\\n            );\\n        if (address(queenStableSwap) != address(0)) {\\n            data.queenStableSwap = getStableSwapData(queenStableSwap, account);\\n        }\\n\\n        data.account.balance.underlying = underlyingToken.balanceOf(account);\\n        data.account.balance.quote = bishopQuoteToken.balanceOf(account);\\n        (\\n            data.account.balance.trancheQ,\\n            data.account.balance.trancheB,\\n            data.account.balance.trancheR\\n        ) = fund.trancheAllBalanceOf(account);\\n\\n        data.account.allowance.primaryMarketRouterUnderlying = underlyingToken.allowance(\\n            account,\\n            address(primaryMarketRouter)\\n        );\\n        data.account.allowance.primaryMarketRouterTrancheQ = fund.trancheAllowance(\\n            TRANCHE_Q,\\n            account,\\n            address(primaryMarketRouter)\\n        );\\n        data.account.allowance.swapRouterUnderlying = underlyingToken.allowance(\\n            account,\\n            address(swapRouter)\\n        );\\n        data.account.allowance.swapRouterTrancheQ = fund.trancheAllowance(\\n            TRANCHE_Q,\\n            account,\\n            address(swapRouter)\\n        );\\n        data.account.allowance.swapRouterTrancheB = fund.trancheAllowance(\\n            TRANCHE_B,\\n            account,\\n            address(swapRouter)\\n        );\\n        data.account.allowance.swapRouterQuote = bishopQuoteToken.allowance(\\n            account,\\n            address(swapRouter)\\n        );\\n        data.account.allowance.flashSwapRouterTrancheR = fund.trancheAllowance(\\n            TRANCHE_R,\\n            account,\\n            flashSwapRouter\\n        );\\n        data.account.allowance.flashSwapRouterQuote = bishopQuoteToken.allowance(\\n            account,\\n            flashSwapRouter\\n        );\\n        data.account.allowance.shareStakingTrancheQ = fund.trancheAllowance(\\n            TRANCHE_Q,\\n            account,\\n            address(shareStaking)\\n        );\\n        data.account.allowance.shareStakingTrancheB = fund.trancheAllowance(\\n            TRANCHE_B,\\n            account,\\n            address(shareStaking)\\n        );\\n        data.account.allowance.shareStakingTrancheR = fund.trancheAllowance(\\n            TRANCHE_R,\\n            account,\\n            address(shareStaking)\\n        );\\n    }\\n\\n    function getFundData(FundV3 fund) public view returns (FundData memory data) {\\n        ITwapOracleV2 twapOracle = fund.twapOracle();\\n\\n        data.isFundActive = fund.isFundActive(block.timestamp);\\n        data.fundActivityStartTime = fund.fundActivityStartTime();\\n        data.activityDelayTimeAfterRebalance = fund.activityDelayTimeAfterRebalance();\\n        data.currentDay = fund.currentDay();\\n        data.dailyProtocolFeeRate = fund.dailyProtocolFeeRate();\\n        data.totalSupplyQ = fund.trancheTotalSupply(TRANCHE_Q);\\n        data.totalSupplyB = fund.trancheTotalSupply(TRANCHE_B);\\n        data.totalUnderlying = fund.getTotalUnderlying();\\n        data.strategyUnderlying = fund.getStrategyUnderlying();\\n        data.rebalanceSize = fund.getRebalanceSize();\\n        data.upperRebalanceThreshold = fund.upperRebalanceThreshold();\\n        data.lowerRebalanceThreshold = fund.lowerRebalanceThreshold();\\n        data.splitRatio = fund.splitRatio();\\n        data.latestUnderlyingPrice = getLatestPrice(twapOracle);\\n        if (data.splitRatio != 0) {\\n            (, data.navB, data.navR) = fund.extrapolateNav(data.latestUnderlyingPrice);\\n            data.currentInterestRate = fund.historicalInterestRate(data.currentDay - 1 days);\\n        }\\n        data.lastRebalance = fund.getRebalance(\\n            data.rebalanceSize == 0 ? 0 : data.rebalanceSize - 1\\n        );\\n    }\\n\\n    function getLatestPrice(ITwapOracleV2 twapOracle) public view returns (uint256) {\\n        (bool success, bytes memory encodedPrice) =\\n            address(twapOracle).staticcall(abi.encodeWithSignature(\\\"getLatest()\\\"));\\n        if (success) {\\n            return abi.decode(encodedPrice, (uint256));\\n        } else {\\n            uint256 lastEpoch = (block.timestamp / 30 minutes) * 30 minutes;\\n            for (uint256 i = 0; i < 48; i++) {\\n                // Search for the latest TWAP\\n                uint256 twap = twapOracle.getTwap(lastEpoch - i * 30 minutes);\\n                if (twap != 0) {\\n                    return twap;\\n                }\\n            }\\n        }\\n    }\\n\\n    function getPrimaryMarketData(PrimaryMarketV3 primaryMarket)\\n        public\\n        view\\n        returns (PrimaryMarketData memory data)\\n    {\\n        data.fundCap = primaryMarket.fundCap();\\n        data.redemptionFeeRate = primaryMarket.redemptionFeeRate();\\n        data.mergeFeeRate = primaryMarket.mergeFeeRate();\\n        data.redemptionQueueHead = primaryMarket.getNewRedemptionQueueHead();\\n    }\\n\\n    function getShareStakingData(\\n        ShareStaking shareStaking,\\n        uint256 splitRatio,\\n        address account\\n    ) public returns (ShareStakingData memory data) {\\n        data.account.claimableChess = shareStaking.claimableRewards(account);\\n        data.totalSupplyQ = shareStaking.totalSupply(TRANCHE_Q);\\n        data.totalSupplyB = shareStaking.totalSupply(TRANCHE_B);\\n        data.totalSupplyR = shareStaking.totalSupply(TRANCHE_R);\\n        data.weightedSupply = shareStaking.weightedBalance(\\n            data.totalSupplyQ,\\n            data.totalSupplyB,\\n            data.totalSupplyR,\\n            splitRatio\\n        );\\n        data.workingSupply = shareStaking.workingSupply();\\n        data.chessRate = shareStaking.getRate();\\n        data.account.balanceQ = shareStaking.trancheBalanceOf(TRANCHE_Q, account);\\n        data.account.balanceB = shareStaking.trancheBalanceOf(TRANCHE_B, account);\\n        data.account.balanceR = shareStaking.trancheBalanceOf(TRANCHE_R, account);\\n        data.account.weightedBalance = shareStaking.weightedBalance(\\n            data.account.balanceQ,\\n            data.account.balanceB,\\n            data.account.balanceR,\\n            splitRatio\\n        );\\n        data.account.workingBalance = shareStaking.workingBalanceOf(account);\\n    }\\n\\n    function getStableSwapData(StableSwap stableSwap, address account)\\n        public\\n        returns (StableSwapData memory data)\\n    {\\n        LiquidityGauge lp = LiquidityGauge(stableSwap.lpToken());\\n        SwapBonus swapBonus = SwapBonus(lp.swapBonus());\\n\\n        // Trigger checkpoint\\n        (\\n            data.account.claimableChess,\\n            data.account.claimableBonus,\\n            data.account.claimableQ,\\n            data.account.claimableB,\\n            data.account.claimableR,\\n            data.account.claimableQuote\\n        ) = lp.claimableRewards(account);\\n        data.account.lpBalance = lp.balanceOf(account);\\n        data.account.workingBalance = lp.workingBalanceOf(account);\\n\\n        data.feeRate = stableSwap.feeRate();\\n        data.adminFeeRate = stableSwap.adminFeeRate();\\n        data.ampl = stableSwap.getAmpl();\\n        data.lpTotalSupply = lp.totalSupply();\\n        if (data.lpTotalSupply != 0) {\\n            // Handle rebalance\\n            stableSwap.sync();\\n        }\\n        data.lpWorkingSupply = lp.workingSupply();\\n        (data.baseBalance, data.quoteBalance) = stableSwap.allBalances();\\n        data.chessRate = lp.getRate();\\n        uint256 lpVersion = lp.latestVersion();\\n        (\\n            data.lastDistributionQ,\\n            data.lastDistributionB,\\n            data.lastDistributionR,\\n            data.lastDistributionQuote\\n        ) = lp.distributions(lpVersion);\\n        data.lastDistributionTotalSupply = lp.distributionTotalSupplies(lpVersion);\\n        data.bonusToken = swapBonus.bonusToken();\\n        data.bonusRate = block.timestamp < swapBonus.endTimestamp() ? swapBonus.ratePerSecond() : 0;\\n\\n        (bool success, bytes memory encodedOraclePrice) =\\n            address(stableSwap).call(abi.encodeWithSignature(\\\"getOraclePrice()\\\"));\\n        if (success) {\\n            data.currentD = stableSwap.getCurrentD();\\n            data.currentPrice = stableSwap.getCurrentPrice();\\n            data.oraclePrice = abi.decode(encodedOraclePrice, (uint256));\\n        }\\n    }\\n\\n    function getGovernanceData(address account) public view returns (GovernanceData memory data) {\\n        uint256 blockCurrentWeek = _endOfWeek(block.timestamp);\\n\\n        data.chessRate = chessSchedule.getRate(block.timestamp);\\n        data.nextWeekChessRate = chessSchedule.getRate(block.timestamp + 1 weeks);\\n\\n        data.votingEscrow.totalLocked = votingEscrow.totalLocked();\\n        data.votingEscrow.totalSupply = votingEscrow.totalSupply();\\n        data.votingEscrow.tradingWeekTotalSupply = votingEscrow.totalSupplyAtTimestamp(\\n            blockCurrentWeek\\n        );\\n        data.votingEscrow.account = votingEscrow.getLockedBalance(account);\\n\\n        data.interestRateBallot.tradingWeekTotalSupply = interestRateBallot.totalSupplyAtTimestamp(\\n            blockCurrentWeek\\n        );\\n        data.interestRateBallot.account = interestRateBallot.getReceipt(account);\\n\\n        data.controllerBallot = getControllerBallotData(account);\\n\\n        data.account.balance.nativeCurrency = account.balance;\\n        data.account.balance.chess = chess.balanceOf(account);\\n        data.account.allowance.votingEscrowChess = chess.allowance(account, address(votingEscrow));\\n    }\\n\\n    function getControllerBallotData(address account)\\n        public\\n        view\\n        returns (ControllerBallotData memory data)\\n    {\\n        data.pools = controllerBallot.getPools();\\n        // TODO handle disabled pools\\n        data.currentSums = new uint256[](data.pools.length);\\n        (data.account.amount, data.account.unlockTime) = controllerBallot.userLockedBalances(\\n            account\\n        );\\n        data.account.weights = new uint256[](data.pools.length);\\n        for (uint256 i = 0; i < data.pools.length; i++) {\\n            address pool = data.pools[i];\\n            data.currentSums[i] = controllerBallot.sumAtTimestamp(pool, block.timestamp);\\n            data.account.weights[i] = controllerBallot.userWeights(account, pool);\\n        }\\n    }\\n\\n    function getFeeDistributorData(FeeDistributor feeDistributor, address account)\\n        public\\n        returns (FeeDistributorData memory data)\\n    {\\n        data.account.claimableRewards = feeDistributor.userCheckpoint(account);\\n        data.account.currentBalance = feeDistributor.userLastBalances(account);\\n        (data.account.amount, data.account.unlockTime) = feeDistributor.userLockedBalances(account);\\n        uint256 blockCurrentWeek = _endOfWeek(block.timestamp);\\n        data.currentRewards = feeDistributor.rewardsPerWeek(blockCurrentWeek - 1 weeks);\\n        data.currentSupply = feeDistributor.veSupplyPerWeek(blockCurrentWeek - 1 weeks);\\n        data.tradingWeekTotalSupply = feeDistributor.totalSupplyAtTimestamp(blockCurrentWeek);\\n        data.adminFeeRate = feeDistributor.adminFeeRate();\\n    }\\n\\n    function getExternalSwapData(\\n        IUniswapV2Router01 router,\\n        address token0,\\n        address token1\\n    ) public view returns (ExternalSwapData memory data) {\\n        IUniswapV2Pair pair =\\n            IUniswapV2Pair(IUniswapV2Factory(router.factory()).getPair(token0, token1));\\n        data.symbol0 = ERC20(token0).symbol();\\n        data.symbol1 = ERC20(token1).symbol();\\n        if (pair.token0() == token0) {\\n            (data.reserve0, data.reserve1, ) = pair.getReserves();\\n        } else {\\n            (data.reserve1, data.reserve0, ) = pair.getReserves();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name_, string memory symbol_) public {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal virtual {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"contracts/fund/PrimaryMarketV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"../utils/SafeDecimalMath.sol\\\";\\n\\nimport \\\"../interfaces/IPrimaryMarketV3.sol\\\";\\nimport \\\"../interfaces/ITrancheIndexV2.sol\\\";\\nimport \\\"../interfaces/IWrappedERC20.sol\\\";\\n\\ncontract PrimaryMarketV3 is IPrimaryMarketV3, ReentrancyGuard, ITrancheIndexV2, Ownable {\\n    event Created(address indexed account, uint256 underlying, uint256 outQ);\\n    event Redeemed(address indexed account, uint256 inQ, uint256 underlying, uint256 fee);\\n    event Split(address indexed account, uint256 inQ, uint256 outB, uint256 outR);\\n    event Merged(\\n        address indexed account,\\n        uint256 outQ,\\n        uint256 inB,\\n        uint256 inR,\\n        uint256 feeUnderlying\\n    );\\n    event RedemptionQueued(address indexed account, uint256 index, uint256 underlying);\\n    event RedemptionPopped(uint256 count, uint256 newHead, uint256 requiredUnderlying);\\n    event RedemptionClaimed(address indexed account, uint256 index, uint256 underlying);\\n    event FundCapUpdated(uint256 newCap);\\n    event RedemptionFeeRateUpdated(uint256 newRedemptionFeeRate);\\n    event MergeFeeRateUpdated(uint256 newMergeFeeRate);\\n\\n    using SafeMath for uint256;\\n    using SafeDecimalMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    struct QueuedRedemption {\\n        address account;\\n        uint256 underlying;\\n        uint256 previousPrefixSum;\\n    }\\n\\n    uint256 private constant MAX_REDEMPTION_FEE_RATE = 0.01e18;\\n    uint256 private constant MAX_MERGE_FEE_RATE = 0.01e18;\\n\\n    IFundV3 public immutable override fund;\\n    IERC20 private immutable _tokenUnderlying;\\n\\n    uint256 public redemptionFeeRate;\\n    uint256 public mergeFeeRate;\\n\\n    /// @notice The upper limit of underlying that the fund can hold. This contract rejects\\n    ///         creations that may break this limit.\\n    /// @dev This limit can be bypassed if the fund has multiple primary markets.\\n    ///\\n    ///      Set it to uint(-1) to skip the check and save gas.\\n    uint256 public fundCap;\\n\\n    /// @notice Queue of redemptions that cannot be claimed yet. Key is a sequential index\\n    ///         starting from zero. Value is a tuple of user address, redeemed underlying and\\n    ///         prefix sum before this entry.\\n    mapping(uint256 => QueuedRedemption) public queuedRedemptions;\\n\\n    /// @notice Total underlying tokens of claimable queued redemptions.\\n    uint256 public claimableUnderlying;\\n\\n    /// @notice Index of the redemption queue head. All redemptions with index smaller than\\n    ///         this value can be claimed now.\\n    uint256 public redemptionQueueHead;\\n\\n    /// @notice Index of the redemption following the last entry of the queue. The next queued\\n    ///         redemption will be written at this index.\\n    uint256 public redemptionQueueTail;\\n\\n    constructor(\\n        address fund_,\\n        uint256 redemptionFeeRate_,\\n        uint256 mergeFeeRate_,\\n        uint256 fundCap_\\n    ) public Ownable() {\\n        fund = IFundV3(fund_);\\n        _tokenUnderlying = IERC20(IFundV3(fund_).tokenUnderlying());\\n        _updateRedemptionFeeRate(redemptionFeeRate_);\\n        _updateMergeFeeRate(mergeFeeRate_);\\n        _updateFundCap(fundCap_);\\n    }\\n\\n    /// @notice Calculate the result of a creation.\\n    /// @param underlying Underlying amount spent for the creation\\n    /// @return outQ Created QUEEN amount\\n    function getCreation(uint256 underlying) public view override returns (uint256 outQ) {\\n        uint256 fundUnderlying = fund.getTotalUnderlying();\\n        uint256 fundEquivalentTotalQ = fund.getEquivalentTotalQ();\\n        require(fundUnderlying.add(underlying) <= fundCap, \\\"Exceed fund cap\\\");\\n        if (fundEquivalentTotalQ == 0) {\\n            outQ = underlying.mul(fund.underlyingDecimalMultiplier());\\n            uint256 splitRatio = fund.splitRatio();\\n            require(splitRatio != 0, \\\"Fund is not initialized\\\");\\n            uint256 settledDay = fund.currentDay() - 1 days;\\n            uint256 underlyingPrice = fund.twapOracle().getTwap(settledDay);\\n            (uint256 navB, uint256 navR) = fund.historicalNavs(settledDay);\\n            outQ = outQ.mul(underlyingPrice).div(splitRatio).divideDecimal(navB.add(navR));\\n        } else {\\n            require(\\n                fundUnderlying != 0,\\n                \\\"Cannot create QUEEN for fund with shares but no underlying\\\"\\n            );\\n            outQ = underlying.mul(fundEquivalentTotalQ).div(fundUnderlying);\\n        }\\n    }\\n\\n    /// @notice Calculate the amount of underlying tokens to create at least the given QUEEN amount.\\n    ///         This only works with non-empty fund for simplicity.\\n    /// @param minOutQ Minimum received QUEEN amount\\n    /// @return underlying Underlying amount that should be used for creation\\n    function getCreationForQ(uint256 minOutQ) external view override returns (uint256 underlying) {\\n        // Assume:\\n        //   minOutQ * fundUnderlying = a * fundEquivalentTotalQ - b\\n        // where a and b are integers and 0 <= b < fundEquivalentTotalQ\\n        // Then\\n        //   underlying = a\\n        //   getCreation(underlying)\\n        //     = floor(a * fundEquivalentTotalQ / fundUnderlying)\\n        //    >= floor((a * fundEquivalentTotalQ - b) / fundUnderlying)\\n        //     = minOutQ\\n        //   getCreation(underlying - 1)\\n        //     = floor((a * fundEquivalentTotalQ - fundEquivalentTotalQ) / fundUnderlying)\\n        //     < (a * fundEquivalentTotalQ - b) / fundUnderlying\\n        //     = minOutQ\\n        uint256 fundUnderlying = fund.getTotalUnderlying();\\n        uint256 fundEquivalentTotalQ = fund.getEquivalentTotalQ();\\n        require(fundEquivalentTotalQ > 0, \\\"Cannot calculate creation for empty fund\\\");\\n        return minOutQ.mul(fundUnderlying).add(fundEquivalentTotalQ - 1).div(fundEquivalentTotalQ);\\n    }\\n\\n    function _getRedemptionBeforeFee(uint256 inQ) private view returns (uint256 underlying) {\\n        uint256 fundUnderlying = fund.getTotalUnderlying();\\n        uint256 fundEquivalentTotalQ = fund.getEquivalentTotalQ();\\n        underlying = inQ.mul(fundUnderlying).div(fundEquivalentTotalQ);\\n    }\\n\\n    /// @notice Calculate the result of a redemption.\\n    /// @param inQ QUEEN amount spent for the redemption\\n    /// @return underlying Redeemed underlying amount\\n    /// @return fee Underlying amount charged as redemption fee\\n    function getRedemption(uint256 inQ)\\n        public\\n        view\\n        override\\n        returns (uint256 underlying, uint256 fee)\\n    {\\n        underlying = _getRedemptionBeforeFee(inQ);\\n        fee = underlying.multiplyDecimal(redemptionFeeRate);\\n        underlying = underlying.sub(fee);\\n    }\\n\\n    /// @notice Calculate the amount of QUEEN that can be redeemed for at least the given amount\\n    ///         of underlying tokens.\\n    /// @dev The return value may not be the minimum solution due to rounding errors.\\n    /// @param minUnderlying Minimum received underlying amount\\n    /// @return inQ QUEEN amount that should be redeemed\\n    function getRedemptionForUnderlying(uint256 minUnderlying)\\n        external\\n        view\\n        override\\n        returns (uint256 inQ)\\n    {\\n        // Assume:\\n        //   minUnderlying * 1e18 = a * (1e18 - redemptionFeeRate) + b\\n        //   a * fundEquivalentTotalQ = c * fundUnderlying - d\\n        // where\\n        //   a, b, c, d are integers\\n        //   0 <= b < 1e18 - redemptionFeeRate\\n        //   0 <= d < fundUnderlying\\n        // Then\\n        //   underlyingBeforeFee = a\\n        //   inQ = c\\n        //   getRedemption(inQ).underlying\\n        //     = floor(c * fundUnderlying / fundEquivalentTotalQ) -\\n        //       - floor(floor(c * fundUnderlying / fundEquivalentTotalQ) * redemptionFeeRate / 1e18)\\n        //     = ceil(floor(c * fundUnderlying / fundEquivalentTotalQ) * (1e18 - redemptionFeeRate) / 1e18)\\n        //    >= ceil(floor((c * fundUnderlying - d) / fundEquivalentTotalQ) * (1e18 - redemptionFeeRate) / 1e18)\\n        //     = ceil(a * (1e18 - redemptionFeeRate) / 1e18)\\n        //     = (a * (1e18 - redemptionFeeRate) + b) / 1e18        // because b < 1e18\\n        //     = minUnderlying\\n        uint256 fundUnderlying = fund.getTotalUnderlying();\\n        uint256 fundEquivalentTotalQ = fund.getEquivalentTotalQ();\\n        uint256 underlyingBeforeFee = minUnderlying.divideDecimal(1e18 - redemptionFeeRate);\\n        return\\n            underlyingBeforeFee.mul(fundEquivalentTotalQ).add(fundUnderlying - 1).div(\\n                fundUnderlying\\n            );\\n    }\\n\\n    /// @notice Calculate the result of a split.\\n    /// @param inQ QUEEN amount to be split\\n    /// @return outB Received BISHOP amount, which is also received ROOK amount\\n    function getSplit(uint256 inQ) public view override returns (uint256 outB) {\\n        return inQ.multiplyDecimal(fund.splitRatio());\\n    }\\n\\n    /// @notice Calculate the amount of QUEEN that can be split into at least the given amount of\\n    ///         BISHOP and ROOK.\\n    /// @param minOutB Received BISHOP amount, which is also received ROOK amount\\n    /// @return inQ QUEEN amount that should be split\\n    function getSplitForB(uint256 minOutB) external view override returns (uint256 inQ) {\\n        uint256 splitRatio = fund.splitRatio();\\n        return minOutB.mul(1e18).add(splitRatio.sub(1)).div(splitRatio);\\n    }\\n\\n    /// @notice Calculate the result of a merge.\\n    /// @param inB Spent BISHOP amount, which is also spent ROOK amount\\n    /// @return outQ Received QUEEN amount\\n    /// @return feeQ QUEEN amount charged as merge fee\\n    function getMerge(uint256 inB) public view override returns (uint256 outQ, uint256 feeQ) {\\n        uint256 outQBeforeFee = inB.divideDecimal(fund.splitRatio());\\n        feeQ = outQBeforeFee.multiplyDecimal(mergeFeeRate);\\n        outQ = outQBeforeFee.sub(feeQ);\\n    }\\n\\n    /// @notice Calculate the amount of BISHOP and ROOK that can be merged into at least\\n    ///      the given amount of QUEEN.\\n    /// @dev The return value may not be the minimum solution due to rounding errors.\\n    /// @param minOutQ Minimum received QUEEN amount\\n    /// @return inB BISHOP amount that should be merged, which is also spent ROOK amount\\n    function getMergeForQ(uint256 minOutQ) external view override returns (uint256 inB) {\\n        // Assume:\\n        //   minOutQ * 1e18 = a * (1e18 - mergeFeeRate) + b\\n        //   c = ceil(a * splitRatio / 1e18)\\n        // where a and b are integers and 0 <= b < 1e18 - mergeFeeRate\\n        // Then\\n        //   outQBeforeFee = a\\n        //   inB = c\\n        //   getMerge(inB).outQ\\n        //     = c * 1e18 / splitRatio - floor(c * 1e18 / splitRatio * mergeFeeRate / 1e18)\\n        //     = ceil(c * 1e18 / splitRatio * (1e18 - mergeFeeRate) / 1e18)\\n        //    >= ceil(a * (1e18 - mergeFeeRate) / 1e18)\\n        //     = (a * (1e18 - mergeFeeRate) + b) / 1e18         // because b < 1e18\\n        //     = minOutQ\\n        uint256 outQBeforeFee = minOutQ.divideDecimal(1e18 - mergeFeeRate);\\n        inB = outQBeforeFee.mul(fund.splitRatio()).add(1e18 - 1).div(1e18);\\n    }\\n\\n    /// @notice Return index of the first queued redemption that cannot be claimed now.\\n    ///         Users can use this function to determine which indices can be passed to\\n    ///         `claimRedemptions()`.\\n    /// @return Index of the first redemption that cannot be claimed now\\n    function getNewRedemptionQueueHead() external view returns (uint256) {\\n        uint256 available = _tokenUnderlying.balanceOf(address(fund));\\n        uint256 l = redemptionQueueHead;\\n        uint256 r = redemptionQueueTail;\\n        uint256 startPrefixSum = queuedRedemptions[l].previousPrefixSum;\\n        // overflow is desired\\n        if (queuedRedemptions[r].previousPrefixSum - startPrefixSum <= available) {\\n            return r;\\n        }\\n        // Iteration count is bounded by log2(tail - head), which is at most 256.\\n        while (l + 1 < r) {\\n            uint256 m = (l + r) / 2;\\n            if (queuedRedemptions[m].previousPrefixSum - startPrefixSum <= available) {\\n                l = m;\\n            } else {\\n                r = m;\\n            }\\n        }\\n        return l;\\n    }\\n\\n    /// @notice Search in the redemption queue.\\n    /// @param account Owner of the redemptions, or zero address to return all redemptions\\n    /// @param startIndex Redemption index where the search starts, or zero to start from the head\\n    /// @param maxIterationCount Maximum number of redemptions to be scanned, or zero for no limit\\n    /// @return indices Indices of found redemptions\\n    /// @return underlying Total underlying of found redemptions\\n    function getQueuedRedemptions(\\n        address account,\\n        uint256 startIndex,\\n        uint256 maxIterationCount\\n    ) external view returns (uint256[] memory indices, uint256 underlying) {\\n        uint256 head = redemptionQueueHead;\\n        uint256 tail = redemptionQueueTail;\\n        if (startIndex == 0) {\\n            startIndex = head;\\n        } else {\\n            require(startIndex >= head && startIndex <= tail, \\\"startIndex out of bound\\\");\\n        }\\n        uint256 endIndex = tail;\\n        if (maxIterationCount != 0 && tail - startIndex > maxIterationCount) {\\n            endIndex = startIndex + maxIterationCount;\\n        }\\n        indices = new uint256[](endIndex - startIndex);\\n        uint256 count = 0;\\n        for (uint256 i = startIndex; i < endIndex; i++) {\\n            if (account == address(0) || queuedRedemptions[i].account == account) {\\n                indices[count] = i;\\n                underlying += queuedRedemptions[i].underlying;\\n                count++;\\n            }\\n        }\\n        if (count != endIndex - startIndex) {\\n            // Shrink the array\\n            assembly {\\n                mstore(indices, count)\\n            }\\n        }\\n    }\\n\\n    /// @notice Return whether the fund can change its primary market to another contract.\\n    function canBeRemovedFromFund() external view override returns (bool) {\\n        return redemptionQueueHead == redemptionQueueTail;\\n    }\\n\\n    /// @notice Create QUEEN using underlying tokens. This function should be called by\\n    ///         a smart contract, which transfers underlying tokens to this contract\\n    ///         in the same transaction.\\n    /// @param recipient Address that will receive created QUEEN\\n    /// @param minOutQ Minimum QUEEN amount to be received\\n    /// @param version The latest rebalance version\\n    /// @return outQ Received QUEEN amount\\n    function create(\\n        address recipient,\\n        uint256 minOutQ,\\n        uint256 version\\n    ) external override nonReentrant returns (uint256 outQ) {\\n        uint256 underlying = _tokenUnderlying.balanceOf(address(this)).sub(claimableUnderlying);\\n        outQ = getCreation(underlying);\\n        require(outQ >= minOutQ && outQ > 0, \\\"Min QUEEN created\\\");\\n        fund.primaryMarketMint(TRANCHE_Q, recipient, outQ, version);\\n        _tokenUnderlying.safeTransfer(address(fund), underlying);\\n        emit Created(recipient, underlying, outQ);\\n    }\\n\\n    /// @notice Redeem QUEEN to get underlying tokens back. Revert if there are still some\\n    ///         queued redemptions that cannot be claimed now.\\n    /// @param recipient Address that will receive redeemed underlying tokens\\n    /// @param inQ Spent QUEEN amount\\n    /// @param minUnderlying Minimum amount of underlying tokens to be received\\n    /// @param version The latest rebalance version\\n    /// @return underlying Received underlying amount\\n    function redeem(\\n        address recipient,\\n        uint256 inQ,\\n        uint256 minUnderlying,\\n        uint256 version\\n    ) external override nonReentrant returns (uint256 underlying) {\\n        underlying = _redeem(recipient, inQ, minUnderlying, version);\\n    }\\n\\n    /// @notice Redeem QUEEN to get native currency back. The underlying must be wrapped token\\n    ///         of the native currency. Revert if there are still some queued redemptions that\\n    ///         cannot be claimed now.\\n    /// @param recipient Address that will receive redeemed underlying tokens\\n    /// @param inQ Spent QUEEN amount\\n    /// @param minUnderlying Minimum amount of underlying tokens to be received\\n    /// @param version The latest rebalance version\\n    /// @return underlying Received underlying amount\\n    function redeemAndUnwrap(\\n        address recipient,\\n        uint256 inQ,\\n        uint256 minUnderlying,\\n        uint256 version\\n    ) external override nonReentrant returns (uint256 underlying) {\\n        underlying = _redeem(address(this), inQ, minUnderlying, version);\\n        IWrappedERC20(address(_tokenUnderlying)).withdraw(underlying);\\n        (bool success, ) = recipient.call{value: underlying}(\\\"\\\");\\n        require(success, \\\"Transfer failed\\\");\\n    }\\n\\n    function _redeem(\\n        address recipient,\\n        uint256 inQ,\\n        uint256 minUnderlying,\\n        uint256 version\\n    ) private returns (uint256 underlying) {\\n        uint256 fee;\\n        (underlying, fee) = getRedemption(inQ);\\n        fund.primaryMarketBurn(TRANCHE_Q, msg.sender, inQ, version);\\n        _popRedemptionQueue(0);\\n        require(underlying >= minUnderlying && underlying > 0, \\\"Min underlying redeemed\\\");\\n        // Redundant check for user-friendly revert message.\\n        require(\\n            underlying <= _tokenUnderlying.balanceOf(address(fund)),\\n            \\\"Not enough underlying in fund\\\"\\n        );\\n        fund.primaryMarketTransferUnderlying(recipient, underlying, fee);\\n        emit Redeemed(recipient, inQ, underlying, fee);\\n    }\\n\\n    /// @notice Redeem QUEEN and wait in the redemption queue. Redeemed underlying tokens will\\n    ///         be claimable when the fund has enough balance to pay this redemption and all\\n    ///         previous ones in the queue.\\n    /// @param recipient Address that will receive redeemed underlying tokens\\n    /// @param inQ Spent QUEEN amount\\n    /// @param minUnderlying Minimum amount of underlying tokens to be received\\n    /// @param version The latest rebalance version\\n    /// @return underlying Received underlying amount\\n    /// @return index Index of the queued redemption\\n    function queueRedemption(\\n        address recipient,\\n        uint256 inQ,\\n        uint256 minUnderlying,\\n        uint256 version\\n    ) external override nonReentrant returns (uint256 underlying, uint256 index) {\\n        uint256 fee;\\n        (underlying, fee) = getRedemption(inQ);\\n        fund.primaryMarketBurn(TRANCHE_Q, msg.sender, inQ, version);\\n        require(underlying >= minUnderlying && underlying > 0, \\\"Min underlying redeemed\\\");\\n        index = redemptionQueueTail;\\n        QueuedRedemption storage newRedemption = queuedRedemptions[index];\\n        newRedemption.account = recipient;\\n        newRedemption.underlying = underlying;\\n        // overflow is desired\\n        queuedRedemptions[index + 1].previousPrefixSum =\\n            newRedemption.previousPrefixSum +\\n            underlying;\\n        redemptionQueueTail = index + 1;\\n        fund.primaryMarketAddDebt(underlying, fee);\\n        emit Redeemed(recipient, inQ, underlying, fee);\\n        emit RedemptionQueued(recipient, index, underlying);\\n    }\\n\\n    /// @notice Remove a given number of redemptions from the front of the redemption queue and\\n    ///         fetch underlying tokens of these redemptions from the fund. Revert if the fund\\n    ///         cannot pay these redemptions now.\\n    /// @param count The number of redemptions to be removed, or zero to completely empty the queue\\n    function popRedemptionQueue(uint256 count) external nonReentrant {\\n        _popRedemptionQueue(count);\\n    }\\n\\n    function _popRedemptionQueue(uint256 count) private {\\n        uint256 oldHead = redemptionQueueHead;\\n        uint256 oldTail = redemptionQueueTail;\\n        uint256 newHead;\\n        if (count == 0) {\\n            if (oldHead == oldTail) {\\n                return;\\n            }\\n            newHead = oldTail;\\n        } else {\\n            newHead = oldHead.add(count);\\n            require(newHead <= oldTail, \\\"Redemption queue out of bound\\\");\\n        }\\n        // overflow is desired\\n        uint256 requiredUnderlying =\\n            queuedRedemptions[newHead].previousPrefixSum -\\n                queuedRedemptions[oldHead].previousPrefixSum;\\n        // Redundant check for user-friendly revert message.\\n        require(\\n            requiredUnderlying <= _tokenUnderlying.balanceOf(address(fund)),\\n            \\\"Not enough underlying in fund\\\"\\n        );\\n        claimableUnderlying = claimableUnderlying.add(requiredUnderlying);\\n        fund.primaryMarketPayDebt(requiredUnderlying);\\n        redemptionQueueHead = newHead;\\n        emit RedemptionPopped(newHead - oldHead, newHead, requiredUnderlying);\\n    }\\n\\n    /// @notice Claim underlying tokens of queued redemptions. All these redemptions must\\n    ///         belong to the same account.\\n    /// @param account Recipient of the redemptions\\n    /// @param indices Indices of the redemptions in the queue, which must be in increasing order\\n    /// @return underlying Total claimed underlying amount\\n    function claimRedemptions(address account, uint256[] calldata indices)\\n        external\\n        override\\n        nonReentrant\\n        returns (uint256 underlying)\\n    {\\n        underlying = _claimRedemptions(account, indices);\\n        _tokenUnderlying.safeTransfer(account, underlying);\\n    }\\n\\n    /// @notice Claim native currency of queued redemptions. The underlying must be wrapped token\\n    ///         of the native currency. All these redemptions must belong to the same account.\\n    /// @param account Recipient of the redemptions\\n    /// @param indices Indices of the redemptions in the queue, which must be in increasing order\\n    /// @return underlying Total claimed underlying amount\\n    function claimRedemptionsAndUnwrap(address account, uint256[] calldata indices)\\n        external\\n        override\\n        nonReentrant\\n        returns (uint256 underlying)\\n    {\\n        underlying = _claimRedemptions(account, indices);\\n        IWrappedERC20(address(_tokenUnderlying)).withdraw(underlying);\\n        (bool success, ) = account.call{value: underlying}(\\\"\\\");\\n        require(success, \\\"Transfer failed\\\");\\n    }\\n\\n    function _claimRedemptions(address account, uint256[] calldata indices)\\n        private\\n        returns (uint256 underlying)\\n    {\\n        uint256 count = indices.length;\\n        if (count == 0) {\\n            return 0;\\n        }\\n        uint256 head = redemptionQueueHead;\\n        if (indices[count - 1] >= head) {\\n            _popRedemptionQueue(indices[count - 1] - head + 1);\\n        }\\n        for (uint256 i = 0; i < count; i++) {\\n            require(i == 0 || indices[i] > indices[i - 1], \\\"Indices out of order\\\");\\n            QueuedRedemption storage redemption = queuedRedemptions[indices[i]];\\n            uint256 redemptionUnderlying = redemption.underlying;\\n            require(\\n                redemption.account == account && redemptionUnderlying != 0,\\n                \\\"Invalid redemption index\\\"\\n            );\\n            underlying = underlying.add(redemptionUnderlying);\\n            emit RedemptionClaimed(account, indices[i], redemptionUnderlying);\\n            delete queuedRedemptions[indices[i]];\\n        }\\n        claimableUnderlying = claimableUnderlying.sub(underlying);\\n    }\\n\\n    function split(\\n        address recipient,\\n        uint256 inQ,\\n        uint256 version\\n    ) external override returns (uint256 outB) {\\n        outB = getSplit(inQ);\\n        fund.primaryMarketBurn(TRANCHE_Q, msg.sender, inQ, version);\\n        fund.primaryMarketMint(TRANCHE_B, recipient, outB, version);\\n        fund.primaryMarketMint(TRANCHE_R, recipient, outB, version);\\n        emit Split(recipient, inQ, outB, outB);\\n    }\\n\\n    function merge(\\n        address recipient,\\n        uint256 inB,\\n        uint256 version\\n    ) external override returns (uint256 outQ) {\\n        uint256 feeQ;\\n        (outQ, feeQ) = getMerge(inB);\\n        uint256 feeUnderlying = _getRedemptionBeforeFee(feeQ);\\n        fund.primaryMarketBurn(TRANCHE_B, msg.sender, inB, version);\\n        fund.primaryMarketBurn(TRANCHE_R, msg.sender, inB, version);\\n        fund.primaryMarketMint(TRANCHE_Q, recipient, outQ, version);\\n        fund.primaryMarketAddDebt(0, feeUnderlying);\\n        emit Merged(recipient, outQ, inB, inB, feeUnderlying);\\n    }\\n\\n    /// @dev Nothing to do for daily fund settlement.\\n    function settle(uint256 day) external override onlyFund {}\\n\\n    function _updateFundCap(uint256 newCap) private {\\n        fundCap = newCap;\\n        emit FundCapUpdated(newCap);\\n    }\\n\\n    function updateFundCap(uint256 newCap) external onlyOwner {\\n        _updateFundCap(newCap);\\n    }\\n\\n    function _updateRedemptionFeeRate(uint256 newRedemptionFeeRate) private {\\n        require(newRedemptionFeeRate <= MAX_REDEMPTION_FEE_RATE, \\\"Exceed max redemption fee rate\\\");\\n        redemptionFeeRate = newRedemptionFeeRate;\\n        emit RedemptionFeeRateUpdated(newRedemptionFeeRate);\\n    }\\n\\n    function updateRedemptionFeeRate(uint256 newRedemptionFeeRate) external onlyOwner {\\n        _updateRedemptionFeeRate(newRedemptionFeeRate);\\n    }\\n\\n    function _updateMergeFeeRate(uint256 newMergeFeeRate) private {\\n        require(newMergeFeeRate <= MAX_MERGE_FEE_RATE, \\\"Exceed max merge fee rate\\\");\\n        mergeFeeRate = newMergeFeeRate;\\n        emit MergeFeeRateUpdated(newMergeFeeRate);\\n    }\\n\\n    function updateMergeFeeRate(uint256 newMergeFeeRate) external onlyOwner {\\n        _updateMergeFeeRate(newMergeFeeRate);\\n    }\\n\\n    /// @notice Receive unwrapped transfer from the wrapped token.\\n    receive() external payable {}\\n\\n    modifier onlyFund() {\\n        require(msg.sender == address(fund), \\\"Only fund\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/fund/PrimaryMarketRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../fund/ShareStaking.sol\\\";\\n\\nimport \\\"../interfaces/IPrimaryMarketRouter.sol\\\";\\nimport \\\"../interfaces/IPrimaryMarketV3.sol\\\";\\nimport \\\"../interfaces/ISwapRouter.sol\\\";\\nimport \\\"../interfaces/IStableSwap.sol\\\";\\nimport \\\"../interfaces/IWrappedERC20.sol\\\";\\n\\ncontract PrimaryMarketRouter is IPrimaryMarketRouter, ITrancheIndexV2 {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    IPrimaryMarketV3 public immutable primaryMarket;\\n    IFundV3 public immutable fund;\\n    IERC20 private immutable _tokenUnderlying;\\n    address private immutable _tokenB;\\n\\n    constructor(address pm) public {\\n        primaryMarket = IPrimaryMarketV3(pm);\\n        IFundV3 fund_ = IPrimaryMarketV3(pm).fund();\\n        fund = fund_;\\n        _tokenUnderlying = IERC20(fund_.tokenUnderlying());\\n        _tokenB = fund_.tokenB();\\n    }\\n\\n    /// @dev Get redemption with StableSwap getQuoteOut interface.\\n    function getQuoteOut(uint256 baseIn) external view override returns (uint256 quoteOut) {\\n        (quoteOut, ) = primaryMarket.getRedemption(baseIn);\\n    }\\n\\n    /// @dev Get creation for QUEEN with StableSwap getQuoteIn interface.\\n    function getQuoteIn(uint256 baseOut) external view override returns (uint256 quoteIn) {\\n        quoteIn = primaryMarket.getCreationForQ(baseOut);\\n    }\\n\\n    /// @dev Get creation with StableSwap getBaseOut interface.\\n    function getBaseOut(uint256 quoteIn) external view override returns (uint256 baseOut) {\\n        baseOut = primaryMarket.getCreation(quoteIn);\\n    }\\n\\n    /// @dev Get redemption for underlying with StableSwap getBaseIn interface.\\n    function getBaseIn(uint256 quoteOut) external view override returns (uint256 baseIn) {\\n        baseIn = primaryMarket.getRedemptionForUnderlying(quoteOut);\\n    }\\n\\n    /// @dev Create QUEEN with StableSwap buy interface.\\n    ///      Underlying should have already been sent to this contract\\n    function buy(\\n        uint256 version,\\n        uint256 baseOut,\\n        address recipient,\\n        bytes calldata\\n    ) external override returns (uint256 realBaseOut) {\\n        uint256 routerQuoteBalance = IERC20(_tokenUnderlying).balanceOf(address(this));\\n        IERC20(_tokenUnderlying).safeTransfer(address(primaryMarket), routerQuoteBalance);\\n        realBaseOut = primaryMarket.create(recipient, baseOut, version);\\n    }\\n\\n    /// @dev Redeem QUEEN with StableSwap sell interface.\\n    ///      QUEEN should have already been sent to this contract\\n    function sell(\\n        uint256 version,\\n        uint256 quoteOut,\\n        address recipient,\\n        bytes calldata\\n    ) external override returns (uint256 realQuoteOut) {\\n        uint256 routerBaseBalance = fund.trancheBalanceOf(TRANCHE_Q, address(this));\\n        realQuoteOut = primaryMarket.redeem(recipient, routerBaseBalance, quoteOut, version);\\n    }\\n\\n    function create(\\n        address recipient,\\n        uint256 underlying,\\n        uint256 minOutQ,\\n        uint256 version\\n    ) public payable override returns (uint256 outQ) {\\n        if (msg.value > 0) {\\n            require(msg.value == underlying); // sanity check\\n            IWrappedERC20(address(_tokenUnderlying)).deposit{value: msg.value}();\\n            _tokenUnderlying.safeTransfer(address(primaryMarket), msg.value);\\n        } else {\\n            IERC20(_tokenUnderlying).safeTransferFrom(\\n                msg.sender,\\n                address(primaryMarket),\\n                underlying\\n            );\\n        }\\n\\n        outQ = primaryMarket.create(recipient, minOutQ, version);\\n    }\\n\\n    function createAndStake(\\n        uint256 underlying,\\n        uint256 minOutQ,\\n        address staking,\\n        uint256 version\\n    ) external payable override {\\n        // Create QUEEN\\n        uint256 outQ = create(staking, underlying, minOutQ, version);\\n        // Stake QUEEN\\n        ShareStaking(staking).deposit(TRANCHE_Q, outQ, msg.sender, version);\\n    }\\n\\n    function createSplitAndStake(\\n        uint256 underlying,\\n        uint256 minOutQ,\\n        address router,\\n        address quoteAddress,\\n        uint256 minLpOut,\\n        address staking,\\n        uint256 version\\n    ) external payable override {\\n        // Create QUEEN\\n        uint256 outQ = create(address(this), underlying, minOutQ, version);\\n        _splitAndStake(outQ, router, quoteAddress, minLpOut, staking, version);\\n    }\\n\\n    function splitAndStake(\\n        uint256 inQ,\\n        address router,\\n        address quoteAddress,\\n        uint256 minLpOut,\\n        address staking,\\n        uint256 version\\n    ) external override {\\n        fund.trancheTransferFrom(TRANCHE_Q, msg.sender, address(this), inQ, version);\\n        _splitAndStake(inQ, router, quoteAddress, minLpOut, staking, version);\\n    }\\n\\n    function _splitAndStake(\\n        uint256 inQ,\\n        address router,\\n        address quoteAddress,\\n        uint256 minLpOut,\\n        address staking,\\n        uint256 version\\n    ) private {\\n        // Split QUEEN into BISHOP and ROOK\\n        uint256 outB = primaryMarket.split(address(this), inQ, version);\\n        // Add BISHOP to stable swap\\n        {\\n            IStableSwap swap = ISwapRouter(router).getSwap(_tokenB, quoteAddress);\\n            fund.trancheTransfer(TRANCHE_B, address(swap), outB, version);\\n            uint256 lpOut = swap.addLiquidity(version, msg.sender);\\n            require(lpOut >= minLpOut, \\\"Insufficient output\\\");\\n        }\\n\\n        if (staking == address(0)) {\\n            fund.trancheTransfer(TRANCHE_R, msg.sender, outB, version);\\n        } else {\\n            // Stake rook\\n            fund.trancheTransfer(TRANCHE_R, staking, outB, version);\\n            ShareStaking(staking).deposit(TRANCHE_R, outB, msg.sender, version);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/swap/StableSwap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\n\\nimport \\\"../interfaces/IStableSwap.sol\\\";\\nimport \\\"../interfaces/ILiquidityGauge.sol\\\";\\nimport \\\"../interfaces/ITranchessSwapCallee.sol\\\";\\nimport \\\"../interfaces/IWrappedERC20.sol\\\";\\n\\nimport \\\"../utils/SafeDecimalMath.sol\\\";\\nimport \\\"../utils/AdvancedMath.sol\\\";\\nimport \\\"../utils/ManagedPausable.sol\\\";\\n\\nabstract contract StableSwap is IStableSwap, Ownable, ReentrancyGuard, ManagedPausable {\\n    using SafeMath for uint256;\\n    using SafeDecimalMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    event LiquidityAdded(\\n        address indexed sender,\\n        address indexed recipient,\\n        uint256 baseIn,\\n        uint256 quoteIn,\\n        uint256 lpOut,\\n        uint256 fee,\\n        uint256 adminFee,\\n        uint256 oraclePrice\\n    );\\n    event LiquidityRemoved(\\n        address indexed account,\\n        uint256 lpIn,\\n        uint256 baseOut,\\n        uint256 quotOut,\\n        uint256 fee,\\n        uint256 adminFee,\\n        uint256 oraclePrice\\n    );\\n    event Swap(\\n        address indexed sender,\\n        address indexed recipient,\\n        uint256 baseIn,\\n        uint256 quoteIn,\\n        uint256 baseOut,\\n        uint256 quoteOut,\\n        uint256 fee,\\n        uint256 adminFee,\\n        uint256 oraclePrice\\n    );\\n    event Sync(uint256 base, uint256 quote, uint256 oraclePrice);\\n    event AmplRampUpdated(uint256 start, uint256 end, uint256 startTimestamp, uint256 endTimestamp);\\n    event FeeCollectorUpdated(address newFeeCollector);\\n    event FeeRateUpdated(uint256 newFeeRate);\\n    event AdminFeeRateUpdated(uint256 newAdminFeeRate);\\n\\n    uint256 private constant AMPL_MAX_VALUE = 1e6;\\n    uint256 private constant AMPL_RAMP_MIN_TIME = 86400;\\n    uint256 private constant AMPL_RAMP_MAX_CHANGE = 10;\\n    uint256 private constant MAX_FEE_RATE = 0.5e18;\\n    uint256 private constant MAX_ADMIN_FEE_RATE = 1e18;\\n    uint256 private constant MAX_ITERATION = 255;\\n    uint256 private constant MINIMUM_LIQUIDITY = 1e3;\\n\\n    address public immutable lpToken;\\n    IFundV3 public immutable override fund;\\n    uint256 public immutable override baseTranche;\\n    address public immutable override quoteAddress;\\n\\n    /// @dev A multipler that normalizes a quote asset balance to 18 decimal places.\\n    uint256 internal immutable _quoteDecimalMultiplier;\\n\\n    uint256 public baseBalance;\\n    uint256 public quoteBalance;\\n\\n    uint256 private _priceOverOracleIntegral;\\n    uint256 private _priceOverOracleTimestamp;\\n\\n    uint256 public amplRampStart;\\n    uint256 public amplRampEnd;\\n    uint256 public amplRampStartTimestamp;\\n    uint256 public amplRampEndTimestamp;\\n\\n    address public feeCollector;\\n    uint256 public feeRate;\\n    uint256 public adminFeeRate;\\n    uint256 public totalAdminFee;\\n\\n    constructor(\\n        address lpToken_,\\n        address fund_,\\n        uint256 baseTranche_,\\n        address quoteAddress_,\\n        uint256 quoteDecimals_,\\n        uint256 ampl_,\\n        address feeCollector_,\\n        uint256 feeRate_,\\n        uint256 adminFeeRate_\\n    ) public {\\n        lpToken = lpToken_;\\n        fund = IFundV3(fund_);\\n        baseTranche = baseTranche_;\\n        quoteAddress = quoteAddress_;\\n        require(quoteDecimals_ <= 18, \\\"Quote asset decimals larger than 18\\\");\\n        _quoteDecimalMultiplier = 10**(18 - quoteDecimals_);\\n\\n        require(ampl_ > 0 && ampl_ < AMPL_MAX_VALUE, \\\"Invalid A\\\");\\n        amplRampEnd = ampl_;\\n        emit AmplRampUpdated(ampl_, ampl_, 0, 0);\\n\\n        _updateFeeCollector(feeCollector_);\\n        _updateFeeRate(feeRate_);\\n        _updateAdminFeeRate(adminFeeRate_);\\n\\n        _initializeManagedPausable(msg.sender);\\n    }\\n\\n    receive() external payable {}\\n\\n    function baseAddress() external view override returns (address) {\\n        return fund.tokenShare(baseTranche);\\n    }\\n\\n    function allBalances() external view override returns (uint256, uint256) {\\n        (uint256 base, uint256 quote, , , , , ) = _getRebalanceResult(fund.getRebalanceSize());\\n        return (base, quote);\\n    }\\n\\n    function getAmpl() public view returns (uint256) {\\n        uint256 endTimestamp = amplRampEndTimestamp;\\n        if (block.timestamp < endTimestamp) {\\n            uint256 startTimestamp = amplRampStartTimestamp;\\n            uint256 start = amplRampStart;\\n            uint256 end = amplRampEnd;\\n            if (end > start) {\\n                return\\n                    start +\\n                    ((end - start) * (block.timestamp - startTimestamp)) /\\n                    (endTimestamp - startTimestamp);\\n            } else {\\n                return\\n                    start -\\n                    ((start - end) * (block.timestamp - startTimestamp)) /\\n                    (endTimestamp - startTimestamp);\\n            }\\n        } else {\\n            return amplRampEnd;\\n        }\\n    }\\n\\n    function getCurrentD() external view override returns (uint256) {\\n        (uint256 base, uint256 quote, , , , , ) = _getRebalanceResult(fund.getRebalanceSize());\\n        return _getD(base, quote, getAmpl(), getOraclePrice());\\n    }\\n\\n    function getCurrentPriceOverOracle() public view override returns (uint256) {\\n        (uint256 base, uint256 quote, , , , , ) = _getRebalanceResult(fund.getRebalanceSize());\\n        if (base == 0 || quote == 0) {\\n            return 1e18;\\n        }\\n        uint256 ampl = getAmpl();\\n        uint256 oraclePrice = getOraclePrice();\\n        uint256 d = _getD(base, quote, ampl, oraclePrice);\\n        return _getPriceOverOracle(base, quote, ampl, oraclePrice, d);\\n    }\\n\\n    /// @notice Get the current swap price, i.e. negative slope at the current point on the curve.\\n    ///         The returned value is computed after both base and quote balances are normalized to\\n    ///         18 decimal places. If the quote token does not have 18 decimal places, the returned\\n    ///         value has a different order of magnitude than the ratio of quote amount to base\\n    ///         amount in a swap.\\n    function getCurrentPrice() external view override returns (uint256) {\\n        (uint256 base, uint256 quote, , , , , ) = _getRebalanceResult(fund.getRebalanceSize());\\n        uint256 oraclePrice = getOraclePrice();\\n        if (base == 0 || quote == 0) {\\n            return oraclePrice;\\n        }\\n        uint256 ampl = getAmpl();\\n        uint256 d = _getD(base, quote, ampl, oraclePrice);\\n        return _getPriceOverOracle(base, quote, ampl, oraclePrice, d).multiplyDecimal(oraclePrice);\\n    }\\n\\n    function getPriceOverOracleIntegral() external view override returns (uint256) {\\n        return\\n            _priceOverOracleIntegral +\\n            getCurrentPriceOverOracle() *\\n            (block.timestamp - _priceOverOracleTimestamp);\\n    }\\n\\n    function getQuoteOut(uint256 baseIn) external view override returns (uint256 quoteOut) {\\n        (uint256 oldBase, uint256 oldQuote, , , , , ) =\\n            _getRebalanceResult(fund.getRebalanceSize());\\n        uint256 newBase = oldBase.add(baseIn);\\n        uint256 ampl = getAmpl();\\n        uint256 oraclePrice = getOraclePrice();\\n        // Add 1 in case of rounding errors\\n        uint256 d = _getD(oldBase, oldQuote, ampl, oraclePrice) + 1;\\n        uint256 newQuote = _getQuote(ampl, newBase, oraclePrice, d) + 1;\\n        quoteOut = oldQuote.sub(newQuote);\\n        // Round down output after fee\\n        quoteOut = quoteOut.multiplyDecimal(1e18 - feeRate);\\n    }\\n\\n    function getQuoteIn(uint256 baseOut) external view override returns (uint256 quoteIn) {\\n        (uint256 oldBase, uint256 oldQuote, , , , , ) =\\n            _getRebalanceResult(fund.getRebalanceSize());\\n        uint256 newBase = oldBase.sub(baseOut);\\n        uint256 ampl = getAmpl();\\n        uint256 oraclePrice = getOraclePrice();\\n        // Add 1 in case of rounding errors\\n        uint256 d = _getD(oldBase, oldQuote, ampl, oraclePrice) + 1;\\n        uint256 newQuote = _getQuote(ampl, newBase, oraclePrice, d) + 1;\\n        quoteIn = newQuote.sub(oldQuote);\\n        uint256 feeRate_ = feeRate;\\n        // Round up input before fee\\n        quoteIn = quoteIn.mul(1e18).add(1e18 - feeRate_ - 1) / (1e18 - feeRate_);\\n    }\\n\\n    function getBaseOut(uint256 quoteIn) external view override returns (uint256 baseOut) {\\n        (uint256 oldBase, uint256 oldQuote, , , , , ) =\\n            _getRebalanceResult(fund.getRebalanceSize());\\n        // Round down input after fee\\n        uint256 quoteInAfterFee = quoteIn.multiplyDecimal(1e18 - feeRate);\\n        uint256 newQuote = oldQuote.add(quoteInAfterFee);\\n        uint256 ampl = getAmpl();\\n        uint256 oraclePrice = getOraclePrice();\\n        // Add 1 in case of rounding errors\\n        uint256 d = _getD(oldBase, oldQuote, ampl, oraclePrice) + 1;\\n        uint256 newBase = _getBase(ampl, newQuote, oraclePrice, d) + 1;\\n        baseOut = oldBase.sub(newBase);\\n    }\\n\\n    function getBaseIn(uint256 quoteOut) external view override returns (uint256 baseIn) {\\n        (uint256 oldBase, uint256 oldQuote, , , , , ) =\\n            _getRebalanceResult(fund.getRebalanceSize());\\n        uint256 feeRate_ = feeRate;\\n        // Round up output before fee\\n        uint256 quoteOutBeforeFee = quoteOut.mul(1e18).add(1e18 - feeRate_ - 1) / (1e18 - feeRate_);\\n        uint256 newQuote = oldQuote.sub(quoteOutBeforeFee);\\n        uint256 ampl = getAmpl();\\n        uint256 oraclePrice = getOraclePrice();\\n        // Add 1 in case of rounding errors\\n        uint256 d = _getD(oldBase, oldQuote, ampl, oraclePrice) + 1;\\n        uint256 newBase = _getBase(ampl, newQuote, oraclePrice, d) + 1;\\n        baseIn = newBase.sub(oldBase);\\n    }\\n\\n    function buy(\\n        uint256 version,\\n        uint256 baseOut,\\n        address recipient,\\n        bytes calldata data\\n    )\\n        external\\n        override\\n        nonReentrant\\n        checkVersion(version)\\n        whenNotPaused\\n        returns (uint256 realBaseOut)\\n    {\\n        require(baseOut > 0, \\\"Zero output\\\");\\n        realBaseOut = baseOut;\\n        (uint256 oldBase, uint256 oldQuote) = _handleRebalance(version);\\n        require(baseOut < oldBase, \\\"Insufficient liquidity\\\");\\n        // Optimistically transfer tokens.\\n        fund.trancheTransfer(baseTranche, recipient, baseOut, version);\\n        if (data.length > 0) {\\n            ITranchessSwapCallee(msg.sender).tranchessSwapCallback(baseOut, 0, data);\\n        }\\n        uint256 newQuote = _getNewQuoteBalance();\\n        uint256 quoteIn = newQuote.sub(oldQuote);\\n        uint256 fee = quoteIn.multiplyDecimal(feeRate);\\n        uint256 oraclePrice = getOraclePrice();\\n        {\\n            uint256 ampl = getAmpl();\\n            uint256 oldD = _getD(oldBase, oldQuote, ampl, oraclePrice);\\n            _updatePriceOverOracleIntegral(oldBase, oldQuote, ampl, oraclePrice, oldD);\\n            uint256 newD = _getD(oldBase - baseOut, newQuote.sub(fee), ampl, oraclePrice);\\n            require(newD >= oldD, \\\"Invariant mismatch\\\");\\n        }\\n        uint256 adminFee = fee.multiplyDecimal(adminFeeRate);\\n        baseBalance = oldBase - baseOut;\\n        quoteBalance = newQuote.sub(adminFee);\\n        totalAdminFee = totalAdminFee.add(adminFee);\\n        uint256 baseOut_ = baseOut;\\n        emit Swap(msg.sender, recipient, 0, quoteIn, baseOut_, 0, fee, adminFee, oraclePrice);\\n    }\\n\\n    function sell(\\n        uint256 version,\\n        uint256 quoteOut,\\n        address recipient,\\n        bytes calldata data\\n    )\\n        external\\n        override\\n        nonReentrant\\n        checkVersion(version)\\n        whenNotPaused\\n        returns (uint256 realQuoteOut)\\n    {\\n        require(quoteOut > 0, \\\"Zero output\\\");\\n        realQuoteOut = quoteOut;\\n        (uint256 oldBase, uint256 oldQuote) = _handleRebalance(version);\\n        // Optimistically transfer tokens.\\n        IERC20(quoteAddress).safeTransfer(recipient, quoteOut);\\n        if (data.length > 0) {\\n            ITranchessSwapCallee(msg.sender).tranchessSwapCallback(0, quoteOut, data);\\n        }\\n        uint256 newBase = fund.trancheBalanceOf(baseTranche, address(this));\\n        uint256 baseIn = newBase.sub(oldBase);\\n        uint256 fee;\\n        {\\n            uint256 feeRate_ = feeRate;\\n            fee = quoteOut.mul(feeRate_).div(1e18 - feeRate_);\\n        }\\n        require(quoteOut.add(fee) < oldQuote, \\\"Insufficient liquidity\\\");\\n        uint256 oraclePrice = getOraclePrice();\\n        {\\n            uint256 newQuote = oldQuote - quoteOut;\\n            uint256 ampl = getAmpl();\\n            uint256 oldD = _getD(oldBase, oldQuote, ampl, oraclePrice);\\n            _updatePriceOverOracleIntegral(oldBase, oldQuote, ampl, oraclePrice, oldD);\\n            uint256 newD = _getD(newBase, newQuote - fee, ampl, oraclePrice);\\n            require(newD >= oldD, \\\"Invariant mismatch\\\");\\n        }\\n        uint256 adminFee = fee.multiplyDecimal(adminFeeRate);\\n        baseBalance = newBase;\\n        quoteBalance = oldQuote - quoteOut - adminFee;\\n        totalAdminFee = totalAdminFee.add(adminFee);\\n        uint256 quoteOut_ = quoteOut;\\n        emit Swap(msg.sender, recipient, baseIn, 0, 0, quoteOut_, fee, adminFee, oraclePrice);\\n    }\\n\\n    /// @notice Add liquidity. This function should be called by a smart contract, which transfers\\n    ///         base and quote tokens to this contract in the same transaction.\\n    /// @param version The latest rebalance version\\n    /// @param recipient Recipient of minted LP tokens\\n    /// @param lpOut Amount of minted LP tokens\\n    function addLiquidity(uint256 version, address recipient)\\n        external\\n        override\\n        nonReentrant\\n        checkVersion(version)\\n        whenNotPaused\\n        returns (uint256 lpOut)\\n    {\\n        (uint256 oldBase, uint256 oldQuote) = _handleRebalance(version);\\n        uint256 newBase = fund.trancheBalanceOf(baseTranche, address(this));\\n        uint256 newQuote = _getNewQuoteBalance();\\n        uint256 ampl = getAmpl();\\n        uint256 oraclePrice = getOraclePrice();\\n        uint256 lpSupply = IERC20(lpToken).totalSupply();\\n        if (lpSupply == 0) {\\n            require(newBase > 0 && newQuote > 0, \\\"Zero initial balance\\\");\\n            baseBalance = newBase;\\n            quoteBalance = newQuote;\\n            // Overflow is desired\\n            _priceOverOracleIntegral += 1e18 * (block.timestamp - _priceOverOracleTimestamp);\\n            _priceOverOracleTimestamp = block.timestamp;\\n            uint256 d1 = _getD(newBase, newQuote, ampl, oraclePrice);\\n            ILiquidityGauge(lpToken).mint(address(this), MINIMUM_LIQUIDITY);\\n            ILiquidityGauge(lpToken).mint(recipient, d1.sub(MINIMUM_LIQUIDITY));\\n            emit LiquidityAdded(msg.sender, recipient, newBase, newQuote, d1, 0, 0, oraclePrice);\\n            return d1;\\n        }\\n        uint256 fee;\\n        uint256 adminFee;\\n        {\\n            // Initial invariant\\n            uint256 d0 = _getD(oldBase, oldQuote, ampl, oraclePrice);\\n            _updatePriceOverOracleIntegral(oldBase, oldQuote, ampl, oraclePrice, d0);\\n            {\\n                // New invariant before charging fee\\n                uint256 d1 = _getD(newBase, newQuote, ampl, oraclePrice);\\n                uint256 idealQuote = d1.mul(oldQuote) / d0;\\n                uint256 difference =\\n                    idealQuote > newQuote ? idealQuote - newQuote : newQuote - idealQuote;\\n                fee = difference.multiplyDecimal(feeRate);\\n            }\\n            adminFee = fee.multiplyDecimal(adminFeeRate);\\n            totalAdminFee = totalAdminFee.add(adminFee);\\n            baseBalance = newBase;\\n            quoteBalance = newQuote.sub(adminFee);\\n            // New invariant after charging fee\\n            uint256 d2 = _getD(newBase, newQuote.sub(fee), ampl, oraclePrice);\\n            require(d2 > d0, \\\"No liquidity is added\\\");\\n            lpOut = lpSupply.mul(d2.sub(d0)).div(d0);\\n        }\\n        ILiquidityGauge(lpToken).mint(recipient, lpOut);\\n        emit LiquidityAdded(\\n            msg.sender,\\n            recipient,\\n            newBase - oldBase,\\n            newQuote - oldQuote,\\n            lpOut,\\n            fee,\\n            adminFee,\\n            oraclePrice\\n        );\\n    }\\n\\n    /// @dev Remove liquidity proportionally.\\n    /// @param lpIn Exact amount of LP token to burn\\n    /// @param minBaseOut Least amount of base asset to withdraw\\n    /// @param minQuoteOut Least amount of quote asset to withdraw\\n    function removeLiquidity(\\n        uint256 version,\\n        uint256 lpIn,\\n        uint256 minBaseOut,\\n        uint256 minQuoteOut\\n    )\\n        external\\n        override\\n        nonReentrant\\n        checkVersion(version)\\n        returns (uint256 baseOut, uint256 quoteOut)\\n    {\\n        (baseOut, quoteOut) = _removeLiquidity(version, lpIn, minBaseOut, minQuoteOut);\\n        IERC20(quoteAddress).safeTransfer(msg.sender, quoteOut);\\n    }\\n\\n    /// @dev Remove liquidity proportionally and unwrap for native token.\\n    /// @param lpIn Exact amount of LP token to burn\\n    /// @param minBaseOut Least amount of base asset to withdraw\\n    /// @param minQuoteOut Least amount of quote asset to withdraw\\n    function removeLiquidityUnwrap(\\n        uint256 version,\\n        uint256 lpIn,\\n        uint256 minBaseOut,\\n        uint256 minQuoteOut\\n    )\\n        external\\n        override\\n        nonReentrant\\n        checkVersion(version)\\n        returns (uint256 baseOut, uint256 quoteOut)\\n    {\\n        (baseOut, quoteOut) = _removeLiquidity(version, lpIn, minBaseOut, minQuoteOut);\\n        IWrappedERC20(quoteAddress).withdraw(quoteOut);\\n        (bool success, ) = msg.sender.call{value: quoteOut}(\\\"\\\");\\n        require(success, \\\"Transfer failed\\\");\\n    }\\n\\n    function _removeLiquidity(\\n        uint256 version,\\n        uint256 lpIn,\\n        uint256 minBaseOut,\\n        uint256 minQuoteOut\\n    ) private returns (uint256 baseOut, uint256 quoteOut) {\\n        uint256 lpSupply = IERC20(lpToken).totalSupply();\\n        (uint256 oldBase, uint256 oldQuote) = _handleRebalance(version);\\n        baseOut = oldBase.mul(lpIn).div(lpSupply);\\n        quoteOut = oldQuote.mul(lpIn).div(lpSupply);\\n        require(baseOut >= minBaseOut, \\\"Insufficient output\\\");\\n        require(quoteOut >= minQuoteOut, \\\"Insufficient output\\\");\\n        baseBalance = oldBase.sub(baseOut);\\n        quoteBalance = oldQuote.sub(quoteOut);\\n        ILiquidityGauge(lpToken).burnFrom(msg.sender, lpIn);\\n        fund.trancheTransfer(baseTranche, msg.sender, baseOut, version);\\n        emit LiquidityRemoved(msg.sender, lpIn, baseOut, quoteOut, 0, 0, 0);\\n    }\\n\\n    /// @dev Remove base liquidity only.\\n    /// @param lpIn Exact amount of LP token to burn\\n    /// @param minBaseOut Least amount of base asset to withdraw\\n    function removeBaseLiquidity(\\n        uint256 version,\\n        uint256 lpIn,\\n        uint256 minBaseOut\\n    ) external override nonReentrant checkVersion(version) whenNotPaused returns (uint256 baseOut) {\\n        (uint256 oldBase, uint256 oldQuote) = _handleRebalance(version);\\n        uint256 lpSupply = IERC20(lpToken).totalSupply();\\n        uint256 ampl = getAmpl();\\n        uint256 oraclePrice = getOraclePrice();\\n        uint256 d1;\\n        {\\n            uint256 d0 = _getD(oldBase, oldQuote, ampl, oraclePrice);\\n            _updatePriceOverOracleIntegral(oldBase, oldQuote, ampl, oraclePrice, d0);\\n            d1 = d0.sub(d0.mul(lpIn).div(lpSupply));\\n        }\\n        {\\n            uint256 fee = oldQuote.mul(lpIn).div(lpSupply).multiplyDecimal(feeRate);\\n            // Add 1 in case of rounding errors\\n            uint256 newBase = _getBase(ampl, oldQuote.sub(fee), oraclePrice, d1) + 1;\\n            baseOut = oldBase.sub(newBase);\\n            require(baseOut >= minBaseOut, \\\"Insufficient output\\\");\\n            ILiquidityGauge(lpToken).burnFrom(msg.sender, lpIn);\\n            baseBalance = newBase;\\n            uint256 adminFee = fee.multiplyDecimal(adminFeeRate);\\n            totalAdminFee = totalAdminFee.add(adminFee);\\n            quoteBalance = oldQuote.sub(adminFee);\\n            emit LiquidityRemoved(msg.sender, lpIn, baseOut, 0, fee, adminFee, oraclePrice);\\n        }\\n        fund.trancheTransfer(baseTranche, msg.sender, baseOut, version);\\n    }\\n\\n    /// @dev Remove quote liquidity only.\\n    /// @param lpIn Exact amount of LP token to burn\\n    /// @param minQuoteOut Least amount of quote asset to withdraw\\n    function removeQuoteLiquidity(\\n        uint256 version,\\n        uint256 lpIn,\\n        uint256 minQuoteOut\\n    )\\n        external\\n        override\\n        nonReentrant\\n        checkVersion(version)\\n        whenNotPaused\\n        returns (uint256 quoteOut)\\n    {\\n        quoteOut = _removeQuoteLiquidity(version, lpIn, minQuoteOut);\\n        IERC20(quoteAddress).safeTransfer(msg.sender, quoteOut);\\n    }\\n\\n    /// @dev Remove quote liquidity only and unwrap for native token.\\n    /// @param lpIn Exact amount of LP token to burn\\n    /// @param minQuoteOut Least amount of quote asset to withdraw\\n    function removeQuoteLiquidityUnwrap(\\n        uint256 version,\\n        uint256 lpIn,\\n        uint256 minQuoteOut\\n    )\\n        external\\n        override\\n        nonReentrant\\n        checkVersion(version)\\n        whenNotPaused\\n        returns (uint256 quoteOut)\\n    {\\n        quoteOut = _removeQuoteLiquidity(version, lpIn, minQuoteOut);\\n        IWrappedERC20(quoteAddress).withdraw(quoteOut);\\n        (bool success, ) = msg.sender.call{value: quoteOut}(\\\"\\\");\\n        require(success, \\\"Transfer failed\\\");\\n    }\\n\\n    function _removeQuoteLiquidity(\\n        uint256 version,\\n        uint256 lpIn,\\n        uint256 minQuoteOut\\n    ) private returns (uint256 quoteOut) {\\n        (uint256 oldBase, uint256 oldQuote) = _handleRebalance(version);\\n        uint256 lpSupply = IERC20(lpToken).totalSupply();\\n        uint256 ampl = getAmpl();\\n        uint256 oraclePrice = getOraclePrice();\\n        uint256 d1;\\n        {\\n            uint256 d0 = _getD(oldBase, oldQuote, ampl, oraclePrice);\\n            _updatePriceOverOracleIntegral(oldBase, oldQuote, ampl, oraclePrice, d0);\\n            d1 = d0.sub(d0.mul(lpIn).div(lpSupply));\\n        }\\n        uint256 idealQuote = oldQuote.mul(lpSupply.sub(lpIn)).div(lpSupply);\\n        // Add 1 in case of rounding errors\\n        uint256 newQuote = _getQuote(ampl, oldBase, oraclePrice, d1) + 1;\\n        uint256 fee = idealQuote.sub(newQuote).multiplyDecimal(feeRate);\\n        quoteOut = oldQuote.sub(newQuote).sub(fee);\\n        require(quoteOut >= minQuoteOut, \\\"Insufficient output\\\");\\n        ILiquidityGauge(lpToken).burnFrom(msg.sender, lpIn);\\n        uint256 adminFee = fee.multiplyDecimal(adminFeeRate);\\n        totalAdminFee = totalAdminFee.add(adminFee);\\n        quoteBalance = newQuote.add(fee).sub(adminFee);\\n        emit LiquidityRemoved(msg.sender, lpIn, 0, quoteOut, fee, adminFee, oraclePrice);\\n    }\\n\\n    /// @notice Force stored values to match balances.\\n    function sync() external nonReentrant {\\n        (uint256 oldBase, uint256 oldQuote) = _handleRebalance(fund.getRebalanceSize());\\n        uint256 ampl = getAmpl();\\n        uint256 oraclePrice = getOraclePrice();\\n        uint256 d = _getD(oldBase, oldQuote, ampl, oraclePrice);\\n        _updatePriceOverOracleIntegral(oldBase, oldQuote, ampl, oraclePrice, d);\\n        uint256 newBase = fund.trancheBalanceOf(baseTranche, address(this));\\n        uint256 newQuote = _getNewQuoteBalance();\\n        baseBalance = newBase;\\n        quoteBalance = newQuote;\\n        emit Sync(newBase, newQuote, oraclePrice);\\n    }\\n\\n    function collectFee() external {\\n        IERC20(quoteAddress).safeTransfer(feeCollector, totalAdminFee);\\n        delete totalAdminFee;\\n    }\\n\\n    function _getNewQuoteBalance() private view returns (uint256) {\\n        return IERC20(quoteAddress).balanceOf(address(this)).sub(totalAdminFee);\\n    }\\n\\n    function _updatePriceOverOracleIntegral(\\n        uint256 base,\\n        uint256 quote,\\n        uint256 ampl,\\n        uint256 oraclePrice,\\n        uint256 d\\n    ) private {\\n        // Overflow is desired\\n        _priceOverOracleIntegral +=\\n            _getPriceOverOracle(base, quote, ampl, oraclePrice, d) *\\n            (block.timestamp - _priceOverOracleTimestamp);\\n        _priceOverOracleTimestamp = block.timestamp;\\n    }\\n\\n    function _getD(\\n        uint256 base,\\n        uint256 quote,\\n        uint256 ampl,\\n        uint256 oraclePrice\\n    ) private view returns (uint256) {\\n        // Newtonian: D' = (4A(kx + y) + D^3 / 2kxy)D / ((4A - 1)D + 3D^3 / 4kxy)\\n        uint256 normalizedQuote = quote.mul(_quoteDecimalMultiplier);\\n        uint256 baseValue = base.multiplyDecimal(oraclePrice);\\n        uint256 sum = baseValue.add(normalizedQuote);\\n        if (sum == 0) return 0;\\n\\n        uint256 prev = 0;\\n        uint256 d = sum;\\n        for (uint256 i = 0; i < MAX_ITERATION; i++) {\\n            prev = d;\\n            uint256 d3 = d.mul(d).div(baseValue).mul(d) / normalizedQuote / 4;\\n            d = (sum.mul(4 * ampl) + 2 * d3).mul(d) / d.mul(4 * ampl - 1).add(3 * d3);\\n            if (d <= prev + 1 && prev <= d + 1) {\\n                break;\\n            }\\n        }\\n        return d;\\n    }\\n\\n    function _getPriceOverOracle(\\n        uint256 base,\\n        uint256 quote,\\n        uint256 ampl,\\n        uint256 oraclePrice,\\n        uint256 d\\n    ) private view returns (uint256) {\\n        uint256 commonExp = d.multiplyDecimal(4e18 - 1e18 / ampl);\\n        uint256 baseValue = base.multiplyDecimal(oraclePrice);\\n        uint256 normalizedQuote = quote.mul(_quoteDecimalMultiplier);\\n        return\\n            (baseValue.mul(8).add(normalizedQuote.mul(4)).sub(commonExp))\\n                .multiplyDecimal(normalizedQuote)\\n                .divideDecimal(normalizedQuote.mul(8).add(baseValue.mul(4)).sub(commonExp))\\n                .divideDecimal(baseValue);\\n    }\\n\\n    function _getBase(\\n        uint256 ampl,\\n        uint256 quote,\\n        uint256 oraclePrice,\\n        uint256 d\\n    ) private view returns (uint256 base) {\\n        // Solve 16Ayk^2\u00b7x^2 + 4ky(4Ay - 4AD + D)\u00b7x - D^3 = 0\\n        // Newtonian: kx' = ((kx)^2 + D^3 / 16Ay) / (2kx + y - D + D/4A)\\n        uint256 normalizedQuote = quote.mul(_quoteDecimalMultiplier);\\n        uint256 d3 = d.mul(d).div(normalizedQuote).mul(d) / (16 * ampl);\\n        uint256 prev = 0;\\n        uint256 baseValue = d;\\n        for (uint256 i = 0; i < MAX_ITERATION; i++) {\\n            prev = baseValue;\\n            baseValue =\\n                baseValue.mul(baseValue).add(d3) /\\n                (2 * baseValue).add(normalizedQuote).add(d / (4 * ampl)).sub(d);\\n            if (baseValue <= prev + 1 && prev <= baseValue + 1) {\\n                break;\\n            }\\n        }\\n        base = baseValue.divideDecimal(oraclePrice);\\n    }\\n\\n    function _getQuote(\\n        uint256 ampl,\\n        uint256 base,\\n        uint256 oraclePrice,\\n        uint256 d\\n    ) private view returns (uint256 quote) {\\n        // Solve 16Axk\u00b7y^2 + 4kx(4Akx - 4AD + D)\u00b7y - D^3 = 0\\n        // Newtonian: y' = (y^2 + D^3 / 16Akx) / (2y + kx - D + D/4A)\\n        uint256 baseValue = base.multiplyDecimal(oraclePrice);\\n        uint256 d3 = d.mul(d).div(baseValue).mul(d) / (16 * ampl);\\n        uint256 prev = 0;\\n        uint256 normalizedQuote = d;\\n        for (uint256 i = 0; i < MAX_ITERATION; i++) {\\n            prev = normalizedQuote;\\n            normalizedQuote =\\n                normalizedQuote.mul(normalizedQuote).add(d3) /\\n                (2 * normalizedQuote).add(baseValue).add(d / (4 * ampl)).sub(d);\\n            if (normalizedQuote <= prev + 1 && prev <= normalizedQuote + 1) {\\n                break;\\n            }\\n        }\\n        quote = normalizedQuote / _quoteDecimalMultiplier;\\n    }\\n\\n    function updateAmplRamp(uint256 endAmpl, uint256 endTimestamp) external onlyOwner {\\n        require(endAmpl > 0 && endAmpl < AMPL_MAX_VALUE, \\\"Invalid A\\\");\\n        require(endTimestamp >= block.timestamp + AMPL_RAMP_MIN_TIME, \\\"A ramp time too short\\\");\\n        uint256 ampl = getAmpl();\\n        require(\\n            (endAmpl >= ampl && endAmpl <= ampl * AMPL_RAMP_MAX_CHANGE) ||\\n                (endAmpl < ampl && endAmpl * AMPL_RAMP_MAX_CHANGE >= ampl),\\n            \\\"A ramp change too large\\\"\\n        );\\n        amplRampStart = ampl;\\n        amplRampEnd = endAmpl;\\n        amplRampStartTimestamp = block.timestamp;\\n        amplRampEndTimestamp = endTimestamp;\\n        emit AmplRampUpdated(ampl, endAmpl, block.timestamp, endTimestamp);\\n    }\\n\\n    function _updateFeeCollector(address newFeeCollector) private {\\n        feeCollector = newFeeCollector;\\n        emit FeeCollectorUpdated(newFeeCollector);\\n    }\\n\\n    function updateFeeCollector(address newFeeCollector) external onlyOwner {\\n        _updateFeeCollector(newFeeCollector);\\n    }\\n\\n    function _updateFeeRate(uint256 newFeeRate) private {\\n        require(newFeeRate <= MAX_FEE_RATE, \\\"Exceed max fee rate\\\");\\n        feeRate = newFeeRate;\\n        emit FeeRateUpdated(newFeeRate);\\n    }\\n\\n    function updateFeeRate(uint256 newFeeRate) external onlyOwner {\\n        _updateFeeRate(newFeeRate);\\n    }\\n\\n    function _updateAdminFeeRate(uint256 newAdminFeeRate) private {\\n        require(newAdminFeeRate <= MAX_ADMIN_FEE_RATE, \\\"Exceed max admin fee rate\\\");\\n        adminFeeRate = newAdminFeeRate;\\n        emit AdminFeeRateUpdated(newAdminFeeRate);\\n    }\\n\\n    function updateAdminFeeRate(uint256 newAdminFeeRate) external onlyOwner {\\n        _updateAdminFeeRate(newAdminFeeRate);\\n    }\\n\\n    /// @dev Check if the user-specified version is correct.\\n    modifier checkVersion(uint256 version) virtual {_;}\\n\\n    /// @dev Compute the new base and quote amount after rebalanced to the latest version.\\n    ///      If any tokens should be distributed to LP holders, their amounts are also returned.\\n    ///\\n    ///      The latest rebalance version is passed in a parameter and it is caller's responsibility\\n    ///      to pass the correct version.\\n    /// @param latestVersion The latest rebalance version\\n    /// @return newBase Amount of base tokens after rebalance\\n    /// @return newQuote Amount of quote tokens after rebalance\\n    /// @return excessiveQ Amount of QUEEN that should be distributed to LP holders due to rebalance\\n    /// @return excessiveB Amount of BISHOP that should be distributed to LP holders due to rebalance\\n    /// @return excessiveR Amount of ROOK that should be distributed to LP holders due to rebalance\\n    /// @return excessiveQuote Amount of quote tokens that should be distributed to LP holders due to rebalance\\n    /// @return isRebalanced Whether the stored base and quote amount are rebalanced\\n    function _getRebalanceResult(uint256 latestVersion)\\n        internal\\n        view\\n        virtual\\n        returns (\\n            uint256 newBase,\\n            uint256 newQuote,\\n            uint256 excessiveQ,\\n            uint256 excessiveB,\\n            uint256 excessiveR,\\n            uint256 excessiveQuote,\\n            bool isRebalanced\\n        );\\n\\n    /// @dev Update the stored base and quote balance to the latest rebalance version and distribute\\n    ///      any excessive tokens to LP holders.\\n    ///\\n    ///      The latest rebalance version is passed in a parameter and it is caller's responsibility\\n    ///      to pass the correct version.\\n    /// @param latestVersion The latest rebalance version\\n    /// @return newBase Amount of stored base tokens after rebalance\\n    /// @return newQuote Amount of stored quote tokens after rebalance\\n    function _handleRebalance(uint256 latestVersion)\\n        internal\\n        virtual\\n        returns (uint256 newBase, uint256 newQuote);\\n\\n    /// @notice Get the base token price from the price oracle. The returned price is normalized\\n    ///         to 18 decimal places.\\n    function getOraclePrice() public view virtual override returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/swap/LiquidityGauge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"../interfaces/ILiquidityGauge.sol\\\";\\nimport \\\"../interfaces/IChessSchedule.sol\\\";\\nimport \\\"../interfaces/IChessController.sol\\\";\\nimport \\\"../interfaces/IFundV3.sol\\\";\\nimport \\\"../interfaces/ITrancheIndexV2.sol\\\";\\nimport \\\"../interfaces/IStableSwap.sol\\\";\\nimport \\\"../interfaces/IVotingEscrow.sol\\\";\\n\\nimport \\\"../utils/CoreUtility.sol\\\";\\nimport \\\"../utils/SafeDecimalMath.sol\\\";\\n\\ninterface ISwapBonus {\\n    function bonusToken() external view returns (address);\\n\\n    function getBonus() external returns (uint256);\\n}\\n\\ncontract LiquidityGauge is ILiquidityGauge, ITrancheIndexV2, CoreUtility, ERC20 {\\n    using Math for uint256;\\n    using SafeMath for uint256;\\n    using SafeDecimalMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    struct Distribution {\\n        uint256 amountQ;\\n        uint256 amountB;\\n        uint256 amountR;\\n        uint256 quoteAmount;\\n    }\\n\\n    uint256 private constant MAX_ITERATIONS = 500;\\n    uint256 private constant MAX_BOOSTING_FACTOR = 3e18;\\n    uint256 private constant MAX_BOOSTING_FACTOR_MINUS_ONE = MAX_BOOSTING_FACTOR - 1e18;\\n\\n    address public immutable stableSwap;\\n    IERC20 private immutable _quoteToken;\\n    IChessSchedule public immutable chessSchedule;\\n    IChessController public immutable chessController;\\n    IFundV3 public immutable fund;\\n    IVotingEscrow private immutable _votingEscrow;\\n    address public immutable swapBonus;\\n    IERC20 private immutable _bonusToken;\\n    /// @notice Timestamp when rewards start.\\n    uint256 public immutable rewardStartTimestamp;\\n\\n    uint256 private _workingSupply;\\n    mapping(address => uint256) private _workingBalances;\\n\\n    uint256 public latestVersion;\\n    mapping(uint256 => Distribution) public distributions;\\n    mapping(uint256 => uint256) public distributionTotalSupplies;\\n    mapping(address => Distribution) public userDistributions;\\n    mapping(address => uint256) public userVersions;\\n\\n    uint256 private _chessIntegral;\\n    uint256 private _chessIntegralTimestamp;\\n    mapping(address => uint256) private _chessUserIntegrals;\\n    mapping(address => uint256) private _claimableChess;\\n\\n    uint256 private _bonusIntegral;\\n    mapping(address => uint256) private _bonusUserIntegral;\\n    mapping(address => uint256) private _claimableBonus;\\n\\n    /// @dev Per-gauge CHESS emission rate. The product of CHESS emission rate\\n    ///      and weekly percentage of the gauge\\n    uint256 private _rate;\\n\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        address stableSwap_,\\n        address chessSchedule_,\\n        address chessController_,\\n        address fund_,\\n        address votingEscrow_,\\n        address swapBonus_,\\n        uint256 rewardStartTimestamp_\\n    ) public ERC20(name_, symbol_) {\\n        stableSwap = stableSwap_;\\n        _quoteToken = IERC20(IStableSwap(stableSwap_).quoteAddress());\\n        chessSchedule = IChessSchedule(chessSchedule_);\\n        chessController = IChessController(chessController_);\\n        fund = IFundV3(fund_);\\n        _votingEscrow = IVotingEscrow(votingEscrow_);\\n        swapBonus = swapBonus_;\\n        _bonusToken = IERC20(ISwapBonus(swapBonus_).bonusToken());\\n        rewardStartTimestamp = rewardStartTimestamp_;\\n        _chessIntegralTimestamp = block.timestamp;\\n    }\\n\\n    modifier onlyStableSwap() {\\n        require(msg.sender == stableSwap, \\\"Only stable swap\\\");\\n        _;\\n    }\\n\\n    function getRate() external view returns (uint256) {\\n        return _rate / 1e18;\\n    }\\n\\n    function mint(address account, uint256 amount) external override onlyStableSwap {\\n        uint256 oldWorkingBalance = _workingBalances[account];\\n        uint256 oldWorkingSupply = _workingSupply;\\n        uint256 oldBalance = balanceOf(account);\\n        _checkpoint(account, oldBalance, oldWorkingBalance, oldWorkingSupply);\\n\\n        _mint(account, amount);\\n        _updateWorkingBalance(\\n            account,\\n            oldWorkingBalance,\\n            oldWorkingSupply,\\n            oldBalance.add(amount),\\n            totalSupply()\\n        );\\n    }\\n\\n    function burnFrom(address account, uint256 amount) external override onlyStableSwap {\\n        uint256 oldWorkingBalance = _workingBalances[account];\\n        uint256 oldWorkingSupply = _workingSupply;\\n        uint256 oldBalance = balanceOf(account);\\n        _checkpoint(account, oldBalance, oldWorkingBalance, oldWorkingSupply);\\n\\n        _burn(account, amount);\\n        _updateWorkingBalance(\\n            account,\\n            oldWorkingBalance,\\n            oldWorkingSupply,\\n            oldBalance.sub(amount),\\n            totalSupply()\\n        );\\n    }\\n\\n    function _transfer(\\n        address,\\n        address,\\n        uint256\\n    ) internal override {\\n        revert(\\\"Transfer is not allowed\\\");\\n    }\\n\\n    function workingBalanceOf(address account) external view override returns (uint256) {\\n        return _workingBalances[account];\\n    }\\n\\n    function workingSupply() external view override returns (uint256) {\\n        return _workingSupply;\\n    }\\n\\n    function claimableRewards(address account)\\n        external\\n        override\\n        returns (\\n            uint256 chessAmount,\\n            uint256 bonusAmount,\\n            uint256 amountQ,\\n            uint256 amountB,\\n            uint256 amountR,\\n            uint256 quoteAmount\\n        )\\n    {\\n        return _checkpoint(account, balanceOf(account), _workingBalances[account], _workingSupply);\\n    }\\n\\n    function claimRewards(address account) external override {\\n        uint256 balance = balanceOf(account);\\n        uint256 oldWorkingBalance = _workingBalances[account];\\n        uint256 oldWorkingSupply = _workingSupply;\\n        (\\n            uint256 chessAmount,\\n            uint256 bonusAmount,\\n            uint256 amountQ,\\n            uint256 amountB,\\n            uint256 amountR,\\n            uint256 quoteAmount\\n        ) = _checkpoint(account, balance, oldWorkingBalance, oldWorkingSupply);\\n        _updateWorkingBalance(account, oldWorkingBalance, oldWorkingSupply, balance, totalSupply());\\n\\n        if (chessAmount != 0) {\\n            chessSchedule.mint(account, chessAmount);\\n            delete _claimableChess[account];\\n        }\\n        if (bonusAmount != 0) {\\n            _bonusToken.safeTransfer(account, bonusAmount);\\n            delete _claimableBonus[account];\\n        }\\n        if (amountQ != 0 || amountB != 0 || amountR != 0 || quoteAmount != 0) {\\n            uint256 version = latestVersion;\\n            if (amountQ != 0) {\\n                fund.trancheTransfer(TRANCHE_Q, account, amountQ, version);\\n            }\\n            if (amountB != 0) {\\n                fund.trancheTransfer(TRANCHE_B, account, amountB, version);\\n            }\\n            if (amountR != 0) {\\n                fund.trancheTransfer(TRANCHE_R, account, amountR, version);\\n            }\\n            if (quoteAmount != 0) {\\n                _quoteToken.safeTransfer(account, quoteAmount);\\n            }\\n            delete userDistributions[account];\\n        }\\n    }\\n\\n    function syncWithVotingEscrow(address account) external {\\n        uint256 balance = balanceOf(account);\\n        uint256 oldWorkingBalance = _workingBalances[account];\\n        uint256 oldWorkingSupply = _workingSupply;\\n        _checkpoint(account, balance, oldWorkingBalance, oldWorkingSupply);\\n        _updateWorkingBalance(account, oldWorkingBalance, oldWorkingSupply, balance, totalSupply());\\n    }\\n\\n    function distribute(\\n        uint256 amountQ,\\n        uint256 amountB,\\n        uint256 amountR,\\n        uint256 quoteAmount,\\n        uint256 version\\n    ) external override onlyStableSwap {\\n        // Update global state\\n        distributions[version].amountQ = amountQ;\\n        distributions[version].amountB = amountB;\\n        distributions[version].amountR = amountR;\\n        distributions[version].quoteAmount = quoteAmount;\\n        distributionTotalSupplies[version] = totalSupply();\\n        latestVersion = version;\\n    }\\n\\n    function _updateWorkingBalance(\\n        address account,\\n        uint256 oldWorkingBalance,\\n        uint256 oldWorkingSupply,\\n        uint256 newBalance,\\n        uint256 newTotalSupply\\n    ) private {\\n        uint256 newWorkingBalance = newBalance;\\n        uint256 veBalance = _votingEscrow.balanceOf(account);\\n        if (veBalance > 0) {\\n            uint256 veTotalSupply = _votingEscrow.totalSupply();\\n            uint256 maxWorkingBalance = newWorkingBalance.multiplyDecimal(MAX_BOOSTING_FACTOR);\\n            uint256 boostedWorkingBalance =\\n                newWorkingBalance.add(\\n                    newTotalSupply\\n                        .mul(veBalance)\\n                        .multiplyDecimal(MAX_BOOSTING_FACTOR_MINUS_ONE)\\n                        .div(veTotalSupply)\\n                );\\n            newWorkingBalance = maxWorkingBalance.min(boostedWorkingBalance);\\n        }\\n        _workingSupply = oldWorkingSupply.sub(oldWorkingBalance).add(newWorkingBalance);\\n        _workingBalances[account] = newWorkingBalance;\\n    }\\n\\n    function _checkpoint(\\n        address account,\\n        uint256 balance,\\n        uint256 weight,\\n        uint256 totalWeight\\n    )\\n        private\\n        returns (\\n            uint256 chessAmount,\\n            uint256 bonusAmount,\\n            uint256 amountQ,\\n            uint256 amountB,\\n            uint256 amountR,\\n            uint256 quoteAmount\\n        )\\n    {\\n        chessAmount = _chessCheckpoint(account, weight, totalWeight);\\n        bonusAmount = _bonusCheckpoint(account, weight, totalWeight);\\n        (amountQ, amountB, amountR, quoteAmount) = _distributionCheckpoint(account, balance);\\n    }\\n\\n    function _chessCheckpoint(\\n        address account,\\n        uint256 weight,\\n        uint256 totalWeight\\n    ) private returns (uint256 amount) {\\n        // Update global state\\n        uint256 timestamp = _chessIntegralTimestamp;\\n        uint256 integral = _chessIntegral;\\n        uint256 endWeek = _endOfWeek(timestamp);\\n        uint256 rate = _rate;\\n        for (uint256 i = 0; i < MAX_ITERATIONS && timestamp < block.timestamp; i++) {\\n            uint256 endTimestamp = endWeek.min(block.timestamp);\\n            if (totalWeight != 0 && endTimestamp > rewardStartTimestamp) {\\n                integral = integral.add(\\n                    rate\\n                        .mul(endTimestamp.sub(timestamp.max(rewardStartTimestamp)))\\n                        .decimalToPreciseDecimal()\\n                        .div(totalWeight)\\n                );\\n            }\\n            if (endTimestamp == endWeek) {\\n                rate = chessSchedule.getRate(endWeek).mul(\\n                    chessController.getFundRelativeWeight(address(this), endWeek)\\n                );\\n                if (endWeek < rewardStartTimestamp && endWeek + 1 weeks > rewardStartTimestamp) {\\n                    // Rewards start in the middle of the next week. We adjust the rate to\\n                    // compensate for the period between `endWeek` and `rewardStartTimestamp`.\\n                    rate = rate.mul(1 weeks).div(endWeek + 1 weeks - rewardStartTimestamp);\\n                }\\n                endWeek += 1 weeks;\\n            }\\n            timestamp = endTimestamp;\\n        }\\n        _chessIntegralTimestamp = block.timestamp;\\n        _chessIntegral = integral;\\n        _rate = rate;\\n\\n        // Update per-user state\\n        amount = _claimableChess[account].add(\\n            weight.multiplyDecimalPrecise(integral.sub(_chessUserIntegrals[account]))\\n        );\\n        _claimableChess[account] = amount;\\n        _chessUserIntegrals[account] = integral;\\n    }\\n\\n    function _bonusCheckpoint(\\n        address account,\\n        uint256 weight,\\n        uint256 totalWeight\\n    ) private returns (uint256 amount) {\\n        // Update global state\\n        uint256 newBonus = ISwapBonus(swapBonus).getBonus();\\n        uint256 integral = _bonusIntegral;\\n        if (totalWeight != 0 && newBonus != 0) {\\n            integral = integral.add(newBonus.divideDecimalPrecise(totalWeight));\\n            _bonusIntegral = integral;\\n        }\\n\\n        // Update per-user state\\n        uint256 oldUserIntegral = _bonusUserIntegral[account];\\n        if (oldUserIntegral == integral) {\\n            return _claimableBonus[account];\\n        }\\n        amount = _claimableBonus[account].add(\\n            weight.multiplyDecimalPrecise(integral.sub(oldUserIntegral))\\n        );\\n        _claimableBonus[account] = amount;\\n        _bonusUserIntegral[account] = integral;\\n    }\\n\\n    function _distributionCheckpoint(address account, uint256 balance)\\n        private\\n        returns (\\n            uint256 amountQ,\\n            uint256 amountB,\\n            uint256 amountR,\\n            uint256 quoteAmount\\n        )\\n    {\\n        uint256 version = userVersions[account];\\n        uint256 newVersion = latestVersion;\\n\\n        // Update per-user state\\n        Distribution storage userDist = userDistributions[account];\\n        amountQ = userDist.amountQ;\\n        amountB = userDist.amountB;\\n        amountR = userDist.amountR;\\n        quoteAmount = userDist.quoteAmount;\\n        if (version == newVersion) {\\n            return (amountQ, amountB, amountR, quoteAmount);\\n        }\\n        for (uint256 i = version; i < newVersion; i++) {\\n            if (amountQ != 0 || amountB != 0 || amountR != 0) {\\n                (amountQ, amountB, amountR) = fund.doRebalance(amountQ, amountB, amountR, i);\\n            }\\n            Distribution storage dist = distributions[i + 1];\\n            uint256 distTotalSupply = distributionTotalSupplies[i + 1];\\n            if (distTotalSupply != 0) {\\n                amountQ = amountQ.add(dist.amountQ.mul(balance).div(distTotalSupply));\\n                amountB = amountB.add(dist.amountB.mul(balance).div(distTotalSupply));\\n                amountR = amountR.add(dist.amountR.mul(balance).div(distTotalSupply));\\n                quoteAmount = quoteAmount.add(dist.quoteAmount.mul(balance).div(distTotalSupply));\\n            }\\n        }\\n        userDist.amountQ = amountQ;\\n        userDist.amountB = amountB;\\n        userDist.amountR = amountR;\\n        userDist.quoteAmount = quoteAmount;\\n        userVersions[account] = newVersion;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/swap/SwapBonus.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\ncontract SwapBonus is Ownable {\\n    using Math for uint256;\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    address public immutable liquidityGauge;\\n    address public immutable bonusToken;\\n    uint256 public ratePerSecond;\\n    uint256 public startTimestamp;\\n    uint256 public endTimestamp;\\n    uint256 public lastTimestamp;\\n\\n    constructor(address liquidityGauge_, address bonusToken_) public {\\n        liquidityGauge = liquidityGauge_;\\n        bonusToken = bonusToken_;\\n    }\\n\\n    function updateBonus(\\n        uint256 amount,\\n        uint256 start,\\n        uint256 interval\\n    ) external onlyOwner {\\n        require(start >= block.timestamp, \\\"Start time in the past\\\");\\n        require(\\n            endTimestamp < block.timestamp && endTimestamp == lastTimestamp,\\n            \\\"Last reward not yet expired\\\"\\n        );\\n        ratePerSecond = amount.div(interval);\\n        startTimestamp = start;\\n        endTimestamp = start.add(interval);\\n        lastTimestamp = startTimestamp;\\n        IERC20(bonusToken).safeTransferFrom(msg.sender, address(this), ratePerSecond.mul(interval));\\n    }\\n\\n    function getBonus() external returns (uint256) {\\n        require(msg.sender == liquidityGauge);\\n        uint256 currentTimestamp = endTimestamp.min(block.timestamp);\\n        uint256 reward = ratePerSecond.mul(currentTimestamp - lastTimestamp);\\n        lastTimestamp = currentTimestamp;\\n        if (reward > 0) {\\n            IERC20(bonusToken).safeTransfer(liquidityGauge, reward);\\n        }\\n        return reward;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/swap/SwapRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"../interfaces/ISwapRouter.sol\\\";\\nimport \\\"../interfaces/ITrancheIndexV2.sol\\\";\\nimport \\\"../fund/ShareStaking.sol\\\";\\nimport \\\"../interfaces/IWrappedERC20.sol\\\";\\n\\n/// @title Tranchess Swap Router\\n/// @notice Router for stateless execution of swaps against Tranchess stable swaps\\ncontract SwapRouter is ISwapRouter, ITrancheIndexV2, Ownable {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    event SwapAdded(address addr0, address addr1, address swap);\\n\\n    mapping(address => mapping(address => IStableSwap)) private _swapMap;\\n\\n    /// @dev Returns the swap for the given token pair and fee. The swap contract may or may not exist.\\n    function getSwap(address baseAddress, address quoteAddress)\\n        public\\n        view\\n        override\\n        returns (IStableSwap)\\n    {\\n        (address addr0, address addr1) =\\n            baseAddress < quoteAddress ? (baseAddress, quoteAddress) : (quoteAddress, baseAddress);\\n        return _swapMap[addr0][addr1];\\n    }\\n\\n    function addSwap(\\n        address baseAddress,\\n        address quoteAddress,\\n        address swap\\n    ) external onlyOwner {\\n        require(\\n            swap == address(0) ||\\n                (baseAddress == IStableSwap(swap).baseAddress() &&\\n                    quoteAddress == IStableSwap(swap).quoteAddress())\\n        ); // sanity check\\n        (address addr0, address addr1) =\\n            baseAddress < quoteAddress ? (baseAddress, quoteAddress) : (quoteAddress, baseAddress);\\n        _swapMap[addr0][addr1] = IStableSwap(swap);\\n        emit SwapAdded(addr0, addr1, swap);\\n    }\\n\\n    receive() external payable {}\\n\\n    function addLiquidity(\\n        address baseAddress,\\n        address quoteAddress,\\n        uint256 baseIn,\\n        uint256 quoteIn,\\n        uint256 minLpOut,\\n        uint256 version,\\n        uint256 deadline\\n    ) external payable override checkDeadline(deadline) {\\n        IStableSwap swap = getSwap(baseAddress, quoteAddress);\\n        require(address(swap) != address(0), \\\"Unknown swap\\\");\\n\\n        swap.fund().trancheTransferFrom(\\n            swap.baseTranche(),\\n            msg.sender,\\n            address(swap),\\n            baseIn,\\n            version\\n        );\\n        if (msg.value > 0) {\\n            require(msg.value == quoteIn); // sanity check\\n            IWrappedERC20(quoteAddress).deposit{value: quoteIn}();\\n            IERC20(quoteAddress).safeTransfer(address(swap), quoteIn);\\n        } else {\\n            IERC20(quoteAddress).safeTransferFrom(msg.sender, address(swap), quoteIn);\\n        }\\n\\n        uint256 lpOut = swap.addLiquidity(version, msg.sender);\\n        require(lpOut >= minLpOut, \\\"Insufficient output\\\");\\n    }\\n\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 minAmountOut,\\n        address[] calldata path,\\n        address recipient,\\n        address staking,\\n        uint256[] calldata versions,\\n        uint256 deadline\\n    ) external payable override checkDeadline(deadline) returns (uint256[] memory amounts) {\\n        require(path.length >= 2, \\\"Invalid path\\\");\\n        require(versions.length == path.length - 1, \\\"Invalid versions\\\");\\n        IStableSwap[] memory swaps;\\n        bool[] memory isBuy;\\n        (amounts, swaps, isBuy) = getAmountsOut(amountIn, path);\\n        require(amounts[amounts.length - 1] >= minAmountOut, \\\"Insufficient output\\\");\\n\\n        if (msg.value > 0) {\\n            require(msg.value == amounts[0]); // sanity check\\n            IWrappedERC20(path[0]).deposit{value: amounts[0]}();\\n            IERC20(path[0]).safeTransfer(address(swaps[0]), amounts[0]);\\n        } else {\\n            if (isBuy[0]) {\\n                IERC20(path[0]).safeTransferFrom(msg.sender, address(swaps[0]), amounts[0]);\\n            } else {\\n                swaps[0].fund().trancheTransferFrom(\\n                    swaps[0].baseTranche(),\\n                    msg.sender,\\n                    address(swaps[0]),\\n                    amounts[0],\\n                    versions[0]\\n                );\\n            }\\n        }\\n\\n        if (staking == address(0)) {\\n            _swap(amounts, swaps, isBuy, versions, recipient);\\n        } else {\\n            _swap(amounts, swaps, isBuy, versions, staking);\\n            ShareStaking(staking).deposit(\\n                swaps[swaps.length - 1].baseTranche(),\\n                amounts[amounts.length - 1],\\n                recipient,\\n                versions[versions.length - 1]\\n            );\\n        }\\n    }\\n\\n    function swapTokensForExactTokens(\\n        uint256 amountOut,\\n        uint256 maxAmountIn,\\n        address[] calldata path,\\n        address recipient,\\n        address staking,\\n        uint256[] calldata versions,\\n        uint256 deadline\\n    ) external payable override checkDeadline(deadline) returns (uint256[] memory amounts) {\\n        require(path.length >= 2, \\\"Invalid path\\\");\\n        require(versions.length == path.length - 1, \\\"Invalid versions\\\");\\n        IStableSwap[] memory swaps;\\n        bool[] memory isBuy;\\n        (amounts, swaps, isBuy) = getAmountsIn(amountOut, path);\\n        require(amounts[0] <= maxAmountIn, \\\"Excessive input\\\");\\n\\n        if (msg.value > 0) {\\n            require(msg.value == maxAmountIn); // sanity check\\n            IWrappedERC20(path[0]).deposit{value: amounts[0]}();\\n            IERC20(path[0]).safeTransfer(address(swaps[0]), amounts[0]);\\n        } else {\\n            if (isBuy[0]) {\\n                IERC20(path[0]).safeTransferFrom(msg.sender, address(swaps[0]), amounts[0]);\\n            } else {\\n                swaps[0].fund().trancheTransferFrom(\\n                    swaps[0].baseTranche(),\\n                    msg.sender,\\n                    address(swaps[0]),\\n                    amounts[0],\\n                    versions[0]\\n                );\\n            }\\n        }\\n\\n        if (staking == address(0)) {\\n            _swap(amounts, swaps, isBuy, versions, recipient);\\n        } else {\\n            _swap(amounts, swaps, isBuy, versions, staking);\\n            ShareStaking(staking).deposit(\\n                swaps[swaps.length - 1].baseTranche(),\\n                amountOut,\\n                recipient,\\n                versions[versions.length - 1]\\n            );\\n        }\\n        // refund native token\\n        if (msg.value > amounts[0]) {\\n            (bool success, ) = msg.sender.call{value: msg.value - amounts[0]}(\\\"\\\");\\n            require(success, \\\"Transfer failed\\\");\\n        }\\n    }\\n\\n    function swapExactTokensForTokensUnwrap(\\n        uint256 amountIn,\\n        uint256 minAmountOut,\\n        address[] calldata path,\\n        address recipient,\\n        uint256[] calldata versions,\\n        uint256 deadline\\n    ) external override checkDeadline(deadline) returns (uint256[] memory amounts) {\\n        require(path.length >= 2, \\\"Invalid path\\\");\\n        require(versions.length == path.length - 1, \\\"Invalid versions\\\");\\n        IStableSwap[] memory swaps;\\n        bool[] memory isBuy;\\n        (amounts, swaps, isBuy) = getAmountsOut(amountIn, path);\\n        require(amounts[amounts.length - 1] >= minAmountOut, \\\"Insufficient output\\\");\\n        if (isBuy[0]) {\\n            IERC20(path[0]).safeTransferFrom(msg.sender, address(swaps[0]), amounts[0]);\\n        } else {\\n            swaps[0].fund().trancheTransferFrom(\\n                swaps[0].baseTranche(),\\n                msg.sender,\\n                address(swaps[0]),\\n                amounts[0],\\n                versions[0]\\n            );\\n        }\\n        _swap(amounts, swaps, isBuy, versions, address(this));\\n        IWrappedERC20(path[path.length - 1]).withdraw(amounts[amounts.length - 1]);\\n        (bool success, ) = recipient.call{value: amounts[amounts.length - 1]}(\\\"\\\");\\n        require(success, \\\"Transfer failed\\\");\\n    }\\n\\n    function swapTokensForExactTokensUnwrap(\\n        uint256 amountOut,\\n        uint256 maxAmountIn,\\n        address[] calldata path,\\n        address recipient,\\n        uint256[] calldata versions,\\n        uint256 deadline\\n    ) external override checkDeadline(deadline) returns (uint256[] memory amounts) {\\n        require(path.length >= 2, \\\"Invalid path\\\");\\n        require(versions.length == path.length - 1, \\\"Invalid versions\\\");\\n        IStableSwap[] memory swaps;\\n        bool[] memory isBuy;\\n        (amounts, swaps, isBuy) = getAmountsIn(amountOut, path);\\n        require(amounts[0] <= maxAmountIn, \\\"Excessive input\\\");\\n        if (isBuy[0]) {\\n            IERC20(path[0]).safeTransferFrom(msg.sender, address(swaps[0]), amounts[0]);\\n        } else {\\n            swaps[0].fund().trancheTransferFrom(\\n                swaps[0].baseTranche(),\\n                msg.sender,\\n                address(swaps[0]),\\n                amounts[0],\\n                versions[0]\\n            );\\n        }\\n        _swap(amounts, swaps, isBuy, versions, address(this));\\n        IWrappedERC20(path[path.length - 1]).withdraw(amountOut);\\n        (bool success, ) = recipient.call{value: amountOut}(\\\"\\\");\\n        require(success, \\\"Transfer failed\\\");\\n    }\\n\\n    function getAmountsOut(uint256 amount, address[] memory path)\\n        public\\n        view\\n        override\\n        returns (\\n            uint256[] memory amounts,\\n            IStableSwap[] memory swaps,\\n            bool[] memory isBuy\\n        )\\n    {\\n        amounts = new uint256[](path.length);\\n        swaps = new IStableSwap[](path.length - 1);\\n        isBuy = new bool[](path.length - 1);\\n        amounts[0] = amount;\\n        for (uint256 i; i < path.length - 1; i++) {\\n            swaps[i] = getSwap(path[i], path[i + 1]);\\n            require(address(swaps[i]) != address(0), \\\"Unknown swap\\\");\\n            if (path[i] == swaps[i].baseAddress()) {\\n                amounts[i + 1] = swaps[i].getQuoteOut(amounts[i]);\\n            } else {\\n                isBuy[i] = true;\\n                amounts[i + 1] = swaps[i].getBaseOut(amounts[i]);\\n            }\\n        }\\n    }\\n\\n    function getAmountsIn(uint256 amount, address[] memory path)\\n        public\\n        view\\n        override\\n        returns (\\n            uint256[] memory amounts,\\n            IStableSwap[] memory swaps,\\n            bool[] memory isBuy\\n        )\\n    {\\n        amounts = new uint256[](path.length);\\n        swaps = new IStableSwap[](path.length - 1);\\n        isBuy = new bool[](path.length - 1);\\n        amounts[amounts.length - 1] = amount;\\n        for (uint256 i = path.length - 1; i > 0; i--) {\\n            swaps[i - 1] = getSwap(path[i - 1], path[i]);\\n            require(address(swaps[i - 1]) != address(0), \\\"Unknown swap\\\");\\n            if (path[i] == swaps[i - 1].baseAddress()) {\\n                isBuy[i - 1] = true;\\n                amounts[i - 1] = swaps[i - 1].getQuoteIn(amounts[i]);\\n            } else {\\n                amounts[i - 1] = swaps[i - 1].getBaseIn(amounts[i]);\\n            }\\n        }\\n    }\\n\\n    function _swap(\\n        uint256[] memory amounts,\\n        IStableSwap[] memory swaps,\\n        bool[] memory isBuy,\\n        uint256[] calldata versions,\\n        address recipient\\n    ) private {\\n        for (uint256 i = 0; i < swaps.length; i++) {\\n            address to = i < swaps.length - 1 ? address(swaps[i + 1]) : recipient;\\n            if (!isBuy[i]) {\\n                swaps[i].sell(versions[i], amounts[i + 1], to, new bytes(0));\\n            } else {\\n                swaps[i].buy(versions[i], amounts[i + 1], to, new bytes(0));\\n            }\\n        }\\n    }\\n\\n    modifier checkDeadline(uint256 deadline) {\\n        require(block.timestamp <= deadline, \\\"Transaction too old\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPrimaryMarketRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../interfaces/IFundV3.sol\\\";\\nimport \\\"../interfaces/IStableSwap.sol\\\";\\n\\ninterface IPrimaryMarketRouter is IStableSwapCore {\\n    function create(\\n        address recipient,\\n        uint256 underlying,\\n        uint256 minOutQ,\\n        uint256 version\\n    ) external payable returns (uint256 outQ);\\n\\n    function createAndStake(\\n        uint256 underlying,\\n        uint256 minOutQ,\\n        address staking,\\n        uint256 version\\n    ) external payable;\\n\\n    function createSplitAndStake(\\n        uint256 underlying,\\n        uint256 minOutQ,\\n        address router,\\n        address quoteAddress,\\n        uint256 minLpOut,\\n        address staking,\\n        uint256 version\\n    ) external payable;\\n\\n    function splitAndStake(\\n        uint256 inQ,\\n        address router,\\n        address quoteAddress,\\n        uint256 minLpOut,\\n        address staking,\\n        uint256 version\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISwapRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"./IStableSwap.sol\\\";\\n\\ninterface ISwapRouter {\\n    function getSwap(address baseToken, address quoteToken) external view returns (IStableSwap);\\n\\n    function getAmountsOut(uint256 amount, address[] memory path)\\n        external\\n        view\\n        returns (\\n            uint256[] memory amounts,\\n            IStableSwap[] memory swaps,\\n            bool[] memory isBuy\\n        );\\n\\n    function getAmountsIn(uint256 amount, address[] memory path)\\n        external\\n        view\\n        returns (\\n            uint256[] memory amounts,\\n            IStableSwap[] memory swaps,\\n            bool[] memory isBuy\\n        );\\n\\n    function addLiquidity(\\n        address baseToken,\\n        address quoteToken,\\n        uint256 baseDelta,\\n        uint256 quoteDelta,\\n        uint256 minMintAmount,\\n        uint256 version,\\n        uint256 deadline\\n    ) external payable;\\n\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 minAmountOut,\\n        address[] calldata path,\\n        address recipient,\\n        address staking,\\n        uint256[] calldata versions,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n\\n    function swapTokensForExactTokens(\\n        uint256 amountOut,\\n        uint256 maxAmountIn,\\n        address[] calldata path,\\n        address recipient,\\n        address staking,\\n        uint256[] calldata versions,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n\\n    function swapExactTokensForTokensUnwrap(\\n        uint256 amountIn,\\n        uint256 minAmountOut,\\n        address[] calldata path,\\n        address recipient,\\n        uint256[] calldata versions,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapTokensForExactTokensUnwrap(\\n        uint256 amountOut,\\n        uint256 maxAmountIn,\\n        address[] calldata path,\\n        address recipient,\\n        uint256[] calldata versions,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStableSwap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"../interfaces/IFundV3.sol\\\";\\n\\ninterface IStableSwapCore {\\n    function getQuoteOut(uint256 baseIn) external view returns (uint256 quoteOut);\\n\\n    function getQuoteIn(uint256 baseOut) external view returns (uint256 quoteIn);\\n\\n    function getBaseOut(uint256 quoteIn) external view returns (uint256 baseOut);\\n\\n    function getBaseIn(uint256 quoteOut) external view returns (uint256 baseIn);\\n\\n    function buy(\\n        uint256 version,\\n        uint256 baseOut,\\n        address recipient,\\n        bytes calldata data\\n    ) external returns (uint256 realBaseOut);\\n\\n    function sell(\\n        uint256 version,\\n        uint256 quoteOut,\\n        address recipient,\\n        bytes calldata data\\n    ) external returns (uint256 realQuoteOut);\\n}\\n\\ninterface IStableSwap is IStableSwapCore {\\n    function fund() external view returns (IFundV3);\\n\\n    function baseTranche() external view returns (uint256);\\n\\n    function baseAddress() external view returns (address);\\n\\n    function quoteAddress() external view returns (address);\\n\\n    function allBalances() external view returns (uint256, uint256);\\n\\n    function getOraclePrice() external view returns (uint256);\\n\\n    function getCurrentD() external view returns (uint256);\\n\\n    function getCurrentPriceOverOracle() external view returns (uint256);\\n\\n    function getCurrentPrice() external view returns (uint256);\\n\\n    function getPriceOverOracleIntegral() external view returns (uint256);\\n\\n    function addLiquidity(uint256 version, address recipient) external returns (uint256);\\n\\n    function removeLiquidity(\\n        uint256 version,\\n        uint256 lpIn,\\n        uint256 minBaseOut,\\n        uint256 minQuoteOut\\n    ) external returns (uint256 baseOut, uint256 quoteOut);\\n\\n    function removeLiquidityUnwrap(\\n        uint256 version,\\n        uint256 lpIn,\\n        uint256 minBaseOut,\\n        uint256 minQuoteOut\\n    ) external returns (uint256 baseOut, uint256 quoteOut);\\n\\n    function removeBaseLiquidity(\\n        uint256 version,\\n        uint256 lpIn,\\n        uint256 minBaseOut\\n    ) external returns (uint256 baseOut);\\n\\n    function removeQuoteLiquidity(\\n        uint256 version,\\n        uint256 lpIn,\\n        uint256 minQuoteOut\\n    ) external returns (uint256 quoteOut);\\n\\n    function removeQuoteLiquidityUnwrap(\\n        uint256 version,\\n        uint256 lpIn,\\n        uint256 minQuoteOut\\n    ) external returns (uint256 quoteOut);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILiquidityGauge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface ILiquidityGauge is IERC20 {\\n    function mint(address account, uint256 amount) external;\\n\\n    function burnFrom(address account, uint256 amount) external;\\n\\n    function workingSupply() external view returns (uint256);\\n\\n    function workingBalanceOf(address account) external view returns (uint256);\\n\\n    function claimableRewards(address account)\\n        external\\n        returns (\\n            uint256 chessAmount,\\n            uint256 bonusAmount,\\n            uint256 amountQ,\\n            uint256 amountB,\\n            uint256 amountR,\\n            uint256 quoteAmount\\n        );\\n\\n    function claimRewards(address account) external;\\n\\n    function distribute(\\n        uint256 amountQ,\\n        uint256 amountB,\\n        uint256 amountR,\\n        uint256 quoteAmount,\\n        uint256 version\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITranchessSwapCallee.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\ninterface ITranchessSwapCallee {\\n    function tranchessSwapCallback(\\n        uint256 baseDeltaOut,\\n        uint256 quoteDeltaOut,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/utils/AdvancedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nlibrary AdvancedMath {\\n    /// @dev Calculate square root.\\n    ///\\n    ///      Reference: https://en.wikipedia.org/wiki/Integer_square_root#Algorithm_using_Newton's_method\\n    function sqrt(uint256 s) internal pure returns (uint256) {\\n        if (s == 0) return 0;\\n        uint256 t = s;\\n        uint256 x0 = 2;\\n        if (t >= 1 << 128) {\\n            t >>= 128;\\n            x0 <<= 64;\\n        }\\n        if (t >= 1 << 64) {\\n            t >>= 64;\\n            x0 <<= 32;\\n        }\\n        if (t >= 1 << 32) {\\n            t >>= 32;\\n            x0 <<= 16;\\n        }\\n        if (t >= 1 << 16) {\\n            t >>= 16;\\n            x0 <<= 8;\\n        }\\n        if (t >= 1 << 8) {\\n            t >>= 8;\\n            x0 <<= 4;\\n        }\\n        if (t >= 1 << 4) {\\n            t >>= 4;\\n            x0 <<= 2;\\n        }\\n        if (t >= 1 << 2) {\\n            x0 <<= 1;\\n        }\\n        uint256 x1 = (x0 + s / x0) >> 1;\\n        while (x1 < x0) {\\n            x0 = x1;\\n            x1 = (x0 + s / x0) >> 1;\\n        }\\n        return x0;\\n    }\\n\\n    /// @notice Calculate cubic root.\\n    function cbrt(uint256 s) internal pure returns (uint256) {\\n        if (s == 0) return 0;\\n        uint256 t = s;\\n        uint256 x0 = 2;\\n        if (t >= 1 << 192) {\\n            t >>= 192;\\n            x0 <<= 64;\\n        }\\n        if (t >= 1 << 96) {\\n            t >>= 96;\\n            x0 <<= 32;\\n        }\\n        if (t >= 1 << 48) {\\n            t >>= 48;\\n            x0 <<= 16;\\n        }\\n        if (t >= 1 << 24) {\\n            t >>= 24;\\n            x0 <<= 8;\\n        }\\n        if (t >= 1 << 12) {\\n            t >>= 12;\\n            x0 <<= 4;\\n        }\\n        if (t >= 1 << 6) {\\n            t >>= 6;\\n            x0 <<= 2;\\n        }\\n        if (t >= 1 << 3) {\\n            x0 <<= 1;\\n        }\\n        uint256 x1 = (2 * x0 + s / x0 / x0) / 3;\\n        while (x1 < x0) {\\n            x0 = x1;\\n            x1 = (2 * x0 + s / x0 / x0) / 3;\\n        }\\n        return x0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/misc/BatchOperationHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport {IVotingEscrowCallback} from \\\"../governance/VotingEscrowV2.sol\\\";\\n\\ninterface IClaimRewards {\\n    function claimRewards(address account) external;\\n\\n    function claimRewardsAndUnwrap(address account) external;\\n}\\n\\ncontract BatchOperationHelper {\\n    string public constant VERSION = \\\"2.0.0\\\";\\n\\n    function batchClaimRewards(address[] calldata contracts, address account) public {\\n        uint256 count = contracts.length;\\n        for (uint256 i = 0; i < count; i++) {\\n            IClaimRewards(contracts[i]).claimRewards(account);\\n        }\\n    }\\n\\n    function batchClaimRewardsAndUnwrap(\\n        address[] calldata contracts,\\n        address[] calldata wrappedContracts,\\n        address account\\n    ) external {\\n        batchClaimRewards(contracts, account);\\n        uint256 count = wrappedContracts.length;\\n        for (uint256 i = 0; i < count; i++) {\\n            IClaimRewards(wrappedContracts[i]).claimRewardsAndUnwrap(account);\\n        }\\n    }\\n\\n    function batchSyncWithVotingEscrow(address[] calldata contracts, address account) external {\\n        uint256 count = contracts.length;\\n        for (uint256 i = 0; i < count; i++) {\\n            IVotingEscrowCallback(contracts[i]).syncWithVotingEscrow(account);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/exchange/ExchangeV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\nimport \\\"../../utils/SafeDecimalMath.sol\\\";\\nimport \\\"../../utils/ProxyUtility.sol\\\";\\n\\nimport {Order, OrderQueue, LibOrderQueue} from \\\"./LibOrderQueue.sol\\\";\\nimport {\\n    UnsettledBuyTrade,\\n    UnsettledSellTrade,\\n    UnsettledTrade,\\n    LibUnsettledBuyTrade,\\n    LibUnsettledSellTrade\\n} from \\\"./LibUnsettledTrade.sol\\\";\\n\\nimport \\\"./ExchangeRoles.sol\\\";\\nimport \\\"./StakingV3.sol\\\";\\n\\n/// @title Tranchess's Exchange Contract\\n/// @notice A decentralized exchange to match premium-discount orders and clear trades\\n/// @author Tranchess\\ncontract ExchangeV3 is ExchangeRoles, StakingV3, ProxyUtility {\\n    /// @dev Reserved storage slots for future base contract upgrades\\n    uint256[29] private _reservedSlots;\\n\\n    using SafeDecimalMath for uint256;\\n    using LibOrderQueue for OrderQueue;\\n    using SafeERC20 for IERC20;\\n    using LibUnsettledBuyTrade for UnsettledBuyTrade;\\n    using LibUnsettledSellTrade for UnsettledSellTrade;\\n\\n    /// @notice A maker bid order is placed.\\n    /// @param maker Account placing the order\\n    /// @param tranche Tranche of the share to buy\\n    /// @param pdLevel Premium-discount level\\n    /// @param quoteAmount Amount of quote asset in the order, rounding precision to 18\\n    ///                    for quote assets with precision other than 18 decimal places\\n    /// @param version The latest rebalance version when the order is placed\\n    /// @param orderIndex Index of the order in the order queue\\n    event BidOrderPlaced(\\n        address indexed maker,\\n        uint256 indexed tranche,\\n        uint256 pdLevel,\\n        uint256 quoteAmount,\\n        uint256 version,\\n        uint256 orderIndex\\n    );\\n\\n    /// @notice A maker ask order is placed.\\n    /// @param maker Account placing the order\\n    /// @param tranche Tranche of the share to sell\\n    /// @param pdLevel Premium-discount level\\n    /// @param baseAmount Amount of base asset in the order\\n    /// @param version The latest rebalance version when the order is placed\\n    /// @param orderIndex Index of the order in the order queue\\n    event AskOrderPlaced(\\n        address indexed maker,\\n        uint256 indexed tranche,\\n        uint256 pdLevel,\\n        uint256 baseAmount,\\n        uint256 version,\\n        uint256 orderIndex\\n    );\\n\\n    /// @notice A maker bid order is canceled.\\n    /// @param maker Account placing the order\\n    /// @param tranche Tranche of the share\\n    /// @param pdLevel Premium-discount level\\n    /// @param quoteAmount Original amount of quote asset in the order, rounding precision to 18\\n    ///                    for quote assets with precision other than 18 decimal places\\n    /// @param version The latest rebalance version when the order is placed\\n    /// @param orderIndex Index of the order in the order queue\\n    /// @param fillable Unfilled amount when the order is canceled, rounding precision to 18 for\\n    ///                 quote assets with precision other than 18 decimal places\\n    event BidOrderCanceled(\\n        address indexed maker,\\n        uint256 indexed tranche,\\n        uint256 pdLevel,\\n        uint256 quoteAmount,\\n        uint256 version,\\n        uint256 orderIndex,\\n        uint256 fillable\\n    );\\n\\n    /// @notice A maker ask order is canceled.\\n    /// @param maker Account placing the order\\n    /// @param tranche Tranche of the share to sell\\n    /// @param pdLevel Premium-discount level\\n    /// @param baseAmount Original amount of base asset in the order\\n    /// @param version The latest rebalance version when the order is placed\\n    /// @param orderIndex Index of the order in the order queue\\n    /// @param fillable Unfilled amount when the order is canceled\\n    event AskOrderCanceled(\\n        address indexed maker,\\n        uint256 indexed tranche,\\n        uint256 pdLevel,\\n        uint256 baseAmount,\\n        uint256 version,\\n        uint256 orderIndex,\\n        uint256 fillable\\n    );\\n\\n    /// @notice Matching result of a taker bid order.\\n    /// @param taker Account placing the order\\n    /// @param tranche Tranche of the share\\n    /// @param quoteAmount Matched amount of quote asset, rounding precision to 18 for quote assets\\n    ///                    with precision other than 18 decimal places\\n    /// @param version Rebalance version of this trade\\n    /// @param lastMatchedPDLevel Premium-discount level of the last matched maker order\\n    /// @param lastMatchedOrderIndex Index of the last matched maker order in its order queue\\n    /// @param lastMatchedBaseAmount Matched base asset amount of the last matched maker order\\n    event BuyTrade(\\n        address indexed taker,\\n        uint256 indexed tranche,\\n        uint256 quoteAmount,\\n        uint256 version,\\n        uint256 lastMatchedPDLevel,\\n        uint256 lastMatchedOrderIndex,\\n        uint256 lastMatchedBaseAmount\\n    );\\n\\n    /// @notice Matching result of a taker ask order.\\n    /// @param taker Account placing the order\\n    /// @param tranche Tranche of the share\\n    /// @param baseAmount Matched amount of base asset\\n    /// @param version Rebalance version of this trade\\n    /// @param lastMatchedPDLevel Premium-discount level of the last matched maker order\\n    /// @param lastMatchedOrderIndex Index of the last matched maker order in its order queue\\n    /// @param lastMatchedQuoteAmount Matched quote asset amount of the last matched maker order,\\n    ///                               rounding precision to 18 for quote assets with precision\\n    ///                               other than 18 decimal places\\n    event SellTrade(\\n        address indexed taker,\\n        uint256 indexed tranche,\\n        uint256 baseAmount,\\n        uint256 version,\\n        uint256 lastMatchedPDLevel,\\n        uint256 lastMatchedOrderIndex,\\n        uint256 lastMatchedQuoteAmount\\n    );\\n\\n    /// @notice Settlement of unsettled trades of maker orders.\\n    /// @param account Account placing the related maker orders\\n    /// @param epoch Epoch of the settled trades\\n    /// @param amountM Amount of Token M added to the account's available balance\\n    /// @param amountA Amount of Token A added to the account's available balance\\n    /// @param amountB Amount of Token B added to the account's available balance\\n    /// @param quoteAmount Amount of quote asset transfered to the account, rounding precision to 18\\n    ///                    for quote assets with precision other than 18 decimal places\\n    event MakerSettled(\\n        address indexed account,\\n        uint256 epoch,\\n        uint256 amountM,\\n        uint256 amountA,\\n        uint256 amountB,\\n        uint256 quoteAmount\\n    );\\n\\n    /// @notice Settlement of unsettled trades of taker orders.\\n    /// @param account Account placing the related taker orders\\n    /// @param epoch Epoch of the settled trades\\n    /// @param amountM Amount of Token M added to the account's available balance\\n    /// @param amountA Amount of Token A added to the account's available balance\\n    /// @param amountB Amount of Token B added to the account's available balance\\n    /// @param quoteAmount Amount of quote asset transfered to the account, rounding precision to 18\\n    ///                    for quote assets with precision other than 18 decimal places\\n    event TakerSettled(\\n        address indexed account,\\n        uint256 epoch,\\n        uint256 amountM,\\n        uint256 amountA,\\n        uint256 amountB,\\n        uint256 quoteAmount\\n    );\\n\\n    uint256 private constant EPOCH = 30 minutes; // An exchange epoch is 30 minutes long\\n\\n    /// @dev Maker reserves 105% of Token M they want to trade, which would stop\\n    ///      losses for makers when the net asset values turn out volatile\\n    uint256 private constant MAKER_RESERVE_RATIO_M = 1.05e18;\\n\\n    /// @dev Maker reserves 100.1% of Token A they want to trade, which would stop\\n    ///      losses for makers when the net asset values turn out volatile\\n    uint256 private constant MAKER_RESERVE_RATIO_A = 1.001e18;\\n\\n    /// @dev Maker reserves 110% of Token B they want to trade, which would stop\\n    ///      losses for makers when the net asset values turn out volatile\\n    uint256 private constant MAKER_RESERVE_RATIO_B = 1.1e18;\\n\\n    /// @dev Premium-discount level ranges from -10% to 10% with 0.25% as step size\\n    uint256 private constant PD_TICK = 0.0025e18;\\n\\n    uint256 private constant MIN_PD = 0.9e18;\\n    uint256 private constant MAX_PD = 1.1e18;\\n    uint256 private constant PD_START = MIN_PD - PD_TICK;\\n    uint256 private constant PD_LEVEL_COUNT = (MAX_PD - MIN_PD) / PD_TICK + 1;\\n\\n    /// @notice Minumum quote amount of maker bid orders with 18 decimal places\\n    uint256 public immutable minBidAmount;\\n\\n    /// @notice Minumum base amount of maker ask orders\\n    uint256 public immutable minAskAmount;\\n\\n    /// @notice Minumum base or quote amount of maker orders during guarded launch\\n    uint256 public immutable guardedLaunchMinOrderAmount;\\n\\n    /// @dev A multipler that normalizes a quote asset balance to 18 decimal places.\\n    uint256 private immutable _quoteDecimalMultiplier;\\n\\n    /// @notice Mapping of rebalance version => tranche => an array of order queues\\n    mapping(uint256 => mapping(uint256 => OrderQueue[PD_LEVEL_COUNT + 1])) public bids;\\n    mapping(uint256 => mapping(uint256 => OrderQueue[PD_LEVEL_COUNT + 1])) public asks;\\n\\n    /// @notice Mapping of rebalance version => best bid premium-discount level of the three tranches.\\n    ///         Zero indicates that there is no bid order.\\n    mapping(uint256 => uint256[TRANCHE_COUNT]) public bestBids;\\n\\n    /// @notice Mapping of rebalance version => best ask premium-discount level of the three tranches.\\n    ///         Zero or `PD_LEVEL_COUNT + 1` indicates that there is no ask order.\\n    mapping(uint256 => uint256[TRANCHE_COUNT]) public bestAsks;\\n\\n    /// @notice Mapping of account => tranche => epoch => unsettled trade\\n    mapping(address => mapping(uint256 => mapping(uint256 => UnsettledTrade)))\\n        public unsettledTrades;\\n\\n    /// @dev Mapping of epoch => rebalance version\\n    mapping(uint256 => uint256) private _epochVersions;\\n\\n    /// @dev The `makerRequirement_` param is removed to workaround a stack-too-deep error.\\n    constructor(\\n        address fund_,\\n        address chessSchedule_,\\n        address chessController_,\\n        address quoteAssetAddress_,\\n        uint256 quoteDecimals_,\\n        address votingEscrow_,\\n        uint256 minBidAmount_,\\n        uint256 minAskAmount_,\\n        uint256 guardedLaunchStart_,\\n        uint256 guardedLaunchMinOrderAmount_,\\n        address upgradeTool_\\n    )\\n        public\\n        ExchangeRoles(votingEscrow_, 0)\\n        StakingV3(\\n            fund_,\\n            chessSchedule_,\\n            chessController_,\\n            quoteAssetAddress_,\\n            guardedLaunchStart_,\\n            votingEscrow_,\\n            upgradeTool_\\n        )\\n    {\\n        minBidAmount = minBidAmount_;\\n        minAskAmount = minAskAmount_;\\n        guardedLaunchMinOrderAmount = guardedLaunchMinOrderAmount_;\\n        require(quoteDecimals_ <= 18, \\\"Quote asset decimals larger than 18\\\");\\n        _quoteDecimalMultiplier = 10**(18 - quoteDecimals_);\\n    }\\n\\n    /// @dev Initialize the contract. The contract is designed to be used with OpenZeppelin's\\n    ///      `TransparentUpgradeableProxy`. This function should be called by the proxy's\\n    ///      constructor (via the `_data` argument).\\n    function initialize() external {\\n        _initializeStaking();\\n        _initializeV2(msg.sender);\\n    }\\n\\n    /// @dev Initialize the part added in V2. If this contract is upgraded from the previous\\n    ///      version, call `upgradeToAndCall` of the proxy and put a call to this function\\n    ///      in the `data` argument.\\n    function initializeV2(address pauser_) external onlyProxyAdmin {\\n        _initializeV2(pauser_);\\n    }\\n\\n    function _initializeV2(address pauser_) private {\\n        _initializeStakingV2(pauser_);\\n    }\\n\\n    /// @notice Return end timestamp of the epoch containing a given timestamp.\\n    /// @param timestamp Timestamp within a given epoch\\n    /// @return The closest ending timestamp\\n    function endOfEpoch(uint256 timestamp) public pure returns (uint256) {\\n        return (timestamp / EPOCH) * EPOCH + EPOCH;\\n    }\\n\\n    function getMakerReserveRatio(uint256 tranche) public pure returns (uint256) {\\n        if (tranche == TRANCHE_M) {\\n            return MAKER_RESERVE_RATIO_M;\\n        } else if (tranche == TRANCHE_A) {\\n            return MAKER_RESERVE_RATIO_A;\\n        } else {\\n            return MAKER_RESERVE_RATIO_B;\\n        }\\n    }\\n\\n    function getBidOrder(\\n        uint256 version,\\n        uint256 tranche,\\n        uint256 pdLevel,\\n        uint256 index\\n    )\\n        external\\n        view\\n        returns (\\n            address maker,\\n            uint256 amount,\\n            uint256 fillable\\n        )\\n    {\\n        Order storage order = bids[version][tranche][pdLevel].list[index];\\n        maker = order.maker;\\n        amount = order.amount;\\n        fillable = order.fillable;\\n    }\\n\\n    function getAskOrder(\\n        uint256 version,\\n        uint256 tranche,\\n        uint256 pdLevel,\\n        uint256 index\\n    )\\n        external\\n        view\\n        returns (\\n            address maker,\\n            uint256 amount,\\n            uint256 fillable\\n        )\\n    {\\n        Order storage order = asks[version][tranche][pdLevel].list[index];\\n        maker = order.maker;\\n        amount = order.amount;\\n        fillable = order.fillable;\\n    }\\n\\n    /// @notice Get all tranches' net asset values of a given time\\n    /// @param timestamp Timestamp of the net asset value\\n    /// @return estimatedNavM Token M's net asset value\\n    /// @return estimatedNavA Token A's net asset value\\n    /// @return estimatedNavB Token B's net asset value\\n    function estimateNavs(uint256 timestamp)\\n        public\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256 price = fund.twapOracle().getTwap(timestamp);\\n        require(price != 0, \\\"Price is not available\\\");\\n        return fund.extrapolateNav(timestamp, price);\\n    }\\n\\n    /// @notice Place a bid order for makers\\n    /// @param tranche Tranche of the base asset\\n    /// @param pdLevel Premium-discount level\\n    /// @param quoteAmount Quote asset amount with 18 decimal places\\n    /// @param version Current rebalance version. Revert if it is not the latest version.\\n    function placeBid(\\n        uint256 tranche,\\n        uint256 pdLevel,\\n        uint256 quoteAmount,\\n        uint256 version\\n    ) external onlyMaker whenNotPaused beforeProtocolUpgrade {\\n        require(block.timestamp >= guardedLaunchStart + 8 days, \\\"Guarded launch: market closed\\\");\\n        if (block.timestamp < guardedLaunchStart + 4 weeks) {\\n            require(quoteAmount >= guardedLaunchMinOrderAmount, \\\"Guarded launch: amount too low\\\");\\n        } else {\\n            require(quoteAmount >= minBidAmount, \\\"Quote amount too low\\\");\\n        }\\n        uint256 bestAsk = bestAsks[version][tranche];\\n        require(\\n            pdLevel > 0 && pdLevel < (bestAsk == 0 ? PD_LEVEL_COUNT + 1 : bestAsk),\\n            \\\"Invalid premium-discount level\\\"\\n        );\\n        require(version == _fundRebalanceSize(), \\\"Invalid version\\\");\\n\\n        uint256 index = bids[version][tranche][pdLevel].append(msg.sender, quoteAmount, version);\\n        if (bestBids[version][tranche] < pdLevel) {\\n            bestBids[version][tranche] = pdLevel;\\n        }\\n\\n        _transferQuoteFrom(msg.sender, quoteAmount);\\n\\n        emit BidOrderPlaced(msg.sender, tranche, pdLevel, quoteAmount, version, index);\\n    }\\n\\n    /// @notice Place an ask order for makers\\n    /// @param tranche Tranche of the base asset\\n    /// @param pdLevel Premium-discount level\\n    /// @param baseAmount Base asset amount\\n    /// @param version Current rebalance version. Revert if it is not the latest version.\\n    function placeAsk(\\n        uint256 tranche,\\n        uint256 pdLevel,\\n        uint256 baseAmount,\\n        uint256 version\\n    ) external onlyMaker whenNotPaused beforeProtocolUpgrade {\\n        require(block.timestamp >= guardedLaunchStart + 8 days, \\\"Guarded launch: market closed\\\");\\n        if (block.timestamp < guardedLaunchStart + 4 weeks) {\\n            require(baseAmount >= guardedLaunchMinOrderAmount, \\\"Guarded launch: amount too low\\\");\\n        } else {\\n            require(baseAmount >= minAskAmount, \\\"Base amount too low\\\");\\n        }\\n        require(\\n            pdLevel > bestBids[version][tranche] && pdLevel <= PD_LEVEL_COUNT,\\n            \\\"Invalid premium-discount level\\\"\\n        );\\n        require(version == _fundRebalanceSize(), \\\"Invalid version\\\");\\n\\n        _lock(tranche, msg.sender, baseAmount);\\n        uint256 index = asks[version][tranche][pdLevel].append(msg.sender, baseAmount, version);\\n        uint256 oldBestAsk = bestAsks[version][tranche];\\n        if (oldBestAsk > pdLevel || oldBestAsk == 0) {\\n            bestAsks[version][tranche] = pdLevel;\\n        }\\n\\n        emit AskOrderPlaced(msg.sender, tranche, pdLevel, baseAmount, version, index);\\n    }\\n\\n    /// @notice Cancel a bid order\\n    /// @param version Order's rebalance version\\n    /// @param tranche Tranche of the order's base asset\\n    /// @param pdLevel Order's premium-discount level\\n    /// @param index Order's index in the order queue\\n    function cancelBid(\\n        uint256 version,\\n        uint256 tranche,\\n        uint256 pdLevel,\\n        uint256 index\\n    ) external whenNotPaused returns (uint256 fillable) {\\n        OrderQueue storage orderQueue = bids[version][tranche][pdLevel];\\n        Order storage order = orderQueue.list[index];\\n        address maker = order.maker;\\n        // Bid orders can be canceled by anyone after the upgrade\\n        if (block.timestamp < upgradeTimestamp) {\\n            require(maker == msg.sender, \\\"Maker address mismatched\\\");\\n        } else {\\n            require(maker != address(0), \\\"Maker address mismatched\\\");\\n        }\\n\\n        fillable = order.fillable;\\n        emit BidOrderCanceled(maker, tranche, pdLevel, order.amount, version, index, fillable);\\n        orderQueue.cancel(index);\\n\\n        // Update bestBid\\n        if (bestBids[version][tranche] == pdLevel) {\\n            uint256 newBestBid = pdLevel;\\n            while (newBestBid > 0 && bids[version][tranche][newBestBid].isEmpty()) {\\n                newBestBid--;\\n            }\\n            bestBids[version][tranche] = newBestBid;\\n        }\\n\\n        _transferQuote(maker, fillable);\\n    }\\n\\n    /// @notice Cancel an ask order\\n    /// @param version Order's rebalance version\\n    /// @param tranche Tranche of the order's base asset\\n    /// @param pdLevel Order's premium-discount level\\n    /// @param index Order's index in the order queue\\n    function cancelAsk(\\n        uint256 version,\\n        uint256 tranche,\\n        uint256 pdLevel,\\n        uint256 index\\n    ) external whenNotPaused beforeProtocolUpgrade {\\n        OrderQueue storage orderQueue = asks[version][tranche][pdLevel];\\n        Order storage order = orderQueue.list[index];\\n        require(order.maker == msg.sender, \\\"Maker address mismatched\\\");\\n\\n        uint256 fillable = order.fillable;\\n        emit AskOrderCanceled(msg.sender, tranche, pdLevel, order.amount, version, index, fillable);\\n        orderQueue.cancel(index);\\n\\n        // Update bestAsk\\n        if (bestAsks[version][tranche] == pdLevel) {\\n            uint256 newBestAsk = pdLevel;\\n            while (newBestAsk <= PD_LEVEL_COUNT && asks[version][tranche][newBestAsk].isEmpty()) {\\n                newBestAsk++;\\n            }\\n            bestAsks[version][tranche] = newBestAsk;\\n        }\\n\\n        if (tranche == TRANCHE_M) {\\n            _rebalanceAndUnlock(msg.sender, fillable, 0, 0, version);\\n        } else if (tranche == TRANCHE_A) {\\n            _rebalanceAndUnlock(msg.sender, 0, fillable, 0, version);\\n        } else {\\n            _rebalanceAndUnlock(msg.sender, 0, 0, fillable, version);\\n        }\\n    }\\n\\n    /// @notice Buy Token M\\n    /// @param version Current rebalance version. Revert if it is not the latest version.\\n    /// @param maxPDLevel Maximal premium-discount level accepted\\n    /// @param quoteAmount Amount of quote assets (with 18 decimal places) willing to trade\\n    function buyM(\\n        uint256 version,\\n        uint256 maxPDLevel,\\n        uint256 quoteAmount\\n    ) external {\\n        (uint256 estimatedNav, , ) = estimateNavs(endOfEpoch(block.timestamp) - 2 * EPOCH);\\n        _buy(version, TRANCHE_M, maxPDLevel, estimatedNav, quoteAmount);\\n    }\\n\\n    /// @notice Buy Token A\\n    /// @param version Current rebalance version. Revert if it is not the latest version.\\n    /// @param maxPDLevel Maximal premium-discount level accepted\\n    /// @param quoteAmount Amount of quote assets (with 18 decimal places) willing to trade\\n    function buyA(\\n        uint256 version,\\n        uint256 maxPDLevel,\\n        uint256 quoteAmount\\n    ) external {\\n        (, uint256 estimatedNav, ) = estimateNavs(endOfEpoch(block.timestamp) - 2 * EPOCH);\\n        _buy(version, TRANCHE_A, maxPDLevel, estimatedNav, quoteAmount);\\n    }\\n\\n    /// @notice Buy Token B\\n    /// @param version Current rebalance version. Revert if it is not the latest version.\\n    /// @param maxPDLevel Maximal premium-discount level accepted\\n    /// @param quoteAmount Amount of quote assets (with 18 decimal places) willing to trade\\n    function buyB(\\n        uint256 version,\\n        uint256 maxPDLevel,\\n        uint256 quoteAmount\\n    ) external {\\n        (, , uint256 estimatedNav) = estimateNavs(endOfEpoch(block.timestamp) - 2 * EPOCH);\\n        _buy(version, TRANCHE_B, maxPDLevel, estimatedNav, quoteAmount);\\n    }\\n\\n    /// @notice Sell Token M\\n    /// @param version Current rebalance version. Revert if it is not the latest version.\\n    /// @param minPDLevel Minimal premium-discount level accepted\\n    /// @param baseAmount Amount of Token M willing to trade\\n    function sellM(\\n        uint256 version,\\n        uint256 minPDLevel,\\n        uint256 baseAmount\\n    ) external {\\n        (uint256 estimatedNav, , ) = estimateNavs(endOfEpoch(block.timestamp) - 2 * EPOCH);\\n        _sell(version, TRANCHE_M, minPDLevel, estimatedNav, baseAmount);\\n    }\\n\\n    /// @notice Sell Token A\\n    /// @param version Current rebalance version. Revert if it is not the latest version.\\n    /// @param minPDLevel Minimal premium-discount level accepted\\n    /// @param baseAmount Amount of Token A willing to trade\\n    function sellA(\\n        uint256 version,\\n        uint256 minPDLevel,\\n        uint256 baseAmount\\n    ) external {\\n        (, uint256 estimatedNav, ) = estimateNavs(endOfEpoch(block.timestamp) - 2 * EPOCH);\\n        _sell(version, TRANCHE_A, minPDLevel, estimatedNav, baseAmount);\\n    }\\n\\n    /// @notice Sell Token B\\n    /// @param version Current rebalance version. Revert if it is not the latest version.\\n    /// @param minPDLevel Minimal premium-discount level accepted\\n    /// @param baseAmount Amount of Token B willing to trade\\n    function sellB(\\n        uint256 version,\\n        uint256 minPDLevel,\\n        uint256 baseAmount\\n    ) external {\\n        (, , uint256 estimatedNav) = estimateNavs(endOfEpoch(block.timestamp) - 2 * EPOCH);\\n        _sell(version, TRANCHE_B, minPDLevel, estimatedNav, baseAmount);\\n    }\\n\\n    /// @notice Settle trades of a specified epoch for makers\\n    /// @param account Address of the maker\\n    /// @param epoch A specified epoch's end timestamp\\n    /// @return amountM Token M amount added to msg.sender's available balance\\n    /// @return amountA Token A amount added to msg.sender's available balance\\n    /// @return amountB Token B amount added to msg.sender's available balance\\n    /// @return quoteAmount Quote asset amount transfered to msg.sender, rounding precison to 18\\n    ///                     for quote assets with precision other than 18 decimal places\\n    function settleMaker(address account, uint256 epoch)\\n        external\\n        whenNotPaused\\n        returns (\\n            uint256 amountM,\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 quoteAmount\\n        )\\n    {\\n        (uint256 estimatedNavM, uint256 estimatedNavA, uint256 estimatedNavB) =\\n            estimateNavs(epoch.add(EPOCH));\\n\\n        uint256 quoteAmountM;\\n        uint256 quoteAmountA;\\n        uint256 quoteAmountB;\\n        (amountM, quoteAmountM) = _settleMaker(account, TRANCHE_M, estimatedNavM, epoch);\\n        (amountA, quoteAmountA) = _settleMaker(account, TRANCHE_A, estimatedNavA, epoch);\\n        (amountB, quoteAmountB) = _settleMaker(account, TRANCHE_B, estimatedNavB, epoch);\\n\\n        uint256 version = _epochVersions[epoch];\\n        (amountM, amountA, amountB) = _rebalanceAndClearTrade(\\n            account,\\n            amountM,\\n            amountA,\\n            amountB,\\n            version\\n        );\\n        quoteAmount = quoteAmountM.add(quoteAmountA).add(quoteAmountB);\\n        _transferQuote(account, quoteAmount);\\n\\n        emit MakerSettled(account, epoch, amountM, amountA, amountB, quoteAmount);\\n    }\\n\\n    /// @notice Settle trades of a specified epoch for takers\\n    /// @param account Address of the maker\\n    /// @param epoch A specified epoch's end timestamp\\n    /// @return amountM Token M amount added to msg.sender's available balance\\n    /// @return amountA Token A amount added to msg.sender's available balance\\n    /// @return amountB Token B amount added to msg.sender's available balance\\n    /// @return quoteAmount Quote asset amount transfered to msg.sender, rounding precison to 18\\n    ///                     for quote assets with precision other than 18 decimal places\\n    function settleTaker(address account, uint256 epoch)\\n        external\\n        whenNotPaused\\n        returns (\\n            uint256 amountM,\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 quoteAmount\\n        )\\n    {\\n        (uint256 estimatedNavM, uint256 estimatedNavA, uint256 estimatedNavB) =\\n            estimateNavs(epoch.add(EPOCH));\\n\\n        uint256 quoteAmountM;\\n        uint256 quoteAmountA;\\n        uint256 quoteAmountB;\\n        (amountM, quoteAmountM) = _settleTaker(account, TRANCHE_M, estimatedNavM, epoch);\\n        (amountA, quoteAmountA) = _settleTaker(account, TRANCHE_A, estimatedNavA, epoch);\\n        (amountB, quoteAmountB) = _settleTaker(account, TRANCHE_B, estimatedNavB, epoch);\\n\\n        uint256 version = _epochVersions[epoch];\\n        (amountM, amountA, amountB) = _rebalanceAndClearTrade(\\n            account,\\n            amountM,\\n            amountA,\\n            amountB,\\n            version\\n        );\\n        quoteAmount = quoteAmountM.add(quoteAmountA).add(quoteAmountB);\\n        _transferQuote(account, quoteAmount);\\n\\n        emit TakerSettled(account, epoch, amountM, amountA, amountB, quoteAmount);\\n    }\\n\\n    /// @dev Buy share\\n    /// @param version Current rebalance version. Revert if it is not the latest version.\\n    /// @param tranche Tranche of the base asset\\n    /// @param maxPDLevel Maximal premium-discount level accepted\\n    /// @param estimatedNav Estimated net asset value of the base asset\\n    /// @param quoteAmount Amount of quote assets willing to trade with 18 decimal places\\n    function _buy(\\n        uint256 version,\\n        uint256 tranche,\\n        uint256 maxPDLevel,\\n        uint256 estimatedNav,\\n        uint256 quoteAmount\\n    ) internal onlyActive whenNotPaused beforeProtocolUpgrade {\\n        require(maxPDLevel > 0 && maxPDLevel <= PD_LEVEL_COUNT, \\\"Invalid premium-discount level\\\");\\n        require(version == _fundRebalanceSize(), \\\"Invalid version\\\");\\n        require(estimatedNav > 0, \\\"Zero estimated NAV\\\");\\n\\n        UnsettledBuyTrade memory totalTrade;\\n        uint256 epoch = endOfEpoch(block.timestamp);\\n\\n        // Record rebalance version in the first transaction in the epoch\\n        if (_epochVersions[epoch] == 0) {\\n            _epochVersions[epoch] = version;\\n        }\\n\\n        UnsettledBuyTrade memory currentTrade;\\n        uint256 orderIndex = 0;\\n        uint256 pdLevel = bestAsks[version][tranche];\\n        if (pdLevel == 0) {\\n            // Zero best ask indicates that no ask order is ever placed.\\n            // We set pdLevel beyond the largest valid level, forcing the following loop\\n            // to exit immediately.\\n            pdLevel = PD_LEVEL_COUNT + 1;\\n        }\\n        for (; pdLevel <= maxPDLevel; pdLevel++) {\\n            uint256 price = pdLevel.mul(PD_TICK).add(PD_START).multiplyDecimal(estimatedNav);\\n            OrderQueue storage orderQueue = asks[version][tranche][pdLevel];\\n            orderIndex = orderQueue.head;\\n            while (orderIndex != 0) {\\n                Order storage order = orderQueue.list[orderIndex];\\n\\n                // If the order initiator is no longer qualified for maker,\\n                // we skip the order and the linked-list-based order queue\\n                // would never traverse the order again\\n                if (!isMaker(order.maker)) {\\n                    orderIndex = order.next;\\n                    continue;\\n                }\\n\\n                // Scope to avoid \\\"stack too deep\\\"\\n                {\\n                    // Calculate the current trade assuming that the taker would be completely filled.\\n                    uint256 makerReserveRatio = getMakerReserveRatio(tranche);\\n                    currentTrade.frozenQuote = quoteAmount.sub(totalTrade.frozenQuote);\\n                    currentTrade.reservedBase = currentTrade.frozenQuote.mul(makerReserveRatio).div(\\n                        price\\n                    );\\n\\n                    if (currentTrade.reservedBase < order.fillable) {\\n                        // Taker is completely filled.\\n                        currentTrade.effectiveQuote = currentTrade.frozenQuote.divideDecimal(\\n                            pdLevel.mul(PD_TICK).add(PD_START)\\n                        );\\n                    } else {\\n                        // Maker is completely filled. Recalculate the current trade.\\n                        currentTrade.frozenQuote = order.fillable.mul(price).div(makerReserveRatio);\\n                        currentTrade.effectiveQuote = order.fillable.mul(estimatedNav).div(\\n                            makerReserveRatio\\n                        );\\n                        currentTrade.reservedBase = order.fillable;\\n                    }\\n                }\\n                totalTrade.frozenQuote = totalTrade.frozenQuote.add(currentTrade.frozenQuote);\\n                totalTrade.effectiveQuote = totalTrade.effectiveQuote.add(\\n                    currentTrade.effectiveQuote\\n                );\\n                totalTrade.reservedBase = totalTrade.reservedBase.add(currentTrade.reservedBase);\\n                unsettledTrades[order.maker][tranche][epoch].makerSell.add(currentTrade);\\n\\n                // There is no need to rebalance for maker; the fact that the order could\\n                // be filled here indicates that the maker is in the latest version\\n                _tradeLocked(tranche, order.maker, currentTrade.reservedBase);\\n\\n                uint256 orderNewFillable = order.fillable.sub(currentTrade.reservedBase);\\n                if (orderNewFillable > 0) {\\n                    // Maker is not completely filled. Matching ends here.\\n                    order.fillable = orderNewFillable;\\n                    break;\\n                } else {\\n                    // Delete the completely filled maker order.\\n                    orderIndex = orderQueue.fill(orderIndex);\\n                }\\n            }\\n\\n            orderQueue.updateHead(orderIndex);\\n            if (orderIndex != 0) {\\n                // This premium-discount level is not completely filled. Matching ends here.\\n                if (bestAsks[version][tranche] != pdLevel) {\\n                    bestAsks[version][tranche] = pdLevel;\\n                }\\n                break;\\n            }\\n        }\\n        emit BuyTrade(\\n            msg.sender,\\n            tranche,\\n            totalTrade.frozenQuote,\\n            version,\\n            pdLevel,\\n            orderIndex,\\n            orderIndex == 0 ? 0 : currentTrade.reservedBase\\n        );\\n        if (orderIndex == 0) {\\n            // Matching ends by completely filling all orders at and below the specified\\n            // premium-discount level `maxPDLevel`.\\n            // Find the new best ask beyond that level.\\n            for (; pdLevel <= PD_LEVEL_COUNT; pdLevel++) {\\n                if (!asks[version][tranche][pdLevel].isEmpty()) {\\n                    break;\\n                }\\n            }\\n            bestAsks[version][tranche] = pdLevel;\\n        }\\n\\n        require(\\n            totalTrade.frozenQuote > 0,\\n            \\\"Nothing can be bought at the given premium-discount level\\\"\\n        );\\n        unsettledTrades[msg.sender][tranche][epoch].takerBuy.add(totalTrade);\\n        _transferQuoteFrom(msg.sender, totalTrade.frozenQuote);\\n    }\\n\\n    /// @dev Sell share\\n    /// @param version Current rebalance version. Revert if it is not the latest version.\\n    /// @param tranche Tranche of the base asset\\n    /// @param minPDLevel Minimal premium-discount level accepted\\n    /// @param estimatedNav Estimated net asset value of the base asset\\n    /// @param baseAmount Amount of base assets willing to trade\\n    function _sell(\\n        uint256 version,\\n        uint256 tranche,\\n        uint256 minPDLevel,\\n        uint256 estimatedNav,\\n        uint256 baseAmount\\n    ) internal onlyActive whenNotPaused beforeProtocolUpgrade {\\n        require(minPDLevel > 0 && minPDLevel <= PD_LEVEL_COUNT, \\\"Invalid premium-discount level\\\");\\n        require(version == _fundRebalanceSize(), \\\"Invalid version\\\");\\n        require(estimatedNav > 0, \\\"Zero estimated NAV\\\");\\n\\n        UnsettledSellTrade memory totalTrade;\\n        uint256 epoch = endOfEpoch(block.timestamp);\\n\\n        // Record rebalance version in the first transaction in the epoch\\n        if (_epochVersions[epoch] == 0) {\\n            _epochVersions[epoch] = version;\\n        }\\n\\n        UnsettledSellTrade memory currentTrade;\\n        uint256 orderIndex;\\n        uint256 pdLevel = bestBids[version][tranche];\\n        for (; pdLevel >= minPDLevel; pdLevel--) {\\n            uint256 price = pdLevel.mul(PD_TICK).add(PD_START).multiplyDecimal(estimatedNav);\\n            OrderQueue storage orderQueue = bids[version][tranche][pdLevel];\\n            orderIndex = orderQueue.head;\\n            while (orderIndex != 0) {\\n                Order storage order = orderQueue.list[orderIndex];\\n\\n                // If the order initiator is no longer qualified for maker,\\n                // we skip the order and the linked-list-based order queue\\n                // would never traverse the order again\\n                if (!isMaker(order.maker)) {\\n                    orderIndex = order.next;\\n                    continue;\\n                }\\n\\n                // Scope to avoid \\\"stack too deep\\\"\\n                {\\n                    // Calculate the current trade assuming that the taker would be completely filled.\\n                    uint256 makerReserveRatio = getMakerReserveRatio(tranche);\\n                    currentTrade.frozenBase = baseAmount.sub(totalTrade.frozenBase);\\n                    currentTrade.reservedQuote = currentTrade\\n                        .frozenBase\\n                        .multiplyDecimal(makerReserveRatio)\\n                        .multiplyDecimal(price);\\n\\n                    if (currentTrade.reservedQuote < order.fillable) {\\n                        // Taker is completely filled\\n                        currentTrade.effectiveBase = currentTrade.frozenBase.multiplyDecimal(\\n                            pdLevel.mul(PD_TICK).add(PD_START)\\n                        );\\n                    } else {\\n                        // Maker is completely filled. Recalculate the current trade.\\n                        currentTrade.frozenBase = order.fillable.divideDecimal(price).divideDecimal(\\n                            makerReserveRatio\\n                        );\\n                        currentTrade.effectiveBase = order\\n                            .fillable\\n                            .divideDecimal(estimatedNav)\\n                            .divideDecimal(makerReserveRatio);\\n                        currentTrade.reservedQuote = order.fillable;\\n                    }\\n                }\\n                totalTrade.frozenBase = totalTrade.frozenBase.add(currentTrade.frozenBase);\\n                totalTrade.effectiveBase = totalTrade.effectiveBase.add(currentTrade.effectiveBase);\\n                totalTrade.reservedQuote = totalTrade.reservedQuote.add(currentTrade.reservedQuote);\\n                unsettledTrades[order.maker][tranche][epoch].makerBuy.add(currentTrade);\\n\\n                uint256 orderNewFillable = order.fillable.sub(currentTrade.reservedQuote);\\n                if (orderNewFillable > 0) {\\n                    // Maker is not completely filled. Matching ends here.\\n                    order.fillable = orderNewFillable;\\n                    break;\\n                } else {\\n                    // Delete the completely filled maker order.\\n                    orderIndex = orderQueue.fill(orderIndex);\\n                }\\n            }\\n\\n            orderQueue.updateHead(orderIndex);\\n            if (orderIndex != 0) {\\n                // This premium-discount level is not completely filled. Matching ends here.\\n                if (bestBids[version][tranche] != pdLevel) {\\n                    bestBids[version][tranche] = pdLevel;\\n                }\\n                break;\\n            }\\n        }\\n        emit SellTrade(\\n            msg.sender,\\n            tranche,\\n            totalTrade.frozenBase,\\n            version,\\n            pdLevel,\\n            orderIndex,\\n            orderIndex == 0 ? 0 : currentTrade.reservedQuote\\n        );\\n        if (orderIndex == 0) {\\n            // Matching ends by completely filling all orders at and above the specified\\n            // premium-discount level `minPDLevel`.\\n            // Find the new best bid beyond that level.\\n            for (; pdLevel > 0; pdLevel--) {\\n                if (!bids[version][tranche][pdLevel].isEmpty()) {\\n                    break;\\n                }\\n            }\\n            bestBids[version][tranche] = pdLevel;\\n        }\\n\\n        require(\\n            totalTrade.frozenBase > 0,\\n            \\\"Nothing can be sold at the given premium-discount level\\\"\\n        );\\n        _tradeAvailable(tranche, msg.sender, totalTrade.frozenBase);\\n        unsettledTrades[msg.sender][tranche][epoch].takerSell.add(totalTrade);\\n    }\\n\\n    /// @dev Settle both buy and sell trades of a specified epoch for takers\\n    /// @param account Taker address\\n    /// @param tranche Tranche of the base asset\\n    /// @param estimatedNav Estimated net asset value for the base asset\\n    /// @param epoch The epoch's end timestamp\\n    function _settleTaker(\\n        address account,\\n        uint256 tranche,\\n        uint256 estimatedNav,\\n        uint256 epoch\\n    ) internal returns (uint256 baseAmount, uint256 quoteAmount) {\\n        UnsettledTrade storage unsettledTrade = unsettledTrades[account][tranche][epoch];\\n\\n        // Settle buy trade\\n        UnsettledBuyTrade memory takerBuy = unsettledTrade.takerBuy;\\n        if (takerBuy.frozenQuote > 0) {\\n            (uint256 executionQuote, uint256 executionBase) =\\n                _buyTradeResult(takerBuy, estimatedNav);\\n            baseAmount = executionBase;\\n            quoteAmount = takerBuy.frozenQuote.sub(executionQuote);\\n            delete unsettledTrade.takerBuy;\\n        }\\n\\n        // Settle sell trade\\n        UnsettledSellTrade memory takerSell = unsettledTrade.takerSell;\\n        if (takerSell.frozenBase > 0) {\\n            (uint256 executionQuote, uint256 executionBase) =\\n                _sellTradeResult(takerSell, estimatedNav);\\n            quoteAmount = quoteAmount.add(executionQuote);\\n            baseAmount = baseAmount.add(takerSell.frozenBase.sub(executionBase));\\n            delete unsettledTrade.takerSell;\\n        }\\n    }\\n\\n    /// @dev Settle both buy and sell trades of a specified epoch for makers\\n    /// @param account Maker address\\n    /// @param tranche Tranche of the base asset\\n    /// @param estimatedNav Estimated net asset value for the base asset\\n    /// @param epoch The epoch's end timestamp\\n    function _settleMaker(\\n        address account,\\n        uint256 tranche,\\n        uint256 estimatedNav,\\n        uint256 epoch\\n    ) internal returns (uint256 baseAmount, uint256 quoteAmount) {\\n        UnsettledTrade storage unsettledTrade = unsettledTrades[account][tranche][epoch];\\n\\n        // Settle buy trade\\n        UnsettledSellTrade memory makerBuy = unsettledTrade.makerBuy;\\n        if (makerBuy.frozenBase > 0) {\\n            (uint256 executionQuote, uint256 executionBase) =\\n                _sellTradeResult(makerBuy, estimatedNav);\\n            baseAmount = executionBase;\\n            quoteAmount = makerBuy.reservedQuote.sub(executionQuote);\\n            delete unsettledTrade.makerBuy;\\n        }\\n\\n        // Settle sell trade\\n        UnsettledBuyTrade memory makerSell = unsettledTrade.makerSell;\\n        if (makerSell.frozenQuote > 0) {\\n            (uint256 executionQuote, uint256 executionBase) =\\n                _buyTradeResult(makerSell, estimatedNav);\\n            quoteAmount = quoteAmount.add(executionQuote);\\n            baseAmount = baseAmount.add(makerSell.reservedBase.sub(executionBase));\\n            delete unsettledTrade.makerSell;\\n        }\\n    }\\n\\n    /// @dev Calculate the result of an unsettled buy trade with a given NAV\\n    /// @param buyTrade Buy trade result of this particular epoch\\n    /// @param nav Net asset value for the base asset\\n    /// @return executionQuote Real amount of quote asset waiting for settlment\\n    /// @return executionBase Real amount of base asset waiting for settlment\\n    function _buyTradeResult(UnsettledBuyTrade memory buyTrade, uint256 nav)\\n        internal\\n        pure\\n        returns (uint256 executionQuote, uint256 executionBase)\\n    {\\n        uint256 reservedBase = buyTrade.reservedBase;\\n        uint256 reservedQuote = reservedBase.multiplyDecimal(nav);\\n        uint256 effectiveQuote = buyTrade.effectiveQuote;\\n        if (effectiveQuote < reservedQuote) {\\n            // Reserved base is enough to execute the trade.\\n            // nav is always positive here\\n            return (buyTrade.frozenQuote, effectiveQuote.divideDecimal(nav));\\n        } else {\\n            // Reserved base is not enough. The trade is partially executed\\n            // and a fraction of frozenQuote is returned to the taker.\\n            return (buyTrade.frozenQuote.mul(reservedQuote).div(effectiveQuote), reservedBase);\\n        }\\n    }\\n\\n    /// @dev Calculate the result of an unsettled sell trade with a given NAV\\n    /// @param sellTrade Sell trade result of this particular epoch\\n    /// @param nav Net asset value for the base asset\\n    /// @return executionQuote Real amount of quote asset waiting for settlment\\n    /// @return executionBase Real amount of base asset waiting for settlment\\n    function _sellTradeResult(UnsettledSellTrade memory sellTrade, uint256 nav)\\n        internal\\n        pure\\n        returns (uint256 executionQuote, uint256 executionBase)\\n    {\\n        uint256 reservedQuote = sellTrade.reservedQuote;\\n        uint256 effectiveQuote = sellTrade.effectiveBase.multiplyDecimal(nav);\\n        if (effectiveQuote < reservedQuote) {\\n            // Reserved quote is enough to execute the trade.\\n            return (effectiveQuote, sellTrade.frozenBase);\\n        } else {\\n            // Reserved quote is not enough. The trade is partially executed\\n            // and a fraction of frozenBase is returned to the taker.\\n            return (reservedQuote, sellTrade.frozenBase.mul(reservedQuote).div(effectiveQuote));\\n        }\\n    }\\n\\n    /// @dev Transfer quote asset to an account. Transfered amount is rounded down.\\n    /// @param account Recipient address\\n    /// @param amount Amount to transfer with 18 decimal places\\n    function _transferQuote(address account, uint256 amount) private {\\n        uint256 amountToTransfer = amount / _quoteDecimalMultiplier;\\n        if (amountToTransfer == 0) {\\n            return;\\n        }\\n        IERC20(quoteAssetAddress).safeTransfer(account, amountToTransfer);\\n    }\\n\\n    /// @dev Transfer quote asset from an account. Transfered amount is rounded up.\\n    /// @param account Sender address\\n    /// @param amount Amount to transfer with 18 decimal places\\n    function _transferQuoteFrom(address account, uint256 amount) private {\\n        uint256 amountToTransfer =\\n            amount.add(_quoteDecimalMultiplier - 1) / _quoteDecimalMultiplier;\\n        IERC20(quoteAssetAddress).safeTransferFrom(account, address(this), amountToTransfer);\\n    }\\n\\n    modifier onlyActive() {\\n        require(fund.isExchangeActive(block.timestamp), \\\"Exchange is inactive\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/exchange/StakingV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\nimport \\\"../../utils/SafeDecimalMath.sol\\\";\\nimport \\\"../../utils/CoreUtility.sol\\\";\\nimport \\\"../../utils/ManagedPausable.sol\\\";\\n\\nimport \\\"../interfaces/IFund.sol\\\";\\nimport \\\"../../interfaces/IChessController.sol\\\";\\nimport \\\"../../interfaces/IChessSchedule.sol\\\";\\nimport \\\"../interfaces/ITrancheIndex.sol\\\";\\nimport \\\"../interfaces/IPrimaryMarketV2.sol\\\";\\nimport \\\"../../interfaces/IVotingEscrow.sol\\\";\\n\\n/// @notice Chess locking snapshot used in calculating working balance of an account.\\n/// @param veProportion The account's veCHESS divided by the total veCHESS supply.\\n/// @param veLocked Locked CHESS and unlock time, which is synchronized from VotingEscrow.\\nstruct VESnapshot {\\n    uint256 veProportion;\\n    IVotingEscrow.LockedBalance veLocked;\\n}\\n\\ninterface IUpgradeTool {\\n    function upgradeTimestamp() external view returns (uint256);\\n}\\n\\nabstract contract StakingV3 is ITrancheIndex, CoreUtility, ManagedPausable {\\n    /// @dev Reserved storage slots for future sibling contract upgrades\\n    uint256[29] private _reservedSlots;\\n\\n    using Math for uint256;\\n    using SafeMath for uint256;\\n    using SafeDecimalMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    event Deposited(uint256 tranche, address account, uint256 amount);\\n    event Withdrawn(uint256 tranche, address account, uint256 amount);\\n\\n    uint256 private constant MAX_ITERATIONS = 500;\\n\\n    uint256 private constant REWARD_WEIGHT_A = 4;\\n    uint256 private constant REWARD_WEIGHT_B = 2;\\n    uint256 private constant REWARD_WEIGHT_M = 3;\\n    uint256 private constant MAX_BOOSTING_FACTOR = 3e18;\\n    uint256 private constant MAX_BOOSTING_FACTOR_MINUS_ONE = MAX_BOOSTING_FACTOR - 1e18;\\n\\n    /// @dev Maximum fraction of veCHESS that can be used to boost Token M.\\n    uint256 private constant MAX_BOOSTING_POWER_M = 0.5e18;\\n\\n    IFund public immutable fund;\\n    IERC20 private immutable tokenM;\\n    IERC20 private immutable tokenA;\\n    IERC20 private immutable tokenB;\\n\\n    /// @notice The Chess release schedule contract.\\n    IChessSchedule public immutable chessSchedule;\\n\\n    uint256 public immutable guardedLaunchStart;\\n\\n    address public immutable upgradeTool;\\n\\n    uint256 public immutable upgradeTimestamp;\\n\\n    uint256 private _rate;\\n\\n    /// @notice The controller contract.\\n    IChessController public immutable chessController;\\n\\n    /// @notice Quote asset for the exchange. Each exchange only handles one quote asset\\n    address public immutable quoteAssetAddress;\\n\\n    /// @dev Total amount of user shares, i.e. sum of all entries in `_availableBalances` and\\n    ///      `_lockedBalances`. Note that these values can be smaller than the amount of\\n    ///      share tokens held by this contract, because shares locked in unsettled trades\\n    ///      are not included in total supplies or any user's balance.\\n    uint256[TRANCHE_COUNT] private _totalSupplies;\\n\\n    /// @dev Rebalance version of `_totalSupplies`.\\n    uint256 private _totalSupplyVersion;\\n\\n    /// @dev Amount of shares that can be withdrawn or traded by each user.\\n    mapping(address => uint256[TRANCHE_COUNT]) private _availableBalances;\\n\\n    /// @dev Amount of shares that are locked in ask orders.\\n    mapping(address => uint256[TRANCHE_COUNT]) private _lockedBalances;\\n\\n    /// @dev Rebalance version mapping for `_availableBalances`.\\n    mapping(address => uint256) private _balanceVersions;\\n\\n    /// @dev 1e27 * \u222b(rate(t) / totalWeight(t) dt) from the latest rebalance till checkpoint.\\n    uint256 private _invTotalWeightIntegral;\\n\\n    /// @dev Final `_invTotalWeightIntegral` before each rebalance.\\n    ///      These values are accessed in a loop in `_userCheckpoint()` with bounds checking.\\n    ///      So we store them in a fixed-length array, in order to make compiler-generated\\n    ///      bounds checking on every access cheaper. The actual length of this array is stored in\\n    ///      `_historicalIntegralSize` and should be explicitly checked when necessary.\\n    uint256[65535] private _historicalIntegrals;\\n\\n    /// @dev Actual length of the `_historicalIntegrals` array, which always equals to the number of\\n    ///      historical rebalances after `checkpoint()` is called.\\n    uint256 private _historicalIntegralSize;\\n\\n    /// @dev Timestamp when checkpoint() is called.\\n    uint256 private _checkpointTimestamp;\\n\\n    /// @dev Snapshot of `_invTotalWeightIntegral` per user.\\n    mapping(address => uint256) private _userIntegrals;\\n\\n    /// @dev Mapping of account => claimable rewards.\\n    mapping(address => uint256) private _claimableRewards;\\n\\n    IVotingEscrow private immutable _votingEscrow;\\n    uint256 private _workingSupply;\\n    mapping(address => uint256) private _workingBalances;\\n    mapping(address => VESnapshot) private _veSnapshots;\\n\\n    constructor(\\n        address fund_,\\n        address chessSchedule_,\\n        address chessController_,\\n        address quoteAssetAddress_,\\n        uint256 guardedLaunchStart_,\\n        address votingEscrow_,\\n        address upgradeTool_\\n    ) public {\\n        fund = IFund(fund_);\\n        tokenM = IERC20(IFund(fund_).tokenM());\\n        tokenA = IERC20(IFund(fund_).tokenA());\\n        tokenB = IERC20(IFund(fund_).tokenB());\\n        chessSchedule = IChessSchedule(chessSchedule_);\\n        chessController = IChessController(chessController_);\\n        quoteAssetAddress = quoteAssetAddress_;\\n        guardedLaunchStart = guardedLaunchStart_;\\n        _votingEscrow = IVotingEscrow(votingEscrow_);\\n        upgradeTool = upgradeTool_;\\n        upgradeTimestamp = IUpgradeTool(upgradeTool_).upgradeTimestamp();\\n    }\\n\\n    function _initializeStaking() internal {\\n        require(_checkpointTimestamp == 0);\\n        _checkpointTimestamp = block.timestamp;\\n        _rate = IChessSchedule(chessSchedule).getRate(block.timestamp);\\n    }\\n\\n    function _initializeStakingV2(address pauser_) internal {\\n        _initializeManagedPausable(pauser_);\\n        // The contract was just upgraded from an old version without boosting\\n        _workingSupply = weightedBalance(\\n            _totalSupplies[TRANCHE_M],\\n            _totalSupplies[TRANCHE_A],\\n            _totalSupplies[TRANCHE_B]\\n        );\\n    }\\n\\n    /// @notice Return weight of given balance with respect to rewards.\\n    /// @param amountM Amount of Token M\\n    /// @param amountA Amount of Token A\\n    /// @param amountB Amount of Token B\\n    /// @return Rewarding weight of the balance\\n    function weightedBalance(\\n        uint256 amountM,\\n        uint256 amountA,\\n        uint256 amountB\\n    ) public pure returns (uint256) {\\n        return\\n            amountM.mul(REWARD_WEIGHT_M).add(amountA.mul(REWARD_WEIGHT_A)).add(\\n                amountB.mul(REWARD_WEIGHT_B)\\n            ) / REWARD_WEIGHT_M;\\n    }\\n\\n    function totalSupply(uint256 tranche) external view returns (uint256) {\\n        uint256 totalSupplyM = _totalSupplies[TRANCHE_M];\\n        uint256 totalSupplyA = _totalSupplies[TRANCHE_A];\\n        uint256 totalSupplyB = _totalSupplies[TRANCHE_B];\\n\\n        uint256 version = _totalSupplyVersion;\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        if (version < rebalanceSize) {\\n            (totalSupplyM, totalSupplyA, totalSupplyB) = _fundBatchRebalance(\\n                totalSupplyM,\\n                totalSupplyA,\\n                totalSupplyB,\\n                version,\\n                rebalanceSize\\n            );\\n        }\\n\\n        if (tranche == TRANCHE_M) {\\n            return totalSupplyM;\\n        } else if (tranche == TRANCHE_A) {\\n            return totalSupplyA;\\n        } else {\\n            return totalSupplyB;\\n        }\\n    }\\n\\n    function availableBalanceOf(uint256 tranche, address account) external view returns (uint256) {\\n        uint256 amountM = _availableBalances[account][TRANCHE_M];\\n        uint256 amountA = _availableBalances[account][TRANCHE_A];\\n        uint256 amountB = _availableBalances[account][TRANCHE_B];\\n\\n        if (tranche == TRANCHE_M) {\\n            if (amountM == 0 && amountA == 0 && amountB == 0) return 0;\\n        } else if (tranche == TRANCHE_A) {\\n            if (amountA == 0) return 0;\\n        } else {\\n            if (amountB == 0) return 0;\\n        }\\n\\n        uint256 version = _balanceVersions[account];\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        if (version < rebalanceSize) {\\n            (amountM, amountA, amountB) = _fundBatchRebalance(\\n                amountM,\\n                amountA,\\n                amountB,\\n                version,\\n                rebalanceSize\\n            );\\n        }\\n\\n        if (tranche == TRANCHE_M) {\\n            return amountM;\\n        } else if (tranche == TRANCHE_A) {\\n            return amountA;\\n        } else {\\n            return amountB;\\n        }\\n    }\\n\\n    function lockedBalanceOf(uint256 tranche, address account) external view returns (uint256) {\\n        uint256 amountM = _lockedBalances[account][TRANCHE_M];\\n        uint256 amountA = _lockedBalances[account][TRANCHE_A];\\n        uint256 amountB = _lockedBalances[account][TRANCHE_B];\\n\\n        if (tranche == TRANCHE_M) {\\n            if (amountM == 0 && amountA == 0 && amountB == 0) return 0;\\n        } else if (tranche == TRANCHE_A) {\\n            if (amountA == 0) return 0;\\n        } else {\\n            if (amountB == 0) return 0;\\n        }\\n\\n        uint256 version = _balanceVersions[account];\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        if (version < rebalanceSize) {\\n            (amountM, amountA, amountB) = _fundBatchRebalance(\\n                amountM,\\n                amountA,\\n                amountB,\\n                version,\\n                rebalanceSize\\n            );\\n        }\\n\\n        if (tranche == TRANCHE_M) {\\n            return amountM;\\n        } else if (tranche == TRANCHE_A) {\\n            return amountA;\\n        } else {\\n            return amountB;\\n        }\\n    }\\n\\n    function balanceVersion(address account) external view returns (uint256) {\\n        return _balanceVersions[account];\\n    }\\n\\n    function workingSupply() external view returns (uint256) {\\n        uint256 version = _totalSupplyVersion;\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        if (version < rebalanceSize) {\\n            (uint256 totalSupplyM, uint256 totalSupplyA, uint256 totalSupplyB) =\\n                _fundBatchRebalance(\\n                    _totalSupplies[TRANCHE_M],\\n                    _totalSupplies[TRANCHE_A],\\n                    _totalSupplies[TRANCHE_B],\\n                    version,\\n                    rebalanceSize\\n                );\\n            return weightedBalance(totalSupplyM, totalSupplyA, totalSupplyB);\\n        } else {\\n            return _workingSupply;\\n        }\\n    }\\n\\n    function workingBalanceOf(address account) external view returns (uint256) {\\n        uint256 version = _balanceVersions[account];\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        uint256 workingBalance = _workingBalances[account]; // gas saver\\n        if (version < rebalanceSize || workingBalance == 0) {\\n            uint256[TRANCHE_COUNT] storage available = _availableBalances[account];\\n            uint256[TRANCHE_COUNT] storage locked = _lockedBalances[account];\\n            uint256 amountM = available[TRANCHE_M].add(locked[TRANCHE_M]);\\n            uint256 amountA = available[TRANCHE_A].add(locked[TRANCHE_A]);\\n            uint256 amountB = available[TRANCHE_B].add(locked[TRANCHE_B]);\\n            if (version < rebalanceSize) {\\n                (amountM, amountA, amountB) = _fundBatchRebalance(\\n                    amountM,\\n                    amountA,\\n                    amountB,\\n                    version,\\n                    rebalanceSize\\n                );\\n            }\\n            return weightedBalance(amountM, amountA, amountB);\\n        } else {\\n            return workingBalance;\\n        }\\n    }\\n\\n    function veSnapshotOf(address account) external view returns (VESnapshot memory) {\\n        return _veSnapshots[account];\\n    }\\n\\n    function _fundRebalanceSize() internal view returns (uint256) {\\n        return fund.getRebalanceSize();\\n    }\\n\\n    function _fundDoRebalance(\\n        uint256 amountM,\\n        uint256 amountA,\\n        uint256 amountB,\\n        uint256 index\\n    )\\n        internal\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        return fund.doRebalance(amountM, amountA, amountB, index);\\n    }\\n\\n    function _fundBatchRebalance(\\n        uint256 amountM,\\n        uint256 amountA,\\n        uint256 amountB,\\n        uint256 fromIndex,\\n        uint256 toIndex\\n    )\\n        internal\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        return fund.batchRebalance(amountM, amountA, amountB, fromIndex, toIndex);\\n    }\\n\\n    /// @dev Deposit to get rewards\\n    /// @param tranche Tranche of the share\\n    /// @param amount The amount to deposit\\n    function deposit(uint256 tranche, uint256 amount) public whenNotPaused beforeProtocolUpgrade {\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(msg.sender, rebalanceSize);\\n        _availableBalances[msg.sender][tranche] = _availableBalances[msg.sender][tranche].add(\\n            amount\\n        );\\n        _totalSupplies[tranche] = _totalSupplies[tranche].add(amount);\\n        _updateWorkingBalance(msg.sender);\\n\\n        if (tranche == TRANCHE_M) {\\n            tokenM.safeTransferFrom(msg.sender, address(this), amount);\\n        } else if (tranche == TRANCHE_A) {\\n            tokenA.safeTransferFrom(msg.sender, address(this), amount);\\n        } else {\\n            tokenB.safeTransferFrom(msg.sender, address(this), amount);\\n        }\\n\\n        emit Deposited(tranche, msg.sender, amount);\\n    }\\n\\n    /// @dev Claim settled Token M from the primary market and deposit to get rewards\\n    /// @param primaryMarket The primary market to claim shares from\\n    function claimAndDeposit(address primaryMarket) external {\\n        (uint256 createdShares, ) = IPrimaryMarketV2(primaryMarket).claim(msg.sender);\\n        deposit(TRANCHE_M, createdShares);\\n    }\\n\\n    function claimAndUnwrapAndDeposit(address primaryMarket) external {\\n        (uint256 createdShares, ) = IPrimaryMarketV2(primaryMarket).claimAndUnwrap(msg.sender);\\n        deposit(TRANCHE_M, createdShares);\\n    }\\n\\n    /// @dev Withdraw\\n    /// @param tranche Tranche of the share\\n    /// @param amount The amount to deposit\\n    function withdraw(uint256 tranche, uint256 amount) external whenNotPaused {\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(msg.sender, rebalanceSize);\\n        _availableBalances[msg.sender][tranche] = _availableBalances[msg.sender][tranche].sub(\\n            amount,\\n            \\\"Insufficient balance to withdraw\\\"\\n        );\\n        _totalSupplies[tranche] = _totalSupplies[tranche].sub(amount);\\n        _updateWorkingBalance(msg.sender);\\n\\n        if (tranche == TRANCHE_M) {\\n            tokenM.safeTransfer(msg.sender, amount);\\n        } else if (tranche == TRANCHE_A) {\\n            tokenA.safeTransfer(msg.sender, amount);\\n        } else {\\n            tokenB.safeTransfer(msg.sender, amount);\\n        }\\n\\n        emit Withdrawn(tranche, msg.sender, amount);\\n    }\\n\\n    /// @notice Transform share balance to a given rebalance version, or to the latest version\\n    ///         if `targetVersion` is zero.\\n    /// @param account Account of the balance to rebalance\\n    /// @param targetVersion The target rebalance version, or zero for the latest version\\n    function refreshBalance(address account, uint256 targetVersion) external {\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        if (targetVersion == 0) {\\n            targetVersion = rebalanceSize;\\n        } else {\\n            require(targetVersion <= rebalanceSize, \\\"Target version out of bound\\\");\\n        }\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(account, targetVersion);\\n    }\\n\\n    /// @notice Return claimable rewards of an account till now.\\n    ///\\n    ///         This function should be call as a \\\"view\\\" function off-chain to get\\n    ///         the return value, e.g. using `contract.claimableRewards.call(account)` in web3\\n    ///         or `contract.callStatic.claimableRewards(account)` in ethers.js.\\n    /// @param account Address of an account\\n    /// @return Amount of claimable rewards\\n    function claimableRewards(address account) external returns (uint256) {\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(account, rebalanceSize);\\n        return _claimableRewards[account];\\n    }\\n\\n    /// @notice Claim the rewards for an account.\\n    /// @param account Account to claim its rewards\\n    function claimRewards(address account) external whenNotPaused {\\n        require(\\n            block.timestamp >= guardedLaunchStart + 15 days,\\n            \\\"Cannot claim during guarded launch\\\"\\n        );\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(account, rebalanceSize);\\n        _claim(account);\\n    }\\n\\n    /// @notice Synchronize an account's locked Chess with `VotingEscrow`\\n    ///         and update its working balance.\\n    /// @param account Address of the synchronized account\\n    function syncWithVotingEscrow(address account) external {\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(account, rebalanceSize);\\n\\n        VESnapshot storage veSnapshot = _veSnapshots[account];\\n        IVotingEscrow.LockedBalance memory newLocked = _votingEscrow.getLockedBalance(account);\\n        if (\\n            newLocked.amount != veSnapshot.veLocked.amount ||\\n            newLocked.unlockTime != veSnapshot.veLocked.unlockTime ||\\n            newLocked.unlockTime < block.timestamp\\n        ) {\\n            veSnapshot.veLocked.amount = newLocked.amount;\\n            veSnapshot.veLocked.unlockTime = newLocked.unlockTime;\\n            veSnapshot.veProportion = _votingEscrow.balanceOf(account).divideDecimal(\\n                _votingEscrow.totalSupply()\\n            );\\n        }\\n\\n        _updateWorkingBalance(account);\\n    }\\n\\n    modifier beforeProtocolUpgrade() {\\n        require(block.timestamp < upgradeTimestamp, \\\"Closed after upgrade\\\");\\n        _;\\n    }\\n\\n    /// @notice Upgrade to Tranchess V2. This can only be called from the upgrade tool.\\n    function protocolUpgrade(address account)\\n        external\\n        returns (\\n            uint256 amountM,\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 claimedRewards\\n        )\\n    {\\n        require(msg.sender == upgradeTool, \\\"Only upgrade tool\\\");\\n        require(block.timestamp >= upgradeTimestamp, \\\"Not ready for upgrade\\\");\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(account, rebalanceSize);\\n\\n        uint256[TRANCHE_COUNT] storage available = _availableBalances[account];\\n        uint256[TRANCHE_COUNT] storage locked = _lockedBalances[account];\\n        // These amounts of tokens will be burnt by the upgrade tool.\\n        amountM = available[TRANCHE_M].add(locked[TRANCHE_M]);\\n        amountA = available[TRANCHE_A].add(locked[TRANCHE_A]);\\n        amountB = available[TRANCHE_B].add(locked[TRANCHE_B]);\\n        if (amountM > 0) {\\n            available[TRANCHE_M] = 0;\\n            locked[TRANCHE_M] = 0;\\n            _totalSupplies[TRANCHE_M] = _totalSupplies[TRANCHE_M].sub(amountM);\\n        }\\n        if (amountA > 0) {\\n            available[TRANCHE_A] = 0;\\n            locked[TRANCHE_A] = 0;\\n            _totalSupplies[TRANCHE_A] = _totalSupplies[TRANCHE_A].sub(amountA);\\n        }\\n        if (amountB > 0) {\\n            available[TRANCHE_B] = 0;\\n            locked[TRANCHE_B] = 0;\\n            _totalSupplies[TRANCHE_B] = _totalSupplies[TRANCHE_B].sub(amountB);\\n        }\\n        _updateWorkingBalance(account);\\n\\n        claimedRewards = _claim(account);\\n    }\\n\\n    /// @dev Transfer shares from the sender to the contract internally\\n    /// @param tranche Tranche of the share\\n    /// @param sender Sender address\\n    /// @param amount The amount to transfer\\n    function _tradeAvailable(\\n        uint256 tranche,\\n        address sender,\\n        uint256 amount\\n    ) internal {\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(sender, rebalanceSize);\\n        _availableBalances[sender][tranche] = _availableBalances[sender][tranche].sub(amount);\\n        _totalSupplies[tranche] = _totalSupplies[tranche].sub(amount);\\n        _updateWorkingBalance(sender);\\n    }\\n\\n    function _rebalanceAndClearTrade(\\n        address account,\\n        uint256 amountM,\\n        uint256 amountA,\\n        uint256 amountB,\\n        uint256 amountVersion\\n    )\\n        internal\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(account, rebalanceSize);\\n        if (amountVersion < rebalanceSize) {\\n            (amountM, amountA, amountB) = _fundBatchRebalance(\\n                amountM,\\n                amountA,\\n                amountB,\\n                amountVersion,\\n                rebalanceSize\\n            );\\n        }\\n        uint256[TRANCHE_COUNT] storage available = _availableBalances[account];\\n        if (amountM > 0) {\\n            available[TRANCHE_M] = available[TRANCHE_M].add(amountM);\\n            _totalSupplies[TRANCHE_M] = _totalSupplies[TRANCHE_M].add(amountM);\\n        }\\n        if (amountA > 0) {\\n            available[TRANCHE_A] = available[TRANCHE_A].add(amountA);\\n            _totalSupplies[TRANCHE_A] = _totalSupplies[TRANCHE_A].add(amountA);\\n        }\\n        if (amountB > 0) {\\n            available[TRANCHE_B] = available[TRANCHE_B].add(amountB);\\n            _totalSupplies[TRANCHE_B] = _totalSupplies[TRANCHE_B].add(amountB);\\n        }\\n        _updateWorkingBalance(account);\\n\\n        return (amountM, amountA, amountB);\\n    }\\n\\n    function _lock(\\n        uint256 tranche,\\n        address account,\\n        uint256 amount\\n    ) internal {\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(account, rebalanceSize);\\n        _availableBalances[account][tranche] = _availableBalances[account][tranche].sub(\\n            amount,\\n            \\\"Insufficient balance to lock\\\"\\n        );\\n        _lockedBalances[account][tranche] = _lockedBalances[account][tranche].add(amount);\\n    }\\n\\n    function _rebalanceAndUnlock(\\n        address account,\\n        uint256 amountM,\\n        uint256 amountA,\\n        uint256 amountB,\\n        uint256 amountVersion\\n    ) internal {\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(account, rebalanceSize);\\n        if (amountVersion < rebalanceSize) {\\n            (amountM, amountA, amountB) = _fundBatchRebalance(\\n                amountM,\\n                amountA,\\n                amountB,\\n                amountVersion,\\n                rebalanceSize\\n            );\\n        }\\n        uint256[TRANCHE_COUNT] storage available = _availableBalances[account];\\n        uint256[TRANCHE_COUNT] storage locked = _lockedBalances[account];\\n        if (amountM > 0) {\\n            available[TRANCHE_M] = available[TRANCHE_M].add(amountM);\\n            locked[TRANCHE_M] = locked[TRANCHE_M].sub(amountM);\\n        }\\n        if (amountA > 0) {\\n            available[TRANCHE_A] = available[TRANCHE_A].add(amountA);\\n            locked[TRANCHE_A] = locked[TRANCHE_A].sub(amountA);\\n        }\\n        if (amountB > 0) {\\n            available[TRANCHE_B] = available[TRANCHE_B].add(amountB);\\n            locked[TRANCHE_B] = locked[TRANCHE_B].sub(amountB);\\n        }\\n    }\\n\\n    function _tradeLocked(\\n        uint256 tranche,\\n        address account,\\n        uint256 amount\\n    ) internal {\\n        uint256 rebalanceSize = _fundRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(account, rebalanceSize);\\n        _lockedBalances[account][tranche] = _lockedBalances[account][tranche].sub(amount);\\n        _totalSupplies[tranche] = _totalSupplies[tranche].sub(amount);\\n        _updateWorkingBalance(account);\\n    }\\n\\n    /// @dev Transfer claimable rewards to an account. Rewards since the last user checkpoint\\n    ///      is not included. This function should always be called after `_userCheckpoint()`,\\n    ///      in order for the user to get all rewards till now.\\n    /// @param account Address of the account\\n    function _claim(address account) internal returns (uint256 claimableReward) {\\n        claimableReward = _claimableRewards[account];\\n        _claimableRewards[account] = 0;\\n        chessSchedule.mint(account, claimableReward);\\n    }\\n\\n    /// @dev Transform total supplies to the latest rebalance version and make a global reward checkpoint.\\n    /// @param rebalanceSize The number of existing rebalances. It must be the same as\\n    ///                       `fund.getRebalanceSize()`.\\n    function _checkpoint(uint256 rebalanceSize) private {\\n        uint256 timestamp = _checkpointTimestamp;\\n        if (timestamp >= block.timestamp) {\\n            return;\\n        }\\n\\n        uint256 integral = _invTotalWeightIntegral;\\n        uint256 endWeek = _endOfWeek(timestamp);\\n        uint256 weeklyPercentage =\\n            chessController.getFundRelativeWeight(address(fund), endWeek - 1 weeks);\\n        uint256 version = _totalSupplyVersion;\\n        uint256 rebalanceTimestamp;\\n        if (version < rebalanceSize) {\\n            rebalanceTimestamp = fund.getRebalanceTimestamp(version);\\n        } else {\\n            rebalanceTimestamp = type(uint256).max;\\n        }\\n        uint256 rate = _rate;\\n        uint256 totalSupplyM = _totalSupplies[TRANCHE_M];\\n        uint256 totalSupplyA = _totalSupplies[TRANCHE_A];\\n        uint256 totalSupplyB = _totalSupplies[TRANCHE_B];\\n        uint256 weight = _workingSupply;\\n        uint256 timestamp_ = timestamp; // avoid stack too deep\\n\\n        for (uint256 i = 0; i < MAX_ITERATIONS && timestamp_ < block.timestamp; i++) {\\n            uint256 endTimestamp = rebalanceTimestamp.min(endWeek).min(block.timestamp);\\n\\n            if (weight > 0) {\\n                integral = integral.add(\\n                    rate\\n                        .mul(endTimestamp.sub(timestamp_))\\n                        .multiplyDecimal(weeklyPercentage)\\n                        .divideDecimalPrecise(weight)\\n                );\\n            }\\n\\n            if (endTimestamp == rebalanceTimestamp) {\\n                uint256 oldSize = _historicalIntegralSize;\\n                _historicalIntegrals[oldSize] = integral;\\n                _historicalIntegralSize = oldSize + 1;\\n\\n                integral = 0;\\n                (totalSupplyM, totalSupplyA, totalSupplyB) = _fundDoRebalance(\\n                    totalSupplyM,\\n                    totalSupplyA,\\n                    totalSupplyB,\\n                    version\\n                );\\n\\n                version++;\\n                // Reset total weight boosting after the first rebalance\\n                weight = weightedBalance(totalSupplyM, totalSupplyA, totalSupplyB);\\n\\n                if (version < rebalanceSize) {\\n                    rebalanceTimestamp = fund.getRebalanceTimestamp(version);\\n                } else {\\n                    rebalanceTimestamp = type(uint256).max;\\n                }\\n            }\\n            if (endTimestamp == endWeek) {\\n                rate = chessSchedule.getRate(endWeek);\\n                weeklyPercentage = chessController.getFundRelativeWeight(address(fund), endWeek);\\n                endWeek += 1 weeks;\\n            }\\n\\n            timestamp_ = endTimestamp;\\n        }\\n\\n        _checkpointTimestamp = block.timestamp;\\n        _invTotalWeightIntegral = integral;\\n        if (_rate != rate) {\\n            _rate = rate;\\n        }\\n        if (_totalSupplyVersion != rebalanceSize) {\\n            _totalSupplies[TRANCHE_M] = totalSupplyM;\\n            _totalSupplies[TRANCHE_A] = totalSupplyA;\\n            _totalSupplies[TRANCHE_B] = totalSupplyB;\\n            _totalSupplyVersion = rebalanceSize;\\n            // Reset total working weight before any boosting if rebalance ever triggered\\n            _workingSupply = weight;\\n        }\\n    }\\n\\n    /// @dev Transform a user's balance to a given rebalance version and update this user's rewards.\\n    ///\\n    ///      In most cases, the target version is the latest version and this function cumulates\\n    ///      rewards till now. When this function is called from `refreshBalance()`,\\n    ///      `targetVersion` can be an older version, in which case rewards are cumulated till\\n    ///      the end of that version (i.e. timestamp of the transaction triggering the rebalance\\n    ///      with index `targetVersion`).\\n    ///\\n    ///      This function should always be called after `_checkpoint()` is called, so that\\n    ///      the global reward checkpoint is guarenteed up to date.\\n    /// @param account Account to update\\n    /// @param targetVersion The target rebalance version\\n    function _userCheckpoint(address account, uint256 targetVersion) private {\\n        uint256 oldVersion = _balanceVersions[account];\\n        if (oldVersion > targetVersion) {\\n            return;\\n        }\\n        uint256 userIntegral = _userIntegrals[account];\\n        uint256 integral;\\n        // This scope is to avoid the \\\"stack too deep\\\" error.\\n        {\\n            // We assume that this function is always called immediately after `_checkpoint()`,\\n            // which guarantees that `_historicalIntegralSize` equals to the number of historical\\n            // rebalances.\\n            uint256 rebalanceSize = _historicalIntegralSize;\\n            integral = targetVersion == rebalanceSize\\n                ? _invTotalWeightIntegral\\n                : _historicalIntegrals[targetVersion];\\n        }\\n        if (userIntegral == integral && oldVersion == targetVersion) {\\n            // Return immediately when the user's rewards have already been updated to\\n            // the target version.\\n            return;\\n        }\\n\\n        uint256 rewards = _claimableRewards[account];\\n        uint256[TRANCHE_COUNT] storage available = _availableBalances[account];\\n        uint256[TRANCHE_COUNT] storage locked = _lockedBalances[account];\\n        uint256 weight = _workingBalances[account];\\n        if (weight == 0) {\\n            // Loading available and locked is repeated to avoid \\\"stake too deep\\\" error.\\n            weight = weightedBalance(\\n                available[TRANCHE_M].add(locked[TRANCHE_M]),\\n                available[TRANCHE_A].add(locked[TRANCHE_A]),\\n                available[TRANCHE_B].add(locked[TRANCHE_B])\\n            );\\n            if (weight > 0) {\\n                // The contract was just upgraded from an old version without boosting\\n                _workingBalances[account] = weight;\\n            }\\n        }\\n        uint256 availableM = available[TRANCHE_M];\\n        uint256 availableA = available[TRANCHE_A];\\n        uint256 availableB = available[TRANCHE_B];\\n        uint256 lockedM = locked[TRANCHE_M];\\n        uint256 lockedA = locked[TRANCHE_A];\\n        uint256 lockedB = locked[TRANCHE_B];\\n        for (uint256 i = oldVersion; i < targetVersion; i++) {\\n            rewards = rewards.add(\\n                weight.multiplyDecimalPrecise(_historicalIntegrals[i].sub(userIntegral))\\n            );\\n            if (availableM != 0 || availableA != 0 || availableB != 0) {\\n                (availableM, availableA, availableB) = _fundDoRebalance(\\n                    availableM,\\n                    availableA,\\n                    availableB,\\n                    i\\n                );\\n            }\\n            if (lockedM != 0 || lockedA != 0 || lockedB != 0) {\\n                (lockedM, lockedA, lockedB) = _fundDoRebalance(lockedM, lockedA, lockedB, i);\\n            }\\n            userIntegral = 0;\\n\\n            // Reset per-user weight boosting after the first rebalance\\n            weight = weightedBalance(\\n                availableM.add(lockedM),\\n                availableA.add(lockedA),\\n                availableB.add(lockedB)\\n            );\\n        }\\n        rewards = rewards.add(weight.multiplyDecimalPrecise(integral.sub(userIntegral)));\\n        address account_ = account; // Fix the \\\"stack too deep\\\" error\\n        _claimableRewards[account_] = rewards;\\n        _userIntegrals[account_] = integral;\\n\\n        if (oldVersion < targetVersion) {\\n            if (available[TRANCHE_M] != availableM) {\\n                available[TRANCHE_M] = availableM;\\n            }\\n            if (available[TRANCHE_A] != availableA) {\\n                available[TRANCHE_A] = availableA;\\n            }\\n            if (available[TRANCHE_B] != availableB) {\\n                available[TRANCHE_B] = availableB;\\n            }\\n            if (locked[TRANCHE_M] != lockedM) {\\n                locked[TRANCHE_M] = lockedM;\\n            }\\n            if (locked[TRANCHE_A] != lockedA) {\\n                locked[TRANCHE_A] = lockedA;\\n            }\\n            if (locked[TRANCHE_B] != lockedB) {\\n                locked[TRANCHE_B] = lockedB;\\n            }\\n            _balanceVersions[account_] = targetVersion;\\n            _workingBalances[account_] = weight;\\n        }\\n    }\\n\\n    /// @dev Calculate working balance, which depends on the amount of staked tokens and veCHESS.\\n    ///      Before this function is called, both `_checkpoint()` and `_userCheckpoint(account)`\\n    ///      should be called to update `_workingSupply` and `_workingBalances[account]` to\\n    ///      the latest rebalance version.\\n    /// @param account User address\\n    function _updateWorkingBalance(address account) private {\\n        uint256 weightedSupply =\\n            weightedBalance(\\n                _totalSupplies[TRANCHE_M],\\n                _totalSupplies[TRANCHE_A],\\n                _totalSupplies[TRANCHE_B]\\n            );\\n        uint256[TRANCHE_COUNT] storage available = _availableBalances[account];\\n        uint256[TRANCHE_COUNT] storage locked = _lockedBalances[account];\\n        // Assume weightedBalance(x, 0, 0) always equal to x\\n        uint256 weightedM = available[TRANCHE_M].add(locked[TRANCHE_M]);\\n        uint256 weightedAB =\\n            weightedBalance(\\n                0,\\n                available[TRANCHE_A].add(locked[TRANCHE_A]),\\n                available[TRANCHE_B].add(locked[TRANCHE_B])\\n            );\\n\\n        uint256 newWorkingBalance = weightedAB.add(weightedM);\\n        uint256 veProportion = _veSnapshots[account].veProportion;\\n        if (veProportion > 0 && _veSnapshots[account].veLocked.unlockTime > block.timestamp) {\\n            uint256 boostingPower = weightedSupply.multiplyDecimal(veProportion);\\n            if (boostingPower <= weightedAB) {\\n                newWorkingBalance = newWorkingBalance.add(\\n                    boostingPower.multiplyDecimal(MAX_BOOSTING_FACTOR_MINUS_ONE)\\n                );\\n            } else {\\n                uint256 boostingPowerM =\\n                    (boostingPower - weightedAB)\\n                        .min(boostingPower.multiplyDecimal(MAX_BOOSTING_POWER_M))\\n                        .min(weightedM);\\n                newWorkingBalance = newWorkingBalance.add(\\n                    weightedAB.add(boostingPowerM).multiplyDecimal(MAX_BOOSTING_FACTOR_MINUS_ONE)\\n                );\\n            }\\n        }\\n\\n        _workingSupply = _workingSupply.sub(_workingBalances[account]).add(newWorkingBalance);\\n        _workingBalances[account] = newWorkingBalance;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/upgrade/BatchUpgradeTool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"../interfaces/IPrimaryMarketV2.sol\\\";\\nimport \\\"../fund/PrimaryMarket.sol\\\";\\nimport \\\"../exchange/ExchangeV3.sol\\\";\\nimport \\\"./UpgradeTool.sol\\\";\\n\\ncontract BatchUpgradeTool {\\n    using SafeMath for uint256;\\n\\n    /// @dev `encodedData` consists of two types of data:\\n    ///      - unsettled epochs\\n    ///      - bid orders\\n    //       Unsettled epochs are encoded as follows:\\n    //       Bit  255       | 0 (constant)\\n    //       Bit [224, 228) | exchangeIndex\\n    //       Bit 192        | 0 (maker), 1(taker)\\n    //       Bit [0, 64)    | epoch\\n    //       Bid orders are encoded as follows:\\n    //       Bit  255       | 1 (constant)\\n    //       Bit [224, 228) | exchangeIndex\\n    //       Bit [76, 80)   | version\\n    //       Bit [72, 76)   | tranche\\n    //       Bit [64, 72)   | pdLevel\\n    //       Bit [0, 64)    | index\\n    /// @return tokenAmounts An array of (upgradeTools.length * 3) values, containing the amount\\n    ///         of three tokens upgraded for each Fund\\n    /// @return underlyingAmounts An array of (oldPrimaryMarkets.length + oldWrappedPrimaryMarkets.length)\\n    ///         values, containing the amount of underlying tokens claimed from each primary market\\n    /// @return totalQuoteAmount Total amount of quote tokens returned to the account.\\n    /// @return totalRewards Total amount of CHESS claimed by the account.\\n    function batchProtocolUpgrade(\\n        address[] calldata oldPrimaryMarkets,\\n        address[] calldata oldWrappedPrimaryMarkets,\\n        address[] calldata upgradeTools,\\n        uint256[] calldata encodedData,\\n        address account\\n    )\\n        external\\n        returns (\\n            uint256[] memory tokenAmounts,\\n            uint256[] memory underlyingAmounts,\\n            uint256 totalQuoteAmount,\\n            uint256 totalRewards\\n        )\\n    {\\n        underlyingAmounts = new uint256[](\\n            oldPrimaryMarkets.length + oldWrappedPrimaryMarkets.length\\n        );\\n        for (uint256 i = 0; i < oldPrimaryMarkets.length; i++) {\\n            (, underlyingAmounts[i]) = IPrimaryMarket(oldPrimaryMarkets[i]).claim(account);\\n        }\\n        for (uint256 i = 0; i < oldWrappedPrimaryMarkets.length; i++) {\\n            (, underlyingAmounts[i + oldPrimaryMarkets.length]) = IPrimaryMarketV2(\\n                oldWrappedPrimaryMarkets[i]\\n            )\\n                .claimAndUnwrap(account);\\n        }\\n\\n        for (uint256 i = 0; i < encodedData.length; i++) {\\n            uint256 encodedDatum = encodedData[i];\\n            uint256 exchangeIndex = (encodedDatum >> 224) & 0xF;\\n            ExchangeV3 exchange =\\n                ExchangeV3(address(UpgradeTool(upgradeTools[exchangeIndex]).oldExchange()));\\n            uint256 quoteAmount;\\n            if ((encodedDatum >> 255) == 0) {\\n                // unsettled epochs\\n                uint256 epoch = encodedDatum & 0xFFFFFFFFFFFFFFFF;\\n                (, , , quoteAmount) = ((encodedDatum >> 192) & 0x1 == 0)\\n                    ? exchange.settleMaker(account, epoch)\\n                    : exchange.settleTaker(account, epoch);\\n            } else {\\n                // bid orders\\n                uint256 version = (encodedDatum >> 76) & 0xF;\\n                uint256 tranche = (encodedDatum >> 72) & 0xF;\\n                uint256 pdLevel = (encodedDatum >> 64) & 0xFF;\\n                uint256 index = encodedDatum & 0xFFFFFFFFFFFFFFFF;\\n                quoteAmount = exchange.cancelBid(version, tranche, pdLevel, index);\\n            }\\n            totalQuoteAmount = totalQuoteAmount.add(quoteAmount);\\n        }\\n\\n        tokenAmounts = new uint256[](upgradeTools.length * 3);\\n        for (uint256 i = 0; i < upgradeTools.length; i++) {\\n            UpgradeTool tool = UpgradeTool(upgradeTools[i]);\\n            if (address(tool) == address(0)) {\\n                continue;\\n            }\\n            uint256 claimedRewards;\\n            (\\n                tokenAmounts[i * 3],\\n                tokenAmounts[i * 3 + 1],\\n                tokenAmounts[i * 3 + 2],\\n                claimedRewards\\n            ) = tool.protocolUpgrade(account);\\n            totalRewards = totalRewards.add(claimedRewards);\\n        }\\n    }\\n\\n    /// @notice Same as `batchProtocolUpgrade` but returns minimal parameters that should be used\\n    ///         to call `batchProtocolUpgrade`.\\n    function batchProtocolUpgradeParameters(\\n        address[] memory oldPrimaryMarkets,\\n        address[] memory oldWrappedPrimaryMarkets,\\n        address[] memory upgradeTools,\\n        uint256[] memory encodedData,\\n        address account\\n    )\\n        external\\n        returns (\\n            address[] memory,\\n            address[] memory,\\n            address[] memory,\\n            uint256[] memory\\n        )\\n    {\\n        bool[] memory requiredTools = new bool[](upgradeTools.length);\\n        _filterPrimaryMarkets(1, oldPrimaryMarkets, upgradeTools, requiredTools, account);\\n        _filterPrimaryMarkets(2, oldWrappedPrimaryMarkets, upgradeTools, requiredTools, account);\\n        _filterEncodedData(encodedData, upgradeTools, requiredTools, account);\\n        _filterUpgradeTools(upgradeTools, requiredTools, account);\\n        return (oldPrimaryMarkets, oldWrappedPrimaryMarkets, upgradeTools, encodedData);\\n    }\\n\\n    function _filterPrimaryMarkets(\\n        uint256 fundVersion,\\n        address[] memory primaryMarkets,\\n        address[] memory upgradeTools,\\n        bool[] memory requiredTools,\\n        address account\\n    ) private {\\n        for (uint256 i = 0; i < primaryMarkets.length; i++) {\\n            (uint256 shares, uint256 underlying) =\\n                fundVersion == 1\\n                    ? IPrimaryMarket(primaryMarkets[i]).claim(account)\\n                    : IPrimaryMarketV2(primaryMarkets[i]).claimAndUnwrap(account);\\n            if (shares | underlying == 0) {\\n                primaryMarkets[i] = address(0);\\n            } else if (shares != 0) {\\n                address tokenUnderlying = PrimaryMarket(primaryMarkets[i]).fund().tokenUnderlying();\\n                for (uint256 j = 0; j < upgradeTools.length; j++) {\\n                    if (\\n                        address(UpgradeTool(upgradeTools[j]).tokenUnderlying()) == tokenUnderlying\\n                    ) {\\n                        requiredTools[j] = true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        _packAddressArray(primaryMarkets);\\n    }\\n\\n    function _filterEncodedData(\\n        uint256[] memory encodedData,\\n        address[] memory upgradeTools,\\n        bool[] memory requiredTools,\\n        address account\\n    ) private {\\n        for (uint256 i = 0; i < encodedData.length; i++) {\\n            uint256 encodedDatum = encodedData[i];\\n            uint256 exchangeIndex = (encodedDatum >> 224) & 0xF;\\n            ExchangeV3 exchange =\\n                ExchangeV3(address(UpgradeTool(upgradeTools[exchangeIndex]).oldExchange()));\\n            if ((encodedDatum >> 255) == 0) {\\n                // unsettled epochs\\n                uint256 epoch = encodedDatum & 0xFFFFFFFFFFFFFFFF;\\n                (uint256 amountM, uint256 amountA, uint256 amountB, uint256 quoteAmount) =\\n                    ((encodedDatum >> 192) & 0x1 == 0)\\n                        ? exchange.settleMaker(account, epoch)\\n                        : exchange.settleTaker(account, epoch);\\n                if (amountM | amountA | amountB | quoteAmount == 0) {\\n                    encodedData[i] = 0;\\n                } else {\\n                    requiredTools[exchangeIndex] = true;\\n                }\\n            } else {\\n                // bid orders\\n                uint256 version = (encodedDatum >> 76) & 0xF;\\n                uint256 tranche = (encodedDatum >> 72) & 0xF;\\n                uint256 pdLevel = (encodedDatum >> 64) & 0xFF;\\n                uint256 index = encodedDatum & 0xFFFFFFFFFFFFFFFF;\\n                (address maker, , ) = exchange.getBidOrder(version, tranche, pdLevel, index);\\n                if (maker != account) {\\n                    encodedData[i] = 0;\\n                } else {\\n                    exchange.cancelBid(version, tranche, pdLevel, index);\\n                    requiredTools[exchangeIndex] = true;\\n                }\\n            }\\n        }\\n        _packUintArray(encodedData);\\n    }\\n\\n    function _filterUpgradeTools(\\n        address[] memory upgradeTools,\\n        bool[] memory requiredTools,\\n        address account\\n    ) private {\\n        for (uint256 i = 0; i < upgradeTools.length; i++) {\\n            UpgradeTool tool = UpgradeTool(upgradeTools[i]);\\n            (uint256 r1, uint256 r2, uint256 r3, uint256 r4) = tool.protocolUpgrade(account);\\n            if (r1 | r2 | r3 | r4 == 0 && !requiredTools[i]) {\\n                upgradeTools[i] = address(0);\\n            }\\n        }\\n        // Do not pack upgradeTools because encodedData has references to it\\n    }\\n\\n    function _packAddressArray(address[] memory array) private pure {\\n        uint256 newLength = 0;\\n        for (uint256 i = 0; i < array.length; i++) {\\n            if (array[i] != address(0)) {\\n                array[newLength] = array[i];\\n                newLength += 1;\\n            }\\n        }\\n        assembly {\\n            mstore(array, newLength)\\n        }\\n    }\\n\\n    function _packUintArray(uint256[] memory array) private pure {\\n        uint256 newLength = 0;\\n        for (uint256 i = 0; i < array.length; i++) {\\n            if (array[i] != 0) {\\n                array[newLength] = array[i];\\n                newLength += 1;\\n            }\\n        }\\n        assembly {\\n            mstore(array, newLength)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/governance/ChessControllerV5.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"../utils/CoreUtility.sol\\\";\\nimport \\\"../utils/SafeDecimalMath.sol\\\";\\nimport \\\"../interfaces/IChessController.sol\\\";\\nimport \\\"../interfaces/IControllerBallot.sol\\\";\\n\\ncontract ChessControllerV5 is IChessController, CoreUtility {\\n    /// @dev Reserved storage slots for future base contract upgrades\\n    uint256[192] private _reservedSlots;\\n\\n    using Math for uint256;\\n    using SafeMath for uint256;\\n    using SafeDecimalMath for uint256;\\n\\n    event WeightUpdated(address indexed fund, uint256 indexed timestamp, uint256 weight);\\n\\n    address public immutable fund0;\\n    uint256 public immutable guardedLaunchStart;\\n    address public immutable controllerBallot;\\n\\n    mapping(uint256 => mapping(address => uint256)) public weights;\\n\\n    /// @notice Start timestamp of the last trading week that has weights updated.\\n    uint256 public lastTimestamp;\\n\\n    constructor(\\n        address fund0_,\\n        uint256 guardedLaunchStart_,\\n        address controllerBallot_\\n    ) public {\\n        fund0 = fund0_;\\n        guardedLaunchStart = guardedLaunchStart_;\\n        require(_endOfWeek(guardedLaunchStart_) == guardedLaunchStart_ + 1 weeks);\\n        controllerBallot = controllerBallot_;\\n    }\\n\\n    /// @dev Initialize the part added in V4. The contract is designed to be used with OpenZeppelin's\\n    ///      `TransparentUpgradeableProxy`. If this contract is upgraded from the previous version,\\n    ///      call `upgradeToAndCall` of the proxy and put a call to this function in the `data`\\n    ///      argument with `lastTimestamp_` set to the last updated week. If this contract is\\n    ///      the first implementation of the proxy, This function should be called by the proxy's\\n    ///      constructor (via the `_data` argument) with `lastTimestamp_` set to one week before\\n    ///      `guardedLaunchStart`.\\n    function initializeV4(uint256 lastTimestamp_) external {\\n        require(lastTimestamp == 0, \\\"Already initialized\\\");\\n        require(\\n            _endOfWeek(lastTimestamp_) == lastTimestamp_ + 1 weeks &&\\n                lastTimestamp_ >= guardedLaunchStart - 1 weeks\\n        );\\n        require(weights[lastTimestamp_ + 1 weeks][fund0] == 0, \\\"Next week already updated\\\");\\n        if (lastTimestamp_ >= guardedLaunchStart) {\\n            require(weights[lastTimestamp_][fund0] > 0, \\\"Last week not updated\\\");\\n        }\\n        lastTimestamp = lastTimestamp_;\\n    }\\n\\n    /// @notice Get Fund relative weight (not more than 1.0) normalized to 1e18\\n    ///         (e.g. 1.0 == 1e18).\\n    /// @return weight Value of relative weight normalized to 1e18\\n    function getFundRelativeWeight(address fundAddress, uint256 timestamp)\\n        external\\n        override\\n        returns (uint256)\\n    {\\n        require(timestamp <= block.timestamp, \\\"Too soon\\\");\\n        if (timestamp < guardedLaunchStart) {\\n            return fundAddress == fund0 ? 1e18 : 0;\\n        }\\n        uint256 weekTimestamp = _endOfWeek(timestamp).sub(1 weeks);\\n        uint256 lastTimestamp_ = lastTimestamp; // gas saver\\n        require(weekTimestamp <= lastTimestamp_ + 1 weeks, \\\"Previous week is empty\\\");\\n        if (weekTimestamp <= lastTimestamp_) {\\n            return weights[weekTimestamp][fundAddress];\\n        }\\n        lastTimestamp = lastTimestamp_ + 1 weeks;\\n        return _updateFundWeight(weekTimestamp, fundAddress);\\n    }\\n\\n    function _updateFundWeight(uint256 weekTimestamp, address fundAddress)\\n        private\\n        returns (uint256 weight)\\n    {\\n        (uint256[] memory ballotWeights, address[] memory funds) =\\n            IControllerBallot(controllerBallot).count(weekTimestamp);\\n\\n        uint256 totalWeight;\\n        for (uint256 i = 0; i < ballotWeights.length; i++) {\\n            uint256 fundWeight = ballotWeights[i];\\n            weights[weekTimestamp][funds[i]] = fundWeight;\\n            emit WeightUpdated(funds[i], weekTimestamp, fundWeight);\\n            if (funds[i] == fundAddress) {\\n                weight = fundWeight;\\n            }\\n            totalWeight = totalWeight.add(fundWeight);\\n        }\\n        require(totalWeight <= 1e18, \\\"Total weight exceeds 100%\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/governance/ChessControllerV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"../../utils/CoreUtility.sol\\\";\\nimport \\\"../../utils/SafeDecimalMath.sol\\\";\\nimport \\\"../../interfaces/IChessController.sol\\\";\\nimport \\\"../interfaces/IFund.sol\\\";\\n\\ncontract ChessControllerV3 is IChessController, CoreUtility {\\n    /// @dev Reserved storage slots for future base contract upgrades\\n    uint256[192] private _reservedSlots;\\n\\n    using Math for uint256;\\n    using SafeMath for uint256;\\n    using SafeDecimalMath for uint256;\\n\\n    uint256 public constant WINDOW_SIZE = 2;\\n    uint256 public immutable minWeight;\\n\\n    address public immutable fund0;\\n    address public immutable fund1;\\n    address public immutable fund2;\\n\\n    uint256 public immutable guardedLaunchStart;\\n    uint256 public immutable guardedLaunchStartV3;\\n\\n    mapping(uint256 => mapping(address => uint256)) public weights;\\n\\n    constructor(\\n        address fund0_,\\n        address fund1_,\\n        address fund2_,\\n        uint256 guardedLaunchStart_,\\n        uint256 guardedLaunchStartV3_,\\n        uint256 minWeight_\\n    ) public {\\n        require(minWeight_ > 0 && minWeight_ < 0.5e18);\\n        fund0 = fund0_;\\n        fund1 = fund1_;\\n        fund2 = fund2_;\\n        guardedLaunchStart = guardedLaunchStart_;\\n        require(_endOfWeek(guardedLaunchStart_) == guardedLaunchStart_ + 1 weeks);\\n        guardedLaunchStartV3 = guardedLaunchStartV3_;\\n        require(_endOfWeek(guardedLaunchStartV3_) == guardedLaunchStartV3_ + 1 weeks);\\n        require(guardedLaunchStartV3_ > guardedLaunchStart_);\\n        minWeight = minWeight_;\\n    }\\n\\n    function initializeV3(uint256[] calldata guardedWeights2_) external {\\n        require(guardedLaunchStartV3 > block.timestamp, \\\"Too late to initialize\\\");\\n        // Make sure guarded launch in V2 has been initialized.\\n        require(weights[guardedLaunchStart][fund0] != 0);\\n        // Make sure guarded launch in V2 has ended.\\n        require(weights[guardedLaunchStartV3][fund0] == 0);\\n        require(weights[guardedLaunchStartV3][fund2] == 0, \\\"Already initialized\\\");\\n        require(guardedWeights2_.length > 0);\\n        for (uint256 i = 0; i < guardedWeights2_.length; i++) {\\n            uint256 weight2 = guardedWeights2_[i];\\n            require(weight2 >= minWeight && weight2 <= 1e18 - minWeight * 2, \\\"Invalid weight\\\");\\n            weights[guardedLaunchStartV3 + i * 1 weeks][fund2] = weight2;\\n        }\\n    }\\n\\n    /// @notice Get Fund relative weight (not more than 1.0) normalized to 1e18\\n    ///         (e.g. 1.0 == 1e18).\\n    /// @return weight Value of relative weight normalized to 1e18\\n    function getFundRelativeWeight(address fundAddress, uint256 timestamp)\\n        external\\n        override\\n        returns (uint256)\\n    {\\n        require(timestamp <= block.timestamp, \\\"Too soon\\\");\\n        if (fundAddress != fund0 && fundAddress != fund1 && fundAddress != fund2) {\\n            return 0;\\n        }\\n        if (timestamp < guardedLaunchStart) {\\n            return fundAddress == fund0 ? 1e18 : 0;\\n        } else if (timestamp < guardedLaunchStartV3 && fundAddress == fund2) {\\n            return 0;\\n        }\\n\\n        uint256 weekTimestamp = _endOfWeek(timestamp).sub(1 weeks);\\n        uint256 weight = weights[weekTimestamp][fundAddress];\\n        if (weight != 0) {\\n            return weight;\\n        }\\n\\n        (uint256 weight0, uint256 weight1, uint256 weight2) = _updateFundWeight(weekTimestamp);\\n        if (fundAddress == fund0) {\\n            return weight0;\\n        } else if (fundAddress == fund1) {\\n            return weight1;\\n        } else {\\n            return weight2;\\n        }\\n    }\\n\\n    function _updateFundWeight(uint256 weekTimestamp)\\n        private\\n        returns (\\n            uint256 weight0,\\n            uint256 weight1,\\n            uint256 weight2\\n        )\\n    {\\n        uint256 prevWeight0 = weights[weekTimestamp - 1 weeks][fund0];\\n        require(prevWeight0 != 0, \\\"Previous week is empty\\\");\\n        uint256 prevWeight2 = weights[weekTimestamp - 1 weeks][fund2];\\n        weight2 = weights[weekTimestamp][fund2];\\n        if (weight2 == 0) {\\n            // After guarded launch V3, keep weight of fund 2 constant. This contract is planned to\\n            // be upgraded again after guarded launch V3 and the constant weight2 won't last long.\\n            weight2 = prevWeight2;\\n        }\\n        prevWeight0 = prevWeight0.mul(1e18 - weight2).div(1e18 - prevWeight2).max(minWeight).min(\\n            1e18 - weight2 - minWeight\\n        );\\n        uint256 fundValueLocked0 = getFundValueLocked(fund0, weekTimestamp);\\n        uint256 totalValueLocked = fundValueLocked0.add(getFundValueLocked(fund1, weekTimestamp));\\n\\n        if (totalValueLocked == 0) {\\n            weight0 = prevWeight0;\\n        } else {\\n            weight0 = (prevWeight0.mul(WINDOW_SIZE - 1).add(\\n                fundValueLocked0.mul(1e18 - weight2).div(totalValueLocked)\\n            ) / WINDOW_SIZE)\\n                .max(minWeight)\\n                .min(1e18 - weight2 - minWeight);\\n        }\\n        weight1 = 1e18 - weight2 - weight0;\\n\\n        weights[weekTimestamp][fund0] = weight0;\\n        weights[weekTimestamp][fund1] = weight1;\\n        weights[weekTimestamp][fund2] = weight2;\\n    }\\n\\n    function getFundValueLocked(address fund, uint256 weekTimestamp)\\n        public\\n        view\\n        returns (uint256 fundValueLocked)\\n    {\\n        uint256 timestamp = (IFund(fund).currentDay() - 1 days).min(weekTimestamp);\\n        (uint256 navM, , ) = IFund(fund).historicalNavs(timestamp);\\n        fundValueLocked = IFund(fund).historicalTotalShares(timestamp).multiplyDecimal(navM);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/governance/ChessControllerV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"../../utils/CoreUtility.sol\\\";\\nimport \\\"../../utils/SafeDecimalMath.sol\\\";\\nimport \\\"../../interfaces/IChessController.sol\\\";\\nimport \\\"../interfaces/IFund.sol\\\";\\n\\ncontract ChessControllerV2 is IChessController, CoreUtility {\\n    /// @dev Reserved storage slots for future base contract upgrades\\n    uint256[192] private _reservedSlots;\\n\\n    using Math for uint256;\\n    using SafeMath for uint256;\\n    using SafeDecimalMath for uint256;\\n\\n    uint256 public constant WINDOW_SIZE = 2;\\n    uint256 public immutable minWeight;\\n\\n    address public immutable fund0;\\n    address public immutable fund1;\\n    mapping(uint256 => mapping(address => uint256)) public weights;\\n\\n    uint256 public immutable guardedLaunchStart;\\n\\n    constructor(\\n        address fund0_,\\n        address fund1_,\\n        uint256 guardedLaunchStart_,\\n        uint256 minWeight_\\n    ) public {\\n        require(minWeight_ > 0 && minWeight_ < 1e18);\\n        fund0 = fund0_;\\n        fund1 = fund1_;\\n        guardedLaunchStart = guardedLaunchStart_;\\n        minWeight = minWeight_;\\n    }\\n\\n    function initialize(uint256[] calldata guardedWeights0_) external {\\n        require(weights[guardedLaunchStart][fund0] == 0);\\n        require(guardedWeights0_.length > 0);\\n        require(_endOfWeek(guardedLaunchStart) == guardedLaunchStart + 1 weeks, \\\"Not end of week\\\");\\n        for (uint256 i = 0; i < guardedWeights0_.length; i++) {\\n            uint256 guardedWeight0 = guardedWeights0_[i];\\n            require(\\n                guardedWeight0 >= minWeight && guardedWeight0 <= 1e18 - minWeight,\\n                \\\"Invalid weight\\\"\\n            );\\n            weights[guardedLaunchStart + i * 1 weeks][fund0] = guardedWeight0;\\n            weights[guardedLaunchStart + i * 1 weeks][fund1] = 1e18 - guardedWeight0;\\n        }\\n    }\\n\\n    /// @notice Get Fund relative weight (not more than 1.0) normalized to 1e18\\n    ///         (e.g. 1.0 == 1e18).\\n    /// @return weight Value of relative weight normalized to 1e18\\n    function getFundRelativeWeight(address fundAddress, uint256 timestamp)\\n        external\\n        override\\n        returns (uint256)\\n    {\\n        require(timestamp <= block.timestamp, \\\"Too soon\\\");\\n        if (fundAddress != fund0 && fundAddress != fund1) {\\n            return 0;\\n        }\\n        if (timestamp < guardedLaunchStart) {\\n            return fundAddress == fund0 ? 1e18 : 0;\\n        }\\n\\n        uint256 weekTimestamp = _endOfWeek(timestamp).sub(1 weeks);\\n        uint256 weight = weights[weekTimestamp][fundAddress];\\n        if (weight != 0) {\\n            return weight;\\n        }\\n\\n        (uint256 weight0, uint256 weight1) = _updateFundWeight(weekTimestamp);\\n        return fundAddress == fund0 ? weight0 : weight1;\\n    }\\n\\n    function _updateFundWeight(uint256 weekTimestamp)\\n        private\\n        returns (uint256 weightMovingAverage0, uint256 weightMovingAverage1)\\n    {\\n        uint256 fundValueLocked0 = getFundValueLocked(fund0, weekTimestamp);\\n        uint256 totalValueLocked = fundValueLocked0.add(getFundValueLocked(fund1, weekTimestamp));\\n        uint256 prevFundWeight0 = weights[weekTimestamp - 1 weeks][fund0];\\n        require(prevFundWeight0 != 0, \\\"Previous week is empty\\\");\\n\\n        if (totalValueLocked == 0) {\\n            weightMovingAverage0 = prevFundWeight0;\\n            weightMovingAverage1 = weights[weekTimestamp - 1 weeks][fund1];\\n        } else {\\n            weightMovingAverage0 = (prevFundWeight0.mul(WINDOW_SIZE - 1).add(\\n                fundValueLocked0.divideDecimal(totalValueLocked)\\n            ) / WINDOW_SIZE)\\n                .max(minWeight)\\n                .min(1e18 - minWeight);\\n            weightMovingAverage1 = 1e18 - weightMovingAverage0;\\n        }\\n\\n        weights[weekTimestamp][fund0] = weightMovingAverage0;\\n        weights[weekTimestamp][fund1] = weightMovingAverage1;\\n    }\\n\\n    function getFundValueLocked(address fund, uint256 weekTimestamp)\\n        public\\n        view\\n        returns (uint256 fundValueLocked)\\n    {\\n        uint256 timestamp = (IFund(fund).currentDay() - 1 days).min(weekTimestamp);\\n        (uint256 navM, , ) = IFund(fund).historicalNavs(timestamp);\\n        fundValueLocked = IFund(fund).historicalTotalShares(timestamp).multiplyDecimal(navM);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/governance/VotingEscrow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\n\\nimport \\\"../../utils/CoreUtility.sol\\\";\\nimport \\\"../../interfaces/IVotingEscrow.sol\\\";\\n\\ninterface IAddressWhitelist {\\n    function check(address account) external view returns (bool);\\n}\\n\\ncontract VotingEscrow is IVotingEscrow, OwnableUpgradeable, ReentrancyGuard, CoreUtility {\\n    /// @dev Reserved storage slots for future base contract upgrades\\n    uint256[32] private _reservedSlots;\\n\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    event LockCreated(address indexed account, uint256 amount, uint256 unlockTime);\\n\\n    event AmountIncreased(address indexed account, uint256 increasedAmount);\\n\\n    event UnlockTimeIncreased(address indexed account, uint256 newUnlockTime);\\n\\n    event Withdrawn(address indexed account, uint256 amount);\\n\\n    uint256 public immutable override maxTime;\\n\\n    address public immutable override token;\\n\\n    string public name;\\n    string public symbol;\\n\\n    address public addressWhitelist;\\n\\n    mapping(address => LockedBalance) public locked;\\n\\n    /// @notice Mapping of unlockTime => total amount that will be unlocked at unlockTime\\n    mapping(uint256 => uint256) public scheduledUnlock;\\n\\n    /// @notice max lock time allowed at the moment\\n    uint256 public maxTimeAllowed;\\n\\n    constructor(\\n        address token_,\\n        address addressWhitelist_,\\n        string memory name_,\\n        string memory symbol_,\\n        uint256 maxTime_\\n    ) public {\\n        name = name_;\\n        symbol = symbol_;\\n        token = token_;\\n        addressWhitelist = addressWhitelist_;\\n        maxTime = maxTime_;\\n    }\\n\\n    /// @notice Initialize ownership\\n    function initialize(uint256 maxTimeAllowed_) external initializer {\\n        __Ownable_init();\\n        require(maxTimeAllowed_ <= maxTime, \\\"Cannot exceed max time\\\");\\n        maxTimeAllowed = maxTimeAllowed_;\\n    }\\n\\n    function getTimestampDropBelow(address account, uint256 threshold)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        LockedBalance memory lockedBalance = locked[account];\\n        if (lockedBalance.amount == 0 || lockedBalance.amount < threshold) {\\n            return 0;\\n        }\\n        return lockedBalance.unlockTime.sub(threshold.mul(maxTime).div(lockedBalance.amount));\\n    }\\n\\n    function balanceOf(address account) external view override returns (uint256) {\\n        return _balanceOfAtTimestamp(account, block.timestamp);\\n    }\\n\\n    function totalSupply() external view override returns (uint256) {\\n        return _totalSupplyAtTimestamp(block.timestamp);\\n    }\\n\\n    function getLockedBalance(address account)\\n        external\\n        view\\n        override\\n        returns (LockedBalance memory)\\n    {\\n        return locked[account];\\n    }\\n\\n    function balanceOfAtTimestamp(address account, uint256 timestamp)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _balanceOfAtTimestamp(account, timestamp);\\n    }\\n\\n    function totalSupplyAtTimestamp(uint256 timestamp) external view returns (uint256) {\\n        return _totalSupplyAtTimestamp(timestamp);\\n    }\\n\\n    function createLock(\\n        uint256 amount,\\n        uint256 unlockTime,\\n        address,\\n        bytes memory\\n    ) external nonReentrant {\\n        _assertNotContract();\\n        require(\\n            unlockTime + 1 weeks == _endOfWeek(unlockTime),\\n            \\\"Unlock time must be end of a week\\\"\\n        );\\n\\n        LockedBalance memory lockedBalance = locked[msg.sender];\\n\\n        require(amount > 0, \\\"Zero value\\\");\\n        require(lockedBalance.amount == 0, \\\"Withdraw old tokens first\\\");\\n        require(unlockTime > block.timestamp, \\\"Can only lock until time in the future\\\");\\n        require(\\n            unlockTime <= block.timestamp + maxTimeAllowed,\\n            \\\"Voting lock cannot exceed max lock time\\\"\\n        );\\n\\n        scheduledUnlock[unlockTime] = scheduledUnlock[unlockTime].add(amount);\\n        locked[msg.sender].unlockTime = unlockTime;\\n        locked[msg.sender].amount = amount;\\n\\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\\n\\n        emit LockCreated(msg.sender, amount, unlockTime);\\n    }\\n\\n    function increaseAmount(\\n        address account,\\n        uint256 amount,\\n        address,\\n        bytes memory\\n    ) external nonReentrant {\\n        LockedBalance memory lockedBalance = locked[account];\\n\\n        require(amount > 0, \\\"Zero value\\\");\\n        require(lockedBalance.unlockTime > block.timestamp, \\\"Cannot add to expired lock\\\");\\n\\n        scheduledUnlock[lockedBalance.unlockTime] = scheduledUnlock[lockedBalance.unlockTime].add(\\n            amount\\n        );\\n        locked[account].amount = lockedBalance.amount.add(amount);\\n\\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\\n\\n        emit AmountIncreased(account, amount);\\n    }\\n\\n    function increaseUnlockTime(\\n        uint256 unlockTime,\\n        address,\\n        bytes memory\\n    ) external nonReentrant {\\n        require(\\n            unlockTime + 1 weeks == _endOfWeek(unlockTime),\\n            \\\"Unlock time must be end of a week\\\"\\n        );\\n        LockedBalance memory lockedBalance = locked[msg.sender];\\n\\n        require(lockedBalance.unlockTime > block.timestamp, \\\"Lock expired\\\");\\n        require(unlockTime > lockedBalance.unlockTime, \\\"Can only increase lock duration\\\");\\n        require(\\n            unlockTime <= block.timestamp + maxTimeAllowed,\\n            \\\"Voting lock cannot exceed max lock time\\\"\\n        );\\n\\n        scheduledUnlock[lockedBalance.unlockTime] = scheduledUnlock[lockedBalance.unlockTime].sub(\\n            lockedBalance.amount\\n        );\\n        scheduledUnlock[unlockTime] = scheduledUnlock[unlockTime].add(lockedBalance.amount);\\n        locked[msg.sender].unlockTime = unlockTime;\\n\\n        emit UnlockTimeIncreased(msg.sender, unlockTime);\\n    }\\n\\n    function withdraw() external nonReentrant {\\n        LockedBalance memory lockedBalance = locked[msg.sender];\\n        require(block.timestamp >= lockedBalance.unlockTime, \\\"The lock is not expired\\\");\\n        uint256 amount = uint256(lockedBalance.amount);\\n\\n        lockedBalance.unlockTime = 0;\\n        lockedBalance.amount = 0;\\n        locked[msg.sender] = lockedBalance;\\n\\n        IERC20(token).safeTransfer(msg.sender, amount);\\n\\n        emit Withdrawn(msg.sender, amount);\\n    }\\n\\n    function updateAddressWhitelist(address newWhitelist) external onlyOwner {\\n        require(\\n            newWhitelist == address(0) || Address.isContract(newWhitelist),\\n            \\\"Smart contract whitelist has to be null or a contract\\\"\\n        );\\n        addressWhitelist = newWhitelist;\\n    }\\n\\n    function _assertNotContract() private view {\\n        if (msg.sender != tx.origin) {\\n            if (\\n                addressWhitelist != address(0) &&\\n                IAddressWhitelist(addressWhitelist).check(msg.sender)\\n            ) {\\n                return;\\n            }\\n            revert(\\\"Smart contract depositors not allowed\\\");\\n        }\\n    }\\n\\n    function _balanceOfAtTimestamp(address account, uint256 timestamp)\\n        private\\n        view\\n        returns (uint256)\\n    {\\n        require(timestamp >= block.timestamp, \\\"Must be current or future time\\\");\\n        LockedBalance memory lockedBalance = locked[account];\\n        if (timestamp > lockedBalance.unlockTime) {\\n            return 0;\\n        }\\n        return (lockedBalance.amount.mul(lockedBalance.unlockTime - timestamp)) / maxTime;\\n    }\\n\\n    function _totalSupplyAtTimestamp(uint256 timestamp) private view returns (uint256) {\\n        uint256 weekCursor = _endOfWeek(timestamp);\\n        uint256 total = 0;\\n        for (; weekCursor <= timestamp + maxTime; weekCursor += 1 weeks) {\\n            total = total.add((scheduledUnlock[weekCursor].mul(weekCursor - timestamp)) / maxTime);\\n        }\\n        return total;\\n    }\\n\\n    function updateMaxTimeAllowed(uint256 newMaxTimeAllowed) external onlyOwner {\\n        require(newMaxTimeAllowed <= maxTime, \\\"Cannot exceed max time\\\");\\n        require(newMaxTimeAllowed > maxTimeAllowed, \\\"Cannot shorten max time allowed\\\");\\n        maxTimeAllowed = newMaxTimeAllowed;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/EnumerableSet.sol\\\";\\nimport \\\"../utils/Address.sol\\\";\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using Address for address;\\n\\n    struct RoleData {\\n        EnumerableSet.AddressSet members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping (bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view returns (bool) {\\n        return _roles[role].members.contains(account);\\n    }\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\\n        return _roles[role].members.length();\\n    }\\n\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\\n        return _roles[role].members.at(index);\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual {\\n        require(hasRole(_roles[role].adminRole, _msgSender()), \\\"AccessControl: sender must be an admin to grant\\\");\\n\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual {\\n        require(hasRole(_roles[role].adminRole, _msgSender()), \\\"AccessControl: sender must be an admin to revoke\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\\n        _roles[role].adminRole = adminRole;\\n    }\\n\\n    function _grantRole(bytes32 role, address account) private {\\n        if (_roles[role].members.add(account)) {\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    function _revokeRole(bytes32 role, address account) private {\\n        if (_roles[role].members.remove(account)) {\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/MockWrappedToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\ncontract MockWrappedToken is ERC20 {\\n    constructor(string memory name, string memory symbol) public ERC20(name, symbol) {\\n        _setupDecimals(18);\\n    }\\n\\n    function deposit() external payable {\\n        _mint(msg.sender, msg.value);\\n    }\\n\\n    function withdraw(uint256 wad) external {\\n        _burn(msg.sender, wad);\\n        msg.sender.transfer(wad);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/MockToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\ncontract MockToken is ERC20, Ownable {\\n    constructor(\\n        string memory name,\\n        string memory symbol,\\n        uint8 decimals\\n    ) public ERC20(name, symbol) {\\n        _setupDecimals(decimals);\\n    }\\n\\n    function mint(address account, uint256 amount) external onlyOwner {\\n        _mint(account, amount);\\n    }\\n\\n    function burn(address account, uint256 amount) external onlyOwner {\\n        _burn(account, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/oracle/TwapOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"../../interfaces/ITwapOracle.sol\\\";\\n\\n/// @title Time-weighted average price oracle\\n/// @notice This contract extends the Open Oracle standard by Compound, accepts price data\\n///         signed by two Reporters (a primary source and a secondary source) and computes\\n///         time-weighted average price (TWAP) in every 30-minute epoch.\\n/// @author Tranchess\\ncontract TwapOracle is ITwapOracle, Ownable {\\n    uint256 private constant MESSAGE_INTERVAL = 1 minutes;\\n    uint256 private constant MESSAGE_BATCH_SIZE = 30; // not exceeding 32 for v's to fit in a word\\n    uint256 private constant EPOCH = MESSAGE_INTERVAL * MESSAGE_BATCH_SIZE;\\n\\n    /// @dev Minimal number of messages in an epoch.\\n    uint256 private constant MIN_MESSAGE_COUNT = 15;\\n    uint256 private constant PUBLISHING_DELAY = 15 minutes;\\n\\n    uint256 private constant SECONDARY_SOURCE_DELAY = EPOCH * 2;\\n    uint256 private constant OWNER_DELAY = EPOCH * 4;\\n    uint256 private constant PRICE_UNIT = 1e12;\\n    uint256 private constant PRICE_MASK = 0xffffffffffffffff;\\n\\n    event Update(uint256 timestamp, uint256 price, UpdateType updateType);\\n\\n    address public immutable primarySource;\\n    address public immutable secondarySource;\\n    uint256 private immutable _startTimestamp;\\n    string public symbol;\\n\\n    uint256 private _lastPrimaryMessageCount;\\n    uint256 private _lastSecondaryTimestamp;\\n    uint256 private _lastSecondaryMessageCount;\\n\\n    /// @dev Mapping of epoch end timestamp => TWAP\\n    mapping(uint256 => uint256) private _prices;\\n\\n    /// @param primarySource_ Address of the primary data source\\n    /// @param secondarySource_ Address of the secondary data source\\n    /// @param symbol_ Asset symbol\\n    constructor(\\n        address primarySource_,\\n        address secondarySource_,\\n        string memory symbol_\\n    ) public {\\n        primarySource = primarySource_;\\n        secondarySource = secondarySource_;\\n        symbol = symbol_;\\n        _startTimestamp = block.timestamp;\\n    }\\n\\n    /// @notice Return TWAP with 18 decimal places in the epoch ending at the specified timestamp.\\n    ///         Zero is returned if the epoch is not initialized yet or can still be updated\\n    ///         with more messages from the same source.\\n    /// @param timestamp End Timestamp in seconds of the epoch\\n    /// @return TWAP (18 decimal places) in the epoch, or zero if the epoch is not initialized yet\\n    ///         or can still be updated with more messages from the same source.\\n    function getTwap(uint256 timestamp) external view override returns (uint256) {\\n        // Check whether the stored price can be updated in the future\\n        if (\\n            // Case 1: it can still be updated by more messages from the primary source\\n            timestamp > block.timestamp - PUBLISHING_DELAY ||\\n            // Case 2: it comes from the secondary source and can still be updated\\n            // by more messages from that source\\n            (timestamp <= block.timestamp - SECONDARY_SOURCE_DELAY &&\\n                timestamp > block.timestamp - SECONDARY_SOURCE_DELAY - PUBLISHING_DELAY &&\\n                timestamp == _lastSecondaryTimestamp)\\n        ) {\\n            return 0;\\n        } else {\\n            return _prices[timestamp];\\n        }\\n    }\\n\\n    /// @notice Return minimum acceptable message count from the primary source\\n    ///         to update a given epoch.\\n    /// @param timestamp End timestamp in seconds of the epoch to update\\n    /// @return Minimum acceptable message count, or `MESSAGE_BATCH_SIZE + 1` if the epoch\\n    ///         cannot be updated now\\n    function minPrimaryMessageCountToUpdate(uint256 timestamp) external view returns (uint256) {\\n        if (_prices[timestamp] != 0) {\\n            if (timestamp > block.timestamp - PUBLISHING_DELAY) {\\n                return _lastPrimaryMessageCount + 1;\\n            } else {\\n                return MESSAGE_BATCH_SIZE + 1;\\n            }\\n        } else {\\n            return MIN_MESSAGE_COUNT;\\n        }\\n    }\\n\\n    /// @notice Return minimum acceptable message count from the secondary source\\n    ///         to update a given epoch.\\n    /// @param timestamp End timestamp in seconds of the epoch to update\\n    /// @return Minimum acceptable message count, or `MESSAGE_BATCH_SIZE + 1` if the epoch\\n    ///         cannot be updated now\\n    function minSecondaryMessageCountToUpdate(uint256 timestamp) external view returns (uint256) {\\n        if (timestamp > block.timestamp - SECONDARY_SOURCE_DELAY || timestamp <= _startTimestamp) {\\n            return MESSAGE_BATCH_SIZE + 1;\\n        } else if (_prices[timestamp] != 0) {\\n            if (\\n                timestamp == _lastSecondaryTimestamp &&\\n                timestamp > block.timestamp - SECONDARY_SOURCE_DELAY - PUBLISHING_DELAY\\n            ) {\\n                return _lastSecondaryMessageCount + 1;\\n            } else {\\n                return MESSAGE_BATCH_SIZE + 1;\\n            }\\n        } else {\\n            return MIN_MESSAGE_COUNT;\\n        }\\n    }\\n\\n    /// @notice Submit prices in a epoch that are signed by the primary source.\\n    /// @param timestamp End timestamp in seconds of the epoch\\n    /// @param priceList A list of prices (6 decimal places) in messages signed by the source,\\n    ///        with zero indicating a missing message\\n    /// @param rList A list of \\\"r\\\" values of signatures\\n    /// @param sList A list of \\\"s\\\" values of signatures\\n    /// @param packedV \\\"v\\\" values of signatures packed in a single word,\\n    ///        starting from the lowest byte\\n    function updateTwapFromPrimary(\\n        uint256 timestamp,\\n        uint256[MESSAGE_BATCH_SIZE] calldata priceList,\\n        bytes32[MESSAGE_BATCH_SIZE] calldata rList,\\n        bytes32[MESSAGE_BATCH_SIZE] calldata sList,\\n        uint256 packedV\\n    ) external {\\n        // Do not check (timestamp > _startTimestamp) for two reasons:\\n        // 1. the primary source is trusted;\\n        // 2. to save gas in most of the time.\\n\\n        uint256 lastMessageCount = MIN_MESSAGE_COUNT - 1;\\n        if (_prices[timestamp] != 0) {\\n            require(\\n                timestamp > block.timestamp - PUBLISHING_DELAY,\\n                \\\"Too late for the primary source to update an existing epoch\\\"\\n            );\\n            lastMessageCount = _lastPrimaryMessageCount;\\n        }\\n        uint256 newMessageCount =\\n            _updateTwapFromSource(\\n                timestamp,\\n                lastMessageCount,\\n                priceList,\\n                rList,\\n                sList,\\n                packedV,\\n                primarySource,\\n                UpdateType.PRIMARY\\n            );\\n        if (timestamp > block.timestamp - PUBLISHING_DELAY) {\\n            _lastPrimaryMessageCount = newMessageCount;\\n        }\\n    }\\n\\n    /// @notice Submit prices in a epoch that are signed by the secondary source.\\n    ///         This is allowed only after SECONDARY_SOURCE_DELAY has elapsed after the epoch.\\n    /// @param timestamp End timestamp in seconds of the epoch\\n    /// @param priceList A list of prices (6 decimal places) in messages signed by the source,\\n    ///        with zero indicating a missing message\\n    /// @param rList A list of \\\"r\\\" values of signatures\\n    /// @param sList A list of \\\"s\\\" values of signatures\\n    /// @param packedV \\\"v\\\" values of signatures packed in a single word,\\n    ///        starting from the lowest byte\\n    function updateTwapFromSecondary(\\n        uint256 timestamp,\\n        uint256[MESSAGE_BATCH_SIZE] calldata priceList,\\n        bytes32[MESSAGE_BATCH_SIZE] calldata rList,\\n        bytes32[MESSAGE_BATCH_SIZE] calldata sList,\\n        uint256 packedV\\n    ) external {\\n        require(\\n            timestamp <= block.timestamp - SECONDARY_SOURCE_DELAY,\\n            \\\"Not ready for the secondary source\\\"\\n        );\\n        require(\\n            timestamp > _startTimestamp,\\n            \\\"The secondary source cannot update epoch before this contract is deployed\\\"\\n        );\\n        uint256 lastMessageCount = MIN_MESSAGE_COUNT - 1;\\n        if (_prices[timestamp] != 0) {\\n            require(\\n                timestamp == _lastSecondaryTimestamp &&\\n                    timestamp > block.timestamp - SECONDARY_SOURCE_DELAY - PUBLISHING_DELAY,\\n                \\\"Too late for the secondary source to update an existing epoch\\\"\\n            );\\n            lastMessageCount = _lastSecondaryMessageCount;\\n        }\\n        uint256 newMessageCount =\\n            _updateTwapFromSource(\\n                timestamp,\\n                lastMessageCount,\\n                priceList,\\n                rList,\\n                sList,\\n                packedV,\\n                secondarySource,\\n                UpdateType.SECONDARY\\n            );\\n        if (timestamp > block.timestamp - SECONDARY_SOURCE_DELAY - PUBLISHING_DELAY) {\\n            _lastSecondaryTimestamp = timestamp;\\n            _lastSecondaryMessageCount = newMessageCount;\\n        }\\n    }\\n\\n    /// @dev Verify signatures and update a epoch.\\n    /// @param timestamp End timestamp in seconds of the epoch\\n    /// @param lastMessageCount Message count in the last update to the epoch\\n    /// @param priceList A list of prices (6 decimal places) in messages signed by the source,\\n    ///        with zero indicating a missing message\\n    /// @param rList A list of \\\"r\\\" values of signatures\\n    /// @param sList A list of \\\"s\\\" values of signatures\\n    /// @param packedV \\\"v\\\" values of signatures packed in a single word,\\n    ///        starting from the lowest byte\\n    /// @param source Address of the data source that signs the messages\\n    /// @param updateType Type of this update, which will be included in an event\\n    /// @return messageCount Non-zero price count in `priceList`\\n    function _updateTwapFromSource(\\n        uint256 timestamp,\\n        uint256 lastMessageCount,\\n        uint256[MESSAGE_BATCH_SIZE] memory priceList,\\n        bytes32[MESSAGE_BATCH_SIZE] memory rList,\\n        bytes32[MESSAGE_BATCH_SIZE] memory sList,\\n        uint256 packedV,\\n        address source,\\n        UpdateType updateType\\n    ) private returns (uint256 messageCount) {\\n        require(timestamp % EPOCH == 0, \\\"Unaligned timestamp\\\");\\n        messageCount = 0;\\n        uint256 sum = 0;\\n        string memory _symbol = symbol; // gas saver\\n        uint256 t = timestamp - EPOCH;\\n        uint256 weight = 1;\\n        for (uint256 i = 0; i < MESSAGE_BATCH_SIZE; i++) {\\n            t += MESSAGE_INTERVAL;\\n            // Only prices fitting in 8 bytes (about 1.8e13 with 6 decimal places) are accepted,\\n            // which guarentees the following arithmetic operations never overflow.\\n            uint256 p = priceList[i] & PRICE_MASK;\\n            if (p == 0) {\\n                weight += 1;\\n                packedV >>= 8;\\n                continue;\\n            }\\n            // Build the original message and verify its signature. The computation is packed\\n            // in a single complex statement to save gas. Solidity generates unnecessary\\n            // initialization for each local variable, which wastes notable gas in this hot loop.\\n            require(\\n                ecrecover(\\n                    keccak256(\\n                        abi.encodePacked(\\n                            \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n                            keccak256(\\n                                // Rebuild the message signed by the source\\n                                abi.encode(\\\"prices\\\", t, _symbol, p)\\n                            )\\n                        )\\n                    ),\\n                    uint8(packedV), // the lowest byte of packedV\\n                    rList[i],\\n                    sList[i]\\n                ) == source,\\n                \\\"Invalid signature\\\"\\n            );\\n            sum += p * weight;\\n            weight = 1;\\n            messageCount += 1;\\n            packedV >>= 8;\\n        }\\n        require(messageCount > lastMessageCount, \\\"More messages are required to update this epoch\\\");\\n        if (weight > 1) {\\n            sum += (priceList[MESSAGE_BATCH_SIZE - weight] & PRICE_MASK) * (weight - 1);\\n        }\\n        uint256 average = (sum * PRICE_UNIT) / MESSAGE_BATCH_SIZE;\\n        _prices[t] = average;\\n        emit Update(t, average, updateType);\\n    }\\n\\n    /// @notice Submit a TWAP with 18 decimal places by the owner.\\n    ///         This is allowed only when a epoch gets no update after OWNER_DELAY has elapsed.\\n    function updateTwapFromOwner(uint256 timestamp, uint256 price) external onlyOwner {\\n        require(timestamp % EPOCH == 0, \\\"Unaligned timestamp\\\");\\n        require(timestamp <= block.timestamp - OWNER_DELAY, \\\"Not ready for owner\\\");\\n        require(_prices[timestamp] == 0, \\\"Owner cannot update an existing epoch\\\");\\n        require(\\n            timestamp > _startTimestamp,\\n            \\\"Owner cannot update epoch before this contract is deployed\\\"\\n        );\\n\\n        uint256 lastPrice = _prices[timestamp - EPOCH];\\n        require(lastPrice > 0, \\\"Owner can only update a epoch following an updated epoch\\\");\\n        require(\\n            price > lastPrice / 10 && price < lastPrice * 10,\\n            \\\"Owner price deviates too much from the last price\\\"\\n        );\\n\\n        _prices[timestamp] = price;\\n        emit Update(timestamp, price, UpdateType.OWNER);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/strategy/BscStakingStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"../utils/SafeDecimalMath.sol\\\";\\n\\nimport \\\"../interfaces/IFundV3.sol\\\";\\nimport \\\"../interfaces/IWrappedERC20.sol\\\";\\n\\ninterface ITokenHub {\\n    function getMiniRelayFee() external view returns (uint256);\\n\\n    function transferOut(\\n        address contractAddr,\\n        address recipient,\\n        uint256 amount,\\n        uint64 expireTime\\n    ) external payable returns (bool);\\n}\\n\\n/// @notice Strategy for delegating BNB to BSC validators and earn rewards.\\n///\\n///         BSC validator delegation and reward distribution happens on the Binance Chain (BC).\\n///         A staker address, which is securely managed by multi-signature, executes\\n///         delegation-related transactions and periodically transfer rewards back to this contract\\n///         on BSC.\\n///\\n///         This contract is a bridge between the fund and the staker. It performs cross-chain\\n///         transfers from the fund to the staker and forward transfers from the staker back to\\n///         the fund. It is also in charge of profit bookkeeping, which is either automatcially\\n///         reported by reporters using scripts or manually calibrated by the owner.\\ncontract BscStakingStrategy is Ownable {\\n    using SafeMath for uint256;\\n    using SafeDecimalMath for uint256;\\n    using SafeERC20 for IWrappedERC20;\\n\\n    event ReporterAdded(address reporter);\\n    event ReporterRemoved(address reporter);\\n    event StakerUpdated(address staker);\\n    event Received(address from, uint256 amount);\\n\\n    ITokenHub private constant TOKEN_HUB = ITokenHub(0x0000000000000000000000000000000000001004);\\n    uint256 private constant BRIDGE_EXPIRE_TIME = 1 hours;\\n    uint256 private constant MAX_ESTIMATED_DAILY_PROFIT_RATE = 0.1e18;\\n    uint256 private constant MAX_PERFORMANCE_FEE_RATE = 0.5e18;\\n\\n    IFundV3 public immutable fund;\\n    address private immutable _tokenUnderlying;\\n\\n    /// @notice BEP2 address that does the actual staking on Binance Chain.\\n    ///         DO NOT transfer any asset to this address on Binance Smart Chain.\\n    address public staker;\\n\\n    /// @notice Fraction of profit that goes to the fund's fee collector.\\n    uint256 public performanceFeeRate;\\n\\n    /// @notice Estimated daily profit rate. This value limits the maximum daily profit that can be\\n    ///         reported by a reporter.\\n    uint256 public estimatedDailyProfitRate;\\n\\n    /// @notice Amount of underlying lost since the last peak. Performance fee is charged\\n    ///         only when this value is zero.\\n    uint256 public currentDrawdown;\\n\\n    /// @notice The set of reporters. Reporters can report profit within a pre-configured range\\n    ///         once a day.\\n    mapping(address => bool) public reporters;\\n\\n    /// @notice The last trading day when a reporter reports daily profit.\\n    uint256 public reportedDay;\\n\\n    constructor(\\n        address fund_,\\n        address staker_,\\n        uint256 performanceFeeRate_\\n    ) public {\\n        fund = IFundV3(fund_);\\n        _tokenUnderlying = IFundV3(fund_).tokenUnderlying();\\n        staker = staker_;\\n        performanceFeeRate = performanceFeeRate_;\\n        emit StakerUpdated(staker_);\\n    }\\n\\n    modifier onlyReporter() {\\n        require(reporters[msg.sender], \\\"Only reporter\\\");\\n        _;\\n    }\\n\\n    function addReporter(address reporter) external onlyOwner {\\n        require(!reporters[reporter]);\\n        reporters[reporter] = true;\\n        emit ReporterAdded(reporter);\\n    }\\n\\n    function removeReporter(address reporter) external onlyOwner {\\n        require(reporters[reporter]);\\n        reporters[reporter] = false;\\n        emit ReporterRemoved(reporter);\\n    }\\n\\n    /// @notice Report daily profit to the fund by a reporter.\\n    /// @param amount Absolute profit, which must be no greater than twice the estimation\\n    function accrueProfit(uint256 amount) external onlyReporter {\\n        uint256 total = fund.getStrategyUnderlying();\\n        require(\\n            amount / 2 <= total.multiplyDecimal(estimatedDailyProfitRate),\\n            \\\"Profit out of range\\\"\\n        );\\n        _accrueProfit(amount);\\n    }\\n\\n    /// @notice Report daily profit according to the pre-configured rate by a reporter.\\n    function accrueEstimatedProfit() external onlyReporter {\\n        uint256 total = fund.getStrategyUnderlying();\\n        _accrueProfit(total.multiplyDecimal(estimatedDailyProfitRate));\\n    }\\n\\n    function _accrueProfit(uint256 amount) private {\\n        uint256 currentDay = fund.currentDay();\\n        uint256 oldReportedDay = reportedDay;\\n        require(oldReportedDay < currentDay, \\\"Already reported\\\");\\n        reportedDay = oldReportedDay + 1 days;\\n        _reportProfit(amount);\\n    }\\n\\n    function updateEstimatedDailyProfitRate(uint256 rate) external onlyOwner {\\n        require(rate < MAX_ESTIMATED_DAILY_PROFIT_RATE);\\n        estimatedDailyProfitRate = rate;\\n        reportedDay = fund.currentDay();\\n    }\\n\\n    /// @notice Report profit to the fund by the owner.\\n    function reportProfit(uint256 amount) external onlyOwner {\\n        reportedDay = fund.currentDay();\\n        _reportProfit(amount);\\n    }\\n\\n    /// @dev Report profit and performance fee to the fund. Performance fee is charged only when\\n    ///      there's no previous loss to cover.\\n    function _reportProfit(uint256 amount) private {\\n        uint256 oldDrawdown = currentDrawdown;\\n        if (amount < oldDrawdown) {\\n            currentDrawdown = oldDrawdown - amount;\\n            fund.reportProfit(amount, 0);\\n        } else {\\n            if (oldDrawdown > 0) {\\n                currentDrawdown = 0;\\n            }\\n            uint256 performanceFee = (amount - oldDrawdown).multiplyDecimal(performanceFeeRate);\\n            fund.reportProfit(amount, performanceFee);\\n        }\\n    }\\n\\n    /// @notice Report loss to the fund. Performance fee will not be charged until\\n    ///         the current drawdown is covered.\\n    function reportLoss(uint256 amount) external onlyOwner {\\n        reportedDay = fund.currentDay();\\n        currentDrawdown = currentDrawdown.add(amount);\\n        fund.reportLoss(amount);\\n    }\\n\\n    function updateStaker(address newStaker) external onlyOwner {\\n        require(newStaker != address(0));\\n        staker = newStaker;\\n        emit StakerUpdated(newStaker);\\n    }\\n\\n    function updatePerformanceFeeRate(uint256 newRate) external onlyOwner {\\n        require(newRate <= MAX_PERFORMANCE_FEE_RATE);\\n        performanceFeeRate = newRate;\\n    }\\n\\n    /// @notice Transfer underlying tokens from the fund to the staker on Binance Chain.\\n    /// @param amount Amount of underlying transfered from the fund, including cross-chain relay fee\\n    function transferToStaker(uint256 amount) external onlyOwner {\\n        fund.transferToStrategy(amount);\\n        _unwrap(amount);\\n        uint256 relayFee = TOKEN_HUB.getMiniRelayFee();\\n        require(\\n            TOKEN_HUB.transferOut{value: amount}(\\n                address(0),\\n                staker,\\n                amount.sub(relayFee),\\n                uint64(block.timestamp + BRIDGE_EXPIRE_TIME)\\n            ),\\n            \\\"BSC bridge failed\\\"\\n        );\\n    }\\n\\n    /// @notice Transfer all underlying tokens, both wrapped and unwrapped, to the fund.\\n    function transferToFund() external onlyOwner {\\n        uint256 unwrapped = address(this).balance;\\n        if (unwrapped > 0) {\\n            _wrap(unwrapped);\\n        }\\n        uint256 amount = IWrappedERC20(_tokenUnderlying).balanceOf(address(this));\\n        IWrappedERC20(_tokenUnderlying).safeApprove(address(fund), amount);\\n        fund.transferFromStrategy(amount);\\n    }\\n\\n    /// @notice Receive cross-chain transfer from the staker.\\n    receive() external payable {\\n        emit Received(msg.sender, msg.value);\\n    }\\n\\n    /// @dev Convert BNB into WBNB\\n    function _wrap(uint256 amount) private {\\n        IWrappedERC20(_tokenUnderlying).deposit{value: amount}();\\n    }\\n\\n    /// @dev Convert WBNB into BNB\\n    function _unwrap(uint256 amount) private {\\n        IWrappedERC20(_tokenUnderlying).withdraw(amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/swap/QueenStableSwap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"../interfaces/ITrancheIndexV2.sol\\\";\\nimport \\\"../utils/SafeDecimalMath.sol\\\";\\nimport \\\"./StableSwap.sol\\\";\\n\\ncontract QueenStableSwap is StableSwap, ITrancheIndexV2 {\\n    using SafeDecimalMath for uint256;\\n\\n    constructor(\\n        address lpToken_,\\n        address fund_,\\n        uint256 quoteDecimals_,\\n        uint256 ampl_,\\n        address feeCollector_,\\n        uint256 feeRate_,\\n        uint256 adminFeeRate_\\n    )\\n        public\\n        StableSwap(\\n            lpToken_,\\n            fund_,\\n            TRANCHE_Q,\\n            IFundV3(fund_).tokenUnderlying(),\\n            quoteDecimals_,\\n            ampl_,\\n            feeCollector_,\\n            feeRate_,\\n            adminFeeRate_\\n        )\\n    {\\n        require(10**(18 - quoteDecimals_) == IFundV3(fund_).underlyingDecimalMultiplier());\\n    }\\n\\n    function _getRebalanceResult(uint256)\\n        internal\\n        view\\n        override\\n        returns (\\n            uint256 newBase,\\n            uint256 newQuote,\\n            uint256 excessiveQ,\\n            uint256 excessiveB,\\n            uint256 excessiveR,\\n            uint256 excessiveQuote,\\n            bool isRebalanced\\n        )\\n    {\\n        return (baseBalance, quoteBalance, 0, 0, 0, 0, false);\\n    }\\n\\n    function _handleRebalance(uint256)\\n        internal\\n        override\\n        returns (uint256 newBase, uint256 newQuote)\\n    {\\n        return (baseBalance, quoteBalance);\\n    }\\n\\n    function getOraclePrice() public view override returns (uint256) {\\n        uint256 fundUnderlying = fund.getTotalUnderlying();\\n        uint256 fundEquivalentTotalQ = fund.getEquivalentTotalQ();\\n        return fundUnderlying.mul(_quoteDecimalMultiplier).divideDecimal(fundEquivalentTotalQ);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/swap/FlashSwapRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\\\";\\n\\nimport \\\"../fund/ShareStaking.sol\\\";\\n\\nimport \\\"../interfaces/ITranchessSwapCallee.sol\\\";\\nimport \\\"../interfaces/IPrimaryMarketV3.sol\\\";\\nimport \\\"../interfaces/ISwapRouter.sol\\\";\\nimport \\\"../interfaces/ITrancheIndexV2.sol\\\";\\n\\n/// @title Tranchess Flash Swap Router\\n/// @notice Router for stateless execution of flash swaps against Tranchess stable swaps\\ncontract FlashSwapRouter is ITranchessSwapCallee, ITrancheIndexV2, Ownable {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    event SwapToggled(address externalRouter, bool enabled);\\n    event SwapRook(\\n        address indexed recipient,\\n        uint256 baseIn,\\n        uint256 quoteIn,\\n        uint256 baseOut,\\n        uint256 quoteOut\\n    );\\n\\n    ISwapRouter public immutable tranchessRouter;\\n    mapping(address => bool) public externalRouterAllowlist;\\n\\n    constructor(address tranchessRouter_) public {\\n        tranchessRouter = ISwapRouter(tranchessRouter_);\\n    }\\n\\n    function toggleExternalRouter(address externalRouter) external onlyOwner {\\n        bool enabled = !externalRouterAllowlist[externalRouter];\\n        externalRouterAllowlist[externalRouter] = enabled;\\n        emit SwapToggled(externalRouter, enabled);\\n    }\\n\\n    function buyR(\\n        IFundV3 fund,\\n        address queenSwapOrPrimaryMarketRouter,\\n        uint256 maxQuote,\\n        address recipient,\\n        address tokenQuote,\\n        address externalRouter,\\n        address[] memory externalPath,\\n        address staking,\\n        uint256 version,\\n        uint256 outR\\n    ) external {\\n        require(externalRouterAllowlist[externalRouter], \\\"Invalid external router\\\");\\n        uint256 underlyingAmount;\\n        uint256 totalQuoteAmount;\\n        bytes memory data;\\n        {\\n            uint256 inQ = IPrimaryMarketV3(fund.primaryMarket()).getSplitForB(outR);\\n            underlyingAmount = IStableSwapCore(queenSwapOrPrimaryMarketRouter).getQuoteIn(inQ);\\n            // Calculate the exact amount of quote asset to pay\\n            totalQuoteAmount = IUniswapV2Router01(externalRouter).getAmountsIn(\\n                underlyingAmount,\\n                externalPath\\n            )[0];\\n            data = abi.encode(\\n                fund,\\n                queenSwapOrPrimaryMarketRouter,\\n                totalQuoteAmount,\\n                staking == address(0) ? recipient : staking,\\n                version,\\n                externalRouter,\\n                externalPath\\n            );\\n        }\\n        // Arrange the stable swap path\\n        IStableSwap tranchessPair = tranchessRouter.getSwap(fund.tokenB(), tokenQuote);\\n        address recipient_ = recipient;\\n        address tokenQuote_ = tokenQuote;\\n        // Calculate the amount of quote asset for selling BISHOP\\n        uint256 quoteAmount = tranchessPair.getQuoteOut(outR);\\n        // Send the user's portion of the payment to Tranchess swap\\n        uint256 resultAmount = totalQuoteAmount.sub(quoteAmount);\\n        require(resultAmount <= maxQuote, \\\"Excessive input\\\");\\n        IERC20(tokenQuote_).safeTransferFrom(msg.sender, address(this), resultAmount);\\n        tranchessPair.sell(version, quoteAmount, address(this), data);\\n        if (staking != address(0)) {\\n            ShareStaking(staking).deposit(TRANCHE_R, outR, recipient_, version);\\n        }\\n        emit SwapRook(recipient_, 0, resultAmount, outR, 0);\\n    }\\n\\n    function sellR(\\n        IFundV3 fund,\\n        address queenSwapOrPrimaryMarketRouter,\\n        uint256 minQuote,\\n        address recipient,\\n        address tokenQuote,\\n        address externalRouter,\\n        address[] memory externalPath,\\n        uint256 version,\\n        uint256 inR\\n    ) external {\\n        require(externalRouterAllowlist[externalRouter], \\\"Invalid external router\\\");\\n        // Send the user's ROOK to this router\\n        fund.trancheTransferFrom(TRANCHE_R, msg.sender, address(this), inR, version);\\n        bytes memory data =\\n            abi.encode(\\n                fund,\\n                queenSwapOrPrimaryMarketRouter,\\n                minQuote,\\n                recipient,\\n                version,\\n                externalRouter,\\n                externalPath\\n            );\\n        tranchessRouter.getSwap(fund.tokenB(), tokenQuote).buy(version, inR, address(this), data);\\n    }\\n\\n    function tranchessSwapCallback(\\n        uint256 baseOut,\\n        uint256 quoteOut,\\n        bytes calldata data\\n    ) external override {\\n        (\\n            IFundV3 fund,\\n            address queenSwapOrPrimaryMarketRouter,\\n            uint256 expectQuoteAmount,\\n            address recipient,\\n            uint256 version,\\n            ,\\n\\n        ) = abi.decode(data, (IFundV3, address, uint256, address, uint256, address, address[]));\\n        address tokenQuote = IStableSwap(msg.sender).quoteAddress();\\n        require(\\n            msg.sender == address(tranchessRouter.getSwap(tokenQuote, fund.tokenB())),\\n            \\\"Tranchess Pair check failed\\\"\\n        );\\n        if (baseOut > 0) {\\n            uint256 resultAmount;\\n            {\\n                require(quoteOut == 0, \\\"Unidirectional check failed\\\");\\n                uint256 quoteAmount = IStableSwap(msg.sender).getQuoteIn(baseOut);\\n                // Merge BISHOP and ROOK into QUEEN\\n                uint256 outQ =\\n                    IPrimaryMarketV3(fund.primaryMarket()).merge(address(this), baseOut, version);\\n\\n                // Redeem or swap QUEEN for underlying\\n                fund.trancheTransfer(TRANCHE_Q, queenSwapOrPrimaryMarketRouter, outQ, version);\\n                uint256 underlyingAmount =\\n                    IStableSwapCore(queenSwapOrPrimaryMarketRouter).sell(\\n                        version,\\n                        0,\\n                        address(this),\\n                        \\\"\\\"\\n                    );\\n\\n                // Trade underlying for quote asset\\n                uint256 totalQuoteAmount =\\n                    _externalSwap(data, underlyingAmount, fund.tokenUnderlying(), tokenQuote)[1];\\n                // Send back quote asset to tranchess swap\\n                IERC20(tokenQuote).safeTransfer(msg.sender, quoteAmount);\\n                // Send the rest of quote asset to user\\n                resultAmount = totalQuoteAmount.sub(quoteAmount);\\n                require(resultAmount >= expectQuoteAmount, \\\"Insufficient output\\\");\\n                IERC20(tokenQuote).safeTransfer(recipient, resultAmount);\\n            }\\n            emit SwapRook(recipient, baseOut, 0, 0, resultAmount);\\n        } else {\\n            address tokenUnderlying = fund.tokenUnderlying();\\n            // Trade quote asset for underlying asset\\n            uint256 underlyingAmount =\\n                _externalSwap(data, expectQuoteAmount, tokenQuote, tokenUnderlying)[1];\\n\\n            // Create or swap borrowed underlying for QUEEN\\n            IERC20(tokenUnderlying).safeTransfer(queenSwapOrPrimaryMarketRouter, underlyingAmount);\\n            uint256 outQ =\\n                IStableSwapCore(queenSwapOrPrimaryMarketRouter).buy(version, 0, address(this), \\\"\\\");\\n\\n            // Split QUEEN into BISHOP and ROOK\\n            uint256 outB =\\n                IPrimaryMarketV3(fund.primaryMarket()).split(address(this), outQ, version);\\n            // Send back BISHOP to tranchess swap\\n            fund.trancheTransfer(TRANCHE_B, msg.sender, outB, version);\\n            // Send ROOK to user\\n            fund.trancheTransfer(TRANCHE_R, recipient, outB, version);\\n        }\\n    }\\n\\n    function _externalSwap(\\n        bytes memory data,\\n        uint256 amountIn,\\n        address tokenIn,\\n        address tokenOut\\n    ) private returns (uint256[] memory amounts) {\\n        (, , , , , address externalRouter, address[] memory externalPath) =\\n            abi.decode(data, (address, address, uint256, address, uint256, address, address[]));\\n        require(externalPath.length > 1, \\\"Invalid external path\\\");\\n        require(externalPath[0] == tokenIn, \\\"Invalid token in\\\");\\n        require(externalPath[externalPath.length - 1] == tokenOut, \\\"Invalid token out\\\");\\n        IERC20(tokenIn).safeApprove(externalRouter, amountIn);\\n        amounts = IUniswapV2Router01(externalRouter).swapExactTokensForTokens(\\n            amountIn,\\n            0,\\n            externalPath,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/exchange/Staking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\nimport \\\"../../utils/SafeDecimalMath.sol\\\";\\nimport \\\"../../utils/CoreUtility.sol\\\";\\n\\nimport \\\"../interfaces/IFund.sol\\\";\\nimport \\\"../../interfaces/IChessController.sol\\\";\\nimport \\\"../../interfaces/IChessSchedule.sol\\\";\\nimport \\\"../interfaces/ITrancheIndex.sol\\\";\\nimport \\\"../interfaces/IPrimaryMarket.sol\\\";\\n\\nabstract contract Staking is ITrancheIndex, CoreUtility {\\n    /// @dev Reserved storage slots for future sibling contract upgrades\\n    uint256[32] private _reservedSlots;\\n\\n    using Math for uint256;\\n    using SafeMath for uint256;\\n    using SafeDecimalMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    event Deposited(uint256 tranche, address account, uint256 amount);\\n    event Withdrawn(uint256 tranche, address account, uint256 amount);\\n\\n    uint256 private constant MAX_ITERATIONS = 500;\\n\\n    uint256 private constant REWARD_WEIGHT_A = 4;\\n    uint256 private constant REWARD_WEIGHT_B = 2;\\n    uint256 private constant REWARD_WEIGHT_M = 3;\\n\\n    IFund public immutable fund;\\n    IERC20 private immutable tokenM;\\n    IERC20 private immutable tokenA;\\n    IERC20 private immutable tokenB;\\n\\n    /// @notice The Chess release schedule contract.\\n    IChessSchedule public immutable chessSchedule;\\n\\n    uint256 public immutable guardedLaunchStart;\\n\\n    uint256 private _rate;\\n\\n    /// @notice The controller contract.\\n    IChessController public immutable chessController;\\n\\n    /// @notice Quote asset for the exchange. Each exchange only handles one quote asset\\n    address public immutable quoteAssetAddress;\\n\\n    /// @dev Total amount of user shares, i.e. sum of all entries in `_availableBalances` and\\n    ///      `_lockedBalances`. Note that these values can be smaller than the amount of\\n    ///      share tokens held by this contract, because shares locked in unsettled trades\\n    ///      are not included in total supplies or any user's balance.\\n    uint256[TRANCHE_COUNT] private _totalSupplies;\\n\\n    /// @dev Rebalance version of `_totalSupplies`.\\n    uint256 private _totalSupplyVersion;\\n\\n    /// @dev Amount of shares that can be withdrawn or traded by each user.\\n    mapping(address => uint256[TRANCHE_COUNT]) private _availableBalances;\\n\\n    /// @dev Amount of shares that are locked in ask orders.\\n    mapping(address => uint256[TRANCHE_COUNT]) private _lockedBalances;\\n\\n    /// @dev Rebalance version mapping for `_availableBalances`.\\n    mapping(address => uint256) private _balanceVersions;\\n\\n    /// @dev 1e27 * \u222b(rate(t) / totalWeight(t) dt) from the latest rebalance till checkpoint.\\n    uint256 private _invTotalWeightIntegral;\\n\\n    /// @dev Final `_invTotalWeightIntegral` before each rebalance.\\n    ///      These values are accessed in a loop in `_userCheckpoint()` with bounds checking.\\n    ///      So we store them in a fixed-length array, in order to make compiler-generated\\n    ///      bounds checking on every access cheaper. The actual length of this array is stored in\\n    ///      `_historicalIntegralSize` and should be explicitly checked when necessary.\\n    uint256[65535] private _historicalIntegrals;\\n\\n    /// @dev Actual length of the `_historicalIntegrals` array, which always equals to the number of\\n    ///      historical rebalances after `checkpoint()` is called.\\n    uint256 private _historicalIntegralSize;\\n\\n    /// @dev Timestamp when checkpoint() is called.\\n    uint256 private _checkpointTimestamp;\\n\\n    /// @dev Snapshot of `_invTotalWeightIntegral` per user.\\n    mapping(address => uint256) private _userIntegrals;\\n\\n    /// @dev Mapping of account => claimable rewards.\\n    mapping(address => uint256) private _claimableRewards;\\n\\n    constructor(\\n        address fund_,\\n        address chessSchedule_,\\n        address chessController_,\\n        address quoteAssetAddress_,\\n        uint256 guardedLaunchStart_\\n    ) public {\\n        fund = IFund(fund_);\\n        tokenM = IERC20(IFund(fund_).tokenM());\\n        tokenA = IERC20(IFund(fund_).tokenA());\\n        tokenB = IERC20(IFund(fund_).tokenB());\\n        chessSchedule = IChessSchedule(chessSchedule_);\\n        chessController = IChessController(chessController_);\\n        quoteAssetAddress = quoteAssetAddress_;\\n        _checkpointTimestamp = block.timestamp;\\n        guardedLaunchStart = guardedLaunchStart_;\\n\\n        _rate = IChessSchedule(chessSchedule_).getRate(block.timestamp);\\n    }\\n\\n    /// @notice Return weight of given balance with respect to rewards.\\n    /// @param amountM Amount of Token M\\n    /// @param amountA Amount of Token A\\n    /// @param amountB Amount of Token B\\n    /// @return Rewarding weight of the balance\\n    function rewardWeight(\\n        uint256 amountM,\\n        uint256 amountA,\\n        uint256 amountB\\n    ) public pure returns (uint256) {\\n        return\\n            amountM.mul(REWARD_WEIGHT_M).add(amountA.mul(REWARD_WEIGHT_A)).add(\\n                amountB.mul(REWARD_WEIGHT_B)\\n            ) / REWARD_WEIGHT_M;\\n    }\\n\\n    function totalSupply(uint256 tranche) external view returns (uint256) {\\n        uint256 totalSupplyM = _totalSupplies[TRANCHE_M];\\n        uint256 totalSupplyA = _totalSupplies[TRANCHE_A];\\n        uint256 totalSupplyB = _totalSupplies[TRANCHE_B];\\n\\n        uint256 version = _totalSupplyVersion;\\n        uint256 rebalanceSize = fund.getRebalanceSize();\\n        if (version < rebalanceSize) {\\n            (totalSupplyM, totalSupplyA, totalSupplyB) = fund.batchRebalance(\\n                totalSupplyM,\\n                totalSupplyA,\\n                totalSupplyB,\\n                version,\\n                rebalanceSize\\n            );\\n        }\\n\\n        if (tranche == TRANCHE_M) {\\n            return totalSupplyM;\\n        } else if (tranche == TRANCHE_A) {\\n            return totalSupplyA;\\n        } else {\\n            return totalSupplyB;\\n        }\\n    }\\n\\n    function availableBalanceOf(uint256 tranche, address account) external view returns (uint256) {\\n        uint256 amountM = _availableBalances[account][TRANCHE_M];\\n        uint256 amountA = _availableBalances[account][TRANCHE_A];\\n        uint256 amountB = _availableBalances[account][TRANCHE_B];\\n\\n        if (tranche == TRANCHE_M) {\\n            if (amountM == 0 && amountA == 0 && amountB == 0) return 0;\\n        } else if (tranche == TRANCHE_A) {\\n            if (amountA == 0) return 0;\\n        } else {\\n            if (amountB == 0) return 0;\\n        }\\n\\n        uint256 version = _balanceVersions[account];\\n        uint256 rebalanceSize = fund.getRebalanceSize();\\n        if (version < rebalanceSize) {\\n            (amountM, amountA, amountB) = fund.batchRebalance(\\n                amountM,\\n                amountA,\\n                amountB,\\n                version,\\n                rebalanceSize\\n            );\\n        }\\n\\n        if (tranche == TRANCHE_M) {\\n            return amountM;\\n        } else if (tranche == TRANCHE_A) {\\n            return amountA;\\n        } else {\\n            return amountB;\\n        }\\n    }\\n\\n    function lockedBalanceOf(uint256 tranche, address account) external view returns (uint256) {\\n        uint256 amountM = _lockedBalances[account][TRANCHE_M];\\n        uint256 amountA = _lockedBalances[account][TRANCHE_A];\\n        uint256 amountB = _lockedBalances[account][TRANCHE_B];\\n\\n        if (tranche == TRANCHE_M) {\\n            if (amountM == 0 && amountA == 0 && amountB == 0) return 0;\\n        } else if (tranche == TRANCHE_A) {\\n            if (amountA == 0) return 0;\\n        } else {\\n            if (amountB == 0) return 0;\\n        }\\n\\n        uint256 version = _balanceVersions[account];\\n        uint256 rebalanceSize = fund.getRebalanceSize();\\n        if (version < rebalanceSize) {\\n            (amountM, amountA, amountB) = fund.batchRebalance(\\n                amountM,\\n                amountA,\\n                amountB,\\n                version,\\n                rebalanceSize\\n            );\\n        }\\n\\n        if (tranche == TRANCHE_M) {\\n            return amountM;\\n        } else if (tranche == TRANCHE_A) {\\n            return amountA;\\n        } else {\\n            return amountB;\\n        }\\n    }\\n\\n    function balanceVersion(address account) external view returns (uint256) {\\n        return _balanceVersions[account];\\n    }\\n\\n    /// @dev Deposit to get rewards\\n    /// @param tranche Tranche of the share\\n    /// @param amount The amount to deposit\\n    function deposit(uint256 tranche, uint256 amount) public {\\n        uint256 rebalanceSize = fund.getRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(msg.sender, rebalanceSize);\\n        if (tranche == TRANCHE_M) {\\n            tokenM.safeTransferFrom(msg.sender, address(this), amount);\\n        } else if (tranche == TRANCHE_A) {\\n            tokenA.safeTransferFrom(msg.sender, address(this), amount);\\n        } else {\\n            tokenB.safeTransferFrom(msg.sender, address(this), amount);\\n        }\\n        _availableBalances[msg.sender][tranche] = _availableBalances[msg.sender][tranche].add(\\n            amount\\n        );\\n        _totalSupplies[tranche] = _totalSupplies[tranche].add(amount);\\n\\n        emit Deposited(tranche, msg.sender, amount);\\n    }\\n\\n    /// @dev Claim settled Token M from the primary market and deposit to get rewards\\n    /// @param primaryMarket The primary market to claim shares from\\n    function claimAndDeposit(address primaryMarket) external {\\n        (uint256 createdShares, ) = IPrimaryMarket(primaryMarket).claim(msg.sender);\\n        deposit(TRANCHE_M, createdShares);\\n    }\\n\\n    /// @dev Withdraw\\n    /// @param tranche Tranche of the share\\n    /// @param amount The amount to deposit\\n    function withdraw(uint256 tranche, uint256 amount) external {\\n        uint256 rebalanceSize = fund.getRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(msg.sender, rebalanceSize);\\n        _availableBalances[msg.sender][tranche] = _availableBalances[msg.sender][tranche].sub(\\n            amount,\\n            \\\"Insufficient balance to withdraw\\\"\\n        );\\n        _totalSupplies[tranche] = _totalSupplies[tranche].sub(amount);\\n        if (tranche == TRANCHE_M) {\\n            tokenM.safeTransfer(msg.sender, amount);\\n        } else if (tranche == TRANCHE_A) {\\n            tokenA.safeTransfer(msg.sender, amount);\\n        } else {\\n            tokenB.safeTransfer(msg.sender, amount);\\n        }\\n\\n        emit Withdrawn(tranche, msg.sender, amount);\\n    }\\n\\n    /// @notice Transform share balance to a given rebalance version, or to the latest version\\n    ///         if `targetVersion` is zero.\\n    /// @param account Account of the balance to rebalance\\n    /// @param targetVersion The target rebalance version, or zero for the latest version\\n    function refreshBalance(address account, uint256 targetVersion) external {\\n        uint256 rebalanceSize = fund.getRebalanceSize();\\n        if (targetVersion == 0) {\\n            targetVersion = rebalanceSize;\\n        } else {\\n            require(targetVersion <= rebalanceSize, \\\"Target version out of bound\\\");\\n        }\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(account, targetVersion);\\n    }\\n\\n    /// @notice Return claimable rewards of an account till now.\\n    ///\\n    ///         This function should be call as a \\\"view\\\" function off-chain to get\\n    ///         the return value, e.g. using `contract.claimableRewards.call(account)` in web3\\n    ///         or `contract.callStatic.claimableRewards(account)` in ethers.js.\\n    /// @param account Address of an account\\n    /// @return Amount of claimable rewards\\n    function claimableRewards(address account) external returns (uint256) {\\n        uint256 rebalanceSize = fund.getRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(account, rebalanceSize);\\n        return _claimableRewards[account];\\n    }\\n\\n    /// @notice Claim the rewards for an account.\\n    /// @param account Account to claim its rewards\\n    function claimRewards(address account) external {\\n        require(\\n            block.timestamp >= guardedLaunchStart + 15 days,\\n            \\\"Cannot claim during guarded launch\\\"\\n        );\\n        uint256 rebalanceSize = fund.getRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(account, rebalanceSize);\\n        _claim(account);\\n    }\\n\\n    /// @dev Transfer shares from the sender to the contract internally\\n    /// @param tranche Tranche of the share\\n    /// @param sender Sender address\\n    /// @param amount The amount to transfer\\n    function _tradeAvailable(\\n        uint256 tranche,\\n        address sender,\\n        uint256 amount\\n    ) internal {\\n        uint256 rebalanceSize = fund.getRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(sender, rebalanceSize);\\n        _availableBalances[sender][tranche] = _availableBalances[sender][tranche].sub(amount);\\n        _totalSupplies[tranche] = _totalSupplies[tranche].sub(amount);\\n    }\\n\\n    function _rebalanceAndClearTrade(\\n        address account,\\n        uint256 amountM,\\n        uint256 amountA,\\n        uint256 amountB,\\n        uint256 amountVersion\\n    )\\n        internal\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256 rebalanceSize = fund.getRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(account, rebalanceSize);\\n        if (amountVersion < rebalanceSize) {\\n            (amountM, amountA, amountB) = fund.batchRebalance(\\n                amountM,\\n                amountA,\\n                amountB,\\n                amountVersion,\\n                rebalanceSize\\n            );\\n        }\\n        uint256[TRANCHE_COUNT] storage available = _availableBalances[account];\\n        if (amountM > 0) {\\n            available[TRANCHE_M] = available[TRANCHE_M].add(amountM);\\n            _totalSupplies[TRANCHE_M] = _totalSupplies[TRANCHE_M].add(amountM);\\n        }\\n        if (amountA > 0) {\\n            available[TRANCHE_A] = available[TRANCHE_A].add(amountA);\\n            _totalSupplies[TRANCHE_A] = _totalSupplies[TRANCHE_A].add(amountA);\\n        }\\n        if (amountB > 0) {\\n            available[TRANCHE_B] = available[TRANCHE_B].add(amountB);\\n            _totalSupplies[TRANCHE_B] = _totalSupplies[TRANCHE_B].add(amountB);\\n        }\\n        return (amountM, amountA, amountB);\\n    }\\n\\n    function _lock(\\n        uint256 tranche,\\n        address account,\\n        uint256 amount\\n    ) internal {\\n        uint256 rebalanceSize = fund.getRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(account, rebalanceSize);\\n        _availableBalances[account][tranche] = _availableBalances[account][tranche].sub(\\n            amount,\\n            \\\"Insufficient balance to lock\\\"\\n        );\\n        _lockedBalances[account][tranche] = _lockedBalances[account][tranche].add(amount);\\n    }\\n\\n    function _rebalanceAndUnlock(\\n        address account,\\n        uint256 amountM,\\n        uint256 amountA,\\n        uint256 amountB,\\n        uint256 amountVersion\\n    ) internal {\\n        uint256 rebalanceSize = fund.getRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(account, rebalanceSize);\\n        if (amountVersion < rebalanceSize) {\\n            (amountM, amountA, amountB) = fund.batchRebalance(\\n                amountM,\\n                amountA,\\n                amountB,\\n                amountVersion,\\n                rebalanceSize\\n            );\\n        }\\n        uint256[TRANCHE_COUNT] storage available = _availableBalances[account];\\n        uint256[TRANCHE_COUNT] storage locked = _lockedBalances[account];\\n        if (amountM > 0) {\\n            available[TRANCHE_M] = available[TRANCHE_M].add(amountM);\\n            locked[TRANCHE_M] = locked[TRANCHE_M].sub(amountM);\\n        }\\n        if (amountA > 0) {\\n            available[TRANCHE_A] = available[TRANCHE_A].add(amountA);\\n            locked[TRANCHE_A] = locked[TRANCHE_A].sub(amountA);\\n        }\\n        if (amountB > 0) {\\n            available[TRANCHE_B] = available[TRANCHE_B].add(amountB);\\n            locked[TRANCHE_B] = locked[TRANCHE_B].sub(amountB);\\n        }\\n    }\\n\\n    function _tradeLocked(\\n        uint256 tranche,\\n        address account,\\n        uint256 amount\\n    ) internal {\\n        uint256 rebalanceSize = fund.getRebalanceSize();\\n        _checkpoint(rebalanceSize);\\n        _userCheckpoint(account, rebalanceSize);\\n        _lockedBalances[account][tranche] = _lockedBalances[account][tranche].sub(amount);\\n        _totalSupplies[tranche] = _totalSupplies[tranche].sub(amount);\\n    }\\n\\n    /// @dev Transfer claimable rewards to an account. Rewards since the last user checkpoint\\n    ///      is not included. This function should always be called after `_userCheckpoint()`,\\n    ///      in order for the user to get all rewards till now.\\n    /// @param account Address of the account\\n    function _claim(address account) internal {\\n        chessSchedule.mint(account, _claimableRewards[account]);\\n        _claimableRewards[account] = 0;\\n    }\\n\\n    /// @dev Transform total supplies to the latest rebalance version and make a global reward checkpoint.\\n    /// @param rebalanceSize The number of existing rebalances. It must be the same as\\n    ///                       `fund.getRebalanceSize()`.\\n    function _checkpoint(uint256 rebalanceSize) private {\\n        uint256 timestamp = _checkpointTimestamp;\\n        if (timestamp >= block.timestamp) {\\n            return;\\n        }\\n\\n        uint256 integral = _invTotalWeightIntegral;\\n        uint256 endWeek = _endOfWeek(timestamp);\\n        uint256 weeklyPercentage =\\n            chessController.getFundRelativeWeight(address(this), endWeek - 1 weeks);\\n        uint256 version = _totalSupplyVersion;\\n        uint256 rebalanceTimestamp;\\n        if (version < rebalanceSize) {\\n            rebalanceTimestamp = fund.getRebalanceTimestamp(version);\\n        } else {\\n            rebalanceTimestamp = type(uint256).max;\\n        }\\n        uint256 rate = _rate;\\n        uint256 totalSupplyM = _totalSupplies[TRANCHE_M];\\n        uint256 totalSupplyA = _totalSupplies[TRANCHE_A];\\n        uint256 totalSupplyB = _totalSupplies[TRANCHE_B];\\n        uint256 weight = rewardWeight(totalSupplyM, totalSupplyA, totalSupplyB);\\n        uint256 timestamp_ = timestamp; // avoid stack too deep\\n\\n        for (uint256 i = 0; i < MAX_ITERATIONS && timestamp_ < block.timestamp; i++) {\\n            uint256 endTimestamp = rebalanceTimestamp.min(endWeek).min(block.timestamp);\\n\\n            if (weight > 0) {\\n                integral = integral.add(\\n                    rate\\n                        .mul(endTimestamp.sub(timestamp_))\\n                        .multiplyDecimal(weeklyPercentage)\\n                        .divideDecimalPrecise(weight)\\n                );\\n            }\\n\\n            if (endTimestamp == rebalanceTimestamp) {\\n                uint256 oldSize = _historicalIntegralSize;\\n                _historicalIntegrals[oldSize] = integral;\\n                _historicalIntegralSize = oldSize + 1;\\n\\n                integral = 0;\\n                (totalSupplyM, totalSupplyA, totalSupplyB) = fund.doRebalance(\\n                    totalSupplyM,\\n                    totalSupplyA,\\n                    totalSupplyB,\\n                    version\\n                );\\n\\n                version++;\\n                weight = rewardWeight(totalSupplyM, totalSupplyA, totalSupplyB);\\n\\n                if (version < rebalanceSize) {\\n                    rebalanceTimestamp = fund.getRebalanceTimestamp(version);\\n                } else {\\n                    rebalanceTimestamp = type(uint256).max;\\n                }\\n            }\\n            if (endTimestamp == endWeek) {\\n                rate = chessSchedule.getRate(endWeek);\\n                weeklyPercentage = chessController.getFundRelativeWeight(address(this), endWeek);\\n                endWeek += 1 weeks;\\n            }\\n\\n            timestamp_ = endTimestamp;\\n        }\\n\\n        _checkpointTimestamp = block.timestamp;\\n        _invTotalWeightIntegral = integral;\\n        if (_rate != rate) {\\n            _rate = rate;\\n        }\\n        if (_totalSupplyVersion != rebalanceSize) {\\n            _totalSupplies[TRANCHE_M] = totalSupplyM;\\n            _totalSupplies[TRANCHE_A] = totalSupplyA;\\n            _totalSupplies[TRANCHE_B] = totalSupplyB;\\n            _totalSupplyVersion = rebalanceSize;\\n        }\\n    }\\n\\n    /// @dev Transform a user's balance to a given rebalance version and update this user's rewards.\\n    ///\\n    ///      In most cases, the target version is the latest version and this function cumulates\\n    ///      rewards till now. When this function is called from `refreshBalance()`,\\n    ///      `targetVersion` can be an older version, in which case rewards are cumulated till\\n    ///      the end of that version (i.e. timestamp of the transaction triggering the rebalance\\n    ///      with index `targetVersion`).\\n    ///\\n    ///      This function should always be called after `_checkpoint()` is called, so that\\n    ///      the global reward checkpoint is guarenteed up to date.\\n    /// @param account Account to update\\n    /// @param targetVersion The target rebalance version\\n    function _userCheckpoint(address account, uint256 targetVersion) private {\\n        uint256 oldVersion = _balanceVersions[account];\\n        if (oldVersion > targetVersion) {\\n            return;\\n        }\\n        uint256 userIntegral = _userIntegrals[account];\\n        uint256 integral;\\n        // This scope is to avoid the \\\"stack too deep\\\" error.\\n        {\\n            // We assume that this function is always called immediately after `_checkpoint()`,\\n            // which guarantees that `_historicalIntegralSize` equals to the number of historical\\n            // rebalances.\\n            uint256 rebalanceSize = _historicalIntegralSize;\\n            integral = targetVersion == rebalanceSize\\n                ? _invTotalWeightIntegral\\n                : _historicalIntegrals[targetVersion];\\n        }\\n        if (userIntegral == integral && oldVersion == targetVersion) {\\n            // Return immediately when the user's rewards have already been updated to\\n            // the target version.\\n            return;\\n        }\\n\\n        uint256[TRANCHE_COUNT] storage available = _availableBalances[account];\\n        uint256[TRANCHE_COUNT] storage locked = _lockedBalances[account];\\n        uint256 availableM = available[TRANCHE_M];\\n        uint256 availableA = available[TRANCHE_A];\\n        uint256 availableB = available[TRANCHE_B];\\n        uint256 lockedM = locked[TRANCHE_M];\\n        uint256 lockedA = locked[TRANCHE_A];\\n        uint256 lockedB = locked[TRANCHE_B];\\n        uint256 rewards = _claimableRewards[account];\\n        for (uint256 i = oldVersion; i < targetVersion; i++) {\\n            uint256 weight =\\n                rewardWeight(\\n                    availableM.add(lockedM),\\n                    availableA.add(lockedA),\\n                    availableB.add(lockedB)\\n                );\\n            rewards = rewards.add(\\n                weight.multiplyDecimalPrecise(_historicalIntegrals[i].sub(userIntegral))\\n            );\\n            if (availableM != 0 || availableA != 0 || availableB != 0) {\\n                (availableM, availableA, availableB) = fund.doRebalance(\\n                    availableM,\\n                    availableA,\\n                    availableB,\\n                    i\\n                );\\n            }\\n            if (lockedM != 0 || lockedA != 0 || lockedB != 0) {\\n                (lockedM, lockedA, lockedB) = fund.doRebalance(lockedM, lockedA, lockedB, i);\\n            }\\n            userIntegral = 0;\\n        }\\n        uint256 weight =\\n            rewardWeight(availableM.add(lockedM), availableA.add(lockedA), availableB.add(lockedB));\\n        rewards = rewards.add(weight.multiplyDecimalPrecise(integral.sub(userIntegral)));\\n        address account_ = account; // Fix the \\\"stack too deep\\\" error\\n        _claimableRewards[account_] = rewards;\\n        _userIntegrals[account_] = integral;\\n\\n        if (oldVersion < targetVersion) {\\n            if (available[TRANCHE_M] != availableM) {\\n                available[TRANCHE_M] = availableM;\\n            }\\n            if (available[TRANCHE_A] != availableA) {\\n                available[TRANCHE_A] = availableA;\\n            }\\n            if (available[TRANCHE_B] != availableB) {\\n                available[TRANCHE_B] = availableB;\\n            }\\n            if (locked[TRANCHE_M] != lockedM) {\\n                locked[TRANCHE_M] = lockedM;\\n            }\\n            if (locked[TRANCHE_A] != lockedA) {\\n                locked[TRANCHE_A] = lockedA;\\n            }\\n            if (locked[TRANCHE_B] != lockedB) {\\n                locked[TRANCHE_B] = lockedB;\\n            }\\n            _balanceVersions[account_] = targetVersion;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/test/StakingTestWrapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"../exchange/Staking.sol\\\";\\n\\ncontract StakingTestWrapper is Staking {\\n    constructor(\\n        address fund_,\\n        address chessSchedule_,\\n        address chessController_,\\n        address quoteAssetAddress_,\\n        uint256 guardedLaunchStart_\\n    )\\n        public\\n        Staking(fund_, chessSchedule_, chessController_, quoteAssetAddress_, guardedLaunchStart_)\\n    {}\\n\\n    function tradeAvailable(\\n        uint256 tranche,\\n        address sender,\\n        uint256 amount\\n    ) external {\\n        _tradeAvailable(tranche, sender, amount);\\n    }\\n\\n    function rebalanceAndClearTrade(\\n        address account,\\n        uint256 amountM,\\n        uint256 amountA,\\n        uint256 amountB,\\n        uint256 amountVersion\\n    ) external {\\n        _rebalanceAndClearTrade(account, amountM, amountA, amountB, amountVersion);\\n    }\\n\\n    function lock(\\n        uint256 tranche,\\n        address account,\\n        uint256 amount\\n    ) external {\\n        _lock(tranche, account, amount);\\n    }\\n\\n    function rebalanceAndUnlock(\\n        address account,\\n        uint256 amountM,\\n        uint256 amountA,\\n        uint256 amountB,\\n        uint256 amountVersion\\n    ) external {\\n        _rebalanceAndUnlock(account, amountM, amountA, amountB, amountVersion);\\n    }\\n\\n    function tradeLocked(\\n        uint256 tranche,\\n        address account,\\n        uint256 amount\\n    ) external {\\n        _tradeLocked(tranche, account, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/test/StakingV2TestWrapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../exchange/StakingV2.sol\\\";\\n\\ncontract StakingV2TestWrapper is StakingV2 {\\n    constructor(\\n        address fund_,\\n        address chessSchedule_,\\n        address chessController_,\\n        address quoteAssetAddress_,\\n        uint256 guardedLaunchStart_,\\n        address votingEscrow_\\n    )\\n        public\\n        StakingV2(\\n            fund_,\\n            chessSchedule_,\\n            chessController_,\\n            quoteAssetAddress_,\\n            guardedLaunchStart_,\\n            votingEscrow_\\n        )\\n    {}\\n\\n    function initialize() external {\\n        _initializeStaking();\\n        _initializeStakingV2(msg.sender);\\n    }\\n\\n    function tradeAvailable(\\n        uint256 tranche,\\n        address sender,\\n        uint256 amount\\n    ) external {\\n        _tradeAvailable(tranche, sender, amount);\\n    }\\n\\n    function rebalanceAndClearTrade(\\n        address account,\\n        uint256 amountM,\\n        uint256 amountA,\\n        uint256 amountB,\\n        uint256 amountVersion\\n    ) external {\\n        _rebalanceAndClearTrade(account, amountM, amountA, amountB, amountVersion);\\n    }\\n\\n    function lock(\\n        uint256 tranche,\\n        address account,\\n        uint256 amount\\n    ) external {\\n        _lock(tranche, account, amount);\\n    }\\n\\n    function rebalanceAndUnlock(\\n        address account,\\n        uint256 amountM,\\n        uint256 amountA,\\n        uint256 amountB,\\n        uint256 amountVersion\\n    ) external {\\n        _rebalanceAndUnlock(account, amountM, amountA, amountB, amountVersion);\\n    }\\n\\n    function tradeLocked(\\n        uint256 tranche,\\n        address account,\\n        uint256 amount\\n    ) external {\\n        _tradeLocked(tranche, account, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/fund/Share.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"../interfaces/IFund.sol\\\";\\n\\ncontract Share is IERC20 {\\n    uint8 public constant decimals = 18;\\n\\n    string public name;\\n    string public symbol;\\n    uint256 private immutable _tranche;\\n\\n    IFund public fund;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * _tranche is immutable: it can only be set once during construction.\\n     */\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        address fund_,\\n        uint256 tranche_\\n    ) public {\\n        name = name_;\\n        symbol = symbol_;\\n        fund = IFund(fund_);\\n        _tranche = tranche_;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() external view override returns (uint256) {\\n        return fund.shareTotalSupply(_tranche);\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) external view override returns (uint256) {\\n        return fund.shareBalanceOf(_tranche, account);\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\\n        fund.transfer(_tranche, msg.sender, recipient, amount);\\n        emit Transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) external view override returns (uint256) {\\n        return fund.shareAllowance(_tranche, owner, spender);\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) external override returns (bool) {\\n        fund.approve(_tranche, msg.sender, spender, amount);\\n        emit Approval(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external override returns (bool) {\\n        uint256 newAllowance = fund.transferFrom(_tranche, msg.sender, sender, recipient, amount);\\n        emit Transfer(sender, recipient, amount);\\n        emit Approval(sender, msg.sender, newAllowance);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {\\n        uint256 newAllowance = fund.increaseAllowance(_tranche, msg.sender, spender, addedValue);\\n        emit Approval(msg.sender, spender, newAllowance);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {\\n        uint256 newAllowance =\\n            fund.decreaseAllowance(_tranche, msg.sender, spender, subtractedValue);\\n        emit Approval(msg.sender, spender, newAllowance);\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/exchange/Exchange.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\nimport \\\"../../utils/SafeDecimalMath.sol\\\";\\n\\nimport {Order, OrderQueue, LibOrderQueue} from \\\"./LibOrderQueue.sol\\\";\\nimport {\\n    UnsettledBuyTrade,\\n    UnsettledSellTrade,\\n    UnsettledTrade,\\n    LibUnsettledBuyTrade,\\n    LibUnsettledSellTrade\\n} from \\\"./LibUnsettledTrade.sol\\\";\\n\\nimport \\\"./ExchangeRoles.sol\\\";\\nimport \\\"./Staking.sol\\\";\\n\\n/// @title Tranchess's Exchange Contract\\n/// @notice A decentralized exchange to match premium-discount orders and clear trades\\n/// @author Tranchess\\ncontract Exchange is ExchangeRoles, Staking {\\n    /// @dev Reserved storage slots for future base contract upgrades\\n    uint256[32] private _reservedSlots;\\n\\n    using SafeDecimalMath for uint256;\\n    using LibOrderQueue for OrderQueue;\\n    using SafeERC20 for IERC20;\\n    using LibUnsettledBuyTrade for UnsettledBuyTrade;\\n    using LibUnsettledSellTrade for UnsettledSellTrade;\\n\\n    /// @notice A maker bid order is placed.\\n    /// @param maker Account placing the order\\n    /// @param tranche Tranche of the share to buy\\n    /// @param pdLevel Premium-discount level\\n    /// @param quoteAmount Amount of quote asset in the order, rounding precision to 18\\n    ///                    for quote assets with precision other than 18 decimal places\\n    /// @param version The latest rebalance version when the order is placed\\n    /// @param orderIndex Index of the order in the order queue\\n    event BidOrderPlaced(\\n        address indexed maker,\\n        uint256 indexed tranche,\\n        uint256 pdLevel,\\n        uint256 quoteAmount,\\n        uint256 version,\\n        uint256 orderIndex\\n    );\\n\\n    /// @notice A maker ask order is placed.\\n    /// @param maker Account placing the order\\n    /// @param tranche Tranche of the share to sell\\n    /// @param pdLevel Premium-discount level\\n    /// @param baseAmount Amount of base asset in the order\\n    /// @param version The latest rebalance version when the order is placed\\n    /// @param orderIndex Index of the order in the order queue\\n    event AskOrderPlaced(\\n        address indexed maker,\\n        uint256 indexed tranche,\\n        uint256 pdLevel,\\n        uint256 baseAmount,\\n        uint256 version,\\n        uint256 orderIndex\\n    );\\n\\n    /// @notice A maker bid order is canceled.\\n    /// @param maker Account placing the order\\n    /// @param tranche Tranche of the share\\n    /// @param pdLevel Premium-discount level\\n    /// @param quoteAmount Original amount of quote asset in the order, rounding precision to 18\\n    ///                    for quote assets with precision other than 18 decimal places\\n    /// @param version The latest rebalance version when the order is placed\\n    /// @param orderIndex Index of the order in the order queue\\n    /// @param fillable Unfilled amount when the order is canceled, rounding precision to 18 for\\n    ///                 quote assets with precision other than 18 decimal places\\n    event BidOrderCanceled(\\n        address indexed maker,\\n        uint256 indexed tranche,\\n        uint256 pdLevel,\\n        uint256 quoteAmount,\\n        uint256 version,\\n        uint256 orderIndex,\\n        uint256 fillable\\n    );\\n\\n    /// @notice A maker ask order is canceled.\\n    /// @param maker Account placing the order\\n    /// @param tranche Tranche of the share to sell\\n    /// @param pdLevel Premium-discount level\\n    /// @param baseAmount Original amount of base asset in the order\\n    /// @param version The latest rebalance version when the order is placed\\n    /// @param orderIndex Index of the order in the order queue\\n    /// @param fillable Unfilled amount when the order is canceled\\n    event AskOrderCanceled(\\n        address indexed maker,\\n        uint256 indexed tranche,\\n        uint256 pdLevel,\\n        uint256 baseAmount,\\n        uint256 version,\\n        uint256 orderIndex,\\n        uint256 fillable\\n    );\\n\\n    /// @notice Matching result of a taker bid order.\\n    /// @param taker Account placing the order\\n    /// @param tranche Tranche of the share\\n    /// @param quoteAmount Matched amount of quote asset, rounding precision to 18 for quote assets\\n    ///                    with precision other than 18 decimal places\\n    /// @param version Rebalance version of this trade\\n    /// @param lastMatchedPDLevel Premium-discount level of the last matched maker order\\n    /// @param lastMatchedOrderIndex Index of the last matched maker order in its order queue\\n    /// @param lastMatchedBaseAmount Matched base asset amount of the last matched maker order\\n    event BuyTrade(\\n        address indexed taker,\\n        uint256 indexed tranche,\\n        uint256 quoteAmount,\\n        uint256 version,\\n        uint256 lastMatchedPDLevel,\\n        uint256 lastMatchedOrderIndex,\\n        uint256 lastMatchedBaseAmount\\n    );\\n\\n    /// @notice Matching result of a taker ask order.\\n    /// @param taker Account placing the order\\n    /// @param tranche Tranche of the share\\n    /// @param baseAmount Matched amount of base asset\\n    /// @param version Rebalance version of this trade\\n    /// @param lastMatchedPDLevel Premium-discount level of the last matched maker order\\n    /// @param lastMatchedOrderIndex Index of the last matched maker order in its order queue\\n    /// @param lastMatchedQuoteAmount Matched quote asset amount of the last matched maker order,\\n    ///                               rounding precision to 18 for quote assets with precision\\n    ///                               other than 18 decimal places\\n    event SellTrade(\\n        address indexed taker,\\n        uint256 indexed tranche,\\n        uint256 baseAmount,\\n        uint256 version,\\n        uint256 lastMatchedPDLevel,\\n        uint256 lastMatchedOrderIndex,\\n        uint256 lastMatchedQuoteAmount\\n    );\\n\\n    /// @notice Settlement of unsettled trades of maker orders.\\n    /// @param account Account placing the related maker orders\\n    /// @param epoch Epoch of the settled trades\\n    /// @param amountM Amount of Token M added to the account's available balance\\n    /// @param amountA Amount of Token A added to the account's available balance\\n    /// @param amountB Amount of Token B added to the account's available balance\\n    /// @param quoteAmount Amount of quote asset transfered to the account, rounding precision to 18\\n    ///                    for quote assets with precision other than 18 decimal places\\n    event MakerSettled(\\n        address indexed account,\\n        uint256 epoch,\\n        uint256 amountM,\\n        uint256 amountA,\\n        uint256 amountB,\\n        uint256 quoteAmount\\n    );\\n\\n    /// @notice Settlement of unsettled trades of taker orders.\\n    /// @param account Account placing the related taker orders\\n    /// @param epoch Epoch of the settled trades\\n    /// @param amountM Amount of Token M added to the account's available balance\\n    /// @param amountA Amount of Token A added to the account's available balance\\n    /// @param amountB Amount of Token B added to the account's available balance\\n    /// @param quoteAmount Amount of quote asset transfered to the account, rounding precision to 18\\n    ///                    for quote assets with precision other than 18 decimal places\\n    event TakerSettled(\\n        address indexed account,\\n        uint256 epoch,\\n        uint256 amountM,\\n        uint256 amountA,\\n        uint256 amountB,\\n        uint256 quoteAmount\\n    );\\n\\n    uint256 private constant EPOCH = 30 minutes; // An exchange epoch is 30 minutes long\\n\\n    /// @dev Maker reserves 110% of the asset they want to trade, which would stop\\n    ///      losses for makers when the net asset values turn out volatile\\n    uint256 private constant MAKER_RESERVE_RATIO = 1.1e18;\\n\\n    /// @dev Premium-discount level ranges from -10% to 10% with 0.25% as step size\\n    uint256 private constant PD_TICK = 0.0025e18;\\n\\n    uint256 private constant MIN_PD = 0.9e18;\\n    uint256 private constant MAX_PD = 1.1e18;\\n    uint256 private constant PD_START = MIN_PD - PD_TICK;\\n    uint256 private constant PD_LEVEL_COUNT = (MAX_PD - MIN_PD) / PD_TICK + 1;\\n\\n    /// @notice Minumum quote amount of maker bid orders with 18 decimal places\\n    uint256 public immutable minBidAmount;\\n\\n    /// @notice Minumum base amount of maker ask orders\\n    uint256 public immutable minAskAmount;\\n\\n    /// @notice Minumum base or quote amount of maker orders during guarded launch\\n    uint256 public immutable guardedLaunchMinOrderAmount;\\n\\n    /// @dev A multipler that normalizes a quote asset balance to 18 decimal places.\\n    uint256 private immutable _quoteDecimalMultiplier;\\n\\n    /// @notice Mapping of rebalance version => tranche => an array of order queues\\n    mapping(uint256 => mapping(uint256 => OrderQueue[PD_LEVEL_COUNT + 1])) public bids;\\n    mapping(uint256 => mapping(uint256 => OrderQueue[PD_LEVEL_COUNT + 1])) public asks;\\n\\n    /// @notice Mapping of rebalance version => best bid premium-discount level of the three tranches.\\n    ///         Zero indicates that there is no bid order.\\n    mapping(uint256 => uint256[TRANCHE_COUNT]) public bestBids;\\n\\n    /// @notice Mapping of rebalance version => best ask premium-discount level of the three tranches.\\n    ///         Zero or `PD_LEVEL_COUNT + 1` indicates that there is no ask order.\\n    mapping(uint256 => uint256[TRANCHE_COUNT]) public bestAsks;\\n\\n    /// @notice Mapping of account => tranche => epoch => unsettled trade\\n    mapping(address => mapping(uint256 => mapping(uint256 => UnsettledTrade)))\\n        public unsettledTrades;\\n\\n    /// @dev Mapping of epoch => rebalance version\\n    mapping(uint256 => uint256) private _epochVersions;\\n\\n    constructor(\\n        address fund_,\\n        address chessSchedule_,\\n        address chessController_,\\n        address quoteAssetAddress_,\\n        uint256 quoteDecimals_,\\n        address votingEscrow_,\\n        uint256 minBidAmount_,\\n        uint256 minAskAmount_,\\n        uint256 makerRequirement_,\\n        uint256 guardedLaunchStart_,\\n        uint256 guardedLaunchMinOrderAmount_\\n    )\\n        public\\n        ExchangeRoles(votingEscrow_, makerRequirement_)\\n        Staking(fund_, chessSchedule_, chessController_, quoteAssetAddress_, guardedLaunchStart_)\\n    {\\n        minBidAmount = minBidAmount_;\\n        minAskAmount = minAskAmount_;\\n        guardedLaunchMinOrderAmount = guardedLaunchMinOrderAmount_;\\n        require(quoteDecimals_ <= 18, \\\"Quote asset decimals larger than 18\\\");\\n        _quoteDecimalMultiplier = 10**(18 - quoteDecimals_);\\n    }\\n\\n    /// @notice Return end timestamp of the epoch containing a given timestamp.\\n    /// @param timestamp Timestamp within a given epoch\\n    /// @return The closest ending timestamp\\n    function endOfEpoch(uint256 timestamp) public pure returns (uint256) {\\n        return (timestamp / EPOCH) * EPOCH + EPOCH;\\n    }\\n\\n    function getBidOrder(\\n        uint256 version,\\n        uint256 tranche,\\n        uint256 pdLevel,\\n        uint256 index\\n    )\\n        external\\n        view\\n        returns (\\n            address maker,\\n            uint256 amount,\\n            uint256 fillable\\n        )\\n    {\\n        Order storage order = bids[version][tranche][pdLevel].list[index];\\n        maker = order.maker;\\n        amount = order.amount;\\n        fillable = order.fillable;\\n    }\\n\\n    function getAskOrder(\\n        uint256 version,\\n        uint256 tranche,\\n        uint256 pdLevel,\\n        uint256 index\\n    )\\n        external\\n        view\\n        returns (\\n            address maker,\\n            uint256 amount,\\n            uint256 fillable\\n        )\\n    {\\n        Order storage order = asks[version][tranche][pdLevel].list[index];\\n        maker = order.maker;\\n        amount = order.amount;\\n        fillable = order.fillable;\\n    }\\n\\n    /// @notice Get all tranches' net asset values of a given time\\n    /// @param timestamp Timestamp of the net asset value\\n    /// @return estimatedNavM Token M's net asset value\\n    /// @return estimatedNavA Token A's net asset value\\n    /// @return estimatedNavB Token B's net asset value\\n    function estimateNavs(uint256 timestamp)\\n        public\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256 price = fund.twapOracle().getTwap(timestamp);\\n        require(price != 0, \\\"Price is not available\\\");\\n        return fund.extrapolateNav(timestamp, price);\\n    }\\n\\n    /// @notice Place a bid order for makers\\n    /// @param tranche Tranche of the base asset\\n    /// @param pdLevel Premium-discount level\\n    /// @param quoteAmount Quote asset amount with 18 decimal places\\n    /// @param version Current rebalance version. Revert if it is not the latest version.\\n    function placeBid(\\n        uint256 tranche,\\n        uint256 pdLevel,\\n        uint256 quoteAmount,\\n        uint256 version\\n    ) external onlyMaker {\\n        require(block.timestamp >= guardedLaunchStart + 8 days, \\\"Guarded launch: market closed\\\");\\n        if (block.timestamp < guardedLaunchStart + 4 weeks) {\\n            require(quoteAmount >= guardedLaunchMinOrderAmount, \\\"Guarded launch: amount too low\\\");\\n        } else {\\n            require(quoteAmount >= minBidAmount, \\\"Quote amount too low\\\");\\n        }\\n        uint256 bestAsk = bestAsks[version][tranche];\\n        require(\\n            pdLevel > 0 && pdLevel < (bestAsk == 0 ? PD_LEVEL_COUNT + 1 : bestAsk),\\n            \\\"Invalid premium-discount level\\\"\\n        );\\n        require(version == fund.getRebalanceSize(), \\\"Invalid version\\\");\\n\\n        _transferQuoteFrom(msg.sender, quoteAmount);\\n\\n        uint256 index = bids[version][tranche][pdLevel].append(msg.sender, quoteAmount, version);\\n        if (bestBids[version][tranche] < pdLevel) {\\n            bestBids[version][tranche] = pdLevel;\\n        }\\n\\n        emit BidOrderPlaced(msg.sender, tranche, pdLevel, quoteAmount, version, index);\\n    }\\n\\n    /// @notice Place an ask order for makers\\n    /// @param tranche Tranche of the base asset\\n    /// @param pdLevel Premium-discount level\\n    /// @param baseAmount Base asset amount\\n    /// @param version Current rebalance version. Revert if it is not the latest version.\\n    function placeAsk(\\n        uint256 tranche,\\n        uint256 pdLevel,\\n        uint256 baseAmount,\\n        uint256 version\\n    ) external onlyMaker {\\n        require(block.timestamp >= guardedLaunchStart + 8 days, \\\"Guarded launch: market closed\\\");\\n        if (block.timestamp < guardedLaunchStart + 4 weeks) {\\n            require(baseAmount >= guardedLaunchMinOrderAmount, \\\"Guarded launch: amount too low\\\");\\n        } else {\\n            require(baseAmount >= minAskAmount, \\\"Base amount too low\\\");\\n        }\\n        require(\\n            pdLevel > bestBids[version][tranche] && pdLevel <= PD_LEVEL_COUNT,\\n            \\\"Invalid premium-discount level\\\"\\n        );\\n        require(version == fund.getRebalanceSize(), \\\"Invalid version\\\");\\n\\n        _lock(tranche, msg.sender, baseAmount);\\n        uint256 index = asks[version][tranche][pdLevel].append(msg.sender, baseAmount, version);\\n        uint256 oldBestAsk = bestAsks[version][tranche];\\n        if (oldBestAsk > pdLevel || oldBestAsk == 0) {\\n            bestAsks[version][tranche] = pdLevel;\\n        }\\n\\n        emit AskOrderPlaced(msg.sender, tranche, pdLevel, baseAmount, version, index);\\n    }\\n\\n    /// @notice Cancel a bid order\\n    /// @param version Order's rebalance version\\n    /// @param tranche Tranche of the order's base asset\\n    /// @param pdLevel Order's premium-discount level\\n    /// @param index Order's index in the order queue\\n    function cancelBid(\\n        uint256 version,\\n        uint256 tranche,\\n        uint256 pdLevel,\\n        uint256 index\\n    ) external {\\n        OrderQueue storage orderQueue = bids[version][tranche][pdLevel];\\n        Order storage order = orderQueue.list[index];\\n        require(order.maker == msg.sender, \\\"Maker address mismatched\\\");\\n\\n        uint256 fillable = order.fillable;\\n        emit BidOrderCanceled(msg.sender, tranche, pdLevel, order.amount, version, index, fillable);\\n        orderQueue.cancel(index);\\n\\n        // Update bestBid\\n        if (bestBids[version][tranche] == pdLevel) {\\n            uint256 newBestBid = pdLevel;\\n            while (newBestBid > 0 && bids[version][tranche][newBestBid].isEmpty()) {\\n                newBestBid--;\\n            }\\n            bestBids[version][tranche] = newBestBid;\\n        }\\n\\n        _transferQuote(msg.sender, fillable);\\n    }\\n\\n    /// @notice Cancel an ask order\\n    /// @param version Order's rebalance version\\n    /// @param tranche Tranche of the order's base asset\\n    /// @param pdLevel Order's premium-discount level\\n    /// @param index Order's index in the order queue\\n    function cancelAsk(\\n        uint256 version,\\n        uint256 tranche,\\n        uint256 pdLevel,\\n        uint256 index\\n    ) external {\\n        OrderQueue storage orderQueue = asks[version][tranche][pdLevel];\\n        Order storage order = orderQueue.list[index];\\n        require(order.maker == msg.sender, \\\"Maker address mismatched\\\");\\n\\n        uint256 fillable = order.fillable;\\n        emit AskOrderCanceled(msg.sender, tranche, pdLevel, order.amount, version, index, fillable);\\n        orderQueue.cancel(index);\\n\\n        // Update bestAsk\\n        if (bestAsks[version][tranche] == pdLevel) {\\n            uint256 newBestAsk = pdLevel;\\n            while (newBestAsk <= PD_LEVEL_COUNT && asks[version][tranche][newBestAsk].isEmpty()) {\\n                newBestAsk++;\\n            }\\n            bestAsks[version][tranche] = newBestAsk;\\n        }\\n\\n        if (tranche == TRANCHE_M) {\\n            _rebalanceAndUnlock(msg.sender, fillable, 0, 0, version);\\n        } else if (tranche == TRANCHE_A) {\\n            _rebalanceAndUnlock(msg.sender, 0, fillable, 0, version);\\n        } else {\\n            _rebalanceAndUnlock(msg.sender, 0, 0, fillable, version);\\n        }\\n    }\\n\\n    /// @notice Buy Token M\\n    /// @param version Current rebalance version. Revert if it is not the latest version.\\n    /// @param maxPDLevel Maximal premium-discount level accepted\\n    /// @param quoteAmount Amount of quote assets (with 18 decimal places) willing to trade\\n    function buyM(\\n        uint256 version,\\n        uint256 maxPDLevel,\\n        uint256 quoteAmount\\n    ) external {\\n        (uint256 estimatedNav, , ) = estimateNavs(endOfEpoch(block.timestamp) - 2 * EPOCH);\\n        _buy(version, TRANCHE_M, maxPDLevel, estimatedNav, quoteAmount);\\n    }\\n\\n    /// @notice Buy Token A\\n    /// @param version Current rebalance version. Revert if it is not the latest version.\\n    /// @param maxPDLevel Maximal premium-discount level accepted\\n    /// @param quoteAmount Amount of quote assets (with 18 decimal places) willing to trade\\n    function buyA(\\n        uint256 version,\\n        uint256 maxPDLevel,\\n        uint256 quoteAmount\\n    ) external {\\n        (, uint256 estimatedNav, ) = estimateNavs(endOfEpoch(block.timestamp) - 2 * EPOCH);\\n        _buy(version, TRANCHE_A, maxPDLevel, estimatedNav, quoteAmount);\\n    }\\n\\n    /// @notice Buy Token B\\n    /// @param version Current rebalance version. Revert if it is not the latest version.\\n    /// @param maxPDLevel Maximal premium-discount level accepted\\n    /// @param quoteAmount Amount of quote assets (with 18 decimal places) willing to trade\\n    function buyB(\\n        uint256 version,\\n        uint256 maxPDLevel,\\n        uint256 quoteAmount\\n    ) external {\\n        (, , uint256 estimatedNav) = estimateNavs(endOfEpoch(block.timestamp) - 2 * EPOCH);\\n        _buy(version, TRANCHE_B, maxPDLevel, estimatedNav, quoteAmount);\\n    }\\n\\n    /// @notice Sell Token M\\n    /// @param version Current rebalance version. Revert if it is not the latest version.\\n    /// @param minPDLevel Minimal premium-discount level accepted\\n    /// @param baseAmount Amount of Token M willing to trade\\n    function sellM(\\n        uint256 version,\\n        uint256 minPDLevel,\\n        uint256 baseAmount\\n    ) external {\\n        (uint256 estimatedNav, , ) = estimateNavs(endOfEpoch(block.timestamp) - 2 * EPOCH);\\n        _sell(version, TRANCHE_M, minPDLevel, estimatedNav, baseAmount);\\n    }\\n\\n    /// @notice Sell Token A\\n    /// @param version Current rebalance version. Revert if it is not the latest version.\\n    /// @param minPDLevel Minimal premium-discount level accepted\\n    /// @param baseAmount Amount of Token A willing to trade\\n    function sellA(\\n        uint256 version,\\n        uint256 minPDLevel,\\n        uint256 baseAmount\\n    ) external {\\n        (, uint256 estimatedNav, ) = estimateNavs(endOfEpoch(block.timestamp) - 2 * EPOCH);\\n        _sell(version, TRANCHE_A, minPDLevel, estimatedNav, baseAmount);\\n    }\\n\\n    /// @notice Sell Token B\\n    /// @param version Current rebalance version. Revert if it is not the latest version.\\n    /// @param minPDLevel Minimal premium-discount level accepted\\n    /// @param baseAmount Amount of Token B willing to trade\\n    function sellB(\\n        uint256 version,\\n        uint256 minPDLevel,\\n        uint256 baseAmount\\n    ) external {\\n        (, , uint256 estimatedNav) = estimateNavs(endOfEpoch(block.timestamp) - 2 * EPOCH);\\n        _sell(version, TRANCHE_B, minPDLevel, estimatedNav, baseAmount);\\n    }\\n\\n    /// @notice Settle trades of a specified epoch for makers\\n    /// @param account Address of the maker\\n    /// @param epoch A specified epoch's end timestamp\\n    /// @return amountM Token M amount added to msg.sender's available balance\\n    /// @return amountA Token A amount added to msg.sender's available balance\\n    /// @return amountB Token B amount added to msg.sender's available balance\\n    /// @return quoteAmount Quote asset amount transfered to msg.sender, rounding precison to 18\\n    ///                     for quote assets with precision other than 18 decimal places\\n    function settleMaker(address account, uint256 epoch)\\n        external\\n        returns (\\n            uint256 amountM,\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 quoteAmount\\n        )\\n    {\\n        (uint256 estimatedNavM, uint256 estimatedNavA, uint256 estimatedNavB) =\\n            estimateNavs(epoch.add(EPOCH));\\n\\n        uint256 quoteAmountM;\\n        uint256 quoteAmountA;\\n        uint256 quoteAmountB;\\n        (amountM, quoteAmountM) = _settleMaker(account, TRANCHE_M, estimatedNavM, epoch);\\n        (amountA, quoteAmountA) = _settleMaker(account, TRANCHE_A, estimatedNavA, epoch);\\n        (amountB, quoteAmountB) = _settleMaker(account, TRANCHE_B, estimatedNavB, epoch);\\n\\n        uint256 version = _epochVersions[epoch];\\n        (amountM, amountA, amountB) = _rebalanceAndClearTrade(\\n            account,\\n            amountM,\\n            amountA,\\n            amountB,\\n            version\\n        );\\n        quoteAmount = quoteAmountM.add(quoteAmountA).add(quoteAmountB);\\n        _transferQuote(account, quoteAmount);\\n\\n        emit MakerSettled(account, epoch, amountM, amountA, amountB, quoteAmount);\\n    }\\n\\n    /// @notice Settle trades of a specified epoch for takers\\n    /// @param account Address of the maker\\n    /// @param epoch A specified epoch's end timestamp\\n    /// @return amountM Token M amount added to msg.sender's available balance\\n    /// @return amountA Token A amount added to msg.sender's available balance\\n    /// @return amountB Token B amount added to msg.sender's available balance\\n    /// @return quoteAmount Quote asset amount transfered to msg.sender, rounding precison to 18\\n    ///                     for quote assets with precision other than 18 decimal places\\n    function settleTaker(address account, uint256 epoch)\\n        external\\n        returns (\\n            uint256 amountM,\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 quoteAmount\\n        )\\n    {\\n        (uint256 estimatedNavM, uint256 estimatedNavA, uint256 estimatedNavB) =\\n            estimateNavs(epoch.add(EPOCH));\\n\\n        uint256 quoteAmountM;\\n        uint256 quoteAmountA;\\n        uint256 quoteAmountB;\\n        (amountM, quoteAmountM) = _settleTaker(account, TRANCHE_M, estimatedNavM, epoch);\\n        (amountA, quoteAmountA) = _settleTaker(account, TRANCHE_A, estimatedNavA, epoch);\\n        (amountB, quoteAmountB) = _settleTaker(account, TRANCHE_B, estimatedNavB, epoch);\\n\\n        uint256 version = _epochVersions[epoch];\\n        (amountM, amountA, amountB) = _rebalanceAndClearTrade(\\n            account,\\n            amountM,\\n            amountA,\\n            amountB,\\n            version\\n        );\\n        quoteAmount = quoteAmountM.add(quoteAmountA).add(quoteAmountB);\\n        _transferQuote(account, quoteAmount);\\n\\n        emit TakerSettled(account, epoch, amountM, amountA, amountB, quoteAmount);\\n    }\\n\\n    /// @dev Buy share\\n    /// @param version Current rebalance version. Revert if it is not the latest version.\\n    /// @param tranche Tranche of the base asset\\n    /// @param maxPDLevel Maximal premium-discount level accepted\\n    /// @param estimatedNav Estimated net asset value of the base asset\\n    /// @param quoteAmount Amount of quote assets willing to trade with 18 decimal places\\n    function _buy(\\n        uint256 version,\\n        uint256 tranche,\\n        uint256 maxPDLevel,\\n        uint256 estimatedNav,\\n        uint256 quoteAmount\\n    ) internal onlyActive {\\n        require(maxPDLevel > 0 && maxPDLevel <= PD_LEVEL_COUNT, \\\"Invalid premium-discount level\\\");\\n        require(version == fund.getRebalanceSize(), \\\"Invalid version\\\");\\n        require(estimatedNav > 0, \\\"Zero estimated NAV\\\");\\n\\n        UnsettledBuyTrade memory totalTrade;\\n        uint256 epoch = endOfEpoch(block.timestamp);\\n\\n        // Record rebalance version in the first transaction in the epoch\\n        if (_epochVersions[epoch] == 0) {\\n            _epochVersions[epoch] = version;\\n        }\\n\\n        UnsettledBuyTrade memory currentTrade;\\n        uint256 orderIndex = 0;\\n        uint256 pdLevel = bestAsks[version][tranche];\\n        if (pdLevel == 0) {\\n            // Zero best ask indicates that no ask order is ever placed.\\n            // We set pdLevel beyond the largest valid level, forcing the following loop\\n            // to exit immediately.\\n            pdLevel = PD_LEVEL_COUNT + 1;\\n        }\\n        for (; pdLevel <= maxPDLevel; pdLevel++) {\\n            uint256 price = pdLevel.mul(PD_TICK).add(PD_START).multiplyDecimal(estimatedNav);\\n            OrderQueue storage orderQueue = asks[version][tranche][pdLevel];\\n            orderIndex = orderQueue.head;\\n            while (orderIndex != 0) {\\n                Order storage order = orderQueue.list[orderIndex];\\n\\n                // If the order initiator is no longer qualified for maker,\\n                // we skip the order and the linked-list-based order queue\\n                // would never traverse the order again\\n                if (!isMaker(order.maker)) {\\n                    orderIndex = order.next;\\n                    continue;\\n                }\\n\\n                // Calculate the current trade assuming that the taker would be completely filled.\\n                currentTrade.frozenQuote = quoteAmount.sub(totalTrade.frozenQuote);\\n                currentTrade.reservedBase = currentTrade.frozenQuote.mul(MAKER_RESERVE_RATIO).div(\\n                    price\\n                );\\n\\n                if (currentTrade.reservedBase < order.fillable) {\\n                    // Taker is completely filled.\\n                    currentTrade.effectiveQuote = currentTrade.frozenQuote.divideDecimal(\\n                        pdLevel.mul(PD_TICK).add(PD_START)\\n                    );\\n                } else {\\n                    // Maker is completely filled. Recalculate the current trade.\\n                    currentTrade.frozenQuote = order.fillable.mul(price).div(MAKER_RESERVE_RATIO);\\n                    currentTrade.effectiveQuote = order.fillable.mul(estimatedNav).div(\\n                        MAKER_RESERVE_RATIO\\n                    );\\n                    currentTrade.reservedBase = order.fillable;\\n                }\\n                totalTrade.frozenQuote = totalTrade.frozenQuote.add(currentTrade.frozenQuote);\\n                totalTrade.effectiveQuote = totalTrade.effectiveQuote.add(\\n                    currentTrade.effectiveQuote\\n                );\\n                totalTrade.reservedBase = totalTrade.reservedBase.add(currentTrade.reservedBase);\\n                unsettledTrades[order.maker][tranche][epoch].makerSell.add(currentTrade);\\n\\n                // There is no need to rebalance for maker; the fact that the order could\\n                // be filled here indicates that the maker is in the latest version\\n                _tradeLocked(tranche, order.maker, currentTrade.reservedBase);\\n\\n                uint256 orderNewFillable = order.fillable.sub(currentTrade.reservedBase);\\n                if (orderNewFillable > 0) {\\n                    // Maker is not completely filled. Matching ends here.\\n                    order.fillable = orderNewFillable;\\n                    break;\\n                } else {\\n                    // Delete the completely filled maker order.\\n                    orderIndex = orderQueue.fill(orderIndex);\\n                }\\n            }\\n\\n            orderQueue.updateHead(orderIndex);\\n            if (orderIndex != 0) {\\n                // This premium-discount level is not completely filled. Matching ends here.\\n                if (bestAsks[version][tranche] != pdLevel) {\\n                    bestAsks[version][tranche] = pdLevel;\\n                }\\n                break;\\n            }\\n        }\\n        emit BuyTrade(\\n            msg.sender,\\n            tranche,\\n            totalTrade.frozenQuote,\\n            version,\\n            pdLevel,\\n            orderIndex,\\n            orderIndex == 0 ? 0 : currentTrade.reservedBase\\n        );\\n        if (orderIndex == 0) {\\n            // Matching ends by completely filling all orders at and below the specified\\n            // premium-discount level `maxPDLevel`.\\n            // Find the new best ask beyond that level.\\n            for (; pdLevel <= PD_LEVEL_COUNT; pdLevel++) {\\n                if (!asks[version][tranche][pdLevel].isEmpty()) {\\n                    break;\\n                }\\n            }\\n            bestAsks[version][tranche] = pdLevel;\\n        }\\n\\n        require(\\n            totalTrade.frozenQuote > 0,\\n            \\\"Nothing can be bought at the given premium-discount level\\\"\\n        );\\n        _transferQuoteFrom(msg.sender, totalTrade.frozenQuote);\\n        unsettledTrades[msg.sender][tranche][epoch].takerBuy.add(totalTrade);\\n    }\\n\\n    /// @dev Sell share\\n    /// @param version Current rebalance version. Revert if it is not the latest version.\\n    /// @param tranche Tranche of the base asset\\n    /// @param minPDLevel Minimal premium-discount level accepted\\n    /// @param estimatedNav Estimated net asset value of the base asset\\n    /// @param baseAmount Amount of base assets willing to trade\\n    function _sell(\\n        uint256 version,\\n        uint256 tranche,\\n        uint256 minPDLevel,\\n        uint256 estimatedNav,\\n        uint256 baseAmount\\n    ) internal onlyActive {\\n        require(minPDLevel > 0 && minPDLevel <= PD_LEVEL_COUNT, \\\"Invalid premium-discount level\\\");\\n        require(version == fund.getRebalanceSize(), \\\"Invalid version\\\");\\n        require(estimatedNav > 0, \\\"Zero estimated NAV\\\");\\n\\n        UnsettledSellTrade memory totalTrade;\\n        uint256 epoch = endOfEpoch(block.timestamp);\\n\\n        // Record rebalance version in the first transaction in the epoch\\n        if (_epochVersions[epoch] == 0) {\\n            _epochVersions[epoch] = version;\\n        }\\n\\n        UnsettledSellTrade memory currentTrade;\\n        uint256 orderIndex;\\n        uint256 pdLevel = bestBids[version][tranche];\\n        for (; pdLevel >= minPDLevel; pdLevel--) {\\n            uint256 price = pdLevel.mul(PD_TICK).add(PD_START).multiplyDecimal(estimatedNav);\\n            OrderQueue storage orderQueue = bids[version][tranche][pdLevel];\\n            orderIndex = orderQueue.head;\\n            while (orderIndex != 0) {\\n                Order storage order = orderQueue.list[orderIndex];\\n\\n                // If the order initiator is no longer qualified for maker,\\n                // we skip the order and the linked-list-based order queue\\n                // would never traverse the order again\\n                if (!isMaker(order.maker)) {\\n                    orderIndex = order.next;\\n                    continue;\\n                }\\n\\n                currentTrade.frozenBase = baseAmount.sub(totalTrade.frozenBase);\\n                currentTrade.reservedQuote = currentTrade\\n                    .frozenBase\\n                    .multiplyDecimal(MAKER_RESERVE_RATIO)\\n                    .multiplyDecimal(price);\\n\\n                if (currentTrade.reservedQuote < order.fillable) {\\n                    // Taker is completely filled\\n                    currentTrade.effectiveBase = currentTrade.frozenBase.multiplyDecimal(\\n                        pdLevel.mul(PD_TICK).add(PD_START)\\n                    );\\n                } else {\\n                    // Maker is completely filled. Recalculate the current trade.\\n                    currentTrade.frozenBase = order.fillable.divideDecimal(price).divideDecimal(\\n                        MAKER_RESERVE_RATIO\\n                    );\\n                    currentTrade.effectiveBase = order\\n                        .fillable\\n                        .divideDecimal(estimatedNav)\\n                        .divideDecimal(MAKER_RESERVE_RATIO);\\n                    currentTrade.reservedQuote = order.fillable;\\n                }\\n                totalTrade.frozenBase = totalTrade.frozenBase.add(currentTrade.frozenBase);\\n                totalTrade.effectiveBase = totalTrade.effectiveBase.add(currentTrade.effectiveBase);\\n                totalTrade.reservedQuote = totalTrade.reservedQuote.add(currentTrade.reservedQuote);\\n                unsettledTrades[order.maker][tranche][epoch].makerBuy.add(currentTrade);\\n\\n                uint256 orderNewFillable = order.fillable.sub(currentTrade.reservedQuote);\\n                if (orderNewFillable > 0) {\\n                    // Maker is not completely filled. Matching ends here.\\n                    order.fillable = orderNewFillable;\\n                    break;\\n                } else {\\n                    // Delete the completely filled maker order.\\n                    orderIndex = orderQueue.fill(orderIndex);\\n                }\\n            }\\n\\n            orderQueue.updateHead(orderIndex);\\n            if (orderIndex != 0) {\\n                // This premium-discount level is not completely filled. Matching ends here.\\n                if (bestBids[version][tranche] != pdLevel) {\\n                    bestBids[version][tranche] = pdLevel;\\n                }\\n                break;\\n            }\\n        }\\n        emit SellTrade(\\n            msg.sender,\\n            tranche,\\n            totalTrade.frozenBase,\\n            version,\\n            pdLevel,\\n            orderIndex,\\n            orderIndex == 0 ? 0 : currentTrade.reservedQuote\\n        );\\n        if (orderIndex == 0) {\\n            // Matching ends by completely filling all orders at and above the specified\\n            // premium-discount level `minPDLevel`.\\n            // Find the new best bid beyond that level.\\n            for (; pdLevel > 0; pdLevel--) {\\n                if (!bids[version][tranche][pdLevel].isEmpty()) {\\n                    break;\\n                }\\n            }\\n            bestBids[version][tranche] = pdLevel;\\n        }\\n\\n        require(\\n            totalTrade.frozenBase > 0,\\n            \\\"Nothing can be sold at the given premium-discount level\\\"\\n        );\\n        _tradeAvailable(tranche, msg.sender, totalTrade.frozenBase);\\n        unsettledTrades[msg.sender][tranche][epoch].takerSell.add(totalTrade);\\n    }\\n\\n    /// @dev Settle both buy and sell trades of a specified epoch for takers\\n    /// @param account Taker address\\n    /// @param tranche Tranche of the base asset\\n    /// @param estimatedNav Estimated net asset value for the base asset\\n    /// @param epoch The epoch's end timestamp\\n    function _settleTaker(\\n        address account,\\n        uint256 tranche,\\n        uint256 estimatedNav,\\n        uint256 epoch\\n    ) internal returns (uint256 baseAmount, uint256 quoteAmount) {\\n        UnsettledTrade storage unsettledTrade = unsettledTrades[account][tranche][epoch];\\n\\n        // Settle buy trade\\n        UnsettledBuyTrade memory takerBuy = unsettledTrade.takerBuy;\\n        if (takerBuy.frozenQuote > 0) {\\n            (uint256 executionQuote, uint256 executionBase) =\\n                _buyTradeResult(takerBuy, estimatedNav);\\n            baseAmount = executionBase;\\n            quoteAmount = takerBuy.frozenQuote.sub(executionQuote);\\n            delete unsettledTrade.takerBuy;\\n        }\\n\\n        // Settle sell trade\\n        UnsettledSellTrade memory takerSell = unsettledTrade.takerSell;\\n        if (takerSell.frozenBase > 0) {\\n            (uint256 executionQuote, uint256 executionBase) =\\n                _sellTradeResult(takerSell, estimatedNav);\\n            quoteAmount = quoteAmount.add(executionQuote);\\n            baseAmount = baseAmount.add(takerSell.frozenBase.sub(executionBase));\\n            delete unsettledTrade.takerSell;\\n        }\\n    }\\n\\n    /// @dev Settle both buy and sell trades of a specified epoch for makers\\n    /// @param account Maker address\\n    /// @param tranche Tranche of the base asset\\n    /// @param estimatedNav Estimated net asset value for the base asset\\n    /// @param epoch The epoch's end timestamp\\n    function _settleMaker(\\n        address account,\\n        uint256 tranche,\\n        uint256 estimatedNav,\\n        uint256 epoch\\n    ) internal returns (uint256 baseAmount, uint256 quoteAmount) {\\n        UnsettledTrade storage unsettledTrade = unsettledTrades[account][tranche][epoch];\\n\\n        // Settle buy trade\\n        UnsettledSellTrade memory makerBuy = unsettledTrade.makerBuy;\\n        if (makerBuy.frozenBase > 0) {\\n            (uint256 executionQuote, uint256 executionBase) =\\n                _sellTradeResult(makerBuy, estimatedNav);\\n            baseAmount = executionBase;\\n            quoteAmount = makerBuy.reservedQuote.sub(executionQuote);\\n            delete unsettledTrade.makerBuy;\\n        }\\n\\n        // Settle sell trade\\n        UnsettledBuyTrade memory makerSell = unsettledTrade.makerSell;\\n        if (makerSell.frozenQuote > 0) {\\n            (uint256 executionQuote, uint256 executionBase) =\\n                _buyTradeResult(makerSell, estimatedNav);\\n            quoteAmount = quoteAmount.add(executionQuote);\\n            baseAmount = baseAmount.add(makerSell.reservedBase.sub(executionBase));\\n            delete unsettledTrade.makerSell;\\n        }\\n    }\\n\\n    /// @dev Calculate the result of an unsettled buy trade with a given NAV\\n    /// @param buyTrade Buy trade result of this particular epoch\\n    /// @param nav Net asset value for the base asset\\n    /// @return executionQuote Real amount of quote asset waiting for settlment\\n    /// @return executionBase Real amount of base asset waiting for settlment\\n    function _buyTradeResult(UnsettledBuyTrade memory buyTrade, uint256 nav)\\n        internal\\n        pure\\n        returns (uint256 executionQuote, uint256 executionBase)\\n    {\\n        uint256 reservedBase = buyTrade.reservedBase;\\n        uint256 reservedQuote = reservedBase.multiplyDecimal(nav);\\n        uint256 effectiveQuote = buyTrade.effectiveQuote;\\n        if (effectiveQuote < reservedQuote) {\\n            // Reserved base is enough to execute the trade.\\n            // nav is always positive here\\n            return (buyTrade.frozenQuote, effectiveQuote.divideDecimal(nav));\\n        } else {\\n            // Reserved base is not enough. The trade is partially executed\\n            // and a fraction of frozenQuote is returned to the taker.\\n            return (buyTrade.frozenQuote.mul(reservedQuote).div(effectiveQuote), reservedBase);\\n        }\\n    }\\n\\n    /// @dev Calculate the result of an unsettled sell trade with a given NAV\\n    /// @param sellTrade Sell trade result of this particular epoch\\n    /// @param nav Net asset value for the base asset\\n    /// @return executionQuote Real amount of quote asset waiting for settlment\\n    /// @return executionBase Real amount of base asset waiting for settlment\\n    function _sellTradeResult(UnsettledSellTrade memory sellTrade, uint256 nav)\\n        internal\\n        pure\\n        returns (uint256 executionQuote, uint256 executionBase)\\n    {\\n        uint256 reservedQuote = sellTrade.reservedQuote;\\n        uint256 effectiveQuote = sellTrade.effectiveBase.multiplyDecimal(nav);\\n        if (effectiveQuote < reservedQuote) {\\n            // Reserved quote is enough to execute the trade.\\n            return (effectiveQuote, sellTrade.frozenBase);\\n        } else {\\n            // Reserved quote is not enough. The trade is partially executed\\n            // and a fraction of frozenBase is returned to the taker.\\n            return (reservedQuote, sellTrade.frozenBase.mul(reservedQuote).div(effectiveQuote));\\n        }\\n    }\\n\\n    /// @dev Transfer quote asset to an account. Transfered amount is rounded down.\\n    /// @param account Recipient address\\n    /// @param amount Amount to transfer with 18 decimal places\\n    function _transferQuote(address account, uint256 amount) private {\\n        uint256 amountToTransfer = amount / _quoteDecimalMultiplier;\\n        if (amountToTransfer == 0) {\\n            return;\\n        }\\n        IERC20(quoteAssetAddress).safeTransfer(account, amountToTransfer);\\n    }\\n\\n    /// @dev Transfer quote asset from an account. Transfered amount is rounded up.\\n    /// @param account Sender address\\n    /// @param amount Amount to transfer with 18 decimal places\\n    function _transferQuoteFrom(address account, uint256 amount) private {\\n        uint256 amountToTransfer =\\n            amount.add(_quoteDecimalMultiplier - 1) / _quoteDecimalMultiplier;\\n        IERC20(quoteAssetAddress).safeTransferFrom(account, address(this), amountToTransfer);\\n    }\\n\\n    modifier onlyActive() {\\n        require(fund.isExchangeActive(block.timestamp), \\\"Exchange is inactive\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tranchessV1/test/OrderQueueTestWrapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport {Order, OrderQueue, LibOrderQueue} from \\\"../exchange/LibOrderQueue.sol\\\";\\n\\ncontract OrderQueueTestWrapper {\\n    using LibOrderQueue for OrderQueue;\\n\\n    OrderQueue public queue;\\n\\n    uint256 public lastReturn;\\n\\n    function getOrder(uint256 index) external view returns (Order memory) {\\n        return queue.list[index];\\n    }\\n\\n    function isEmpty() external view returns (bool) {\\n        return queue.isEmpty();\\n    }\\n\\n    function append(\\n        address maker,\\n        uint256 amount,\\n        uint256 version\\n    ) external {\\n        lastReturn = queue.append(maker, amount, version);\\n    }\\n\\n    function cancel(uint256 index) external {\\n        queue.cancel(index);\\n    }\\n\\n    function fill(uint256 index) external {\\n        lastReturn = queue.fill(index);\\n    }\\n\\n    function updateHead(uint256 newHead) external {\\n        queue.updateHead(newHead);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/oracle/AprOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"../interfaces/IAprOracle.sol\\\";\\nimport \\\"../utils/SafeDecimalMath.sol\\\";\\nimport \\\"../utils/Exponential.sol\\\";\\nimport \\\"../utils/CoreUtility.sol\\\";\\n\\n// Compound\\ninterface CTokenInterface {\\n    function borrowIndex() external view returns (uint256);\\n\\n    function borrowRatePerBlock() external view returns (uint256);\\n\\n    function accrualBlockNumber() external view returns (uint256);\\n}\\n\\n// Aave\\ninterface ILendingPool {\\n    function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\\n}\\n\\ncontract AprOracle is IAprOracle, Exponential, CoreUtility {\\n    using SafeMath for uint256;\\n    using SafeDecimalMath for uint256;\\n\\n    uint256 public constant DECIMAL = 10**18;\\n    uint256 public constant COMPOUND_BORROW_MAX_MANTISSA = 0.0005e16;\\n\\n    // Mainnet: 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\\n    // Kovan: 0xe22da380ee6B445bb8273C81944ADEB6E8450422\\n    address public immutable usdc;\\n\\n    // Kovan: 0x9FE532197ad76c5a68961439604C037EB79681F0\\n    address public immutable aaveUsdcLendingPool;\\n\\n    // Mainnet: 0x39AA39c021dfbaE8faC545936693aC917d5E7563\\n    // Kovan: 0x4a92E71227D294F041BD82dd8f78591B75140d63\\n    address public immutable cUsdc;\\n\\n    string public name;\\n    uint256 public compoundBorrowIndex;\\n    uint256 public aaveBorrowIndex;\\n    uint256 public timestamp;\\n    uint256 public currentDailyRate;\\n\\n    constructor(\\n        string memory name_,\\n        address usdc_,\\n        address aaveUsdcLendingPool_,\\n        address cUsdc_\\n    ) public {\\n        name = name_;\\n        usdc = usdc_;\\n        aaveUsdcLendingPool = aaveUsdcLendingPool_;\\n        cUsdc = cUsdc_;\\n        compoundBorrowIndex = getCompoundBorrowIndex(cUsdc_);\\n        aaveBorrowIndex = getAaveBorrowIndex(aaveUsdcLendingPool_, usdc_);\\n        timestamp = block.timestamp;\\n    }\\n\\n    // Compound\\n    function getCompoundBorrowIndex(address cToken) public view returns (uint256 newBorrowIndex) {\\n        /* Calculate the current borrow interest rate */\\n        uint256 borrowRateMantissa = CTokenInterface(cToken).borrowRatePerBlock();\\n        require(borrowRateMantissa <= COMPOUND_BORROW_MAX_MANTISSA, \\\"Borrow rate is absurdly high\\\");\\n\\n        uint256 borrowIndexPrior = CTokenInterface(cToken).borrowIndex();\\n        uint256 accrualBlockNumber = CTokenInterface(cToken).accrualBlockNumber();\\n\\n        (, uint256 blockDelta) = subUInt(block.number, accrualBlockNumber);\\n\\n        (, Exp memory simpleInterestFactor) =\\n            mulScalar(Exp({mantissa: borrowRateMantissa}), blockDelta);\\n        (, newBorrowIndex) = mulScalarTruncateAddUInt(\\n            simpleInterestFactor,\\n            borrowIndexPrior,\\n            borrowIndexPrior\\n        );\\n    }\\n\\n    // Aave\\n    function getAaveBorrowIndex(address aaveLendingPool, address token)\\n        public\\n        view\\n        returns (uint256 newBorrowRate)\\n    {\\n        newBorrowRate = ILendingPool(aaveLendingPool).getReserveNormalizedVariableDebt(token);\\n    }\\n\\n    function getAverageDailyRate()\\n        public\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256 newCompoundBorrowIndex = getCompoundBorrowIndex(cUsdc);\\n        uint256 newAaveBorrowRate = getAaveBorrowIndex(aaveUsdcLendingPool, usdc);\\n\\n        uint256 compoundPeriodicRate =\\n            newCompoundBorrowIndex.sub(compoundBorrowIndex).divideDecimal(compoundBorrowIndex);\\n        uint256 aavePeriodicRate =\\n            newAaveBorrowRate.sub(aaveBorrowIndex).divideDecimal(aaveBorrowIndex);\\n\\n        uint256 dailyRate =\\n            compoundPeriodicRate.add(aavePeriodicRate).mul(1 days).div(2).div(\\n                block.timestamp.sub(timestamp)\\n            );\\n\\n        return (\\n            newCompoundBorrowIndex,\\n            newAaveBorrowRate,\\n            compoundPeriodicRate,\\n            aavePeriodicRate,\\n            dailyRate\\n        );\\n    }\\n\\n    function capture() external override returns (uint256 dailyRate) {\\n        uint256 currentWeek = _endOfWeek(timestamp);\\n        if (currentWeek > block.timestamp) {\\n            return currentDailyRate;\\n        }\\n\\n        (compoundBorrowIndex, aaveBorrowIndex, , , dailyRate) = getAverageDailyRate();\\n        timestamp = block.timestamp;\\n        currentDailyRate = dailyRate;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Exponential.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\nimport \\\"./CarefulMath.sol\\\";\\nimport \\\"./ExponentialNoError.sol\\\";\\n\\n/**\\n * @title Exponential module for storing fixed-precision decimals\\n * @author Compound\\n * @dev Legacy contract for compatibility reasons with existing contracts that still use MathError\\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\\n *         `Exp({mantissa: 5100000000000000000})`.\\n */\\nabstract contract Exponential is CarefulMath, ExponentialNoError {\\n    /**\\n     * @dev Creates an exponential from numerator and denominator values.\\n     *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\\n     *            or if `denom` is zero.\\n     */\\n    function getExp(uint256 num, uint256 denom) internal pure returns (MathError, Exp memory) {\\n        (MathError err0, uint256 scaledNumerator) = mulUInt(num, expScale);\\n        if (err0 != MathError.NO_ERROR) {\\n            return (err0, Exp({mantissa: 0}));\\n        }\\n\\n        (MathError err1, uint256 rational) = divUInt(scaledNumerator, denom);\\n        if (err1 != MathError.NO_ERROR) {\\n            return (err1, Exp({mantissa: 0}));\\n        }\\n\\n        return (MathError.NO_ERROR, Exp({mantissa: rational}));\\n    }\\n\\n    /**\\n     * @dev Adds two exponentials, returning a new exponential.\\n     */\\n    function addExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\\n        (MathError error, uint256 result) = addUInt(a.mantissa, b.mantissa);\\n\\n        return (error, Exp({mantissa: result}));\\n    }\\n\\n    /**\\n     * @dev Subtracts two exponentials, returning a new exponential.\\n     */\\n    function subExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\\n        (MathError error, uint256 result) = subUInt(a.mantissa, b.mantissa);\\n\\n        return (error, Exp({mantissa: result}));\\n    }\\n\\n    /**\\n     * @dev Multiply an Exp by a scalar, returning a new Exp.\\n     */\\n    function mulScalar(Exp memory a, uint256 scalar) internal pure returns (MathError, Exp memory) {\\n        (MathError err0, uint256 scaledMantissa) = mulUInt(a.mantissa, scalar);\\n        if (err0 != MathError.NO_ERROR) {\\n            return (err0, Exp({mantissa: 0}));\\n        }\\n\\n        return (MathError.NO_ERROR, Exp({mantissa: scaledMantissa}));\\n    }\\n\\n    /**\\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\\n     */\\n    function mulScalarTruncate(Exp memory a, uint256 scalar)\\n        internal\\n        pure\\n        returns (MathError, uint256)\\n    {\\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\\n        if (err != MathError.NO_ERROR) {\\n            return (err, 0);\\n        }\\n\\n        return (MathError.NO_ERROR, truncate(product));\\n    }\\n\\n    /**\\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\\n     */\\n    function mulScalarTruncateAddUInt(\\n        Exp memory a,\\n        uint256 scalar,\\n        uint256 addend\\n    ) internal pure returns (MathError, uint256) {\\n        (MathError err, Exp memory product) = mulScalar(a, scalar);\\n        if (err != MathError.NO_ERROR) {\\n            return (err, 0);\\n        }\\n\\n        return addUInt(truncate(product), addend);\\n    }\\n\\n    /**\\n     * @dev Divide an Exp by a scalar, returning a new Exp.\\n     */\\n    function divScalar(Exp memory a, uint256 scalar) internal pure returns (MathError, Exp memory) {\\n        (MathError err0, uint256 descaledMantissa) = divUInt(a.mantissa, scalar);\\n        if (err0 != MathError.NO_ERROR) {\\n            return (err0, Exp({mantissa: 0}));\\n        }\\n\\n        return (MathError.NO_ERROR, Exp({mantissa: descaledMantissa}));\\n    }\\n\\n    /**\\n     * @dev Divide a scalar by an Exp, returning a new Exp.\\n     */\\n    function divScalarByExp(uint256 scalar, Exp memory divisor)\\n        internal\\n        pure\\n        returns (MathError, Exp memory)\\n    {\\n        /*\\n          We are doing this as:\\n          getExp(mulUInt(expScale, scalar), divisor.mantissa)\\n\\n          How it works:\\n          Exp = a / b;\\n          Scalar = s;\\n          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\\n        */\\n        (MathError err0, uint256 numerator) = mulUInt(expScale, scalar);\\n        if (err0 != MathError.NO_ERROR) {\\n            return (err0, Exp({mantissa: 0}));\\n        }\\n        return getExp(numerator, divisor.mantissa);\\n    }\\n\\n    /**\\n     * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\\n     */\\n    function divScalarByExpTruncate(uint256 scalar, Exp memory divisor)\\n        internal\\n        pure\\n        returns (MathError, uint256)\\n    {\\n        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\\n        if (err != MathError.NO_ERROR) {\\n            return (err, 0);\\n        }\\n\\n        return (MathError.NO_ERROR, truncate(fraction));\\n    }\\n\\n    /**\\n     * @dev Multiplies two exponentials, returning a new exponential.\\n     */\\n    function mulExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\\n        (MathError err0, uint256 doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);\\n        if (err0 != MathError.NO_ERROR) {\\n            return (err0, Exp({mantissa: 0}));\\n        }\\n\\n        // We add half the scale before dividing so that we get rounding instead of truncation.\\n        //  See \\\"Listing 6\\\" and text above it at https://accu.org/index.php/journals/1717\\n        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\\n        (MathError err1, uint256 doubleScaledProductWithHalfScale) =\\n            addUInt(halfExpScale, doubleScaledProduct);\\n        if (err1 != MathError.NO_ERROR) {\\n            return (err1, Exp({mantissa: 0}));\\n        }\\n\\n        (MathError err2, uint256 product) = divUInt(doubleScaledProductWithHalfScale, expScale);\\n        // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\\n        assert(err2 == MathError.NO_ERROR);\\n\\n        return (MathError.NO_ERROR, Exp({mantissa: product}));\\n    }\\n\\n    /**\\n     * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\\n     */\\n    function mulExp(uint256 a, uint256 b) internal pure returns (MathError, Exp memory) {\\n        return mulExp(Exp({mantissa: a}), Exp({mantissa: b}));\\n    }\\n\\n    /**\\n     * @dev Multiplies three exponentials, returning a new exponential.\\n     */\\n    function mulExp3(\\n        Exp memory a,\\n        Exp memory b,\\n        Exp memory c\\n    ) internal pure returns (MathError, Exp memory) {\\n        (MathError err, Exp memory ab) = mulExp(a, b);\\n        if (err != MathError.NO_ERROR) {\\n            return (err, ab);\\n        }\\n        return mulExp(ab, c);\\n    }\\n\\n    /**\\n     * @dev Divides two exponentials, returning a new exponential.\\n     *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\\n     *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\\n     */\\n    function divExp(Exp memory a, Exp memory b) internal pure returns (MathError, Exp memory) {\\n        return getExp(a.mantissa, b.mantissa);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/CarefulMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\n/**\\n * @title Careful Math\\n * @author Compound\\n * @notice Derived from OpenZeppelin's SafeMath library\\n *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\\n */\\nabstract contract CarefulMath {\\n    /**\\n     * @dev Possible error codes that we can return\\n     */\\n    enum MathError {NO_ERROR, DIVISION_BY_ZERO, INTEGER_OVERFLOW, INTEGER_UNDERFLOW}\\n\\n    /**\\n     * @dev Multiplies two numbers, returns an error on overflow.\\n     */\\n    function mulUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\\n        if (a == 0) {\\n            return (MathError.NO_ERROR, 0);\\n        }\\n\\n        uint256 c = a * b;\\n\\n        if (c / a != b) {\\n            return (MathError.INTEGER_OVERFLOW, 0);\\n        } else {\\n            return (MathError.NO_ERROR, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Integer division of two numbers, truncating the quotient.\\n     */\\n    function divUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\\n        if (b == 0) {\\n            return (MathError.DIVISION_BY_ZERO, 0);\\n        }\\n\\n        return (MathError.NO_ERROR, a / b);\\n    }\\n\\n    /**\\n     * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\\n     */\\n    function subUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\\n        if (b <= a) {\\n            return (MathError.NO_ERROR, a - b);\\n        } else {\\n            return (MathError.INTEGER_UNDERFLOW, 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Adds two numbers, returns an error on overflow.\\n     */\\n    function addUInt(uint256 a, uint256 b) internal pure returns (MathError, uint256) {\\n        uint256 c = a + b;\\n\\n        if (c >= a) {\\n            return (MathError.NO_ERROR, c);\\n        } else {\\n            return (MathError.INTEGER_OVERFLOW, 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev add a and b and then subtract c\\n     */\\n    function addThenSubUInt(\\n        uint256 a,\\n        uint256 b,\\n        uint256 c\\n    ) internal pure returns (MathError, uint256) {\\n        (MathError err0, uint256 sum) = addUInt(a, b);\\n\\n        if (err0 != MathError.NO_ERROR) {\\n            return (err0, 0);\\n        }\\n\\n        return subUInt(sum, c);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/ExponentialNoError.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\n/**\\n * @title Exponential module for storing fixed-precision decimals\\n * @author Compound\\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\\n *         `Exp({mantissa: 5100000000000000000})`.\\n */\\nabstract contract ExponentialNoError {\\n    uint256 constant expScale = 1e18;\\n    uint256 constant doubleScale = 1e36;\\n    uint256 constant halfExpScale = expScale / 2;\\n    uint256 constant mantissaOne = expScale;\\n\\n    struct Exp {\\n        uint256 mantissa;\\n    }\\n\\n    struct Double {\\n        uint256 mantissa;\\n    }\\n\\n    /**\\n     * @dev Truncates the given exp to a whole number value.\\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\\n     */\\n    function truncate(Exp memory exp) internal pure returns (uint256) {\\n        // Note: We are not using careful math here as we're performing a division that cannot fail\\n        return exp.mantissa / expScale;\\n    }\\n\\n    /**\\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\\n     */\\n    function mul_ScalarTruncate(Exp memory a, uint256 scalar) internal pure returns (uint256) {\\n        Exp memory product = mul_(a, scalar);\\n        return truncate(product);\\n    }\\n\\n    /**\\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\\n     */\\n    function mul_ScalarTruncateAddUInt(\\n        Exp memory a,\\n        uint256 scalar,\\n        uint256 addend\\n    ) internal pure returns (uint256) {\\n        Exp memory product = mul_(a, scalar);\\n        return add_(truncate(product), addend);\\n    }\\n\\n    /**\\n     * @dev Checks if first Exp is less than second Exp.\\n     */\\n    function lessThanExp(Exp memory left, Exp memory right) internal pure returns (bool) {\\n        return left.mantissa < right.mantissa;\\n    }\\n\\n    /**\\n     * @dev Checks if left Exp <= right Exp.\\n     */\\n    function lessThanOrEqualExp(Exp memory left, Exp memory right) internal pure returns (bool) {\\n        return left.mantissa <= right.mantissa;\\n    }\\n\\n    /**\\n     * @dev Checks if left Exp > right Exp.\\n     */\\n    function greaterThanExp(Exp memory left, Exp memory right) internal pure returns (bool) {\\n        return left.mantissa > right.mantissa;\\n    }\\n\\n    /**\\n     * @dev returns true if Exp is exactly zero\\n     */\\n    function isZeroExp(Exp memory value) internal pure returns (bool) {\\n        return value.mantissa == 0;\\n    }\\n\\n    function safe224(uint256 n, string memory errorMessage) internal pure returns (uint224) {\\n        require(n < 2**224, errorMessage);\\n        return uint224(n);\\n    }\\n\\n    function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\\n        require(n < 2**32, errorMessage);\\n        return uint32(n);\\n    }\\n\\n    function add_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\\n        return Exp({mantissa: add_(a.mantissa, b.mantissa)});\\n    }\\n\\n    function add_(Double memory a, Double memory b) internal pure returns (Double memory) {\\n        return Double({mantissa: add_(a.mantissa, b.mantissa)});\\n    }\\n\\n    function add_(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return add_(a, b, \\\"addition overflow\\\");\\n    }\\n\\n    function add_(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, errorMessage);\\n        return c;\\n    }\\n\\n    function sub_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\\n        return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\\n    }\\n\\n    function sub_(Double memory a, Double memory b) internal pure returns (Double memory) {\\n        return Double({mantissa: sub_(a.mantissa, b.mantissa)});\\n    }\\n\\n    function sub_(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub_(a, b, \\\"subtraction underflow\\\");\\n    }\\n\\n    function sub_(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    function mul_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\\n        return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\\n    }\\n\\n    function mul_(Exp memory a, uint256 b) internal pure returns (Exp memory) {\\n        return Exp({mantissa: mul_(a.mantissa, b)});\\n    }\\n\\n    function mul_(uint256 a, Exp memory b) internal pure returns (uint256) {\\n        return mul_(a, b.mantissa) / expScale;\\n    }\\n\\n    function mul_(Double memory a, Double memory b) internal pure returns (Double memory) {\\n        return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\\n    }\\n\\n    function mul_(Double memory a, uint256 b) internal pure returns (Double memory) {\\n        return Double({mantissa: mul_(a.mantissa, b)});\\n    }\\n\\n    function mul_(uint256 a, Double memory b) internal pure returns (uint256) {\\n        return mul_(a, b.mantissa) / doubleScale;\\n    }\\n\\n    function mul_(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mul_(a, b, \\\"multiplication overflow\\\");\\n    }\\n\\n    function mul_(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        if (a == 0 || b == 0) {\\n            return 0;\\n        }\\n        uint256 c = a * b;\\n        require(c / a == b, errorMessage);\\n        return c;\\n    }\\n\\n    function div_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\\n        return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\\n    }\\n\\n    function div_(Exp memory a, uint256 b) internal pure returns (Exp memory) {\\n        return Exp({mantissa: div_(a.mantissa, b)});\\n    }\\n\\n    function div_(uint256 a, Exp memory b) internal pure returns (uint256) {\\n        return div_(mul_(a, expScale), b.mantissa);\\n    }\\n\\n    function div_(Double memory a, Double memory b) internal pure returns (Double memory) {\\n        return Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\\n    }\\n\\n    function div_(Double memory a, uint256 b) internal pure returns (Double memory) {\\n        return Double({mantissa: div_(a.mantissa, b)});\\n    }\\n\\n    function div_(uint256 a, Double memory b) internal pure returns (uint256) {\\n        return div_(mul_(a, doubleScale), b.mantissa);\\n    }\\n\\n    function div_(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div_(a, b, \\\"divide by zero\\\");\\n    }\\n\\n    function div_(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    function fraction(uint256 a, uint256 b) internal pure returns (Double memory) {\\n        return Double({mantissa: div_(mul_(a, doubleScale), b)});\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/oracle/BscAprOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"../interfaces/IAprOracle.sol\\\";\\nimport \\\"../utils/SafeDecimalMath.sol\\\";\\nimport \\\"../utils/Exponential.sol\\\";\\nimport \\\"../utils/CoreUtility.sol\\\";\\n\\n// Venus\\ninterface VTokenInterfaces {\\n    function borrowIndex() external view returns (uint256);\\n\\n    function borrowRatePerBlock() external view returns (uint256);\\n\\n    function accrualBlockNumber() external view returns (uint256);\\n}\\n\\ncontract BscAprOracle is IAprOracle, Exponential, CoreUtility {\\n    using SafeMath for uint256;\\n    using SafeDecimalMath for uint256;\\n\\n    uint256 public constant VENUS_BORROW_MAX_MANTISSA = 0.0005e16;\\n\\n    address public immutable vUsdc;\\n\\n    string public name;\\n    uint256 public venusBorrowIndex;\\n    uint256 public timestamp;\\n    uint256 public currentDailyRate;\\n\\n    constructor(string memory name_, address vUsdc_) public {\\n        name = name_;\\n        vUsdc = vUsdc_;\\n        venusBorrowIndex = getVenusBorrowIndex(vUsdc_);\\n        timestamp = block.timestamp;\\n    }\\n\\n    // Venus\\n    function getVenusBorrowIndex(address vToken) public view returns (uint256 newBorrowIndex) {\\n        /* Calculate the current borrow interest rate */\\n        uint256 borrowRateMantissa = VTokenInterfaces(vToken).borrowRatePerBlock();\\n        require(borrowRateMantissa <= VENUS_BORROW_MAX_MANTISSA, \\\"Borrow rate is absurdly high\\\");\\n\\n        uint256 borrowIndexPrior = VTokenInterfaces(vToken).borrowIndex();\\n        uint256 accrualBlockNumber = VTokenInterfaces(vToken).accrualBlockNumber();\\n\\n        (, uint256 blockDelta) = subUInt(block.number, accrualBlockNumber);\\n\\n        (, Exp memory simpleInterestFactor) =\\n            mulScalar(Exp({mantissa: borrowRateMantissa}), blockDelta);\\n        (, newBorrowIndex) = mulScalarTruncateAddUInt(\\n            simpleInterestFactor,\\n            borrowIndexPrior,\\n            borrowIndexPrior\\n        );\\n    }\\n\\n    function getAverageDailyRate()\\n        public\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256 newVenusBorrowIndex = getVenusBorrowIndex(vUsdc);\\n\\n        uint256 venusPeriodicRate =\\n            newVenusBorrowIndex.sub(venusBorrowIndex).divideDecimal(venusBorrowIndex);\\n\\n        uint256 dailyRate = venusPeriodicRate.mul(1 days).div(block.timestamp.sub(timestamp));\\n\\n        return (newVenusBorrowIndex, venusPeriodicRate, dailyRate);\\n    }\\n\\n    function capture() external override returns (uint256 dailyRate) {\\n        uint256 currentWeek = _endOfWeek(timestamp);\\n        if (currentWeek > block.timestamp) {\\n            return currentDailyRate;\\n        }\\n\\n        (venusBorrowIndex, , dailyRate) = getAverageDailyRate();\\n        timestamp = block.timestamp;\\n        currentDailyRate = dailyRate;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/governance/VestingEscrow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\n/// @notice Vests `Chess` tokens for a single address\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\ncontract VestingEscrow is Ownable {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    event Fund(uint256 amount);\\n    event Claim(uint256 amount);\\n    event ToggleDisable(bool disabled);\\n\\n    address public immutable token;\\n    address public immutable recipient;\\n    uint256 public immutable startTime;\\n    uint256 public immutable endTime;\\n    bool public canDisable;\\n\\n    uint256 public initialLocked;\\n    uint256 public vestedAtStart;\\n    uint256 public totalClaimed;\\n    uint256 public disabledAt;\\n\\n    constructor(\\n        address token_,\\n        address recipient_,\\n        uint256 startTime_,\\n        uint256 endTime_,\\n        bool canDisable_\\n    ) public {\\n        token = token_;\\n        recipient = recipient_;\\n        startTime = startTime_;\\n        endTime = endTime_;\\n        canDisable = canDisable_;\\n    }\\n\\n    function initialize(uint256 amount, uint256 vestedAtStart_) external {\\n        require(amount != 0 && amount >= vestedAtStart_, \\\"Invalid amount or vestedAtStart\\\");\\n        require(initialLocked == 0, \\\"Already initialized\\\");\\n\\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\\n\\n        initialLocked = amount;\\n        vestedAtStart = vestedAtStart_;\\n        emit Fund(amount);\\n    }\\n\\n    /// @notice Get the total number of tokens which have vested, that are held\\n    ///         by this contract\\n    function vestedSupply() external view returns (uint256) {\\n        return _totalVestedOf(block.timestamp);\\n    }\\n\\n    /// @notice Get the total number of tokens which are still locked\\n    ///         (have not yet vested)\\n    function lockedSupply() external view returns (uint256) {\\n        return initialLocked.sub(_totalVestedOf(block.timestamp));\\n    }\\n\\n    /// @notice Get the number of unclaimed, vested tokens for a given address\\n    /// @param account address to check\\n    function balanceOf(address account) external view returns (uint256) {\\n        if (account != recipient) {\\n            return 0;\\n        }\\n        return _totalVestedOf(block.timestamp).sub(totalClaimed);\\n    }\\n\\n    /// @notice Disable or re-enable a vested address's ability to claim tokens\\n    /// @dev When disabled, the address is only unable to claim tokens which are still\\n    ///      locked at the time of this call. It is not possible to block the claim\\n    ///      of tokens which have already vested.\\n    function toggleDisable() external onlyOwner {\\n        require(canDisable, \\\"Cannot disable\\\");\\n\\n        bool isDisabled = disabledAt == 0;\\n        if (isDisabled) {\\n            disabledAt = block.timestamp;\\n        } else {\\n            disabledAt = 0;\\n        }\\n\\n        emit ToggleDisable(isDisabled);\\n    }\\n\\n    /// @notice Disable the ability to call `toggleDisable`\\n    function disableCanDisable() external onlyOwner {\\n        canDisable = false;\\n    }\\n\\n    /// @notice Claim tokens which have vested\\n    function claim() external {\\n        uint256 timestamp = disabledAt;\\n        if (timestamp == 0) {\\n            timestamp = block.timestamp;\\n        }\\n        uint256 claimable = _totalVestedOf(timestamp).sub(totalClaimed);\\n        totalClaimed = totalClaimed.add(claimable);\\n        IERC20(token).safeTransfer(recipient, claimable);\\n\\n        emit Claim(claimable);\\n    }\\n\\n    function _totalVestedOf(uint256 timestamp) internal view returns (uint256) {\\n        uint256 start = startTime;\\n        uint256 end = endTime;\\n        uint256 locked = initialLocked;\\n        if (timestamp < start) {\\n            return 0;\\n        } else if (timestamp > end) {\\n            return locked;\\n        }\\n        uint256 vestedAtStart_ = vestedAtStart;\\n        return\\n            locked.sub(vestedAtStart_).mul(timestamp - start).div(end - start).add(vestedAtStart_);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/governance/ChessSchedule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\n\\nimport \\\"../interfaces/IChessSchedule.sol\\\";\\nimport \\\"../utils/CoreUtility.sol\\\";\\n\\nimport \\\"./ChessRoles.sol\\\";\\n\\ncontract ChessSchedule is IChessSchedule, OwnableUpgradeable, ChessRoles, CoreUtility {\\n    /// @dev Reserved storage slots for future base contract upgrades\\n    uint256[32] private _reservedSlots;\\n\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    uint256 public constant MAX_SUPPLY = 120_000_000e18;\\n\\n    /// @dev Hard-coded cumulative weekly supply. Please refer to the whitepaper for details.\\n    ///      Below are the concrete numbers in this list, which are also tested in \\\"test/chessSchedule.ts\\\".\\n    ///\\n    ///      ```\\n    ///         300000    900000   1800000   3000000   5400000   7704000   9915840  12039206  14077638  16034532\\n    ///       17913151  19716625  21447960  23110041  24705640  26237414  27707917  29119601  30474817  31775824\\n    ///       33037801  34261919  35449313  36601086  37718305  38802007  39853199  40872855  41861921  42921315\\n    ///       43931928  44894622  45810235  46679580  47503444  48302592  49077766  49829685  50559047  51266527\\n    ///       51959858  52639322  53305197  53957754  54597261  55223977  55838159  56440057  57029917  57607980\\n    ///       58174482  58729653  59273722  59806909  60329432  60841504  61343336  61835130  62317089  62789409\\n    ///       63252282  63705898  64150441  64586093  65013033  65431434  65841466  66243298  66637094  67023013\\n    ///      ```\\n    bytes private constant CUMULATIVE_SUPPLY_SCHEDULE =\\n        hex\\\"000000000000000000000000000000000000000000003f870857a3e0e380000000000000000000000000000000000000000000000000be951906eba2aa800000000000000000000000000000000000000000000000017d2a320dd74555000000000000000000000000000000000000000000000000027b46536c66c8e300000000000000000000000000000000000000000000000004777e962985cfff000000000000000000000000000000000000000000000000065f62ad457aa39f0000000000000000000000000000000000000000000000000833c2c374cc129f00000000000000000000000000000000000000000000000009f566aa3e18d928d800000000000000000000000000000000000000000000000ba50e48ffcd3def5800000000000000000000000000000000000000000000000d4371b8b190797d1000000000000000000000000000000000000000000000000ed141dc8c1e6e659c0000000000000000000000000000000000000000000000104f28620947a945a4000000000000000000000000000000000000000000000011bdc83dca5db1a5600000000000000000000000000000000000000000000000131dbdd53a5724eec40000000000000000000000000000000000000000000000146f9f6d938553a8a0000000000000000000000000000000000000000000000015b3fd101e26da27d8000000000000000000000000000000000000000000000016eb6130b8f80c68140000000000000000000000000000000000000000000000181650bbb9e9a9b324000000000000000000000000000000000000000000000019354b23ced790486400000000000000000000000000000000000000000000001a48cadee3f50e3f4000000000000000000000000000000000000000000000001b5406c7ea3059ae0400000000000000000000000000000000000000000000001c573e59c54139431c00000000000000000000000000000000000000000000001d52af1bbf2e3022e400000000000000000000000000000000000000000000001e4694d90b274c853800000000000000000000000000000000000000000000001f33296942ab5917e400000000000000000000000000000000000000000000002018a503a9d012eafc000000000000000000000000000000000000000000000020f73e3f2f422970dc000000000000000000000000000000000000000000000021cf29e8ca212387fc000000000000000000000000000000000000000000000022a09b48dd90e1bfe400000000000000000000000000000000000000000000002380f126009ae94fac00000000000000000000000000000000000000000000002456f296c5adc1756000000000000000000000000000000000000000000000002522ce55d3fa57d3b8000000000000000000000000000000000000000000000025e4b1d0c190c25c0c0000000000000000000000000000000000000000000000269cc91a32a98ba6f00000000000000000000000000000000000000000000000274b3edbf8eeff4cd0000000000000000000000000000000000000000000000027f478c257eb6de800000000000000000000000000000000000000000000000028989f06a12b8ea45800000000000000000000000000000000000000000000002937d8a2f5d1f4a3b4000000000000000000000000000000000000000000000029d24b6e0804764cbc00000000000000000000000000000000000000000000002a681bff597ec5fc1c00000000000000000000000000000000000000000000002afaed8bd921b3118800000000000000000000000000000000000000000000002b8acf5d102f23f12800000000000000000000000000000000000000000000002c17d085050e30619400000000000000000000000000000000000000000000002ca1ffb499270695a800000000000000000000000000000000000000000000002d296b730bbdb9ca1400000000000000000000000000000000000000000000002dae21cab5aa0c590400000000000000000000000000000000000000000000002e3030aa2e56594ddc00000000000000000000000000000000000000000000002eafa59ee82e12204400000000000000000000000000000000000000000000002f2c8dfed2c1d9aa5400000000000000000000000000000000000000000000002fa6f6da7a10d081300000000000000000000000000000000000000000000000301eecfd068894f508000000000000000000000000000000000000000000000030947cde5c4e8f69b400000000000000000000000000000000000000000000003107b2e87ed1749ba8000000000000000000000000000000000000000000000031789b088b13a864d4000000000000000000000000000000000000000000000031e7410fdcaa27506000000000000000000000000000000000000000000000003253b08a6b986ba480000000000000000000000000000000000000000000000032bdf4e86e748858a000000000000000000000000000000000000000000000003326191d35683f81a80000000000000000000000000000000000000000000000338c2829f15406dbe4000000000000000000000000000000000000000000000033f02caeae196a8fe4000000000000000000000000000000000000000000000034523113f4bf2828a8000000000000000000000000000000000000000000000034b23fa68cde95e26800000000000000000000000000000000000000000000003510625ff9c8d40d040000000000000000000000000000000000000000000000356ca31dfd619ba994000000000000000000000000000000000000000000000035c70b94b7688ac3040000000000000000000000000000000000000000000000361fa52503550977e80000000000000000000000000000000000000000000000367679061a7a64f0a8000000000000000000000000000000000000000000000036cb9061557536ae480000000000000000000000000000000000000000000000371ef41aa95095ecd800000000000000000000000000000000000000000000003770acd0a78617a3740000\\\";\\n\\n    IERC20 public immutable chess;\\n    uint256 public immutable startTimestamp;\\n\\n    uint256 public minted;\\n\\n    constructor(address chess_, uint256 startTimestamp_) public ChessRoles() {\\n        require(\\n            _endOfWeek(startTimestamp_ - 1) == startTimestamp_,\\n            \\\"Start timestamp is not start of a trading week\\\"\\n        );\\n        chess = IERC20(chess_);\\n        startTimestamp = startTimestamp_;\\n    }\\n\\n    /// @notice Initialize ownership and deposit tokens.\\n    function initialize() external initializer {\\n        __Ownable_init();\\n        chess.safeTransferFrom(msg.sender, address(this), MAX_SUPPLY);\\n    }\\n\\n    /// @notice Get length of the supply schedule\\n    /// @return The length of the supply schedule\\n    function getScheduleLength() public pure returns (uint256) {\\n        return CUMULATIVE_SUPPLY_SCHEDULE.length / 32;\\n    }\\n\\n    /// @notice Get the total supply and weekly supply at the given week index\\n    /// @param index Index for weekly supply\\n    /// @return currentWeekCumulativeSupply The cumulative supply at the\\n    ///         beginning of the week\\n    /// @return weeklySupply Weekly supply\\n    function getWeeklySupply(uint256 index)\\n        public\\n        pure\\n        returns (uint256 currentWeekCumulativeSupply, uint256 weeklySupply)\\n    {\\n        uint256 length = getScheduleLength();\\n        bytes memory scheduleBytes = CUMULATIVE_SUPPLY_SCHEDULE;\\n        if (index == 0) {\\n            assembly {\\n                weeklySupply := mload(add(scheduleBytes, 32))\\n            }\\n        } else if (index < length) {\\n            uint256 offset = index * 32;\\n            uint256 nextWeekCumulativeSupply;\\n            assembly {\\n                currentWeekCumulativeSupply := mload(add(scheduleBytes, offset))\\n                nextWeekCumulativeSupply := mload(add(scheduleBytes, add(offset, 32)))\\n            }\\n            weeklySupply = nextWeekCumulativeSupply.sub(currentWeekCumulativeSupply);\\n        } else {\\n            uint256 offset = length * 32;\\n            assembly {\\n                currentWeekCumulativeSupply := mload(add(scheduleBytes, offset))\\n            }\\n        }\\n    }\\n\\n    /// @notice Current number of tokens in existence (claimed or unclaimed)\\n    function availableSupply() public view returns (uint256) {\\n        if (block.timestamp < startTimestamp) {\\n            return 0;\\n        }\\n        uint256 index = (block.timestamp - startTimestamp) / 1 weeks;\\n        uint256 currentWeek = index * 1 weeks + startTimestamp;\\n        (uint256 currentWeekCumulativeSupply, uint256 weeklySupply) = getWeeklySupply(index);\\n        return\\n            currentWeekCumulativeSupply.add(\\n                weeklySupply.mul(block.timestamp - currentWeek).div(1 weeks)\\n            );\\n    }\\n\\n    /// @notice Get the release rate of CHESS token at the given timestamp\\n    /// @param timestamp Timestamp for release rate\\n    /// @return Release rate (number of CHESS token per second)\\n    function getRate(uint256 timestamp) external view override returns (uint256) {\\n        if (timestamp < startTimestamp) {\\n            return 0;\\n        }\\n        uint256 index = (timestamp - startTimestamp) / 1 weeks;\\n        (, uint256 weeklySupply) = getWeeklySupply(index);\\n        return weeklySupply.div(1 weeks);\\n    }\\n\\n    /// @notice Creates `amount` CHESS tokens and assigns them to `account`,\\n    ///         increasing the total supply. This is guarded by `Minter` role.\\n    /// @param account recipient of the token\\n    /// @param amount amount of the token\\n    function mint(address account, uint256 amount) external override onlyMinter {\\n        require(minted.add(amount) <= availableSupply(), \\\"Exceeds allowable mint amount\\\");\\n        chess.safeTransfer(account, amount);\\n        minted = minted.add(amount);\\n    }\\n\\n    function addMinter(address account) external override onlyOwner {\\n        _addMinter(account);\\n    }\\n\\n    function removeMinter(address account) external onlyOwner {\\n        _removeMinter(account);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/governance/ChessRoles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/EnumerableSet.sol\\\";\\n\\nabstract contract ChessRoles {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    EnumerableSet.AddressSet private _minterMembers;\\n\\n    event MinterAdded(address indexed minter);\\n    event MinterRemoved(address indexed minter);\\n\\n    modifier onlyMinter() {\\n        require(isMinter(msg.sender), \\\"Only minter\\\");\\n        _;\\n    }\\n\\n    function isMinter(address account) public view returns (bool) {\\n        return _minterMembers.contains(account);\\n    }\\n\\n    function getMinterMember(uint256 index) external view returns (address) {\\n        return _minterMembers.at(index);\\n    }\\n\\n    function getMinterCount() external view returns (uint256) {\\n        return _minterMembers.length();\\n    }\\n\\n    function _addMinter(address minter) internal {\\n        if (_minterMembers.add(minter)) {\\n            emit MinterAdded(minter);\\n        }\\n    }\\n\\n    function _removeMinter(address minter) internal {\\n        if (_minterMembers.remove(minter)) {\\n            emit MinterRemoved(minter);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/swap/BishopStableSwap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\\\";\\n\\nimport \\\"../interfaces/IPrimaryMarketV3.sol\\\";\\nimport \\\"../interfaces/ITrancheIndexV2.sol\\\";\\nimport \\\"./StableSwap.sol\\\";\\n\\ncontract BishopStableSwap is StableSwap, ITrancheIndexV2 {\\n    event Rebalanced(uint256 base, uint256 quote, uint256 version);\\n\\n    uint256 public immutable tradingCurbThreshold;\\n\\n    uint256 public currentVersion;\\n\\n    constructor(\\n        address lpToken_,\\n        address fund_,\\n        address quoteAddress_,\\n        uint256 quoteDecimals_,\\n        uint256 ampl_,\\n        address feeCollector_,\\n        uint256 feeRate_,\\n        uint256 adminFeeRate_,\\n        uint256 tradingCurbThreshold_\\n    )\\n        public\\n        StableSwap(\\n            lpToken_,\\n            fund_,\\n            TRANCHE_B,\\n            quoteAddress_,\\n            quoteDecimals_,\\n            ampl_,\\n            feeCollector_,\\n            feeRate_,\\n            adminFeeRate_\\n        )\\n    {\\n        tradingCurbThreshold = tradingCurbThreshold_;\\n        currentVersion = IFundV3(fund_).getRebalanceSize();\\n    }\\n\\n    /// @dev Make sure the user-specified version is the latest rebalance version.\\n    modifier checkVersion(uint256 version) override {\\n        require(version == fund.getRebalanceSize(), \\\"Obsolete rebalance version\\\");\\n        _;\\n    }\\n\\n    function _getRebalanceResult(uint256 latestVersion)\\n        internal\\n        view\\n        override\\n        returns (\\n            uint256 newBase,\\n            uint256 newQuote,\\n            uint256 excessiveQ,\\n            uint256 excessiveB,\\n            uint256 excessiveR,\\n            uint256 excessiveQuote,\\n            bool isRebalanced\\n        )\\n    {\\n        if (latestVersion == currentVersion) {\\n            return (baseBalance, quoteBalance, 0, 0, 0, 0, false);\\n        }\\n        isRebalanced = true;\\n\\n        uint256 oldBaseBalance = baseBalance;\\n        uint256 oldQuoteBalance = quoteBalance;\\n        (excessiveQ, newBase, ) = fund.batchRebalance(\\n            0,\\n            oldBaseBalance,\\n            0,\\n            currentVersion,\\n            latestVersion\\n        );\\n        if (newBase < oldBaseBalance) {\\n            // We split all QUEEN from rebalance if the amount of BISHOP is smaller than before.\\n            // In almost all cases, the total amount of BISHOP after the split is still smaller\\n            // than before.\\n            excessiveR = IPrimaryMarketV3(fund.primaryMarket()).getSplit(excessiveQ);\\n            newBase = newBase.add(excessiveR);\\n        }\\n        if (newBase < oldBaseBalance) {\\n            // If BISHOP amount is still smaller than before, we remove quote tokens proportionally.\\n            newQuote = oldQuoteBalance.mul(newBase).div(oldBaseBalance);\\n            excessiveQuote = oldQuoteBalance - newQuote;\\n        } else {\\n            // In most cases when we reach here, the BISHOP amount remains the same (ratioBR = 1).\\n            newQuote = oldQuoteBalance;\\n            excessiveB = newBase - oldBaseBalance;\\n            newBase = oldBaseBalance;\\n        }\\n    }\\n\\n    function _handleRebalance(uint256 latestVersion)\\n        internal\\n        override\\n        returns (uint256 newBase, uint256 newQuote)\\n    {\\n        uint256 excessiveQ;\\n        uint256 excessiveB;\\n        uint256 excessiveR;\\n        uint256 excessiveQuote;\\n        bool isRebalanced;\\n        (\\n            newBase,\\n            newQuote,\\n            excessiveQ,\\n            excessiveB,\\n            excessiveR,\\n            excessiveQuote,\\n            isRebalanced\\n        ) = _getRebalanceResult(latestVersion);\\n        if (isRebalanced) {\\n            baseBalance = newBase;\\n            quoteBalance = newQuote;\\n            currentVersion = latestVersion;\\n            emit Rebalanced(newBase, newQuote, latestVersion);\\n            if (excessiveQ > 0) {\\n                if (excessiveR > 0) {\\n                    IPrimaryMarketV3(fund.primaryMarket()).split(\\n                        address(this),\\n                        excessiveQ,\\n                        latestVersion\\n                    );\\n                    excessiveQ = 0;\\n                } else {\\n                    fund.trancheTransfer(TRANCHE_Q, lpToken, excessiveQ, latestVersion);\\n                }\\n            }\\n            if (excessiveB > 0) {\\n                fund.trancheTransfer(TRANCHE_B, lpToken, excessiveB, latestVersion);\\n            }\\n            if (excessiveR > 0) {\\n                fund.trancheTransfer(TRANCHE_R, lpToken, excessiveR, latestVersion);\\n            }\\n            if (excessiveQuote > 0) {\\n                IERC20(quoteAddress).safeTransfer(lpToken, excessiveQuote);\\n            }\\n            ILiquidityGauge(lpToken).distribute(\\n                excessiveQ,\\n                excessiveB,\\n                excessiveR,\\n                excessiveQuote,\\n                latestVersion\\n            );\\n        }\\n    }\\n\\n    function getOraclePrice() public view override returns (uint256) {\\n        uint256 price = fund.twapOracle().getLatest();\\n        (, uint256 navB, uint256 navR) = fund.extrapolateNav(price);\\n        require(navR >= navB.multiplyDecimal(tradingCurbThreshold), \\\"Trading curb\\\");\\n        return navB;\\n    }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\ninterface AggregatorV3Interface {\\n\\n  function decimals()\\n    external\\n    view\\n    returns (\\n      uint8\\n    );\\n\\n  function description()\\n    external\\n    view\\n    returns (\\n      string memory\\n    );\\n\\n  function version()\\n    external\\n    view\\n    returns (\\n      uint256\\n    );\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(\\n    uint80 _roundId\\n  )\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n}\\n\"\r\n    },\r\n    \"contracts/oracle/ChainlinkTwapOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\\\";\\nimport \\\"@uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol\\\";\\nimport \\\"@uniswap/lib/contracts/libraries/FixedPoint.sol\\\";\\n\\nimport \\\"../interfaces/ITwapOracleV2.sol\\\";\\n\\n/// @title Time-weighted average price oracle\\n/// @notice This contract extends the Chainlink Oracle, computes\\n///         time-weighted average price (TWAP) in every 30-minute epoch.\\n/// @author Tranchess\\n/// @dev This contract relies on the following assumptions on the Chainlink aggregator:\\n///      1. Round ID returned by `latestRoundData()` is monotonically increasing over time.\\n///      2. Round ID is continuous in the same phase. Formally speaking, let `x` and `y` be two\\n///         round IDs returned by `latestRoundData` in different blocks and they satisfy `x < y`\\n///         and `x >> 64 == y >> 64`. Then every integer between `x` and `y` is a valid round ID.\\n///      3. Phase change is rare.\\n///      4. Each round is updated only once and `updatedAt` returned by `getRoundData()` is\\n///         timestamp of the block in which the round is updated. Therefore, a transaction is\\n///         guaranteed to see all rounds whose `updatedAt` is less than the current block timestamp.\\ncontract ChainlinkTwapOracle is ITwapOracleV2, Ownable {\\n    using FixedPoint for FixedPoint.uq112x112;\\n    using FixedPoint for FixedPoint.uq144x112;\\n    using SafeMath for uint256;\\n\\n    uint256 private constant EPOCH = 30 minutes;\\n    uint256 private constant MAX_SWAP_DELAY = 15 minutes;\\n    uint256 private constant MAX_ITERATION = 500;\\n\\n    event Update(uint256 timestamp, uint256 price, UpdateType updateType);\\n\\n    /// @notice The contract fails to update an epoch from either Chainlink or Uniswap\\n    ///         and will not attempt to do so in the future.\\n    event SkipMissingData(uint256 timestamp);\\n\\n    /// @notice Twap of this epoch can be calculated from both Chainlink and Uniswap,\\n    ///         but the difference is too large. The contract decides not to update this epoch\\n    ///         using either result.\\n    event SkipDeviation(uint256 timestamp, uint256 chainlinkTwap, uint256 swapTwap);\\n\\n    /// @notice Chainlink aggregator used as the primary data source.\\n    address public immutable chainlinkAggregator;\\n\\n    /// @notice Minimum number of Chainlink rounds required in an epoch.\\n    uint256 public immutable chainlinkMinMessageCount;\\n\\n    /// @dev A multipler that normalizes price from the Chainlink aggregator to 18 decimal places.\\n    uint256 private immutable _chainlinkPriceMultiplier;\\n\\n    /// @notice Uniswap V2 pair contract used as the backup data source.\\n    address public immutable swapPair;\\n\\n    /// @dev Index of the token (0 or 1) in the pair whose price is taken.\\n    uint256 private immutable _swapTokenIndex;\\n\\n    /// @dev A multipler that normalizes price from the Uniswap V2 pair to 18 decimal places.\\n    uint256 private immutable _swapPriceMultiplier;\\n\\n    /// @notice The previous oracle that was used before this contract is deployed.\\n    ITwapOracle public immutable fallbackOracle;\\n\\n    /// @notice Epochs until this timestamp should be read from the fallback oracle.\\n    uint256 public immutable fallbackTimestamp;\\n\\n    string public symbol;\\n\\n    /// @notice The last epoch that has been updated (or attempted to update) using data from\\n    ///         Chainlink or Uniswap.\\n    uint256 public lastTimestamp;\\n\\n    /// @notice The last Chainlink round ID that has been read.\\n    uint80 public lastRoundID;\\n\\n    /// @notice The last observation of the Uniswap V2 pair cumulative price.\\n    uint256 public lastSwapCumulativePrice;\\n\\n    /// @notice Timestamp of the last Uniswap observation.\\n    uint256 public lastSwapTimestamp;\\n\\n    /// @dev Mapping of epoch end timestamp => TWAP\\n    mapping(uint256 => uint256) private _prices;\\n\\n    /// @param chainlinkAggregator_ Address of the Chainlink aggregator\\n    /// @param swapPair_ Address of the Uniswap V2 pair\\n    /// @param symbol_ Asset symbol\\n    constructor(\\n        address chainlinkAggregator_,\\n        uint256 chainlinkMinMessageCount_,\\n        address swapPair_,\\n        address fallbackOracle_,\\n        uint256 fallbackTimestamp_,\\n        string memory symbol_\\n    ) public {\\n        chainlinkAggregator = chainlinkAggregator_;\\n        chainlinkMinMessageCount = chainlinkMinMessageCount_;\\n        uint256 decimal = AggregatorV3Interface(chainlinkAggregator_).decimals();\\n        _chainlinkPriceMultiplier = 10**(uint256(18).sub(decimal));\\n\\n        swapPair = swapPair_;\\n        ERC20 swapToken0 = ERC20(IUniswapV2Pair(swapPair_).token0());\\n        ERC20 swapToken1 = ERC20(IUniswapV2Pair(swapPair_).token1());\\n        uint256 swapTokenIndex_;\\n        bytes32 symbolHash = keccak256(bytes(symbol_));\\n        if (symbolHash == keccak256(bytes(swapToken0.symbol()))) {\\n            swapTokenIndex_ = 0;\\n        } else if (symbolHash == keccak256(bytes(swapToken1.symbol()))) {\\n            swapTokenIndex_ = 1;\\n        } else {\\n            revert(\\\"Symbol mismatch\\\");\\n        }\\n        _swapTokenIndex = swapTokenIndex_;\\n        _swapPriceMultiplier = swapTokenIndex_ == 0\\n            ? 10**(uint256(18).add(swapToken0.decimals()).sub(swapToken1.decimals()))\\n            : 10**(uint256(18).add(swapToken1.decimals()).sub(swapToken0.decimals()));\\n\\n        fallbackOracle = ITwapOracle(fallbackOracle_);\\n        symbol = symbol_;\\n        lastTimestamp = (block.timestamp / EPOCH) * EPOCH + EPOCH;\\n        require(\\n            fallbackOracle_ == address(0) || fallbackTimestamp_ >= lastTimestamp,\\n            \\\"Fallback timestamp too early\\\"\\n        );\\n        fallbackTimestamp = fallbackTimestamp_;\\n        (lastRoundID, , , , ) = AggregatorV3Interface(chainlinkAggregator_).latestRoundData();\\n    }\\n\\n    /// @notice Return the latest price with 18 decimal places.\\n    function getLatest() external view override returns (uint256) {\\n        (, int256 answer, , uint256 updatedAt, ) =\\n            AggregatorV3Interface(chainlinkAggregator).latestRoundData();\\n        require(updatedAt > block.timestamp - EPOCH, \\\"Stale price oracle\\\");\\n        return uint256(answer).mul(_chainlinkPriceMultiplier);\\n    }\\n\\n    /// @notice Return TWAP with 18 decimal places in the epoch ending at the specified timestamp.\\n    ///         Zero is returned if the epoch is not initialized yet.\\n    /// @param timestamp End Timestamp in seconds of the epoch\\n    /// @return TWAP (18 decimal places) in the epoch, or zero if the epoch is not initialized yet.\\n    function getTwap(uint256 timestamp) external view override returns (uint256) {\\n        if (timestamp <= fallbackTimestamp) {\\n            return address(fallbackOracle) == address(0) ? 0 : fallbackOracle.getTwap(timestamp);\\n        } else {\\n            return _prices[timestamp];\\n        }\\n    }\\n\\n    /// @notice Attempt to update the next epoch after `lastTimestamp` using data from Chainlink\\n    ///         or Uniswap. If neither data source is available, the epoch is skipped and this\\n    ///         function will never update it in the future.\\n    ///\\n    ///         This function is designed to be called after each epoch.\\n    /// @dev First, this function reads all Chainlink rounds before the end of this epoch, and\\n    ///      calculates the TWAP if there are enough data points in this epoch.\\n    ///\\n    ///      Otherwise, it tries to use data from Uniswap. Calculating TWAP from a Uniswap pair\\n    ///      requires two observations at both endpoints of the epoch. An observation is considered\\n    ///      valid only if it's taken within `MAX_SWAP_DELAY` seconds after the desired timestamp.\\n    ///      Regardless of whether or how the epoch is updated, the current observation is stored\\n    ///      if it is valid for the next epoch's start.\\n    function update() external {\\n        uint256 timestamp = lastTimestamp + EPOCH;\\n        require(block.timestamp > timestamp, \\\"Too soon\\\");\\n\\n        (uint256 chainlinkTwap, uint80 newRoundID) = _updateTwapFromChainlink(timestamp);\\n\\n        // Only observe the Uniswap pair if it's not too late.\\n        uint256 swapTwap = 0;\\n        if (block.timestamp <= timestamp + MAX_SWAP_DELAY) {\\n            uint256 currentCumulativePrice = _observeSwap();\\n            swapTwap = _updateTwapFromSwap(timestamp, currentCumulativePrice);\\n            lastSwapCumulativePrice = currentCumulativePrice;\\n            lastSwapTimestamp = block.timestamp;\\n        }\\n\\n        if (chainlinkTwap != 0) {\\n            if (\\n                swapTwap != 0 &&\\n                (chainlinkTwap < (swapTwap / 10) * 9 || swapTwap < (chainlinkTwap / 10) * 9)\\n            ) {\\n                emit SkipDeviation(timestamp, chainlinkTwap, swapTwap);\\n            } else {\\n                _prices[timestamp] = chainlinkTwap;\\n                emit Update(timestamp, chainlinkTwap, UpdateType.CHAINLINK);\\n            }\\n        } else if (swapTwap != 0) {\\n            _prices[timestamp] = swapTwap;\\n            emit Update(timestamp, swapTwap, UpdateType.UNISWAP_V2);\\n        } else {\\n            emit SkipMissingData(timestamp);\\n        }\\n        lastTimestamp = timestamp;\\n        lastRoundID = newRoundID;\\n    }\\n\\n    /// @dev Sequentially read Chainlink oracle until end of the given epoch.\\n    /// @param timestamp End timestamp of the epoch to be updated\\n    /// @return twap TWAP of the epoch calculated from Chainlink, or zero if there's no sufficient data\\n    /// @return newRoundID The last round ID that has been read until the end of this epoch\\n    function _updateTwapFromChainlink(uint256 timestamp)\\n        private\\n        view\\n        returns (uint256 twap, uint80 newRoundID)\\n    {\\n        (uint80 roundID, int256 oldAnswer, , uint256 oldUpdatedAt, ) =\\n            _getChainlinkRoundData(lastRoundID);\\n        uint256 sum = 0;\\n        uint256 sumTimestamp = timestamp - EPOCH;\\n        uint256 messageCount = 0;\\n        for (uint256 i = 0; i < MAX_ITERATION; i++) {\\n            (, int256 newAnswer, , uint256 newUpdatedAt, ) = _getChainlinkRoundData(++roundID);\\n            if (newUpdatedAt < oldUpdatedAt || newUpdatedAt > timestamp) {\\n                // This round is either not available yet (newUpdatedAt < updatedAt)\\n                // or beyond the current epoch (newUpdatedAt > timestamp).\\n                roundID--;\\n                break;\\n            }\\n            if (newUpdatedAt > sumTimestamp) {\\n                sum = sum.add(uint256(oldAnswer).mul(newUpdatedAt - sumTimestamp));\\n                sumTimestamp = newUpdatedAt;\\n                messageCount++;\\n            }\\n            oldAnswer = newAnswer;\\n            oldUpdatedAt = newUpdatedAt;\\n        }\\n\\n        if (messageCount >= chainlinkMinMessageCount) {\\n            sum = sum.add(uint256(oldAnswer).mul(timestamp - sumTimestamp));\\n            return (sum.mul(_chainlinkPriceMultiplier) / EPOCH, roundID);\\n        } else {\\n            return (0, roundID);\\n        }\\n    }\\n\\n    /// @dev Calculate TWAP for the given epoch.\\n    /// @param timestamp End timestamp of the epoch to be updated\\n    /// @param currentCumulativePrice Current observation of the Uniswap pair\\n    /// @return TWAP of the epoch calculated from Uniswap, or zero if either observation is invalid\\n    function _updateTwapFromSwap(uint256 timestamp, uint256 currentCumulativePrice)\\n        private\\n        view\\n        returns (uint256)\\n    {\\n        uint256 t = lastSwapTimestamp;\\n        if (t <= timestamp - EPOCH || t > timestamp - EPOCH + MAX_SWAP_DELAY) {\\n            // The last observation is not taken near the start of this epoch and cannot be used\\n            // to update this epoch.\\n            return 0;\\n        } else {\\n            return\\n                _getSwapTwap(lastSwapCumulativePrice, currentCumulativePrice, t, block.timestamp);\\n        }\\n    }\\n\\n    /// @dev Call `chainlinkAggregator.getRoundData(roundID)`. Return zero if the call reverts.\\n    function _getChainlinkRoundData(uint80 roundID)\\n        private\\n        view\\n        returns (\\n            uint80,\\n            int256,\\n            uint256,\\n            uint256,\\n            uint80\\n        )\\n    {\\n        (bool success, bytes memory returnData) =\\n            chainlinkAggregator.staticcall(\\n                abi.encodePacked(AggregatorV3Interface.getRoundData.selector, abi.encode(roundID))\\n            );\\n        if (success) {\\n            return abi.decode(returnData, (uint80, int256, uint256, uint256, uint80));\\n        } else {\\n            return (roundID, 0, 0, 0, roundID);\\n        }\\n    }\\n\\n    function _observeSwap() private view returns (uint256) {\\n        (uint256 price0Cumulative, uint256 price1Cumulative, ) =\\n            UniswapV2OracleLibrary.currentCumulativePrices(swapPair);\\n        return _swapTokenIndex == 0 ? price0Cumulative : price1Cumulative;\\n    }\\n\\n    function _getSwapTwap(\\n        uint256 startCumulativePrice,\\n        uint256 endCumulativePrice,\\n        uint256 startTimestamp,\\n        uint256 endTimestamp\\n    ) private view returns (uint256) {\\n        return\\n            FixedPoint\\n                .uq112x112(\\n                uint224(\\n                    (endCumulativePrice - startCumulativePrice) / (endTimestamp - startTimestamp)\\n                )\\n            )\\n                .mul(_swapPriceMultiplier)\\n                .decode144();\\n    }\\n\\n    /// @notice Fast-forward Chainlink round ID by owner. This is required when `lastRoundID` stucks\\n    ///         at an old round, due to either incontinuous round IDs caused by a phase change or\\n    ///         an abnormal `updatedAt` timestamp.\\n    function fastForwardRoundID(uint80 roundID) external onlyOwner {\\n        uint80 lastRoundID_ = lastRoundID;\\n        require(roundID > lastRoundID_, \\\"Round ID too low\\\");\\n        (, , , uint256 lastUpdatedAt, ) = _getChainlinkRoundData(lastRoundID_);\\n        (, , , uint256 updatedAt, ) = _getChainlinkRoundData(roundID);\\n        require(updatedAt > lastUpdatedAt, \\\"Invalid round timestamp\\\");\\n        require(updatedAt <= lastTimestamp, \\\"Round too new\\\");\\n        lastRoundID = roundID;\\n    }\\n\\n    /// @notice Submit a TWAP with 18 decimal places by the owner.\\n    ///         This is allowed only when a epoch cannot be updated by either Chainlink or Uniswap.\\n    function updateTwapFromOwner(uint256 timestamp, uint256 price) external onlyOwner {\\n        require(timestamp % EPOCH == 0, \\\"Unaligned timestamp\\\");\\n        require(timestamp <= lastTimestamp, \\\"Not ready for owner\\\");\\n        require(_prices[timestamp] == 0, \\\"Owner cannot update an existing epoch\\\");\\n\\n        uint256 lastPrice = _prices[timestamp - EPOCH];\\n        require(lastPrice > 0, \\\"Owner can only update a epoch following an updated epoch\\\");\\n        require(\\n            price > lastPrice / 10 && price < lastPrice * 10,\\n            \\\"Owner price deviates too much from the last price\\\"\\n        );\\n\\n        _prices[timestamp] = price;\\n        emit Update(timestamp, price, UpdateType.OWNER);\\n    }\\n\\n    /// @notice Observe the Uniswap pair and calculate TWAP since the last observation.\\n    function peekSwapPrice() external view returns (uint256) {\\n        uint256 cumulativePrice = _observeSwap();\\n        return\\n            _getSwapTwap(\\n                lastSwapCumulativePrice,\\n                cumulativePrice,\\n                lastSwapTimestamp,\\n                block.timestamp\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\\nimport '@uniswap/lib/contracts/libraries/FixedPoint.sol';\\n\\n// library with helper methods for oracles that are concerned with computing average prices\\nlibrary UniswapV2OracleLibrary {\\n    using FixedPoint for *;\\n\\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\\n    function currentBlockTimestamp() internal view returns (uint32) {\\n        return uint32(block.timestamp % 2 ** 32);\\n    }\\n\\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\\n    function currentCumulativePrices(\\n        address pair\\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\\n        blockTimestamp = currentBlockTimestamp();\\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\\n\\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\\n        if (blockTimestampLast != blockTimestamp) {\\n            // subtraction overflow is desired\\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\\n            // addition overflow is desired\\n            // counterfactual\\n            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\\n            // counterfactual\\n            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/lib/contracts/libraries/FixedPoint.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.0;\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\nlibrary FixedPoint {\\n    // range: [0, 2**112 - 1]\\n    // resolution: 1 / 2**112\\n    struct uq112x112 {\\n        uint224 _x;\\n    }\\n\\n    // range: [0, 2**144 - 1]\\n    // resolution: 1 / 2**112\\n    struct uq144x112 {\\n        uint _x;\\n    }\\n\\n    uint8 private constant RESOLUTION = 112;\\n\\n    // encode a uint112 as a UQ112x112\\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\\n        return uq112x112(uint224(x) << RESOLUTION);\\n    }\\n\\n    // encodes a uint144 as a UQ144x112\\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\\n        return uq144x112(uint256(x) << RESOLUTION);\\n    }\\n\\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\\n    function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\\n        require(x != 0, 'FixedPoint: DIV_BY_ZERO');\\n        return uq112x112(self._x / uint224(x));\\n    }\\n\\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\\n    // reverts on overflow\\n    function mul(uq112x112 memory self, uint y) internal pure returns (uq144x112 memory) {\\n        uint z;\\n        require(y == 0 || (z = uint(self._x) * y) / y == uint(self._x), \\\"FixedPoint: MULTIPLICATION_OVERFLOW\\\");\\n        return uq144x112(z);\\n    }\\n\\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\\n    // equivalent to encode(numerator).div(denominator)\\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\\n        require(denominator > 0, \\\"FixedPoint: DIV_BY_ZERO\\\");\\n        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\\n    }\\n\\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\\n        return uint112(self._x >> RESOLUTION);\\n    }\\n\\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\\n        return uint144(self._x >> RESOLUTION);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/MockTwapOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"../interfaces/ITwapOracleV2.sol\\\";\\nimport \\\"../utils/CoreUtility.sol\\\";\\n\\ncontract MockTwapOracle is ITwapOracleV2, CoreUtility, Ownable {\\n    struct StoredEpoch {\\n        uint256 twap;\\n        uint256 nextEpoch;\\n    }\\n\\n    event Update(uint256 timestamp, uint256 price, UpdateType updateType);\\n    event ReporterAdded(address reporter);\\n    event ReporterRemoved(address reporter);\\n\\n    uint256 private constant EPOCH = 30 minutes;\\n    uint256 private constant MAX_ITERATION = 500;\\n\\n    ITwapOracle public immutable fallbackOracle;\\n    uint256 public immutable fallbackTimestamp;\\n\\n    /// @notice A linked-list of epochs when TWAP is updated.\\n    ///         Epochs ending at the end of trading days are always stored.\\n    mapping(uint256 => StoredEpoch) public storedEpochs;\\n\\n    /// @notice Timestamp of the last stored epoch. The `Update` event is not emitted for\\n    ///         this epoch yet.\\n    uint256 public lastStoredEpoch;\\n\\n    /// @notice Mapping of epoch => TWAP. This mapping stores epochs that are manually updated\\n    ///         out-of-order.\\n    ///\\n    ///         - If value is 0, the epoch is not a hole and its TWAP equals to the last stored epoch.\\n    ///         - If value is uint(-1), the epoch is a hole and not updated yet.\\n    ///         - Otherwise, the epoch is a hole and the value is its TWAP.\\n    mapping(uint256 => uint256) public holes;\\n\\n    mapping(address => bool) public reporters;\\n\\n    constructor(\\n        uint256 initialTwap_,\\n        address fallbackOracle_,\\n        uint256 fallbackTimestamp_\\n    ) public {\\n        lastStoredEpoch = _endOfDay(block.timestamp) - 1 days;\\n        storedEpochs[lastStoredEpoch].twap = initialTwap_;\\n        fallbackOracle = ITwapOracle(fallbackOracle_);\\n        require(\\n            fallbackOracle_ == address(0) || fallbackTimestamp_ >= lastStoredEpoch,\\n            \\\"Fallback timestamp too early\\\"\\n        );\\n        fallbackTimestamp = fallbackTimestamp_;\\n        catchUp();\\n        reporters[msg.sender] = true;\\n        emit ReporterAdded(msg.sender);\\n    }\\n\\n    modifier onlyReporter() {\\n        require(reporters[msg.sender], \\\"Only reporter\\\");\\n        _;\\n    }\\n\\n    function addReporter(address reporter) external onlyOwner {\\n        require(!reporters[reporter]);\\n        reporters[reporter] = true;\\n        emit ReporterAdded(reporter);\\n    }\\n\\n    function removeReporter(address reporter) external onlyOwner {\\n        require(reporters[reporter]);\\n        reporters[reporter] = false;\\n        emit ReporterRemoved(reporter);\\n    }\\n\\n    function updateNext(uint256 twap) external onlyReporter {\\n        catchUp();\\n        uint256 nextEpoch = _nextEpoch();\\n        require(nextEpoch == lastStoredEpoch, \\\"Call catchUp() first\\\");\\n        storedEpochs[nextEpoch].twap = twap;\\n    }\\n\\n    /// @notice Emit `Update` event for past epochs and add a stored epoch for the next one.\\n    function catchUp() public {\\n        uint256 nextEpoch = _nextEpoch();\\n        uint256 lastEpoch = lastStoredEpoch;\\n        if (nextEpoch <= lastEpoch) {\\n            return;\\n        }\\n        uint256 nextStoredEpoch = _endOfDay(lastEpoch);\\n        uint256 twap = storedEpochs[lastEpoch].twap;\\n        if (holes[lastEpoch] == 0) {\\n            emit Update(lastEpoch, twap, UpdateType.PRIMARY);\\n        }\\n        uint256 epoch = lastEpoch + EPOCH;\\n        for (uint256 i = 0; i < MAX_ITERATION && epoch < nextEpoch; i++) {\\n            if (holes[epoch] == 0) {\\n                emit Update(epoch, twap, UpdateType.PRIMARY);\\n                if (epoch == nextStoredEpoch) {\\n                    storedEpochs[lastEpoch].nextEpoch = nextStoredEpoch;\\n                    storedEpochs[nextStoredEpoch].twap = twap;\\n                    lastEpoch = nextStoredEpoch;\\n                    nextStoredEpoch += 1 days;\\n                }\\n            }\\n            epoch += EPOCH;\\n        }\\n        storedEpochs[lastEpoch].nextEpoch = epoch;\\n        storedEpochs[epoch].twap = twap;\\n        lastStoredEpoch = epoch;\\n    }\\n\\n    function digHole(uint256 timestamp) external onlyReporter {\\n        require(timestamp % EPOCH == 0, \\\"Unaligned timestamp\\\");\\n        require(timestamp > block.timestamp, \\\"Can only dig hole in the future\\\");\\n        holes[timestamp] = uint256(-1);\\n    }\\n\\n    function fillHole(uint256 timestamp, uint256 twap) external onlyReporter {\\n        require(timestamp % EPOCH == 0, \\\"Unaligned timestamp\\\");\\n        require(timestamp < block.timestamp, \\\"Can only fill hole in the past\\\");\\n        require(holes[timestamp] == uint256(-1), \\\"Not a hole or already filled\\\");\\n        holes[timestamp] = twap;\\n        emit Update(timestamp, twap, UpdateType.OWNER);\\n    }\\n\\n    function getTwap(uint256 timestamp) external view override returns (uint256) {\\n        if (timestamp <= fallbackTimestamp) {\\n            if (address(fallbackOracle) == address(0)) {\\n                return 0;\\n            } else {\\n                return fallbackOracle.getTwap(timestamp);\\n            }\\n        }\\n        if (timestamp >= lastStoredEpoch || timestamp % EPOCH != 0) {\\n            return 0;\\n        }\\n\\n        uint256 holeTwap = holes[timestamp];\\n        if (holeTwap != 0) {\\n            return holeTwap == uint256(-1) ? 0 : holeTwap;\\n        }\\n\\n        // Search for the nearest stored epoch. The search starts at the latest 00:00 UTC\\n        // no later than the given timestamp, which is guaranteed to be a stored epoch.\\n        uint256 epoch = _endOfDay(timestamp) - 1 days;\\n        uint256 next = storedEpochs[epoch].nextEpoch;\\n        while (next > 0 && next <= timestamp) {\\n            epoch = next;\\n            next = storedEpochs[epoch].nextEpoch;\\n        }\\n        return storedEpochs[epoch].twap;\\n    }\\n\\n    function getLatest() external view override returns (uint256) {\\n        return storedEpochs[lastStoredEpoch].twap;\\n    }\\n\\n    function _endOfDay(uint256 timestamp) private pure returns (uint256) {\\n        return ((timestamp.add(1 days) - SETTLEMENT_TIME) / 1 days) * 1 days + SETTLEMENT_TIME;\\n    }\\n\\n    function _nextEpoch() private view returns (uint256) {\\n        return (block.timestamp / EPOCH) * EPOCH + EPOCH;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/MockTwapOracleKeeper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"./MockTwapOracle.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.6/interfaces/KeeperCompatibleInterface.sol\\\";\\n\\ncontract MockTwapOracleKeeper is KeeperCompatibleInterface, CoreUtility {\\n    MockTwapOracle private immutable mockTwap;\\n\\n    constructor(address mockTwap_) public {\\n        mockTwap = MockTwapOracle(mockTwap_);\\n    }\\n\\n    function checkUpkeep(\\n        bytes calldata /*checkData*/\\n    ) external override returns (bool upkeepNeeded, bytes memory performData) {\\n        return (block.timestamp > _endOfDay(mockTwap.lastStoredEpoch()), bytes(\\\"\\\"));\\n    }\\n\\n    function performUpkeep(\\n        bytes calldata /*performData*/\\n    ) external override {\\n        mockTwap.catchUp();\\n    }\\n\\n    function _endOfDay(uint256 timestamp) private pure returns (uint256) {\\n        return ((timestamp.add(1 days) - SETTLEMENT_TIME) / 1 days) * 1 days + SETTLEMENT_TIME;\\n    }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.6/interfaces/KeeperCompatibleInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.0;\\n\\ninterface KeeperCompatibleInterface {\\n\\n  /**\\n   * @notice checks if the contract requires work to be done.\\n   * @param checkData data passed to the contract when checking for upkeep.\\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\\n   * performUpkeep or not.\\n   * @return performData bytes that the keeper should call performUpkeep with,\\n   * if upkeep is needed.\\n   */\\n  function checkUpkeep(\\n    bytes calldata checkData\\n  )\\n    external\\n    returns (\\n      bool upkeepNeeded,\\n      bytes memory performData\\n    );\\n\\n  /**\\n   * @notice Performs work on the contract. Executed by the keepers, via the registry.\\n   * @param performData is the data which was passed back from the checkData\\n   * simulation.\\n   */\\n  function performUpkeep(\\n    bytes calldata performData\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/keeper/BatchKeeperHelperBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/EnumerableSet.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.6/interfaces/KeeperCompatibleInterface.sol\\\";\\n\\ncontract BatchKeeperHelperBase is KeeperCompatibleInterface, Ownable {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    event AllowlistAdded(address contractAddress);\\n    event AllowlistRemoved(address contractAddress);\\n\\n    EnumerableSet.AddressSet private _allowlist;\\n\\n    constructor(address[] memory contracts_) public {\\n        for (uint256 i = 0; i < contracts_.length; i++) {\\n            _allowlist.add(contracts_[i]);\\n            emit AllowlistAdded(contracts_[i]);\\n        }\\n    }\\n\\n    function allowlist() external view returns (address[] memory list) {\\n        uint256 length = _allowlist.length();\\n        list = new address[](length);\\n        for (uint256 i = 0; i < length; i++) {\\n            list[i] = _allowlist.at(i);\\n        }\\n    }\\n\\n    function addAllowlist(address contractAddress) external onlyOwner {\\n        _allowlist.add(contractAddress);\\n        emit AllowlistAdded(contractAddress);\\n    }\\n\\n    function removeAllowlist(address contractAddress) external onlyOwner {\\n        _allowlist.remove(contractAddress);\\n        emit AllowlistRemoved(contractAddress);\\n    }\\n\\n    function checkUpkeep(bytes calldata)\\n        external\\n        override\\n        returns (bool upkeepNeeded, bytes memory performData)\\n    {\\n        uint256 length = _allowlist.length();\\n        for (uint256 i = 0; i < length; i++) {\\n            address contractAddress = _allowlist.at(i);\\n            if (_checkUpkeep(contractAddress)) {\\n                upkeepNeeded = true;\\n                performData = abi.encodePacked(performData, contractAddress);\\n            }\\n        }\\n    }\\n\\n    function performUpkeep(bytes calldata performData) external override {\\n        uint256 contractLength = performData.length / 20;\\n        require(contractLength > 0);\\n        for (uint256 i = 0; i < contractLength; i++) {\\n            address contractAddress = _getContractAddr(i);\\n            require(_allowlist.contains(contractAddress), \\\"Not allowlisted\\\");\\n            _performUpkeep(contractAddress);\\n        }\\n    }\\n\\n    function _getContractAddr(uint256 index) private pure returns (address contractAddress) {\\n        assembly {\\n            // 0x38 = 0x4 + 0x20 + 0x14\\n            contractAddress := calldataload(add(0x38, mul(index, 0x14)))\\n        }\\n    }\\n\\n    function _checkUpkeep(address contractAddress) internal virtual returns (bool) {}\\n\\n    function _performUpkeep(address contractAddress) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"contracts/keeper/OracleKeeperHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"./BatchKeeperHelperBase.sol\\\";\\n\\ninterface IChainlinkTwapOracle {\\n    function lastTimestamp() external view returns (uint256);\\n\\n    function update() external;\\n}\\n\\ncontract OracleKeeperHelper is BatchKeeperHelperBase {\\n    uint256 private constant EPOCH = 30 minutes;\\n\\n    uint256 public delay;\\n\\n    constructor(address[] memory oracles_, uint256 delay_) public BatchKeeperHelperBase(oracles_) {\\n        delay = delay_;\\n    }\\n\\n    function updateDelay(uint256 newDelay) external onlyOwner {\\n        delay = newDelay;\\n    }\\n\\n    function _checkUpkeep(address contractAddress) internal override returns (bool) {\\n        IChainlinkTwapOracle chainlinkTwap = IChainlinkTwapOracle(contractAddress);\\n        uint256 lastTimestamp = chainlinkTwap.lastTimestamp();\\n        return block.timestamp > lastTimestamp + EPOCH + delay;\\n    }\\n\\n    function _performUpkeep(address contractAddress) internal override {\\n        IChainlinkTwapOracle(contractAddress).update();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/keeper/FundKeeperHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"./BatchKeeperHelperBase.sol\\\";\\nimport \\\"../interfaces/IFundV3.sol\\\";\\n\\ninterface IFundSettlement is IFundV3 {\\n    function settle() external;\\n}\\n\\ninterface IDistributor {\\n    function checkpoint() external;\\n}\\n\\ncontract FundKeeperHelper is BatchKeeperHelperBase {\\n    uint256 public delay;\\n\\n    address private immutable _bnbFundAddr;\\n    IDistributor private immutable _feeDistributor;\\n\\n    constructor(\\n        address[] memory funds_,\\n        uint256 delay_,\\n        address bnbFundAddr_,\\n        address feeDistributor_\\n    ) public BatchKeeperHelperBase(funds_) {\\n        delay = delay_;\\n        _bnbFundAddr = bnbFundAddr_;\\n        _feeDistributor = IDistributor(feeDistributor_);\\n    }\\n\\n    function updateDelay(uint256 newDelay) external onlyOwner {\\n        delay = newDelay;\\n    }\\n\\n    function _checkUpkeep(address contractAddress) internal override returns (bool) {\\n        IFundSettlement fund = IFundSettlement(contractAddress);\\n        uint256 currentDay = fund.currentDay();\\n        uint256 price = fund.twapOracle().getTwap(currentDay);\\n        return (block.timestamp >= currentDay + delay && price != 0);\\n    }\\n\\n    function _performUpkeep(address contractAddress) internal override {\\n        if (contractAddress == _bnbFundAddr) {\\n            _feeDistributor.checkpoint();\\n        }\\n        IFundSettlement(contractAddress).settle();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/fund/ShareV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"../interfaces/IFundV3.sol\\\";\\nimport \\\"../interfaces/IShareV2.sol\\\";\\n\\ncontract ShareV2 is IShareV2 {\\n    uint8 public constant decimals = 18;\\n    IFundV3 public immutable fund;\\n    uint256 public immutable tranche;\\n\\n    string public name;\\n    string public symbol;\\n\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        address fund_,\\n        uint256 tranche_\\n    ) public {\\n        name = name_;\\n        symbol = symbol_;\\n        fund = IFundV3(fund_);\\n        tranche = tranche_;\\n    }\\n\\n    function totalSupply() external view override returns (uint256) {\\n        return fund.trancheTotalSupply(tranche);\\n    }\\n\\n    function balanceOf(address account) external view override returns (uint256) {\\n        return fund.trancheBalanceOf(tranche, account);\\n    }\\n\\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\\n        fund.shareTransfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function allowance(address owner, address spender) external view override returns (uint256) {\\n        return fund.trancheAllowance(tranche, owner, spender);\\n    }\\n\\n    function approve(address spender, uint256 amount) external override returns (bool) {\\n        fund.shareApprove(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external override returns (bool) {\\n        fund.shareTransferFrom(msg.sender, sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {\\n        fund.shareIncreaseAllowance(msg.sender, spender, addedValue);\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {\\n        fund.shareDecreaseAllowance(msg.sender, spender, subtractedValue);\\n        return true;\\n    }\\n\\n    modifier onlyFund() {\\n        require(msg.sender == address(fund), \\\"Only fund\\\");\\n        _;\\n    }\\n\\n    function fundEmitTransfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external override onlyFund {\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    function fundEmitApproval(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) external override onlyFund {\\n        emit Approval(owner, spender, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/MockExternalRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\n\\ncontract MockExternalRouter {\\n    using SafeERC20 for IERC20;\\n\\n    // keccak256(path) => amountOut => amountIn\\n    mapping(bytes32 => mapping(uint256 => uint256)) public nextIn;\\n\\n    // keccak256(path) => amountIn => amountOut\\n    mapping(bytes32 => mapping(uint256 => uint256)) public nextOut;\\n\\n    function setNextSwap(\\n        address[] memory path,\\n        uint256 amountIn,\\n        uint256 amountOut\\n    ) external {\\n        nextIn[keccak256(abi.encode(path))][amountOut] = amountIn;\\n        nextOut[keccak256(abi.encode(path))][amountIn] = amountOut;\\n    }\\n\\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\\n        external\\n        view\\n        returns (uint256[] memory amounts)\\n    {\\n        uint256 amountIn = nextIn[keccak256(abi.encode(path))][amountOut];\\n        require(amountIn != 0, \\\"No mock for the swap\\\");\\n        amounts = new uint256[](path.length);\\n        amounts[amounts.length - 1] = amountOut;\\n        amounts[0] = nextIn[keccak256(abi.encode(path))][amountOut];\\n    }\\n\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts) {\\n        require(deadline >= block.timestamp, \\\"Deadline\\\");\\n        uint256 amountOut = nextOut[keccak256(abi.encode(path))][amountIn];\\n        require(amountOut != 0, \\\"No mock for the swap\\\");\\n        require(amountOut >= amountOutMin, \\\"MockExternalRouter: Insufficient output\\\");\\n        amounts = new uint256[](path.length);\\n        amounts[0] = amountIn;\\n        amounts[amounts.length - 1] = amountOut;\\n        nextIn[keccak256(abi.encode(path))][amountOut] = 0;\\n        nextOut[keccak256(abi.encode(path))][amountIn] = 0;\\n        IERC20(path[0]).safeTransferFrom(msg.sender, address(this), amountIn);\\n        IERC20(path[path.length - 1]).safeTransfer(to, amountOut);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/UpgradeableProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./Proxy.sol\\\";\\nimport \\\"../utils/Address.sol\\\";\\n\\n/**\\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\\n * implementation address that can be changed. This address is stored in storage in the location specified by\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\\n * implementation behind the proxy.\\n *\\n * Upgradeability is only provided internally through {_upgradeTo}. For an externally upgradeable proxy see\\n * {TransparentUpgradeableProxy}.\\n */\\ncontract UpgradeableProxy is Proxy {\\n    /**\\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\\n     *\\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\\n     */\\n    constructor(address _logic, bytes memory _data) public payable {\\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.implementation\\\")) - 1));\\n        _setImplementation(_logic);\\n        if(_data.length > 0) {\\n            Address.functionDelegateCall(_logic, _data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _implementation() internal view virtual override returns (address impl) {\\n        bytes32 slot = _IMPLEMENTATION_SLOT;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            impl := sload(slot)\\n        }\\n    }\\n\\n    /**\\n     * @dev Upgrades the proxy to a new implementation.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal virtual {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(Address.isContract(newImplementation), \\\"UpgradeableProxy: new implementation is not a contract\\\");\\n\\n        bytes32 slot = _IMPLEMENTATION_SLOT;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(slot, newImplementation)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 { revert(0, returndatasize()) }\\n            default { return(0, returndatasize()) }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback () external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive () external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overriden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/TransparentUpgradeableProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./UpgradeableProxy.sol\\\";\\n\\n/**\\n * @dev This contract implements a proxy that is upgradeable by an admin.\\n *\\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\\n * clashing], which can potentially be used in an attack, this contract uses the\\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\\n * things that go hand in hand:\\n *\\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\\n * that call matches one of the admin functions exposed by the proxy itself.\\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\\n * \\\"admin cannot fallback to proxy target\\\".\\n *\\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\\n * to sudden errors when trying to call a function from the proxy implementation.\\n *\\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\\n */\\ncontract TransparentUpgradeableProxy is UpgradeableProxy {\\n    /**\\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\\n     * optionally initialized with `_data` as explained in {UpgradeableProxy-constructor}.\\n     */\\n    constructor(address _logic, address admin_, bytes memory _data) public payable UpgradeableProxy(_logic, _data) {\\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.admin\\\")) - 1));\\n        _setAdmin(admin_);\\n    }\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\\n     */\\n    modifier ifAdmin() {\\n        if (msg.sender == _admin()) {\\n            _;\\n        } else {\\n            _fallback();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the current admin.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\\n     */\\n    function admin() external ifAdmin returns (address admin_) {\\n        admin_ = _admin();\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\\n     */\\n    function implementation() external ifAdmin returns (address implementation_) {\\n        implementation_ = _implementation();\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\\n     */\\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\\n        require(newAdmin != address(0), \\\"TransparentUpgradeableProxy: new admin is the zero address\\\");\\n        emit AdminChanged(_admin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\\n     */\\n    function upgradeTo(address newImplementation) external virtual ifAdmin {\\n        _upgradeTo(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\\n     * proxied contract.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable virtual ifAdmin {\\n        _upgradeTo(newImplementation);\\n        Address.functionDelegateCall(newImplementation, data);\\n    }\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _admin() internal view virtual returns (address adm) {\\n        bytes32 slot = _ADMIN_SLOT;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            adm := sload(slot)\\n        }\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        bytes32 slot = _ADMIN_SLOT;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(slot, newAdmin)\\n        }\\n    }\\n\\n    /**\\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\\n     */\\n    function _beforeFallback() internal virtual override {\\n        require(msg.sender != _admin(), \\\"TransparentUpgradeableProxy: admin cannot fallback to proxy target\\\");\\n        super._beforeFallback();\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/ProxyAdmin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../access/Ownable.sol\\\";\\nimport \\\"./TransparentUpgradeableProxy.sol\\\";\\n\\n/**\\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\\n */\\ncontract ProxyAdmin is Ownable {\\n\\n    /**\\n     * @dev Returns the current implementation of `proxy`.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the admin of `proxy`.\\n     */\\n    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\\n        // We need to manually run the static call since the getter cannot be flagged as view\\n        // bytes4(keccak256(\\\"implementation()\\\")) == 0x5c60da1b\\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\\\"5c60da1b\\\");\\n        require(success);\\n        return abi.decode(returndata, (address));\\n    }\\n\\n    /**\\n     * @dev Returns the current admin of `proxy`.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the admin of `proxy`.\\n     */\\n    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\\n        // We need to manually run the static call since the getter cannot be flagged as view\\n        // bytes4(keccak256(\\\"admin()\\\")) == 0xf851a440\\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\\\"f851a440\\\");\\n        require(success);\\n        return abi.decode(returndata, (address));\\n    }\\n\\n    /**\\n     * @dev Changes the admin of `proxy` to `newAdmin`.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the current admin of `proxy`.\\n     */\\n    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\\n        proxy.changeAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the admin of `proxy`.\\n     */\\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\\n        proxy.upgradeTo(implementation);\\n    }\\n\\n    /**\\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the admin of `proxy`.\\n     */\\n    function upgradeAndCall(TransparentUpgradeableProxy proxy, address implementation, bytes memory data) public payable virtual onlyOwner {\\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/misc/ExternalContracts.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\n// This file imports external contracts that are used by this project,\\n// forcing Hardhat to compile them.\\n\\nimport \\\"@openzeppelin/contracts/access/TimelockController.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/TransparentUpgradeableProxy.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/ProxyAdmin.sol\\\";\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/TimelockController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.9 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./../math/SafeMath.sol\\\";\\nimport \\\"./AccessControl.sol\\\";\\n\\n/**\\n * @dev Contract module which acts as a timelocked controller. When set as the\\n * owner of an `Ownable` smart contract, it enforces a timelock on all\\n * `onlyOwner` maintenance operations. This gives time for users of the\\n * controlled contract to exit before a potentially dangerous maintenance\\n * operation is applied.\\n *\\n * By default, this contract is self administered, meaning administration tasks\\n * have to go through the timelock process. The proposer (resp executor) role\\n * is in charge of proposing (resp executing) operations. A common use case is\\n * to position this {TimelockController} as the owner of a smart contract, with\\n * a multisig or a DAO as the sole proposer.\\n *\\n * _Available since v3.3._\\n */\\ncontract TimelockController is AccessControl {\\n\\n    bytes32 public constant TIMELOCK_ADMIN_ROLE = keccak256(\\\"TIMELOCK_ADMIN_ROLE\\\");\\n    bytes32 public constant PROPOSER_ROLE = keccak256(\\\"PROPOSER_ROLE\\\");\\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\\\"EXECUTOR_ROLE\\\");\\n    uint256 internal constant _DONE_TIMESTAMP = uint256(1);\\n\\n    mapping(bytes32 => uint256) private _timestamps;\\n    uint256 private _minDelay;\\n\\n    /**\\n     * @dev Emitted when a call is scheduled as part of operation `id`.\\n     */\\n    event CallScheduled(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data, bytes32 predecessor, uint256 delay);\\n\\n    /**\\n     * @dev Emitted when a call is performed as part of operation `id`.\\n     */\\n    event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);\\n\\n    /**\\n     * @dev Emitted when operation `id` is cancelled.\\n     */\\n    event Cancelled(bytes32 indexed id);\\n\\n    /**\\n     * @dev Emitted when the minimum delay for future operations is modified.\\n     */\\n    event MinDelayChange(uint256 oldDuration, uint256 newDuration);\\n\\n    /**\\n     * @dev Initializes the contract with a given `minDelay`.\\n     */\\n    constructor(uint256 minDelay, address[] memory proposers, address[] memory executors) public {\\n        _setRoleAdmin(TIMELOCK_ADMIN_ROLE, TIMELOCK_ADMIN_ROLE);\\n        _setRoleAdmin(PROPOSER_ROLE, TIMELOCK_ADMIN_ROLE);\\n        _setRoleAdmin(EXECUTOR_ROLE, TIMELOCK_ADMIN_ROLE);\\n\\n        // deployer + self administration\\n        _setupRole(TIMELOCK_ADMIN_ROLE, _msgSender());\\n        _setupRole(TIMELOCK_ADMIN_ROLE, address(this));\\n\\n        // register proposers\\n        for (uint256 i = 0; i < proposers.length; ++i) {\\n            _setupRole(PROPOSER_ROLE, proposers[i]);\\n        }\\n\\n        // register executors\\n        for (uint256 i = 0; i < executors.length; ++i) {\\n            _setupRole(EXECUTOR_ROLE, executors[i]);\\n        }\\n\\n        _minDelay = minDelay;\\n        emit MinDelayChange(0, minDelay);\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only by a certain role. In\\n     * addition to checking the sender's role, `address(0)` 's role is also\\n     * considered. Granting a role to `address(0)` is equivalent to enabling\\n     * this role for everyone.\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        require(hasRole(role, _msgSender()) || hasRole(role, address(0)), \\\"TimelockController: sender requires permission\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Contract might receive/hold ETH as part of the maintenance process.\\n     */\\n    receive() external payable {}\\n\\n    /**\\n     * @dev Returns whether an id correspond to a registered operation. This\\n     * includes both Pending, Ready and Done operations.\\n     */\\n    function isOperation(bytes32 id) public view virtual returns (bool pending) {\\n        return getTimestamp(id) > 0;\\n    }\\n\\n    /**\\n     * @dev Returns whether an operation is pending or not.\\n     */\\n    function isOperationPending(bytes32 id) public view virtual returns (bool pending) {\\n        return getTimestamp(id) > _DONE_TIMESTAMP;\\n    }\\n\\n    /**\\n     * @dev Returns whether an operation is ready or not.\\n     */\\n    function isOperationReady(bytes32 id) public view virtual returns (bool ready) {\\n        uint256 timestamp = getTimestamp(id);\\n        // solhint-disable-next-line not-rely-on-time\\n        return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;\\n    }\\n\\n    /**\\n     * @dev Returns whether an operation is done or not.\\n     */\\n    function isOperationDone(bytes32 id) public view virtual returns (bool done) {\\n        return getTimestamp(id) == _DONE_TIMESTAMP;\\n    }\\n\\n    /**\\n     * @dev Returns the timestamp at with an operation becomes ready (0 for\\n     * unset operations, 1 for done operations).\\n     */\\n    function getTimestamp(bytes32 id) public view virtual returns (uint256 timestamp) {\\n        return _timestamps[id];\\n    }\\n\\n    /**\\n     * @dev Returns the minimum delay for an operation to become valid.\\n     *\\n     * This value can be changed by executing an operation that calls `updateDelay`.\\n     */\\n    function getMinDelay() public view virtual returns (uint256 duration) {\\n        return _minDelay;\\n    }\\n\\n    /**\\n     * @dev Returns the identifier of an operation containing a single\\n     * transaction.\\n     */\\n    function hashOperation(address target, uint256 value, bytes calldata data, bytes32 predecessor, bytes32 salt) public pure virtual returns (bytes32 hash) {\\n        return keccak256(abi.encode(target, value, data, predecessor, salt));\\n    }\\n\\n    /**\\n     * @dev Returns the identifier of an operation containing a batch of\\n     * transactions.\\n     */\\n    function hashOperationBatch(address[] calldata targets, uint256[] calldata values, bytes[] calldata datas, bytes32 predecessor, bytes32 salt) public pure virtual returns (bytes32 hash) {\\n        return keccak256(abi.encode(targets, values, datas, predecessor, salt));\\n    }\\n\\n    /**\\n     * @dev Schedule an operation containing a single transaction.\\n     *\\n     * Emits a {CallScheduled} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the 'proposer' role.\\n     */\\n    function schedule(address target, uint256 value, bytes calldata data, bytes32 predecessor, bytes32 salt, uint256 delay) public virtual onlyRole(PROPOSER_ROLE) {\\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\\n        _schedule(id, delay);\\n        emit CallScheduled(id, 0, target, value, data, predecessor, delay);\\n    }\\n\\n    /**\\n     * @dev Schedule an operation containing a batch of transactions.\\n     *\\n     * Emits one {CallScheduled} event per transaction in the batch.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the 'proposer' role.\\n     */\\n    function scheduleBatch(address[] calldata targets, uint256[] calldata values, bytes[] calldata datas, bytes32 predecessor, bytes32 salt, uint256 delay) public virtual onlyRole(PROPOSER_ROLE) {\\n        require(targets.length == values.length, \\\"TimelockController: length mismatch\\\");\\n        require(targets.length == datas.length, \\\"TimelockController: length mismatch\\\");\\n\\n        bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt);\\n        _schedule(id, delay);\\n        for (uint256 i = 0; i < targets.length; ++i) {\\n            emit CallScheduled(id, i, targets[i], values[i], datas[i], predecessor, delay);\\n        }\\n    }\\n\\n    /**\\n     * @dev Schedule an operation that is to becomes valid after a given delay.\\n     */\\n    function _schedule(bytes32 id, uint256 delay) private {\\n        require(!isOperation(id), \\\"TimelockController: operation already scheduled\\\");\\n        require(delay >= getMinDelay(), \\\"TimelockController: insufficient delay\\\");\\n        // solhint-disable-next-line not-rely-on-time\\n        _timestamps[id] = SafeMath.add(block.timestamp, delay);\\n    }\\n\\n    /**\\n     * @dev Cancel an operation.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the 'proposer' role.\\n     */\\n    function cancel(bytes32 id) public virtual onlyRole(PROPOSER_ROLE) {\\n        require(isOperationPending(id), \\\"TimelockController: operation cannot be cancelled\\\");\\n        delete _timestamps[id];\\n\\n        emit Cancelled(id);\\n    }\\n\\n    /**\\n     * @dev Execute an (ready) operation containing a single transaction.\\n     *\\n     * Emits a {CallExecuted} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the 'executor' role.\\n     */\\n    function execute(address target, uint256 value, bytes calldata data, bytes32 predecessor, bytes32 salt) public payable virtual onlyRole(EXECUTOR_ROLE) {\\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\\n        _beforeCall(id, predecessor);\\n        _call(id, 0, target, value, data);\\n        _afterCall(id);\\n    }\\n\\n    /**\\n     * @dev Execute an (ready) operation containing a batch of transactions.\\n     *\\n     * Emits one {CallExecuted} event per transaction in the batch.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have the 'executor' role.\\n     */\\n    function executeBatch(address[] calldata targets, uint256[] calldata values, bytes[] calldata datas, bytes32 predecessor, bytes32 salt) public payable virtual onlyRole(EXECUTOR_ROLE) {\\n        require(targets.length == values.length, \\\"TimelockController: length mismatch\\\");\\n        require(targets.length == datas.length, \\\"TimelockController: length mismatch\\\");\\n\\n        bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt);\\n        _beforeCall(id, predecessor);\\n        for (uint256 i = 0; i < targets.length; ++i) {\\n            _call(id, i, targets[i], values[i], datas[i]);\\n        }\\n        _afterCall(id);\\n    }\\n\\n    /**\\n     * @dev Checks before execution of an operation's calls.\\n     */\\n    function _beforeCall(bytes32 id, bytes32 predecessor) private view {\\n        require(isOperationReady(id), \\\"TimelockController: operation is not ready\\\");\\n        require(predecessor == bytes32(0) || isOperationDone(predecessor), \\\"TimelockController: missing dependency\\\");\\n    }\\n\\n    /**\\n     * @dev Checks after execution of an operation's calls.\\n     */\\n    function _afterCall(bytes32 id) private {\\n        require(isOperationReady(id), \\\"TimelockController: operation is not ready\\\");\\n        _timestamps[id] = _DONE_TIMESTAMP;\\n    }\\n\\n    /**\\n     * @dev Execute an operation's call.\\n     *\\n     * Emits a {CallExecuted} event.\\n     */\\n    function _call(bytes32 id, uint256 index, address target, uint256 value, bytes calldata data) private {\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success,) = target.call{value: value}(data);\\n        require(success, \\\"TimelockController: underlying transaction reverted\\\");\\n\\n        emit CallExecuted(id, index, target, value, data);\\n    }\\n\\n    /**\\n     * @dev Changes the minimum timelock duration for future operations.\\n     *\\n     * Emits a {MinDelayChange} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be the timelock itself. This can only be achieved by scheduling and later executing\\n     * an operation where the timelock is the target and the data is the ABI-encoded call to this function.\\n     */\\n    function updateDelay(uint256 newDelay) external virtual {\\n        require(msg.sender == address(this), \\\"TimelockController: caller must be timelock\\\");\\n        emit MinDelayChange(_minDelay, newDelay);\\n        _minDelay = newDelay;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/AdvancedMathWrapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"../utils/AdvancedMath.sol\\\";\\n\\ncontract AdvancedMathWrapper {\\n    using AdvancedMath for uint256;\\n\\n    function sqrt(uint256 value) external pure returns (uint256) {\\n        return value.sqrt();\\n    }\\n\\n    function cbrt(uint256 value) external pure returns (uint256) {\\n        return value.cbrt();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/governance/Chess.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.10 <0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\n\\ncontract Chess is ERC20 {\\n    constructor(uint256 initialSupply) public ERC20(\\\"Chess\\\", \\\"CHESS\\\") {\\n        _mint(msg.sender, initialSupply);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpToken_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fund_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"quoteAddress_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"quoteDecimals_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ampl_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"feeCollector_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"feeRate_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"adminFeeRate_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tradingCurbThreshold_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAdminFeeRate\",\"type\":\"uint256\"}],\"name\":\"AdminFeeRateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTimestamp\",\"type\":\"uint256\"}],\"name\":\"AmplRampUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newFeeCollector\",\"type\":\"address\"}],\"name\":\"FeeCollectorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFeeRate\",\"type\":\"uint256\"}],\"name\":\"FeeRateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quoteIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"adminFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oraclePrice\",\"type\":\"uint256\"}],\"name\":\"LiquidityAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quotOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"adminFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oraclePrice\",\"type\":\"uint256\"}],\"name\":\"LiquidityRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousPauser\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newPauser\",\"type\":\"address\"}],\"name\":\"PauserRoleTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"base\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quote\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"}],\"name\":\"Rebalanced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quoteIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quoteOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"adminFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oraclePrice\",\"type\":\"uint256\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"base\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quote\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oraclePrice\",\"type\":\"uint256\"}],\"name\":\"Sync\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"addLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lpOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminFeeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amplRampEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amplRampEndTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amplRampStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"amplRampStartTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseTranche\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"buy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"realBaseOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentVersion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeCollector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fund\",\"outputs\":[{\"internalType\":\"contract IFundV3\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAmpl\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"quoteOut\",\"type\":\"uint256\"}],\"name\":\"getBaseIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"baseIn\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"quoteIn\",\"type\":\"uint256\"}],\"name\":\"getBaseOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"baseOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentPriceOverOracle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOraclePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPriceOverOracleIntegral\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"baseOut\",\"type\":\"uint256\"}],\"name\":\"getQuoteIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"quoteIn\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"baseIn\",\"type\":\"uint256\"}],\"name\":\"getQuoteOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"quoteOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauser\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"quoteAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"quoteBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBaseOut\",\"type\":\"uint256\"}],\"name\":\"removeBaseLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"baseOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBaseOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minQuoteOut\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"baseOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quoteOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBaseOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minQuoteOut\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityUnwrap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"baseOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quoteOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minQuoteOut\",\"type\":\"uint256\"}],\"name\":\"removeQuoteLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"quoteOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minQuoteOut\",\"type\":\"uint256\"}],\"name\":\"removeQuoteLiquidityUnwrap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"quoteOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renouncePauserRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quoteOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"sell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"realQuoteOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sync\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAdminFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingCurbThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPauser\",\"type\":\"address\"}],\"name\":\"transferPauserRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAdminFeeRate\",\"type\":\"uint256\"}],\"name\":\"updateAdminFeeRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"endAmpl\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTimestamp\",\"type\":\"uint256\"}],\"name\":\"updateAmplRamp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newFeeCollector\",\"type\":\"address\"}],\"name\":\"updateFeeCollector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFeeRate\",\"type\":\"uint256\"}],\"name\":\"updateFeeRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "BishopStableSwap", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000d150c057f5d66107dfdb9d6d97f8b53ebd4d7a0000000000000000000000001f18cc2b50575a71dd2ebf58793d4e661a7ba0e0000000000000000000000000e9e7cea3dedca5984780bafc599bd69add087d56000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000500000000000000000000000004832f0faeae2b9458d0c01bcc11b99d44d16fd4200000000000000000000000000000000000000000000000000038d7ea4c68000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004db732547630000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b363288d79dbdca9238549b03db4a10e367a65d57e8e06c1c69f35e3b6bb29be"}