{"SourceCode": "{\"IERC20.sol\":{\"content\":\"pragma solidity ^0.8.18;  \\r\\n// SPDX-License-Identifier: MIT\\r\\n\\r\\n\\r\\n\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `to`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n    \\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the symbol of the token.\\r\\n     */\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the decimals places of the token.\\r\\n     */\\r\\n    function decimals() external view returns (uint8);\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) external returns (bool); \\r\\n    \\r\\n}\"},\"PreSaleWallet.sol\":{\"content\":\"  import \\\"./IERC20.sol\\\"; \\r\\n  pragma solidity ^0.8.18;  \\r\\n// SPDX-License-Identifier: MIT\\r\\n  contract UpgradableContext{ \\r\\n    address internal implementation;\\r\\n    address internal proxyAdmin; \\r\\n    bool internal implement_synchronized; \\r\\n    string internal versionName;  \\r\\n    modifier onlyAdmin{ \\r\\n        require(msg.sender==proxyAdmin); \\r\\n        _;\\r\\n    } \\r\\n    function implement_enabled() public view returns(bool){ \\r\\n        return implement_synchronized;\\r\\n    }  \\r\\n    \\r\\n    function getOwner() public view returns(address){ \\r\\n        return proxyAdmin;\\r\\n    }\\r\\n} \\r\\n \\r\\n\\r\\nabstract contract WalletContext { \\r\\n     function receviedBnb(uint256 value,address sender,address txOrigin,uint8 state)public{ }\\r\\n        \\r\\n    \\r\\n}\\r\\ncontract Proxy {\\r\\n\\r\\n    address internal implementation;\\r\\n    address internal proxyAdmin; \\r\\n    bool internal implement_synchronized; \\r\\n    string internal versionName;  \\r\\n\\r\\n constructor(){ \\r\\n     proxyAdmin=msg.sender;\\r\\n } \\r\\n function getAdmin() external view returns(address) { \\r\\n     return proxyAdmin;\\r\\n }  \\r\\n function version()public view returns(string memory ){ \\r\\n     return versionName;\\r\\n }\\r\\n function getImplement()public view returns(address){ \\r\\n    return implementation;\\r\\n    }\\r\\n function changeOwner(address newOwner) public onlyAdmin notContract(newOwner){ \\r\\n     transferOwner(newOwner);\\r\\n } \\r\\n function transferOwner(address newOwner) private notZero(newOwner) notContract(newOwner){ \\r\\n      address oldOwner=proxyAdmin;\\r\\n      proxyAdmin=newOwner;  \\r\\n      emit OwnerTransfered(oldOwner,newOwner);\\r\\n } \\r\\n modifier notZero(address account){ \\r\\n     require(account!=address(0) \\u0026\\u0026 account!=0x000000000000000000000000000000000000dEaD); \\r\\n     _;\\r\\n } \\r\\n modifier notContract(address account){ \\r\\n     require(!isContract(account)); \\r\\n     _;\\r\\n }\\r\\n modifier onlyAdmin{ \\r\\n     require(msg.sender==proxyAdmin,\\\"You is not proxy admin !\\\"); \\r\\n     _;\\r\\n } \\r\\n\\r\\nfunction setImplementation(string memory _version,address implementation_) public onlyAdmin {\\r\\n require(isContract(implementation_),\\\"Not contract !\\\"); \\r\\n  \\r\\n implementation = implementation_; \\r\\n versionName=_version;  \\r\\n emit Upgraded(_version,implementation);\\r\\n \\r\\n    \\r\\n \\r\\n } \\r\\n \\r\\nfunction isContract(address account) private view returns(bool){ \\r\\n    uint size; \\r\\n    assembly{ \\r\\n        size:=extcodesize(account)\\r\\n    } \\r\\n    return size\\u003e0;\\r\\n}\\r\\nfunction _delegate() internal { \\r\\n        \\r\\n          assembly {\\r\\n            let _target := sload(0)\\r\\n            calldatacopy(0x0, 0x0, calldatasize())\\r\\n            let result := delegatecall(gas(), _target, 0x0, calldatasize(), 0x0, 0)\\r\\n            returndatacopy(0x0, 0x0, returndatasize())\\r\\n            switch result case 0 {revert(0, 0)} default {return (0, returndatasize())}\\r\\n        }\\r\\n       \\r\\n       \\r\\n       } \\r\\n      receive() external payable {\\r\\n        \\r\\n        WalletContext(address(this)).receviedBnb(msg.value,msg.sender,tx.origin,0x0);\\r\\n    }\\r\\n     fallback() external payable {\\r\\n        if(msg.value\\u003e0){ \\r\\n            WalletContext(address(this)).receviedBnb(msg.value,msg.sender,tx.origin,0x1);\\r\\n        }else{ \\r\\n                assembly {\\r\\n            let _target := sload(0)\\r\\n            calldatacopy(0x0, 0x0, calldatasize())\\r\\n            let result := delegatecall(gas(), _target, 0x0, calldatasize(), 0x0, 0)\\r\\n            returndatacopy(0x0, 0x0, returndatasize())\\r\\n            switch result case 0 {revert(0, 0)} default {return (0, returndatasize())}\\r\\n        }\\r\\n        }\\r\\n        \\r\\n}   \\r\\n     event Upgraded(string indexed version,address indexed implementation);\\r\\n     event OwnerTransfered(address indexed oldOwner,address indexed newOwner);\\r\\n}  \\r\\n interface IPancakeRouter01 {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint amountADesired,\\r\\n        uint amountBDesired,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint amountTokenDesired,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETH(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function removeLiquidityWithPermit(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint liquidity,\\r\\n        uint amountAMin,\\r\\n        uint amountBMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountA, uint amountB);\\r\\n    function removeLiquidityETHWithPermit(\\r\\n        address token,\\r\\n        uint liquidity,\\r\\n        uint amountTokenMin,\\r\\n        uint amountETHMin,\\r\\n        address to,\\r\\n        uint deadline,\\r\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n    ) external returns (uint amountToken, uint amountETH);\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapTokensForExactTokens(\\r\\n        uint amountOut,\\r\\n        uint amountInMax,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint deadline\\r\\n    ) external returns (uint[] memory amounts);\\r\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        returns (uint[] memory amounts);\\r\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n        external\\r\\n        payable\\r\\n        returns (uint[] memory amounts);\\r\\n\\r\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}  \\r\\n \\r\\n  contract PreSaleWallet is UpgradableContext{ \\r\\n       address private owner; \\r\\n       \\r\\n       uint256 public tokenPriceForUsd=10**17;\\r\\n       address public erc20Address;  \\r\\n       address public anotherWallet; \\r\\n       bool public sendAnotherWallet=false;\\r\\n       address public router; \\r\\n       \\r\\n       mapping(address=\\u003ebool) private stableCoins; \\r\\n       address public usdtContract; \\r\\n       uint256 totalbalance=0;\\r\\n       uint256 totalsupply=0;  \\r\\n       \\r\\n       uint256 totalCollectedUsdt=0; \\r\\n       mapping(address=\\u003euint256) private balances; \\r\\n       constructor(){ \\r\\n         \\r\\n       }  \\r\\n        modifier onlyOwner{ \\r\\n          \\r\\n           require(msg.sender==proxyAdmin,\\\"This is not owner\\\");\\r\\n        _;\\r\\n       } \\r\\n       \\r\\n       function addStableCoin(address contractAdr)public onlyOwner{ \\r\\n         stableCoins[contractAdr]=true;\\r\\n       }  \\r\\n       function removeStableCoin(address contractAdr)public onlyOwner{ \\r\\n         stableCoins[contractAdr]=false;\\r\\n       }  \\r\\n       modifier OnlyStableToken(address tokenAddress){ \\r\\n         require(stableCoins[tokenAddress],\\\"Not support this coin\\\"); \\r\\n         _;\\r\\n       }\\r\\n      function setUsdtContract(address usdtAddress)public onlyOwner{ \\r\\n         require(isContract(usdtAddress),\\\"this is not contract !\\\");\\r\\n         usdtContract=usdtAddress;\\r\\n      } \\r\\n      function setTotalSupply(uint256 supply)public onlyOwner{ \\r\\n        totalsupply=supply;\\r\\n      } \\r\\n      function setRouterContract(address _router)public onlyOwner{ \\r\\n         require(isContract(_router),\\\"this is not contract !\\\");\\r\\n         router=_router;\\r\\n      } \\r\\n      receive() external payable{ \\r\\n\\r\\n      }\\r\\n      function isContract(address _addr) internal view returns (bool){\\r\\n            uint32 size;\\r\\n            assembly {\\r\\n              size := extcodesize(_addr)\\r\\n              }\\r\\n          return (size \\u003e 0);\\r\\n          }\\r\\n       function getTotalBalance() public view returns(uint256){ \\r\\n         return totalbalance;\\r\\n       } \\r\\n       function burnErc20(uint256 amount)public onlyOwner{ \\r\\n         \\r\\n       }\\r\\n       function setAnotherWallet(address another)public onlyOwner{ \\r\\n           require(!isContract(another),\\\"this is not account !\\\");\\r\\n          anotherWallet=another;\\r\\n       } \\r\\n       function setAnotherWalletMode(bool mode)public onlyOwner{ \\r\\n          \\r\\n          sendAnotherWallet=mode;\\r\\n       }\\r\\n       function setToken(address TokenAddress)public onlyOwner { \\r\\n          require(isContract(TokenAddress),\\\"this is not contract !\\\");\\r\\n           uint256 supply= IERC20(TokenAddress).balanceOf(address(this)); \\r\\n           if(supply\\u003e0){ \\r\\n             totalsupply=supply;\\r\\n           }\\r\\n           erc20Address=TokenAddress; \\r\\n           implement_synchronized=true;\\r\\n       } \\r\\n      function changeTokenPrice(uint256 price)public onlyOwner{ \\r\\n         uint256 oldprice=tokenPriceForUsd;\\r\\n         tokenPriceForUsd=price;  \\r\\n         emit TokenPriceChanged(oldprice,price);\\r\\n\\r\\n      } \\r\\n      function balanceOf(address adr) public view returns(uint256){ \\r\\n        return balances[adr];\\r\\n      } \\r\\n      function getTotalUsdt()public view returns(uint256){ \\r\\n        return (GetBnbPrice()*totalbalance)/10**18;\\r\\n      } \\r\\n       function getTotalCollectedUsdt()public view returns(uint256){ \\r\\n         return totalCollectedUsdt;\\r\\n       }\\r\\n       function getTotalSupplyForPrice()public view returns(uint256){ \\r\\n        return (totalsupply*tokenPriceForUsd)/10**18;\\r\\n      }\\r\\n      function GetPrice(uint256 amount,address otherContract)public view returns(uint256) { \\r\\n        IPancakeRouter01 _router=IPancakeRouter01(router); \\r\\n       \\r\\n        address[] memory path = new address[](2); \\r\\n        path[0]=_router.WETH(); \\r\\n        path[1]=otherContract;\\r\\n        return _router.getAmountsOut(amount ,path)[1];\\r\\n\\r\\n    }  \\r\\n      function GetBnbPrice()public view returns(uint256){ \\r\\n       \\r\\n        return GetPrice(10**18,usdtContract);\\r\\n        \\r\\n        \\r\\n      } \\r\\n      function buyForStableUsd(address token,uint256 amount)public OnlyStableToken(token) { \\r\\n        uint256 allow=IERC20(token).allowance(msg.sender,address(this));  \\r\\n        if(amount\\u003c=allow \\u0026\\u0026 allow\\u003e0){ \\r\\n           if(IERC20(token).transferFrom(msg.sender,address(this),amount)==true){ \\r\\n              _payERC20ForStable(amount,msg.sender);\\r\\n           }\\r\\n            \\r\\n        }\\r\\n      }\\r\\n      function matchvirtual(uint256 bnbamount)public view returns(uint256){ \\r\\n        uint256 willpay=((GetBnbPrice()*bnbamount)/tokenPriceForUsd);   \\r\\n        return willpay;\\r\\n      } \\r\\n       function matchvirtualForStable(uint256 tokenAmount)public view returns(uint256){ \\r\\n        uint256 willpay=((10**18*tokenAmount)/tokenPriceForUsd);   \\r\\n        return willpay;\\r\\n      }\\r\\n      function _payERC20ForStable(uint256 allowance,address to)internal{ \\r\\n        \\r\\n       \\r\\n       \\r\\n        uint256 willpay=((10**18*allowance)/tokenPriceForUsd); \\r\\n        bool result=IERC20(erc20Address).transfer(to,willpay); \\r\\n        if(result==true){ \\r\\n          uint256 balance=balances[to]; \\r\\n          balances[to]=balance+willpay;  \\r\\n          emit BuyTokens(willpay,to);\\r\\n        }\\r\\n      } \\r\\n      \\r\\n      function _payERC20(address sender,uint256 bnbValue)internal{ \\r\\n            require(erc20Address!=address(0),\\\"Token contract can not found !\\\"); \\r\\n            \\r\\n            \\r\\n            unchecked{ \\r\\n              uint256 willpay=matchvirtual(bnbValue); \\r\\n              \\r\\n              \\r\\n              bool result=IERC20(erc20Address).transfer(sender,willpay); \\r\\n              if(result==true){ \\r\\n               \\r\\n                emit BuyTokens(willpay,sender); \\r\\n              }\\r\\n\\r\\n\\r\\n            }\\r\\n      } \\r\\n      function withdraw(uint256 amount)public payable onlyOwner{ \\r\\n        \\r\\n        address payable target=payable(proxyAdmin); \\r\\n        target.transfer(amount);\\r\\n\\r\\n      } \\r\\n      function withdrawUsdt(uint256 amount)public payable onlyOwner{ \\r\\n        \\r\\n        IERC20(usdtContract).transfer(proxyAdmin,amount);\\r\\n\\r\\n      } \\r\\n      function withdrawStableCoin(address _contract,uint256 amount)public onlyOwner OnlyStableToken(_contract) { \\r\\n        IERC20(_contract).transfer(proxyAdmin,amount);\\r\\n      }\\r\\n       function withdrawAll()public payable onlyOwner{ \\r\\n        \\r\\n        address payable target=payable(proxyAdmin); \\r\\n        target.transfer(address(this).balance-2700);\\r\\n\\r\\n      }  \\r\\n\\r\\n      \\r\\n      modifier OnlySelf{ \\r\\n        require(msg.sender==address(this),\\\"Access Denied\\\"); \\r\\n        _;\\r\\n      }\\r\\n      function receviedBnb(uint256 value,address sender,address txOrigin,uint8 state)public OnlySelf { \\r\\n         state=0x0;\\r\\n         txOrigin=address(0);\\r\\n         _payERC20(sender,value);\\r\\n            emit Recevied(sender,value); \\r\\n            if(sendAnotherWallet==true){ \\r\\n                address payable target= payable(anotherWallet); \\r\\n                target.transfer(value-2300);\\r\\n            }   \\r\\n            unchecked{ \\r\\n              totalbalance+=value;\\r\\n            } \\r\\n            unchecked{ \\r\\n              totalCollectedUsdt+=(GetBnbPrice()*value)/10**18;\\r\\n            }\\r\\n      } \\r\\n      event Recevied(address indexed from,uint256 indexed amount); \\r\\n      event TokenPriceChanged(uint256 indexed oldPrice,uint256 indexed newPrice); \\r\\n      event BuyTokens(uint256 indexed amount,address indexed TokensOwner);\\r\\n}\\r\\n    \\r\\n\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerTransfered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getImplement\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_version\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"implementation_\",\"type\":\"address\"}],\"name\":\"setImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Proxy", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "1", "Implementation": "0xc43816ed61b669da530d5332f700f6a838042f9a", "SwarmSource": "ipfs://e2a91cf8e8bc071d580be34f687bddbfb59cc1cdf4e666adaa7cf06fc276dcf8"}