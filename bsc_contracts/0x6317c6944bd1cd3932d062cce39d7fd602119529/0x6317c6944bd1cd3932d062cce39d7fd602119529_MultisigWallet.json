{"SourceCode": "// SPDX-License-Identifier: No License (None)\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Library for managing\r\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\r\n * types.\r\n *\r\n * Sets have the following properties:\r\n *\r\n * - Elements are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumerableSet for EnumerableSet.AddressSet;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumerableSet.AddressSet private mySet;\r\n * }\r\n * ```\r\n *\r\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\r\n * (`UintSet`) are supported.\r\n */\r\nlibrary EnumerableSet {\r\n\r\n    struct AddressSet {\r\n        // Storage of set values\r\n        address[] _values;\r\n\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping (address => uint256) _indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        if (!contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\r\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\r\n\r\n            address lastvalue = set._values[lastIndex];\r\n\r\n            // Move the last value to the index where the value to delete is\r\n            set._values[toDeleteIndex] = lastvalue;\r\n            // Update the index for the moved value\r\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Replace a current value from a set with the new value.\r\n     *\r\n     * Returns true if the value was replaced, and false if newValue already in set or currentValue is not in set\r\n     */\r\n    function replace(AddressSet storage set, address currentValue, address newValue) internal returns (bool) {\r\n        uint256 currentIndex = set._indexes[currentValue];\r\n        if (contains(set, newValue) || currentIndex == 0) {\r\n            return false;\r\n        } else {\r\n            set._values[currentIndex - 1] = newValue;\r\n            set._indexes[newValue] = currentIndex;\r\n            delete set._indexes[currentValue];\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns 1-based index of value in the set. O(1).\r\n     */\r\n    function indexOf(AddressSet storage set, address value) internal view returns (uint256) {\r\n        return set._indexes[value];\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n   /**\r\n    * @dev Returns the value stored at position `index` in the set. O(1).\r\n    *\r\n    * Note that there are no guarantees on the ordering of values inside the\r\n    * array, and it may change when more values are added or removed.\r\n    *\r\n    * Requirements:\r\n    *\r\n    * - `index` must be strictly less than {length}.\r\n    */\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\r\n        return set._values[index];\r\n    }\r\n}\r\n\r\ncontract MultisigWallet {\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n    struct Ballot {\r\n        uint128 votes;      // bitmap of unique votes (max 127 votes)\r\n        uint64 expire;      // time when ballot expire\r\n        uint8 yea;          // number of votes `Yea`\r\n    }\r\n\r\n    EnumerableSet.AddressSet owners; // founders may transfer contract's ownership\r\n    uint256 public ownersSetCounter;   // each time when change owners increase the counter\r\n    uint256 public expirePeriod = 3 days;\r\n    mapping(bytes32 => Ballot) public ballots;\r\n    uint256 public minRequired; // minimum voters required to approve. If 0 then required 50% + 1 vote.\r\n \r\n    event SetOwner(address owner, bool isEnable);\r\n    event CreateBallot(bytes32 ballotHash, uint256 expired);\r\n    event Execute(bytes32 ballotHash, address to, uint256 value, bytes data);\r\n\r\n\r\n    modifier onlyThis() {\r\n        require(address(this) == msg.sender, \"Only multisig allowed\");\r\n        _;\r\n    }\r\n    \r\n    // add list of owners and minimum voters required to approve (if 0 then required 50% + 1 vote).\r\n    constructor (address[] memory _owners, uint256 _minRequired) {\r\n        for (uint i = 0; i < _owners.length; i++) {\r\n            require(_owners[i] != address(0), \"Zero address\");\r\n            owners.add(_owners[i]);\r\n        }\r\n        require(_minRequired <= owners.length(), \"_minRequired too big\");\r\n        minRequired = _minRequired;\r\n    }\r\n\r\n    // get number of owners\r\n    function getOwnersNumber() external view returns(uint256) {\r\n        return owners.length();\r\n    }\r\n\r\n    // returns list of owners addresses\r\n    function getOwners() external view returns(address[] memory) {\r\n        return owners._values;\r\n    }\r\n\r\n    // add owner\r\n    function addOwner(address owner) external onlyThis{\r\n        require(owner != address(0), \"Zero address\");\r\n        require(owners.length() < 127, \"Too many owners\");\r\n        require(owners.add(owner), \"Owner already added\");\r\n        ownersSetCounter++; // change owners set\r\n        emit SetOwner(owner, true);\r\n    }\r\n\r\n    // remove owner\r\n    function removeOwner(address owner) external onlyThis{\r\n        require(owners.length() > 1, \"Remove all owners is not allowed\");\r\n        require(owners.remove(owner), \"Owner does not exist\");\r\n        ownersSetCounter++; // change owners set\r\n        emit SetOwner(owner, false);\r\n    }\r\n    \r\n    // change owner address\r\n    function changeOwnerAddress(address currentAddress, address newAddress) external onlyThis{\r\n        require(newAddress != address(0), \"Zero address\");\r\n        require(owners.replace(currentAddress, newAddress), \"currentAddress does not exist or newAddress already exist\");\r\n        emit SetOwner(currentAddress, false);\r\n        emit SetOwner(newAddress, true);\r\n    }\r\n\r\n    // set minimum voters required to approve (if 0 then required 50% + 1 vote).\r\n    function setMinRequired(uint256 _minRequired) external onlyThis{\r\n        require(_minRequired <= owners.length(), \"_minRequired too big\");\r\n        minRequired = _minRequired;\r\n    }\r\n\r\n    function setExpirePeriod(uint256 period) external onlyThis {\r\n        require(period >= 1 days, \"Too short period\");  // avoid deadlock in case of set too short period\r\n        expirePeriod = period;\r\n    }\r\n\r\n    function vote(address to, uint256 value, bytes calldata data) external {\r\n        uint256 index = owners.indexOf(msg.sender);\r\n        require(index != 0, \"Only owner\");\r\n        bytes32 ballotHash = keccak256(abi.encodePacked(to, value, data, ownersSetCounter));\r\n        Ballot memory b = ballots[ballotHash];\r\n        if (b.expire == 0 || b.expire < uint64(block.timestamp)) { // if no ballot or ballot expired - create new ballot\r\n            b.expire = uint64(block.timestamp + expirePeriod);\r\n            b.votes = 0;\r\n            b.yea = 0;\r\n            emit CreateBallot(ballotHash, b.expire);\r\n        }\r\n        uint256 mask = 1 << index;\r\n        if (b.votes & mask == 0) {  // this owner don't vote yet.\r\n            b.votes = uint128(b.votes | mask); // record owner's vote\r\n            b.yea += 1; // increase total votes \"Yea\"\r\n        }\r\n\r\n        if (isApproved(b.yea)) {   \r\n            delete ballots[ballotHash];\r\n            execute(to, value, data);\r\n            emit Execute(ballotHash, to, value, data);\r\n        } else {\r\n            // update ballot\r\n            ballots[ballotHash] = b;\r\n        }\r\n    }\r\n\r\n    function isApproved(uint256 votesYea) internal view returns(bool) {\r\n        // use local variables to save gas\r\n        uint256 _minRequired = minRequired;\r\n        uint256 _ownersLength = owners.length();\r\n        if (_minRequired == 0 || _minRequired > _ownersLength) { // to avoid deadlock minRequired can't be bigger than number of owners.\r\n            return (votesYea >= _ownersLength / 2 + 1); // vote \"Yea\" > 50% of owners\r\n        } else {\r\n            return (votesYea >= _minRequired); // vote \"Yea\" >= minimum required\r\n        }\r\n    }\r\n\r\n    function execute(address to, uint256 value, bytes memory data) internal {\r\n        (bool success,) = to.call{value: value}(data);\r\n        require(success, \"Execute error\");\r\n    }\r\n\r\n    // allow receive ERC223 tokens\r\n    function tokenReceived(address _from, uint _value, bytes calldata _data) external {} \r\n    // allow receive ERC721 tokens (NFT)\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external pure returns(bytes4) {\r\n        return bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"));\r\n    }\r\n    // allow receive coin\r\n    receive() external payable {}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_owners\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_minRequired\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"ballotHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expired\",\"type\":\"uint256\"}],\"name\":\"CreateBallot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"ballotHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Execute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isEnable\",\"type\":\"bool\"}],\"name\":\"SetOwner\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"ballots\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"votes\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"expire\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"yea\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"currentAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"changeOwnerAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"expirePeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwnersNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minRequired\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownersSetCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"setExpirePeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minRequired\",\"type\":\"uint256\"}],\"name\":\"setMinRequired\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenReceived\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"vote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MultisigWallet", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000030000000000000000000000004cc3a18209517a09f472639551357db80a17412b000000000000000000000000c9bea9379a8fade01240ee583535fac713b71014000000000000000000000000600360f031a22213522329c41ead9f0a4d6f37ff", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://61a47b557b39abaf4503164bfe4ed0191cca4e8175058355e189e9cce349ad34"}