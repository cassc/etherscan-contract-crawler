{"SourceCode": "{\"atlasAuctions.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.10;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\r\\n * in bugs, because programmers usually assume that an overflow raises an\\r\\n * error, which is the standard behavior in high level programming languages.\\r\\n * `SafeMath` restores this intuition by reverting the transaction when an\\r\\n * operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it\\u0027s recommended to use it always.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        // Solidity only automatically asserts when dividing by 0\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount)\\r\\n        external\\r\\n        returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address _owner, address spender)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n}\\r\\n\\r\\nenum EQNOXStakeState {\\r\\n    Active,\\r\\n    InAccounting,\\r\\n    Closed,\\r\\n    Moved,\\r\\n    Merged\\r\\n}\\r\\n\\r\\nstruct EqnoxStake {\\r\\n    bytes16 stakeId;\\r\\n    uint256 stakeAmount;\\r\\n    uint256 shares;\\r\\n    EQNOXStakeState stakeState;\\r\\n    uint256 interestAmount;\\r\\n    uint256 stakeStartTokenDay;\\r\\n    uint256 numDaysAccountedFor;\\r\\n    uint256 accountingStartTokenDay;\\r\\n    uint256 accountingStartDayOfYear;\\r\\n    uint256 accountingStartTokenYear;\\r\\n}\\r\\n\\r\\nstruct Inflation {\\r\\n    uint256 numerator;\\r\\n    uint256 denominator;\\r\\n    uint256 totalShares;\\r\\n    uint256 totalSupply;\\r\\n    uint256 tokensStakedAccounting;\\r\\n}\\r\\n\\r\\ninterface IEqnoxToken {\\r\\n\\r\\n    function stakes(address account, bytes16 stakeId) external view returns (EqnoxStake memory);\\r\\n\\r\\n    function SharesAccounting() external view returns (uint256);\\r\\n}\\r\\n\\r\\ninterface IAtlasToken {\\r\\n    function CurrentTokenDay() external view returns (uint256);\\r\\n\\r\\n    function TokenStartTimestamp() external view returns (uint256);\\r\\n\\r\\n    function updatePoolDepthAndAvgs() external;\\r\\n\\r\\n    function sharesHeldByAccountsAccounting(address account, uint256 tokenDay) external view returns (uint256);\\r\\n\\r\\n    function dailyInflations(uint256 tokenDay) external view returns (Inflation memory);\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    function mintSupply(address account, uint256 amount) external;\\r\\n\\r\\n    function createAuctionStake(address account, uint256 amountToStake, uint256 stakeDuration) external;\\r\\n\\r\\n    function MAX_STAKE_DURATION_IN_DAYS() external view returns (uint256);\\r\\n\\r\\n    function setIsTradingActive(bool value) external;\\r\\n\\r\\n    function IS_TRADING_ACTIVE() external view returns (bool);\\r\\n\\r\\n    function burnSupply(uint256 amount) external;\\r\\n\\r\\n    function SECONDS_PER_DAY() external view returns (uint256);\\r\\n\\r\\n}\\r\\n\\r\\ninterface IAtlasPoolMgmt {\\r\\n    function fundBusd(uint256 busdAmount) external;\\r\\n    function poolReserves() external view returns (uint256 tokenAmount, uint256 busdAmount);\\r\\n    function calcPoolAndBuybackAmounts(uint256 amountIn) external returns (uint256 poolAmount, uint256 buybackAmount);\\r\\n    function calcOutputAmountSwapBusdToAtlas(uint256 amountBusd, uint256 taxNum) external view returns (uint256 amountAtlas);\\r\\n    function calcOutputAmountSwapWETHtoBusd(uint256 amountWeth, uint256 taxNum) external view returns (uint256 amountBusd);\\r\\n    function TRADE_TAX() external view returns (uint256);\\r\\n}\\r\\n\\r\\nstruct MAddress {\\r\\n    address account;\\r\\n    uint256 num;\\r\\n    uint256 den;\\r\\n}\\r\\n\\r\\ninterface IAtlasMAddressMgmt {\\r\\n    function mAddresses(uint256) external view returns (MAddress memory);\\r\\n    function mAddressesLength() external view returns (uint256);\\r\\n}\\r\\n\\r\\ninterface IEqnoxUtils {\\r\\n    function isEqnoxStakeValid(address account, bytes16 stakeId) external view returns (bool, string memory);\\r\\n    function userBestEqnoxStake(address account) external view returns (bytes16);\\r\\n}\\r\\n\\r\\nimport \\\"./pool.sol\\\";\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Abstract contract to manage owner access to contract\\r\\n */\\r\\nabstract contract Owner {\\r\\n    address public CONTRACT_DEFINER;\\r\\n    address public BID_MANAGER;\\r\\n\\r\\n    modifier mod_onlyContractDefiner() {\\r\\n        require(msg.sender == CONTRACT_DEFINER, \\\"Wrong sender.\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier mod_onlyBidManager() {\\r\\n        require(msg.sender == BID_MANAGER, \\\"Wrong sender.\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() external mod_onlyContractDefiner {\\r\\n        CONTRACT_DEFINER = address(0x0);\\r\\n    }\\r\\n\\r\\n    function changeOwnership(address newOwner) external mod_onlyBidManager {\\r\\n        BID_MANAGER = newOwner;\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Abstract base contract with addresses and contracts, and locking mechanism for native currency donations\\r\\n */\\r\\nabstract contract Base is Owner {\\r\\n    IEqnoxToken public EQNOX_CONTRACT;\\r\\n    IEqnoxUtils public EQNOX_UTILS_CONTRACT;\\r\\n    IERC20 public BUSD_CONTRACT;\\r\\n\\r\\n    address public UNISWAP_ROUTER;\\r\\n\\r\\n    bool isOperationLocked = false;\\r\\n\\r\\n    modifier mod_lock() {\\r\\n        require(!isOperationLocked, \\\"Operation is locked\\\");\\r\\n        isOperationLocked = true;\\r\\n        _;\\r\\n        isOperationLocked = false;\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Abstract Data contract that holds the contract variables and mappings\\r\\n */\\r\\nabstract contract Data is Base {\\r\\n\\r\\n    //minimum base donation is 30 BUSD\\r\\n    uint256 public MIN_DONATE = 30E18; //30.00 BUSD\\r\\n\\r\\n    uint256 public MAX_NUM_PARTICIPANTS = 500;\\r\\n\\r\\n\\r\\n    //45% for pool and buyback\\r\\n    uint256 public POOL_AND_BUYBACK_NUM = 45;\\r\\n    uint256 public POOL_AND_BUYBACK_DEN = 100;\\r\\n\\r\\n    //40% from rewards go to dividends\\r\\n    uint256 public DIVIDENDS_NUMERATOR = 4;\\r\\n    uint256 public DIVIDENDS_DENOMINATOR = 10;\\r\\n\\r\\n    //5% from rewards go to BPDs\\r\\n    uint256 public BPD_NUMERATOR = 5;\\r\\n    uint256 public BPD_DENOMINATOR = 100;\\r\\n\\r\\n    //10% for mkt and dev\\r\\n    uint256 public MKT_DEN = 10;\\r\\n\\r\\n\\r\\n    struct AuctionResult {\\r\\n        uint256 auctionDay;\\r\\n        uint256 totalDonatedBusd;\\r\\n        uint256 totalBidPower;\\r\\n        uint256 donatedBusdByUser;\\r\\n        uint256 bidPowerByUser;\\r\\n        uint256 numberOfParticipants;\\r\\n    }\\r\\n\\r\\n    struct PeriodDistributionRatio {\\r\\n        uint256 numerator;\\r\\n        uint256 denominator;\\r\\n        uint256 periodNumber;\\r\\n    }\\r\\n\\r\\n    IAtlasToken public TOKEN_CONTRACT;\\r\\n    IAtlasPoolMgmt public ATLAS_POOL_MGMT;\\r\\n    IAtlasMAddressMgmt public MADDRESS_CONTRACT;\\r\\n\\r\\n    uint256 public CurrentAuctionDay = 1;\\r\\n    uint256 public MAX_DONATION_PERIODS = 90;\\r\\n    uint256 public LAST_DIVIDEND_DAY = 182;\\r\\n\\r\\n    uint256 public TotalTokensClaimedFromDonations = 0;\\r\\n\\r\\n    uint256 public TotalBUSDReceivedForBPDs = 0;\\r\\n    uint256 public TotalBUSDSentToBPDs = 0;\\r\\n    uint256 public TotalBUSDClaimedFromBPDs = 0;\\r\\n\\r\\n    uint256 public TotalBPDsAwardedCounter = 0;\\r\\n    uint256 public TotalBPDsClaimedCounter = 0;\\r\\n\\r\\n    uint256 public BUSDForPoolAccounting = 0;\\r\\n\\r\\n    uint256 public TotalBUSDSentToAuctions = 0;\\r\\n\\r\\n    uint256 public TotalBUSDSentToPool = 0;\\r\\n    uint256 public TotalBUSDUsedForBuybacks = 0;\\r\\n    uint256 public TotalAtlasBurnedFromBuybacks = 0;\\r\\n\\r\\n\\r\\n    uint256 public BUSDForDividendsAccounting = 0;\\r\\n    uint256 public BUSDForBPDAccounting = 0;\\r\\n\\r\\n    uint256 public TotalBUSDReceivedForDividends = 0;\\r\\n    uint256 public TotalBUSDClaimedFromDividends = 0;\\r\\n\\r\\n    uint256 public MIN_AUCTION_STAKING_DAYS = 90;\\r\\n\\r\\n    uint256 public MAX_NUMBER_BPD_STEPS = 400;\\r\\n\\r\\n    mapping(uint256 =\\u003e uint256) public periodBUSDDonations;\\r\\n    mapping(uint256 =\\u003e uint256) public periodPowerDonations;\\r\\n\\r\\n    mapping(uint256 =\\u003e PeriodDistributionRatio) public periodRatio;\\r\\n\\r\\n    mapping(uint256 =\\u003e uint256) public donatorAccountCount;\\r\\n    mapping(uint256 =\\u003e mapping(uint256 =\\u003e address)) public donatorAccounts;\\r\\n    mapping(address =\\u003e uint256) public donatorBUSDBpdDonations;\\r\\n    address[] public donatorsList;\\r\\n\\r\\n    mapping(address =\\u003e mapping(uint256 =\\u003e uint256)) public donatorClaimedTokensFromDonations;\\r\\n\\r\\n\\r\\n    mapping(address =\\u003e uint256) public donatorClaimedBUSDFromBPDs;\\r\\n    mapping(address =\\u003e uint256) public donatorClaimableBUSDFromBPDs;\\r\\n\\r\\n    mapping(address =\\u003e uint256) public donatorTotalBPDsClaimedCounter;\\r\\n\\r\\n    mapping(address =\\u003e uint256) public donatorTotalClaimedTokens;\\r\\n\\r\\n    mapping(address =\\u003e mapping(uint256 =\\u003e uint256)) public donatorClaimedDividendsForPeriod;\\r\\n\\r\\n    mapping(address =\\u003e uint256) public donatorTotalBusdDividendsClaimed;\\r\\n\\r\\n    mapping(address =\\u003e mapping(uint256 =\\u003e bool)) public haveDividendsBeenClaimedByAccountForPeriod;\\r\\n\\r\\n    mapping(uint256 =\\u003e uint256) public totalDividendsPerPeriod;\\r\\n\\r\\n    uint256 public PERIOD_SUPPLY = 1E25; // 10M tokens per period 10,000,000 * 1E18\\r\\n\\r\\n\\r\\n    /**\\r\\n     * External function to ajust the minimum amount to bid\\r\\n     */\\r\\n    function updateMinBidAmount(uint256 minAmount) external mod_onlyBidManager {\\r\\n        MIN_DONATE = minAmount;\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Abstract contract to manage day update, dividends and BPDs\\r\\n */\\r\\nabstract contract DayMgmt is Data {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    event auctionPeriodUpdated(\\r\\n        uint256 indexed auctionDay\\r\\n    );\\r\\n\\r\\n    event dividendsClaimed(\\r\\n        uint256 indexed auctionDay,\\r\\n        uint256 indexed amountClaimed,\\r\\n        address indexed claimedBy\\r\\n    );\\r\\n\\r\\n    event bpdClaimed(\\r\\n        uint256 indexed auctionDay,\\r\\n        uint256 indexed amountClaimed,\\r\\n        address indexed claimedBy\\r\\n    );\\r\\n\\r\\n    event poolContractFunded(\\r\\n        uint256 indexed auctionDay,\\r\\n        uint256 indexed amount\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to add days to a timestamp\\r\\n     */\\r\\n    function _addDays(uint timestamp, uint _days) internal view returns (uint newTimestamp) {\\r\\n        uint256 secondsPerDay = TOKEN_CONTRACT.SECONDS_PER_DAY();\\r\\n        newTimestamp = timestamp + _days * secondsPerDay;\\r\\n        require(newTimestamp \\u003e= timestamp);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to add hours to timestamp\\r\\n     */\\r\\n    function _addHours(uint256 timestamp, uint256 numHours) internal view returns (uint256 newTimestamp) {\\r\\n        uint256 secondsPerDay = TOKEN_CONTRACT.SECONDS_PER_DAY();\\r\\n        uint256 secondsPerHour = secondsPerDay.div(24);\\r\\n        return numHours.mul(secondsPerHour).add(timestamp);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Public function to check amount of seconds after daily auctions cutoff\\r\\n     */\\r\\n    function checkAmountSecondsAfterCutOff(uint256 currentTokenDay, uint256 contractStartTimestamp, uint256 nowTimestamp, uint256 numHours) public view returns (uint256) {\\r\\n        uint256 currentDayStartTimestamp = _addDays(contractStartTimestamp, currentTokenDay.sub(1));\\r\\n        uint256 cutOffTimestamp = _addHours(currentDayStartTimestamp, numHours);\\r\\n        if(nowTimestamp \\u003c= cutOffTimestamp) return 0;\\r\\n        return nowTimestamp.sub(cutOffTimestamp);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Public function to calculate the bid power reduction multiplier\\r\\n     */\\r\\n    function calculateBidPowerReductionMultiplier(uint256 cuttOffComplementInHours, uint256 amountAfterCutOff) public view returns (uint256 num, uint256 den) {\\r\\n        uint256 secondsPerDay = TOKEN_CONTRACT.SECONDS_PER_DAY();\\r\\n        uint256 secondsPerHour = secondsPerDay.div(24);\\r\\n        uint256 cuttOffComplementInSeconds = cuttOffComplementInHours.mul(secondsPerHour);\\r\\n        uint256 bidPowerNum = 75;\\r\\n        uint256 bidPowerDen = 100;\\r\\n\\r\\n        if(amountAfterCutOff \\u003e= cuttOffComplementInSeconds) return (bidPowerNum, bidPowerDen);\\r\\n\\r\\n        return (bidPowerDen.sub(bidPowerDen.sub(bidPowerNum).mul(amountAfterCutOff).div(cuttOffComplementInSeconds)), bidPowerDen);\\r\\n    }\\r\\n\\r\\n    function canUserChangeBidPledgeOrEqnoxStake() public view returns (bool) {\\r\\n        uint256 contractStartTimestamp = TOKEN_CONTRACT.TokenStartTimestamp();\\r\\n        return checkAmountSecondsAfterCutOff(CurrentAuctionDay, contractStartTimestamp, block.timestamp, 22) == 0;\\r\\n    }\\r\\n\\r\\n    function calculateBidPowerNetWithModulation(uint256 amount) public view returns (uint256) {\\r\\n        uint256 contractStartTimestamp = TOKEN_CONTRACT.TokenStartTimestamp();\\r\\n        uint256 amountSecondsAfterCutOff = checkAmountSecondsAfterCutOff(CurrentAuctionDay, contractStartTimestamp, block.timestamp, 23);\\r\\n        (uint256 num, uint256 den) = calculateBidPowerReductionMultiplier(1, amountSecondsAfterCutOff);\\r\\n\\r\\n        return amount.mul(num).div(den);\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n    modifier mod_opTrigger() {\\r\\n        _updateDay();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function updateDay() external {\\r\\n        _updateDay();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to update the day. Advances the auction day until it reaches the CurrentTokenDay on the Token contract.\\r\\n     */\\r\\n    function _updateDay() internal {\\r\\n        uint256 currentTokenDay = TOKEN_CONTRACT.CurrentTokenDay();\\r\\n        //in theory CurrentAuctionDay should never be bigger than currentTokenDay, but for safety let\\u0027s leave it here\\r\\n        if (CurrentAuctionDay \\u003e= currentTokenDay) {\\r\\n            //nothing to do\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        TOKEN_CONTRACT.updatePoolDepthAndAvgs();\\r\\n\\r\\n        //we will advance as many days as needed to sync up with the token contract\\r\\n        while (CurrentAuctionDay \\u003c currentTokenDay) {\\r\\n            \\r\\n            \\r\\n            _registerDistributionRatio(CurrentAuctionDay);\\r\\n\\r\\n            _createBPDRewards();\\r\\n\\r\\n            TOKEN_CONTRACT.updatePoolDepthAndAvgs();\\r\\n\\r\\n\\r\\n            //reduce the period supply by 2% every period change\\r\\n            PERIOD_SUPPLY = PERIOD_SUPPLY.sub(PERIOD_SUPPLY.mul(2).div(100));\\r\\n\\r\\n            //increment the auction day\\r\\n            CurrentAuctionDay += 1;\\r\\n\\r\\n            //calculate the dividends for the new auction day. It fetches previous data, and needs to have the calculation ready for the current auction day\\r\\n            totalDividendsPerPeriod[CurrentAuctionDay] = calcDividendsForPeriod(CurrentAuctionDay);\\r\\n\\r\\n            emit auctionPeriodUpdated(CurrentAuctionDay);\\r\\n        }\\r\\n\\r\\n\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Private function to register the daily distribution ratio of Token to BUSD.\\r\\n     */\\r\\n    function _registerDistributionRatio(uint256 period) private {\\r\\n        PeriodDistributionRatio memory ratio;\\r\\n\\r\\n        if (periodPowerDonations[period] == 0) {\\r\\n            //if no one donated, set the ratio to 0/1\\r\\n            ratio.numerator = 0;\\r\\n            ratio.denominator = 1;\\r\\n        } else {\\r\\n            ratio.numerator = PERIOD_SUPPLY;\\r\\n            ratio.denominator = periodPowerDonations[period];\\r\\n        }\\r\\n        ratio.periodNumber = period;\\r\\n\\r\\n        periodRatio[period] = ratio;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Public function to calculate the total dividends for a period\\r\\n     */\\r\\n    function calcDividendsForPeriod(uint256 period) public view returns (uint256) {\\r\\n        //if the period is less than day 3 return 0\\r\\n        if (period \\u003c= 2) return 0;\\r\\n        //if the period is in the future, return 0\\r\\n        if (period \\u003e CurrentAuctionDay) return 0;\\r\\n\\r\\n        uint256 dividendsForPeriod = 0;\\r\\n\\r\\n        //we just need to account backwards to half the length\\r\\n        uint256 endPos = period.div(2);\\r\\n\\r\\n        //we can start two positions prior to the period date\\r\\n        uint256 pos = period - 2;\\r\\n\\r\\n        //cycle from the start pos until the end (including)\\r\\n        while (pos \\u003e= endPos) {\\r\\n            dividendsForPeriod = dividendsForPeriod.add(\\r\\n                //dailyTotalDividend = totalAmountDonatedThatDay * dividendPercentage / pos\\r\\n                //day 3 totalDividend = totalAmountDonatedDay1 * dividendPercentage / 1\\r\\n                //day 4 totalDividend = totalAmountDonatedDay2 * dividendPercentage / 2\\r\\n                //day 5 totalDividend = totalAmountDonatedDay3 * dividendPercentage / 3 + totalAmountDonatedDay2 * dividendPercentage / 2\\r\\n                periodBUSDDonations[pos]\\r\\n                    .mul(DIVIDENDS_NUMERATOR)\\r\\n                    .div(DIVIDENDS_DENOMINATOR)\\r\\n                    .div(pos)\\r\\n            );\\r\\n            pos--;\\r\\n        }\\r\\n\\r\\n        return dividendsForPeriod;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Public auxiliary function to claim dividends for multiple periods in one go\\r\\n     */\\r\\n    function claimDividendsBetweenPeriods(uint256 startPeriod, uint256 endPeriod) external {\\r\\n        require(startPeriod \\u003c= endPeriod, \\\"Start period must be smaller or equal to end period\\\");\\r\\n        \\r\\n        uint256 totalDividendsClaimed = 0;\\r\\n        for(uint256 i = startPeriod; i \\u003c= endPeriod; i++) {\\r\\n            //if dividends have already been claimed, jump to the next day\\r\\n            if(haveDividendsBeenClaimedByAccountForPeriod[msg.sender][i]) continue;\\r\\n\\r\\n            //if the amount of total shares for the previous daily inflation is zero, we can skip the day since nothing was staked that day\\r\\n            if(TOKEN_CONTRACT.dailyInflations(i-1).totalShares == 0) continue;\\r\\n\\r\\n            //claim dividends for the period\\r\\n            uint256 dividendClaimed = _claimDividendsForPeriod(i);\\r\\n            totalDividendsClaimed = totalDividendsClaimed.add(dividendClaimed);\\r\\n        }\\r\\n\\r\\n        //transfer the dividends to the user\\r\\n        BUSD_CONTRACT.transfer(msg.sender, totalDividendsClaimed);\\r\\n        emit dividendsClaimed(CurrentAuctionDay, totalDividendsClaimed, msg.sender);\\r\\n    }\\r\\n\\r\\n    function claimDividendsForPeriod(uint256 period) public {\\r\\n\\r\\n        uint256 dividendClaimed = _claimDividendsForPeriod(period);\\r\\n        //transfer the dividends to the user\\r\\n        BUSD_CONTRACT.transfer(msg.sender, dividendClaimed);\\r\\n        emit dividendsClaimed(CurrentAuctionDay, dividendClaimed, msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Private function to claim dividends for a period. Does not do the transfer to the user. Needs to be used in conjunction with the public functions\\r\\n     */\\r\\n    function _claimDividendsForPeriod(uint256 period) private returns (uint256) {\\r\\n        //Claiming can only start at day 3 and onwards\\r\\n        require(period \\u003e 2, \\\"Periods are claimable only after day 2\\\");\\r\\n        require(period \\u003c= LAST_DIVIDEND_DAY, \\\"Claiming dividends after last dividend day is not allowed\\\");\\r\\n        require(!haveDividendsBeenClaimedByAccountForPeriod[msg.sender][period], \\\"Dividends already claimed\\\");\\r\\n        //Claiming can go up to the current auction day\\r\\n        require(period \\u003c= CurrentAuctionDay, \\\"Claim period must be until the current auction day\\\");\\r\\n        haveDividendsBeenClaimedByAccountForPeriod[msg.sender][period] = true;\\r\\n\\r\\n        uint256 totalSharesStakedAccounting = 0;\\r\\n\\r\\n        //account for staked shares since day two. Day one you can\\u0027t stake from auctions\\r\\n        //account until the day before the period given. This is because the period can go up to the current day, where stakes can be ended\\r\\n        for (uint256 i = 2; i \\u003c period; i++) {\\r\\n            totalSharesStakedAccounting = totalSharesStakedAccounting.add(TOKEN_CONTRACT.sharesHeldByAccountsAccounting(msg.sender, i));\\r\\n        }\\r\\n\\r\\n        //the busd dividend for the user is calculated based on the total busd accumulated up until two days prior to the period - see calcDividendsForPeriod\\r\\n        //multiplied by the ratio of: the total amount of shares the user has staked up until the previous day / the total amount of shares on the previous day\\r\\n        uint256 busdDividend = totalDividendsPerPeriod[period].mul(totalSharesStakedAccounting).div(TOKEN_CONTRACT.dailyInflations(period-1).totalShares);\\r\\n\\r\\n        //register the amount the user claimed\\r\\n        donatorClaimedDividendsForPeriod[msg.sender][period] = busdDividend;\\r\\n\\r\\n        //register the total amount the user has claimed\\r\\n        donatorTotalBusdDividendsClaimed[msg.sender] = donatorTotalBusdDividendsClaimed[msg.sender].add(busdDividend);\\r\\n\\r\\n        //register the amount of dividends claimed in total\\r\\n        TotalBUSDClaimedFromDividends = TotalBUSDClaimedFromDividends.add(busdDividend);\\r\\n\\r\\n        //subtract the amount of dividends available\\r\\n        BUSDForDividendsAccounting = BUSDForDividendsAccounting.sub(busdDividend);\\r\\n\\r\\n        return busdDividend;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Public function to read how much dividends are claimable for a period\\r\\n     */\\r\\n    function claimableDividendsForPeriod(address account, uint256 period) external view returns (uint256) {\\r\\n        if(period \\u003c= 2) return 0;\\r\\n        if(period \\u003e LAST_DIVIDEND_DAY) return 0;\\r\\n        if(haveDividendsBeenClaimedByAccountForPeriod[account][period]) return 0;\\r\\n        if(period \\u003e CurrentAuctionDay) return 0;\\r\\n        \\r\\n        //check for 0 to avoid division by 0\\r\\n        if(TOKEN_CONTRACT.dailyInflations(period-1).totalShares == 0) return 0;\\r\\n\\r\\n        uint256 totalSharesStakedAccounting = 0;\\r\\n\\r\\n        for (uint256 i = 2; i \\u003c period; i++) {\\r\\n            totalSharesStakedAccounting = totalSharesStakedAccounting.add(TOKEN_CONTRACT.sharesHeldByAccountsAccounting(account, i));\\r\\n        }\\r\\n\\r\\n        return totalDividendsPerPeriod[period].mul(totalSharesStakedAccounting).div(TOKEN_CONTRACT.dailyInflations(period-1).totalShares);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev External function for claiming BPDs. Claiming transfer all accumulated BPDs back to the user, and zeros the accumulated amount\\r\\n     */\\r\\n    function claimBusdFromBPDs() external {\\r\\n        //BPD claiming starts after auction day 1\\r\\n        require(CurrentAuctionDay \\u003e 1, \\\"Too early.\\\");\\r\\n        require(donatorClaimableBUSDFromBPDs[msg.sender] \\u003e 0, \\\"No BUSD to claim.\\\");\\r\\n\\r\\n        //fetch the amount the user can claim\\r\\n        uint256 claimed = donatorClaimableBUSDFromBPDs[msg.sender];\\r\\n\\r\\n        //zero the amount claimable\\r\\n        donatorClaimableBUSDFromBPDs[msg.sender] = 0;\\r\\n\\r\\n        //register the total amount in BPDs claimed by the user\\r\\n        donatorClaimedBUSDFromBPDs[msg.sender] = donatorClaimedBUSDFromBPDs[msg.sender].add(claimed);\\r\\n\\r\\n        //register the amount claimed in total from BPDs\\r\\n        TotalBUSDClaimedFromBPDs = TotalBUSDClaimedFromBPDs.add(claimed); // add to total claimed\\r\\n\\r\\n        //register the amount of times BPDs were claimed\\r\\n        TotalBPDsClaimedCounter = TotalBPDsClaimedCounter + 1;\\r\\n\\r\\n        //register the amount of times the user has claimed BPDs\\r\\n        donatorTotalBPDsClaimedCounter[msg.sender] = donatorTotalBPDsClaimedCounter[msg.sender] + 1;\\r\\n\\r\\n        //transfer the claimed amount to the user\\r\\n        BUSD_CONTRACT.transfer(msg.sender, claimed);\\r\\n\\r\\n        emit bpdClaimed(CurrentAuctionDay, claimed, msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Private function for generating a random number.\\r\\n     */\\r\\n    function _getRandomNumber(uint256 ceiling) private view returns (uint256) {\\r\\n        if (ceiling \\u003e 0) {\\r\\n            uint256 val = (uint256(blockhash(block.number - 1)) %\\r\\n                uint256(block.timestamp)) + (block.difficulty);\\r\\n            val = val % uint256(ceiling);\\r\\n            return val;\\r\\n        } else return 0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Private function for creating random BPD rewards\\r\\n     */\\r\\n    function _createBPDRewards() private {\\r\\n        //if nothing was donated do nothing\\r\\n        if (BUSDForBPDAccounting == 0) return;\\r\\n\\r\\n        uint256 numParticipants = donatorsList.length;\\r\\n\\r\\n        //if no one donated, do nothing\\r\\n        if (numParticipants == 0) return;\\r\\n\\r\\n        //go through the list and check for each donator if there is still enough BUSD to give back\\r\\n        //read from storage at the start of the loop\\r\\n        uint256 currentBUSDForBPDAccounting = BUSDForBPDAccounting;\\r\\n\\r\\n        //start at a random position in the array\\r\\n        uint256 startPosition = _getRandomNumber(numParticipants);\\r\\n\\r\\n        uint256 counter = 0;\\r\\n        //iterate at most 400 seats\\r\\n        for(uint256 i = startPosition; counter \\u003c MAX_NUMBER_BPD_STEPS; counter++) {\\r\\n\\r\\n            //fetch the winner\\r\\n            address winner = donatorsList[i];\\r\\n\\r\\n            //fetch his accumulated BPD amount\\r\\n            uint256 bpd = donatorBUSDBpdDonations[winner];\\r\\n\\r\\n            //check if there enough BUSD to give back\\r\\n            if (currentBUSDForBPDAccounting \\u003e= bpd) {\\r\\n\\r\\n                //add to the user claimable BPDs\\r\\n                donatorClaimableBUSDFromBPDs[winner] = donatorClaimableBUSDFromBPDs[winner].add(bpd);\\r\\n                \\r\\n                //increase the total BPDs awarded\\r\\n                TotalBPDsAwardedCounter = TotalBPDsAwardedCounter + 1;\\r\\n\\r\\n                //subtract the bpd awarded from the current accounting\\r\\n                currentBUSDForBPDAccounting = currentBUSDForBPDAccounting.sub(bpd);\\r\\n\\r\\n                //reset the donator BPD - since he won, his BPD is reset\\r\\n                donatorBUSDBpdDonations[winner] = 0;\\r\\n\\r\\n                //if the winner is at the last position of the list, just pop him\\r\\n                if(i == donatorsList.length - 1) {\\r\\n                    donatorsList.pop();\\r\\n                }\\r\\n                //otherwise, fetch the address at the last position and swap it with the current position\\r\\n                //and pop the last position\\r\\n                else {\\r\\n                    address swap = donatorsList[donatorsList.length - 1];\\r\\n                    donatorsList[i] = swap;\\r\\n                    donatorsList.pop();\\r\\n                }\\r\\n                //the list just got one position shorter\\r\\n                //check if the list has items, if it hasn\\u0027t break out of the cycle\\r\\n                if(donatorsList.length == 0) break;\\r\\n            }\\r\\n            \\r\\n            //move the index forward until the end of the list, and restart at the beginning when it reaches the end\\r\\n            i = i + 1 \\u003c donatorsList.length ? i + 1 : 0;\\r\\n        }\\r\\n\\r\\n        //account for all transferred to BPDs\\r\\n        TotalBUSDSentToBPDs = TotalBUSDSentToBPDs.add(BUSDForBPDAccounting.sub(currentBUSDForBPDAccounting));\\r\\n\\r\\n        //write to storage only at the end of the loop\\r\\n        BUSDForBPDAccounting = currentBUSDForBPDAccounting;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to transfer funds for pool management contract\\r\\n     */\\r\\n    function _transferPoolFundsToPoolMgmtContract() internal {\\r\\n        if (BUSDForPoolAccounting \\u003c 1e18) return; //do nothing if it\\u0027s less than 1 BUSD\\r\\n\\r\\n        BUSD_CONTRACT.approve(address(ATLAS_POOL_MGMT), BUSDForPoolAccounting);\\r\\n        ATLAS_POOL_MGMT.fundBusd(BUSDForPoolAccounting);\\r\\n        //update the total busd sent to the pool contract\\r\\n        TotalBUSDSentToPool = TotalBUSDSentToPool.add(BUSDForPoolAccounting);\\r\\n        BUSDForPoolAccounting = 0;\\r\\n\\r\\n        emit poolContractFunded(CurrentAuctionDay, BUSDForPoolAccounting);\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Abstract contract to manage donations and funds distribution\\r\\n */\\r\\nabstract contract DonationMgmt is DayMgmt {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    uint256 public STAKE_PLEDGE_MAX_BOOST = 5;\\r\\n    uint256 public EQNOX_STAKE_MAX_BOOST = 1;\\r\\n    uint256 public EQNOX_STAKE_SHARE_BOOST_NUM = 1;\\r\\n    uint256 public EQNOX_STAKE_SHARE_BOOST_DEN = 100;\\r\\n\\r\\n    event donationReceived(\\r\\n        uint256 indexed tokenDay,\\r\\n        address donatorAddress,\\r\\n        uint256 amountDonated\\r\\n    );\\r\\n\\r\\n    event tokensClaimed(\\r\\n        uint256 indexed tokenDay,\\r\\n        uint256 tokenAmount,\\r\\n        address claimerAddress\\r\\n    );\\r\\n\\r\\n    //mapping of checks of claimed tokens per user per auction day\\r\\n    mapping(address =\\u003e mapping(uint256 =\\u003e bool))  public hasDonatorClaimedTokensFromAuctions;\\r\\n\\r\\n    //staking pledge for each user\\r\\n    mapping(address =\\u003e mapping(uint256 =\\u003e uint256)) public donatorStakingPledge;\\r\\n\\r\\n    //mapping of reference eqnox stakeid set per auction day\\r\\n    mapping(address =\\u003e mapping(uint256 =\\u003e bytes16)) public donatorReferenceEqnoxStakeId;\\r\\n\\r\\n    //donated busd by each user\\r\\n    mapping(address =\\u003e mapping(uint256 =\\u003e uint256)) public donatorBUSDPeriodDonations;\\r\\n\\r\\n    //donation power for each user\\r\\n    mapping(address =\\u003e mapping(uint256 =\\u003e uint256)) public donatorPowerPeriodDonations;\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Public function for user pledging for a stake duration for this auction day\\r\\n     */\\r\\n    function pledgeStakeDuration(uint256 duration) mod_opTrigger external {\\r\\n        require(CurrentAuctionDay \\u003e= 1, \\\"Too early\\\");\\r\\n        require(CurrentAuctionDay \\u003c= MAX_DONATION_PERIODS, \\\"Too late\\\");\\r\\n        require(duration \\u003e= MIN_AUCTION_STAKING_DAYS, \\\"Stake pledge below minimum\\\");\\r\\n        require(duration \\u003c= TOKEN_CONTRACT.MAX_STAKE_DURATION_IN_DAYS(), \\\"Stake pledge above maximum\\\");\\r\\n        require(canUserChangeBidPledgeOrEqnoxStake(), \\\"Stake pledge blocked until end of auction day\\\");\\r\\n\\r\\n        //update the donator staking pledge\\r\\n        donatorStakingPledge[msg.sender][CurrentAuctionDay] = duration;\\r\\n\\r\\n        //when pledge is updated, bid power has to be updated\\r\\n        updateUserDonationPower(msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Public function for user setting his best eqnox stake for this auction day\\r\\n     */\\r\\n    function setEqnoxStakeId() mod_opTrigger external {\\r\\n        require(CurrentAuctionDay \\u003e= 1, \\\"Too early\\\");\\r\\n        require(CurrentAuctionDay \\u003c= MAX_DONATION_PERIODS, \\\"Too late\\\");\\r\\n        require(canUserChangeBidPledgeOrEqnoxStake(), \\\"Setting EQNOX stake blocked until end of auction day\\\");\\r\\n\\r\\n        bytes16 eqnoxStakeId = EQNOX_UTILS_CONTRACT.userBestEqnoxStake(msg.sender);\\r\\n        (bool isStakeValid, string memory message) = EQNOX_UTILS_CONTRACT.isEqnoxStakeValid(msg.sender, eqnoxStakeId);\\r\\n        require(isStakeValid, message);\\r\\n\\r\\n        //update the donator eqnox stake id\\r\\n        donatorReferenceEqnoxStakeId[msg.sender][CurrentAuctionDay] = eqnoxStakeId;\\r\\n\\r\\n        //when eqnoxStakeId is updated, bid power has to be updated\\r\\n        updateUserDonationPower(msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to update a user donation power\\r\\n     */\\r\\n    function updateUserDonationPower(address account) internal {\\r\\n\\r\\n        //fetch user donation\\r\\n        uint256 userBusdDonation = donatorBUSDPeriodDonations[account][CurrentAuctionDay];\\r\\n\\r\\n        //fetch user current bid power\\r\\n        uint256 userCurrentBidPower = donatorPowerPeriodDonations[account][CurrentAuctionDay];\\r\\n\\r\\n        //deduct user bid power from total bid power for the day\\r\\n        periodPowerDonations[CurrentAuctionDay] = periodPowerDonations[CurrentAuctionDay].sub(userCurrentBidPower);\\r\\n\\r\\n        //calc user new bid power\\r\\n        //users settings configurable for the auction day for the first 22h of the auction day\\r\\n        uint256 stakePledgePower = calcStakePledgePower(userBusdDonation, donatorStakingPledge[account][CurrentAuctionDay]);\\r\\n        uint256 eqnoxStakePower = calcEqnoxStakePower(userBusdDonation, account, donatorReferenceEqnoxStakeId[account][CurrentAuctionDay]);\\r\\n\\r\\n        //update user current bid power\\r\\n        donatorPowerPeriodDonations[account][CurrentAuctionDay] = userBusdDonation.add(stakePledgePower).add(eqnoxStakePower);\\r\\n\\r\\n        //update total bid power for the day\\r\\n        periodPowerDonations[CurrentAuctionDay] = periodPowerDonations[CurrentAuctionDay].add(donatorPowerPeriodDonations[account][CurrentAuctionDay]);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Public function to calculate a stake pledge power\\r\\n     */\\r\\n    function calcStakePledgePower(uint256 bidAmount, uint256 duration) public view returns (uint256) {\\r\\n        //fetch the max stake duration\\r\\n        uint256 maxStakeDuration = TOKEN_CONTRACT.MAX_STAKE_DURATION_IN_DAYS();\\r\\n        //if the duration is less than the minimum return 0\\r\\n        if(duration \\u003c MIN_AUCTION_STAKING_DAYS) return 0;\\r\\n        //if the duration is higher than the maximum, limit it to the maximum\\r\\n        if(duration \\u003e maxStakeDuration) duration = maxStakeDuration;\\r\\n        \\r\\n        //pledgePower = bidAmount * maxBoost * duration/maxDuration\\r\\n        return bidAmount.mul(STAKE_PLEDGE_MAX_BOOST).mul(duration).div(maxStakeDuration);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Public function to calculate a eqnox stake power\\r\\n     */\\r\\n    function calcEqnoxStakePower(uint256 bidAmount, address account, bytes16 stakeId) public view returns(uint256) {\\r\\n        (bool isStakeValid, ) = EQNOX_UTILS_CONTRACT.isEqnoxStakeValid(account, stakeId);\\r\\n        //if stake isn\\u0027t valid return 0\\r\\n        if(!isStakeValid) return 0;\\r\\n\\r\\n        //fetch the stake\\r\\n        EqnoxStake memory stake = EQNOX_CONTRACT.stakes(account, stakeId);\\r\\n\\r\\n        //fetch the total shares\\r\\n        uint256 totalSharesAccounting = EQNOX_CONTRACT.SharesAccounting();\\r\\n\\r\\n        //calculate how much is 1% of all shares\\r\\n        uint256 sharesAccounting = totalSharesAccounting.mul(EQNOX_STAKE_SHARE_BOOST_NUM).div(EQNOX_STAKE_SHARE_BOOST_DEN);\\r\\n\\r\\n        //if the number of shares is above 1% limit it to 1%\\r\\n        uint256 stakeShares = stake.shares \\u003e= sharesAccounting ? sharesAccounting : stake.shares;\\r\\n\\r\\n        //stakePower = bidAmount * maxBoox * stakeShares/1%OfSharesAccounting\\r\\n        return bidAmount.mul(EQNOX_STAKE_MAX_BOOST).mul(stakeShares).div(sharesAccounting);\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Public function to donate BNB. Donation is immediately converted to BUSD\\r\\n     */\\r\\n    function donateBNB() payable mod_lock mod_opTrigger external {\\r\\n\\r\\n        uint256 busdBalanceBeforeSwap = BUSD_CONTRACT.balanceOf(address(this));\\r\\n        //doesn\\u0027t need to account for taxes because the auctions contract is excluded\\r\\n        uint256 minOutputBusdAmount = ATLAS_POOL_MGMT.calcOutputAmountSwapWETHtoBusd(msg.value, ATLAS_POOL_MGMT.TRADE_TAX());\\r\\n\\r\\n        pool.swapEthForTokens(msg.value, minOutputBusdAmount, address(this), IUniswapV2Router02(UNISWAP_ROUTER).WETH(), address(BUSD_CONTRACT), UNISWAP_ROUTER, block.timestamp + 10000);\\r\\n        uint256 busdBalanceAfterSwap = BUSD_CONTRACT.balanceOf(address(this));\\r\\n\\r\\n        //run internally the converted BUSD after the swap\\r\\n        donateBUSDInternal(msg.sender, busdBalanceAfterSwap.sub(busdBalanceBeforeSwap));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Public function to donate BUSD\\r\\n     */\\r\\n    function donateBUSD(uint256 amountToDonateBusd) mod_opTrigger external {\\r\\n        \\r\\n        require(BUSD_CONTRACT.balanceOf(msg.sender) \\u003e= amountToDonateBusd, \\\"Account does not have enough BUSD\\\");\\r\\n        require(BUSD_CONTRACT.allowance(msg.sender, address(this)) \\u003e= amountToDonateBusd, \\\"Not enough BUSD allowed\\\");\\r\\n        require(BUSD_CONTRACT.transferFrom(msg.sender, address(this), amountToDonateBusd), \\\"Unable to transfer required BUSD\\\");\\r\\n\\r\\n        donateBUSDInternal(msg.sender, amountToDonateBusd);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev External function to donate BUSD for an auction period. Users can donate BUSD multiple times and as such get a greater stake of ATLAS to distribute.\\r\\n     */\\r\\n    function donateBUSDInternal(address account, uint256 amountToDonateBUSD) private {\\r\\n        \\r\\n        require(amountToDonateBUSD \\u003e= MIN_DONATE, \\\"Donation below minimum\\\");\\r\\n        require(CurrentAuctionDay \\u003e= 1, \\\"Too early\\\");\\r\\n        require(CurrentAuctionDay \\u003c= MAX_DONATION_PERIODS, \\\"Too late\\\");\\r\\n\\r\\n        TOKEN_CONTRACT.updatePoolDepthAndAvgs();\\r\\n\\r\\n        //if the donator hasn\\u0027t donated for this period, register it and increase the periods donation count\\r\\n        if (donatorBUSDPeriodDonations[account][CurrentAuctionDay] == 0) {\\r\\n            //if this is a new donator check if he has surpassed the maximum number of donators for the period\\r\\n            require(donatorAccountCount[CurrentAuctionDay] \\u003c MAX_NUM_PARTICIPANTS, \\\"Maximum number of auction participants reached for this period\\\");\\r\\n\\r\\n            donatorAccounts[CurrentAuctionDay][donatorAccountCount[CurrentAuctionDay]] = account;\\r\\n            donatorAccountCount[CurrentAuctionDay]++;\\r\\n        }\\r\\n        \\r\\n        _processDonatedBUSD(account, CurrentAuctionDay, amountToDonateBUSD);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Private function to process the donated BUSD.\\r\\n     */\\r\\n    function _processDonatedBUSD(address sender, uint256 auctionPeriod, uint256 amountToDonateBUSD) private {\\r\\n        \\r\\n        \\r\\n        for(uint256 i = 0; i \\u003c MADDRESS_CONTRACT.mAddressesLength(); i++) {\\r\\n            BUSD_CONTRACT.transfer(MADDRESS_CONTRACT.mAddresses(i).account,\\r\\n                amountToDonateBUSD.mul(MADDRESS_CONTRACT.mAddresses(i).num).div(MADDRESS_CONTRACT.mAddresses(i).den).div(MKT_DEN));\\r\\n        }\\r\\n\\r\\n        //45% for pool and buybacks\\r\\n        //Modulate the amounts according to the price impact\\r\\n        uint256 amountInForCalculation = amountToDonateBUSD.mul(POOL_AND_BUYBACK_NUM).div(POOL_AND_BUYBACK_DEN);\\r\\n        (uint256 poolAmount, uint256 buybackAmount) = ATLAS_POOL_MGMT.calcPoolAndBuybackAmounts(amountInForCalculation);\\r\\n        \\r\\n        uint256 amountToBuyFromPool = 0;\\r\\n\\r\\n        //if for some exceptional reason the amounts have overflown, default to pushing everything to the pool mgmt\\r\\n        if(poolAmount.add(buybackAmount) \\u003e amountInForCalculation) {\\r\\n            BUSDForPoolAccounting = BUSDForPoolAccounting.add(amountInForCalculation);\\r\\n        }\\r\\n        //otherwise, distribute the amounts for the pool accounting and for buyback\\r\\n        else {\\r\\n            BUSDForPoolAccounting = BUSDForPoolAccounting.add(poolAmount);\\r\\n            amountToBuyFromPool = buybackAmount;\\r\\n        }\\r\\n\\r\\n        //if there is an amount to buyback\\r\\n        if(amountToBuyFromPool \\u003e 0) {\\r\\n\\r\\n            //trading is disabled during the first days. Check if it is, and enable it if it is disabled\\r\\n            bool isTradingActive = TOKEN_CONTRACT.IS_TRADING_ACTIVE();\\r\\n            if(!isTradingActive) TOKEN_CONTRACT.setIsTradingActive(true);\\r\\n\\r\\n            //register the token balance before the swap\\r\\n            uint256 tokenBalanceBeforeTrade = TOKEN_CONTRACT.balanceOf(address(this));\\r\\n            //register the busd balance before the swap\\r\\n            uint256 busdBalanceBeforeTrade = BUSD_CONTRACT.balanceOf(address(this));\\r\\n            BUSD_CONTRACT.approve(UNISWAP_ROUTER, amountToBuyFromPool);\\r\\n\\r\\n            address[] memory path = new address[](2);\\r\\n            path[0] = address(BUSD_CONTRACT);\\r\\n            path[1] = address(TOKEN_CONTRACT);\\r\\n\\r\\n            uint256 minOutputAtlasAmount = ATLAS_POOL_MGMT.calcOutputAmountSwapBusdToAtlas(amountToBuyFromPool, ATLAS_POOL_MGMT.TRADE_TAX());\\r\\n            try IUniswapV2Router02(UNISWAP_ROUTER).swapExactTokensForTokens(\\r\\n                amountToBuyFromPool,\\r\\n                minOutputAtlasAmount,\\r\\n                path,\\r\\n                address(this),\\r\\n                block.timestamp + 10000\\r\\n            ) \\r\\n            //if the transaction worked\\r\\n            {\\r\\n                //register the token balance after the swap\\r\\n                uint256 tokenBalanceAfterTrade = TOKEN_CONTRACT.balanceOf(address(this));\\r\\n\\r\\n                //register the busd balance after the swap\\r\\n                uint256 busdBalanceAfterTrade = BUSD_CONTRACT.balanceOf(address(this));\\r\\n\\r\\n                //check the actual busd swapped (before minus after)\\r\\n                uint256 actualBusdUsedInSwap = busdBalanceBeforeTrade.sub(busdBalanceAfterTrade);\\r\\n\\r\\n                //check if the amount swapped was less than what was planned\\r\\n                uint256 busdLeftOffs = amountToBuyFromPool.sub(actualBusdUsedInSwap);\\r\\n\\r\\n                //add the left over to the pool accounting\\r\\n                BUSDForPoolAccounting = BUSDForPoolAccounting.add(busdLeftOffs);\\r\\n\\r\\n                //increase the total amount of busd used for buybacks\\r\\n                TotalBUSDUsedForBuybacks = TotalBUSDUsedForBuybacks.add(actualBusdUsedInSwap);\\r\\n                \\r\\n                //Burn the extra supply from the trade\\r\\n                TOKEN_CONTRACT.burnSupply(tokenBalanceAfterTrade.sub(tokenBalanceBeforeTrade));\\r\\n\\r\\n                //increase the total atlas burned from buybacks\\r\\n                TotalAtlasBurnedFromBuybacks = TotalAtlasBurnedFromBuybacks.add(tokenBalanceAfterTrade.sub(tokenBalanceBeforeTrade));\\r\\n            }\\r\\n            //otherwise, if the trade didn\\u0027t go through\\r\\n            catch {\\r\\n                //default the trading amount to the pool mgmt\\r\\n                BUSDForPoolAccounting = BUSDForPoolAccounting.add(amountToBuyFromPool);\\r\\n            }\\r\\n\\r\\n            //if trading was closed, close it again\\r\\n            if(!isTradingActive) TOKEN_CONTRACT.setIsTradingActive(false);\\r\\n        }\\r\\n\\r\\n        //update the balance of the donator for this period\\r\\n        //bid amount is reduced linearly in 25% during the last auction hour\\r\\n        uint256 modulatedAmountToDonateBusd = calculateBidPowerNetWithModulation(amountToDonateBUSD);\\r\\n        //modulated bid amount is added to the total donated from the user that day\\r\\n        //full amount is considered for everything else, since the full amount was what was received\\r\\n        donatorBUSDPeriodDonations[sender][auctionPeriod] = donatorBUSDPeriodDonations[sender][auctionPeriod].add(modulatedAmountToDonateBusd);\\r\\n\\r\\n        //if the donator has never donated or has had his BPD reset, add him to the list of donators\\r\\n        if(donatorBUSDBpdDonations[sender] == 0) donatorsList.push(sender);\\r\\n\\r\\n        //update the total BUSD the donator has ever donated\\r\\n        donatorBUSDBpdDonations[sender] = donatorBUSDBpdDonations[sender].add(amountToDonateBUSD);\\r\\n\\r\\n        //update the balance of total donated for this period\\r\\n        periodBUSDDonations[auctionPeriod] = periodBUSDDonations[auctionPeriod].add(amountToDonateBUSD);\\r\\n\\r\\n        //update the users bid power\\r\\n        updateUserDonationPower(sender);\\r\\n\\r\\n        //update the ratio to go to dividends 40%\\r\\n        BUSDForDividendsAccounting = BUSDForDividendsAccounting.add(amountToDonateBUSD.mul(DIVIDENDS_NUMERATOR).div(DIVIDENDS_DENOMINATOR));\\r\\n        TotalBUSDReceivedForDividends = TotalBUSDReceivedForDividends.add(amountToDonateBUSD.mul(DIVIDENDS_NUMERATOR).div(DIVIDENDS_DENOMINATOR));\\r\\n\\r\\n        //update the total of BUSD ever sent to auction\\r\\n        TotalBUSDSentToAuctions = TotalBUSDSentToAuctions.add(amountToDonateBUSD);\\r\\n\\r\\n        //update the ratio to go to BPDs 5%\\r\\n        BUSDForBPDAccounting = BUSDForBPDAccounting.add(amountToDonateBUSD.mul(BPD_NUMERATOR).div(BPD_DENOMINATOR));\\r\\n        TotalBUSDReceivedForBPDs = TotalBUSDReceivedForBPDs.add(amountToDonateBUSD.mul(BPD_NUMERATOR).div(BPD_DENOMINATOR));\\r\\n\\r\\n        //transfer accumulated pool funds to the pool mgmt contract\\r\\n        _transferPoolFundsToPoolMgmtContract();\\r\\n\\r\\n        emit donationReceived(CurrentAuctionDay, sender, amountToDonateBUSD);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev External function to read how many ATLAS a user can claim as a stake\\r\\n     */\\r\\n    function claimableTokensFromAuctions(address account) external view returns (uint256) {\\r\\n        if (CurrentAuctionDay \\u003c 2) return 0;\\r\\n\\r\\n        uint256 claimUntilDate = CurrentAuctionDay \\u003e MAX_DONATION_PERIODS ? MAX_DONATION_PERIODS : CurrentAuctionDay - 1;\\r\\n\\r\\n        uint256 payout = 0;\\r\\n\\r\\n       //can claim tokens for auctions that happened from day 2 to MA \\r\\n        for(uint256 auctionDay = 1; auctionDay \\u003c= claimUntilDate; auctionDay++) {\\r\\n            if(hasDonatorClaimedTokensFromAuctions[account][auctionDay]) continue;\\r\\n            //payout += supply * userPowerDonation/totalPowerDonation\\r\\n            payout += donatorPowerPeriodDonations[account][auctionDay].mul(periodRatio[auctionDay].numerator).div(periodRatio[auctionDay].denominator);\\r\\n        }\\r\\n\\r\\n        return payout;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev External function to read how many ATLAS a user can claim\\r\\n     */\\r\\n    function claimableTokensFromAuctionDay(address account, uint256 auctionDay) external view returns (uint256) {\\r\\n        uint256 payout = 0;\\r\\n        if(hasDonatorClaimedTokensFromAuctions[account][auctionDay]) return 0;\\r\\n        //payout = supply * userPowerDonation/totalPowerDonation\\r\\n        payout = donatorPowerPeriodDonations[account][auctionDay].mul(periodRatio[auctionDay].numerator).div(periodRatio[auctionDay].denominator);\\r\\n        return payout;\\r\\n    }\\r\\n\\r\\n    function stakeTokensFromAuctions(uint256 auctionDay, uint256 stakeDays) mod_opTrigger external {\\r\\n        //user can only stake after auction day 1\\r\\n        require(CurrentAuctionDay \\u003e 1, \\\"Too early.\\\");\\r\\n        //stake time must be higher than minimum staking days \\r\\n        require(stakeDays \\u003e= MIN_AUCTION_STAKING_DAYS, \\\"Stake must have at least 90 days or more\\\");\\r\\n        //user can stake results starting from auction day 1\\r\\n        require(auctionDay \\u003e= 1, \\\"Auction day invalid\\\");\\r\\n        //user can stake up to last auction day\\r\\n        require(auctionDay \\u003c= MAX_DONATION_PERIODS, \\\"Auction day invalid\\\");\\r\\n        //user can stake up until the current auction day (non including)\\r\\n        require(auctionDay \\u003c CurrentAuctionDay, \\\"Auction day invalid\\\");\\r\\n        //check if the user has already staked\\r\\n        require(!hasDonatorClaimedTokensFromAuctions[msg.sender][auctionDay], \\\"Auction day already claimed\\\");\\r\\n\\r\\n        //mark the day as claimed\\r\\n        hasDonatorClaimedTokensFromAuctions[msg.sender][auctionDay] = true;\\r\\n        //payout = supply * userPowerDonation/totalPowerDonation\\r\\n        uint256 payout = donatorPowerPeriodDonations[msg.sender][auctionDay].mul(periodRatio[auctionDay].numerator).div(periodRatio[auctionDay].denominator);\\r\\n\\r\\n        //if there are tokens to claim\\r\\n        if (payout \\u003e 0) {\\r\\n\\r\\n            //register how much the user claimed for that auction day\\r\\n            donatorClaimedTokensFromDonations[msg.sender][auctionDay] = payout;\\r\\n            //register the total amount the user has ever claimed\\r\\n            donatorTotalClaimedTokens[msg.sender] = donatorTotalClaimedTokens[msg.sender].add(payout);\\r\\n            //register the amount in total all users have claimed\\r\\n            TotalTokensClaimedFromDonations = TotalTokensClaimedFromDonations.add(payout);\\r\\n\\r\\n            //mint the supply into this contract\\r\\n            TOKEN_CONTRACT.mintSupply(msg.sender, payout);\\r\\n\\r\\n            //if there is a staking pledge, enforce its minimum\\r\\n            stakeDays = stakeDays \\u003c donatorStakingPledge[msg.sender][auctionDay] ? donatorStakingPledge[msg.sender][auctionDay] : stakeDays; \\r\\n\\r\\n            //create the stake for the user\\r\\n            TOKEN_CONTRACT.createAuctionStake(msg.sender, payout, stakeDays);\\r\\n\\r\\n            emit tokensClaimed(CurrentAuctionDay, payout, msg.sender);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev External function to provide pagination of auction days.\\r\\n     */\\r\\n    function auctionsPagination(address account, uint256 offset, uint256 length) public view returns (AuctionResult[] memory auctions) {\\r\\n        //if offset has exceeded the available elements return an empty array\\r\\n        if(offset \\u003e CurrentAuctionDay - 1) {\\r\\n            auctions = new AuctionResult[](0);\\r\\n            return auctions;\\r\\n        }\\r\\n        \\r\\n        if(offset + length \\u003e CurrentAuctionDay - 1) {\\r\\n            length = (CurrentAuctionDay - 1) - offset;\\r\\n        }\\r\\n        \\r\\n        auctions = new AuctionResult[](length);\\r\\n        \\r\\n        uint256 end = offset + length;\\r\\n        \\r\\n        for(uint256 i = 0; offset \\u003c end; offset++) {\\r\\n            \\r\\n            auctions[i].auctionDay = offset+1;\\r\\n            auctions[i].totalDonatedBusd = periodBUSDDonations[offset+1];\\r\\n            auctions[i].totalBidPower = periodPowerDonations[offset+1];\\r\\n            auctions[i].donatedBusdByUser = donatorBUSDPeriodDonations[account][offset+1];\\r\\n            auctions[i].bidPowerByUser = donatorPowerPeriodDonations[account][offset+1];\\r\\n            auctions[i].numberOfParticipants = donatorAccountCount[offset+1];\\r\\n            \\r\\n            i++;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IContractsManager {\\r\\n    function find(string memory contractName) external view returns (address, bool);\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Main auctions contract\\r\\n */\\r\\ncontract AtlasAuctions is DonationMgmt {\\r\\n\\r\\n    function setContracts(address contractsManager) external mod_onlyContractDefiner {\\r\\n\\r\\n        //Atlas contract\\r\\n        (address ctr, bool found) = IContractsManager(contractsManager).find(\\\"TOKEN_CONTRACT\\\");\\r\\n        require(found, \\\"Contract not found\\\");\\r\\n        TOKEN_CONTRACT = IAtlasToken(ctr);\\r\\n\\r\\n        //MAddress contract\\r\\n        (ctr, found) = IContractsManager(contractsManager).find(\\\"MADDRESS_CONTRACT\\\");\\r\\n        require(found, \\\"Contract not found\\\");\\r\\n        MADDRESS_CONTRACT = IAtlasMAddressMgmt(ctr);\\r\\n\\r\\n        //Eqnox contract\\r\\n        (ctr, found) = IContractsManager(contractsManager).find(\\\"EQNOX_CONTRACT\\\");\\r\\n        require(found, \\\"Contract not found\\\");\\r\\n        EQNOX_CONTRACT = IEqnoxToken(ctr);\\r\\n\\r\\n        //Atlas Pool Mgmt\\r\\n        (ctr, found) = IContractsManager(contractsManager).find(\\\"ATLAS_POOL_MGMT\\\");\\r\\n        require(found, \\\"Contract not found\\\");\\r\\n        ATLAS_POOL_MGMT = IAtlasPoolMgmt(ctr);\\r\\n\\r\\n        //Eqnox Utils contract\\r\\n        (ctr, found) = IContractsManager(contractsManager).find(\\\"EQNOX_UTILS_CONTRACT\\\");\\r\\n        require(found, \\\"Contract not found\\\");\\r\\n        EQNOX_UTILS_CONTRACT = IEqnoxUtils(ctr);\\r\\n\\r\\n        //Uniswap Router\\r\\n        (ctr, found) = IContractsManager(contractsManager).find(\\\"UNISWAP_ROUTER\\\");\\r\\n        require(found, \\\"Contract not found\\\");\\r\\n        UNISWAP_ROUTER = ctr;\\r\\n\\r\\n        //Busd contract\\r\\n        (ctr, found) = IContractsManager(contractsManager).find(\\\"BUSD_CONTRACT\\\");\\r\\n        require(found, \\\"Contract not found\\\");\\r\\n        BUSD_CONTRACT = IERC20(ctr);\\r\\n    }\\r\\n\\r\\n\\r\\n    constructor() {\\r\\n        CONTRACT_DEFINER = msg.sender;\\r\\n        BID_MANAGER = msg.sender;\\r\\n    }\\r\\n}\\r\\n\"},\"pool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.10;\\r\\n\\r\\ninterface IPoolToken {\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n\\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Pair {\\r\\n    function token0() external view returns (address);\\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Router02 {\\r\\n    function factory() external pure returns (address);\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint256 amountADesired,\\r\\n        uint256 amountBDesired,\\r\\n        uint256 amountAMin,\\r\\n        uint256 amountBMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    )\\r\\n        external\\r\\n        returns (\\r\\n            uint256 amountA,\\r\\n            uint256 amountB,\\r\\n            uint256 liquidity\\r\\n        );\\r\\n\\r\\n    function removeLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint256 liquidity,\\r\\n        uint256 amountAMin,\\r\\n        uint256 amountBMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256 amountA, uint256 amountB);\\r\\n\\r\\n    function swapExactTokensForTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external returns (uint256[] memory amounts);\\r\\n\\r\\n    function swapExactETHForTokens(\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external payable returns (uint256[] memory amounts);\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external;\\r\\n\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external payable;\\r\\n}\\r\\n\\r\\nlibrary pool {\\r\\n\\r\\n    function getPairWithWETH(address router, address tokenAddress) internal view returns (address pair) {\\r\\n        IUniswapV2Factory factory = IUniswapV2Factory((IUniswapV2Router02(router)).factory());\\r\\n        return factory.getPair(IUniswapV2Router02(router).WETH(), tokenAddress);\\r\\n    }\\r\\n\\r\\n    function getPair(address router, address tokenAddress, address otherTokenAddress) internal view returns (address pair) {\\r\\n        return\\r\\n            IUniswapV2Factory((IUniswapV2Router02(router)).factory()).getPair(\\r\\n                tokenAddress,\\r\\n                otherTokenAddress\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function hasPoolBeenCreated(\\r\\n        address router,\\r\\n        address tokenAddress,\\r\\n        address otherTokenAddress\\r\\n    ) internal view returns (bool) {\\r\\n        return\\r\\n            IUniswapV2Factory((IUniswapV2Router02(router)).factory()).getPair(\\r\\n                tokenAddress,\\r\\n                otherTokenAddress\\r\\n            ) != address(0x0);\\r\\n    }\\r\\n\\r\\n    function createPool(\\r\\n        address router,\\r\\n        address tokenAddress,\\r\\n        address otherTokenAddress\\r\\n    ) internal returns (address) {\\r\\n        return\\r\\n            IUniswapV2Factory((IUniswapV2Router02(router)).factory())\\r\\n                .createPair(tokenAddress, otherTokenAddress);\\r\\n    }\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenAddress,\\r\\n        address otherTokenAddress,\\r\\n        address lpTokensReceiver,\\r\\n        address router,\\r\\n        uint256 tokenAmount,\\r\\n        uint256 otherTokenAmount,\\r\\n        uint256 deadline\\r\\n    ) internal {\\r\\n        IPoolToken(tokenAddress).approve(router, tokenAmount);\\r\\n        IPoolToken(otherTokenAddress).approve(router, otherTokenAmount);\\r\\n\\r\\n        IUniswapV2Router02(router).addLiquidity(\\r\\n            tokenAddress,\\r\\n            otherTokenAddress,\\r\\n            tokenAmount,\\r\\n            otherTokenAmount,\\r\\n            0,\\r\\n            0,\\r\\n            lpTokensReceiver,\\r\\n            deadline\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function removeLiquidity(\\r\\n        address tokenAddress,\\r\\n        address otherTokenAddress,\\r\\n        address liquidityReceiver,\\r\\n        address router,\\r\\n        address pair,\\r\\n        uint256 lpTokens,\\r\\n        uint256 deadline\\r\\n    ) internal {\\r\\n        IUniswapV2Pair(pair).approve(router, lpTokens);\\r\\n\\r\\n        IUniswapV2Router02(router).removeLiquidity(\\r\\n            tokenAddress,\\r\\n            otherTokenAddress,\\r\\n            lpTokens,\\r\\n            0,\\r\\n            0,\\r\\n            liquidityReceiver,\\r\\n            deadline\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function swapTokens(\\r\\n        address receiver,\\r\\n        uint256 tokenAmount,\\r\\n        uint256 outputMinAmount,\\r\\n        address originTokenAddress,\\r\\n        address destinationTokenAddress,\\r\\n        address router,\\r\\n        uint256 deadline\\r\\n    ) internal {\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = originTokenAddress;\\r\\n        path[1] = destinationTokenAddress;\\r\\n\\r\\n        IUniswapV2Router02(router).swapExactTokensForTokens(\\r\\n            tokenAmount,\\r\\n            outputMinAmount,\\r\\n            path,\\r\\n            receiver,\\r\\n            deadline\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        address receiver,\\r\\n        uint256 tokenAmount,\\r\\n        address originTokenAddress,\\r\\n        address destinationTokenAddress,\\r\\n        address router,\\r\\n        uint256 deadline\\r\\n    ) internal {\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = originTokenAddress;\\r\\n        path[1] = destinationTokenAddress;\\r\\n\\r\\n        IUniswapV2Router02(router).swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n            tokenAmount,\\r\\n            0,\\r\\n            path,\\r\\n            receiver,\\r\\n            deadline\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function swapEthForTokens(\\r\\n        uint256 MESSAGE_VALUE,\\r\\n        uint256 outputMinAmount,\\r\\n        address receiver,\\r\\n        address originAddress,\\r\\n        address destinationAddress,\\r\\n        address router,\\r\\n        uint256 deadline\\r\\n    ) internal {\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = originAddress;\\r\\n        path[1] = destinationAddress;\\r\\n\\r\\n        IUniswapV2Router02(router).swapExactETHForTokens{value: MESSAGE_VALUE}(\\r\\n            outputMinAmount,\\r\\n            path,\\r\\n            receiver,\\r\\n            deadline\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function getPoolReserves(address tokenAddress, address pair)\\r\\n        internal\\r\\n        view\\r\\n        returns (uint256 tokenAmount, uint256 otherTokenAmount)\\r\\n    {\\r\\n        IUniswapV2Pair uniswapPair = IUniswapV2Pair(pair);\\r\\n        (uint256 reserveIn, uint256 reserveOut, ) = uniswapPair.getReserves(); // reserveIn SHOULD be TOKEN, may be BUSD\\r\\n\\r\\n        if (uniswapPair.token0() == tokenAddress) {\\r\\n            tokenAmount = reserveIn;\\r\\n            otherTokenAmount = reserveOut;\\r\\n        } else {\\r\\n            tokenAmount = reserveOut;\\r\\n            otherTokenAmount = reserveIn;\\r\\n        }\\r\\n\\r\\n        return (tokenAmount, otherTokenAmount);\\r\\n    }\\r\\n}\\r\\n\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionDay\",\"type\":\"uint256\"}],\"name\":\"auctionPeriodUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionDay\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amountClaimed\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimedBy\",\"type\":\"address\"}],\"name\":\"bpdClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionDay\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amountClaimed\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimedBy\",\"type\":\"address\"}],\"name\":\"dividendsClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenDay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"donatorAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountDonated\",\"type\":\"uint256\"}],\"name\":\"donationReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionDay\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"poolContractFunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenDay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"claimerAddress\",\"type\":\"address\"}],\"name\":\"tokensClaimed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ATLAS_POOL_MGMT\",\"outputs\":[{\"internalType\":\"contract IAtlasPoolMgmt\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BID_MANAGER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BPD_DENOMINATOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BPD_NUMERATOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BUSDForBPDAccounting\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BUSDForDividendsAccounting\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BUSDForPoolAccounting\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BUSD_CONTRACT\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CONTRACT_DEFINER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CurrentAuctionDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DIVIDENDS_DENOMINATOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DIVIDENDS_NUMERATOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EQNOX_CONTRACT\",\"outputs\":[{\"internalType\":\"contract IEqnoxToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EQNOX_STAKE_MAX_BOOST\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EQNOX_STAKE_SHARE_BOOST_DEN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EQNOX_STAKE_SHARE_BOOST_NUM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EQNOX_UTILS_CONTRACT\",\"outputs\":[{\"internalType\":\"contract IEqnoxUtils\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LAST_DIVIDEND_DAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MADDRESS_CONTRACT\",\"outputs\":[{\"internalType\":\"contract IAtlasMAddressMgmt\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_DONATION_PERIODS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_NUMBER_BPD_STEPS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_NUM_PARTICIPANTS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_AUCTION_STAKING_DAYS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_DONATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MKT_DEN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERIOD_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"POOL_AND_BUYBACK_DEN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"POOL_AND_BUYBACK_NUM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STAKE_PLEDGE_MAX_BOOST\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN_CONTRACT\",\"outputs\":[{\"internalType\":\"contract IAtlasToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TotalAtlasBurnedFromBuybacks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TotalBPDsAwardedCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TotalBPDsClaimedCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TotalBUSDClaimedFromBPDs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TotalBUSDClaimedFromDividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TotalBUSDReceivedForBPDs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TotalBUSDReceivedForDividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TotalBUSDSentToAuctions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TotalBUSDSentToBPDs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TotalBUSDSentToPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TotalBUSDUsedForBuybacks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TotalTokensClaimedFromDonations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNISWAP_ROUTER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"auctionsPagination\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"auctionDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDonatedBusd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBidPower\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"donatedBusdByUser\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidPowerByUser\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numberOfParticipants\",\"type\":\"uint256\"}],\"internalType\":\"struct Data.AuctionResult[]\",\"name\":\"auctions\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"calcDividendsForPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bidAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"stakeId\",\"type\":\"bytes16\"}],\"name\":\"calcEqnoxStakePower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bidAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"calcStakePledgePower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"calculateBidPowerNetWithModulation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cuttOffComplementInHours\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAfterCutOff\",\"type\":\"uint256\"}],\"name\":\"calculateBidPowerReductionMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"den\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"canUserChangeBidPledgeOrEqnoxStake\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"currentTokenDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"contractStartTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nowTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numHours\",\"type\":\"uint256\"}],\"name\":\"checkAmountSecondsAfterCutOff\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimBusdFromBPDs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endPeriod\",\"type\":\"uint256\"}],\"name\":\"claimDividendsBetweenPeriods\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"claimDividendsForPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"claimableDividendsForPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"auctionDay\",\"type\":\"uint256\"}],\"name\":\"claimableTokensFromAuctionDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"claimableTokensFromAuctions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"donateBNB\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToDonateBusd\",\"type\":\"uint256\"}],\"name\":\"donateBUSD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"donatorAccountCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"donatorAccounts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"donatorBUSDBpdDonations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"donatorBUSDPeriodDonations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"donatorClaimableBUSDFromBPDs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"donatorClaimedBUSDFromBPDs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"donatorClaimedDividendsForPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"donatorClaimedTokensFromDonations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"donatorPowerPeriodDonations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"donatorReferenceEqnoxStakeId\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"donatorStakingPledge\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"donatorTotalBPDsClaimedCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"donatorTotalBusdDividendsClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"donatorTotalClaimedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"donatorsList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"hasDonatorClaimedTokensFromAuctions\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"haveDividendsBeenClaimedByAccountForPeriod\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"periodBUSDDonations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"periodPowerDonations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"periodRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"numerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"periodNumber\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"pledgeStakeDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractsManager\",\"type\":\"address\"}],\"name\":\"setContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setEqnoxStakeId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeDays\",\"type\":\"uint256\"}],\"name\":\"stakeTokensFromAuctions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalDividendsPerPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateDay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"}],\"name\":\"updateMinBidAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AtlasAuctions", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://57d66731b7cfda5d0179b43187bd9a063f928c7ac089b7056ec2a3da7a7162fc"}