{"SourceCode": "// SPDX-License-Identifier: Unlicensed\r\n\r\n/*\r\n\r\n\r\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\u2500\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2500\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2500\u2500\u2500\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2500\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2500\u2500\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2500\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2500\u2500\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2500\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2500\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2500\u2500\u2500\r\n\u2500\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2500\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2500\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2500\u2588\u2588\u2591\u2591\u2591\u2591\u2588\u2588\u2500\u2500\u2588\u2588\u2591\u2591\u2591\u2591\u2588\u2588\u2500\u2588\u2588\u2591\u2591\u2591\u2591\u2588\u2588\u2500\u2500\u2588\u2588\u2591\u2591\u2591\u2591\u2588\u2588\u2500\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2500\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2500\r\n\u2500\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2588\u2588\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2500\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2500\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2500\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2500\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2588\u2588\u2500\r\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2500\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2500\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2500\u2500\u2500\u2588\u2588\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2591\u2588\u2588\u2500\u2500\u2500\u2500\u2500\u2588\u2588\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2591\u2588\u2588\u2500\u2500\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2500\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2500\r\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2500\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2500\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2500\u2500\u2500\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2500\u2500\u2500\u2500\u2500\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2500\u2500\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2500\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2500\r\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2500\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2500\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2500\u2500\u2500\u2500\u2500\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2500\u2500\u2500\u2500\u2500\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2500\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2500\r\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2500\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2500\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2500\u2500\u2500\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2500\u2500\u2500\u2500\u2500\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2500\u2500\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2500\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2500\r\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2500\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2500\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2500\u2500\u2500\u2588\u2588\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2591\u2588\u2588\u2500\u2500\u2500\u2500\u2500\u2588\u2588\u2591\u2591\u2591\u2591\u2588\u2588\u2591\u2591\u2591\u2591\u2588\u2588\u2500\u2500\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2500\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2500\r\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2588\u2588\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2500\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2500\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2500\u2588\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2500\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2588\u2588\u2500\r\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2588\u2588\u2591\u2591\u2588\u2588\u2500\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2500\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2500\u2588\u2588\u2591\u2591\u2591\u2591\u2588\u2588\u2500\u2500\u2588\u2588\u2591\u2591\u2591\u2591\u2588\u2588\u2500\u2588\u2588\u2591\u2591\u2591\u2591\u2588\u2588\u2500\u2500\u2588\u2588\u2591\u2591\u2591\u2591\u2588\u2588\u2500\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2500\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2588\u2500\r\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2588\u2588\u2588\u2588\u2588\u2588\u2500\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2500\u2500\u2500\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2500\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2500\u2500\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2500\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2500\u2500\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2500\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2500\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2500\u2500\u2500\r\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\r\n\r\nWebsite: http://7doxxed.com\r\nTG: https://t.me/SEVENDOXXED\r\n\r\n\r\n*/\r\n\r\npragma solidity ^0.8.3;\r\n\r\ninterface IERC20 {\r\n    \r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    event TransferDetails(address indexed from, address indexed to, uint256 total_Amount, uint256 reflected_amount, uint256 total_TransferAmount, uint256 reflected_TransferAmount);\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\nlibrary Address {\r\n    \r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n    \r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n    \r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n    \r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n    \r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n    \r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n    \r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n    \r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                 assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    constructor () {\r\n        _owner = _msgSender();\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n    \r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n    function initialize(address, address) external;\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\n\r\n\r\n\r\n// Begin sauce.\r\ncontract SevenDoxxed is Context, IERC20, Ownable {\r\n    using Address for address;\r\n\r\n    mapping (address => uint256) public _balance_reflected;\r\n    mapping (address => uint256) public _balance_total;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n    mapping (address => bool) private _isExcludedFromFee;\r\n    mapping (address => bool) private _isExcluded;\r\n    \r\n    // bye bye bots\r\n    mapping (address => bool) public _isBlacklisted;\r\n    \r\n    // add liquidity and do airdrops\r\n    bool public tradingOpen = false;\r\n\r\n    // Cooldown & timer functionality\r\n    bool public buyCooldownEnabled = true;\r\n    uint8 public cooldownTimerInterval = 60;\r\n    mapping (address => uint) private cooldownTimer;\r\n    \r\n    address[] private _excluded;\r\n    \r\n    uint256 private constant MAX = ~uint256(0);\r\n\r\n    uint8 private   _decimals           = 9;\r\n    uint256 private _supply_total       = 7 * 10**9 * 10**_decimals;\r\n    uint256 private _supply_reflected   = (MAX - (MAX % _supply_total));\r\n    string private  _name               = \"7Doxxed Token\";\r\n    string private  _symbol             = \"7DOXX\";\r\n\r\n\r\n    // 0 to disable conversion\r\n    // an integer to convert only fixed number of tokens\r\n    uint256 public _fee_team_convert_limit = _supply_total * 1 / 10000;\r\n    uint256 public _fee_marketing_convert_limit = _supply_total * 1 / 10000;\r\n\r\n    // Minimum Balance to maintain\r\n    uint256 public _fee_team_min_bal = 0;\r\n    uint256 public _fee_marketing_min_bal = _supply_total * 1 / 100;\r\n    \r\n    //refection fee\r\n    uint256 public _fee_reflection = 200;\r\n    uint256 private _fee_reflection_old = _fee_reflection;\r\n    uint256 private _contractReflectionStored = 0;\r\n    \r\n    // marketing\r\n    uint256 public _fee_marketing = 100;\r\n    uint256 private _fee_marketing_old = _fee_marketing;\r\n    address payable public _wallet_marketing = payable(0x7FbCF90DF1947DEE956BCc6dC13189DBB719a6CE);\r\n\r\n    // for burn\r\n    uint256 public _fee_burn = 100;\r\n    uint256 private _fee_burn_old = _fee_burn;\r\n    address payable public _wallet_burn = payable(0xBdaBa4F5e7AA06103ff3d8ADc5e69903e28D81A3);\r\n\r\n    // for team\r\n    uint256 public _fee_team = 100;\r\n    uint256 private _fee_team_old = _fee_team;\r\n    address payable public _wallet_team = payable(0x10F1F1b22d3A83B9df800bb7e9c10fE09165Aeb1);\r\n\r\n    // Auto LP\r\n    uint256 public _fee_liquidity = 200;\r\n    uint256 private _fee_liquidity_old = _fee_liquidity;\r\n\r\n    uint256 public _fee_denominator = 10000;\r\n\r\n                                     \r\n    IUniswapV2Router02 public immutable uniswapV2Router;\r\n    address public immutable uniswapV2Pair;\r\n    bool inSwapAndLiquify;\r\n    bool public swapAndLiquifyEnabled = true;\r\n\r\n    uint256 public _maxWalletToken = ( _supply_total * 1 ) / 1000;\r\n    uint256 public _maxTxAmount =  ( _supply_total * 1 ) / 1000;\r\n\r\n    uint256 public _numTokensSellToAddToLiquidity =  ( _supply_total * 2 ) / 1000;\r\n\r\n    uint256 public sellMultiplier = 200;\r\n\r\n\r\n    event MinTokensBeforeSwapUpdated(uint256 minTokensBeforeSwap);\r\n    event SwapAndLiquifyEnabledUpdated(bool enabled);\r\n    event SwapAndLiquify(\r\n        uint256 tokensSwapped,\r\n        uint256 ethReceived,\r\n        uint256 tokensIntoLiqudity\r\n        \r\n    );\r\n\r\n    address PCSRouter = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\r\n    address deadAddress = 0x000000000000000000000000000000000000dEaD;\r\n    \r\n    modifier lockTheSwap {\r\n        inSwapAndLiquify = true;\r\n        _;\r\n        inSwapAndLiquify = false;\r\n    }\r\n    \r\n    constructor () {\r\n        _balance_reflected[owner()] = _supply_reflected;\r\n        \r\n        // Pancakeswap Router Initialization & Pair creation\r\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(PCSRouter);\r\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\r\n        uniswapV2Router = _uniswapV2Router;\r\n\r\n        _isExcludedFromFee[owner()] = true;\r\n        _isExcludedFromFee[address(this)] = true;\r\n        _isExcludedFromFee[deadAddress] = true;\r\n        _isExcludedFromFee[_wallet_marketing] = true;\r\n        _isExcludedFromFee[_wallet_burn] = true;\r\n        _isExcludedFromFee[_wallet_team] = true;\r\n       \r\n        emit Transfer(address(0), owner(), _supply_total);\r\n    }\r\n\r\n\r\n/*  CORE INTERFACE FUNCTION */\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _supply_total;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        if (_isExcluded[account]) return _balance_total[account];\r\n        return tokenFromReflection(_balance_reflected[account]);\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n\r\n        require (_allowances[sender][_msgSender()] >= amount,\"ERC20: transfer amount exceeds allowance\");\r\n        \r\n        _approve(sender, _msgSender(), (_allowances[sender][_msgSender()]-amount));\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, (_allowances[_msgSender()][spender] + addedValue));\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        require (_allowances[_msgSender()][spender] >= subtractedValue,\"ERC20: decreased allowance below zero\");\r\n\r\n        _approve(_msgSender(), spender, (_allowances[_msgSender()][spender] - subtractedValue));\r\n        return true;\r\n    }\r\n\r\n    function totalFees() public view returns (uint256) {\r\n        return _contractReflectionStored;\r\n    }\r\n\r\n    function isExcludedFromFee(address account) public view returns(bool) {\r\n        return _isExcludedFromFee[account];\r\n    }\r\n    \r\n\r\n    // Interface imported from GENx\r\n\r\n        function ___tokenInfo () public view returns(\r\n        uint8 Decimals,\r\n        uint256 MaxTxAmount,\r\n        uint256 MaxWalletToken,\r\n        uint256 TotalSupply,\r\n        uint256 Reflected_Supply,\r\n        uint256 Reflection_Rate,\r\n        bool TradingOpen,\r\n        bool Cooldown_timer_enabled,\r\n        uint8 Cooldown_timer_interval\r\n        ) {\r\n        return (_decimals, _maxTxAmount, _maxWalletToken, _supply_total, _supply_reflected, _getRate(), tradingOpen, buyCooldownEnabled, cooldownTimerInterval  );\r\n    }\r\n\r\n    function ___feesInfo () public view returns(\r\n        \r\n        uint256 NumTokensSellToAddToLiquidity,\r\n        uint256 contractTokenBalance,\r\n        uint256 Reflection_tokens_stored\r\n        ) {\r\n        return (_numTokensSellToAddToLiquidity, balanceOf(address(this)), _contractReflectionStored);\r\n    }\r\n\r\n    function ___wallets () public view returns(\r\n        uint256 Reflection_Fees,\r\n        uint256 Liquidity_Fee,\r\n        uint256 Team_Fee,\r\n        uint256 Team_Fee_Convert_Limit,\r\n        uint256 Team_Fee_Minimum_Balance,\r\n        uint256 Marketing_Fee,\r\n        uint256 Marketing_Fee_Convert_Limit,\r\n        uint256 Marketing_Fee_Minimum_Balance,\r\n        uint256 Burn_Fee,\r\n        address Team_Wallet_Address,\r\n        address Burn_Wallet_Address,\r\n        address Marketing_Wallet_Address\r\n        ) {\r\n        return ( _fee_reflection, _fee_liquidity,\r\n            _fee_team,_fee_team_convert_limit,_fee_team_min_bal,\r\n            _fee_marketing,_fee_marketing_convert_limit, _fee_marketing_min_bal,\r\n            _fee_burn,\r\n            _wallet_team, _wallet_burn, _wallet_marketing);\r\n    }\r\n\r\n/*  Wallet Management  */\r\n\r\n    function Change_Wallet_Marketing (address newWallet) external onlyOwner() {\r\n        _wallet_marketing = payable(newWallet);\r\n    }\r\n\r\n    function Change_Wallet_Team (address newWallet) external onlyOwner() {\r\n        _wallet_team = payable(newWallet);\r\n    }\r\n\r\n    function Change_Wallet_Burn (address newWallet) external onlyOwner() {\r\n        _wallet_burn = payable(newWallet);\r\n    }\r\n\r\n\r\n\r\n/* Interface Read & Write Functions --- Reflection Specific */\r\n\r\n    function deliver(uint256 tAmount) public {\r\n        address sender = _msgSender();\r\n        require(!_isExcluded[sender], \"Excluded addresses cannot call this function\");\r\n        (uint256 rAmount,,,,,,,,) = _getValues(tAmount,false);\r\n        _balance_reflected[sender] = _balance_reflected[sender] - rAmount;\r\n        _supply_reflected = _supply_reflected - rAmount;\r\n        _contractReflectionStored = _contractReflectionStored + tAmount;\r\n    }\r\n\r\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) {\r\n        require(tAmount <= _supply_total, \"Amount must be less than supply\");\r\n        if (!deductTransferFee) {\r\n            (uint256 rAmount,,,,,,,,) = _getValues(tAmount,false);\r\n            return rAmount;\r\n        } else {\r\n            (,uint256 rTransferAmount,,,,,,,) = _getValues(tAmount,false);\r\n            return rTransferAmount;\r\n        }\r\n    }\r\n\r\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\r\n        require(rAmount <= _supply_reflected, \"Amount must be less than total reflections\");\r\n        uint256 currentRate =  _getRate();\r\n        return (rAmount / currentRate);\r\n    }\r\n\r\n    function excludeFromReward(address account) public onlyOwner() {\r\n        // require(account != 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D, 'We can not exclude Uniswap router.');\r\n        require(!_isExcluded[account], \"Account is already excluded\");\r\n        if(_balance_reflected[account] > 0) {\r\n            _balance_total[account] = tokenFromReflection(_balance_reflected[account]);\r\n        }\r\n        _isExcluded[account] = true;\r\n        _excluded.push(account);\r\n    }\r\n\r\n    function includeInReward(address account) external onlyOwner() {\r\n        require(_isExcluded[account], \"Account is already included\");\r\n        for (uint256 i = 0; i < _excluded.length; i++) {\r\n            if (_excluded[i] == account) {\r\n                _excluded[i] = _excluded[_excluded.length - 1];\r\n                _balance_total[account] = 0;\r\n                _isExcluded[account] = false;\r\n                _excluded.pop();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function isExcludedFromReward(address account) public view returns (bool) {\r\n        return _isExcluded[account];\r\n    }\r\n\r\n\r\n\r\n\r\n/* Interface Read & Write Functions */\r\n\r\n\r\n\r\n\r\n    // switch Trading\r\n    function tradingStatus(bool _status) public onlyOwner {\r\n        tradingOpen = _status;\r\n    }\r\n\r\n    // enable cooldown between trades\r\n    function cooldownEnabled(bool _status, uint8 _interval) public onlyOwner {\r\n        buyCooldownEnabled = _status;\r\n        cooldownTimerInterval = _interval;\r\n    }\r\n\r\n    \r\n    //set the number of tokens required to activate auto-liquidity\r\n    function setNumTokensSellToAddToLiquidityt(uint256 numTokensSellToAddToLiquidity) external onlyOwner() {\r\n        _numTokensSellToAddToLiquidity = numTokensSellToAddToLiquidity;\r\n    }\r\n    \r\n    //set the Max transaction amount (percent of total supply)\r\n    function setMaxTxPercent(uint256 maxTxPercent) external onlyOwner() {\r\n        _maxTxAmount = (_supply_total * maxTxPercent ) / 100;\r\n    }\r\n    \r\n    //set the Max transaction amount (in tokens)\r\n     function setMaxTxTokens(uint256 maxTxTokens) external onlyOwner() {\r\n        _maxTxAmount = maxTxTokens;\r\n    }\r\n    \r\n    //settting the maximum permitted wallet holding (percent of total supply)\r\n     function setMaxWalletPercent(uint256 maxWallPercent) external onlyOwner() {\r\n        _maxWalletToken = (_supply_total * maxWallPercent ) / 100;\r\n    }\r\n    \r\n    //settting the maximum permitted wallet holding (in tokens)\r\n     function setMaxWalletTokens(uint256 maxWallTokens) external onlyOwner() {\r\n        _maxWalletToken = maxWallTokens;\r\n    }\r\n    \r\n    \r\n    \r\n    //toggle on and off to activate auto liquidity \r\n    function setSwapAndLiquifyEnabled(bool _status) public onlyOwner {\r\n        swapAndLiquifyEnabled = _status;\r\n        emit SwapAndLiquifyEnabledUpdated(_status);\r\n    }\r\n    \r\n\r\n/** All list management functions BEGIN*/\r\n\r\n    function s_manageExcludeFromFee(address[] calldata addresses, bool status) external onlyOwner {\r\n        for (uint256 i; i < addresses.length; ++i) {\r\n            _isExcludedFromFee[addresses[i]] = status;\r\n        }\r\n    }\r\n\r\n    function s_manageBlacklist(address[] calldata addresses, bool status) external onlyOwner {\r\n        for (uint256 i; i < addresses.length; ++i) {\r\n            _isBlacklisted[addresses[i]] = status;\r\n        }\r\n    }\r\n\r\n    function s_excludeFromFee(address[] calldata addresses, bool status) external onlyOwner {\r\n        for (uint256 i; i < addresses.length; ++i) {\r\n            _isExcludedFromFee[addresses[i]] = status;\r\n        }\r\n    }\r\n    \r\n\r\n    /** All list management functions END*/\r\n\r\n\r\n\r\n\r\n/* Airdrop Begins */\r\n\r\n// NOTE: need to manually supply high gas incase this list is > 100 addresses\r\n function makeItRain(address from, address[] calldata addresses, uint256[] calldata tokens) external onlyOwner {\r\n\r\n    uint256 showerCapacity = 0;\r\n    uint256 reflectRate = _getRate();\r\n    require(addresses.length == tokens.length,\"Mismatch between Address and token count\");\r\n\r\n\r\n    for(uint i=0; i < addresses.length; i++){\r\n        showerCapacity = showerCapacity + tokens[i];\r\n    }\r\n\r\n    require(balanceOf(msg.sender) >= showerCapacity, \"Not enough tokens to airdrop\");\r\n\r\n     // Update reflected Balance for sender\r\n    _balance_reflected[from]    = _balance_reflected[from]  - showerCapacity * reflectRate ;\r\n\r\n    // Only update actual balance of sender if he's excluded from rewards\r\n    if (_isExcluded[from]){\r\n        _balance_total[from]    = _balance_total[from]      - showerCapacity;\r\n    }\r\n\r\n    for(uint i=0; i < addresses.length; i++){\r\n        \r\n        // Only update actual balance of recipient if he's excluded from rewards\r\n        if (_isExcluded[addresses[i]]){\r\n            _balance_total[addresses[i]]      = _balance_total[addresses[i]]        + tokens[i]; \r\n        }\r\n\r\n        // update reflected balance of receipient\r\n        _balance_reflected[addresses[i]]      = _balance_reflected[addresses[i]]    + tokens[i] * reflectRate;\r\n\r\n        emit Transfer(from,addresses[i],tokens[i]);\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n// Liquidity and contract Balance functions\r\n\r\n// convert all stored tokens for LP into LP Pairs\r\n    function convertLiquidityBalance(uint256 tokensToConvert) public onlyOwner {\r\n\r\n        uint256 contractTokenBalance = balanceOf(address(this));\r\n\r\n        if(contractTokenBalance >= _maxTxAmount) {\r\n            contractTokenBalance = _maxTxAmount - 1;\r\n        }\r\n\r\n        if(tokensToConvert == 0 || tokensToConvert > contractTokenBalance){\r\n            tokensToConvert = contractTokenBalance;\r\n        }\r\n        swapAndLiquify(tokensToConvert);\r\n    }\r\n\r\n// convert all stored tokens for LP into LP Pairs\r\n    function purgeContractBalance() public {\r\n        require(msg.sender == owner() || msg.sender == _wallet_marketing, \"Not authorized to perform this\");\r\n         _wallet_marketing.transfer(address(this).balance);\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// Reflect Finance core code\r\n\r\n    function _getRate() private view returns(uint256) {\r\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\r\n        return rSupply / tSupply;\r\n    }\r\n\r\n    function _getCurrentSupply() private view returns(uint256, uint256) {\r\n        uint256 rSupply = _supply_reflected;\r\n        uint256 tSupply = _supply_total;      \r\n        for (uint256 i = 0; i < _excluded.length; i++) {\r\n            if (_balance_reflected[_excluded[i]] > rSupply || _balance_total[_excluded[i]] > tSupply) return (_supply_reflected, _supply_total);\r\n            rSupply = rSupply - _balance_reflected[_excluded[i]];\r\n            tSupply = tSupply - _balance_total[_excluded[i]];\r\n        }\r\n        if (rSupply < (_supply_reflected/_supply_total)) return (_supply_reflected, _supply_total);\r\n        return (rSupply, tSupply);\r\n    }\r\n\r\n\r\n    function _getValues(uint256 tAmount, bool isSell) private view returns (\r\n        uint256 rAmount, uint256 rTransferAmount, uint256 rReflection,\r\n        uint256 tTransferAmount,uint256 tBurn, uint256 tMarketing, uint256 tLiquidity, uint256 tTeam, uint256 tReflection) {\r\n\r\n        uint256 multiplier = isSell ? sellMultiplier : 100;\r\n\r\n        tBurn           = ( tAmount * _fee_burn )/ _fee_denominator;\r\n        tMarketing       = ( tAmount * _fee_marketing ) * multiplier / (_fee_denominator * 100);\r\n        tLiquidity      = ( tAmount * _fee_liquidity ) * multiplier / (_fee_denominator * 100);\r\n        tTeam           = ( tAmount * _fee_team ) * multiplier / (_fee_denominator * 100);\r\n        tReflection     = ( tAmount * _fee_reflection ) * multiplier  / (_fee_denominator * 100);\r\n\r\n        tTransferAmount = tAmount - (tBurn + tMarketing + tLiquidity + tTeam + tReflection);\r\n\r\n        rReflection     = tReflection * _getRate();\r\n\r\n        rAmount         = tAmount * _getRate();\r\n\r\n        rTransferAmount = tTransferAmount * _getRate();\r\n\r\n    }\r\n\r\n\r\n\r\n    function _fees_to_bnb_process( address payable wallet, uint256 tokensToConvert) private lockTheSwap {\r\n\r\n        uint256 rTokensToConvert = tokensToConvert * _getRate();\r\n\r\n        _balance_reflected[wallet]    = _balance_reflected[wallet]  - rTokensToConvert;\r\n        if (_isExcluded[wallet]){\r\n            _balance_total[wallet]    = _balance_total[wallet]      - tokensToConvert;\r\n        }\r\n        _balance_reflected[address(this)]      = _balance_reflected[address(this)]    + rTokensToConvert;\r\n\r\n        emit Transfer(wallet, address(this), tokensToConvert);\r\n\r\n        swapTokensForEthAndSend(tokensToConvert,wallet);\r\n\r\n    }\r\n\r\n\r\n// Fee & Wallet Related\r\n\r\n    function fees_to_bnb_manual(uint256 tokensToConvert, address payable feeWallet, uint256 minBalanceToKeep) external onlyOwner {\r\n        _fees_to_bnb(tokensToConvert,feeWallet,minBalanceToKeep);\r\n    }\r\n\r\n\r\n    function _fees_to_bnb(uint256 tokensToConvert, address payable feeWallet, uint256 minBalanceToKeep) private {\r\n        // case 1: 0 tokens to convert, exit the function\r\n        // case 2: tokens to convert are more than the max limit\r\n        \r\n        if(tokensToConvert == 0){\r\n            return;\r\n        } \r\n\r\n        if(tokensToConvert > _maxTxAmount){\r\n            tokensToConvert = _maxTxAmount;\r\n        }\r\n\r\n        if((tokensToConvert+minBalanceToKeep)  <= balanceOf(feeWallet)){\r\n            _fees_to_bnb_process(feeWallet,tokensToConvert);\r\n        }\r\n    }\r\n\r\n\r\n    function _takeFee(uint256 feeAmount, address receiverWallet) private {\r\n        uint256 reflectedReeAmount = feeAmount * _getRate();\r\n        _balance_reflected[receiverWallet] = _balance_reflected[receiverWallet] + reflectedReeAmount;\r\n\r\n\r\n        if(_isExcluded[receiverWallet]){\r\n            _balance_total[receiverWallet] = _balance_total[receiverWallet] + feeAmount;\r\n        }\r\n\r\n        emit Transfer(msg.sender, receiverWallet, feeAmount);\r\n    }\r\n\r\n\r\n    function _takefees_Liquidity(uint256 amount) private {\r\n        _takeFee(amount,address(this));\r\n    }\r\n    \r\n    function _takefees_burn(uint256 amount) private {\r\n        _takeFee(amount,_wallet_burn);\r\n        \r\n    }\r\n\r\n    function _takefees_team(uint256 amount) private {\r\n        _takeFee(amount,_wallet_team);\r\n\r\n    }\r\n\r\n    function _takefees_marketing(uint256 amount) private {\r\n        _takeFee(amount,_wallet_marketing);\r\n        \r\n    }\r\n\r\n    function _take_reflectionFee(uint256 rFee, uint256 tFee) private {\r\n        _supply_reflected = _supply_reflected - rFee;\r\n        _contractReflectionStored = _contractReflectionStored + tFee;\r\n    }\r\n    \r\n\r\n\r\n// Fee management from GENx\r\n// Made all parameters in alphabetical order\r\n    function _setAllFees(uint256 burnFees, uint256 marketingFee, uint256 liquidityFees, uint256 teamFee, uint256 reflectionFees) private {\r\n        _fee_burn           = burnFees;\r\n        _fee_marketing        = marketingFee;\r\n        _fee_liquidity      = liquidityFees;\r\n        _fee_team           = teamFee;\r\n        _fee_reflection     = reflectionFees;\r\n        \r\n    }\r\n\r\n    function set_sell_multiplier(uint256 Multiplier) external onlyOwner{\r\n        sellMultiplier = Multiplier;        \r\n    }\r\n\r\n    function set_All_Fees_Triggers(uint256 marketing_fee_convert_limit, uint256 team_fee_convert_limit) external onlyOwner {\r\n        _fee_marketing_convert_limit      = marketing_fee_convert_limit;\r\n        _fee_team_convert_limit         = team_fee_convert_limit;   \r\n    }\r\n\r\n    function set_All_Fees_Minimum_Balance(uint256 marketing_fee_minimum_balance, uint256 team_fee_minimum_balance) external onlyOwner {\r\n        _fee_team_min_bal       = team_fee_minimum_balance;\r\n        _fee_marketing_min_bal    = marketing_fee_minimum_balance;\r\n    }\r\n\r\n\r\n\r\n\r\n    // set all fees in one go, we dont need 4 functions!\r\n    function set_All_Fees(uint256 Team_Fee, uint256 Burn_Fees, uint256 Liquidity_Fees, uint256 Reflection_Fees, uint256 MarketingFee) external onlyOwner {\r\n        uint256 total_fees = Burn_Fees + MarketingFee + Liquidity_Fees +  Team_Fee + Reflection_Fees;\r\n        require(total_fees < 4000, \"Cannot set fees this high, pancake swap will hate us!\");\r\n        _setAllFees( Burn_Fees, MarketingFee, Liquidity_Fees, Team_Fee, Reflection_Fees);\r\n    }\r\n\r\n\r\n    function removeAllFee() private {\r\n        _fee_burn_old           = _fee_burn;\r\n        _fee_marketing_old        = _fee_marketing;\r\n        _fee_liquidity_old      = _fee_liquidity;\r\n        _fee_team_old           = _fee_team;\r\n        _fee_reflection_old     = _fee_reflection;\r\n\r\n        _setAllFees(0,0,0,0,0);\r\n    }\r\n    \r\n    function restoreAllFee() private {\r\n        _setAllFees(_fee_burn_old, _fee_marketing_old, _fee_liquidity_old, _fee_team_old, _fee_reflection_old);\r\n    }\r\n\r\n\r\n    // this one reduces supply\r\n    function burn_tokens_reduce_supply(address wallet, uint256 tokensToConvert) external {\r\n\r\n        require(msg.sender == owner() || msg.sender == wallet, \"Not authorized to burn\");\r\n\r\n        uint256 rTokensToConvert = tokensToConvert * _getRate();\r\n\r\n        _balance_reflected[wallet]    = _balance_reflected[wallet]  - rTokensToConvert;\r\n        if (_isExcluded[wallet]){\r\n            _balance_total[wallet]    = _balance_total[wallet]      - tokensToConvert;\r\n        }\r\n\r\n        _supply_total = _supply_total - tokensToConvert;\r\n        _supply_reflected = _supply_reflected - rTokensToConvert;\r\n\r\n        emit Transfer(wallet, address(this), tokensToConvert);\r\n\r\n    }\r\n\r\n    // this one sends to dead address\r\n    function burn_tokens_to_dead(address wallet, uint256 tokensToConvert) external {\r\n\r\n        require(msg.sender == owner() || msg.sender == wallet, \"Not authorized to burn\");\r\n\r\n        uint256 rTokensToConvert = tokensToConvert * _getRate();\r\n\r\n        _balance_reflected[wallet]          = _balance_reflected[wallet]  - rTokensToConvert;\r\n        if (_isExcluded[wallet]){\r\n            _balance_total[wallet]          = _balance_total[wallet]      - tokensToConvert;\r\n        }\r\n\r\n        if (_isExcluded[deadAddress]){\r\n            _balance_total[deadAddress]     = _balance_total[deadAddress]        + tokensToConvert;  \r\n        }\r\n\r\n        // update reflected balance of receipient\r\n        _balance_reflected[deadAddress]     = _balance_reflected[deadAddress]    + rTokensToConvert;\r\n\r\n        emit Transfer(wallet, deadAddress, tokensToConvert);\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n// Liquidity functions\r\n\r\n    function swapAndLiquify(uint256 tokensToSwap) private lockTheSwap {\r\n        uint256 tokensHalf = tokensToSwap/2;\r\n\r\n        uint256 contractBnbBalance = address(this).balance;\r\n\r\n        swapTokensForEth(tokensHalf);\r\n        \r\n        uint256 bnbSwapped = address(this).balance - contractBnbBalance;\r\n\r\n        addLiquidity(tokensHalf,bnbSwapped);\r\n\r\n        emit SwapAndLiquify(tokensToSwap, tokensHalf, bnbSwapped);\r\n    }\r\n\r\n    function swapTokensForEth(uint256 tokenAmount) private {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = uniswapV2Router.WETH();\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function swapTokensForEthAndSend(uint256 tokenAmount, address payable receiverWallet) private {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = uniswapV2Router.WETH();\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0,\r\n            path,\r\n            receiverWallet,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n\r\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        uniswapV2Router.addLiquidityETH{value: ethAmount}(\r\n            address(this),\r\n            tokenAmount,\r\n            0,\r\n            0,\r\n            deadAddress,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    function _approve(address owner, address spender, uint256 amount) private {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n\r\n\r\n\r\n    // All transfer functions\r\n\r\n    function _transfer(address from, address to, uint256 amount) private {\r\n        \r\n       \r\n        //limits the amount of tokens that each person can buy - launch limit is 2% of total supply!\r\n        if (to != owner() && to != address(this)  && to != address(deadAddress) && to != uniswapV2Pair && to != _wallet_marketing && to != _wallet_team){\r\n            uint256 heldTokens = balanceOf(to);\r\n            require((heldTokens + amount) <= _maxWalletToken,\"Total Holding is currently limited, you can not buy that much.\");}\r\n        \r\n        if(from != owner() && to != owner()){\r\n            require(tradingOpen,\"Trading not open yet\");\r\n        }\r\n\r\n        //blacklisted addreses can not buy! If you have ever used a bot, or scammed anybody, then you're wallet address will probably be blacklisted\r\n        require(!_isBlacklisted[from] && !_isBlacklisted[to], \"This address is blacklisted\");\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n        require(amount > 0, \"Transfer amount must be greater than zero\");\r\n\r\n     \r\n\r\n        // cooldown timer, so a bot doesnt do quick trades! 1min gap between 2 trades.\r\n        if (from == uniswapV2Pair &&\r\n            buyCooldownEnabled &&\r\n            !_isExcludedFromFee[to] &&\r\n            to != address(this)  && \r\n            to != address(deadAddress)) {\r\n            require(cooldownTimer[to] < block.timestamp,\"Please wait for cooldown between buys\");\r\n            cooldownTimer[to] = block.timestamp + cooldownTimerInterval;\r\n        }\r\n\r\n\r\n        //limit the maximum number of tokens that can be bought or sold in one transaction\r\n        if(from != owner() && to != owner()){\r\n            require(amount <= _maxTxAmount, \"Transfer amount exceeds the maxTxAmount.\");\r\n        }\r\n\r\n        // extra bracket to supress stack too deep error\r\n        {\r\n            uint256 contractTokenBalance = balanceOf(address(this));\r\n        \r\n            if(contractTokenBalance >= _maxTxAmount) {\r\n                contractTokenBalance = _maxTxAmount - 1;\r\n            }\r\n            \r\n            bool overMinTokenBalance = contractTokenBalance >= _numTokensSellToAddToLiquidity;\r\n            if (overMinTokenBalance &&\r\n                !inSwapAndLiquify &&\r\n                from != uniswapV2Pair &&\r\n                swapAndLiquifyEnabled\r\n            ) {\r\n                contractTokenBalance = _numTokensSellToAddToLiquidity;\r\n                swapAndLiquify(contractTokenBalance);\r\n            }\r\n\r\n            // Convert fees to BNB\r\n            if(!inSwapAndLiquify && from != uniswapV2Pair){\r\n                _fees_to_bnb(_fee_team_convert_limit,_wallet_team, _fee_team_min_bal);\r\n                _fees_to_bnb(_fee_marketing_convert_limit,_wallet_marketing, _fee_marketing_min_bal);\r\n            }\r\n            \r\n        }\r\n        // extra useless ugly brackets ends\r\n        \r\n        \r\n        bool takeFee = true;\r\n        if(_isExcludedFromFee[from] || _isExcludedFromFee[to]){\r\n            takeFee = false;\r\n        }\r\n        \r\n        if(!takeFee){\r\n            removeAllFee();\r\n        }\r\n        \r\n        // Get all tranfer values        \r\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rReflection, uint256 tTransferAmount, uint256 tBurn, uint256 tMarketing, uint256 tLiquidity, uint256 tTeam,  uint256 tReflection) = _getValues(amount, (to == uniswapV2Pair));\r\n\r\n\r\n        _transferStandard(from,to,amount,rAmount,tTransferAmount, rTransferAmount);\r\n       \r\n        // update reflections\r\n        _take_reflectionFee(rReflection, tReflection);\r\n\r\n        if(!takeFee){\r\n            restoreAllFee();\r\n        } else{\r\n            // functions to take all fees\r\n            // no point to call them if there's no fees to be taken\r\n            _takefees_burn(tBurn);\r\n            _takefees_marketing(tMarketing);\r\n            _takefees_Liquidity(tLiquidity);\r\n            _takefees_team(tTeam);\r\n        }\r\n\r\n    }\r\n\r\n    function _transferStandard(address from, address to, uint256 tAmount, uint256 rAmount, uint256 tTransferAmount, uint256 rTransferAmount) private {\r\n         // Update reflected Balance for sender\r\n        _balance_reflected[from]    = _balance_reflected[from]  - rAmount;\r\n\r\n\r\n        // Only update actual balance of sender if he's excluded from rewards\r\n        if (_isExcluded[from]){\r\n            _balance_total[from]    = _balance_total[from]      - tAmount;\r\n        }\r\n\r\n        // Only update actual balance of recipient if he's excluded from rewards\r\n        if (_isExcluded[to]){\r\n            _balance_total[to]      = _balance_total[to]        + tTransferAmount;  \r\n        }\r\n\r\n        // update reflected balance of receipient\r\n        _balance_reflected[to]      = _balance_reflected[to]    + rTransferAmount;\r\n\r\n        emit Transfer(from, to, tTransferAmount);\r\n        emit TransferDetails(from, to, tAmount, rAmount, tTransferAmount, rTransferAmount);\r\n    }\r\n\r\n    //receive BNB from PancakeSwap Router\r\n    receive() external payable {}\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minTokensBeforeSwap\",\"type\":\"uint256\"}],\"name\":\"MinTokensBeforeSwapUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiqudity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"SwapAndLiquifyEnabledUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total_Amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reflected_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total_TransferAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reflected_TransferAmount\",\"type\":\"uint256\"}],\"name\":\"TransferDetails\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"Change_Wallet_Burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"Change_Wallet_Marketing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"Change_Wallet_Team\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"___feesInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"NumTokensSellToAddToLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"contractTokenBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Reflection_tokens_stored\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"___tokenInfo\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"Decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"MaxTxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"MaxWalletToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TotalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Reflected_Supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Reflection_Rate\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"TradingOpen\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"Cooldown_timer_enabled\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"Cooldown_timer_interval\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"___wallets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"Reflection_Fees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Liquidity_Fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Team_Fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Team_Fee_Convert_Limit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Team_Fee_Minimum_Balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Marketing_Fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Marketing_Fee_Convert_Limit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Marketing_Fee_Minimum_Balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Burn_Fee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"Team_Wallet_Address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"Burn_Wallet_Address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"Marketing_Wallet_Address\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_balance_reflected\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_balance_total\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_fee_burn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_fee_denominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_fee_liquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_fee_marketing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_fee_marketing_convert_limit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_fee_marketing_min_bal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_fee_reflection\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_fee_team\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_fee_team_convert_limit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_fee_team_min_bal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isBlacklisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxWalletToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_numTokensSellToAddToLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_wallet_burn\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_wallet_marketing\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_wallet_team\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokensToConvert\",\"type\":\"uint256\"}],\"name\":\"burn_tokens_reduce_supply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokensToConvert\",\"type\":\"uint256\"}],\"name\":\"burn_tokens_to_dead\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyCooldownEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokensToConvert\",\"type\":\"uint256\"}],\"name\":\"convertLiquidityBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"_interval\",\"type\":\"uint8\"}],\"name\":\"cooldownEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cooldownTimerInterval\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tAmount\",\"type\":\"uint256\"}],\"name\":\"deliver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokensToConvert\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"feeWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minBalanceToKeep\",\"type\":\"uint256\"}],\"name\":\"fees_to_bnb_manual\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokens\",\"type\":\"uint256[]\"}],\"name\":\"makeItRain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"purgeContractBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"deductTransferFee\",\"type\":\"bool\"}],\"name\":\"reflectionFromToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"s_excludeFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"s_manageBlacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"s_manageExcludeFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxTxPercent\",\"type\":\"uint256\"}],\"name\":\"setMaxTxPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxTxTokens\",\"type\":\"uint256\"}],\"name\":\"setMaxTxTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxWallPercent\",\"type\":\"uint256\"}],\"name\":\"setMaxWalletPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxWallTokens\",\"type\":\"uint256\"}],\"name\":\"setMaxWalletTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numTokensSellToAddToLiquidity\",\"type\":\"uint256\"}],\"name\":\"setNumTokensSellToAddToLiquidityt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setSwapAndLiquifyEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"Team_Fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Burn_Fees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Liquidity_Fees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Reflection_Fees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"MarketingFee\",\"type\":\"uint256\"}],\"name\":\"set_All_Fees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketing_fee_minimum_balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"team_fee_minimum_balance\",\"type\":\"uint256\"}],\"name\":\"set_All_Fees_Minimum_Balance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketing_fee_convert_limit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"team_fee_convert_limit\",\"type\":\"uint256\"}],\"name\":\"set_All_Fees_Triggers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"Multiplier\",\"type\":\"uint256\"}],\"name\":\"set_sell_multiplier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapAndLiquifyEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rAmount\",\"type\":\"uint256\"}],\"name\":\"tokenFromReflection\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"tradingStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SevenDoxxed", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://69f57378761cc2687fe7eac0cfbeca3536bfd3f081485b426dc89f082c5b8622"}