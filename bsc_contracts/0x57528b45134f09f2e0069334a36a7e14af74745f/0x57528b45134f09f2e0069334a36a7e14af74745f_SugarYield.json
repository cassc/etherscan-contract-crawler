{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/SugarYield.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.15;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\ninterface IERC20Metadata is IERC20 {\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n}\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n            unchecked {\\n                _approve(sender, _msgSender(), currentAllowance - amount);\\n            }\\n        }\\n\\n        _transfer(sender, recipient, amount);\\n\\n        return true;\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[sender] = senderBalance - amount;\\n        }\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n\\n        _afterTokenTransfer(sender, recipient, amount);\\n    }\\n\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\\nenum TokenClass {\\n    basicToken,\\n    reflectionToken,\\n    SugarToken,\\n    apyToken\\n}\\n\\nabstract contract BaseToken {\\n    event TokenCreated(\\n        address indexed owner,\\n        address indexed token,\\n        TokenClass tokenClass,\\n        uint256 version\\n    );\\n}\\n\\ncontract SugarYield is ERC20, Ownable, BaseToken {\\n    uint256 public buyFee;\\n    uint256 public sellFee;\\n    uint256 public liquidityShare;\\n    uint256 public marketingShare;\\n    uint256 public charityShare;\\n\\n    address public marketingWallet;\\n    address public charityWallet;\\n\\n    bool public walletToWalletTransferWithoutFee;\\n\\n    IUniswapV2Router02 public uniswapV2Router;\\n    address public  uniswapV2Pair;\\n\\n    address private DEAD = 0x000000000000000000000000000000000000dEaD;\\n\\n    bool    private swapping;\\n    uint256 public swapTokensAtAmount;\\n\\n    mapping (address => bool) private _isExcludedFromFees;\\n    mapping (address => bool) public automatedMarketMakerPairs;\\n\\n    event ExcludeFromFees(address indexed account, bool isExcluded);\\n    event ExcludedFromMaxTransactionLimit(address indexed account, bool isExcluded);\\n    event ExcludedFromMaxWalletLimit(address indexed account, bool isExcluded);\\n    event FeesUpdated(uint256 buyFee, uint256 sellFee);\\n    event FeeSharesUpdated(uint256 liquidityShare, uint256 marketingShare, uint256 charityShare);\\n    event MarketingWalletChanged(address marketingWallet);\\n    event CharityWalletChanged(address charityWallet);\\n    event MaxWalletLimitRateChanged(uint256 maxWalletLimitRate);\\n    event MaxWalletLimitStateChanged(bool maxWalletLimit);\\n    event MaxTransactionLimitRatesChanged(uint256 maxTransferRateBuy, uint256 maxTransferRateSell);\\n    event MaxTransactionLimitStateChanged(bool maxTransactionLimit);\\n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\\n    event SwapAndLiquify(uint256 tokensSwapped, uint256 bnbReceived, uint256 tokensIntoLiqudity);\\n    event SwapAndSendFees(uint256 tokensSwapped, uint256 bnbSend);\\n    event UpdateUniswapV2Router(address indexed newAddress, address indexed oldAddress);\\n\\n    struct ConstructorArgument {\\n        string  name_;\\n        string  symbol_;\\n        uint256 totalSupply_;\\n        address router_;\\n        bool    walletToWalletTransferWithoutFee_;\\n        bool    maxTransactionLimitAvailable_;\\n        uint256 maxTransactionRateBuy_;\\n        uint256 maxTransactionRateSell_;\\n        bool    maxWalletLimitAvailable_;\\n        uint256 maxWalletLimitRate_;\\n        uint256 buyFee_;\\n        uint256 sellFee_;\\n        uint256 liquidityShare_;\\n        uint256 marketingShare_;\\n        uint256 charityShare_;\\n        address marketingWallet_;\\n        address charityWallet_;\\n    }\\n\\n    constructor (\\n        ConstructorArgument memory _arg\\n        ) ERC20(_arg.name_, _arg.symbol_)\\n    {\\n        require(_arg.buyFee_ + _arg.sellFee_ <= 25, \\\"Total buy and sell fees cannot be more than 25%\\\");\\n        require(_arg.marketingShare_ + _arg.liquidityShare_ + _arg.charityShare_ == 100, \\\"Total fee shares must be equal to 100\\\");\\n        require(_arg.maxTransactionRateBuy_ >= 1 && _arg.maxTransactionRateSell_ >= 1, \\\"Max transfer rates must be greater than 0.1%\\\");\\n        require(_arg.maxWalletLimitRate_ >= 10, \\\"Max wallet limit rate must be greater than 1%\\\");\\n\\n        buyFee  = _arg.buyFee_;\\n        sellFee = _arg.sellFee_ ;\\n        liquidityShare  = _arg.liquidityShare_;\\n        marketingShare  = _arg.marketingShare_;\\n        charityShare    = _arg.charityShare_;\\n        marketingWallet = _arg.marketingWallet_;\\n        charityWallet   = _arg.charityWallet_;\\n        walletToWalletTransferWithoutFee = _arg.walletToWalletTransferWithoutFee_;\\n        maxTransactionAvailable    = _arg.maxTransactionLimitAvailable_;\\n        maxTransactionLimitEnabled = _arg.maxTransactionLimitAvailable_;\\n        maxTransactionRateBuy      = _arg.maxTransactionRateBuy_;\\n        maxTransactionRateSell     = _arg.maxTransactionRateSell_;\\n        maxWalletAvailable         = _arg.maxWalletLimitAvailable_;\\n        maxWalletLimitEnabled      = _arg.maxWalletLimitAvailable_;\\n        maxWalletLimitRate         = _arg.maxWalletLimitRate_;\\n\\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(_arg.router_);\\n        address _uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\\n            .createPair(address(this), _uniswapV2Router.WETH());\\n\\n        uniswapV2Router = _uniswapV2Router;\\n        uniswapV2Pair   = _uniswapV2Pair;\\n\\n        _approve(address(this), address(uniswapV2Router), type(uint256).max);\\n\\n        _setAutomatedMarketMakerPair(_uniswapV2Pair, true);\\n\\n        _isExcludedFromMaxTxLimit[owner()] = true;\\n        _isExcludedFromMaxTxLimit[address(0)] = true;\\n        _isExcludedFromMaxTxLimit[address(this)] = true;\\n        _isExcludedFromMaxTxLimit[DEAD] = true;\\n\\n        _isExcludedFromMaxWalletLimit[owner()] = true;\\n        _isExcludedFromMaxWalletLimit[address(0)] = true;\\n        _isExcludedFromMaxWalletLimit[address(this)] = true;\\n        _isExcludedFromMaxWalletLimit[DEAD] = true;\\n\\n        _isExcludedFromFees[owner()] = true;\\n        _isExcludedFromFees[DEAD] = true;\\n        _isExcludedFromFees[address(this)] = true;\\n\\n        swapTokensAtAmount = _arg.totalSupply_ * (10 ** 18) / 5000;\\n        _mint(owner(), _arg.totalSupply_ * (10 ** 18));\\n\\n        emit TokenCreated(owner(), address(this), TokenClass.basicToken, 3);\\n    }\\n\\n    receive() external payable {\\n\\n  \\t}\\n\\n    function claimStuckTokens(address token) external onlyOwner {\\n        require(token != address(this), \\\"Owner cannot claim native tokens\\\");\\n        if (token == address(0x0)) {\\n            payable(msg.sender).transfer(address(this).balance);\\n            return;\\n        }\\n        IERC20 ERC20token = IERC20(token);\\n        uint256 balance = ERC20token.balanceOf(address(this));\\n        ERC20token.transfer(msg.sender, balance);\\n    }\\n\\n    function isContract(address account) internal view returns (bool) {\\n        return account.code.length > 0;\\n    }\\n\\n    function sendBNB(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    function _setAutomatedMarketMakerPair(address pair, bool value) private {\\n        require(automatedMarketMakerPairs[pair] != value, \\\"Automated market maker pair is already set to that value\\\");\\n        automatedMarketMakerPairs[pair] = value;\\n\\n        emit SetAutomatedMarketMakerPair(pair, value);\\n    }\\n\\n    //=======FeeManagement=======//\\n    function excludeFromFees(address account, bool excluded) external onlyOwner {\\n        require(_isExcludedFromFees[account] != excluded, \\\"Account is already set to that state\\\");\\n        _isExcludedFromFees[account] = excluded;\\n\\n        emit ExcludeFromFees(account, excluded);\\n    }\\n\\n    function isExcludedFromFees(address account) public view returns(bool) {\\n        return _isExcludedFromFees[account];\\n    }\\n\\n    function updateFees(uint256 _buyFee, uint256 _sellFee) external onlyOwner {\\n        require(_buyFee + _sellFee <= 25, \\\"Total buy and sell fees cannot be more than 25%\\\");\\n        buyFee = _buyFee;\\n        sellFee = _sellFee;\\n        emit FeesUpdated(buyFee, sellFee);\\n    }\\n\\n    function updateFeeShares(uint256 _marketingFeeShare, uint256 _liquidityFeeShare, uint256 _charityShare) external onlyOwner {\\n        require(_marketingFeeShare + _liquidityFeeShare + _charityShare == 100, \\\"Total fee shares must be equal to 100\\\");\\n        marketingShare = _marketingFeeShare;\\n        liquidityShare = _liquidityFeeShare;\\n        charityShare   = _charityShare;\\n        emit FeeSharesUpdated(marketingShare, liquidityShare, charityShare);\\n    }\\n\\n    function enableWalletToWalletTransferWithoutFee(bool enable) external onlyOwner {\\n        require(walletToWalletTransferWithoutFee != enable, \\\"Wallet to wallet transfer without fee is already set to that value\\\");\\n        walletToWalletTransferWithoutFee = enable;\\n    }\\n\\n    function changeMarketingWallet(address _marketingWallet) external onlyOwner {\\n        require(_marketingWallet != marketingWallet, \\\"Marketing wallet is already that address\\\");\\n        require(!isContract(_marketingWallet), \\\"Marketing wallet cannot be a contract\\\");\\n        require(_marketingWallet != address(0), \\\"Marketing wallet cannot be zero address\\\");\\n        marketingWallet = _marketingWallet;\\n        emit MarketingWalletChanged(marketingWallet);\\n    }\\n\\n    function changeCharityWallet(address _charityWallet) external onlyOwner {\\n        require(_charityWallet != charityWallet, \\\"Charity wallet is already that address\\\");\\n        require(!isContract(_charityWallet), \\\"Charity wallet cannot be a contract\\\");\\n        require(_charityWallet != address(0), \\\"Charity wallet cannot be zero address\\\");\\n        charityWallet = _charityWallet;\\n        emit CharityWalletChanged(charityWallet);\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal  override {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        if(amount == 0) {\\n            super._transfer(from, to, 0);\\n            return;\\n        }\\n\\n        if (maxWalletLimitEnabled) {\\n            if (_isExcludedFromMaxWalletLimit[from] == false\\n                && _isExcludedFromMaxWalletLimit[to] == false &&\\n                to != uniswapV2Pair\\n            ) {\\n                uint balance  = balanceOf(to);\\n                require(balance + amount <= maxWalletAmount(), \\\"MaxWallet: Transfer amount exceeds the maxWalletAmount\\\");\\n            }\\n        }\\n\\n        if (maxTransactionLimitEnabled) {\\n            if (_isExcludedFromMaxTxLimit[from] == false\\n                && _isExcludedFromMaxTxLimit[to] == false\\n            ) {\\n                if (from == uniswapV2Pair) {\\n                    require(amount <= maxTransferAmountBuy(), \\\"AntiWhale: Transfer amount exceeds the maxTransferAmount\\\");\\n                }else{\\n                    require(amount <= maxTransferAmountSell(), \\\"AntiWhale: Transfer amount exceeds the maxTransferAmount\\\");\\n                }\\n            }\\n        }\\n\\n\\t\\tuint256 contractTokenBalance = balanceOf(address(this));\\n\\n        bool canSwap = contractTokenBalance >= swapTokensAtAmount;\\n\\n        if( canSwap &&\\n            !swapping &&\\n            automatedMarketMakerPairs[to]\\n        ) {\\n            swapping = true;\\n\\n            if(liquidityShare > 0) {\\n                uint256 liquidityTokens = contractTokenBalance * liquidityShare / 100;\\n                swapAndLiquify(liquidityTokens);\\n            }\\n\\n            if(marketingShare + charityShare > 0) {\\n                uint256 feeTokens = (contractTokenBalance * (marketingShare + charityShare)) / 100;\\n                swapAndSendFees(feeTokens);\\n            }\\n\\n            swapping = false;\\n        }\\n\\n        bool takeFee = !swapping;\\n\\n        if(_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\\n            takeFee = false;\\n        }\\n\\n        if(walletToWalletTransferWithoutFee && from != uniswapV2Pair && to != uniswapV2Pair) {\\n            takeFee = false;\\n        }\\n\\n        if(takeFee) {\\n            uint256 _totalFees;\\n            if(from == uniswapV2Pair) {\\n                _totalFees = buyFee;\\n            } else {\\n                _totalFees = sellFee;\\n            }\\n        \\tuint256 fees = amount * _totalFees / 100;\\n\\n        \\tamount = amount - fees;\\n\\n            super._transfer(from, address(this), fees);\\n        }\\n\\n        super._transfer(from, to, amount);\\n\\n    }\\n\\n    //=======Swap=======//\\n    function swapAndLiquify(uint256 tokens) private {\\n        uint256 half = tokens / 2;\\n        uint256 otherHalf = tokens - half;\\n\\n        uint256 initialBalance = address(this).balance;\\n\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = uniswapV2Router.WETH();\\n\\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            half,\\n            0, // accept any amount of ETH\\n            path,\\n            address(this),\\n            block.timestamp);\\n\\n        uint256 newBalance = address(this).balance - initialBalance;\\n\\n        uniswapV2Router.addLiquidityETH{value: newBalance}(\\n            address(this),\\n            otherHalf,\\n            0, // slippage is unavoidable\\n            0, // slippage is unavoidable\\n            DEAD,\\n            block.timestamp\\n        );\\n\\n        emit SwapAndLiquify(half, newBalance, otherHalf);\\n    }\\n\\n    function swapAndSendFees(uint256 tokenAmount) private {\\n        uint256 initialBalance = address(this).balance;\\n\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = uniswapV2Router.WETH();\\n\\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            tokenAmount,\\n            0, // accept any amount of ETH\\n            path,\\n            address(this),\\n            block.timestamp);\\n\\n        uint256 newBalance = address(this).balance - initialBalance;\\n\\n        uint256 bnbShare = marketingShare + charityShare;\\n\\n        if(marketingShare > 0) {\\n            uint256 marketingBnb = newBalance * marketingShare / bnbShare;\\n            sendBNB(payable(marketingWallet), marketingBnb);\\n        }\\n\\n        if(charityShare > 0) {\\n            uint256 charityBnb = newBalance * charityShare / bnbShare;\\n            sendBNB(payable(charityWallet), charityBnb);\\n        }\\n\\n        emit SwapAndSendFees(tokenAmount, newBalance);\\n    }\\n\\n    function setSwapTokensAtAmount(uint256 newAmount) external onlyOwner{\\n        require(newAmount > totalSupply() / 100000, \\\"SwapTokensAtAmount must be greater than 0.001% of total supply\\\");\\n        swapTokensAtAmount = newAmount;\\n    }\\n\\n    //=======MaxWallet=======//\\n    mapping(address => bool) private _isExcludedFromMaxWalletLimit;\\n    bool    public maxWalletAvailable;\\n    bool    public maxWalletLimitEnabled;\\n    uint256 private maxWalletLimitRate;\\n\\n    modifier _maxWalletAvailable() {\\n        require(maxWalletAvailable, \\\"Max wallet limit is not available\\\");\\n        _;\\n    }\\n\\n    function setEnableMaxWalletLimit(bool enable) external onlyOwner _maxWalletAvailable {\\n        require(enable != maxWalletLimitEnabled, \\\"Max wallet limit is already that state\\\");\\n        maxWalletLimitEnabled = enable;\\n        emit MaxWalletLimitStateChanged(maxWalletLimitEnabled);\\n    }\\n\\n    function isExcludedFromMaxWalletLimit(address account) public view returns(bool) {\\n        return _isExcludedFromMaxWalletLimit[account];\\n    }\\n\\n    function maxWalletAmount() public view returns (uint256) {\\n        return totalSupply() * maxWalletLimitRate / 1000;\\n    }\\n\\n    function setMaxWalletRate_Denominator1000(uint256 _val) external onlyOwner _maxWalletAvailable {\\n        require(_val >= 10, \\\"Max wallet percentage cannot be lower than 1%\\\");\\n        maxWalletLimitRate = _val;\\n        emit MaxWalletLimitRateChanged(maxWalletLimitRate);\\n    }\\n\\n    function setExcludeFromMaxWallet(address account, bool exclude) external onlyOwner _maxWalletAvailable {\\n        require(_isExcludedFromMaxWalletLimit[account] != exclude, \\\"Account is already set to that state\\\");\\n        _isExcludedFromMaxWalletLimit[account] = exclude;\\n        emit ExcludedFromMaxWalletLimit(account, exclude);\\n    }\\n\\n    //=======MaxTransaction=======//\\n    mapping(address => bool) private _isExcludedFromMaxTxLimit;\\n    bool    public maxTransactionAvailable;\\n    bool    public maxTransactionLimitEnabled;\\n    uint256 private maxTransactionRateBuy;\\n    uint256 private maxTransactionRateSell;\\n\\n    modifier _maxTransactionAvailable() {\\n        require(maxTransactionAvailable, \\\"Max transaction limit is not available\\\");\\n        _;\\n    }\\n\\n    function setEnableMaxTransactionLimit(bool enable) external onlyOwner _maxTransactionAvailable {\\n        require(enable != maxTransactionLimitEnabled, \\\"Max transaction limit is already that state\\\");\\n        maxTransactionLimitEnabled = enable;\\n        emit MaxTransactionLimitStateChanged(maxTransactionLimitEnabled);\\n    }\\n\\n    function isExcludedFromMaxTransaction(address account) public view returns(bool) {\\n        return _isExcludedFromMaxTxLimit[account];\\n    }\\n\\n    function maxTransferAmountBuy() public view returns (uint256) {\\n        return totalSupply() * maxTransactionRateBuy / 1000;\\n    }\\n\\n    function maxTransferAmountSell() public view returns (uint256) {\\n        return totalSupply() * maxTransactionRateSell / 1000;\\n    }\\n\\n    function setMaxTransactionRates_Denominator1000(uint256 _maxTransactionRateBuy, uint256 _maxTransactionRateSell) external onlyOwner _maxTransactionAvailable {\\n        require(_maxTransactionRateSell >= 1 && _maxTransactionRateBuy >= 1, \\\"Max Transaction limit cannot be lower than 0.1% of total supply\\\");\\n        maxTransactionRateBuy  = _maxTransactionRateBuy;\\n        maxTransactionRateSell = _maxTransactionRateSell;\\n        emit MaxTransactionLimitRatesChanged(maxTransactionRateBuy, maxTransactionRateSell);\\n    }\\n\\n    function setExcludeFromMaxTransactionLimit(address account, bool exclude) external onlyOwner _maxTransactionAvailable {\\n        require(_isExcludedFromMaxTxLimit[account] != exclude, \\\"Account is already set to that state\\\");\\n        _isExcludedFromMaxTxLimit[account] = exclude;\\n        emit ExcludedFromMaxTransactionLimit(account, exclude);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"router_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"walletToWalletTransferWithoutFee_\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"maxTransactionLimitAvailable_\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"maxTransactionRateBuy_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTransactionRateSell_\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"maxWalletLimitAvailable_\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"maxWalletLimitRate_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyFee_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellFee_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityShare_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketingShare_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"charityShare_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"marketingWallet_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"charityWallet_\",\"type\":\"address\"}],\"internalType\":\"struct SugarYield.ConstructorArgument\",\"name\":\"_arg\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"charityWallet\",\"type\":\"address\"}],\"name\":\"CharityWalletChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeFromFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludedFromMaxTransactionLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludedFromMaxWalletLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidityShare\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketingShare\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"charityShare\",\"type\":\"uint256\"}],\"name\":\"FeeSharesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sellFee\",\"type\":\"uint256\"}],\"name\":\"FeesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"marketingWallet\",\"type\":\"address\"}],\"name\":\"MarketingWalletChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxTransferRateBuy\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxTransferRateSell\",\"type\":\"uint256\"}],\"name\":\"MaxTransactionLimitRatesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"maxTransactionLimit\",\"type\":\"bool\"}],\"name\":\"MaxTransactionLimitStateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxWalletLimitRate\",\"type\":\"uint256\"}],\"name\":\"MaxWalletLimitRateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"maxWalletLimit\",\"type\":\"bool\"}],\"name\":\"MaxWalletLimitStateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetAutomatedMarketMakerPair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bnbReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiqudity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bnbSend\",\"type\":\"uint256\"}],\"name\":\"SwapAndSendFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum TokenClass\",\"name\":\"tokenClass\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"}],\"name\":\"TokenCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"}],\"name\":\"UpdateUniswapV2Router\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"automatedMarketMakerPairs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_charityWallet\",\"type\":\"address\"}],\"name\":\"changeCharityWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_marketingWallet\",\"type\":\"address\"}],\"name\":\"changeMarketingWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"charityShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"charityWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"claimStuckTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"enableWalletToWalletTransferWithoutFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromMaxTransaction\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromMaxWalletLimit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTransactionAvailable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTransactionLimitEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTransferAmountBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTransferAmountSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWalletAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWalletAvailable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWalletLimitEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setEnableMaxTransactionLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"setEnableMaxWalletLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exclude\",\"type\":\"bool\"}],\"name\":\"setExcludeFromMaxTransactionLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exclude\",\"type\":\"bool\"}],\"name\":\"setExcludeFromMaxWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxTransactionRateBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxTransactionRateSell\",\"type\":\"uint256\"}],\"name\":\"setMaxTransactionRates_Denominator1000\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_val\",\"type\":\"uint256\"}],\"name\":\"setMaxWalletRate_Denominator1000\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"setSwapTokensAtAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTokensAtAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketingFeeShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidityFeeShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_charityShare\",\"type\":\"uint256\"}],\"name\":\"updateFeeShares\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_buyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sellFee\",\"type\":\"uint256\"}],\"name\":\"updateFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"walletToWalletTransferWithoutFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SugarYield", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000022000000000000000000000000000000000000000000000000000000000000002600000000000000000000000000000000000000000000000000000000001312d0000000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006c6b935b8bbd40000000000000000000000000000000000000000000000000006c6b935b8bbd400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006c6b935b8bbd400000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000028000000000000000000000000000000000000000000000000000000000000002800000000000000000000000000000000000000000000000000000000000000140000000000000000000000008935ed83d52a378f42d959cebcab1410f827ce9d000000000000000000000000d3f8df29e8b47faf3c5af652a16a1944b4625cc9000000000000000000000000000000000000000000000000000000000000000a53756761725969656c640000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000055355474152000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}