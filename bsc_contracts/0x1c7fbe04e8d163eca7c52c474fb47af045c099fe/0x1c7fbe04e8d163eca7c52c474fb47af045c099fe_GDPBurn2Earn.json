{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\r\n     *   a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\r\n     *   {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\r\n     *   a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\r\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\r\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the address zero.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n}\r\n\r\n\r\ninterface IERC20 {\r\n    function decimals() external view returns (uint256);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\nabstract contract Ownable {\r\n    address internal _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() {\r\n        address msgSender = msg.sender;\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == msg.sender, \"!owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"new is 0\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ninterface ISwapRouter {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n}\r\n\r\ninterface ISwapPair {\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function kLast() external view returns (uint);\r\n\r\n    function sync() external;\r\n}\r\n\r\n\r\ncontract GDPBurn2Earn is Ownable {\r\n\r\n    address public usdtAddress = address(0x55d398326f99059fF775485246999027B3197955);\r\n    address public gdpAddress = address(0x8624B3A4F29620390d06286DF207F6791C243389);\r\n    address public burnAddress = address(0x000000000000000000000000000000000000dEaD);\r\n    address public pairAddress = address(0xC69d7310a07582015a34cD057a49928bc7754797);\r\n    address public adminAddress = address(0xcdf5A3eEF15236696c0bbeE2A78433E871e64e10);\r\n    ISwapRouter private immutable _swapRouter;\r\n    uint256 private constant MAX = ~uint256(0);\r\n\r\n    mapping(address => address) refAddress;\r\n    mapping(address => uint256) validRefNum;\r\n\r\n    struct Product {\r\n        uint256 amount;\r\n        uint256 claimed;\r\n        uint256 pid;\r\n        uint256 timestamp;\r\n    }\r\n\r\n    mapping (address => Product[]) private ProductA;\r\n    mapping (address => Product[]) private ProductB;\r\n    mapping (address => Product[]) private ProductC;\r\n    mapping (address => Product[]) private AllProduct;\r\n\r\n    uint256 public totalBurnValue;\r\n    uint256 public totalReward;\r\n    uint256 public totalTeamReward;\r\n\r\n    mapping (address => uint256) private teamReward;\r\n    mapping (address => uint256) private teamTotalReward;\r\n    mapping (address => uint256) private teamTotalBurnValue;\r\n    mapping (address => bool) private valUsed;\r\n    \r\n    constructor(){\r\n        ISwapRouter swapRouter = ISwapRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n        _swapRouter = swapRouter;\r\n        IERC20 token = IERC20(usdtAddress);\r\n        token.approve(address(0x10ED43C718714eb63d5aA57B78B54704E256024E), MAX);\r\n    }\r\n\r\n    function joinMing(address _token, uint256 amount, address ref) public {\r\n        require(msg.sender != address(ref), \"EOR\");\r\n        if (_token == usdtAddress){\r\n            IERC20 token = IERC20(_token);\r\n            bool res = token.transferFrom(msg.sender, address(this), amount);\r\n            require(res, \"Transfer error\");\r\n            swapToken2Burn(amount);\r\n            buildPkg(amount);\r\n            if (amount >= 100 * 1e18 && !valUsed[msg.sender]){\r\n                refAddress[msg.sender] = ref;\r\n                valUsed[msg.sender] = true;\r\n                validRefNum[address(ref)] = validRefNum[address(ref)] + 1;\r\n            }\r\n            if (refAddress[msg.sender] != address(0)){\r\n                teamTotalBurnValue[address(refAddress[msg.sender])] = teamTotalBurnValue[address(refAddress[msg.sender])] + amount;\r\n            }\r\n        }else if (_token == gdpAddress){\r\n            IERC20 token = IERC20(_token);\r\n            bool res = token.transferFrom(msg.sender, burnAddress, amount);\r\n            require(res, \"Transfer error\");\r\n            ISwapPair mainPair = ISwapPair(pairAddress);\r\n            (uint r0, uint256 r1,) = mainPair.getReserves();\r\n            uint256 usdtValue = _swapRouter.quote(amount, r1, r0);\r\n            buildPkg(usdtValue);\r\n            if (usdtValue >= 100 * 1e18 && !valUsed[msg.sender]){\r\n                refAddress[msg.sender] = ref;\r\n                valUsed[msg.sender] = true;\r\n                validRefNum[address(ref)] = validRefNum[address(ref)] + 1;\r\n            }\r\n            if (refAddress[msg.sender] != address(0)){\r\n                teamTotalBurnValue[address(refAddress[msg.sender])] = teamTotalBurnValue[address(refAddress[msg.sender])] + usdtValue;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    function caculTeamReward(address _owner, uint256 _amount)  private {\r\n        if(refAddress[_owner] != address(0)){\r\n            uint256 rewardAmount = _amount * 50 / 1000;\r\n            uint256 enableReward = 0;\r\n            address tempOwner = _owner;\r\n            for (uint i; i < 10; i++) \r\n            {\r\n                if (tempOwner == address(0)){\r\n                    continue ;\r\n                }\r\n                address upper = refAddress[tempOwner];\r\n                if (upper != address(0)){\r\n                    if(validRefNum[address(upper)] > i){\r\n                        teamReward[address(upper)] = teamReward[address(upper)] + rewardAmount;\r\n                        teamTotalReward[address(upper)] = teamTotalReward[address(upper)] + rewardAmount;\r\n                        enableReward = enableReward + rewardAmount;\r\n                    }\r\n                    tempOwner = address(upper);\r\n                }else {\r\n                    tempOwner = address(0);\r\n                }\r\n            }\r\n            totalTeamReward = totalTeamReward + enableReward;\r\n        }\r\n    }\r\n\r\n    function getAllProduct(address owner) public view returns (Product[] memory pl){\r\n        return AllProduct[owner];\r\n    }\r\n\r\n    function minerInfo(address owner, uint256 pId) public view  returns (Product[] memory pl){\r\n        if (pId == 0){\r\n            return ProductA[owner];\r\n        }else if (pId == 1){\r\n            return ProductB[owner];\r\n        }else if (pId == 2){\r\n            return ProductC[owner];\r\n        }\r\n    }\r\n\r\n    function claimProfit() public returns(bool _res) {\r\n        Product[] storage pLA = ProductA[msg.sender];\r\n        uint256 totalProfit = 0;\r\n        for (uint i = 0; i < pLA.length; i++) \r\n        {\r\n            if(pLA[i].claimed < pLA[i].amount){\r\n                uint256 times = (block.timestamp - pLA[i].timestamp) / 24 hours;\r\n                if (times > 0){\r\n                    uint256 profit = (times * pLA[i].amount / 100 ) - pLA[i].claimed;\r\n                    pLA[i].claimed = pLA[i].claimed + profit;\r\n                    totalProfit += profit;\r\n                }\r\n            }\r\n        }\r\n        Product[] storage pLB = ProductB[msg.sender];\r\n        for (uint i = 0; i < pLB.length; i++) \r\n        {\r\n            if(pLB[i].claimed < pLB[i].amount){\r\n                uint256 times = (block.timestamp - pLB[i].timestamp) / 24 hours;\r\n                if (times > 0){\r\n                    uint256 profit = (times * pLB[i].amount / 100 ) - pLB[i].claimed;\r\n                    pLB[i].claimed = pLB[i].claimed + profit;\r\n                    totalProfit += profit;\r\n                }\r\n            }\r\n        }\r\n        Product[] storage pLC = ProductC[msg.sender];\r\n        for (uint i = 0; i < pLC.length; i++) \r\n        {\r\n            if(pLC[i].claimed < pLC[i].amount){\r\n                uint256 times = (block.timestamp - pLC[i].timestamp) / 24 hours;\r\n                if (times > 0){\r\n                    uint256 profit = (times * pLC[i].amount / 100 ) - pLC[i].claimed;\r\n                    pLC[i].claimed = pLC[i].claimed + profit;\r\n                    totalProfit += profit;\r\n                }\r\n            }\r\n        }\r\n        ISwapPair mainPair = ISwapPair(pairAddress);\r\n        (uint r0, uint256 r1,) = mainPair.getReserves();\r\n        uint256 rAmount = _swapRouter.quote(totalProfit,r0, r1);\r\n        IERC20 token = IERC20(gdpAddress);\r\n        require(token.balanceOf(address(this)) >= rAmount, \"Insufficient balance\");\r\n        _res = token.transfer(msg.sender, rAmount);\r\n        require(_res, \"Transfer error\");\r\n        caculTeamReward(msg.sender, totalProfit);\r\n        totalReward = totalReward + totalProfit;\r\n        return _res;\r\n    }\r\n\r\n    function claimTeamReward() public returns(bool _res) {\r\n        require(teamReward[msg.sender] > 0, \"Insufficient Reward\");\r\n        ISwapPair mainPair = ISwapPair(pairAddress);\r\n        (uint r0, uint256 r1,) = mainPair.getReserves();\r\n        uint256 rAmount = _swapRouter.quote(teamReward[msg.sender],r0, r1);\r\n        IERC20 token = IERC20(gdpAddress);\r\n        require(token.balanceOf(address(this)) >= rAmount, \"Insufficient balance\");\r\n        _res = token.transfer(msg.sender, rAmount);\r\n        require(_res, \"Transfer error\");\r\n        return _res;\r\n    }\r\n\r\n    function withdraw() public returns(bool _res) {\r\n        IERC20 token = IERC20(gdpAddress);\r\n        _res = token.transfer(address(adminAddress), token.balanceOf(address(this)));\r\n        return _res;\r\n    }\r\n\r\n    function profitInfo(address owner) public view  returns (uint256 totalProfit){\r\n        Product[] memory pLA = ProductA[address(owner)];\r\n        for (uint i = 0; i < pLA.length; i++) \r\n        {\r\n            if(pLA[i].claimed < pLA[i].amount){\r\n                uint256 times = (block.timestamp - pLA[i].timestamp) / 24 hours;\r\n                if (times > 0){\r\n                    uint256 profit = (times * pLA[i].amount / 100 ) - pLA[i].claimed;\r\n                    totalProfit += profit;\r\n                }\r\n            }\r\n        }\r\n        Product[] memory pLB = ProductB[address(owner)];\r\n        for (uint i = 0; i < pLB.length; i++) \r\n        {\r\n            uint256 times = (block.timestamp - pLB[i].timestamp) / 24 hours;\r\n            if (times > 0){\r\n                uint256 profit = (times * pLB[i].amount / 100 ) - pLB[i].claimed;\r\n                totalProfit += profit;\r\n            }\r\n        }\r\n        Product[] memory pLC = ProductC[address(owner)];\r\n        for (uint i = 0; i < pLC.length; i++) \r\n        {\r\n            uint256 times = (block.timestamp - pLC[i].timestamp) / 24 hours;\r\n            if (times > 0){\r\n                uint256 profit = (times * pLC[i].amount / 100 ) - pLC[i].claimed;\r\n                totalProfit += profit;\r\n            }\r\n        }\r\n        return totalProfit;\r\n    }\r\n\r\n    function buildPkg(uint256 amount) private {\r\n        \r\n        if (amount < 1001 * 1e18){\r\n            ProductA[msg.sender].push(Product(amount*2,0,0,block.timestamp));\r\n            AllProduct[msg.sender].push(Product(amount*2,0,0,block.timestamp));\r\n        }else if (amount >= 1001 * 1e18 && amount < 5001 * 1e18){\r\n            ProductB[msg.sender].push(Product(amount*5/2,0,1,block.timestamp));\r\n            AllProduct[msg.sender].push(Product(amount*5/2,0,1,block.timestamp));\r\n        }else if (amount >= 5001 * 1e18){\r\n            ProductC[msg.sender].push(Product(amount*3,0,2,block.timestamp));\r\n            AllProduct[msg.sender].push(Product(amount*3,0,2,block.timestamp));\r\n        }\r\n        totalBurnValue = totalBurnValue + amount;\r\n    }\r\n\r\n    function swapToken2Burn(uint256 tokenAmount) private {\r\n        address[] memory path = new address[](2);\r\n        path[0] = usdtAddress;\r\n        path[1] = gdpAddress;\r\n        _swapRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0,\r\n            path,\r\n            burnAddress,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function getTotalBurnValue() public view returns(uint256 v){\r\n        return totalBurnValue;\r\n    }\r\n    \r\n    function getTeamReward(address _owner) public view returns(uint256 v){\r\n        return teamReward[address(_owner)];\r\n    }\r\n\r\n    function getTotalTeamReward(address _owner) public view returns(uint256 v){\r\n        return teamTotalReward[address(_owner)];\r\n    }\r\n\r\n    function getTeamTotalBurnValue(address _owner) public view returns(uint256 v){\r\n        return teamTotalBurnValue[address(_owner)];\r\n    }\r\n\r\n    function getRefAddress(address _owner) public view returns(address v){\r\n        return refAddress[address(_owner)];\r\n    }\r\n\r\n    function getValidRefNum(address _owner) public view returns(uint256 v){\r\n        return validRefNum[address(_owner)];\r\n    }\r\n\r\n    function getTotalReward() public view returns(uint256 v){\r\n        return totalReward;\r\n    }\r\n\r\n    function getAllTeamReward() public view returns(uint256 v){\r\n        return totalTeamReward;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"adminAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimProfit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_res\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimTeamReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_res\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gdpAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getAllProduct\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct GDPBurn2Earn.Product[]\",\"name\":\"pl\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllTeamReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"v\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getRefAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"v\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getTeamReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"v\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getTeamTotalBurnValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"v\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalBurnValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"v\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"v\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getTotalTeamReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"v\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getValidRefNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"v\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"}],\"name\":\"joinMing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pId\",\"type\":\"uint256\"}],\"name\":\"minerInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct GDPBurn2Earn.Product[]\",\"name\":\"pl\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pairAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"profitInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalProfit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBurnValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTeamReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdtAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_res\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "GDPBurn2Earn", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://647adf406592b0d869d3e8869eca7d0e943ce2a805fc236cb52f60a7b058d35d"}