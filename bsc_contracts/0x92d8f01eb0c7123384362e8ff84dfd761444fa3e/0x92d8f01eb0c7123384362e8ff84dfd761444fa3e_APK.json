{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity =0.4.26;\r\n\r\n// SafeMath methods\r\nlibrary SafeMath {\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a + _b;\r\n        require(c >= _a, \"unsafe add math\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_a >= _b, \"unsafe sub math\");\r\n        return _a - _b;\r\n    }\r\n\r\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a * _b;\r\n        require(_a == 0 || c / _a == _b, \"unsafe mul math\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b != 0, \"unsafe div math\");\r\n        uint256 c = _a / _b;\r\n        return c;\r\n    }\r\n}\r\n\r\n// Contract must have an owner\r\ncontract Owned {\r\n    address public owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function setOwner(address _owner) public onlyOwner {\r\n        owner = _owner;\r\n    }\r\n}\r\n\r\n// Standard ERC20 Token Interface\r\ninterface ERC20Token {\r\n    function name() external view returns (string name_);\r\n\r\n    function symbol() external view returns (string symbol_);\r\n\r\n    function decimals() external view returns (uint8 decimals_);\r\n\r\n    function totalSupply() external view returns (uint256 totalSupply_);\r\n\r\n    function balanceOf(address _owner) external view returns (uint256 _balance);\r\n\r\n    function transfer(address _to, uint256 _value) external returns (bool _success);\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) external returns (bool _success);\r\n\r\n    function approve(address _spender, uint256 _value) external returns (bool _success);\r\n\r\n    function allowance(address _owner, address _spender) external view returns (uint256 _remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n// the main ERC20-compliant multi-timelock enabled contract\r\ncontract APK is Owned, ERC20Token {\r\n    using SafeMath for uint256;\r\n\r\n    string private constant standard = \"202201120000001\";\r\n    string private constant version = \"v1.0\";\r\n    string private name_ = \"ApeKing\";\r\n    string private symbol_ = \"APK\";\r\n    uint8 private decimals_ = 18;\r\n    uint256 private totalSupply_ = uint256(10000000000000) * uint256(10)**uint256(decimals_);\r\n    uint256 private PPM = 1000000;\r\n    uint256 private burnRate = 50000;\r\n    uint256 private burnLimit = uint256(1000000) * uint256(10)**uint256(decimals_);\r\n\r\n    mapping(address => uint256) private balanceP;\r\n    mapping(address => mapping(address => uint256)) private allowed;\r\n\r\n    mapping(address => uint256[]) private lockTime;\r\n    mapping(address => uint256[]) private lockValue;\r\n    mapping(address => uint256) private lockNum;\r\n    uint256 private later = 0;\r\n    uint256 private earlier = 0;\r\n    bool private mintable_ = false;\r\n\r\n    // burn token event\r\n    event Burn(address indexed _from, uint256 _value);\r\n\r\n    // mint token event\r\n    event Mint(address indexed _to, uint256 _value);\r\n\r\n    // timelock-related events\r\n    event TransferLocked(address indexed _from, address indexed _to, uint256 _time, uint256 _value);\r\n    event TokenUnlocked(address indexed _address, uint256 _value);\r\n\r\n    // safety method-related events\r\n    event WrongTokenEmptied(address indexed _token, address indexed _addr, uint256 _amount);\r\n    event WrongEtherEmptied(address indexed _addr, uint256 _amount);\r\n\r\n    // constructor for the ERC20 Token\r\n    constructor() public {\r\n        balanceP[msg.sender] = totalSupply_;\r\n        emit Transfer(address(0x0), msg.sender, totalSupply_);\r\n    }\r\n\r\n    modifier validAddress(address _address) {\r\n        require(_address != 0x0);\r\n        _;\r\n    }\r\n\r\n    modifier isMintable() {\r\n        require(mintable_);\r\n        _;\r\n    }\r\n\r\n    // fast-forward the timelocks for all accounts\r\n    function setUnlockEarlier(uint256 _earlier) public onlyOwner {\r\n        earlier = earlier.add(_earlier);\r\n    }\r\n\r\n    // delay the timelocks for all accounts\r\n    function setUnlockLater(uint256 _later) public onlyOwner {\r\n        later = later.add(_later);\r\n    }\r\n\r\n    // owner may permanently disable minting\r\n    function disableMint() public onlyOwner isMintable {\r\n        mintable_ = false;\r\n    }\r\n\r\n    // show if the token is still mintable\r\n    function mintable() public view returns (bool) {\r\n        return mintable_;\r\n    }\r\n\r\n    // standard ERC20 name function\r\n    function name() public view returns (string) {\r\n        return name_;\r\n    }\r\n\r\n    // standard ERC20 symbol function\r\n    function symbol() public view returns (string) {\r\n        return symbol_;\r\n    }\r\n\r\n    // standard ERC20 decimals function\r\n    function decimals() public view returns (uint8) {\r\n        return decimals_;\r\n    }\r\n\r\n    // standard ERC20 totalSupply function\r\n    function totalSupply() public view returns (uint256) {\r\n        return totalSupply_;\r\n    }\r\n\r\n    // standard ERC20 allowance function\r\n    function allowance(address _owner, address _spender) external view returns (uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    // show unlocked balance of an account\r\n    function balanceUnlocked(address _address) public view returns (uint256 _balance) {\r\n        _balance = balanceP[_address];\r\n        uint256 i = 0;\r\n        while (i < lockNum[_address]) {\r\n            if (now.add(earlier) >= lockTime[_address][i].add(later)) _balance = _balance.add(lockValue[_address][i]);\r\n            i++;\r\n        }\r\n        return _balance;\r\n    }\r\n\r\n    // show timelocked balance of an account\r\n    function balanceLocked(address _address) public view returns (uint256 _balance) {\r\n        _balance = 0;\r\n        uint256 i = 0;\r\n        while (i < lockNum[_address]) {\r\n            if (now.add(earlier) < lockTime[_address][i].add(later)) _balance = _balance.add(lockValue[_address][i]);\r\n            i++;\r\n        }\r\n        return _balance;\r\n    }\r\n\r\n    // standard ERC20 balanceOf with timelock added\r\n    function balanceOf(address _address) public view returns (uint256 _balance) {\r\n        _balance = balanceP[_address];\r\n        uint256 i = 0;\r\n        while (i < lockNum[_address]) {\r\n            _balance = _balance.add(lockValue[_address][i]);\r\n            i++;\r\n        }\r\n        return _balance;\r\n    }\r\n\r\n    // show timelocks in an account\r\n    function showLockTimes(address _address) public view validAddress(_address) returns (uint256[] _times) {\r\n        uint256 i = 0;\r\n        uint256[] memory tempLockTime = new uint256[](lockNum[_address]);\r\n        while (i < lockNum[_address]) {\r\n            tempLockTime[i] = lockTime[_address][i].add(later).sub(earlier);\r\n            i++;\r\n        }\r\n        return tempLockTime;\r\n    }\r\n\r\n    // show values locked in an account's timelocks\r\n    function showLockValues(address _address) public view validAddress(_address) returns (uint256[] _values) {\r\n        return lockValue[_address];\r\n    }\r\n\r\n    function showLockNum(address _address) public view validAddress(_address) returns (uint256 _lockNum) {\r\n        return lockNum[_address];\r\n    }\r\n\r\n    // Calculate and process the timelock states of an account\r\n    function calcUnlock(address _address) private {\r\n        uint256 i = 0;\r\n        uint256 j = 0;\r\n        uint256[] memory currentLockTime;\r\n        uint256[] memory currentLockValue;\r\n        uint256[] memory newLockTime = new uint256[](lockNum[_address]);\r\n        uint256[] memory newLockValue = new uint256[](lockNum[_address]);\r\n        currentLockTime = lockTime[_address];\r\n        currentLockValue = lockValue[_address];\r\n        while (i < lockNum[_address]) {\r\n            if (now.add(earlier) >= currentLockTime[i].add(later)) {\r\n                balanceP[_address] = balanceP[_address].add(currentLockValue[i]);\r\n                emit TokenUnlocked(_address, currentLockValue[i]);\r\n            } else {\r\n                newLockTime[j] = currentLockTime[i];\r\n                newLockValue[j] = currentLockValue[i];\r\n                j++;\r\n            }\r\n            i++;\r\n        }\r\n        uint256[] memory trimLockTime = new uint256[](j);\r\n        uint256[] memory trimLockValue = new uint256[](j);\r\n        i = 0;\r\n        while (i < j) {\r\n            trimLockTime[i] = newLockTime[i];\r\n            trimLockValue[i] = newLockValue[i];\r\n            i++;\r\n        }\r\n        lockTime[_address] = trimLockTime;\r\n        lockValue[_address] = trimLockValue;\r\n        lockNum[_address] = j;\r\n    }\r\n\r\n    // standard ERC20 transfer\r\n    function transfer(address _to, uint256 _value) public validAddress(_to) returns (bool _success) {\r\n        if (lockNum[msg.sender] > 0) calcUnlock(msg.sender);\r\n        require(balanceP[msg.sender] >= _value && _value >= 0);\r\n        balanceP[msg.sender] = balanceP[msg.sender].sub(_value);\r\n        uint256 lValue = tBurn(_value);\r\n        balanceP[_to] = balanceP[_to].add(lValue);\r\n        emit Transfer(msg.sender, _to, lValue);\r\n        return true;\r\n    }\r\n\r\n    // transfer Token with timelocks\r\n    function transferLocked(\r\n        address _to,\r\n        uint256[] _time,\r\n        uint256[] _value\r\n    ) public validAddress(_to) returns (bool _success) {\r\n        require(_value.length == _time.length);\r\n\r\n        if (lockNum[msg.sender] > 0) calcUnlock(msg.sender);\r\n        uint256 i = 0;\r\n        uint256 totalValue = 0;\r\n        while (i < _value.length) {\r\n            totalValue = totalValue.add(_value[i]);\r\n            i++;\r\n        }\r\n        require(balanceP[msg.sender] >= totalValue && totalValue >= 0);\r\n        require(lockNum[_to].add(_time.length) <= 42);\r\n        i = 0;\r\n        while (i < _time.length) {\r\n            uint256 lValue = tBurn(_value[i]);\r\n\r\n            if (_value[i] > 0) {\r\n                balanceP[msg.sender] = balanceP[msg.sender].sub(_value[i]);\r\n                lockTime[_to].length = lockNum[_to] + 1;\r\n                lockValue[_to].length = lockNum[_to] + 1;\r\n                lockTime[_to][lockNum[_to]] = now.add(_time[i]).add(earlier).sub(later);\r\n                lockValue[_to][lockNum[_to]] = lValue;\r\n                lockNum[_to]++;\r\n            }\r\n            \r\n            // emit custom TransferLocked event\r\n            emit TransferLocked(msg.sender, _to, _time[i], lValue);\r\n\r\n            // emit standard Transfer event for wallets\r\n            emit Transfer(msg.sender, _to, lValue);\r\n\r\n            i++;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // TransferFrom Token with timelocks\r\n    function transferLockedFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256[] _time,\r\n        uint256[] _value\r\n    ) public validAddress(_from) validAddress(_to) returns (bool success) {\r\n        require(_value.length == _time.length);\r\n\r\n        if (lockNum[_from] > 0) calcUnlock(_from);\r\n        uint256 i = 0;\r\n        uint256 totalValue = 0;\r\n        while (i < _value.length) {\r\n            totalValue = totalValue.add(_value[i]);\r\n            i++;\r\n        }\r\n        require(balanceP[_from] >= totalValue && totalValue >= 0 && allowed[_from][msg.sender] >= totalValue);\r\n        require(lockNum[_to].add(_time.length) <= 42);\r\n        i = 0;\r\n        while (i < _time.length) {\r\n            uint256 lValue = tBurn(_value[i]);\r\n\r\n            if (_value[i] > 0) {\r\n                balanceP[_from] = balanceP[_from].sub(_value[i]);\r\n                allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value[i]);\r\n                lockTime[_to].length = lockNum[_to] + 1;\r\n                lockValue[_to].length = lockNum[_to] + 1;\r\n                lockTime[_to][lockNum[_to]] = now.add(_time[i]).add(earlier).sub(later);\r\n                lockValue[_to][lockNum[_to]] = lValue;\r\n                lockNum[_to]++;\r\n            }\r\n\r\n            // emit custom TransferLocked event\r\n            emit TransferLocked(_from, _to, _time[i], lValue);\r\n\r\n            // emit standard Transfer event for wallets\r\n            emit Transfer(_from, _to, lValue);\r\n\r\n            i++;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // standard ERC20 transferFrom\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) public validAddress(_from) validAddress(_to) returns (bool _success) {\r\n        if (lockNum[_from] > 0) calcUnlock(_from);\r\n        require(balanceP[_from] >= _value && _value >= 0 && allowed[_from][msg.sender] >= _value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        balanceP[_from] = balanceP[_from].sub(_value);\r\n        uint256 lValue = tBurn(_value);\r\n        balanceP[_to] = balanceP[_to].add(lValue);\r\n        emit Transfer(_from, _to, lValue);\r\n        return true;\r\n    }\r\n\r\n    // should only be called when first setting an allowed\r\n    function approve(address _spender, uint256 _value) public validAddress(_spender) returns (bool _success) {\r\n        if (lockNum[msg.sender] > 0) calcUnlock(msg.sender);\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    // increase or decrease allowed\r\n    function increaseApproval(address _spender, uint256 _value)\r\n        public\r\n        validAddress(_spender)\r\n        returns (bool _success)\r\n    {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_value);\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval(address _spender, uint256 _value)\r\n        public\r\n        validAddress(_spender)\r\n        returns (bool _success)\r\n    {\r\n        if (_value >= allowed[msg.sender][_spender]) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = allowed[msg.sender][_spender].sub(_value);\r\n        }\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    function tBurn(uint256 _value) private returns (uint256) {\r\n        if (_value <= 0 && totalSupply_ <= burnLimit) {\r\n            return _value;\r\n        }\r\n        uint256 limited = totalSupply_.sub(burnLimit);\r\n        uint256 burned = _value.mul(burnRate).div(PPM);\r\n        burned = burned > limited ? limited : burned;\r\n        totalSupply_ = totalSupply_.sub(burned);\r\n        emit Burn(msg.sender, burned);\r\n        emit Transfer(msg.sender, address(0x0), burned);\r\n        return _value.sub(burned);\r\n    }\r\n\r\n    // owner may burn own token\r\n    function burn(uint256 _value) public onlyOwner returns (bool _success) {\r\n        if (lockNum[msg.sender] > 0) calcUnlock(msg.sender);\r\n        require(balanceP[msg.sender] >= _value && _value >= 0);\r\n        balanceP[msg.sender] = balanceP[msg.sender].sub(_value);\r\n        totalSupply_ = totalSupply_.sub(_value);\r\n        emit Burn(msg.sender, _value);\r\n        emit Transfer(msg.sender, address(0x0), _value);\r\n        return true;\r\n    }\r\n\r\n    // owner may mint new token and increase total supply\r\n    function mint(uint256 _value) public onlyOwner isMintable returns (bool _success) {\r\n        balanceP[msg.sender] = balanceP[msg.sender].add(_value);\r\n        totalSupply_ = totalSupply_.add(_value);\r\n        emit Mint(msg.sender, _value);\r\n        emit Transfer(address(0x0), msg.sender, _value);\r\n        return true;\r\n    }\r\n\r\n    // safety methods\r\n    function() public payable {\r\n        revert();\r\n    }\r\n\r\n    function emptyWrongToken(address _addr) public onlyOwner {\r\n        ERC20Token wrongToken = ERC20Token(_addr);\r\n        uint256 amount = wrongToken.balanceOf(address(this));\r\n        require(amount > 0);\r\n        require(wrongToken.transfer(msg.sender, amount));\r\n\r\n        emit WrongTokenEmptied(_addr, msg.sender, amount);\r\n    }\r\n\r\n    // shouldn't happen, just in case\r\n    function emptyWrongEther() public onlyOwner {\r\n        uint256 amount = address(this).balance;\r\n        require(amount > 0);\r\n        msg.sender.transfer(amount);\r\n\r\n        emit WrongEtherEmptied(msg.sender, amount);\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"balanceUnlocked\",\"outputs\":[{\"name\":\"_balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_time\",\"type\":\"uint256[]\"},{\"name\":\"_value\",\"type\":\"uint256[]\"}],\"name\":\"transferLockedFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableMint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"balanceLocked\",\"outputs\":[{\"name\":\"_balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"_balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_time\",\"type\":\"uint256[]\"},{\"name\":\"_value\",\"type\":\"uint256[]\"}],\"name\":\"transferLocked\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"showLockTimes\",\"outputs\":[{\"name\":\"_times\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"showLockValues\",\"outputs\":[{\"name\":\"_values\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_later\",\"type\":\"uint256\"}],\"name\":\"setUnlockLater\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"emptyWrongToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"emptyWrongEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_earlier\",\"type\":\"uint256\"}],\"name\":\"setUnlockEarlier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"showLockNum\",\"outputs\":[{\"name\":\"_lockNum\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_time\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"TransferLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"TokenUnlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"WrongTokenEmptied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"WrongEtherEmptied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]", "ContractName": "APK", "CompilerVersion": "v0.4.26+commit.4563c3fc", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://a7e643af5073caec21cafe2262eec7bbdcad16e113c1154fddfe1accc947d0b3"}