{"SourceCode": "pragma solidity 0.8.7;\r\n// SPDX-License-Identifier: Unlicensed\r\n// Developer: Cathal Mac Fadden\r\n// dev@tswiftytoken.com\r\n// All code is copyrighted and cannot be used unless permission is authorized. Contact me on the email above. \r\n//  _______ _______          _______ ______ _________     __\r\n// |__   __/ ____\\ \\        / /_   _|  ____|__   __\\ \\   / /\r\n//    | | | (___  \\ \\  /\\  / /  | | | |__     | |   \\ \\_/ / \r\n//    | |  \\___ \\  \\ \\/  \\/ /   | | |  __|    | |    \\   /  \r\n//    | |  ____) |  \\  /\\  /   _| |_| |       | |     | |   \r\n//    |_| |_____/    \\/  \\/   |_____|_|       |_|     |_|   \r\n//\r\n\r\n\r\ncontract Context {\r\n  constructor () { }\r\n  function _msgSender() internal view returns (address payable) {\r\n    return payable(msg.sender);\r\n  }\r\n  function _msgData() internal view returns (bytes memory) {\r\n    this; \r\n    return msg.data;\r\n  }\r\n}\r\n\r\ncontract Ownable is Context {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  constructor () {\r\n    address msgSender = _msgSender();\r\n    _owner = msgSender;\r\n    emit OwnershipTransferred(address(0), msgSender);\r\n  }\r\n\r\n  function isContractAddress(address addr) internal view returns(bool) {\r\n    return addr.code.length != 0;\r\n  }\r\n\r\n  function owner() public view returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n    _;\r\n  }\r\n\r\n  function transferOwnership(address newOwner) public onlyOwner() {\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  function _transferOwnership(address newOwner) internal {\r\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\ninterface IBEP20 {\r\n\r\n  function totalSupply() external view returns (uint256);\r\n  function decimals() external view returns (uint8);\r\n  function symbol() external view returns (string memory);\r\n  function name() external view returns (string memory);\r\n  function getOwner() external view returns (address);\r\n  function balanceOf(address addr) external view returns (uint256);\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n  function allowance(address _owner, address spender) external view returns (uint256);\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ATSWIFTY is Context, IBEP20, Ownable {\r\n  using SafeMath for uint256;\r\n\r\n  bool public PcsTradingEnabled = false;\r\n  address public PcsPairAddress; \r\n\r\n  mapping (address => uint256) public _lastAccrueDate; \r\n  mapping (address => uint256) public _lastSellDate;\r\n  mapping (address => uint256) private _balances;\r\n  mapping (address => mapping (address => uint256)) private _allowances;\r\n  mapping (address => bool) public _isExcludedFromInterest;\r\n  mapping (address => bool) public _isExcludedFromTax;\r\n  mapping (address => uint256) public _accruedInterest;\r\n  mapping (address => uint256) public _interestRates;\r\n  mapping (address => uint256) public _previousInterestRate;\r\n  mapping (address => uint256) public _dateAddressLocked;\r\n\r\n  mapping (address => bool) public BlockedAddresses;    // Addresses that are prevented from Buying tokens. (we dont prevent selling). Used for stopping frontrunning bots. \r\n  mapping (address => bool) public LockedLPTokens;    // LP Tokens which are locked into the contract until the expiry date. \r\n  uint256 public LPUnlockDate;  // The date when any LockedLPTokens can be withdrawn. \r\n  address public LockedTeamFundsAddress;    // Team funds are locked into an address that is permanently prevented from selling its initial allocation. Team can only earn interest.\r\n  uint256 public LockedTeamFundsBalance;    // The amount of team funds that cannot be spent. \r\n\r\n  uint256 public MinutesBeforeInterest = 28 * 24 * 60;   // Representing as minutes to make testing easier. 28 days in production.\r\n  address payable public TaxStorageDestination;\r\n\r\n  uint256 private _standardInterestRate = 12;   // The standard base rate that everyone gets.\r\n  uint256 private _newAddressInterestRate = 20;   // A bonus rate that new addresses will receive until they sell.\r\n  uint256 private _unlockFeePercentage = 20;\r\n  bool private _allowSettingBonusRateAddresses = true;\r\n  uint256 private _yearInMinutes = 366 * 24 * 60;\r\n  bool private _claimingExternally = false;\r\n  uint256 private _lockMultiplier = 6;\r\n\r\n  address payable private _burnAddress = payable(0x000000000000000000000000000000000000dEaD); // Burn address used to burn a portion of tokens\r\n  address payable private _testPancakeswapContract;\r\n  address payable private _productionPancakeswapContract;\r\n  address payable private _pancakeswapRouterContract;\r\n\r\n  uint8 private _devPercentage = 1;\r\n  uint8 private _liquidityPercentage = 1; \r\n  uint8 private _burnPercentage = 1;\r\n  uint256 private _totalSupply;\r\n  uint8 private constant _decimals = 18;\r\n  string private constant _symbol = \"TSWIFTY\";\r\n  string private _name = _symbol;\r\n  uint256 private constant _billion = 1000000000;\r\n  uint256 private _decimalPointsCalc = 10 ** uint256(_decimals);\r\n\r\n  IUniswapV2Router02 private _pancakeswapV2Router; // The address of the PancakeSwap V2 Router\r\n\r\n  bool currentlySwapping;  \r\n\r\n  event Claim(address indexed claimAddress, uint256 interestClaimed);\r\n  event ExternalClaim(address indexed claimAddress, address indexed destinationAddress, uint256 interestClaimed);\r\n  event SwapAndLiquify(uint256 tokensSwapped, uint256 bnbReceived, uint256 tokensIntoLiqudity);\r\n  event AddressLocked(address indexed lockAddress, uint256 unlockDate, uint256 bonusInterestRate);\r\n  event PaidToUnlockAddress(address indexed unlockedAddress, uint256 feePaid);\r\n  event BonusRatesIssued(address[] indexed bonusAddresses, uint256 percentage);\r\n  event TeamFundsAddressChanged(address indexed oldTeamFundsAddress, address indexed newTeamFundsAddress);\r\n  event LPUnlockDateIncreased(uint256 oldDate, uint256 newDate);\r\n  event TradingEnabled();\r\n\r\n  constructor(address teamFundsAddress) payable {\r\n\r\n    LockedTeamFundsAddress = teamFundsAddress;\r\n    _totalSupply = 10 * _billion * _decimalPointsCalc;\r\n\r\n    uint256 TokensForLiquidity = (_totalSupply * 75) / 100; // 75% for sale and liquidity.\r\n    _balances[owner()] += TokensForLiquidity;\r\n    emit Transfer(address(0), owner(), TokensForLiquidity);   // Dist #1\r\n\r\n    uint256 TokensForAirdrop = _totalSupply / 200;  // 0.5% for airdrop\r\n    _balances[owner()] += TokensForAirdrop;\r\n    emit Transfer(address(0), owner(), TokensForAirdrop);           // Dist #2\r\n\r\n    uint256 TokensForSwiftDemandDistribution = (_totalSupply * 15) / 100;   // 15% for Swiftdemand conversion\r\n    _balances[owner()] += TokensForSwiftDemandDistribution;\r\n    emit Transfer(address(0), owner(), TokensForSwiftDemandDistribution);   // Dist #3\r\n    \r\n    uint256 TokensForTeam = (_totalSupply * 95) / 1000;    // 9.5% Locked team funds. Team can only spend the interest earned. \r\n    LockedTeamFundsBalance = TokensForTeam;\r\n    _balances[LockedTeamFundsAddress] += TokensForTeam;\r\n    accrueInterest(LockedTeamFundsAddress, false);\r\n    emit Transfer(address(0), LockedTeamFundsAddress, TokensForTeam);          // Dist #4\r\n  \r\n    _isExcludedFromInterest[owner()] = true;\r\n    _isExcludedFromTax[owner()] = true;\r\n    _isExcludedFromTax[LockedTeamFundsAddress] = true;\r\n    _isExcludedFromTax[address(this)] = true;\r\n    _isExcludedFromTax[address(0x0000000000000000000000000000000000000000)] = true;\r\n\r\n    TaxStorageDestination = payable(owner());\r\n    _testPancakeswapContract = payable(0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3);\r\n    _productionPancakeswapContract = payable(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n  }\r\n\r\n  receive() external payable {}\r\n  fallback() external payable {}\r\n\r\n  // Used to block certain addresses from buying. Like frontrunning bots. We never prevent anyone from selling.\r\n  function _transfer(address sender, address recipient, uint256 amount) internal {\r\n    require(BlockedAddresses[recipient] == false, \"Recipient address has been blocked. They cannot buy. Contact dev's if you think this is a mistake\");\r\n    require(_balances[sender] >= amount, \"BEP20: transfer amount exceeds balance\");\r\n\r\n    if(!PcsTradingEnabled && sender == PcsPairAddress)  // Prevents bots from sniping the addition of the liquidity pool\r\n    {\r\n      revert(\"Dex Trading has not been enabled yet.\");\r\n    }\r\n\r\n    if(sender == LockedTeamFundsAddress)\r\n    {\r\n      require(_balances[LockedTeamFundsAddress].sub(amount) >= LockedTeamFundsBalance, \"Cannot reduce balance below the locked team funds balance\");\r\n    }\r\n\r\n    if(!_claimingExternally && whenWillAddressUnlock(sender)  > block.timestamp)\r\n    {\r\n      revert(\"Transaction reverted because the address has been locked by the address owner.\");\r\n    }\r\n\r\n    uint256 taxAmount;\r\n\r\n    if(!currentlySwapping)\r\n    {\r\n      if(!_claimingExternally)  // If they are claiming externally then we dont want to accrue again, and we dont want to consider it a sale. \r\n        accrueInterest(sender, true);\r\n\r\n      accrueInterest(recipient, false);\r\n\r\n      if(_isExcludedFromTax[sender] || sender == TaxStorageDestination || recipient == TaxStorageDestination)\r\n      {\r\n        taxAmount = 0;\r\n      }\r\n      else\r\n      {\r\n        taxAmount = handleTaxes(sender, amount);\r\n      }\r\n\r\n      amount = amount.sub(taxAmount);\r\n    }\r\n\r\n    _balances[sender] = _balances[sender].sub(amount);\r\n    _balances[recipient] = _balances[recipient].add(amount);\r\n    emit Transfer(sender, recipient, amount);\r\n  }\r\n\r\n  function enableDexTrading() external onlyOwner {\r\n    PcsTradingEnabled = true;\r\n    emit TradingEnabled();\r\n  }\r\n\r\n  // Blocked addresses cannot buy. I want to be able to stop frontrunning bots from buying. We dont stop selling EVER.\r\n  function setBlockedAddressStatus(address addr, bool isBlocked) external onlyOwner {\r\n    BlockedAddresses[addr] = isBlocked;\r\n  }\r\n\r\n  // Used to maintain the safety of the team funds address. If for any reason we need to move the team funds to a new wallet we can use this.\r\n  // Contract owner has control, not the Team Funds Address. \r\n  function transferTeamFundsToNewAddress(address newTeamFundsAddress) external onlyOwner {\r\n    require(newTeamFundsAddress != address(0), \"Cannot be zero address.\");\r\n    require(!isContractAddress(newTeamFundsAddress), \"Cannot transfer to contract.\");\r\n\r\n    uint256 currentTeamFunds = _balances[LockedTeamFundsAddress];\r\n    _balances[LockedTeamFundsAddress] = 0;\r\n    _balances[newTeamFundsAddress] = currentTeamFunds;\r\n\r\n    accrueInterest(newTeamFundsAddress, false);   // Perform the initial accrue to setup the address correctly.\r\n\r\n    emit Transfer(LockedTeamFundsAddress, newTeamFundsAddress, currentTeamFunds);\r\n    emit TeamFundsAddressChanged(LockedTeamFundsAddress, newTeamFundsAddress);\r\n\r\n    LockedTeamFundsAddress = newTeamFundsAddress;\r\n  }\r\n\r\n  // This function will lock an address and prevent it from selling any tokens for 6x MinutesBeforeInterest.\r\n  // In exchange for locking your address you can restore your address to immediately earning interest after selling. \r\n  function lockSalesForBonusInterest() external {\r\n\r\n    uint256 unlockDate = whenWillAddressUnlock(msg.sender);\r\n    require(unlockDate < block.timestamp, \"Address is already locked.\");\r\n\r\n    accrueInterest(msg.sender, false);\r\n    _dateAddressLocked[msg.sender] = block.timestamp;\r\n    _previousInterestRate[msg.sender] = _interestRates[msg.sender];   // save the current rate so we can restore it after the address unlocked. \r\n    _interestRates[msg.sender] = 40;   \r\n    unlockDate = whenWillAddressUnlock(msg.sender);\r\n\r\n    emit AddressLocked(msg.sender, unlockDate, _interestRates[msg.sender]);\r\n  }\r\n\r\n  // Returns the unix time stamp of when the address will unlock. \r\n  // If the address is not locked it will return the current block timestamp.\r\n  function whenWillAddressUnlock(address addr) public view returns(uint256) {\r\n      if(_dateAddressLocked[addr] == 0)\r\n        return 0;\r\n      else\r\n        return _dateAddressLocked[addr] + ((MinutesBeforeInterest * 60) * _lockMultiplier);\r\n  }\r\n\r\n  function isAddressLocked(address addr) external view returns(bool){\r\n    return (whenWillAddressUnlock(addr) > block.timestamp);\r\n  }\r\n\r\n  // If the user has locked their address and they are willing to pay the unlock fee they can allow outbound transfers again.\r\n  // The unlock fee is a percentage of the current balance of the address, not the balance when the address was locked.  \r\n  function payToUnlockAddress() external {\r\n    require(_balances[msg.sender] > 0, \"Cannot unlock a zero balance address.\");\r\n    require(whenWillAddressUnlock(msg.sender)  > block.timestamp, \"Address is not locked.\");\r\n\r\n    accrueInterest(msg.sender, false);\r\n\r\n    uint256 unlockFee = (_balances[msg.sender] * _unlockFeePercentage) / 100; // Unlock fee.\r\n\r\n    uint256 burnAmount = unlockFee / 2;\r\n    uint256 taxFee = unlockFee - burnAmount;\r\n\r\n    _balances[msg.sender] -= unlockFee;\r\n    _balances[_burnAddress] += burnAmount;\r\n    _balances[TaxStorageDestination] += taxFee;\r\n\r\n    _dateAddressLocked[msg.sender] = 0;\r\n    _interestRates[msg.sender] = _standardInterestRate;\r\n\r\n    emit Transfer(msg.sender, _burnAddress, burnAmount); \r\n    emit Transfer(msg.sender, TaxStorageDestination, taxFee); \r\n    emit PaidToUnlockAddress(msg.sender, unlockFee);\r\n  }\r\n\r\n\r\n  // Gives the list of addresses a bonus rate which will be revoked if they ever sell even a single token. \r\n  // This will be used to encourage airdrop and converters to not sell once the trading goes live. \r\n  function setBonusRateAddresses(address[] calldata addresses, uint256 rate) external onlyOwner() {\r\n   \r\n   if(_allowSettingBonusRateAddresses)\r\n   {\r\n    for (uint i=0; i < addresses.length; i++) {\r\n        accrueInterest(addresses[i], false);  // Accrue any interest the address is due before setting the new rate. Prevents them earning the new rate on historical balances.\r\n         _previousInterestRate[addresses[i]] = rate;\r\n        _interestRates[addresses[i]] = rate;\r\n    }\r\n\r\n    emit BonusRatesIssued(addresses, rate);\r\n   }\r\n  }\r\n\r\n  // This function disables the ability to issue new bonus rates. Once the token is stable and initial promotions have been run we should probably disable it. \r\n  function disableNewBonusRateAddressesPermanently() external onlyOwner() {\r\n     _allowSettingBonusRateAddresses = false;\r\n  }\r\n\r\n  function getLastSaleDate(address addr) external view returns(uint256) {\r\n    return _lastSellDate[addr];\r\n  }\r\n\r\n  function getAccruedInterest(address addr) external view returns(uint256) {\r\n    return _accruedInterest[addr];\r\n  }\r\n\r\n  function getCurrentInterestRateForAddress(address addr) external view returns(uint256) {\r\n    uint256 unlockDate = whenWillAddressUnlock(addr);\r\n\r\n    if(_lastSellDate[addr] + (MinutesBeforeInterest * 60) >= block.timestamp)\r\n    {\r\n      return 0;   // The address is still being penalised for making a sale. \r\n    }\r\n    else if(unlockDate == 0)   // Address was never locked.\r\n    {\r\n      return _interestRates[addr];\r\n    }\r\n    else if(unlockDate != 0 && unlockDate > block.timestamp) // Address is still locked, so it earns the bonus interest currently stored in _interestrates.\r\n    {\r\n      return _interestRates[addr];\r\n    }\r\n    else if (unlockDate != 0 && unlockDate > _lastAccrueDate[addr])   // address has unlocked but no transaction have been performed to update the accrual and change the _interestrates.\r\n    {\r\n      return _previousInterestRate[addr];\r\n    }\r\n    else  // The address has unlocked and transactions have already been performed. \r\n    {\r\n      return _interestRates[addr];\r\n    }\r\n  }\r\n\r\n  // Prevents the supplied address from being charged taxes. \r\n  // This is necessary for things like airdrops to prevent those values from being taxed. \r\n  function excludeAddressFromTaxes(address addr) external onlyOwner() {\r\n      _isExcludedFromTax[addr] = true;\r\n  }\r\n\r\n  // Specifies that the supplied address should pay taxes. Used to undo a excludeAddressFromTaxes function call. \r\n  // The default is that all addresses will pay taxes, so we dont need to call this for every address.\r\n  function includeAddressInTaxes(address addr) external onlyOwner() {\r\n    _isExcludedFromTax[addr] = false;\r\n  }\r\n\r\n  // Prevents addresses from claiming interest. We exclude contracts, the token owner etc from claiming interest. \r\n  // This will also be used when the token gets listed on central exchanges. The exchange cant claim interest.\r\n  function excludeAddressFromInterest(address addr) external onlyOwner() {\r\n      _isExcludedFromInterest[addr] = true;\r\n  }\r\n\r\n  // Specifies that the supplied address can claim interest. Used to undo a excludeAddressFromInterest function call. \r\n  // The default is that all the addresses can claim interest (unless its a contract), so we dont need to call this for every address. \r\n  // Contracts can never claim interest.\r\n  function includeAddressInInterest(address addr) external onlyOwner() {\r\n      _isExcludedFromInterest[addr] = false;\r\n  }\r\n\r\n  function enableDefaultPancakeRouter(bool production) public onlyOwner() {\r\n\r\n    address contractAddress;\r\n\r\n    if(production)\r\n      contractAddress = _productionPancakeswapContract;\r\n    else\r\n      contractAddress = _testPancakeswapContract;\r\n\r\n    setPancakeRouterAddress(contractAddress);\r\n  }\r\n\r\n  // Sets the router address and creates the trading pair if it doesnt already exist\r\n  function setPancakeRouterAddress(address addr) public onlyOwner() {\r\n\r\n    IUniswapV2Router02 newPancakeSwapRouter = IUniswapV2Router02(addr);      \r\n    address newPair = IUniswapV2Factory(newPancakeSwapRouter.factory()).getPair(address(this), newPancakeSwapRouter.WETH());\r\n    if(newPair == address(0)){\r\n      newPair = IUniswapV2Factory(newPancakeSwapRouter.factory()).createPair(address(this), newPancakeSwapRouter.WETH());\r\n      LockedLPTokens[newPair] = true;\r\n      LPUnlockDate = block.timestamp + (1 * 366 * 24 * 60 * 60);  // lock it for 1 year. \r\n    }\r\n    PcsPairAddress = newPair;\r\n    _pancakeswapV2Router = newPancakeSwapRouter;\r\n  }\r\n\r\n  function extendLPUnlockDate(uint256 newUnlockDate) external onlyOwner {\r\n\r\n    require(newUnlockDate > LPUnlockDate, \"New unlock date must be great than current unlock date\");\r\n    emit LPUnlockDateIncreased(LPUnlockDate, newUnlockDate);\r\n    LPUnlockDate = newUnlockDate;\r\n  }\r\n\r\n  /// Anybody can call this function to create liquidity. \r\n  /// If the contract has some tokens then these can be used to generate liquidity.\r\n  /// Half of the tokens are converted to BNB, the other half is paired against the BNB and added to the liquidity pool.\r\n  /// This function is made external so anybody can call it to add the liquidity incase the developer becomes inactive for any reason.\r\n  /// This provides a way for the token community to continue to add more BNB to the liquidity pool from the taxes collected by the contract.\r\n  function generateLiquidityFromContractTokensSupply(uint256 tokenAmount) external returns (bool) {\r\n\r\n      currentlySwapping = true;\r\n      require(tokenAmount > 0, \"Invalid tokenAmount supplied.\");\r\n      require(_balances[address(this)] >= tokenAmount, \"The contract does not have a sufficient supply of tokens.\");\r\n\r\n      uint256 amountToSwap = tokenAmount.div(2);  // The amount to convert to BNB\r\n      uint256 amountToUseForLiquidity = tokenAmount.sub(amountToSwap);   // The amount to pair against the BNB in the liquidity pool\r\n\r\n      address[] memory tradingPair = new address[](2);\r\n      tradingPair[0] = address(this); // this contracts tokens\r\n      tradingPair[1] = address(_pancakeswapV2Router.WETH());  // WETH is actually WBNB when used on the Binance Smart Chain.\r\n\r\n      _approve(address(this), address(_pancakeswapV2Router), amountToSwap);    // Allow the router to spend the amount.\r\n\r\n      uint256 initialBalance = address(this).balance;\r\n\r\n      _pancakeswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n          amountToSwap,\r\n          0,\r\n          tradingPair,\r\n          address(this),  // Put the resulting BNB into the contract address\r\n          block.timestamp.add(300));\r\n\r\n      uint256 receivedBNB = address(this).balance.sub(initialBalance);  // The amount of BNB generated by the swap\r\n\r\n      _approve(address(this), address(_pancakeswapV2Router), amountToUseForLiquidity);\r\n\r\n      _pancakeswapV2Router.addLiquidityETH{value: receivedBNB}(\r\n          address(this),\r\n          amountToUseForLiquidity,\r\n          0,\r\n          0,\r\n          address(this),  // Put the LP tokens into the contract\r\n          block.timestamp.add(300)\r\n      );\r\n\r\n      emit SwapAndLiquify(amountToSwap, receivedBNB, amountToUseForLiquidity);\r\n\r\n      currentlySwapping = false;\r\n\r\n      return true;\r\n  }\r\n\r\n  function getOwner() override external view returns (address) {\r\n    return owner();\r\n  }\r\n\r\n  function decimals() override external pure returns (uint8) {\r\n    return _decimals;\r\n  }\r\n\r\n  function symbol() override external pure returns (string memory) {\r\n    return _symbol;\r\n  }\r\n\r\n  function name() override external view returns (string memory) {\r\n    return _name;\r\n  }\r\n\r\n  function totalSupply() override external view returns (uint256) {\r\n    return _totalSupply;\r\n  }\r\n\r\n  function balanceOf(address addr) override external view returns (uint256) {\r\n    return _balances[addr];\r\n  }\r\n\r\n  function transfer(address recipient, uint256 amount) override external returns (bool) {\r\n    _transfer(_msgSender(), recipient, amount);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address owner, address spender) override external view returns (uint256) {\r\n    return _allowances[owner][spender];\r\n  }\r\n\r\n  function approve(address spender, uint256 amount) override external returns (bool) {\r\n    _approve(_msgSender(), spender, amount);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address sender, address recipient, uint256 amount) override external returns (bool) {\r\n    _transfer(sender, recipient, amount);\r\n    _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"BEP20: transfer amount exceeds allowance\"));\r\n    return true;\r\n  }\r\n\r\n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n    return true;\r\n  }\r\n\r\n  function setDevTaxAddress(address payable taxStorageDestination) external onlyOwner() returns(bool) {\r\n    TaxStorageDestination = taxStorageDestination;\r\n    return true;\r\n  }\r\n\r\n  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"BEP20: decreased allowance below zero\"));\r\n    return true;\r\n  }\r\n\r\n  // This function allows someone to claim interest on their address and send it to another address. \r\n  // If this function is used then the taxes apply to the amount claimed. \r\n  // This is useful if someone wishes to use their interest as an income. They can keep their principal address locked and earn 40% but still be able to spend the earned interest.\r\n  function claimInterestToAnotherAddress(address addr) public {\r\n\r\n    uint256 currentBalance = _balances[msg.sender];\r\n\r\n    claimInterest();\r\n\r\n    uint256 interestEarned = _balances[msg.sender] - currentBalance;\r\n\r\n    if(interestEarned != 0)\r\n    {\r\n      _claimingExternally = true;\r\n      _transfer(msg.sender, addr, interestEarned);\r\n      emit ExternalClaim(msg.sender, addr, interestEarned);\r\n      _claimingExternally = false;\r\n    }\r\n  }\r\n\r\n  // Claims any interest due and transfers it into the earners wallet. \r\n  // If you want to send the interest to an external address then use the claimInterestToAnotherAddress function.\r\n  function claimInterest() public returns(uint256) {\r\n\r\n    require(msg.sender != address(0), \"BEP20: zero address not allowed\");\r\n    \r\n    accrueInterest(msg.sender, false);\r\n\r\n    uint256 addressesInterest = _accruedInterest[msg.sender];\r\n\r\n    _balances[msg.sender] += addressesInterest;\r\n    _totalSupply += addressesInterest;\r\n\r\n    emit Transfer(address(0), msg.sender, addressesInterest);\r\n    emit Claim(msg.sender, addressesInterest);\r\n\r\n    _lastAccrueDate[msg.sender] = block.timestamp;\r\n    _accruedInterest[msg.sender] = 0;   // sender has claimed their interest so we reset the accrued amount to zero.\r\n\r\n    return addressesInterest;\r\n  }\r\n\r\n  function accrueInterest(address addr, bool isSelling) private {\r\n    if(_interestRates[addr] == 0 && !_isExcludedFromInterest[addr])\r\n    {\r\n      _interestRates[addr] = _newAddressInterestRate; // We give new addresses a bonus rate.\r\n      _previousInterestRate[addr] = _interestRates[addr];\r\n    }\r\n\r\n    if(_lastAccrueDate[addr] == 0) // Happens for the first token transaction on an address.\r\n    {  \r\n      _lastAccrueDate[addr] = block.timestamp;\r\n      _accruedInterest[addr] = 0;      \r\n    }\r\n\r\n    if(_lastSellDate[addr] == 0)\r\n    {\r\n      _lastSellDate[addr] == block.timestamp - (MinutesBeforeInterest * 60);   // set the sell date to the past so that addresses are immediately able to earn interest.\r\n    }\r\n\r\n    if(_isExcludedFromInterest[addr])\r\n      return;\r\n\r\n    _accruedInterest[addr] = calculateClaimableInterest(addr);\r\n    _lastAccrueDate[addr] = block.timestamp;\r\n\r\n    uint256 unlockDate = whenWillAddressUnlock(addr);\r\n    if(unlockDate != 0 && unlockDate <= block.timestamp)\r\n    {\r\n      _interestRates[addr] = _previousInterestRate[addr];\r\n    }\r\n\r\n    if(isSelling)\r\n    {\r\n      // we downgrade the address rate to the standard rate. They cant get a higher rate unless they lock their address. \r\n      _lastSellDate[addr] = block.timestamp;\r\n      _interestRates[addr] = _standardInterestRate; // Address performed a sell so they are downgraded to the standard rate as their default rate. \r\n      _previousInterestRate[addr] = _interestRates[addr];\r\n    }\r\n  }\r\n\r\n  // Calculates the total interest currently due to an address which can be claimed.\r\n  function calculateClaimableInterest(address addr) public view returns(uint256) {\r\n\r\n    if(_interestRates[addr] == 0 || _isExcludedFromInterest[addr])\r\n    {\r\n      return 0;\r\n    }\r\n\r\n    if(_lastSellDate[addr] + (MinutesBeforeInterest * 60) >= block.timestamp)\r\n    {\r\n      // The seller still earns 0% interest because of their last sale. \r\n      return _accruedInterest[addr];    // return previously accrued interest which hasnt been claimed.\r\n    }\r\n\r\n    uint256 validStandardMinutes = 0;\r\n    uint256 validLockedMinutes = 0;\r\n    uint256 unlockDate = whenWillAddressUnlock(addr);\r\n\r\n    if(unlockDate != 0 && unlockDate > _lastAccrueDate[addr])    // The address is due some locked bonus interest\r\n    {\r\n      if(unlockDate < block.timestamp)  // Address is unlocked.\r\n      {\r\n        validLockedMinutes = (unlockDate - _dateAddressLocked[addr]) / 60;\r\n        validStandardMinutes = (block.timestamp  - unlockDate) / 60;\r\n      } \r\n      else\r\n      {\r\n        validLockedMinutes = (block.timestamp - _lastAccrueDate[addr]) / 60;\r\n      }\r\n    }\r\n    else    // The address is not locked and has accrued all bonus locked interest.\r\n    {\r\n      validStandardMinutes = (block.timestamp - _lastAccrueDate[addr]) / 60;\r\n    }\r\n\r\n    if(validStandardMinutes == 0 && validLockedMinutes == 0)    // no new interest is due. Will only happen if the address is queried within 1 minute of the last accrual.\r\n    {\r\n      return _accruedInterest[addr];\r\n    }\r\n    else\r\n    {\r\n      // calculates the interest due prorated over the number of minutes that the balance has been valid for.\r\n      uint256 standardInterestDue = ((_balances[addr].mul(_previousInterestRate[addr]).div(_yearInMinutes) / 100).mul(validStandardMinutes));\r\n      uint256 lockedInterestDue = ((_balances[addr].mul(_interestRates[addr]).div(_yearInMinutes) / 100).mul(validLockedMinutes));\r\n      return standardInterestDue + lockedInterestDue + _accruedInterest[addr];\r\n    }\r\n  }\r\n\r\n  function handleTaxes(address sender, uint256 totalRequestedSpendAmount) private returns (uint256) {\r\n\r\n    uint256 devTaxTotal = totalRequestedSpendAmount.div(100).mul(_devPercentage + _liquidityPercentage);\r\n    uint256 burnTaxTotal = totalRequestedSpendAmount.div(100).mul(_burnPercentage);\r\n    uint256 liquidityTotal = devTaxTotal.div(2);  // Half of the tax can be used for liquidity.\r\n\r\n    _balances[_burnAddress] = _balances[_burnAddress].add(burnTaxTotal);\r\n    emit Transfer(sender, _burnAddress, burnTaxTotal);\r\n\r\n    _balances[TaxStorageDestination] += devTaxTotal.sub(liquidityTotal);   // Send the devTax to the configured address.\r\n    emit Transfer(sender, TaxStorageDestination, devTaxTotal.sub(liquidityTotal));\r\n\r\n    _balances[address(this)] += liquidityTotal;   // Send the liquidityTax to the current contract.\r\n    emit Transfer(sender, address(this), liquidityTotal);\r\n\r\n    return devTaxTotal + burnTaxTotal;\r\n  }\r\n\r\n  function _approve(address owner, address spender, uint256 amount) internal {\r\n    require(owner != address(0), \"BEP20: approve from the zero address\");\r\n    require(spender != address(0), \"BEP20: approve to the zero address\");\r\n\r\n    _allowances[owner][spender] = amount;\r\n    emit Approval(owner, spender, amount);\r\n  }\r\n\r\n  // Used to withdraw any BNB which is in the contract address. BNB should never be in this address, so this will be used if someone accidentally\r\n  // transfers BNB to this address. This can be used to get them back their BNB. \r\n  function withdrawBNB(uint256 amount) public onlyOwner() {\r\n    \r\n    if(address(this).balance == 0)\r\n      revert(\"Contract has a zero balance.\");\r\n    else\r\n    {\r\n      if(amount == 0) \r\n        payable(owner()).transfer(address(this).balance);\r\n      else \r\n        payable(owner()).transfer(amount);\r\n    }\r\n  }\r\n\r\n  // Used to withdraw tokens transferred to this address. Used to prevent permanently locking tokens which are accidentally sent to the contract address.\r\n  // Contact the dev if you accidentally send tokens and we will do our best to return your funds. \r\n  function withdrawToken(address token, uint256 amount) public onlyOwner() {\r\n    require(amount > 0, \"Invalid amount supplied.\");\r\n\r\n    if(LockedLPTokens[token] && block.timestamp < LPUnlockDate)\r\n        revert(\"This LP Token cannot be withdrawn yet\");\r\n    else\r\n        IBEP20(address(token)).transfer(msg.sender, amount);\r\n  }\r\n\r\n}   // end of contract\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return sub(a, b, \"SafeMath: subtraction overflow\");\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    require(b <= a, errorMessage);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return div(a, b, \"SafeMath: division by zero\");\r\n  }\r\n\r\n  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    // Solidity only automatically asserts when dividing by 0\r\n    require(b > 0, errorMessage);\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return mod(a, b, \"SafeMath: modulo by zero\");\r\n  }\r\n\r\n  function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    require(b != 0, errorMessage);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n// IUniswapV2Factory interface taken from: https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/interfaces/IUniswapV2Factory.sol\r\ninterface IUniswapV2Factory {\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\n// IUniswapV2Router01 interface taken from: https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/interfaces/IUniswapV2Router01.sol\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);    // WETH is actually WBNB when used on the Binance Smart Chain.\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n}\r\n\r\n// IUniswapV2Router02 interface taken from: https://github.com/Uniswap/uniswap-v2-periphery/blob/master/contracts/interfaces/IUniswapV2Router02.sol \r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata tradingPair,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"teamFundsAddress\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lockAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unlockDate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bonusInterestRate\",\"type\":\"uint256\"}],\"name\":\"AddressLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address[]\",\"name\":\"bonusAddresses\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"}],\"name\":\"BonusRatesIssued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interestClaimed\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"destinationAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interestClaimed\",\"type\":\"uint256\"}],\"name\":\"ExternalClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldDate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDate\",\"type\":\"uint256\"}],\"name\":\"LPUnlockDateIncreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"unlockedAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feePaid\",\"type\":\"uint256\"}],\"name\":\"PaidToUnlockAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bnbReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiqudity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldTeamFundsAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newTeamFundsAddress\",\"type\":\"address\"}],\"name\":\"TeamFundsAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"TradingEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"BlockedAddresses\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LPUnlockDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"LockedLPTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LockedTeamFundsAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LockedTeamFundsBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MinutesBeforeInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PcsPairAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PcsTradingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TaxStorageDestination\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_accruedInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_dateAddressLocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_interestRates\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isExcludedFromInterest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isExcludedFromTax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_lastAccrueDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_lastSellDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_previousInterestRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"calculateClaimableInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"claimInterestToAnotherAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableNewBonusRateAddressesPermanently\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"production\",\"type\":\"bool\"}],\"name\":\"enableDefaultPancakeRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableDexTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"excludeAddressFromInterest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"excludeAddressFromTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newUnlockDate\",\"type\":\"uint256\"}],\"name\":\"extendLPUnlockDate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"generateLiquidityFromContractTokensSupply\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getAccruedInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getCurrentInterestRateForAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getLastSaleDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"includeAddressInInterest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"includeAddressInTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isAddressLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockSalesForBonusInterest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"payToUnlockAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBlocked\",\"type\":\"bool\"}],\"name\":\"setBlockedAddressStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"setBonusRateAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"taxStorageDestination\",\"type\":\"address\"}],\"name\":\"setDevTaxAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setPancakeRouterAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newTeamFundsAddress\",\"type\":\"address\"}],\"name\":\"transferTeamFundsToNewAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"whenWillAddressUnlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ATSWIFTY", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "00000000000000000000000036f8b8516b5c22d9458c2914770015317f8bd4a2", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://024eadb5c1abf11ed2526e6a81df563deeccda34a7a0118f0ce512f267f7cc93"}