{"SourceCode": "{\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.19;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller\\u0027s account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n\\n    function transferPrebitsContract(address from, address to, uint256 value) external;\\n\\n}\"},\"Main.sol\":{\"content\":\"//Prebit - Predict  Version 0.2 - Fast Version\\n/*\\n\\n  ____           _     _ _   \\n |  _ \\\\ _ __ ___| |__ (_) |_ \\n | |_) | \\u0027__/ _ \\\\ \\u0027_ \\\\| | __|\\n |  __/| | |  __/ |_) | | |_ \\n |_|   |_|  \\\\___|_.__/|_|\\\\__|\\n                             \\n\\n                 _                                              _ _     _ _ _ _   _           \\n   ___ _ __ ___ | |__  _ __ __ _  ___ ___   _ __   ___  ___ ___(_) |__ (_) (_) |_(_) ___  ___ \\n  / _ \\\\ \\u0027_ ` _ \\\\| \\u0027_ \\\\| \\u0027__/ _` |/ __/ _ \\\\ | \\u0027_ \\\\ / _ \\\\/ __/ __| | \\u0027_ \\\\| | | | __| |/ _ \\\\/ __|\\n |  __/ | | | | | |_) | | | (_| | (_|  __/ | |_) | (_) \\\\__ \\\\__ \\\\ | |_) | | | | |_| |  __/\\\\__ \\\\\\n  \\\\___|_| |_| |_|_.__/|_|  \\\\__,_|\\\\___\\\\___| | .__/ \\\\___/|___/___/_|_.__/|_|_|_|\\\\__|_|\\\\___||___/\\n                                           |_|                                                \\n\\n\\n\\n\\n*/\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.19;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n// Interfaces\\n\\ninterface IPrebitReferrals {\\n    function generateReferralCode(uint256 _parentCode) external;\\n\\n    function generateReferralCodeWithContract(\\n        uint256 _parentCode,\\n        address _user\\n    ) external;\\n\\n    function userReferralCode(address _user)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            address,\\n            address,\\n            bool\\n        );\\n\\n    function referralCodeToAddress(uint256 _referralCode)\\n        external\\n        view\\n        returns (address);\\n\\n    function userReferralCodeCheck(address _user) external view returns (bool);\\n\\n    function userReferralCodeToAddress(uint256 _code)\\n        external\\n        view\\n        returns (address);\\n\\n    function getUserTparent(address _user) external view returns (address);\\n\\n    function getUserParent(address _user) external view returns (address);\\n\\n    function isContractAllowed(address _contractAddress)\\n        external\\n        view\\n        returns (bool);\\n}\\n\\ninterface IPrebit {\\n    function injectFundsFromContract(\\n        uint256 _prebitId,\\n        uint256 _amount,\\n        uint256 _row\\n    ) external;\\n\\n    function injectFundsBitBoxFromContract(uint256 _prebitId, uint256 _amount)\\n        external;\\n\\n    function injectFundsToReservesFromContract(uint256 _bitboxAmount,uint256 _bitpotAmount)\\n        external;\\n\\n    function currentPreBitId() external view returns (uint256);\\n}\\n\\ncontract MainPrebit is Ownable {\\n    using SafeMath for uint256;\\n\\n    // Interfaces\\n    IPrebitReferrals public referralContract;\\n    IERC20 public payToken;\\n    IERC20 public bonusToken;\\n\\n    // Addresses\\n    address public injectorAddress;\\n    address public operatorAddress;\\n    address public treasuryAddress;\\n    address public contractInject;\\n\\n    address[] public treasuryWallets;\\n    uint256[] public treasuryPercentages;\\n\\n    // Percents\\n    uint256 public percentTreasury = 15;\\n    uint256 public percentReferralsLv1 = 10;\\n    uint256 public percentReferralsLv2 = 5;\\n\\n    // Constants\\n    uint256 public constant MAX_CARD_PRICE = 10000000000000000000;\\n\\n    // Price and variables\\n    uint256 public  precardPrice = 2000000000000000000;\\n    uint256 public  precardPriceBonus = 1000000000;\\n\\n    // Rows to Injection\\n    uint256 percentOfRowsToInjection = 0;\\n    uint256 public constant MAX_ROWS_TO_INJECTION = 100;\\n\\n    // Pot Percent\\n    uint256 public potPercent = 70;\\n    // Reserv Pot Bitpot \\u0026 Bitbank\\n    uint256 public reserveBitbank = 0;\\n    uint256 public reserveBitpot = 0;\\n    // Current PreBit and PreCard IDs\\n    uint256 public currentPreBitId;\\n    uint256 public currentPreCardId;\\n\\n    // Time Intervals\\n    uint256 public intervalToOpenNextPrebit = 0;\\n    uint256 public intervalToCloseNextPrebit = 240;\\n    uint256 public intervalToEndNextPrebit = 600;\\n\\n\\n    // Define a mapping to track user addresses that have won in Row 0 for each prebit\\n    // mapping(uint256 =\\u003e mapping(address =\\u003e bool)) public row0Winners;\\n    // Define a mapping to store the addresses of Row 0 winners for each prebit\\n    mapping(uint256 =\\u003e uint256[]) private row0Precards;\\n    mapping(uint256 =\\u003e mapping(address =\\u003e bool)) private row0Winners;\\n    mapping(uint256 =\\u003e address[]) private  bitboxWinners;\\n\\n    // Enumeration for Prebit status\\n    enum Status {\\n        Pending,\\n        Open,\\n        Close,\\n        End\\n    }\\n\\n    // Structs\\n    struct Prebit {\\n        Status status;\\n        uint256 startTime;\\n        uint256 openPredictTime;\\n        uint256 closePredictTime;\\n        uint256 endTime;\\n        uint256[6] amountInRows;\\n        uint256[6] rewardEachCard;\\n        uint256[6] cardsInRows;\\n        uint256 firstPrecardId;\\n        uint256 totalTreasuryAmount;\\n        uint256 totalEntryAmount;\\n        uint256 bitBox;\\n        uint256 finalPrice;\\n        bool priceSet;\\n    }\\n\\n    struct RowData {\\n        uint256 amountInRow;\\n        uint256 cardsInRow;\\n        uint256 rewardEachCard;\\n    }\\n\\n    struct PrebitData {\\n        uint256 endTime;\\n        uint256 userPrecardCount;\\n    }\\n\\n    struct RewardResult {\\n        bool claimed;\\n        uint256 rewards;\\n    }\\n\\n    struct Precard {\\n        uint256 predictPrice;\\n        address owner;\\n        bool claimed;\\n    }\\n\\n    struct BitboxUserAmount {\\n        uint256 _amount;\\n        bool claimed;\\n    }\\n\\n    // State Variables\\n    mapping(uint256 =\\u003e Prebit) public _prebits;\\n    mapping(uint256 =\\u003e Precard) public _precards;\\n    uint256[6] public rowsRange;\\n    uint256 public latestPrecardCalculated;\\n    uint256[6] public pendingInjectionNextPrebit;\\n    uint256 public pendingBitbox;\\n    mapping(address =\\u003e mapping(uint256 =\\u003e uint256[]))\\n        public _userPreCardIdsPerPreBitId;\\n\\n    mapping(uint256 =\\u003e mapping(address =\\u003e BitboxUserAmount))\\n        public bitboxUsersAmounts;\\n\\n    // Modifiers\\n    modifier onlyOperator() {\\n        require(msg.sender == operatorAddress, \\\"Not operator\\\");\\n        _;\\n    }\\n\\n    modifier onlyOwnerOrInjector() {\\n        require(\\n            (msg.sender == owner()) || (msg.sender == injectorAddress),\\n            \\\"Not owner or injector\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier contractInjector() {\\n        require(msg.sender == contractInject, \\\"Not Contract Injector\\\");\\n        _;\\n    }\\n    //Events\\n    event PurchasePrecardEvent(\\n        address _user,\\n        uint256 _prebitID,\\n        uint256[] _prediction,\\n        uint256 _count,\\n        uint256 _referralCode\\n    );\\n        event PurchasePrecardBonusEvent(\\n        address _user,\\n        uint256 _prebitID,\\n        uint256[] _prediction,\\n        uint256 _count,\\n        uint256 _referralCode\\n    );\\n    event PayReferralsEvent(\\n        address _parent,\\n        uint256 _prebitID,\\n        uint256 _payReferralAmount,\\n        uint256 _totalAmount,\\n        uint256 _type\\n    );\\n    event StartNextPrebitEvent(\\n        uint256 indexed prebitId,\\n        uint256 _endTime,\\n        uint256 _openPrecardTime,\\n        uint256 _closePrecardTime,\\n        uint256 firstTicketId\\n    );\\n    event ExecuteDrawFinalPriceEvent(\\n        uint256 indexed prebitId,\\n        uint256 finalPrice\\n    );\\n    event ClaimTicketEvent(\\n        address _user,\\n        uint256 indexed prebitId,\\n        uint256[] precards,\\n        uint256 amount\\n    );\\n\\n    // Event to set addresses\\n    event SetAddressesEvent(\\n        address indexed operatorAddress,\\n        address indexed treasuryAddress,\\n        address indexed injectorAddress\\n    );\\n    event BitboxClaimed(\\n        address indexed user,\\n        uint256 indexed prebitId,\\n        uint256 amount\\n    );\\n\\n    // Event to update Precard price\\n    event UpdatePrecardPriceEvent(uint256 newPrice);\\n\\n    // Event for injecting funds\\n    event InjectFundsEvent(uint256 prebitId, uint256 amount, uint256 row);\\n\\n    // Event for migrating to a new version\\n    event MigrateToNewVersionEvent(address newContract);\\n\\n    // Event for setting the percent of rows\\n    event SetPercentOfRowsEvent(uint256 percent);\\n\\n    // Event for setting new intervals\\n    event SetNewIntervalEvent(\\n        uint256 openInterval,\\n        uint256 closeInterval,\\n        uint256 endInterval\\n    );\\n\\n    constructor(\\n        address _payToken,\\n        address _referralContractAddress,\\n        address _contractInjector,\\n        address _bonusToken\\n    ) {\\n        payToken = IERC20(_payToken);\\n        contractInject = _contractInjector;\\n        referralContract = IPrebitReferrals(_referralContractAddress);\\n        bonusToken=IERC20(_bonusToken);\\n        rowsRange[0] = 0; // Row 1 - 0 Cent\\n        rowsRange[1] = 2; // Row 2 - 2 Cent\\n        rowsRange[2] = 5; // Row 3 - 5 Cent\\n        rowsRange[3] = 10; // Row 4 - 8 Cent\\n        rowsRange[4] = 100; // Row 5 - 100 Cent\\n        rowsRange[5] = 300; // Row 6 - 300 Cent\\n    }\\n\\n     \\n    function purchasePrecardBonus(\\n        uint256 _prebitID,\\n        uint256[] memory _prediction,\\n        uint256 _referralCode\\n    ) external {\\n        require(\\n            _prebits[_prebitID].status == Status.Open,\\n            \\\"Prebit ID is not open\\\"\\n        );\\n        require(\\n            block.timestamp \\u003c _prebits[_prebitID].closePredictTime,\\n            \\\"Prebit ID is over\\\"\\n        );\\n\\n        require(\\n            _prediction.length \\u003e 0,\\n            \\\"101 : Precard count must be greater than 0\\\"\\n        );\\n\\n        uint256 totalPayAmount = _prediction.length * precardPriceBonus;\\n\\n        require(\\n            bonusToken.balanceOf(msg.sender) \\u003e= totalPayAmount,\\n            \\\"102 : Insufficient Bonus balance\\\"\\n        );\\n\\n        // Pays \\u0026 Generate referral code\\n\\n        referralContract.generateReferralCodeWithContract(\\n            _referralCode,\\n            msg.sender\\n        );\\n       bonusToken.transferPrebitsContract(msg.sender, address(this), totalPayAmount);\\n        //Insert Precard\\n\\n       _insertPrecards(_prebitID,_prediction);\\n\\n        emit PurchasePrecardBonusEvent(\\n            msg.sender,\\n            _prebitID,\\n            _prediction,\\n            _prediction.length,\\n            _referralCode\\n        );\\n    }\\n\\n    /**\\n     * @dev Allows a user to purchase precards for a specific prebit round.\\n     * @param _prebitID The ID of the prebit round to purchase precards for.\\n     * @param _prediction An array of predicted prices (in 2 decimals) for BTC.\\n     * @param _referralCode The referral code associated with the user making the purchase.\\n     */\\n    function purchasePrecard(\\n        uint256 _prebitID,\\n        uint256[] memory _prediction,\\n        uint256 _referralCode\\n    ) external {\\n        require(\\n            _prebits[_prebitID].status == Status.Open,\\n            \\\"Prebit ID is not open\\\"\\n        );\\n        require(\\n            block.timestamp \\u003c _prebits[_prebitID].closePredictTime,\\n            \\\"Prebit ID is over\\\"\\n        );\\n\\n        require(\\n            _prediction.length \\u003e 0,\\n            \\\"101 : Precard count must be greater than 0\\\"\\n        );\\n\\n        uint256 totalPayAmount = _prediction.length * precardPrice;\\n\\n        require(\\n            payToken.balanceOf(msg.sender) \\u003e= totalPayAmount,\\n            \\\"102 : Insufficient USDT balance\\\"\\n        );\\n\\n        // Pays \\u0026 Generate referral code\\n\\n        referralContract.generateReferralCodeWithContract(\\n            _referralCode,\\n            msg.sender\\n        );\\n        _paysProcess(totalPayAmount);\\n\\n       _calculateRows(_prebitID,totalPayAmount);\\n\\n        //Insert Precard\\n\\n       _insertPrecards(_prebitID,_prediction);\\n\\n        emit PurchasePrecardEvent(\\n            msg.sender,\\n            _prebitID,\\n            _prediction,\\n            _prediction.length,\\n            _referralCode\\n        );\\n    }\\n\\n    function _insertPrecards(uint256 _prebitID,uint256[] memory _prediction) private{\\n for (uint256 i = 0; i \\u003c _prediction.length; i++) {\\n            uint256 thisPrecardPrice = _prediction[i];\\n\\n            _userPreCardIdsPerPreBitId[msg.sender][_prebitID].push(\\n                currentPreCardId\\n            );\\n\\n            _precards[currentPreCardId] = Precard({\\n                predictPrice: thisPrecardPrice,\\n                owner: msg.sender,\\n                claimed: false\\n            });\\n\\n            currentPreCardId++;\\n        }\\n    }\\n    function _calculateRows(uint256 _prebitID,uint256 totalPayAmount) private{\\n         uint256 amountPot = totalPayAmount.mul(potPercent).div(100);\\n        // Increment the total amount collected for the prebit round\\n        _prebits[_prebitID].totalEntryAmount += amountPot;\\n        _prebits[_prebitID].totalTreasuryAmount += totalPayAmount\\n            .mul(percentTreasury)\\n            .div(100);\\n\\n        //Calulate\\n        //Reserve Pot\\n        reserveBitbank += amountPot.mul(2).div(100);\\n        reserveBitpot += amountPot.mul(2).div(100);\\n        //\\n        _prebits[_prebitID].bitBox += amountPot.mul(18).div(100);\\n        _prebits[_prebitID].amountInRows[0] += amountPot.mul(18).div(100);\\n        _prebits[_prebitID].amountInRows[1] += amountPot.mul(18).div(100);\\n        _prebits[_prebitID].amountInRows[2] += amountPot.mul(16).div(100);\\n        _prebits[_prebitID].amountInRows[3] += amountPot.mul(12).div(100);\\n        _prebits[_prebitID].amountInRows[4] += amountPot.mul(8).div(100);\\n        _prebits[_prebitID].amountInRows[5] += amountPot.mul(6).div(100);\\n    }\\n\\n    /**\\n     * @dev Handles the payment process for a user\\u0027s purchase of precards, including referral rewards.\\n     * @param _totalPayAmount The total payment amount made by the user.\\n     */\\n    function _paysProcess(uint256 _totalPayAmount) private {\\n        uint256 newAmount = _totalPayAmount;\\n        address parentAddress = referralContract.getUserParent(msg.sender);\\n        if (parentAddress != address(0)) {\\n            newAmount -= _totalPayAmount.mul(percentReferralsLv1).div(100);\\n            payToken.transferFrom(\\n                msg.sender,\\n                parentAddress,\\n                _totalPayAmount.mul(percentReferralsLv1).div(100)\\n            );\\n            emit PayReferralsEvent(\\n                parentAddress,\\n                currentPreBitId,\\n                _totalPayAmount.mul(percentReferralsLv1).div(100),\\n                _totalPayAmount,\\n                1\\n            );\\n            address tParentAddress = referralContract.getUserTparent(\\n                msg.sender\\n            );\\n            if (tParentAddress != address(0)) {\\n                payToken.transferFrom(\\n                    msg.sender,\\n                    tParentAddress,\\n                    _totalPayAmount.mul(percentReferralsLv2).div(100)\\n                );\\n\\n                emit PayReferralsEvent(\\n                    tParentAddress,\\n                    currentPreBitId,\\n                    _totalPayAmount.mul(percentReferralsLv2).div(100),\\n                    _totalPayAmount,\\n                    2\\n                );\\n\\n                newAmount -= _totalPayAmount.mul(percentReferralsLv2).div(100);\\n            } else {\\n                _prebits[currentPreBitId].totalTreasuryAmount += _totalPayAmount\\n                    .mul(percentReferralsLv2)\\n                    .div(100);\\n            }\\n        } else {\\n            _prebits[currentPreBitId].totalTreasuryAmount += _totalPayAmount\\n                .mul(percentReferralsLv1 + percentReferralsLv2)\\n                .div(100);\\n        }\\n\\n        payToken.transferFrom(msg.sender, address(this), newAmount);\\n    }\\n\\n    /**\\n     * @dev Allows the owner of the contract to adjust the timestamps for a specific prebit. for re-config a round\\n     * @param _prebitId The ID of the prebit to adjust timestamps for.\\n     * @param endTimestamp The new end timestamp for the prebit.\\n     * @param openTimestamp The new open prediction timestamp for the prebit.\\n     * @param closeTimestamp The new close prediction timestamp for the prebit.\\n     */\\n    function adjustTimestamp(\\n        uint256 _prebitId,\\n        uint256 endTimestamp,\\n        uint256 openTimestamp,\\n        uint256 closeTimestamp\\n    ) external onlyOwner {\\n        _prebits[_prebitId].endTime = endTimestamp;\\n        _prebits[_prebitId].openPredictTime = openTimestamp;\\n        _prebits[_prebitId].closePredictTime = closeTimestamp;\\n    }\\n\\n    /**\\n     * @dev Allows the operator to start the next prebit in the sequence.\\n     * This function calculates and sets the timestamps for the new prebit.\\n     */\\n    function startNextPrebit() external onlyOperator {\\n        require(\\n            (_prebits[currentPreBitId].status == Status.End),\\n            \\\"Not time to start PreBit\\\"\\n        );\\n\\n        currentPreBitId++;\\n        uint256 nowTimestamp = block.timestamp;\\n\\n        uint256 openTimestamp = nowTimestamp + intervalToOpenNextPrebit;\\n        uint256 endTimestamp = _prebits[currentPreBitId - 1].endTime +\\n            intervalToEndNextPrebit;\\n        uint256 closeTimestamp = _prebits[currentPreBitId - 1].endTime +\\n            intervalToCloseNextPrebit;\\n\\n        // Ensure that endTimestamp is not earlier than nowTimestamp\\n        while (endTimestamp \\u003c openTimestamp) {\\n            endTimestamp += intervalToEndNextPrebit;\\n        }\\n\\n        // Ensure that openTimestamp is not later than\\n        while (closeTimestamp \\u003c openTimestamp) {\\n            closeTimestamp += intervalToCloseNextPrebit;\\n        }\\n\\n        // Ensure that closeTimestamp is not later than endTimestamp\\n        while (closeTimestamp \\u003e endTimestamp) {\\n            endTimestamp += intervalToEndNextPrebit;\\n        }\\n        if (closeTimestamp == endTimestamp) {\\n            closeTimestamp = endTimestamp - intervalToCloseNextPrebit;\\n        }\\n\\n        startNext(endTimestamp, openTimestamp, closeTimestamp);\\n    }\\n\\n    /**\\n     * @dev Allows the owner to start the initial prebit (genesis prebit) with specific timestamps.\\n     * This function is used to kickstart the game with the first round.\\n     * @param _prebitID The ID of the initial prebit.\\n     * @param _endTime The end timestamp for the initial prebit.\\n     * @param _openPrecardTime The open precard timestamp for the initial prebit.\\n     * @param _closePrecardTime The close precard timestamp for the initial prebit.\\n     */\\n    function startNextPrebitGenesis(\\n        uint256 _prebitID,\\n        uint256 _endTime,\\n        uint256 _openPrecardTime,\\n        uint256 _closePrecardTime\\n    ) external onlyOwner {\\n        require((currentPreBitId == 0), \\\"Not time to start PreBit\\\");\\n\\n        currentPreBitId = _prebitID;\\n\\n        startNext(_endTime, _openPrecardTime, _closePrecardTime);\\n    }\\n\\n    /**\\n     * @dev Initializes the next prebit with specific timestamps and distributes pending injections to the prebit\\u0027s rows.\\n     * @param _endTime The end timestamp for the next prebit.\\n     * @param _openPrecardTime The open precard timestamp for the next prebit.\\n     * @param _closePrecardTime The close precard timestamp for the next prebit.\\n     */\\n    function startNext(\\n        uint256 _endTime,\\n        uint256 _openPrecardTime,\\n        uint256 _closePrecardTime\\n    ) private {\\n        _prebits[currentPreBitId] = Prebit({\\n            status: Status.Open,\\n            startTime: block.timestamp,\\n            openPredictTime: _openPrecardTime,\\n            closePredictTime: _closePrecardTime,\\n            endTime: _endTime,\\n            amountInRows: [\\n                uint256(0),\\n                uint256(0),\\n                uint256(0),\\n                uint256(0),\\n                uint256(0),\\n                uint256(0)\\n            ],\\n            rewardEachCard: [\\n                uint256(0),\\n                uint256(0),\\n                uint256(0),\\n                uint256(0),\\n                uint256(0),\\n                uint256(0)\\n            ],\\n            cardsInRows: [\\n                uint256(0),\\n                uint256(0),\\n                uint256(0),\\n                uint256(0),\\n                uint256(0),\\n                uint256(0)\\n            ],\\n            firstPrecardId: currentPreCardId,\\n            totalTreasuryAmount: 0,\\n            totalEntryAmount: 0,\\n            bitBox: 0,\\n            finalPrice: 0,\\n            priceSet: false\\n        });\\n\\n        _prebits[currentPreBitId].bitBox = pendingBitbox;\\n        uint256 sumAllPendingExceptBitpot = pendingInjectionNextPrebit[1] +\\n            pendingInjectionNextPrebit[2] +\\n            pendingInjectionNextPrebit[3] +\\n            pendingInjectionNextPrebit[4] +\\n            pendingInjectionNextPrebit[5];\\n\\n        _prebits[currentPreBitId].amountInRows[0] = pendingInjectionNextPrebit[\\n            0\\n        ];\\n        _prebits[currentPreBitId].amountInRows[1] = sumAllPendingExceptBitpot\\n            .mul(18)\\n            .div(60);\\n        _prebits[currentPreBitId].amountInRows[2] = sumAllPendingExceptBitpot\\n            .mul(16)\\n            .div(60);\\n        _prebits[currentPreBitId].amountInRows[3] = sumAllPendingExceptBitpot\\n            .mul(12)\\n            .div(60);\\n        _prebits[currentPreBitId].amountInRows[4] = sumAllPendingExceptBitpot\\n            .mul(8)\\n            .div(60);\\n        _prebits[currentPreBitId].amountInRows[5] = sumAllPendingExceptBitpot\\n            .mul(6)\\n            .div(60);\\n\\n        pendingInjectionNextPrebit[0] = 0;\\n        pendingInjectionNextPrebit[1] = 0;\\n        pendingInjectionNextPrebit[2] = 0;\\n        pendingInjectionNextPrebit[3] = 0;\\n        pendingInjectionNextPrebit[4] = 0;\\n        pendingInjectionNextPrebit[5] = 0;\\n        pendingBitbox = 0;\\n        emit StartNextPrebitEvent(\\n            currentPreBitId,\\n            _endTime,\\n            _openPrecardTime,\\n            _closePrecardTime,\\n            currentPreCardId\\n        );\\n    }\\n\\n    /**\\n     * @dev Executes the draw of the final price for a prebit and calculates rewards.\\n     * @param _prebitId The ID of the prebit for which the final price is being drawn.\\n     * @param _price The final price for the prebit.\\n     * @param _batchSize The number of precards to process in each batch.\\n     */\\n    function executeDrawFinalPrice(\\n        uint256 _prebitId,\\n        uint256 _price,\\n        uint256 _batchSize\\n    ) external onlyOperator {\\n        require(\\n            block.timestamp \\u003e _prebits[_prebitId].endTime,\\n            \\\"This Prebit Not End\\\"\\n        );\\n\\n        require(\\n            _prebits[_prebitId].status != Status.End,\\n            \\\"This Prebit is Finished\\\"\\n        );\\n\\n        uint256 finalPrice;\\n        if (_prebits[_prebitId].priceSet == false) {\\n            _prebits[_prebitId].finalPrice = _price;\\n            finalPrice = _price;\\n            _prebits[_prebitId].priceSet = true;\\n        } else {\\n            finalPrice = _prebits[_prebitId].finalPrice;\\n        }\\n\\n        //Percent Rows\\n\\n        uint256 startPrecardId = latestPrecardCalculated;\\n        uint256 endPrecardId = startPrecardId + _batchSize;\\n        // Ensure we don\\u0027t exceed the total number of precards\\n        if (endPrecardId \\u003e currentPreCardId) {\\n            endPrecardId = currentPreCardId;\\n        }\\n\\n        for (uint256 i = startPrecardId; i \\u003c endPrecardId; i++) {\\n            uint256 cardPrice = _precards[i].predictPrice;\\n            if (cardPrice == finalPrice) {\\n                //Jackpot\\n                _prebits[_prebitId].cardsInRows[0] =\\n                    _prebits[_prebitId].cardsInRows[0] +\\n                    1;\\n\\n                recordWinInRow0(_prebitId, i, _precards[i].owner);\\n            } else if (\\n                isPredictionWithinRange(cardPrice, rowsRange[1], finalPrice)\\n            ) {\\n                _prebits[_prebitId].cardsInRows[1] =\\n                    _prebits[_prebitId].cardsInRows[1] +\\n                    1;\\n            } else if (\\n                isPredictionWithinRange(cardPrice, rowsRange[2], finalPrice)\\n            ) {\\n                _prebits[_prebitId].cardsInRows[2] =\\n                    _prebits[_prebitId].cardsInRows[2] +\\n                    1;\\n            } else if (\\n                isPredictionWithinRange(cardPrice, rowsRange[3], finalPrice)\\n            ) {\\n                _prebits[_prebitId].cardsInRows[3] =\\n                    _prebits[_prebitId].cardsInRows[3] +\\n                    1;\\n            } else if (\\n                isPredictionWithinRange(cardPrice, rowsRange[4], finalPrice)\\n            ) {\\n                _prebits[_prebitId].cardsInRows[4] =\\n                    _prebits[_prebitId].cardsInRows[4] +\\n                    1;\\n            } else if (\\n                isPredictionWithinRange(cardPrice, rowsRange[5], finalPrice)\\n            ) {\\n                _prebits[_prebitId].cardsInRows[5] =\\n                    _prebits[_prebitId].cardsInRows[5] +\\n                    1;\\n            }\\n\\n            latestPrecardCalculated++;\\n        }\\n\\n        if (latestPrecardCalculated == currentPreCardId) {\\n            //Calc  Reward Each card\\n            if (_prebits[_prebitId].cardsInRows[0] \\u003e 0) {\\n                _prebits[_prebitId].rewardEachCard[0] = (\\n                    _prebits[_prebitId].amountInRows[0]\\n                ).div(_prebits[_prebitId].cardsInRows[0]);\\n\\n                // Inject Reserve Bitpot\\n                 pendingInjectionNextPrebit[0] += reserveBitpot;\\n                 reserveBitpot=0;\\n            } else {\\n                pendingInjectionNextPrebit[0] += _prebits[_prebitId]\\n                    .amountInRows[0];\\n            }\\n\\n            if (_prebits[_prebitId].cardsInRows[1] \\u003e 0) {\\n                _prebits[_prebitId].rewardEachCard[1] = (\\n                    _prebits[_prebitId].amountInRows[1]\\n                ).div(_prebits[_prebitId].cardsInRows[1]);\\n            } else {\\n                pendingInjectionNextPrebit[0] += (\\n                    _prebits[_prebitId].amountInRows[1]\\n                ).mul(percentOfRowsToInjection).div(100);\\n                pendingInjectionNextPrebit[1] += (\\n                    _prebits[_prebitId].amountInRows[1]\\n                ).mul(100 - percentOfRowsToInjection).div(100);\\n            }\\n\\n            if (_prebits[_prebitId].cardsInRows[2] \\u003e 0) {\\n                _prebits[_prebitId].rewardEachCard[2] = (\\n                    _prebits[_prebitId].amountInRows[2]\\n                ).div(_prebits[_prebitId].cardsInRows[2]);\\n            } else {\\n                pendingInjectionNextPrebit[0] += (\\n                    _prebits[_prebitId].amountInRows[2]\\n                ).mul(percentOfRowsToInjection).div(100);\\n                pendingInjectionNextPrebit[2] += (\\n                    _prebits[_prebitId].amountInRows[2]\\n                ).mul(100 - percentOfRowsToInjection).div(100);\\n            }\\n\\n            if (_prebits[_prebitId].cardsInRows[3] \\u003e 0) {\\n                _prebits[_prebitId].rewardEachCard[3] = (\\n                    _prebits[_prebitId].amountInRows[3]\\n                ).div(_prebits[_prebitId].cardsInRows[3]);\\n            } else {\\n                pendingInjectionNextPrebit[0] += (\\n                    _prebits[_prebitId].amountInRows[3]\\n                ).mul(percentOfRowsToInjection).div(100);\\n                pendingInjectionNextPrebit[3] += (\\n                    _prebits[_prebitId].amountInRows[3]\\n                ).mul(100 - percentOfRowsToInjection).div(100);\\n            }\\n\\n            if (_prebits[_prebitId].cardsInRows[4] \\u003e 0) {\\n                _prebits[_prebitId].rewardEachCard[4] = (\\n                    _prebits[_prebitId].amountInRows[4]\\n                ).div(_prebits[_prebitId].cardsInRows[4]);\\n            } else {\\n                pendingInjectionNextPrebit[0] += (\\n                    _prebits[_prebitId].amountInRows[4]\\n                ).mul(percentOfRowsToInjection).div(100);\\n                pendingInjectionNextPrebit[4] += (\\n                    _prebits[_prebitId].amountInRows[4]\\n                ).mul(100 - percentOfRowsToInjection).div(100);\\n            }\\n\\n            if (_prebits[_prebitId].cardsInRows[5] \\u003e 0) {\\n                _prebits[_prebitId].rewardEachCard[5] = (\\n                    _prebits[_prebitId].amountInRows[5]\\n                ).div(_prebits[_prebitId].cardsInRows[5]);\\n            } else {\\n                pendingInjectionNextPrebit[0] += (\\n                    _prebits[_prebitId].amountInRows[5]\\n                ).mul(percentOfRowsToInjection).div(100);\\n                pendingInjectionNextPrebit[5] += (\\n                    _prebits[_prebitId].amountInRows[5]\\n                ).mul(100 - percentOfRowsToInjection).div(100);\\n            }\\n\\n            // Mark the Prebit as finalized\\n            _prebits[_prebitId].status = Status.End;\\n\\n            calculateBitbox();\\n\\n            //Transfer TreasuryAmount\\n\\n            _paysTreasury(_prebits[_prebitId].totalTreasuryAmount);\\n\\n            //\\n\\n            emit ExecuteDrawFinalPriceEvent(_prebitId, finalPrice);\\n        }\\n    }\\n\\n    /**\\n     * @dev Allows a user to claim their Bitbox winnings for a specific prebit.\\n     * @param _prebitId The ID of the prebit from which to claim Bitbox winnings.\\n     */\\n    function claimBitbox(uint256 _prebitId) external {\\n        // Ensure that the _prebitId is valid (you may add additional checks)\\n\\n        // Get the user\\u0027s address\\n        address user = msg.sender;\\n\\n        // Ensure that the user exists in Row 0 for the given _prebitId\\n        require(\\n            userExistsInRow0(_prebitId, user),\\n            \\\"User not eligible to claim Bitbox\\\"\\n        );\\n\\n        // Ensure that the Bitbox winnings for this _prebitId have not been claimed before\\n        require(\\n            !bitboxUsersAmounts[_prebitId][user].claimed,\\n            \\\"Bitbox already claimed\\\"\\n        );\\n\\n        // Calculate the amount the user is eligible to claim\\n        uint256 amountToClaim = bitboxUsersAmounts[_prebitId][user]._amount;\\n\\n        // Ensure that the amount to claim is greater than zero\\n        require(amountToClaim \\u003e 0, \\\"No Bitbox to claim\\\");\\n\\n        // Mark the Bitbox winnings as claimed for this _prebitId\\n        bitboxUsersAmounts[_prebitId][user].claimed = true;\\n\\n        // Perform the actual transfer of Bitbox tokens to the user\\n        // You should have a function to handle token transfers, e.g., transferBitbox(address to, uint256 amount)\\n        // Make sure to implement this function or use the appropriate token transfer method.\\n        payToken.transfer(user, amountToClaim.mul(97).div(100));\\n        //Transfer to Referrals lv1\\n        if (referralContract.getUserParent(msg.sender) != address(0)) {\\n            address parentAddress = referralContract.getUserParent(msg.sender);\\n            payToken.transfer(\\n                parentAddress,\\n                amountToClaim.mul(3).div(100)\\n            );\\n            emit PayReferralsEvent(\\n                parentAddress,\\n                _prebitId,\\n                amountToClaim.mul(3).div(100),\\n                amountToClaim.mul(97).div(100),\\n                10\\n            ); //10 means from winner\\n        } else {\\n            _paysTreasury(amountToClaim.mul(3).div(100));\\n        }\\n        // Optionally emit an event to log the successful claim\\n        emit BitboxClaimed(user, _prebitId, amountToClaim);\\n    }\\n\\n    /**\\n     * @dev Calculate and distribute Bitbox rewards for the current prebit.\\n     * This function determines eligible users and distributes the Bitbox accordingly.\\n     */\\n    function calculateBitbox() private {\\n        // Calculate Bitbox here\\n        if (\\n            _prebits[currentPreBitId].cardsInRows[0] \\u003e 0 \\u0026\\u0026\\n            _prebits[currentPreBitId - 1].cardsInRows[0] \\u003e 0\\n        ) {\\n            // uint256 bitboxAmount = bitBox;\\n\\n            // Iterate through eligible users and distribute the Bitbox\\n            for (uint256 j = 0; j \\u003c row0Precards[currentPreBitId].length; j++) {\\n                address precardUserAddress = _precards[\\n                    row0Precards[currentPreBitId][j]\\n                ].owner;\\n                if (userExistsInRow0(currentPreBitId, precardUserAddress)) {\\n                    bitboxWinners[currentPreBitId].push(precardUserAddress);\\n                }\\n            }\\n\\n            if (bitboxWinners[currentPreBitId].length \\u003e 0) {\\n                uint256 amountPerBitboxWinner = _prebits[currentPreBitId]\\n                    .bitBox\\n                    .div(bitboxWinners[currentPreBitId].length);\\n                for (\\n                    uint256 k = 0;\\n                    k \\u003c bitboxWinners[currentPreBitId].length;\\n                    k++\\n                ) {\\n                    address winner = bitboxWinners[currentPreBitId][k];\\n                    bitboxUsersAmounts[currentPreBitId][winner]\\n                        ._amount += amountPerBitboxWinner;\\n                    bitboxUsersAmounts[currentPreBitId][winner].claimed = false;\\n                }\\n\\n               \\n                pendingBitbox = reserveBitbank;\\n                reserveBitbank=0;\\n            } else {\\n                pendingBitbox = _prebits[currentPreBitId].bitBox;\\n            }\\n        } else {\\n            pendingBitbox = _prebits[currentPreBitId].bitBox;\\n        }\\n    }\\n\\n    /**\\n     * @dev Allows a user to claim their rewards for a specific prebit.\\n     * @param _prebitID The ID of the prebit from which to claim rewards.\\n     */\\n    function claimRewardPrebit(uint256 _prebitID) external {\\n        require(\\n            _prebits[_prebitID].status == Status.End,\\n            \\\"Prebit not claimable\\\"\\n        );\\n        uint256[] memory _preCardsIDs;\\n        _preCardsIDs = getUserPreCardIDs(msg.sender, _prebitID);\\n\\n        require(\\n            _preCardsIDs.length != 0,\\n            \\\"You Don\\u0027t Have Any Precard in This Round\\\"\\n        );\\n        uint256 rewardInUsdtToTransfer;\\n        for (uint256 i = 0; i \\u003c _preCardsIDs.length; i++) {\\n            uint256 thisPrecard = _preCardsIDs[i];\\n\\n            require(\\n                _prebits[_prebitID].firstPrecardId \\u003c= thisPrecard,\\n                \\\"TicketId too low\\\"\\n            );\\n            require(\\n                msg.sender == _precards[thisPrecard].owner,\\n                \\\"Not the owner\\\"\\n            );\\n\\n            // Update the lottery ticket owner to 0x address\\n            _precards[thisPrecard].owner = address(0);\\n\\n            uint256 rewardForPrecardId = _calculateRewardsForOnePrecard(\\n                _prebitID,\\n                thisPrecard\\n            );\\n            _precards[thisPrecard].claimed = true;\\n            // Increment the reward to transfer\\n            rewardInUsdtToTransfer += rewardForPrecardId;\\n        }\\n\\n        require(rewardInUsdtToTransfer \\u003e 0, \\\"You are not winner in this round\\\");\\n        //Transfer to User\\n        payToken.transfer(msg.sender, rewardInUsdtToTransfer.mul(97).div(100));\\n        //Transfer to Referrals lv1\\n        if (referralContract.getUserParent(msg.sender) != address(0)) {\\n            address parentAddress = referralContract.getUserParent(msg.sender);\\n            payToken.transfer(\\n                parentAddress,\\n                rewardInUsdtToTransfer.mul(3).div(100)\\n            );\\n            emit PayReferralsEvent(\\n                parentAddress,\\n                _prebitID,\\n                rewardInUsdtToTransfer.mul(3).div(100),\\n                rewardInUsdtToTransfer.mul(97).div(100),\\n                10\\n            ); //10 means from winner\\n        } else {\\n            _paysTreasury(rewardInUsdtToTransfer.mul(3).div(100));\\n        }\\n\\n        emit ClaimTicketEvent(\\n            msg.sender,\\n            _prebitID,\\n            _preCardsIDs,\\n            rewardInUsdtToTransfer.mul(97).div(100)\\n        );\\n    }\\n\\n    /**\\n     * @dev Distributes funds to various treasury wallets based on configured percentages.\\n     * @param _totalTransfers The total amount to be distributed to treasuries.\\n     */\\n    function _paysTreasury(uint256 _totalTransfers) private {\\n        uint256 remainingAmount = _totalTransfers;\\n        if (treasuryWallets.length \\u003e 0) {\\n            for (uint256 i = 0; i \\u003c treasuryWallets.length; i++) {\\n                uint256 amountToTransfer = (_totalTransfers)\\n                    .mul(treasuryPercentages[i])\\n                    .div(100);\\n\\n                if (amountToTransfer \\u003e 0) {\\n                    remainingAmount -= amountToTransfer;\\n                    payToken.transfer(treasuryWallets[i], amountToTransfer);\\n                }\\n            }\\n\\n            if (remainingAmount \\u003e 0) {\\n                payToken.transfer(treasuryAddress, remainingAmount);\\n            }\\n        } else {\\n            payToken.transfer(treasuryAddress, remainingAmount);\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculate rewards for one precard in a specific prebit.\\n     * @param _prebitId The ID of the prebit for which to calculate rewards.\\n     * @param _precardId The ID of the precard for which to calculate rewards.\\n     * @return The calculated reward amount for the precard.\\n     */\\n    function _calculateRewardsForOnePrecard(\\n        uint256 _prebitId,\\n        uint256 _precardId\\n    ) public view returns (uint256) {\\n        // Retrieve the user number combination from the ticketId\\n        if (!_precards[_precardId].claimed) {\\n            uint256 userPredictPrice = _precards[_precardId].predictPrice;\\n\\n            uint256 rowCard = getRowsTicketInPrebit(\\n                userPredictPrice,\\n                _prebitId\\n            );\\n            if (rowCard != 6) {\\n                // Means not in any rows and return 0\\n                if (getCountAndAmountCardsInRow(_prebitId, rowCard)[2] \\u003e 0) {\\n                    return getCountAndAmountCardsInRow(_prebitId, rowCard)[2];\\n                } else {\\n                    return 0;\\n                }\\n            } else {\\n                return 0;\\n            }\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculate rewards for all precards owned by a specific user in a particular prebit.\\n     * @param _prebitId The ID of the prebit for which to calculate rewards.\\n     * @param _user The address of the user for whom to calculate rewards.\\n     * @return A `RewardResult` struct containing information about claimed status and total rewards.\\n     */\\n    function _calculateRewardsForAllPrecard(uint256 _prebitId, address _user)\\n        public\\n        view\\n        returns (RewardResult memory)\\n    {\\n        // Retrieve the user number combination from the ticketId\\n\\n        uint256[] memory userPrecards = getUserPreCardIDs(_user, _prebitId);\\n        uint256 sumReward = 0;\\n        bool claimed = false;\\n        for (uint256 i = 0; i \\u003c userPrecards.length; i++) {\\n            uint256 userPredictPrice = _precards[userPrecards[i]].predictPrice;\\n            if (_precards[userPrecards[i]].claimed) {\\n                claimed = true;\\n            }\\n\\n            uint256 rowCard = getRowsTicketInPrebit(\\n                userPredictPrice,\\n                _prebitId\\n            );\\n\\n            if (rowCard != 6) {\\n                // Means not in any rows and return 0\\n                if (getCountAndAmountCardsInRow(_prebitId, rowCard)[2] \\u003e 0) {\\n                    sumReward += getCountAndAmountCardsInRow(\\n                        _prebitId,\\n                        rowCard\\n                    )[2];\\n                } else {\\n                    sumReward += 0;\\n                }\\n            } else {\\n                sumReward += 0;\\n            }\\n        }\\n\\n        return RewardResult({claimed: claimed, rewards: sumReward});\\n    }\\n\\n    /**\\n     * @dev Determines the row number a ticket (precard) belongs to based on its predicted price and the final price of a prebit.\\n     *\\n     * @param _cardPrice The predicted price on the ticket.\\n     * @param _prebitId The ID of the prebit for which the row is determined.\\n     * @return An integer representing the row number:\\n     *         - 0: Bitpot row if _cardPrice matches _prebitFinalPrice.\\n     *         - 1 to 5: The row number if _cardPrice falls within the corresponding price range.\\n     *         - 6: Not in any rows if _cardPrice doesn\\u0027t match any criteria.\\n     */\\n    function getRowsTicketInPrebit(uint256 _cardPrice, uint256 _prebitId)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 _prebitFinalPrice = _prebits[_prebitId].finalPrice;\\n        if (_cardPrice == _prebitFinalPrice) {\\n            //Bitpot\\n            return 0;\\n        } else if (\\n            isPredictionWithinRange(_cardPrice, rowsRange[1], _prebitFinalPrice)\\n        ) {\\n            return 1;\\n        } else if (\\n            isPredictionWithinRange(_cardPrice, rowsRange[2], _prebitFinalPrice)\\n        ) {\\n            return 2;\\n        } else if (\\n            isPredictionWithinRange(_cardPrice, rowsRange[3], _prebitFinalPrice)\\n        ) {\\n            return 3;\\n        } else if (\\n            isPredictionWithinRange(_cardPrice, rowsRange[4], _prebitFinalPrice)\\n        ) {\\n            return 4;\\n        } else if (\\n            isPredictionWithinRange(_cardPrice, rowsRange[5], _prebitFinalPrice)\\n        ) {\\n            return 5;\\n        } else {\\n            return 6; //  not in any rows\\n        }\\n    }\\n\\n    /**\\n     * @dev Checks if a given predicted price falls within a specified price range centered around a reference price.\\n     *\\n     * @param _myPrice The predicted price to be checked.\\n     * @param _rangeCent The width of the price range in cents.\\n     * @param _bitcoinPrice The reference price, typically the final Bitcoin price.\\n     * @return A boolean value indicating whether the predicted price is within the specified range.\\n     */\\n    function isPredictionWithinRange(\\n        uint256 _myPrice,\\n        uint256 _rangeCent,\\n        uint256 _bitcoinPrice\\n    ) private pure returns (bool) {\\n        return\\n            (_myPrice \\u003e= _bitcoinPrice.sub(_rangeCent)) \\u0026\\u0026\\n            (_myPrice \\u003c= _bitcoinPrice.add(_rangeCent));\\n    }\\n\\n    /**\\n     * @dev Get an array of precard IDs owned by a specific address for a given prebit.\\n     *\\n     * @param _address The address of the user.\\n     * @param _prebit The ID of the prebit.\\n     * @return An array of precard IDs owned by the address for the specified prebit.\\n     */\\n    function getUserPreCardIDs(address _address, uint256 _prebit)\\n        public\\n        view\\n        returns (uint256[] memory)\\n    {\\n        return _userPreCardIdsPerPreBitId[_address][_prebit];\\n    }\\n\\n    /**\\n     * @dev Get an array of predicted prices for a given array of precard IDs.\\n     *\\n     * @param _cards An array of precard IDs.\\n     * @return An array of predicted prices corresponding to the given precard IDs.\\n     */\\n    function getPredictPriceWithPrecards(uint256[] memory _cards)\\n        public\\n        view\\n        returns (uint256[] memory)\\n    {\\n        uint256[] memory _data = new uint256[](_cards.length);\\n        for (uint256 i = 0; i \\u003c _cards.length; i++) {\\n            _data[i] = _precards[_cards[i]].predictPrice;\\n        }\\n        return _data;\\n    }\\n\\n    /**\\n     * @dev Get the total number of precards in a specific prebit.\\n     *\\n     * @param _prebit The ID of the prebit.\\n     * @return The total number of precards in the specified prebit.\\n     */\\n    function TotalTicketInPrebitId(uint256 _prebit)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        if (currentPreBitId == _prebit) {\\n            return currentPreCardId - (_prebits[_prebit].firstPrecardId);\\n        } else {\\n            return\\n                (_prebits[_prebit + 1].firstPrecardId) -\\n                _prebits[_prebit].firstPrecardId;\\n        }\\n    }\\n\\n    /**\\n     * @dev Get the current BitPot amount.\\n     *\\n     * @return The current amount in the BitPot.\\n     */\\n    function getCurrentBitPot() public view returns (uint256) {\\n        return getCountAndAmountCardsInRow(currentPreBitId, 0)[0];\\n    }\\n\\n    /**\\n     * @dev Get the current BitBox amount.\\n     *\\n     * @return The current amount in the BitBox.\\n     */\\n    function getCurrentBitBox() public view returns (uint256) {\\n        return _prebits[currentPreBitId].bitBox;\\n    }\\n\\n    /**\\n     * @dev Get the total amount in all rows for the current prebit.\\n     *\\n     * @return The total amount in all rows, including the BitBox, for the current prebit.\\n     */\\n    function getCurrentAmountInAllRows() public view returns (uint256) {\\n        uint256 sumAmount = 0;\\n        for (uint256 i = 0; i \\u003c 6; i++) {\\n            sumAmount += getCountAndAmountCardsInRow(currentPreBitId, i)[0];\\n        }\\n        return sumAmount + _prebits[currentPreBitId].bitBox;\\n    }\\n\\n    /**\\n     * @dev Get an array of RowData representing the data for each row in a specific prebit.\\n     *\\n     * @param _prebit The ID of the prebit.\\n     * @return An array of RowData representing the data for each row in the specified prebit.\\n     */\\n    function getRowsData(uint256 _prebit)\\n        public\\n        view\\n        returns (RowData[] memory)\\n    {\\n        RowData[] memory rowArray = new RowData[](6);\\n\\n        for (uint256 i = 0; i \\u003c 6; i++) {\\n            rowArray[i] = RowData({\\n                amountInRow: _prebits[_prebit].amountInRows[i],\\n                cardsInRow: _prebits[_prebit].cardsInRows[i],\\n                rewardEachCard: _prebits[_prebit].rewardEachCard[i]\\n            });\\n        }\\n\\n        return rowArray;\\n    }\\n\\n    /**\\n     * @dev Get an array of precard IDs that won in Row 0 for a specific prebit.\\n     *\\n     * @param _prebitId The ID of the prebit.\\n     * @return An array of precard IDs that won in Row 0 for the specified prebit.\\n     */\\n    function getRow0Winners(uint256 _prebitId)\\n        public\\n        view\\n        returns (uint256[] memory)\\n    {\\n        return row0Precards[_prebitId];\\n    }\\n\\n    /**\\n     * @dev Record a win in Row 0 for a user in a specific prebit.\\n     *\\n     * @param _prebitId The ID of the prebit.\\n     * @param _precard The ID of the precard.\\n     * @param _user The address of the user.\\n     */\\n    function recordWinInRow0(\\n        uint256 _prebitId,\\n        uint256 _precard,\\n        address _user\\n    ) internal {\\n        row0Precards[_prebitId].push(_precard);\\n        row0Winners[_prebitId][_user] = true;\\n    }\\n\\n    /**\\n     * @dev Check if a user exists in Row 0 for a specific prebit.\\n     *\\n     * @param _prebitId The ID of the prebit.\\n     * @param _user The address of the user.\\n     * @return A boolean indicating whether the user exists in Row 0 for the specified prebit and prebit-1.\\n     */\\n    function userExistsInRow0(uint256 _prebitId, address _user)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return\\n            row0Winners[_prebitId][_user] \\u0026\\u0026 row0Winners[_prebitId - 1][_user];\\n    }\\n\\n    /**\\n     * @dev Get Bitbox reward data for a user in a specific prebit.\\n     *\\n     * @param _prebitId The ID of the prebit.\\n     * @param _user The address of the user.\\n     * @return A struct containing Bitbox reward data for the user in the specified prebit.\\n     */\\n    function getRewardAmountUser(uint256 _prebitId, address _user)\\n        public\\n        view\\n        returns (BitboxUserAmount memory)\\n    {\\n        return bitboxUsersAmounts[_prebitId][_user];\\n    }\\n\\n    /**\\n     * @dev Get data for multiple prebits for a specific user.\\n     *\\n     * @param _prebitIds An array of prebit IDs.\\n     * @param _user The address of the user.\\n     * @return An array of PrebitData representing data for each prebit in the list for the specified user.\\n     */\\n    function getLatestPrebitsData(uint256[] memory _prebitIds, address _user)\\n        public\\n        view\\n        returns (PrebitData[] memory)\\n    {\\n        PrebitData[] memory prebitsData = new PrebitData[](_prebitIds.length);\\n\\n        for (uint256 i = 0; i \\u003c _prebitIds.length; i++) {\\n            uint256 prebitId = _prebitIds[i];\\n            uint256 getUserPrecardCount = getUserPreCardIDs(_user, prebitId)\\n                .length;\\n\\n            prebitsData[i] = PrebitData({\\n                endTime: _prebits[prebitId].endTime,\\n                userPrecardCount: getUserPrecardCount\\n            });\\n        }\\n\\n        return prebitsData;\\n    }\\n\\n    /**\\n    * @dev Get the list of Bitbox winners for a specific Prebit round.\\n    *\\n    * @param _prebitId The ID of the Prebit round for which you want to retrieve the winners.\\n    * @return An array of addresses representing the Bitbox winners for the specified Prebit round.\\n    */\\n    function getBitboxWinners(uint256  _prebitId)\\n        public\\n        view\\n        returns (address[] memory)\\n    {\\n       \\n        return bitboxWinners[_prebitId];\\n    }\\n\\n    /**\\n     * @dev Get count and amount of cards in a specific row for a prebit.\\n     *\\n     * @param _prebit The ID of the prebit.\\n     * @param _row The row index.\\n     * @return An array containing count, amount, and reward each card in the specified row for the prebit.\\n     */\\n    function getCountAndAmountCardsInRow(uint256 _prebit, uint256 _row)\\n        public\\n        view\\n        returns (uint256[] memory)\\n    {\\n        uint256[] memory _data = new uint256[](3); // Initialize _data with a length of 3\\n\\n        _data[0] = _prebits[_prebit].amountInRows[_row];\\n        _data[1] = _prebits[_prebit].cardsInRows[_row];\\n        _data[2] = _prebits[_prebit].rewardEachCard[_row];\\n\\n        return _data;\\n    }\\n\\n    /**\\n     * @dev Inject funds into a specific row for a prebit.\\n     *\\n     * @param _prebitId The ID of the prebit.\\n     * @param _amount The amount of funds to inject.\\n     * @param _row The row index to inject funds into.\\n     */\\n    function injectFunds(\\n        uint256 _prebitId,\\n        uint256 _amount,\\n        uint256 _row\\n    ) external onlyOwnerOrInjector {\\n        require(_prebits[_prebitId].status != Status.End, \\\"Prebit not be End\\\");\\n\\n        payToken.transferFrom(address(msg.sender), address(this), _amount);\\n        _prebits[_prebitId].amountInRows[_row] += _amount;\\n\\n        emit InjectFundsEvent(_prebitId, _amount, _row);\\n    }\\n\\n    /**\\n     * @dev Inject funds into the BitBox for a prebit.\\n     *\\n     * @param _prebitId The ID of the prebit.\\n     * @param _amount The amount of funds to inject.\\n     */\\n    function injectFundsBitBank(uint256 _prebitId, uint256 _amount)\\n        external\\n        onlyOwnerOrInjector\\n    {\\n        require(_prebits[_prebitId].status != Status.End, \\\"Prebit not be End\\\");\\n        payToken.transferFrom(address(msg.sender), address(this), _amount);\\n        _prebits[_prebitId].bitBox += _amount;\\n    }\\n\\n    /**\\n     * @dev Inject funds into the BitBox for a prebit from the contract.\\n     *\\n     * @param _prebitId The ID of the prebit.\\n     * @param _amount The amount of funds to inject.\\n     */\\n    function injectFundsBitBoxFromContract(uint256 _prebitId, uint256 _amount)\\n        external\\n        contractInjector\\n    {\\n        require(_prebits[_prebitId].status != Status.End, \\\"Prebit not be End\\\");\\n\\n        _prebits[_prebitId].bitBox += _amount;\\n    }\\n\\n\\n      function injectFundsToReservesFromContract(uint256 _bitboxAmount,uint256 _bitpotAmount)\\n        external\\n        contractInjector\\n    {\\n       reserveBitpot = _bitpotAmount;\\n       reserveBitbank =_bitboxAmount;\\n    }\\n\\n    /**\\n     * @dev Inject funds into a specific row for a prebit from the contract.\\n     *\\n     * @param _prebitId The ID of the prebit.\\n     * @param _amount The amount of funds to inject.\\n     * @param _row The row index to inject funds into.\\n     */\\n    function injectFundsFromContract(\\n        uint256 _prebitId,\\n        uint256 _amount,\\n        uint256 _row\\n    ) external contractInjector {\\n        require(_prebits[_prebitId].status != Status.End, \\\"Prebit not be End\\\");\\n\\n        _prebits[_prebitId].amountInRows[_row] += _amount;\\n\\n        emit InjectFundsEvent(_prebitId, _amount, _row);\\n    }\\n\\n/**\\n * @dev Allows a contract injector to redistribute funds from other rows to Row 0 (BitPot).\\n *\\n * @param _percent The percentage of funds to redistribute (must be 50% or less).\\n */\\nfunction injectToBitpotFromAnotherRows(uint256 _percent)\\n    external\\n    onlyOwnerOrInjector\\n{\\n    require(\\n        _prebits[currentPreBitId].status != Status.End,\\n        \\\"Prebit must not be in \\u0027End\\u0027 status\\\"\\n    );\\n    require(_percent \\u003c= 50, \\\"Percentage must be 50% or less\\\");\\n\\n    uint256 totalAmountToInject = 0;\\n\\n    // Calculate the total amount to redistribute from rows 1 to 5 based on the specified percentage.\\n    for (uint256 row = 1; row \\u003c= 5; row++) {\\n        uint256 rowAmount = getCountAndAmountCardsInRow(currentPreBitId, row)[0];\\n        uint256 amountToRedistribute = (rowAmount * _percent) / 100;\\n\\n        // Ensure that the amount to redistribute does not exceed the balance of the row.\\n        require(rowAmount \\u003e= amountToRedistribute, \\\"Exceeds row balance\\\");\\n\\n        // Decrease the balance of the row.\\n        _prebits[currentPreBitId].amountInRows[row] -= amountToRedistribute;\\n\\n        // Increase the balance of Row 0 (BitPot).\\n        _prebits[currentPreBitId].amountInRows[0] += amountToRedistribute;\\n\\n        totalAmountToInject += amountToRedistribute;\\n    }\\n\\n    // Ensure that the total amount to inject into the BitPot is as expected.\\n    require(totalAmountToInject \\u003c= _prebits[currentPreBitId].amountInRows[0], \\\"Exceeds BitPot balance\\\");\\n\\n    emit InjectFundsEvent(currentPreBitId, totalAmountToInject, 0);\\n}\\n\\n    /**\\n     * @dev Set operator, treasury, and injector addresses.\\n     *\\n     * @param _operatorAddress The address of the operator.\\n     * @param _treasuryAddress The address of the treasury.\\n     * @param _injectorAddress The address of the injector.\\n     */\\n    function setOperatorAndTreasuryAndInjectorAddresses(\\n        address _operatorAddress,\\n        address _treasuryAddress,\\n        address _injectorAddress\\n    ) external onlyOwner {\\n        require(_operatorAddress != address(0), \\\"Cannot be zero address\\\");\\n        require(_treasuryAddress != address(0), \\\"Cannot be zero address\\\");\\n        require(_injectorAddress != address(0), \\\"Cannot be zero address\\\");\\n\\n        operatorAddress = _operatorAddress;\\n        treasuryAddress = _treasuryAddress;\\n        injectorAddress = _injectorAddress;\\n\\n        emit SetAddressesEvent(\\n            _operatorAddress,\\n            _treasuryAddress,\\n            _injectorAddress\\n        );\\n    }\\n\\n    /**\\n     * @dev Set the price of a precard.\\n     *\\n     * @param _newPrice The new price for precards.\\n     */\\n    function setPrecardPrice(uint256 _newPrice) external onlyOwner {\\n        require(\\n            _newPrice \\u003c= MAX_CARD_PRICE,\\n            \\\"Price exceeds the maximum allowed\\\"\\n        );\\n\\n        precardPrice = _newPrice;\\n\\n        emit UpdatePrecardPriceEvent(_newPrice);\\n    }\\n\\n      function setPrecardBonusPrice(uint256 _newPrice) external onlyOwner {\\n      \\n\\n        precardPriceBonus = _newPrice;\\n\\n      \\n    }\\n\\n\\n         function setBonusTokenAddress(address _newAddress) external onlyOwner {\\n      \\n\\n        bonusToken = IERC20(_newAddress);\\n\\n      \\n    }\\n\\n    /**\\n     * @dev Add a treasury wallet address with a percentage share.\\n     *\\n     * @param _wallet The address of the treasury wallet.\\n     * @param _percentage The percentage share for the wallet.\\n     */\\n    function addTreasuryWallet(address _wallet, uint256 _percentage)\\n        external\\n        onlyOwner\\n    {\\n        require(\\n            _wallet != address(0),\\n            \\\"Treasury wallet address cannot be zero\\\"\\n        );\\n        require(_percentage \\u003c= 100, \\\"Percentage must be between 0 and 100\\\");\\n        uint256 totalPercentage = 0;\\n        for (uint256 i = 0; i \\u003c treasuryWallets.length; i++) {\\n            totalPercentage += treasuryPercentages[i];\\n        }\\n        require(\\n            totalPercentage + _percentage \\u003c= 100,\\n            \\\"Percentage must be less than 100\\\"\\n        );\\n\\n        treasuryWallets.push(_wallet);\\n        treasuryPercentages.push(_percentage);\\n    }\\n\\n    /**\\n     * @dev Update a treasury wallet address and its percentage share.\\n     *\\n     * @param _index The index of the treasury wallet to update.\\n     * @param _wallet The new address for the treasury wallet.\\n     * @param _percentage The new percentage share for the wallet.\\n     */\\n    function updateTreasuryWallet(\\n        uint256 _index,\\n        address _wallet,\\n        uint256 _percentage\\n    ) external onlyOwner {\\n        require(_index \\u003c treasuryWallets.length, \\\"Invalid index\\\");\\n        require(\\n            _wallet != address(0),\\n            \\\"Treasury wallet address cannot be zero\\\"\\n        );\\n        require(_percentage \\u003c= 100, \\\"Percentage must be between 1 and 100\\\");\\n\\n        uint256 totalPercentage = 0;\\n        for (uint256 i = 0; i \\u003c treasuryWallets.length; i++) {\\n            totalPercentage += treasuryPercentages[i];\\n        }\\n        require(\\n            totalPercentage + _percentage \\u003c= 100,\\n            \\\"Percentage must be less than 100\\\"\\n        );\\n\\n        treasuryWallets[_index] = _wallet;\\n        treasuryPercentages[_index] = _percentage;\\n    }\\n\\n    /**\\n     * @dev Migrate the contract to a new version. (Just use when we make a new version)\\n     *\\n     * @param _newContract The address of the new contract.\\n     */\\n    function migrateToNewVersion(address _newContract) external onlyOwner {\\n        // Ensure that the new contract address is set\\n        require(_newContract != address(0), \\\"New contract address not set\\\");\\n        //require Status end\\n        require(\\n            _prebits[currentPreBitId].status == Status.End,\\n            \\\"Prebit must be End\\\"\\n        );\\n\\n        // Transfer all pending injections to the new contract\\n\\n        for (uint256 i = 0; i \\u003c pendingInjectionNextPrebit.length; i++) {\\n            payToken.transfer(_newContract, pendingInjectionNextPrebit[i]);\\n            IPrebit(_newContract).injectFundsFromContract(\\n                IPrebit(_newContract).currentPreBitId(),\\n                pendingInjectionNextPrebit[i],\\n                i\\n            );\\n            pendingInjectionNextPrebit[i] = 0;\\n        }\\n\\n        IPrebit(_newContract).injectFundsBitBoxFromContract(\\n            IPrebit(_newContract).currentPreBitId(),\\n            pendingBitbox\\n        );\\n        payToken.transfer(_newContract, pendingBitbox);\\n        pendingBitbox = 0;\\n        //Migrate Reserves\\n        IPrebit(_newContract).injectFundsToReservesFromContract(reserveBitbank,reserveBitbank);\\n         payToken.transfer(_newContract, reserveBitbank);\\n          payToken.transfer(_newContract, reserveBitpot);\\n          reserveBitbank=0;\\n          reserveBitpot=0;\\n        emit MigrateToNewVersionEvent(_newContract);\\n    }\\n\\n    /**\\n     * @dev Set the percentage of rows to be used for injection into the BitPot.\\n     *\\n     * @param _percent The percentage of rows to inject funds into the BitPot.\\n     */\\n    function setPercentOfRowsToInjection(uint256 _percent) external onlyOwner {\\n        require(_percent \\u003c= MAX_ROWS_TO_INJECTION, \\\"Percent exceeds maximum\\\");\\n        percentOfRowsToInjection = _percent;\\n\\n        emit SetPercentOfRowsEvent(_percent);\\n    }\\n\\n    /**\\n     * @dev Set the intervals for opening, closing, and ending prebits.\\n     *\\n     * @param _openInterval The interval duration for opening prebits.\\n     * @param _closeInterval The interval duration for closing prebits.\\n     * @param _endInterval The interval duration for ending prebits.\\n     */\\n    function setIntervals(\\n        uint256 _openInterval,\\n        uint256 _closeInterval,\\n        uint256 _endInterval\\n    ) external onlyOwner {\\n        require(\\n            _openInterval \\u003c _closeInterval,\\n            \\\"Open must be smaller than Close\\\"\\n        );\\n        require(\\n            _closeInterval \\u003c= _endInterval,\\n            \\\"Close must be grater than End\\\"\\n        );\\n\\n        intervalToOpenNextPrebit = _openInterval;\\n        intervalToCloseNextPrebit = _closeInterval;\\n        intervalToEndNextPrebit = _endInterval;\\n\\n        emit SetNewIntervalEvent(_openInterval, _closeInterval, _endInterval);\\n    }\\n}\\n\"},\"Ownable.sol\":{\"content\":\"\\n// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.19;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\"},\"SafeMath.sol\":{\"content\":\"\\n// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.19;\\n\\n\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\\n\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler\\u0027s built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c \\u003c a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b \\u003e a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n            // benefit is lost if \\u0027b\\u0027 is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity\\u0027s `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity\\u0027s `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b \\u003c= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b \\u003e 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b \\u003e 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_payToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_referralContractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_contractInjector\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bonusToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"prebitId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BitboxClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"prebitId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"precards\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClaimTicketEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"prebitId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"finalPrice\",\"type\":\"uint256\"}],\"name\":\"ExecuteDrawFinalPriceEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prebitId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"row\",\"type\":\"uint256\"}],\"name\":\"InjectFundsEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"MigrateToNewVersionEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_parent\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_prebitID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_payReferralAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_totalAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"}],\"name\":\"PayReferralsEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_prebitID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_prediction\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_referralCode\",\"type\":\"uint256\"}],\"name\":\"PurchasePrecardBonusEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_prebitID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"_prediction\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_referralCode\",\"type\":\"uint256\"}],\"name\":\"PurchasePrecardEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operatorAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"treasuryAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"injectorAddress\",\"type\":\"address\"}],\"name\":\"SetAddressesEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"openInterval\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"closeInterval\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endInterval\",\"type\":\"uint256\"}],\"name\":\"SetNewIntervalEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"SetPercentOfRowsEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"prebitId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_endTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_openPrecardTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_closePrecardTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"firstTicketId\",\"type\":\"uint256\"}],\"name\":\"StartNextPrebitEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"UpdatePrecardPriceEvent\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_CARD_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_ROWS_TO_INJECTION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_prebit\",\"type\":\"uint256\"}],\"name\":\"TotalTicketInPrebitId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_prebitId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"_calculateRewardsForAllPrecard\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"claimed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"}],\"internalType\":\"struct MainPrebit.RewardResult\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_prebitId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_precardId\",\"type\":\"uint256\"}],\"name\":\"_calculateRewardsForOnePrecard\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_prebits\",\"outputs\":[{\"internalType\":\"enum MainPrebit.Status\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"openPredictTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"closePredictTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"firstPrecardId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalTreasuryAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalEntryAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bitBox\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finalPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"priceSet\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_precards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"predictPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"claimed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_userPreCardIdsPerPreBitId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_percentage\",\"type\":\"uint256\"}],\"name\":\"addTreasuryWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_prebitId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"openTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"closeTimestamp\",\"type\":\"uint256\"}],\"name\":\"adjustTimestamp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"bitboxUsersAmounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"claimed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bonusToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_prebitId\",\"type\":\"uint256\"}],\"name\":\"claimBitbox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_prebitID\",\"type\":\"uint256\"}],\"name\":\"claimRewardPrebit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractInject\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentPreBitId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentPreCardId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_prebitId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_batchSize\",\"type\":\"uint256\"}],\"name\":\"executeDrawFinalPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_prebitId\",\"type\":\"uint256\"}],\"name\":\"getBitboxWinners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_prebit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_row\",\"type\":\"uint256\"}],\"name\":\"getCountAndAmountCardsInRow\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentAmountInAllRows\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentBitBox\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentBitPot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_prebitIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getLatestPrebitsData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userPrecardCount\",\"type\":\"uint256\"}],\"internalType\":\"struct MainPrebit.PrebitData[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_cards\",\"type\":\"uint256[]\"}],\"name\":\"getPredictPriceWithPrecards\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_prebitId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getRewardAmountUser\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"claimed\",\"type\":\"bool\"}],\"internalType\":\"struct MainPrebit.BitboxUserAmount\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_prebitId\",\"type\":\"uint256\"}],\"name\":\"getRow0Winners\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_prebit\",\"type\":\"uint256\"}],\"name\":\"getRowsData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountInRow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cardsInRow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardEachCard\",\"type\":\"uint256\"}],\"internalType\":\"struct MainPrebit.RowData[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cardPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_prebitId\",\"type\":\"uint256\"}],\"name\":\"getRowsTicketInPrebit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_prebit\",\"type\":\"uint256\"}],\"name\":\"getUserPreCardIDs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_prebitId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_row\",\"type\":\"uint256\"}],\"name\":\"injectFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_prebitId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"injectFundsBitBank\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_prebitId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"injectFundsBitBoxFromContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_prebitId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_row\",\"type\":\"uint256\"}],\"name\":\"injectFundsFromContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bitboxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bitpotAmount\",\"type\":\"uint256\"}],\"name\":\"injectFundsToReservesFromContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_percent\",\"type\":\"uint256\"}],\"name\":\"injectToBitpotFromAnotherRows\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"injectorAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"intervalToCloseNextPrebit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"intervalToEndNextPrebit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"intervalToOpenNextPrebit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestPrecardCalculated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newContract\",\"type\":\"address\"}],\"name\":\"migrateToNewVersion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operatorAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"payToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingBitbox\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pendingInjectionNextPrebit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percentReferralsLv1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percentReferralsLv2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"percentTreasury\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"potPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"precardPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"precardPriceBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_prebitID\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_prediction\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_referralCode\",\"type\":\"uint256\"}],\"name\":\"purchasePrecard\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_prebitID\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_prediction\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_referralCode\",\"type\":\"uint256\"}],\"name\":\"purchasePrecardBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralContract\",\"outputs\":[{\"internalType\":\"contract IPrebitReferrals\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveBitbank\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveBitpot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rowsRange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"setBonusTokenAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_openInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_closeInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endInterval\",\"type\":\"uint256\"}],\"name\":\"setIntervals\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operatorAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasuryAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_injectorAddress\",\"type\":\"address\"}],\"name\":\"setOperatorAndTreasuryAndInjectorAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_percent\",\"type\":\"uint256\"}],\"name\":\"setPercentOfRowsToInjection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newPrice\",\"type\":\"uint256\"}],\"name\":\"setPrecardBonusPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newPrice\",\"type\":\"uint256\"}],\"name\":\"setPrecardPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startNextPrebit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_prebitID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_openPrecardTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_closePrecardTime\",\"type\":\"uint256\"}],\"name\":\"startNextPrebitGenesis\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"treasuryPercentages\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"treasuryWallets\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_percentage\",\"type\":\"uint256\"}],\"name\":\"updateTreasuryWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_prebitId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"userExistsInRow0\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MainPrebit", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000055d398326f99059ff775485246999027b31979550000000000000000000000009a8ae3be63fc293ce1bc934010dcd0132b6585b000000000000000000000000047b11a3afe6538e299c138c031264a10802a7e7a000000000000000000000000df1a5faa82d6d61f86d1df4fa777ef597bf69080", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://08a957ed6db79abda767854fedabdf3837e86fd7f2ba79c4eeb02b4c489af7c5"}