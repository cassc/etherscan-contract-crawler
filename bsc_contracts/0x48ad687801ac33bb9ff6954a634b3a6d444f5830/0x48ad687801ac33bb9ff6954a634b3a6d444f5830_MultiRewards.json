{"SourceCode": "pragma solidity 0.5.17;\r\n\r\n\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * > It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when `approve` or `transferFrom` are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * > Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an `Approval` event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to `approve`. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\ncontract Owned {\r\n    address public owner;\r\n    address public nominatedOwner;\r\n\r\n    constructor(address _owner) public {\r\n        require(_owner != address(0), \"Owner address cannot be 0\");\r\n        owner = _owner;\r\n        emit OwnerChanged(address(0), _owner);\r\n    }\r\n\r\n    function nominateNewOwner(address _owner) external onlyOwner {\r\n        nominatedOwner = _owner;\r\n        emit OwnerNominated(_owner);\r\n    }\r\n\r\n    function acceptOwnership() external {\r\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\r\n        emit OwnerChanged(owner, nominatedOwner);\r\n        owner = nominatedOwner;\r\n        nominatedOwner = address(0);\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        _onlyOwner();\r\n        _;\r\n    }\r\n\r\n    function _onlyOwner() private view {\r\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\r\n    }\r\n\r\n    event OwnerNominated(address newOwner);\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n}\r\n\r\ncontract Pausable is Owned {\r\n    uint public lastPauseTime;\r\n    bool public paused;\r\n\r\n    constructor() internal {\r\n        // This contract is abstract, and thus cannot be instantiated directly\r\n        require(owner != address(0), \"Owner must be set\");\r\n        // Paused will be false, and lastPauseTime will be 0 upon initialisation\r\n    }\r\n\r\n    /**\r\n     * @notice Change the paused state of the contract\r\n     * @dev Only the contract owner may call this.\r\n     */\r\n    function setPaused(bool _paused) external onlyOwner {\r\n        // Ensure we're actually changing the state before we do anything\r\n        if (_paused == paused) {\r\n            return;\r\n        }\r\n\r\n        // Set our paused state.\r\n        paused = _paused;\r\n\r\n        // If applicable, set the last pause time.\r\n        if (paused) {\r\n            lastPauseTime = now;\r\n        }\r\n\r\n        // Let everyone know that our pause state has changed.\r\n        emit PauseChanged(paused);\r\n    }\r\n\r\n    event PauseChanged(bool isPaused);\r\n\r\n    modifier notPaused {\r\n        require(!paused, \"This action cannot be performed while the contract is paused\");\r\n        _;\r\n    }\r\n}\r\n\r\ncontract ReentrancyGuard {\r\n    /// @dev counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    constructor () internal {\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\r\n    }\r\n}\r\n\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract MultiRewards is ReentrancyGuard, Pausable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    /* ========== STATE VARIABLES ========== */\r\n\r\n    struct Reward {\r\n        address rewardsDistributor;\r\n        uint256 rewardsDuration;\r\n        uint256 periodFinish;\r\n        uint256 rewardRate;\r\n        uint256 lastUpdateTime;\r\n        uint256 rewardPerTokenStored;\r\n    }\r\n    IERC20 public stakingToken;\r\n    mapping(address => Reward) public rewardData;\r\n    address[] public rewardTokens;\r\n\r\n    struct RewardRate {\r\n        uint256 startingTime;      // inclusive of this time\r\n\t    uint256 ratePerToken;\t   // reward per second for each token from startingTime to next (exclusive).  last one applicable to lastTimeRewardApplicable\r\n    }\r\n    // reward token -> RewardRate[]\r\n    mapping(address => RewardRate[]) public rewardRatePerToken;\r\n\r\n    // user -> reward token -> amount\r\n    mapping(address => mapping(address => uint256)) public userRewardPerTokenPaid;\r\n    mapping(address => mapping(address => uint256)) public rewards;\r\n\r\n    uint256 private _totalSupply;\r\n    mapping(address => uint256) private _balances;\r\n\r\n    // handling lockup for individual stake\r\n    uint256 public lockDuration;\r\n    // user -> reward token -> amount\r\n    mapping(address => mapping(address => uint256)) public claimedRewards;\r\n\r\n    struct Stake {\r\n        uint256 stakingMaturity;\r\n\t    uint256 remainingBalance;\t\r\n    }    \r\n    // user -> stakes [stake index]\r\n    mapping(address => Stake[]) public userStakes;\r\n\r\n    struct StakeBalance {\r\n        uint256 startingTime;    // inclusive of this time\r\n\t    uint256 sBalance;\t     // balance from startingTime to next (exclusive of next)    \r\n    }\r\n    // user -> StakeBalance[]\r\n    mapping(address => StakeBalance[]) public userStakeBalance;\r\n\r\n    /* ========== CONSTRUCTOR ========== */\r\n\r\n    constructor(\r\n        address _owner,\r\n        address _stakingToken,\r\n        uint256 _lockDuration\r\n    ) public Owned(_owner) {\r\n        stakingToken = IERC20(_stakingToken);\r\n        lockDuration = _lockDuration;\r\n    }\r\n\r\n    function addReward(\r\n        address _rewardsToken,\r\n        address _rewardsDistributor,\r\n        uint256 _rewardsDuration\r\n    )\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(rewardData[_rewardsToken].rewardsDuration == 0, \"reward data of token has been added\");\r\n        require(_rewardsToken != address(0) && _rewardsDistributor != address(0), \"Zero address not allowed\");\r\n        require(_rewardsDuration > 0, \"Reward duration must be non-zero\");\r\n        rewardTokens.push(_rewardsToken);\r\n        rewardData[_rewardsToken].rewardsDistributor = _rewardsDistributor;\r\n        rewardData[_rewardsToken].rewardsDuration = _rewardsDuration;\r\n        emit RewardsDistributorUpdated(_rewardsToken, _rewardsDistributor);\r\n        emit RewardsDurationUpdated(_rewardsToken, _rewardsDuration);\r\n    }\r\n\r\n    /* ========== VIEWS ========== */\r\n\r\n    function totalSupply() external view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) external view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function lastTimeRewardApplicable(address _rewardsToken) public view returns (uint256) {\r\n        return Math.min(block.timestamp, rewardData[_rewardsToken].periodFinish);\r\n    }\r\n\r\n    function rewardPerToken(address _rewardsToken) public view returns (uint256) {\r\n        if (_totalSupply == 0) {\r\n            return rewardData[_rewardsToken].rewardPerTokenStored;\r\n        }\r\n        return\r\n            rewardData[_rewardsToken].rewardPerTokenStored.add(\r\n                lastTimeRewardApplicable(_rewardsToken).sub(rewardData[_rewardsToken].lastUpdateTime).mul(rewardData[_rewardsToken].rewardRate).mul(1e18).div(_totalSupply)\r\n            );\r\n    }\r\n\r\n    function earned(address account, address _rewardsToken) public view returns (uint256) {\r\n        return _balances[account].mul(rewardPerToken(_rewardsToken).sub(userRewardPerTokenPaid[account][_rewardsToken])).div(1e18).add(rewards[account][_rewardsToken]);\r\n    }\r\n    \r\n    function earnedLifetime(address account, address _rewardsToken) public view returns (uint256) {\r\n        uint256 notClaimed = earned(account, _rewardsToken);\r\n        return notClaimed.add(claimedRewards[account][_rewardsToken]);\r\n    }    \r\n\r\n    function getRewardForDuration(address _rewardsToken) external view returns (uint256) {\r\n        return rewardData[_rewardsToken].rewardRate.mul(rewardData[_rewardsToken].rewardsDuration);\r\n    }\r\n    \r\n    function unlockedStakeAtTime(address account, uint256 thisTime, uint256 stakeI) public view returns (uint256) {\r\n\t    if (userStakes[account][stakeI].remainingBalance > 0 && \r\n\t            (block.timestamp >= rewardData[rewardTokens[0]].periodFinish || userStakes[account][stakeI].stakingMaturity <= thisTime ) )\t\t\r\n\t        return userStakes[account][stakeI].remainingBalance;\r\n        else\r\n            return 0;\r\n    }\r\n\r\n    function unlockedStake(address account) public view returns (uint256) {\r\n\t    uint256 actualAmount = 0;\r\n\t    uint256 thisTest = lastTimeRewardApplicable(rewardTokens[0]);\r\n        for (uint i; i < userStakes[account].length; i++) {\r\n\t\t    actualAmount = actualAmount.add(unlockedStakeAtTime(account, thisTest, i));\r\n\t    }\r\n\t    require(actualAmount <= _balances[account], \"internal 0\");\r\n        return actualAmount;\r\n    }\r\n\r\n    // returns the index in rewardRatePerToken s.t. time[index]<= timeT and time[sss+1]>timeT.\r\n    // corner cases:\r\n    //      if timeT >= time[length-1], return length-1\r\n    //      if timeT <= time[0], return 0\r\n    function indexForRate(address _rewardsToken, uint256 timeT) public view returns (uint256) {\r\n        uint256 length = rewardRatePerToken[_rewardsToken].length;\r\n        uint256 sss = length-1;\r\n\r\n        if (length > 1) {    \r\n            for (uint256 j=1; j < length; j++) {\r\n                if (timeT < rewardRatePerToken[_rewardsToken][j].startingTime) {  // rewardRatePerToken[account][j].startingTime is the ending time for j-1 period\r\n                    sss = j.sub(1);\r\n                    break;\r\n                }          \r\n            }\r\n        } else if (length == 1)\r\n            sss = 0;\r\n        else\r\n            sss = 1;   // length == 0, return length+1, invalid\r\n\r\n        return sss;\r\n    }\r\n\r\n    // returns the index in userStakeBalance s.t. time[index]<= timeT and time[sss+1]>timeT.\r\n    // corner cases:\r\n    //      if timeT >= time[length-1], return length-1\r\n    //      if timeT <= time[0], return 0\r\n    function indexForBalance(address account, uint256 timeT) public view returns (uint256) {\r\n        uint256 length = userStakeBalance[account].length;\r\n        uint256 sss = length-1;\r\n\r\n        if (length > 1) {    \r\n            for (uint256 j=1; j < length; j++) {\r\n                if (timeT < userStakeBalance[account][j].startingTime) {  // userStakeBalance[account][j].startingTime is the ending time for j-1 period\r\n                    sss = j.sub(1);\r\n                    break;\r\n                }          \r\n            }\r\n        } else if (length == 1)\r\n            sss = 0;\r\n        else\r\n            sss = 1;   // length == 0, return length+1, invalid\r\n\r\n        return sss;\r\n    }\r\n\r\n    function rewardForNotionalPeriod(uint256 notional, uint256 rewardRate, uint256 start, uint256 end) public pure returns (uint256) {\r\n        require(start <= end, \"time 1\");\r\n        uint256 reward = notional.mul(rewardRate).div(1e18).mul(end.sub(start));\r\n        return reward;\r\n    }   \r\n\r\n    // returns accumulated rewards from time start to end for account on _rewardsToken\r\n    // start is restricted to on or after the first starting time at the earliest for the account\r\n    // end is restricted to be the earliest time of 1) end  2) maturity 3) the current block time\r\n    // so no reward is generated after maturity\r\n    // the ratePerToken across the maturity has to be handled carefully\r\n    function rewardForTimePeriod(address account, address _rewardsToken, uint256 start, uint256 end) public view returns (uint256) {\r\n        if (userStakeBalance[account].length==0)\r\n            return 0;\r\n        if (start >= lastTimeRewardApplicable(_rewardsToken))\r\n            return 0;  // no reward after the applicable time\r\n        start = Math.max(start, userStakeBalance[account][0].startingTime);\r\n        if (end > lastTimeRewardApplicable(_rewardsToken))\r\n            end = lastTimeRewardApplicable(_rewardsToken);\r\n        require(start < end, \"time 0\");      \r\n\r\n        uint256 balIndex = indexForBalance(account, start); \r\n        require(balIndex < userStakeBalance[account].length, \"balance idx 0\");  \r\n\r\n        uint256 timeIndex = indexForRate(_rewardsToken, start);\r\n        require(timeIndex < rewardRatePerToken[_rewardsToken].length, \"rate idx 0\");       \r\n\r\n        uint256 accReward = 0;    \r\n        if (timeIndex == rewardRatePerToken[_rewardsToken].length -1) {\r\n            accReward = rewardForNotionalPeriod(userStakeBalance[account][balIndex].sBalance, rewardRatePerToken[_rewardsToken][timeIndex].ratePerToken, start, end );\r\n        } else {\r\n            // case for timeIndex < length-1, so myStart < time[length-1]\r\n\r\n            // solving the stack too deep problem: separating the first period here  \r\n            {\r\n                uint256 endT = Math.min(end, rewardRatePerToken[_rewardsToken][timeIndex+1].startingTime);\r\n                accReward = rewardForNotionalPeriod(userStakeBalance[account][balIndex].sBalance, rewardRatePerToken[_rewardsToken][timeIndex].ratePerToken, start, endT);\r\n                timeIndex = timeIndex.add(1);  // done the current time period, moving to the next one\r\n            }\r\n\r\n            // integrating intermediate steps.  \r\n            // each step integrating from rewardRatePerToken[_rewardsToken][iii].startingTime to rewardRatePerToken[_rewardsToken][iii+1].startingTime\r\n            // so the loop can only end at length-1\r\n            for ( uint256 iii = timeIndex; iii< rewardRatePerToken[_rewardsToken].length.sub(1); iii++ ) {\r\n                if (end <= rewardRatePerToken[_rewardsToken][iii].startingTime)\r\n                    break;\r\n                // going to the right balIndex if necessary.  the very last one does not have restriction of time\r\n                if (balIndex < userStakeBalance[account].length.sub(1)) {\r\n                    // userStakeBalance[account][balIndex.add(1)].startingTime is the end time for balIndex\r\n                    // rewardRatePerToken[_rewardsToken][iii].startingTime is the starting time for iii\r\n                    if (userStakeBalance[account][balIndex.add(1)].startingTime <= rewardRatePerToken[_rewardsToken][iii].startingTime)\r\n                        balIndex = balIndex.add(1);\r\n                }\r\n                if (end <= rewardRatePerToken[_rewardsToken][iii+1].startingTime) {\r\n                    accReward = accReward.add( rewardForNotionalPeriod(userStakeBalance[account][balIndex].sBalance, rewardRatePerToken[_rewardsToken][iii].ratePerToken, rewardRatePerToken[_rewardsToken][iii].startingTime, end ));\r\n                    break;\r\n                } else\r\n                    accReward = accReward.add( rewardForNotionalPeriod(userStakeBalance[account][balIndex].sBalance, rewardRatePerToken[_rewardsToken][iii].ratePerToken, rewardRatePerToken[_rewardsToken][iii].startingTime, rewardRatePerToken[_rewardsToken][iii+1].startingTime )); \r\n            }\r\n\r\n            // handling the last time period, timeIndex == length-1.  the rate of the last one applies for [lastPeriodTime, maturity)\r\n            // note for current case, myStart < time[length-1]\r\n            {\r\n                uint256 lastIdx = rewardRatePerToken[_rewardsToken].length.sub(1);\r\n                uint256 lastPeriodTime = rewardRatePerToken[_rewardsToken][lastIdx].startingTime;\r\n                if (end > lastPeriodTime) {\r\n                    // userStakeBalance[account][balIndex.add(1)].startingTime is the end time for balIndex\r\n                    // lastPeriodTime is the starting time for the period beyond the end of time index\r\n                    if (balIndex < userStakeBalance[account].length.sub(1)) {\r\n                        if (userStakeBalance[account][balIndex.add(1)].startingTime <= lastPeriodTime)\r\n                            balIndex = balIndex.add(1);\r\n                    }    \r\n                    accReward = accReward.add( rewardForNotionalPeriod(userStakeBalance[account][balIndex].sBalance, rewardRatePerToken[_rewardsToken][lastIdx].ratePerToken, lastPeriodTime, end ));                       \r\n                }  \r\n            }                       \r\n        }\r\n\r\n        return accReward;\r\n    }      \r\n\r\n    function checkRewardForTimePeriod(address account, address _rewardsToken) public view returns (uint256) {\r\n        if (userStakeBalance[account].length == 0)\r\n            return 0;\r\n        uint256 totalReward = earnedLifetime(account,  _rewardsToken);\r\n        uint256 rewardFromIntegration = rewardForTimePeriod( account,  _rewardsToken, userStakeBalance[account][0].startingTime, block.timestamp);\r\n        require(totalReward >= rewardFromIntegration, \"check 0\");\r\n        return totalReward.sub(rewardFromIntegration);\r\n    }  \r\n\r\n    function rewardUnlockCutoffTime(address _rewardsToken) public view returns (uint256) {\r\n        return Math.min(block.timestamp.sub(lockDuration), rewardData[_rewardsToken].periodFinish);\r\n    }\r\n\r\n    function unlockedReward(address account, address _rewardsToken) public view returns (uint256) {\r\n        uint256 sss = userStakeBalance[account].length;\r\n        if (sss==0)\r\n            return 0;\r\n        uint256 startT = userStakeBalance[account][0].startingTime;\r\n        uint256 endT = rewardUnlockCutoffTime(_rewardsToken);\r\n        if (endT <= startT)\r\n            return 0;\r\n        uint256 rewardUnLocked = rewardForTimePeriod( account, _rewardsToken, startT, endT);\r\n        rewardUnLocked = rewardUnLocked.sub(claimedRewards[account][_rewardsToken]);\r\n        uint256 earnedAmount = earned( account, _rewardsToken);\r\n        rewardUnLocked = Math.min(rewardUnLocked, earnedAmount);    // to eusure no possibility of overpaying\r\n        return rewardUnLocked;\r\n    }      \r\n    \r\n    function distributorRemainingReward(address _rewardsToken) public view returns (uint256) {\r\n        return rewards[rewardData[_rewardsToken].rewardsDistributor][_rewardsToken];\r\n    }\r\n    \r\n    function userInfoByIndexRange(address account, uint256 _start, uint256 _stop) external view returns (uint256[2][] memory)  {\r\n        uint256 _allStakeLength = userStakes[account].length;\r\n        if (_stop > _allStakeLength) {\r\n            _stop = _allStakeLength;\r\n        }\r\n        require(_stop >= _start, \"start cannot be higher than stop\");\r\n        uint256 _qty = _stop - _start;\r\n        uint256[2][] memory result = new uint256[2][](_qty);\r\n        for (uint i = 0; i < _qty; i++) {\r\n            result[i][0] = userStakes[account][_start + i].stakingMaturity;\r\n            result[i][1] = userStakes[account][_start + i].remainingBalance;         \r\n        }\r\n        return result;\r\n    }    \r\n\r\n    /* ========== MUTATIVE FUNCTIONS ========== */\r\n\r\n    function setRewardsDistributor(address _rewardsToken, address _rewardsDistributor) external onlyOwner {\r\n        require(_rewardsToken != address(0) && _rewardsDistributor != address(0), \"Zero address not allowed\");\r\n        rewardData[_rewardsToken].rewardsDistributor = _rewardsDistributor;\r\n        emit RewardsDistributorUpdated(_rewardsToken, _rewardsDistributor);\r\n    }\r\n\r\n    function stake(uint256 amount) external nonReentrant notPaused updateReward(msg.sender) {\r\n        require(amount > 0, \"Cannot stake 0\");\r\n        uint256 previousBalance = IERC20(stakingToken).balanceOf(address(this));\r\n        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\r\n        uint256 actualAmount = IERC20(stakingToken).balanceOf(address(this)).sub(previousBalance);\r\n        actualAmount = Math.min(actualAmount, amount);\r\n        _totalSupply = _totalSupply.add(actualAmount);\r\n        _balances[msg.sender] = _balances[msg.sender].add(actualAmount);\r\n\r\n        if (actualAmount > 0) {\r\n            userStakes[msg.sender].push(Stake(block.timestamp.add(lockDuration), actualAmount));\r\n\r\n            {  \r\n                uint256 prev = userStakeBalance[msg.sender].length;\r\n                if (prev > 0 && block.timestamp == userStakeBalance[msg.sender][prev-1].startingTime)\r\n                    // in case the user can stake more than once within the same block.  no reward is generated within this block yet\r\n                    userStakeBalance[msg.sender][prev-1].sBalance = _balances[msg.sender];  \r\n                else\r\n                    userStakeBalance[msg.sender].push(StakeBalance(block.timestamp, _balances[msg.sender]));\r\n            } \r\n            for (uint i = 0; i < rewardTokens.length; i++) {\r\n                require(block.timestamp < rewardData[rewardTokens[i]].periodFinish, \"maturity 0\");\r\n                uint256 prev = rewardRatePerToken[rewardTokens[i]].length;\r\n                uint256 reward_rate = 0;\r\n                if (_totalSupply > 0 )\r\n                    reward_rate = rewardData[rewardTokens[i]].rewardRate.mul(1e18).div(_totalSupply);\r\n                if (prev > 0 && block.timestamp == rewardRatePerToken[rewardTokens[i]][prev-1].startingTime)  // in case same block stake or withdraw\r\n                    rewardRatePerToken[rewardTokens[i]][prev-1].ratePerToken = reward_rate; \r\n                else          \r\n                    rewardRatePerToken[rewardTokens[i]].push(RewardRate(block.timestamp, reward_rate ) );   \r\n            }  \r\n        }\r\n\r\n        emit Staked(msg.sender, actualAmount);\r\n    }\r\n\r\n    function withdraw(uint256 amount) public nonReentrant notPaused updateReward(msg.sender) {\r\n        require(amount > 0, \"Cannot withdraw 0\");\r\n\t    uint256 askedAmount = Math.min(amount, _balances[msg.sender]);\r\n\t    uint256 actualAmount = 0;\r\n\t    uint256 thisTest = lastTimeRewardApplicable(rewardTokens[0]);\r\n        for (uint i; i < userStakes[msg.sender].length; i++) {\r\n            uint256 outAmount = unlockedStakeAtTime(msg.sender, thisTest, i);\r\n            if (outAmount > 0) {\r\n                outAmount = Math.min(outAmount, askedAmount);\r\n\t   \t        userStakes[msg.sender][i].remainingBalance = userStakes[msg.sender][i].remainingBalance.sub(outAmount);\t   \r\n \t   \t        askedAmount = askedAmount.sub(outAmount);\r\n\t\t        actualAmount = actualAmount.add(outAmount);\r\n            }\r\n            if (askedAmount == 0)\r\n        \t    break;\r\n\t    }\r\n        require(actualAmount > 0 && actualAmount <= amount && actualAmount <= _balances[msg.sender], \"No unlocked stake\");    \r\n        _totalSupply = _totalSupply.sub(actualAmount);\r\n        _balances[msg.sender] = _balances[msg.sender].sub(actualAmount);\r\n\r\n        {  \r\n            uint256 prev = userStakeBalance[msg.sender].length;\r\n            if (prev > 0 && block.timestamp == userStakeBalance[msg.sender][prev-1].startingTime)\r\n                userStakeBalance[msg.sender][prev-1].sBalance = _balances[msg.sender];  // in case the user can withdraw more than once within the same block\r\n            else\r\n                userStakeBalance[msg.sender].push(StakeBalance(block.timestamp, _balances[msg.sender]));\r\n        }\r\n        for (uint i = 0; i < rewardTokens.length; i++) {\r\n            uint256 prev = rewardRatePerToken[rewardTokens[i]].length;\r\n            uint256 reward_rate = 0;\r\n            if (_totalSupply > 0 && block.timestamp < rewardData[rewardTokens[i]].periodFinish)\r\n                reward_rate = rewardData[rewardTokens[i]].rewardRate.mul(1e18).div(_totalSupply);\r\n            if (prev > 0 && block.timestamp == rewardRatePerToken[rewardTokens[i]][prev-1].startingTime)  // in case same block stake or withdraw\r\n                rewardRatePerToken[rewardTokens[i]][prev-1].ratePerToken = reward_rate; \r\n            else          \r\n                rewardRatePerToken[rewardTokens[i]].push(RewardRate(block.timestamp, reward_rate ) );   \r\n        } \r\n\r\n        stakingToken.safeTransfer(msg.sender, actualAmount);\r\n        emit Withdrawn(msg.sender, actualAmount);\r\n    }\r\n\r\n    function getReward() public nonReentrant notPaused updateReward(msg.sender) {\r\n        for (uint i; i < rewardTokens.length; i++) {\r\n            address _rewardsToken = rewardTokens[i];\r\n            uint256 reward = rewards[msg.sender][_rewardsToken];\r\n            uint256 actualAmount = unlockedReward(msg.sender, _rewardsToken);\r\n            actualAmount = Math.min(actualAmount, reward);\r\n            if (actualAmount > 0) {  // let 0 case pass so that exit and other i's work\r\n                rewards[msg.sender][_rewardsToken] = rewards[msg.sender][_rewardsToken].sub(actualAmount);\r\n                claimedRewards[msg.sender][_rewardsToken] = actualAmount.add(claimedRewards[msg.sender][_rewardsToken]);\r\n                IERC20(_rewardsToken).safeTransfer(msg.sender, actualAmount);\r\n                emit RewardPaid(msg.sender, _rewardsToken, actualAmount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function exit() external {\r\n        withdraw(_balances[msg.sender]);\r\n        getReward();\r\n    }\r\n\r\n    /* ========== RESTRICTED FUNCTIONS ========== */\r\n\r\n    function notifyRewardAmount(address _rewardsToken, uint256 reward) external updateReward(address(0)) {\r\n        require(rewardData[_rewardsToken].rewardsDistributor == msg.sender);\r\n        // handle the transfer of reward tokens via `transferFrom` to reduce the number\r\n        // of transactions required and ensure correctness of the reward amount\r\n        IERC20(_rewardsToken).safeTransferFrom(msg.sender, address(this), reward);\r\n\r\n        if (block.timestamp >= rewardData[_rewardsToken].periodFinish) {\r\n            rewardData[_rewardsToken].rewardRate = reward.div(rewardData[_rewardsToken].rewardsDuration);\r\n        } else {\r\n            uint256 remaining = rewardData[_rewardsToken].periodFinish.sub(block.timestamp);\r\n            uint256 leftover = remaining.mul(rewardData[_rewardsToken].rewardRate);\r\n            rewardData[_rewardsToken].rewardRate = reward.add(leftover).div(rewardData[_rewardsToken].rewardsDuration);\r\n        }\r\n        rewardData[_rewardsToken].lastUpdateTime = block.timestamp;\r\n        rewardData[_rewardsToken].periodFinish = block.timestamp.add(rewardData[_rewardsToken].rewardsDuration);\r\n        emit RewardAdded(reward);\r\n    }\r\n\r\n    function collectRemainingReward(address _rewardsToken) external nonReentrant updateReward(address(0)) {\r\n        require(rewardData[_rewardsToken].rewardsDistributor == msg.sender);\r\n        require(block.timestamp >= rewardData[_rewardsToken].periodFinish);\r\n        uint256 amount = rewards[msg.sender][_rewardsToken];\r\n        if (amount > 0) {\r\n            rewards[msg.sender][_rewardsToken] = 0;\r\n            IERC20(_rewardsToken).safeTransfer(msg.sender, amount);\r\n        }\r\n    }\r\n\r\n    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\r\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\r\n        require(tokenAddress != address(stakingToken), \"Cannot withdraw staking token\");\r\n        require(rewardData[tokenAddress].lastUpdateTime == 0, \"Cannot withdraw reward token\");\r\n        IERC20(tokenAddress).safeTransfer(owner, tokenAmount);\r\n        emit Recovered(tokenAddress, tokenAmount);\r\n    }\r\n\r\n    /* ========== MODIFIERS ========== */\r\n\r\n    modifier updateReward(address account) {\r\n        for (uint i; i < rewardTokens.length; i++) {\r\n            address token = rewardTokens[i];\r\n            \r\n            if (_totalSupply == 0)\r\n                rewards[rewardData[token].rewardsDistributor][token] = lastTimeRewardApplicable(token).sub(rewardData[token].lastUpdateTime).mul(rewardData[token].rewardRate).add(rewards[rewardData[token].rewardsDistributor][token]);\r\n            \r\n            rewardData[token].rewardPerTokenStored = rewardPerToken(token);\r\n            rewardData[token].lastUpdateTime = lastTimeRewardApplicable(token);\r\n            if (account != address(0)) {\r\n                rewards[account][token] = earned(account, token);\r\n                userRewardPerTokenPaid[account][token] = rewardData[token].rewardPerTokenStored;\r\n            }\r\n        }\r\n        _;\r\n    }\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    event RewardAdded(uint256 reward);\r\n    event Staked(address indexed user, uint256 amount);\r\n    event Withdrawn(address indexed user, uint256 amount);\r\n    event RewardPaid(address indexed user, address indexed rewardsToken, uint256 reward);\r\n    event RewardsDistributorUpdated(address indexed token, address indexed newDistributor);\r\n    event RewardsDurationUpdated(address indexed token, uint256 newDuration);\r\n    event Recovered(address token, uint256 amount);\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stakingToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_lockDuration\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isPaused\",\"type\":\"bool\"}],\"name\":\"PauseChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Recovered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"rewardsToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newDistributor\",\"type\":\"address\"}],\"name\":\"RewardsDistributorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDuration\",\"type\":\"uint256\"}],\"name\":\"RewardsDurationUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardsToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardsDistributor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_rewardsDuration\",\"type\":\"uint256\"}],\"name\":\"addReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardsToken\",\"type\":\"address\"}],\"name\":\"checkRewardForTimePeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimedRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardsToken\",\"type\":\"address\"}],\"name\":\"collectRemainingReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardsToken\",\"type\":\"address\"}],\"name\":\"distributorRemainingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardsToken\",\"type\":\"address\"}],\"name\":\"earned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardsToken\",\"type\":\"address\"}],\"name\":\"earnedLifetime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"exit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardsToken\",\"type\":\"address\"}],\"name\":\"getRewardForDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timeT\",\"type\":\"uint256\"}],\"name\":\"indexForBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardsToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timeT\",\"type\":\"uint256\"}],\"name\":\"indexForRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastPauseTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardsToken\",\"type\":\"address\"}],\"name\":\"lastTimeRewardApplicable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardsToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"notifyRewardAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"recoverERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"rewardsDistributor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rewardsDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"periodFinish\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdateTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerTokenStored\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"notional\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"rewardForNotionalPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardsToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"rewardForTimePeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardsToken\",\"type\":\"address\"}],\"name\":\"rewardPerToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardRatePerToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ratePerToken\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardsToken\",\"type\":\"address\"}],\"name\":\"rewardUnlockCutoffTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardsToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardsDistributor\",\"type\":\"address\"}],\"name\":\"setRewardsDistributor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakingToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardsToken\",\"type\":\"address\"}],\"name\":\"unlockedReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"unlockedStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"thisTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeI\",\"type\":\"uint256\"}],\"name\":\"unlockedStakeAtTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stop\",\"type\":\"uint256\"}],\"name\":\"userInfoByIndexRange\",\"outputs\":[{\"internalType\":\"uint256[2][]\",\"name\":\"\",\"type\":\"uint256[2][]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userRewardPerTokenPaid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userStakeBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userStakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakingMaturity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainingBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MultiRewards", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000cb0b78a732fae669b003b4e4f952993ca530de10000000000000000000000000c71bec3d63297e2833807323a5bf03426d3cc4530000000000000000000000000000000000000000000000000000000000000e10", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://23898aaf32b91796413c8ff4d017533eea91d2c8d21b76ad8f4f49c1b2acc90c"}