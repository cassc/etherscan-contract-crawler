{"SourceCode": "// SPDX-License-Identifier: Unlicensed \r\n// This contract is not open source and can not be used/forked without permission\r\n// Contract created at TokensByGen.com\r\n\r\n/*\r\n\r\n    Query the \"Project_Information\" function on 'BSCScan > Contract > Read Contract' for information on this project\r\n\r\n*/\r\n\r\npragma solidity 0.8.19;\r\n \r\ninterface IERC20 {\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint256);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    function factory() external view returns (address);\r\n}\r\n\r\ninterface IUniswapV2Router02 {\r\n\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n\r\ncontract REFLECTIONS_TOKEN is Context, IERC20 { \r\n\r\n    // Contract Wallets\r\n    address public _owner;\r\n    address public Wallet_Liquidity;\r\n    address payable public Wallet_Marketing;\r\n    address payable public Wallet_Affiliate;\r\n    address payable public constant Wallet_DevFee = payable(0xde491C65E507d281B6a3688d11e8fC222eee0975);\r\n    address public constant Wallet_Burn = 0x000000000000000000000000000000000000dEaD;\r\n\r\n    // GEN address (for affiliate commission level tracking)\r\n    IERC20 GEN = IERC20(0x5a457fb51bD0F50df9eC9F3d0aeC04CD4B9Ce0BF); \r\n\r\n\r\n    // Token Info\r\n    string private  _name;\r\n    string private  _symbol;\r\n    uint256 private _decimals;\r\n    uint256 private _tTotal;\r\n    uint256 private _rTotal;\r\n    uint256 private _tFeeTotal;\r\n    uint256 private constant MAX = ~uint256(0);\r\n\r\n    // Project links\r\n    string private _website;\r\n    string private _telegram;\r\n    string private _lplock;\r\n\r\n    // Wallet and transaction limits\r\n    uint256 private max_Hold;\r\n    uint256 private max_Tran;\r\n\r\n    // Fees - 1% contract fee until removed\r\n    uint8 public _fee__Buy_Contract = 1;\r\n    uint8 public _fee__Buy_Liquidity;\r\n    uint8 public _fee__Buy_Marketing;\r\n    uint8 public _fee__Buy_Reflection;\r\n    uint8 public _fee__Buy_Burn;\r\n\r\n    uint8 public _fee__Sell_Contract = 1;\r\n    uint8 public _fee__Sell_Liquidity;\r\n    uint8 public _fee__Sell_Marketing;\r\n    uint8 public _fee__Sell_Reflection;\r\n    uint8 public _fee__Sell_Burn;\r\n\r\n    // Total Fee for Swap\r\n    uint8 private _SwapFeeTotal_Buy = 1;\r\n    uint8 private _SwapFeeTotal_Sell = 1;\r\n\r\n    bool public contractFeePaid;\r\n\r\n\r\n    // Set factory\r\n    IUniswapV2Router02 public uniswapV2Router;\r\n    address public uniswapV2Pair;\r\n\r\n\r\n    constructor (string memory      _TokenName, \r\n                 string memory      _TokenSymbol,  \r\n                 uint256            _TotalSupply, \r\n                 uint256            _Decimals,\r\n                 address payable    _AffiliateWallet, \r\n                 address payable    _OwnerWallet) {\r\n\r\n        emit TokenCreated(address(this));\r\n\r\n        _name               = _TokenName;\r\n        _symbol             = _TokenSymbol;\r\n        _decimals           = _Decimals;\r\n        _tTotal             = _TotalSupply * 10**_Decimals;\r\n        _rTotal             = (MAX - (MAX % _tTotal));\r\n        max_Hold            = _tTotal;\r\n        max_Tran            = _tTotal;\r\n\r\n        _owner = _OwnerWallet;\r\n        Wallet_Liquidity = _owner;\r\n        Wallet_Marketing = payable(_owner);\r\n        Wallet_Affiliate = payable(_AffiliateWallet);\r\n\r\n        // Whitelist owner so they can add initial liquidity \r\n        _isWhiteListed[_owner] = true;\r\n\r\n        // Wallets excluded from holding limits\r\n        _isLimitExempt[_owner] = true;\r\n        _isLimitExempt[address(this)] = true;\r\n        _isLimitExempt[Wallet_Burn] = true;\r\n\r\n        // Wallets excluded from fees\r\n        _isExcludedFromFee[_owner] = true;\r\n        _isExcludedFromFee[address(this)] = true;\r\n        _isExcludedFromFee[Wallet_Burn] = true;\r\n\r\n        // Exclude from rewards\r\n        _isExcludedFromRewards[Wallet_Burn] = true;\r\n        _isExcludedFromRewards[address(this)] = true;\r\n        _excluded.push(Wallet_Burn);\r\n        _excluded.push(address(this));\r\n\r\n        _rOwned[_owner] = _rTotal;\r\n      \r\n        emit Transfer(address(0), _owner, _tTotal);\r\n        emit OwnershipTransferred(address(0), _owner);\r\n\r\n    }\r\n\r\n    // Events\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event updated_Wallet_Limits(uint256 max_Tran, uint256 max_Hold);\r\n    event updated_Buy_fees(uint8 Marketing, uint8 Liquidity, uint8 Reflection, uint8 Burn, uint8 Contract_Fee);\r\n    event updated_Sell_fees(uint8 Marketing, uint8 Liquidity, uint8 Reflection, uint8 Burn, uint8 Contract_Fee);\r\n    event updated_SwapAndLiquify_Enabled(bool Swap_and_Liquify_Enabled);\r\n    event SwapAndLiquify(uint256 tokensSwapped, uint256 ethReceived, uint256 tokensIntoLiqudity);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    event TokenCreated(address indexed Token_CA);\r\n    event LiquidityAdded(uint256 Tokens_Amount, uint256 BNB_Amount);\r\n\r\n\r\n    // Restrict function to contract owner only \r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    // Address mappings\r\n    mapping (address => uint256) private _tOwned;                               // Tokens Owned\r\n    mapping (address => uint256) private _rOwned;                               // Reflected balance\r\n    mapping (address => mapping (address => uint256)) private _allowances;      // Allowance to spend another wallets tokens\r\n    mapping (address => bool) public _isExcludedFromFee;                        // Wallets that do not pay fees\r\n    mapping (address => bool) public _isExcludedFromRewards;                    // Excluded from RFI rewards\r\n    mapping (address => bool) public _isWhiteListed;                            // Wallets that have access before trade is open\r\n    mapping (address => bool) public _isLimitExempt;                            // Wallets that are excluded from HOLD and TRANSFER limits\r\n    mapping (address => bool) public _isPair;                                   // Address is liquidity pair\r\n    address[] private _excluded;                                                // Array of wallets excluded from rewards\r\n\r\n    // Fee Processing Triggers\r\n    uint256 private swapTrigger = 11; \r\n    uint256 private swapCounter = 1;    \r\n    \r\n    // Fee processing (SwapAndLiquify) Switch                  \r\n    bool public processingFees;\r\n    bool public feeProcessingEnabled; \r\n\r\n    // Launch Settings\r\n    bool public Trade_Open;\r\n    bool public no_Fee_Transfers = true;   // True at launch (Wallet to wallet transfers do not incur a fee)\r\n    bool public burnFromSupply;             // False at launch (Burned tokens are sent to burn wallet, and not removed from supply)\r\n\r\n    // Fee Tracker\r\n    bool private takeFee;\r\n\r\n\r\n    // Project info\r\n    function Project_Information() external view returns(address Owner_Wallet,\r\n                                                       uint256 Transaction_Limit,\r\n                                                       uint256 Max_Wallet,\r\n                                                       uint256 Fee_When_Buying,\r\n                                                       uint256 Fee_When_Selling,\r\n                                                       string memory Website,\r\n                                                       string memory Telegram,\r\n                                                       string memory Liquidity_Lock,\r\n                                                       string memory Contract_Created_By) {\r\n                                                           \r\n        string memory Creator = \"TokensByGen.com\";\r\n\r\n        uint256 Total_buy =  _fee__Buy_Contract     +\r\n                             _fee__Buy_Liquidity    +\r\n                             _fee__Buy_Reflection   +\r\n                             _fee__Buy_Marketing    +\r\n                             _fee__Buy_Burn;\r\n\r\n        uint256 Total_sell = _fee__Sell_Contract    +\r\n                             _fee__Sell_Liquidity   +\r\n                             _fee__Sell_Reflection  +\r\n                             _fee__Sell_Marketing   +\r\n                             _fee__Sell_Burn;\r\n\r\n        uint256 _max_Hold = max_Hold / 10 ** _decimals;\r\n        uint256 _max_Tran = max_Tran / 10 ** _decimals;\r\n\r\n        if (_max_Tran > _max_Hold) {\r\n\r\n            _max_Tran = _max_Hold;\r\n        }\r\n\r\n\r\n        // Return Token Data\r\n        return (_owner,\r\n                _max_Tran,\r\n                _max_Hold,\r\n                Total_buy,\r\n                Total_sell,\r\n                _website,\r\n                _telegram,\r\n                _lplock,\r\n                Creator);\r\n\r\n    }\r\n    \r\n\r\n    function Set_Presale_CA(address Presale_CA) external onlyOwner {\r\n\r\n        _isExcludedFromFee[Presale_CA] = true; \r\n        _isLimitExempt[Presale_CA] = true;\r\n        _isWhiteListed[Presale_CA] = true;\r\n\r\n    }\r\n    \r\n    // Set Buy and Sell Fees\r\n    function Set_Fees(\r\n\r\n        uint8 Marketing_on_BUY, \r\n        uint8 Liquidity_on_BUY, \r\n        uint8 Reflection_on_BUY,\r\n        uint8 Burn_on_BUY,\r\n\r\n        uint8 Marketing_on_SELL,\r\n        uint8 Liquidity_on_SELL,\r\n        uint8 Reflection_on_SELL,\r\n        uint8 Burn_on_SELL\r\n\r\n        ) external onlyOwner {\r\n\r\n        // Buyer Protection: Max Fee 15% (includes the 1% contract fee until removed)\r\n        require (Marketing_on_BUY + Liquidity_on_BUY + Reflection_on_BUY + Burn_on_BUY + _fee__Buy_Contract <= 15, \"FEE1\");  // Max fee 15%\r\n\r\n        // Buyer Protection: Max Fee 15% (includes the 1% contract fee until removed)\r\n        require (Marketing_on_SELL + Liquidity_on_SELL + Reflection_on_SELL + Burn_on_SELL + _fee__Sell_Contract <= 15, \"FEE2\");  // Max fee 15%\r\n\r\n        // Update Fees\r\n        _fee__Buy_Marketing   = Marketing_on_BUY;\r\n        _fee__Buy_Liquidity   = Liquidity_on_BUY;\r\n        _fee__Buy_Reflection  = Reflection_on_BUY;\r\n        _fee__Buy_Burn        = Burn_on_BUY;\r\n\r\n        _fee__Sell_Marketing   = Marketing_on_SELL;\r\n        _fee__Sell_Liquidity   = Liquidity_on_SELL;\r\n        _fee__Sell_Reflection  = Reflection_on_SELL;\r\n        _fee__Sell_Burn        = Burn_on_SELL;\r\n\r\n        // Fees For Processing\r\n        _SwapFeeTotal_Sell   = _fee__Sell_Marketing + _fee__Sell_Liquidity + _fee__Buy_Contract;\r\n        _SwapFeeTotal_Buy    = _fee__Buy_Marketing + _fee__Buy_Liquidity + _fee__Sell_Contract;\r\n\r\n        emit updated_Buy_fees(_fee__Buy_Marketing, _fee__Buy_Liquidity, _fee__Buy_Reflection, _fee__Buy_Burn, _fee__Buy_Contract);\r\n        emit updated_Sell_fees(_fee__Sell_Marketing, _fee__Sell_Liquidity, _fee__Sell_Reflection, _fee__Sell_Burn, _fee__Sell_Contract);\r\n    \r\n    }\r\n\r\n    /*\r\n    \r\n    ------------------------------------------\r\n    SET MAX TRANSACTION AND MAX HOLDING LIMITS\r\n    ------------------------------------------\r\n\r\n    Solidity can only accept whole numbers. \r\n    If you want to set a limit to 0.5% enter 0 (This is the minimum permitted value)\r\n\r\n    */\r\n\r\n\r\n    function Set_Wallet_Limits(\r\n\r\n        uint256 Max_Transaction_Percent,\r\n        uint256 Max_Wallet_Percent\r\n\r\n        ) external onlyOwner {\r\n\r\n        if (Max_Transaction_Percent < 1){\r\n\r\n            // Defaults to 0.5% if 0 is entered\r\n            max_Tran = _tTotal / 200;\r\n\r\n        } else {\r\n\r\n            max_Tran = _tTotal * Max_Transaction_Percent / 100;\r\n\r\n        }\r\n\r\n\r\n        if (Max_Wallet_Percent < 1){\r\n\r\n            // Defaults to 0.5% if 0 is entered\r\n            max_Hold = _tTotal / 200;\r\n\r\n        } else {\r\n\r\n            max_Hold = _tTotal * Max_Wallet_Percent / 100;\r\n\r\n        }\r\n\r\n        emit updated_Wallet_Limits(max_Tran, max_Hold);\r\n\r\n    }\r\n\r\n    // Open Trade\r\n    function Open_Trade() external onlyOwner {\r\n\r\n        require(!Trade_Open, \"TradeOpen\"); // Trade is already open - Trade can not be paused \r\n        feeProcessingEnabled = true;\r\n        Trade_Open = true;\r\n\r\n        // Check if router and pair have been set\r\n        if (uniswapV2Router == IUniswapV2Router02(0x0000000000000000000000000000000000000000)){\r\n\r\n\r\n    IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E); // BSC MAIN\r\n\r\n            uniswapV2Router = _uniswapV2Router;\r\n        }\r\n\r\n        if (uniswapV2Pair == address(0x0000000000000000000000000000000000000000)) {\r\n\r\n            address pairCreated = IUniswapV2Factory(uniswapV2Router.factory()).getPair(address(this), uniswapV2Router.WETH());\r\n\r\n                // Check if pair has been created\r\n                if (pairCreated == address(0x0000000000000000000000000000000000000000)){\r\n\r\n                    // Create and set the pair\r\n                    uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), uniswapV2Router.WETH());\r\n\r\n                } else {\r\n\r\n                    // Set the pair\r\n                    uniswapV2Pair = pairCreated;\r\n                }\r\n            \r\n        }\r\n\r\n        // Set as pair and make limit exempt\r\n        if (!_isPair[uniswapV2Pair]){_isPair[uniswapV2Pair] = true;} \r\n        if (!_isLimitExempt[uniswapV2Pair]){_isLimitExempt[uniswapV2Pair] = true;}\r\n\r\n        // Exclude pair from reflection rewards\r\n        if (!_isExcludedFromRewards[uniswapV2Pair]){\r\n\r\n            if(_rOwned[uniswapV2Pair] > 0) {\r\n                _tOwned[uniswapV2Pair] = tokenFromReflection(_rOwned[uniswapV2Pair]);\r\n            }\r\n\r\n            _isExcludedFromRewards[uniswapV2Pair] = true;\r\n            _excluded.push(uniswapV2Pair);\r\n            }\r\n\r\n    }\r\n\r\n\r\n    /*\r\n\r\n    --------------\r\n    FEE PROCESSING \r\n    --------------\r\n\r\n    */\r\n\r\n\r\n    // Add Liquidity Pair - required for correct fee calculations \r\n    function addLiquidityPair(\r\n\r\n        address Wallet_Address,\r\n        bool true_or_false)\r\n\r\n        external onlyOwner {\r\n\r\n        _isPair[Wallet_Address] = true_or_false;\r\n        _isLimitExempt[Wallet_Address] = true_or_false;\r\n\r\n    } \r\n\r\n    /*\r\n    \r\n    ----------------\r\n    BURN FROM SUPPLY\r\n    ----------------\r\n\r\n    Default = false\r\n\r\n    If false: Burned tokens are sent to the DEAD address\r\n    If true: Burned tokens are not sent to the DEAD address but are removed from the total supply\r\n\r\n    */\r\n\r\n    function burnFromTotalSupply(bool true_or_false) external onlyOwner {\r\n\r\n        burnFromSupply = true_or_false;\r\n    }\r\n    /*\r\n    \r\n    ---------------------------------\r\n    NO FEE WALLET TO WALLET TRANSFERS\r\n    ---------------------------------\r\n\r\n    Default = true\r\n\r\n    Having no fee on wallet-to-wallet transfers means that people can move tokens between wallets, \r\n    or send them to friends etc without incurring a fee. \r\n\r\n    If false, the 'Buy' fee will apply to all wallet to wallet transfers.\r\n\r\n    */\r\n\r\n\r\n    function noFeeWalletTransfers(bool true_or_false) external onlyOwner {\r\n\r\n        no_Fee_Transfers = true_or_false;\r\n\r\n    }\r\n\r\n\r\n    // Auto Fee Processing Switch (SwapAndLiquify)\r\n    function swapAndLiquifySwitch(bool true_or_false) external onlyOwner {\r\n        feeProcessingEnabled = true_or_false;\r\n        emit updated_SwapAndLiquify_Enabled(true_or_false);\r\n    }\r\n    \r\n    function swapTriggerCount(uint256 Transaction_Count) external onlyOwner {\r\n\r\n        swapTrigger = Transaction_Count + 1; // Reset to 1 (not 0) to save gas\r\n    }\r\n\r\n    // Manually Process Fees\r\n    function swapAndLiquifyNow (uint256 Percent_of_Tokens_to_Process) external onlyOwner {\r\n\r\n        require(!processingFees, \"E15\"); // Already in swap, try later\r\n\r\n        if (Percent_of_Tokens_to_Process > 100){Percent_of_Tokens_to_Process = 100;}\r\n        uint256 tokensOnContract = balanceOf(address(this));\r\n        uint256 sendTokens = tokensOnContract * Percent_of_Tokens_to_Process / 100;\r\n        processFees(sendTokens);\r\n\r\n    }  \r\n\r\n    function removeContractFee() external payable {\r\n\r\n        require(msg.value >= 1 * 10 ** 18, \"REQ_1BNB\"); // Payment too low. To remove the 1% contract fee costs 1 BNB\r\n\r\n        uint256 contractFee = msg.value;\r\n\r\n            // Check affiliate\r\n            if(Wallet_Affiliate == Wallet_DevFee){\r\n\r\n                    // Collect Contract Fee 2% until 2 BNB \r\n                    send_BNB(Wallet_DevFee, contractFee);\r\n\r\n                } else {\r\n\r\n                    // Pay affiliate commission based on GEN balance\r\n                    if (GEN.balanceOf(Wallet_Affiliate) > 100000*10**9) {\r\n\r\n                        // 20% Affiliate Commission (Affiliate holds 100k or more GEN)\r\n                        send_BNB(Wallet_Affiliate, contractFee * 20 / 100);\r\n                        send_BNB(Wallet_DevFee, contractFee * 80 / 100);\r\n\r\n                    } else {\r\n\r\n                        // 10% Affiliate Commission (Affiliate holds less than 100k GEN)\r\n                        send_BNB(Wallet_Affiliate, contractFee * 10 / 100);\r\n                        send_BNB(Wallet_DevFee, contractFee * 90 / 100);\r\n                    }\r\n                \r\n                }\r\n                \r\n        contractFeePaid = true;\r\n\r\n        // Remove Contract Fee\r\n        _fee__Buy_Contract  = 0;\r\n        _fee__Sell_Contract = 0;\r\n\r\n        // Update Swap Fees\r\n        _SwapFeeTotal_Buy   = _fee__Buy_Liquidity + _fee__Buy_Marketing;\r\n        _SwapFeeTotal_Sell  = _fee__Sell_Liquidity + _fee__Sell_Marketing;\r\n    }\r\n\r\n\r\n    function rescueTrappedTokens(\r\n\r\n        address random_Token_Address,\r\n        uint256 number_of_Tokens\r\n\r\n        ) external onlyOwner {\r\n\r\n            require (random_Token_Address != address(this), \"E16\"); // Can not remove the native token\r\n            IERC20(random_Token_Address).transfer(msg.sender, number_of_Tokens);\r\n            \r\n    }\r\n\r\n    /*\r\n\r\n    --------------\r\n    UPDATE PROJECT\r\n    --------------\r\n\r\n    */\r\n\r\n    function Update_Links_LP_Lock(\r\n\r\n        string memory LP_Lock_URL\r\n\r\n        ) external onlyOwner{\r\n\r\n        _lplock = LP_Lock_URL;\r\n\r\n    }\r\n\r\n    function Update_Links_Telegram(\r\n\r\n        string memory Telegram_Group\r\n\r\n        ) external onlyOwner{\r\n\r\n        _telegram = Telegram_Group;\r\n\r\n    }\r\n\r\n    function Update_Links_Website(\r\n\r\n        string memory Website_URL\r\n\r\n        ) external onlyOwner{\r\n\r\n        _website = Website_URL;\r\n\r\n    }\r\n\r\n    function Update_Wallet_Liquidity(\r\n\r\n        address Liquidity_Collection_Wallet\r\n\r\n        ) external onlyOwner {\r\n\r\n        // Update LP Collection Wallet\r\n        require(Liquidity_Collection_Wallet != address(0), \"E07\"); // Enter a valid BSC Address\r\n        Wallet_Liquidity = Liquidity_Collection_Wallet;\r\n\r\n    }\r\n\r\n    function Update_Wallet_Marketing(\r\n\r\n        address payable Marketing_Wallet\r\n\r\n        ) external onlyOwner {\r\n\r\n        // Update Marketing Wallet\r\n        require(Marketing_Wallet != address(0), \"E08\"); // Enter a valid BSC Address\r\n        Wallet_Marketing = payable(Marketing_Wallet);\r\n\r\n    }\r\n\r\n\r\n    /*\r\n\r\n    ------------------\r\n    REFLECTION REWARDS\r\n    ------------------\r\n\r\n    The following functions are used to exclude or include a wallet in the reflection rewards.\r\n    By default, all wallets are included. \r\n\r\n    Wallets that are excluded:\r\n\r\n            The Burn address \r\n            The Liquidity Pair\r\n            The Contract Address\r\n\r\n    ----------------------------------------\r\n    *** WARNING - DoS 'OUT OF GAS' Risk! ***\r\n    ----------------------------------------\r\n\r\n    A reflections contract needs to loop through all excluded wallets to correctly process several functions. \r\n    This loop can break the contract if it runs out of gas before completion.\r\n\r\n    To prevent this, keep the number of wallets that are excluded from rewards to an absolute minimum. \r\n    In addition to the default excluded wallets, you may need to exclude the address of any locked tokens.\r\n\r\n    */\r\n\r\n    // Wallet will not get reflections\r\n    function Rewards_Exclude_Wallet(address account) public onlyOwner() {\r\n        require(!_isExcludedFromRewards[account], \"Account is already excluded\");\r\n        if(_rOwned[account] > 0) {\r\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\r\n        }\r\n        _isExcludedFromRewards[account] = true;\r\n        _excluded.push(account);\r\n    }\r\n\r\n\r\n    // Wallet will get reflections - DEFAULT\r\n    function Rewards_Include_Wallet(address account) external onlyOwner() {\r\n        require(_isExcludedFromRewards[account], \"Account is already included\");\r\n        for (uint256 i = 0; i < _excluded.length; i++) {\r\n            if (_excluded[i] == account) {\r\n                _excluded[i] = _excluded[_excluded.length - 1];\r\n                _tOwned[account] = 0;\r\n                _isExcludedFromRewards[account] = false;\r\n                _excluded.pop();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    \r\n\r\n\r\n\r\n    /*\r\n\r\n    ---------------\r\n    WALLET SETTINGS\r\n    ---------------\r\n\r\n    */\r\n\r\n\r\n    // Exclude From Transaction and Holding Limits\r\n    function Wallet_Exempt_From_Limits(\r\n\r\n        address Wallet_Address,\r\n        bool true_or_false\r\n\r\n        ) external onlyOwner {  \r\n        _isLimitExempt[Wallet_Address] = true_or_false;\r\n    }\r\n\r\n    // Exclude From Fees\r\n    function Wallet_Exclude_From_Fees(\r\n\r\n        address Wallet_Address,\r\n        bool true_or_false\r\n\r\n        ) external onlyOwner {\r\n        _isExcludedFromFee[Wallet_Address] = true_or_false;\r\n\r\n    }\r\n\r\n    // Grant Pre-Launch Access (Whitelist)\r\n    function Wallet_Pre_Launch_Access(\r\n\r\n        address Wallet_Address,\r\n        bool true_or_false\r\n\r\n        ) external onlyOwner {    \r\n        _isWhiteListed[Wallet_Address] = true_or_false;\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    /* \r\n\r\n    ----------------------------\r\n    CONTRACT OWNERSHIP FUNCTIONS\r\n    ----------------------------\r\n\r\n\r\n    */\r\n\r\n  \r\n    // Renounce Ownership\r\n    function ownership_RENOUNCE() public virtual onlyOwner {\r\n\r\n\r\n        // Remove old owner status \r\n        _isLimitExempt[owner()]     = false;\r\n        _isExcludedFromFee[owner()] = false;\r\n        _isWhiteListed[owner()]     = false;\r\n\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    // Transfer to New Owner \r\n    function ownership_TRANSFER(address payable newOwner) public onlyOwner {\r\n\r\n        require(newOwner != address(0), \"ZEROADD\"); // Enter a valid BSC wallet\r\n\r\n        // Revoke old owner status\r\n        _isLimitExempt[owner()]     = false;\r\n        _isExcludedFromFee[owner()] = false;\r\n        _isWhiteListed[owner()]     = false;\r\n\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n\r\n    }\r\n\r\n\r\n    /*\r\n\r\n    -----------------------------\r\n    BEP20 STANDARD AND COMPLIANCE\r\n    -----------------------------\r\n\r\n    */\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns (uint256) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _tTotal;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        if (_isExcludedFromRewards[account]) return _tOwned[account];\r\n        return tokenFromReflection(_rOwned[account]);\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n    \r\n    function _approve(address owner, address spender, uint256 amount) private {\r\n        require(owner != address(0), \"BEP20: approve from the zero address\");\r\n        require(spender != address(0), \"BEP20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n   \r\n    function tokenFromReflection(uint256 _rAmount) internal view returns(uint256) {\r\n        require(_rAmount <= _rTotal, \"rAmount can not be greater than rTotal\");\r\n        uint256 currentRate =  _getRate();\r\n        return _rAmount / currentRate;\r\n    }\r\n\r\n    function _getRate() private view returns(uint256) {\r\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\r\n        return rSupply / tSupply;\r\n    }\r\n\r\n    function _getCurrentSupply() private view returns(uint256, uint256) {\r\n        uint256 rSupply = _rTotal;\r\n        uint256 tSupply = _tTotal;      \r\n        for (uint256 i = 0; i < _excluded.length; i++) {\r\n            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\r\n            rSupply = rSupply - _rOwned[_excluded[i]];\r\n            tSupply = tSupply - _tOwned[_excluded[i]];\r\n        }\r\n        if (rSupply < _rTotal / _tTotal) return (_rTotal, _tTotal);\r\n        return (rSupply, tSupply);\r\n    }\r\n\r\n\r\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n\r\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n        _approve(sender, _msgSender(), currentAllowance - amount);\r\n\r\n        return true;\r\n    }\r\n    \r\n    function send_BNB(address _to, uint256 _amount) internal returns (bool SendSuccess) {\r\n                                \r\n        (SendSuccess,) = payable(_to).call{value: _amount}(\"\");\r\n\r\n    }\r\n\r\n    function getCirculatingSupply() public view returns (uint256) {\r\n        return (_tTotal - balanceOf(address(Wallet_Burn)));\r\n    }\r\n\r\n\r\n\r\n    /*\r\n\r\n    ---------------\r\n    TOKEN TRANSFERS\r\n    ---------------\r\n\r\n    */\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n      ) private {\r\n\r\n\r\n\r\n\r\n        require(balanceOf(from) >= amount, \"TO1\"); // Sender does not have enough tokens!\r\n\r\n       \r\n\r\n        if (!Trade_Open && from != address(this)){\r\n\r\n            require(_isWhiteListed[from] || _isWhiteListed[to], \"TO2\");  // Trade closed, only whitelisted wallets can move tokens\r\n\r\n\r\n        }\r\n\r\n        // Wallet Limit\r\n        if (!_isLimitExempt[to] && from != owner()) {\r\n\r\n            uint256 heldTokens = balanceOf(to);\r\n            require((heldTokens + amount) <= max_Hold, \"WL\"); // Over max wallet limit\r\n\r\n        }\r\n\r\n        // Transaction limit - To send over the transaction limit the sender AND the recipient must be limit exempt\r\n        if (!_isLimitExempt[to] || !_isLimitExempt[from]){\r\n\r\n            require(amount <= max_Tran, \"TL\"); // Over max transaction limit\r\n            \r\n        }\r\n\r\n\r\n\r\n        // Compliance and safety checks\r\n        require(from != address(0), \"FROM0\"); // Not a valid BSC wallet address\r\n        require(to != address(0), \"TO0\"); // Not a valid BSC wallet address\r\n        require(amount > 0, \"AMT0\"); // Amount must be greater than 0\r\n\r\n      \r\n        if(_isExcludedFromFee[from] || _isExcludedFromFee[to] || (no_Fee_Transfers && !_isPair[to] && !_isPair[from])){\r\n            takeFee = false;\r\n        } else {\r\n            takeFee = true;\r\n        }\r\n\r\n        // Trigger Fee Processing\r\n        if (_isPair[to] && !processingFees && feeProcessingEnabled) {\r\n\r\n            // Check Transaction Count\r\n            if(swapCounter >= swapTrigger){\r\n\r\n                // Check Contract Tokens\r\n                uint256 contractTokens = balanceOf(address(this));\r\n\r\n                if (contractTokens > 0) {\r\n\r\n\r\n                    // Limit Swap to Max Transaction\r\n                    if (contractTokens <= max_Tran) {\r\n\r\n                        processFees (contractTokens);\r\n\r\n                        } else {\r\n\r\n                        processFees (max_Tran);\r\n\r\n                    }\r\n                }\r\n            }  \r\n        }\r\n\r\n\r\n        _tokenTransfer(from, to, amount, takeFee);\r\n\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n    /*\r\n    \r\n    ------------\r\n    PROCESS FEES\r\n    ------------\r\n\r\n    */\r\n\r\n    function processFees(uint256 Tokens) private {\r\n\r\n        // Lock Swap\r\n        processingFees = true;\r\n\r\n        // Totals for buy and sell fees\r\n        uint8 _LiquidityTotal   = _fee__Buy_Liquidity + _fee__Sell_Liquidity;\r\n        uint8 _FeesTotal        = _SwapFeeTotal_Buy + _SwapFeeTotal_Sell;\r\n\r\n        // Calculate tokens for swap\r\n        uint256 LP_Tokens       = Tokens * _LiquidityTotal / _FeesTotal / 2;\r\n        uint256 Swap_Tokens     = Tokens - LP_Tokens;\r\n\r\n        // Swap Tokens\r\n        uint256 contract_BNB    = address(this).balance;\r\n        swapTokensForBNB(Swap_Tokens);\r\n        uint256 returned_BNB    = address(this).balance - contract_BNB;\r\n\r\n        // Avoid Rounding Errors on LP Fee if Odd Number\r\n        uint256 fee_Split       = _FeesTotal * 2 - _LiquidityTotal;\r\n\r\n        // Add auto liquidity \r\n        if (_LiquidityTotal > 0 ) {\r\n\r\n            uint256 BNB_Liquidity = returned_BNB * _LiquidityTotal / fee_Split;\r\n            addLiquidity(LP_Tokens, BNB_Liquidity);\r\n            emit SwapAndLiquify(LP_Tokens, BNB_Liquidity, LP_Tokens);\r\n        \r\n        }\r\n\r\n        if (!contractFeePaid){\r\n\r\n            // Calculate and take contract fee (2 = 1% on buys and sells *2 to match fee split to avoid odd number rounding error on LP calculations)\r\n            uint256 BNB_ContractFee = returned_BNB * 2 * 2 / fee_Split;\r\n\r\n            // Check affiliate\r\n            if(Wallet_Affiliate == Wallet_DevFee){\r\n\r\n                    // Collect Contract Fee 2% until 2 BNB \r\n                    send_BNB(Wallet_DevFee, BNB_ContractFee);\r\n\r\n                } else {\r\n\r\n                    // Pay affiliate commission based on GEN balance\r\n                    if (GEN.balanceOf(Wallet_Affiliate) > 100000*10**9) {\r\n\r\n                        // 20% Affiliate Commission (Affiliate holds 100k or more GEN)\r\n                        send_BNB(Wallet_Affiliate, BNB_ContractFee * 20 / 100);\r\n                        send_BNB(Wallet_DevFee, BNB_ContractFee * 80 / 100);\r\n\r\n                    } else {\r\n\r\n                        // 10% Affiliate Commission (Affiliate holds less than 100k GEN)\r\n                        send_BNB(Wallet_Affiliate, BNB_ContractFee * 10 / 100);\r\n                        send_BNB(Wallet_DevFee, BNB_ContractFee * 90 / 100);\r\n                    }\r\n                \r\n                }\r\n\r\n            }\r\n\r\n        \r\n        // Flush Remaining BNB to Marketing Wallet\r\n        contract_BNB = address(this).balance;\r\n\r\n        if (contract_BNB > 0){\r\n\r\n            send_BNB(Wallet_Marketing, contract_BNB);\r\n        }\r\n\r\n\r\n        // Reset Counter\r\n        swapCounter = 1;\r\n\r\n        // Unlock Swap\r\n        processingFees = false;\r\n\r\n\r\n    }\r\n\r\n    // Swap tokens for BNB\r\n    function swapTokensForBNB(uint256 tokenAmount) private {\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = uniswapV2Router.WETH();\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0, \r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    // Add liquidity and send Cake LP tokens to liquidity collection wallet\r\n    function addLiquidity(uint256 tokenAmount, uint256 BNBAmount) private {\r\n\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        uniswapV2Router.addLiquidityETH{value: BNBAmount}(\r\n            address(this),\r\n            tokenAmount,\r\n            0, \r\n            0,\r\n            Wallet_Liquidity, \r\n            block.timestamp\r\n        );\r\n    } \r\n\r\n    /*\r\n    \r\n    ----------------------------------\r\n    TRANSFER TOKENS AND CALCULATE FEES\r\n    ----------------------------------\r\n\r\n    */\r\n\r\n    // Non local to avoid stack too deep error\r\n    uint256 private tBurn;\r\n\r\n    // Transfer Tokens and Calculate Fees\r\n    function _tokenTransfer(address sender, address recipient, uint256 tAmount, bool Fee) private {\r\n\r\n    \r\n    uint256  tReflect;\r\n    uint256  tSwapFeeTotal;\r\n        \r\n        if (Fee){\r\n\r\n            if(_isPair[recipient]){\r\n\r\n                // Sell fees\r\n                tSwapFeeTotal   = tAmount * _SwapFeeTotal_Sell    / 100;\r\n                tReflect        = tAmount * _fee__Sell_Reflection / 100;\r\n                tBurn           = tAmount * _fee__Sell_Burn       / 100;\r\n\r\n            } else {\r\n\r\n                // Buy fees\r\n                tSwapFeeTotal   = tAmount * _SwapFeeTotal_Buy     / 100;\r\n                tReflect        = tAmount * _fee__Buy_Reflection  / 100;\r\n                tBurn           = tAmount * _fee__Buy_Burn        / 100;\r\n\r\n            }\r\n\r\n        } else {\r\n\r\n                tSwapFeeTotal   = 0;\r\n                tReflect        = 0;\r\n                tBurn           = 0;\r\n\r\n        }\r\n\r\n        uint256 tTransferAmount = tAmount - (tSwapFeeTotal + tReflect + tBurn);\r\n\r\n\r\n        // Calculate reflected fees for RFI\r\n        uint256 RFI     = _getRate(); \r\n\r\n        uint256 rAmount         = tAmount       * RFI;\r\n        uint256 rBurn           = tBurn         * RFI;\r\n        uint256 rReflect        = tReflect      * RFI;\r\n        uint256 rSwapFeeTotal   = tSwapFeeTotal * RFI;\r\n\r\n        uint256 rTransferAmount = rAmount - (rReflect + rSwapFeeTotal + rBurn);\r\n\r\n\r\n        // Remove tokens from sender\r\n        _rOwned[sender] -= rAmount;\r\n        if(_isExcludedFromRewards[sender]){\r\n            _tOwned[sender] -= tAmount;\r\n        }\r\n\r\n        // Send tokens to recipient or remove from supply\r\n        if (recipient == Wallet_Burn && burnFromSupply) {\r\n\r\n            _tTotal -= tTransferAmount;\r\n            _rTotal -= rTransferAmount;\r\n            \r\n            } else {\r\n\r\n                _rOwned[recipient] += rTransferAmount;\r\n\r\n                if(_isExcludedFromRewards[recipient]){\r\n                    _tOwned[recipient] += tTransferAmount;\r\n                }\r\n            }\r\n\r\n        emit Transfer(sender, recipient, tTransferAmount);\r\n\r\n        // Take reflections\r\n        if(tReflect > 0){\r\n\r\n            _rTotal -= rReflect;\r\n            _tFeeTotal += tReflect;\r\n        }\r\n\r\n        // Take fees that require processing during swap and liquify\r\n        if(tSwapFeeTotal > 0){\r\n\r\n            _rOwned[address(this)] += rSwapFeeTotal;\r\n            if(_isExcludedFromRewards[address(this)]){_tOwned[address(this)] += tSwapFeeTotal;}\r\n            emit Transfer(sender, address(this), tSwapFeeTotal);\r\n\r\n            // Increase the transaction counter\r\n            if(swapCounter < swapTrigger){\r\n                unchecked{swapCounter++;}\r\n            }\r\n                \r\n        }\r\n\r\n        // Take burn fee\r\n        if(tBurn > 0){\r\n\r\n            if(burnFromSupply){\r\n\r\n                _tTotal -= tBurn;\r\n                _rTotal -= rBurn;\r\n\r\n                } else {\r\n\r\n                _rOwned[Wallet_Burn] += rBurn;\r\n                if(_isExcludedFromRewards[Wallet_Burn]){_tOwned[Wallet_Burn] += tBurn;}\r\n           \r\n                emit Transfer(sender, Wallet_Burn, tBurn);\r\n                \r\n            }\r\n                \r\n        }\r\n\r\n    }\r\n\r\n\r\n    // This function is required so that the contract can receive BNB during fee processing\r\n    receive() external payable {}\r\n\r\n}\r\n\r\n\r\n\r\n/*\r\n\r\n\r\n    Token Created at https://TokensByGen.com\r\n    This contract is not open source - Can not be used or forked without permission.\r\n    \r\n\r\n*/", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_TokenName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_TokenSymbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_TotalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_Decimals\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_AffiliateWallet\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_OwnerWallet\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Tokens_Amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"BNB_Amount\",\"type\":\"uint256\"}],\"name\":\"LiquidityAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiqudity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"Token_CA\",\"type\":\"address\"}],\"name\":\"TokenCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"Marketing\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"Liquidity\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"Reflection\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"Burn\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"Contract_Fee\",\"type\":\"uint8\"}],\"name\":\"updated_Buy_fees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"Marketing\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"Liquidity\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"Reflection\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"Burn\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"Contract_Fee\",\"type\":\"uint8\"}],\"name\":\"updated_Sell_fees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"Swap_and_Liquify_Enabled\",\"type\":\"bool\"}],\"name\":\"updated_SwapAndLiquify_Enabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"max_Tran\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"max_Hold\",\"type\":\"uint256\"}],\"name\":\"updated_Wallet_Limits\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"Open_Trade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Project_Information\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"Owner_Wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"Transaction_Limit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Max_Wallet\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Fee_When_Buying\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Fee_When_Selling\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"Website\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"Telegram\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"Liquidity_Lock\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"Contract_Created_By\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Rewards_Exclude_Wallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Rewards_Include_Wallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"Marketing_on_BUY\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"Liquidity_on_BUY\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"Reflection_on_BUY\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"Burn_on_BUY\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"Marketing_on_SELL\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"Liquidity_on_SELL\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"Reflection_on_SELL\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"Burn_on_SELL\",\"type\":\"uint8\"}],\"name\":\"Set_Fees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Presale_CA\",\"type\":\"address\"}],\"name\":\"Set_Presale_CA\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"Max_Transaction_Percent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Max_Wallet_Percent\",\"type\":\"uint256\"}],\"name\":\"Set_Wallet_Limits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Trade_Open\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"LP_Lock_URL\",\"type\":\"string\"}],\"name\":\"Update_Links_LP_Lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"Telegram_Group\",\"type\":\"string\"}],\"name\":\"Update_Links_Telegram\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"Website_URL\",\"type\":\"string\"}],\"name\":\"Update_Links_Website\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Liquidity_Collection_Wallet\",\"type\":\"address\"}],\"name\":\"Update_Wallet_Liquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"Marketing_Wallet\",\"type\":\"address\"}],\"name\":\"Update_Wallet_Marketing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Wallet_Affiliate\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Wallet_Burn\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Wallet_DevFee\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Wallet_Address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"true_or_false\",\"type\":\"bool\"}],\"name\":\"Wallet_Exclude_From_Fees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Wallet_Address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"true_or_false\",\"type\":\"bool\"}],\"name\":\"Wallet_Exempt_From_Limits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Wallet_Liquidity\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Wallet_Marketing\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Wallet_Address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"true_or_false\",\"type\":\"bool\"}],\"name\":\"Wallet_Pre_Launch_Access\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_fee__Buy_Burn\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_fee__Buy_Contract\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_fee__Buy_Liquidity\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_fee__Buy_Marketing\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_fee__Buy_Reflection\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_fee__Sell_Burn\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_fee__Sell_Contract\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_fee__Sell_Liquidity\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_fee__Sell_Marketing\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_fee__Sell_Reflection\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isExcludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isExcludedFromRewards\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isLimitExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isPair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isWhiteListed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Wallet_Address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"true_or_false\",\"type\":\"bool\"}],\"name\":\"addLiquidityPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnFromSupply\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"true_or_false\",\"type\":\"bool\"}],\"name\":\"burnFromTotalSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractFeePaid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeProcessingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"true_or_false\",\"type\":\"bool\"}],\"name\":\"noFeeWalletTransfers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"no_Fee_Transfers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownership_RENOUNCE\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"ownership_TRANSFER\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"processingFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeContractFee\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"random_Token_Address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"number_of_Tokens\",\"type\":\"uint256\"}],\"name\":\"rescueTrappedTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"Percent_of_Tokens_to_Process\",\"type\":\"uint256\"}],\"name\":\"swapAndLiquifyNow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"true_or_false\",\"type\":\"bool\"}],\"name\":\"swapAndLiquifySwitch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"Transaction_Count\",\"type\":\"uint256\"}],\"name\":\"swapTriggerCount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "REFLECTIONS_TOKEN", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000f42400000000000000000000000000000000000000000000000000000000000000004000000000000000000000000888220cf888894a717eaffd9c29480c52c5cbbb7000000000000000000000000888220cf888894a717eaffd9c29480c52c5cbbb70000000000000000000000000000000000000000000000000000000000000004544553540000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000045445535400000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://bf6002dec56e48b4521a7f5df16731141c1dbc70a0a8d868692362ed8134a0c7"}