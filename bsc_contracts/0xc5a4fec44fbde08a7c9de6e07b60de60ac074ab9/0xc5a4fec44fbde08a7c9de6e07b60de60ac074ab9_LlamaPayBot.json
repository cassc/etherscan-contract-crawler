{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/LlamaPayBot.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: AGPL-3.0-only\\n\\npragma solidity ^0.8.0;\\n\\nimport {ERC20} from \\\"solmate/tokens/ERC20.sol\\\";\\nimport {SafeTransferLib} from \\\"solmate/utils/SafeTransferLib.sol\\\";\\n\\ninterface LlamaPay {\\n    function withdraw(\\n        address from,\\n        address to,\\n        uint216 amountPerSec\\n    ) external;\\n\\n    function withdrawable(\\n        address from,\\n        address to,\\n        uint216 amountPerSec\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 withdrawableAmount,\\n            uint256 lastUpdate,\\n            uint256 owed\\n        );\\n}\\n\\ninterface LlamaPayFactory {\\n    function getLlamaPayContractByToken(address _token)\\n        external\\n        view\\n        returns (address predictedAddress, bool isDeployed);\\n}\\n\\ncontract LlamaPayBot {\\n    using SafeTransferLib for ERC20;\\n\\n    address public immutable factory;\\n    address public bot;\\n    address public llama;\\n    address public newLlama = address(0);\\n    uint256 public fee = 50000; // Covers bot gas cost for calling function\\n\\n    event WithdrawScheduled(\\n        address owner,\\n        address token,\\n        address from,\\n        address to,\\n        uint216 amountPerSec,\\n        uint40 starts,\\n        uint40 frequency,\\n        bytes32 id\\n    );\\n\\n    event WithdrawCancelled(\\n        address owner,\\n        address token,\\n        address from,\\n        address to,\\n        uint216 amountPerSec,\\n        uint40 starts,\\n        uint40 frequency,\\n        bytes32 id\\n    );\\n\\n    event WithdrawExecuted(\\n        address owner,\\n        address token,\\n        address from,\\n        address to,\\n        uint216 amountPerSec,\\n        uint40 starts,\\n        uint40 frequency,\\n        bytes32 id\\n    );\\n\\n    mapping(address => uint256) public balances;\\n    mapping(bytes32 => address) public owners;\\n    mapping(address => address) public redirects;\\n\\n    constructor(\\n        address _factory,\\n        address _bot,\\n        address _llama\\n    ) {\\n        factory = _factory;\\n        bot = _bot;\\n        llama = _llama;\\n    }\\n\\n    function deposit() external payable {\\n        require(msg.sender != bot, \\\"bot cannot deposit\\\");\\n        balances[msg.sender] += msg.value;\\n    }\\n\\n    function refund() external {\\n        uint256 toSend = balances[msg.sender];\\n        balances[msg.sender] = 0;\\n        (bool sent, ) = msg.sender.call{value: toSend}(\\\"\\\");\\n        require(sent, \\\"failed to send ether\\\");\\n    }\\n\\n    function scheduleWithdraw(\\n        address _token,\\n        address _from,\\n        address _to,\\n        uint216 _amountPerSec,\\n        uint40 _starts,\\n        uint40 _frequency\\n    ) external returns (bytes32 id) {\\n        id = calcWithdrawId(\\n            _token,\\n            _from,\\n            _to,\\n            _amountPerSec,\\n            _starts,\\n            _frequency\\n        );\\n        require(owners[id] == address(0), \\\"already exists\\\");\\n        owners[id] = msg.sender;\\n        emit WithdrawScheduled(\\n            msg.sender,\\n            _token,\\n            _from,\\n            _to,\\n            _amountPerSec,\\n            _starts,\\n            _frequency,\\n            id\\n        );\\n    }\\n\\n    function cancelWithdraw(\\n        address _token,\\n        address _from,\\n        address _to,\\n        uint216 _amountPerSec,\\n        uint40 _starts,\\n        uint40 _frequency\\n    ) external returns (bytes32 id) {\\n        id = calcWithdrawId(\\n            _token,\\n            _from,\\n            _to,\\n            _amountPerSec,\\n            _starts,\\n            _frequency\\n        );\\n        require(msg.sender == owners[id], \\\"not owner\\\");\\n        owners[id] = address(0);\\n        emit WithdrawCancelled(\\n            msg.sender,\\n            _token,\\n            _from,\\n            _to,\\n            _amountPerSec,\\n            _starts,\\n            _frequency,\\n            id\\n        );\\n    }\\n\\n    function setRedirect(address _to) external {\\n        redirects[msg.sender] = _to;\\n    }\\n\\n    function cancelRedirect() external {\\n        redirects[msg.sender] = address(0);\\n    }\\n\\n    function executeWithdraw(\\n        address _owner,\\n        address _token,\\n        address _from,\\n        address _to,\\n        uint216 _amountPerSec,\\n        uint40 _starts,\\n        uint40 _frequency,\\n        bytes32 _id,\\n        bool _execute,\\n        bool _emitEvent\\n    ) external {\\n        require(msg.sender == bot, \\\"not bot\\\");\\n        if (_execute) {\\n            (address llamapay, bool isDeployed) = LlamaPayFactory(factory)\\n                .getLlamaPayContractByToken(_token);\\n            require(isDeployed, \\\"invalid llamapay contract\\\");\\n            if (redirects[_to] != address(0)) {\\n                (uint256 withdrawableAmount, , ) = LlamaPay(llamapay)\\n                    .withdrawable(_from, _to, _amountPerSec);\\n                LlamaPay(llamapay).withdraw(_from, _to, _amountPerSec);\\n                ERC20(_token).safeTransferFrom(\\n                    _to,\\n                    redirects[_to],\\n                    withdrawableAmount\\n                );\\n            } else {\\n                LlamaPay(llamapay).withdraw(_from, _to, _amountPerSec);\\n            }\\n        }\\n        if (_emitEvent) {\\n            emit WithdrawExecuted(\\n                _owner,\\n                _token,\\n                _from,\\n                _to,\\n                _amountPerSec,\\n                _starts,\\n                _frequency,\\n                _id\\n            );\\n        }\\n    }\\n\\n    function execute(bytes[] calldata _calls, address _from) external {\\n        require(msg.sender == bot, \\\"not bot\\\");\\n        uint256 i;\\n        uint256 len = _calls.length;\\n        uint256 startGas = gasleft();\\n        for (i = 0; i < len; ++i) {\\n            address(this).delegatecall(_calls[i]);\\n        }\\n        uint256 gasUsed = ((startGas - gasleft()) + 21000) + fee;\\n        uint256 totalSpent = gasUsed * tx.gasprice;\\n        balances[_from] -= totalSpent;\\n        (bool sent, ) = bot.call{value: totalSpent}(\\\"\\\");\\n        require(sent, \\\"failed to send ether to bot\\\");\\n    }\\n\\n    function batchExecute(bytes[] calldata _calls) external {\\n        require(msg.sender == bot, \\\"not bot\\\");\\n        uint256 i;\\n        uint256 len = _calls.length;\\n        for (i = 0; i < len; ++i) {\\n            address(this).delegatecall(_calls[i]);\\n        }\\n    }\\n\\n    function changeBot(address _newBot) external {\\n        require(msg.sender == llama, \\\"not llama\\\");\\n        bot = _newBot;\\n    }\\n\\n    function changeLlama(address _newLlama) external {\\n        require(msg.sender == llama, \\\"not llama\\\");\\n        newLlama = _newLlama;\\n    }\\n\\n    function confirmNewLlama() external {\\n        require(msg.sender == newLlama, \\\"not new llama\\\");\\n        llama = newLlama;\\n    }\\n\\n    function changeFee(uint256 _newFee) external {\\n        require(msg.sender == llama, \\\"not llama\\\");\\n        fee = _newFee;\\n    }\\n\\n    function calcWithdrawId(\\n        address _token,\\n        address _from,\\n        address _to,\\n        uint216 _amountPerSec,\\n        uint40 _starts,\\n        uint40 _frequency\\n    ) public pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    _token,\\n                    _from,\\n                    _to,\\n                    _amountPerSec,\\n                    _starts,\\n                    _frequency\\n                )\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), from) // Append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/solmate/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bot\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_llama\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint216\",\"name\":\"amountPerSec\",\"type\":\"uint216\"},{\"indexed\":false,\"internalType\":\"uint40\",\"name\":\"starts\",\"type\":\"uint40\"},{\"indexed\":false,\"internalType\":\"uint40\",\"name\":\"frequency\",\"type\":\"uint40\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"WithdrawCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint216\",\"name\":\"amountPerSec\",\"type\":\"uint216\"},{\"indexed\":false,\"internalType\":\"uint40\",\"name\":\"starts\",\"type\":\"uint40\"},{\"indexed\":false,\"internalType\":\"uint40\",\"name\":\"frequency\",\"type\":\"uint40\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"WithdrawExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint216\",\"name\":\"amountPerSec\",\"type\":\"uint216\"},{\"indexed\":false,\"internalType\":\"uint40\",\"name\":\"starts\",\"type\":\"uint40\"},{\"indexed\":false,\"internalType\":\"uint40\",\"name\":\"frequency\",\"type\":\"uint40\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"WithdrawScheduled\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"_calls\",\"type\":\"bytes[]\"}],\"name\":\"batchExecute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bot\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint216\",\"name\":\"_amountPerSec\",\"type\":\"uint216\"},{\"internalType\":\"uint40\",\"name\":\"_starts\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"_frequency\",\"type\":\"uint40\"}],\"name\":\"calcWithdrawId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelRedirect\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint216\",\"name\":\"_amountPerSec\",\"type\":\"uint216\"},{\"internalType\":\"uint40\",\"name\":\"_starts\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"_frequency\",\"type\":\"uint40\"}],\"name\":\"cancelWithdraw\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newBot\",\"type\":\"address\"}],\"name\":\"changeBot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newFee\",\"type\":\"uint256\"}],\"name\":\"changeFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newLlama\",\"type\":\"address\"}],\"name\":\"changeLlama\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"confirmNewLlama\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"_calls\",\"type\":\"bytes[]\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint216\",\"name\":\"_amountPerSec\",\"type\":\"uint216\"},{\"internalType\":\"uint40\",\"name\":\"_starts\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"_frequency\",\"type\":\"uint40\"},{\"internalType\":\"bytes32\",\"name\":\"_id\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"_execute\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_emitEvent\",\"type\":\"bool\"}],\"name\":\"executeWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"llama\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newLlama\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"owners\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"redirects\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint216\",\"name\":\"_amountPerSec\",\"type\":\"uint216\"},{\"internalType\":\"uint40\",\"name\":\"_starts\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"_frequency\",\"type\":\"uint40\"}],\"name\":\"scheduleWithdraw\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"setRedirect\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LlamaPayBot", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000de1c04855c2828431ba637675b6929a684f84c7f000000000000000000000000a43bc77e5362a81b3ab7accd8b7812a981bda478000000000000000000000000ad730d8e730c99e205a371436ce2e5acfc38d7f9", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}