{"SourceCode": "/**\r\n * @title OUR AWESOME TOKEN - The Shit you never saw before\r\n *\r\n *      TG: MY_AWESOME_TG\r\n *      TWITTER: MY_AWESOME_TWITTER\r\n *      WEB_SITE: MY_AWESOME_WEBSITE.COM\r\n */\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\n/// @dev removed context dependency.\r\n/// @author OpenZeppelin https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\r\nabstract contract Ownable {\r\n    address private _owner;\r\n\r\n    /**\r\n     * @dev The caller account is not authorized to perform an operation.\r\n     */\r\n    error OwnableUnauthorizedAccount(address account);\r\n\r\n    /**\r\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\r\n     */\r\n    error OwnableInvalidOwner(address owner);\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\r\n     */\r\n    constructor(address initialOwner) {\r\n        _transferOwnership(initialOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        if (owner() != msg.sender) {\r\n            revert OwnableUnauthorizedAccount(msg.sender);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        if (newOwner == address(0)) {\r\n            revert OwnableInvalidOwner(address(0));\r\n        }\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\n/// @dev edits: pass initial pause state in constructor and removed context dependency.\r\n/// @author OpenZeppelin https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/Pausable.sol\r\nabstract contract Pausable {\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    /**\r\n     * @dev The operation failed because the contract is paused.\r\n     */\r\n    error EnforcedPause();\r\n\r\n    /**\r\n     * @dev The operation failed because the contract is not paused.\r\n     */\r\n    error ExpectedPause();\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor(bool initialPaused) {\r\n        _paused = initialPaused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        _requireNotPaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        _requirePaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is paused.\r\n     */\r\n    function _requireNotPaused() internal view virtual {\r\n        if (paused()) {\r\n            revert EnforcedPause();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is not paused.\r\n     */\r\n    function _requirePaused() internal view virtual {\r\n        if (!paused()) {\r\n            revert ExpectedPause();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(msg.sender);\r\n    }\r\n}\r\n\r\ncontract SuperBscPoo is Ownable, Pausable {\r\n    /*//////////////////////////////////////////////////////////////\r\n                                 EVENTS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    // ERC20 events.\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n\r\n    // This token specific events.\r\n    event BlacklistStatusUpdated(address wallet, bool isBlacklisted);\r\n    event MarketPairUpdated(address pair, bool isMarketPair);\r\n    event ExcludedFromFeesUpdated(address wallet, bool isExcluded);\r\n    event TaxRecipientUpdated(address recipient);\r\n    event TaxesUpdated(uint256 buyTax, uint256 sellTax, uint256 transferTax);\r\n    event LimitsUpdated(uint256 maxBuy, uint256 maxSell, uint256 maxWallet);\r\n    event NumTokensToSwapUpdated(uint256 amount);\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            METADATA STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    string public name = \"SuperBscPoo\";\r\n\r\n    string public symbol = \"SBPT\";\r\n\r\n    uint8 public constant decimals = 18;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                              ERC20 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    // No mint or burn means we can just use a constant.\r\n    // Total supply must fit in uint128.\r\n    uint256 public constant totalSupply = 10_000_000 * 10**decimals;\r\n\r\n    mapping(address => uint256) public balanceOf;\r\n\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                              TOKEN-SPECIFIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    address public taxRecipient = address(0x451B47d3519Ca2dc24A0296B0DCbE0181433d08A);\r\n\r\n    // When accessing the buy tax, we also access buy limit, and the same applies for\r\n    // sell tax and limit. We pack them into a struct to save on gas.\r\n\r\n    // When accessing the buy tax, we also access buy limit, and the same applies for\r\n    // sell tax and limit. We pack them into a struct to save on gas.\r\n    struct taxAndLimit {\r\n        uint128 tax;\r\n        uint128 limit;\r\n    }\r\n\r\n    taxAndLimit public buyTaxAndLimit = taxAndLimit({\r\n        tax: 0,\r\n        limit: uint128(totalSupply)\r\n    });\r\n    taxAndLimit public sellTaxAndLimit = taxAndLimit({\r\n        tax: 0,\r\n        limit: uint128(totalSupply)\r\n    });\r\n\r\n    uint256 public transferTax = 0;\r\n    uint256 public maxWallet = totalSupply;\r\n\r\n    /// @dev totalSupply * maxTax cannot exceed uint256.\r\n    /// @dev maxTax cannot exceed taxDenominator.\r\n    uint256 private constant maxTax = 1_000; // 10%, same limit applies to all taxes.\r\n    uint256 private constant taxDenominator = 10_000; // 500/10000 = 5%\r\n\r\n    // Pack it into a struct instead of individual mappings to save on gas.\r\n    struct walletState {\r\n        bool isMarketPair;\r\n        bool isExcludedFromFees;\r\n    }\r\n    mapping (address => walletState) public _walletState;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            EIP-2612 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    uint256 internal immutable INITIAL_CHAIN_ID;\r\n\r\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\r\n\r\n    mapping(address => uint256) public nonces;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                               CONSTRUCTOR\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    // Start paused.\r\n    constructor() Ownable(msg.sender) Pausable(true) {\r\n        // Require supply to be less than the max uint128 value.\r\n        require(totalSupply < type(uint128).max, \"TOTAL_SUPPLY_EXCEEDS_MAX\");\r\n\r\n        // Setup for EIP-2612.\r\n        INITIAL_CHAIN_ID = block.chainid;\r\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\r\n\r\n        // Exclude owner and the contract from fees.\r\n        _walletState[msg.sender] = walletState({\r\n            isMarketPair: false,\r\n            isExcludedFromFees: true\r\n        });\r\n        emit ExcludedFromFeesUpdated(msg.sender, true);\r\n        _walletState[address(this)] = walletState({\r\n            isMarketPair: false,\r\n            isExcludedFromFees: true\r\n        });\r\n        emit ExcludedFromFeesUpdated(taxRecipient, true);\r\n        _walletState[address(this)] = walletState({\r\n            isMarketPair: false,\r\n            isExcludedFromFees: true\r\n        });\r\n\r\n        // Mint the initial supply.\r\n        unchecked {\r\n            balanceOf[msg.sender] += totalSupply;\r\n        }\r\n\r\n        emit Transfer(address(0), msg.sender, totalSupply);\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                               ERC20 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        address owner = msg.sender;\r\n        _approve(owner, spender, allowance[owner][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        address owner = msg.sender;\r\n        uint256 currentAllowance = allowance[owner][spender];\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        unchecked {\r\n            _approve(owner, spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n        allowance[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n\r\n    function transfer(address to, uint256 amount) public whenNotPaused returns (bool) {\r\n        _transfer(msg.sender, to, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public whenNotPaused returns (bool) {\r\n        uint256 allowed = allowance[from][msg.sender];\r\n        if (allowed != type(uint256).max) {\r\n            require(allowed >= amount, \"ERC20: insufficient allowance\");\r\n            // Won't overflow since allowed >= amount.\r\n            unchecked {\r\n                allowance[from][msg.sender] = allowed - amount;\r\n            }\r\n        }\r\n\r\n        _transfer(from, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function _buyTransfer(address to, uint256 amount) internal view returns (uint256) {\r\n        // balanceOf[to]+amount can't exceed uint256 as it can't exceed totalSupply.\r\n        // Taxes are capped at 10k and totalSupply is <= uint(128).max, overflow is impossible.\r\n        unchecked {\r\n            taxAndLimit memory buyConfig = buyTaxAndLimit;\r\n            uint256 fees = (amount * buyConfig.tax) / taxDenominator;\r\n\r\n            require(amount <= buyConfig.limit, \"transfer exceeds max buy\");\r\n            require(balanceOf[to] + amount <= maxWallet, \"balance exceeds max wallet\");\r\n\r\n            return fees;\r\n        }\r\n    }\r\n\r\n    function _sellTransfer(uint256 amount) internal view returns (uint256) {\r\n        unchecked {\r\n            taxAndLimit memory sellConfig = sellTaxAndLimit;\r\n            uint256 fees = (amount * sellConfig.tax) / taxDenominator;\r\n\r\n            require(amount <= sellConfig.limit, \"transfer exceeds max sell\");\r\n            // Do not check max wallet as market pairs are allowed to exceed it.\r\n\r\n            return fees;\r\n        }\r\n    }\r\n\r\n    function _baseTransfer(address to, uint256 amount) internal view returns (uint256) {\r\n        unchecked {\r\n            require(balanceOf[to] + amount <= maxWallet, \"balance exceeds max wallet\");\r\n\r\n            return (amount * transferTax) / taxDenominator;\r\n        }\r\n    }\r\n\r\n    function _calcFees(address to, uint256 amount, bool isBuy, bool isSell) internal view returns (uint256) {\r\n        if(isBuy) {\r\n            return _buyTransfer(to, amount);\r\n        }\r\n        if(isSell) {\r\n            return _sellTransfer(amount);\r\n        }\r\n        return _baseTransfer(to, amount);\r\n    }\r\n\r\n    function _transfer(address from, address to, uint256 amount) internal {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        uint256 balance = balanceOf[from];\r\n        require(balance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        unchecked {\r\n            balanceOf[from] = balance - amount;\r\n        }\r\n\r\n        walletState memory fromWalletState = _walletState[from];\r\n        walletState memory toWalletState = _walletState[to];\r\n\r\n        uint256 fees = 0;\r\n        bool takeFee = !fromWalletState.isExcludedFromFees && !toWalletState.isExcludedFromFees;\r\n\r\n        // Tax and enforce limits appriopriately.\r\n        if(takeFee) {\r\n            bool isBuy = fromWalletState.isMarketPair;\r\n            bool isSell = toWalletState.isMarketPair;\r\n\r\n            fees = _calcFees(to, amount, isBuy, isSell);\r\n        }\r\n\r\n        // Add the amount minus fees to the receiver.\r\n        uint256 amountMinusFees;\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        // fees is less than amount, so it can't overflow.\r\n        unchecked {\r\n            amountMinusFees = amount - fees;\r\n            balanceOf[to] += amountMinusFees;\r\n        }\r\n        emit Transfer(from, to, amountMinusFees);\r\n\r\n        // Add any fees collected to the contract.\r\n        if(fees > 0) {\r\n            emit Transfer(from, taxRecipient, fees);\r\n            unchecked {\r\n                balanceOf[taxRecipient] += fees;\r\n            }\r\n        }\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                             OWNER-ONLY\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function openTrading() external onlyOwner {\r\n        // Start with manual swap disabled\r\n        setTaxes(250, 250, 0);\r\n        _unpause();\r\n    }\r\n\r\n    function setMarketPair(address account, bool value) external onlyOwner {\r\n        require(account != address(this), \"cant change contract\");\r\n        _walletState[account].isMarketPair = value;\r\n        emit MarketPairUpdated(account, value);\r\n    }\r\n\r\n    function setExcludedFromFees(address account, bool value) external onlyOwner {\r\n        require(account != address(this), \"cant change contract\");\r\n        _walletState[account].isExcludedFromFees = value;\r\n        emit ExcludedFromFeesUpdated(account, value);\r\n    }\r\n\r\n    function setTaxRecipient(address account) external onlyOwner {\r\n        taxRecipient = account;\r\n        emit TaxRecipientUpdated(account);\r\n    }\r\n\r\n    function Unpause() external onlyOwner {\r\n        _unpause();\r\n    }\r\n\r\n    function Pause() external onlyOwner {\r\n        _pause();\r\n    }\r\n\r\n    function setTaxes(uint256 _buyTax, uint256 _sellTax, uint256 _transferTax) public onlyOwner {\r\n        // Cap any of the taxes to 10% max.\r\n        require(_buyTax <= maxTax, \"buy is too high\");\r\n        require(_sellTax <= maxTax, \"sell is too high\");\r\n        require(_transferTax <= maxTax, \"transfer is too high\");\r\n\r\n        buyTaxAndLimit.tax = uint128(_buyTax);\r\n        sellTaxAndLimit.tax = uint128(_sellTax);\r\n\r\n        emit TaxesUpdated(_buyTax, _sellTax, _transferTax);\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                             PAUSABLE OVERRIDES\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    // Override the requireNotPaused implementation to allow the owner\r\n    // to interact with the contract while it is paused. This allows the\r\n    // owner to airdrop tokens or add liquidity while in a paused state.\r\n    function _requireNotPaused() internal view override{\r\n        if(paused()) {\r\n            if(tx.origin != owner() && msg.sender != owner()) {\r\n                revert EnforcedPause();\r\n            }\r\n        }\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                             EIP-2612 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public {\r\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\r\n\r\n        // Unchecked because the only math done is incrementing\r\n        // the owner's nonce which cannot realistically overflow.\r\n        unchecked {\r\n            address recoveredAddress = ecrecover(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        \"\\x19\\x01\",\r\n                        DOMAIN_SEPARATOR(),\r\n                        keccak256(\r\n                            abi.encode(\r\n                                keccak256(\r\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\r\n                                ),\r\n                                owner,\r\n                                spender,\r\n                                value,\r\n                                nonces[owner]++,\r\n                                deadline\r\n                            )\r\n                        )\r\n                    )\r\n                ),\r\n                v,\r\n                r,\r\n                s\r\n            );\r\n\r\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\r\n\r\n            allowance[recoveredAddress][spender] = value;\r\n        }\r\n\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function DOMAIN_SEPARATOR() public view returns (bytes32) {\r\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\r\n    }\r\n\r\n    function computeDomainSeparator() internal view returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encode(\r\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n                    keccak256(bytes(name)),\r\n                    keccak256(\"1\"),\r\n                    block.chainid,\r\n                    address(this)\r\n                )\r\n            );\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"EnforcedPause\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExpectedPause\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isBlacklisted\",\"type\":\"bool\"}],\"name\":\"BlacklistStatusUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludedFromFeesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxBuy\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxSell\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxWallet\",\"type\":\"uint256\"}],\"name\":\"LimitsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isMarketPair\",\"type\":\"bool\"}],\"name\":\"MarketPairUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NumTokensToSwapUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"TaxRecipientUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyTax\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sellTax\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"transferTax\",\"type\":\"uint256\"}],\"name\":\"TaxesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_walletState\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isMarketPair\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isExcludedFromFees\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTaxAndLimit\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"tax\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"limit\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellTaxAndLimit\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"tax\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"limit\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setExcludedFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setMarketPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"setTaxRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_buyTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sellTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_transferTax\",\"type\":\"uint256\"}],\"name\":\"setTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "SuperBscPoo", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://28140b960c1d997db5f695fadb94b9ef3a3703b080b26689f1d7e7245a7e86b9"}