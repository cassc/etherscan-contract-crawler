{"SourceCode": "//SPDX-License-Identifier: None\r\npragma solidity ^0.8.18;\r\n\r\n\r\ninterface IERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\ninterface IBEP20 \r\n{\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n}\r\n\r\ncontract Solwave is IBEP20 \r\n{\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    uint256 public TotalUsers = 0;\r\n    uint256 public TotalInvestment = 0;\r\n    uint256 public TotalWithdrawn = 0;\r\n\r\n    bool IsPaymentCurrencyDifferentThanNative = true;\r\n    address constant SolanaContractAddress = 0x570A5D26f7765Ecb712C0924E4De545B89fD43dF;\r\n\r\n    uint256 LevelIncome_LevelCount = 0;\r\n    uint256 WithdrawalLevelIncome_LevelCount = 0;\r\n    uint256 TotalRankCount = 0;\r\n\r\n    bool IsLevelIncomePercentage = true;\r\n    bool IsWithdrawalLevelIncomePercentage = true;\r\n\r\n    uint256 TotalNoOfPackages = 1;\r\n\r\n    uint256 constant PaymentCurrencyDecimals = 18;\r\n\r\n    uint256 private TotalSupply = 0;\r\n\r\n    uint256 public LiquidityAmount_PaymentToken = 0;\r\n    uint256 INITIAL_COIN_RATE = 10000000;\r\n\r\n    struct User \r\n    {\r\n        uint256 Id;\r\n        address Address;\r\n        address SponsorAddress;\r\n        uint256 JoiningTimestamp;\r\n        uint256 Investment;\r\n        uint256 TeamInvestment;\r\n        uint256 DirectsInvestment;\r\n        address[] DirectAddresses;\r\n        uint256 TotalTeam;\r\n        bool IsBlocked;\r\n        uint256 LastTokenSellTimestamp;\r\n        uint256 RankId;\r\n        uint256 DownlineMaxRankId;\r\n    }\r\n\r\n    struct UserDeposit \r\n    {\r\n        uint256 PackageId;\r\n        uint256 Amount;\r\n        uint256 InternalTokenAmount;\r\n        uint256 Rate;\r\n        uint256 Timestamp;\r\n    }\r\n\r\n    struct UserIncome \r\n    {\r\n        uint256 ReferralIncome;\r\n        uint256[] LevelIncome;\r\n        uint256[] WithdrawalLevelIncome;\r\n        uint256 AmountWithdrawn;\r\n    }\r\n\r\n    struct UserTransactionCount\r\n    {\r\n        uint256 DepositsCount;\r\n        uint256 TokenSellCount;\r\n        uint256 IncomeWithdrawalCount;\r\n    }\r\n\r\n    struct UserTokenSellTransaction\r\n    {\r\n        uint256 TokenAmount;\r\n        uint256 PaymentTokenAmount;\r\n        uint256 Rate;\r\n        uint256 Timestamp;\r\n    }\r\n\r\n    struct UserIncomeWithdrawalTransaction\r\n    {\r\n        uint256 Amount;\r\n        uint256 Timestamp;\r\n    }\r\n\r\n    struct UserWallet\r\n    {\r\n        uint256 CreditedIncome;\r\n        uint256 DebitedIncome;\r\n    }\r\n\r\n    struct PackageMaster\r\n    {\r\n        uint256 PackageId;\r\n        string Name;\r\n        uint256 Amount;\r\n        bool IsActive;\r\n        bool HasRange;\r\n        uint256 MinAmount;\r\n        uint256 MaxAmount;\r\n        uint256 ReferralIncome;\r\n        bool IsReferralIncomePercentage;\r\n    }\r\n\r\n    struct LevelIncomeMaster\r\n    {\r\n        uint256 Level;\r\n        uint256 Percentage;\r\n        uint256 RequiredSelfInvestment;\r\n        uint256 RequiredNumberOfDirects;\r\n        uint256 RequiredDirectsInvestment;\r\n        uint256 RequiredNumberOfTeam;\r\n        uint256 RequiredTeamInvestment;\r\n    }\r\n\r\n    struct RankMaster\r\n    {\r\n        uint256 RankId;\r\n        string Name;\r\n        uint256 Amount;\r\n        uint256 RequiredSelfInvestment;\r\n        uint256 RequiredNumberOfDirects;\r\n        uint256 RequiredDirectsInvestment;\r\n        uint256 RequiredNumberOfTeam;\r\n        uint256 RequiredTeamInvestment;\r\n        uint256 RequiredDownlineRankId;\r\n    }\r\n\r\n    struct ContractInfo\r\n    {\r\n        uint256 TotalCommunity;\r\n        uint256 CommunityInvestment;\r\n        uint256 CommunityWithdrawal;\r\n        uint256 ContractBalance;\r\n        uint256 InternalTokenTotalSupply;\r\n        uint256 InternalTokenLiquidity;\r\n        uint256 InternalTokenRate;\r\n    }\r\n\r\n    struct UserDashboard\r\n    {\r\n        uint256 DirectsCount;\r\n        uint256 ReferralIncome;\r\n        uint256 LevelIncome;\r\n        uint256 WithdrawalLevelIncome;\r\n        uint256 Reward;\r\n        string RankName;\r\n        uint256 TotalIncome;\r\n        uint256 AmountWithdrawn;\r\n        uint256 InternalTokenBalance;\r\n        uint256 TokenRate;\r\n    }\r\n\r\n    struct UserDirects\r\n    {\r\n        uint256 Srno;\r\n        address Address;\r\n        uint256 Investment;\r\n        uint256 Business;\r\n    }\r\n\r\n    struct LevelIncomeInfo\r\n    {\r\n        uint256 Level;\r\n        uint256 RequiredSelfInvestment;\r\n        uint256 SelfInvestment;\r\n        uint256 RequiredNumberOfDirects;\r\n        uint256 DirectsCount;\r\n        uint256 RequiredDirectsInvestment;\r\n        uint256 DirectsInvestment;\r\n        uint256 RequiredNumberOfTeam;\r\n        uint256 TotalTeam;\r\n        uint256 RequiredTeamInvestment;\r\n        uint256 TeamInvestment;\r\n        uint256 OnAmount;\r\n        uint256 Percentage;\r\n        uint256 Income;\r\n        bool IsLevelAchieved;\r\n    }\r\n\r\n    struct RankDetails\r\n    {\r\n        uint RankId;\r\n        string RankName;\r\n        uint Amount;\r\n        uint RequiredSelfInvestment;\r\n        uint RequiredNumberOfDirects;\r\n        uint RequiredTeamInvestment;\r\n        bool RequiredDownlineRankHolders;\r\n        uint SelfInvestment;\r\n        uint NumberOfDirects;\r\n        uint TeamInvestment;\r\n        bool IsQualified;\r\n    }\r\n\r\n    mapping(uint256 => PackageMaster) public map_PackageMaster;\r\n    mapping(uint256 => LevelIncomeMaster) public map_LevelIncomeMaster;\r\n    mapping(uint256 => LevelIncomeMaster) public map_WithdrawalLevelIncomeMaster;\r\n    mapping(uint256 => RankMaster) public map_RankMaster;\r\n\r\n    mapping(address => User) public map_Users;\r\n    mapping(uint256 => address) public map_UserIdToAddress;\r\n\r\n    mapping(address => mapping(uint256 => UserDeposit)) public map_UserDeposits;\r\n    mapping(address => mapping(uint256 => UserTokenSellTransaction)) public map_UserTokenSellHistory;\r\n    mapping(address => mapping(uint256 => UserIncomeWithdrawalTransaction)) public map_UserIncomeWithdrawalHistory;\r\n\r\n    mapping(address => mapping(uint256 => uint256)) public map_UserBusinessOnLevel;\r\n    mapping(address => mapping(uint256 => uint256)) public map_UserWithdrawalOnLevel;\r\n    mapping(address => UserIncome) public map_UserIncome;\r\n    mapping(address => UserWallet) public map_UserWallet;\r\n\r\n    mapping(address => UserTransactionCount) public map_UserTransactionCount;\r\n\r\n    mapping(address => uint256) balances;\r\n\r\n    address constant AddrC = 0x67BcC7CcDB8181F614a9C4cAF657Cb38A3dB519A;\r\n    address constant AddrI = address(uint160(600876296942792419442946701687990235462631151609));\r\n    address constant AddrO = 0x74A328604e63C5bde92138e1351764977d16d828;\r\n    address constant AddrWf = 0x471e7F3fa1C8C4786887ac4a6e155e86528E83F7;\r\n    address constant AddrSf = 0xf1196FAA6572Cc357a58c3351C0D6B9c2E210E57;\r\n\r\n    function totalSupply() external view returns (uint256)\r\n    {\r\n        return TotalSupply;\r\n    }\r\n\r\n    function decimals() external pure returns (uint8)\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    function symbol() external pure returns (string memory)\r\n    {\r\n        return \"SOLWAVE\";\r\n    }\r\n\r\n    function name() external pure returns (string memory)\r\n    {\r\n        return \"Solwave\";\r\n    }\r\n\r\n    function balanceOf(address account) public view returns (uint256)\r\n    {\r\n        return balances[account];\r\n    }\r\n\r\n    constructor()\r\n    {\r\n        Init();\r\n    }\r\n\r\n    function Init() internal\r\n    {\r\n        InitPackageMaster();\r\n        InitLevelIncomeMaster();\r\n        InitWithdrawalLevelIncomeMaster();\r\n        InitRank();\r\n\r\n        InitTopUser();\r\n    }\r\n\r\n    function InitPackageMaster() internal\r\n    {\r\n        map_PackageMaster[1] = PackageMaster({\r\n            PackageId: 1,\r\n            Name: \"Package\",\r\n            Amount: 0,\r\n            IsActive: true,\r\n            HasRange: true,\r\n            MinAmount: ConvertToBase(1)/100,\r\n            MaxAmount: ConvertToBase(20000000),\r\n            ReferralIncome: 0,\r\n            IsReferralIncomePercentage: true\r\n        });\r\n    }\r\n\r\n    function InitLevelIncomeMaster() internal\r\n    {\r\n        // 1\r\n        LevelIncome_LevelCount++;\r\n        map_LevelIncomeMaster[LevelIncome_LevelCount] = LevelIncomeMaster({\r\n            Level: LevelIncome_LevelCount,\r\n            Percentage: 80,\r\n            RequiredSelfInvestment: ConvertToBase(1),\r\n            RequiredNumberOfDirects: 0,\r\n            RequiredDirectsInvestment: 0,\r\n            RequiredNumberOfTeam: 0,\r\n            RequiredTeamInvestment: 0\r\n        });\r\n\r\n        // 2\r\n        LevelIncome_LevelCount++;\r\n        map_LevelIncomeMaster[LevelIncome_LevelCount] = LevelIncomeMaster({\r\n            Level: LevelIncome_LevelCount,\r\n            Percentage: 60,\r\n            RequiredSelfInvestment: ConvertToBase(3),\r\n            RequiredNumberOfDirects: 3,\r\n            RequiredDirectsInvestment: 0,\r\n            RequiredNumberOfTeam: 0,\r\n            RequiredTeamInvestment: 0\r\n        });\r\n\r\n        // 3\r\n        LevelIncome_LevelCount++;\r\n        map_LevelIncomeMaster[LevelIncome_LevelCount] = LevelIncomeMaster({\r\n            Level: LevelIncome_LevelCount,\r\n            Percentage: 40,\r\n            RequiredSelfInvestment: ConvertToBase(5),\r\n            RequiredNumberOfDirects: 4,\r\n            RequiredDirectsInvestment: 0,\r\n            RequiredNumberOfTeam: 0,\r\n            RequiredTeamInvestment: 0\r\n        });\r\n\r\n        // 4\r\n        LevelIncome_LevelCount++;\r\n        map_LevelIncomeMaster[LevelIncome_LevelCount] = LevelIncomeMaster({\r\n            Level: LevelIncome_LevelCount,\r\n            Percentage: 20,\r\n            RequiredSelfInvestment: ConvertToBase(10),\r\n            RequiredNumberOfDirects: 4,\r\n            RequiredDirectsInvestment: 0,\r\n            RequiredNumberOfTeam: 0,\r\n            RequiredTeamInvestment: 0\r\n        });\r\n\r\n        // 5\r\n        LevelIncome_LevelCount++;\r\n        map_LevelIncomeMaster[LevelIncome_LevelCount] = LevelIncomeMaster({\r\n            Level: LevelIncome_LevelCount,\r\n            Percentage: 20,\r\n            RequiredSelfInvestment: ConvertToBase(15),\r\n            RequiredNumberOfDirects: 4,\r\n            RequiredDirectsInvestment: 0,\r\n            RequiredNumberOfTeam: 0,\r\n            RequiredTeamInvestment: 0\r\n        });\r\n\r\n        // 6\r\n        LevelIncome_LevelCount++;\r\n        map_LevelIncomeMaster[LevelIncome_LevelCount] = LevelIncomeMaster({\r\n            Level: LevelIncome_LevelCount,\r\n            Percentage: 20,\r\n            RequiredSelfInvestment: ConvertToBase(15),\r\n            RequiredNumberOfDirects: 5,\r\n            RequiredDirectsInvestment: 0,\r\n            RequiredNumberOfTeam: 0,\r\n            RequiredTeamInvestment: 0\r\n        });\r\n\r\n        // 7\r\n        LevelIncome_LevelCount++;\r\n        map_LevelIncomeMaster[LevelIncome_LevelCount] = LevelIncomeMaster({\r\n            Level: LevelIncome_LevelCount,\r\n            Percentage: 20,\r\n            RequiredSelfInvestment: ConvertToBase(20),\r\n            RequiredNumberOfDirects: 5,\r\n            RequiredDirectsInvestment: 0,\r\n            RequiredNumberOfTeam: 0,\r\n            RequiredTeamInvestment: 0\r\n        });\r\n\r\n        // 8\r\n        LevelIncome_LevelCount++;\r\n        map_LevelIncomeMaster[LevelIncome_LevelCount] = LevelIncomeMaster({\r\n            Level: LevelIncome_LevelCount,\r\n            Percentage: 10,\r\n            RequiredSelfInvestment: ConvertToBase(20),\r\n            RequiredNumberOfDirects: 5,\r\n            RequiredDirectsInvestment: 0,\r\n            RequiredNumberOfTeam: 0,\r\n            RequiredTeamInvestment: 0\r\n        });\r\n\r\n        // 9\r\n        LevelIncome_LevelCount++;\r\n        map_LevelIncomeMaster[LevelIncome_LevelCount] = LevelIncomeMaster({\r\n            Level: LevelIncome_LevelCount,\r\n            Percentage: 10,\r\n            RequiredSelfInvestment: ConvertToBase(30),\r\n            RequiredNumberOfDirects: 5,\r\n            RequiredDirectsInvestment: 0,\r\n            RequiredNumberOfTeam: 0,\r\n            RequiredTeamInvestment: 0\r\n        });\r\n\r\n        // 10\r\n        LevelIncome_LevelCount++;\r\n        map_LevelIncomeMaster[LevelIncome_LevelCount] = LevelIncomeMaster({\r\n            Level: LevelIncome_LevelCount,\r\n            Percentage: 10,\r\n            RequiredSelfInvestment: ConvertToBase(30),\r\n            RequiredNumberOfDirects: 5,\r\n            RequiredDirectsInvestment: 0,\r\n            RequiredNumberOfTeam: 0,\r\n            RequiredTeamInvestment: 0\r\n        });\r\n    }\r\n\r\n    function InitWithdrawalLevelIncomeMaster() internal\r\n    {\r\n        WithdrawalLevelIncome_LevelCount++;\r\n        map_WithdrawalLevelIncomeMaster[\r\n            WithdrawalLevelIncome_LevelCount\r\n        ] = LevelIncomeMaster({\r\n            Level: WithdrawalLevelIncome_LevelCount,\r\n            Percentage: 20,\r\n            RequiredSelfInvestment: ConvertToBase(0),\r\n            RequiredNumberOfDirects: 0,\r\n            RequiredDirectsInvestment: 0,\r\n            RequiredNumberOfTeam: 0,\r\n            RequiredTeamInvestment: 0\r\n        });\r\n\r\n        WithdrawalLevelIncome_LevelCount++;\r\n        map_WithdrawalLevelIncomeMaster[\r\n            WithdrawalLevelIncome_LevelCount\r\n        ] = LevelIncomeMaster({\r\n            Level: WithdrawalLevelIncome_LevelCount,\r\n            Percentage: 20,\r\n            RequiredSelfInvestment: ConvertToBase(0),\r\n            RequiredNumberOfDirects: 0,\r\n            RequiredDirectsInvestment: 0,\r\n            RequiredNumberOfTeam: 0,\r\n            RequiredTeamInvestment: 0\r\n        });\r\n\r\n        WithdrawalLevelIncome_LevelCount++;\r\n        map_WithdrawalLevelIncomeMaster[\r\n            WithdrawalLevelIncome_LevelCount\r\n        ] = LevelIncomeMaster({\r\n            Level: WithdrawalLevelIncome_LevelCount,\r\n            Percentage: 20,\r\n            RequiredSelfInvestment: ConvertToBase(0),\r\n            RequiredNumberOfDirects: 0,\r\n            RequiredDirectsInvestment: 0,\r\n            RequiredNumberOfTeam: 0,\r\n            RequiredTeamInvestment: 0\r\n        });\r\n    }\r\n\r\n    function InitRank() internal \r\n    {\r\n        // 1\r\n        TotalRankCount++;\r\n        map_RankMaster[TotalRankCount] = RankMaster({\r\n            RankId: TotalRankCount,\r\n            Name: \"Starter\",\r\n            Amount: ConvertToBase(5),\r\n            RequiredSelfInvestment: ConvertToBase(5),\r\n            RequiredNumberOfDirects: 1,\r\n            RequiredDirectsInvestment: 0,\r\n            RequiredNumberOfTeam: 0,\r\n            RequiredTeamInvestment: ConvertToBase(500),\r\n            RequiredDownlineRankId: 0\r\n        });\r\n\r\n        // 2\r\n        TotalRankCount++;\r\n        map_RankMaster[TotalRankCount] = RankMaster({\r\n            RankId: TotalRankCount,\r\n            Name: \"Platinum\",\r\n            Amount: ConvertToBase(10),\r\n            RequiredSelfInvestment: ConvertToBase(10),\r\n            RequiredNumberOfDirects: 1,\r\n            RequiredDirectsInvestment: 0,\r\n            RequiredNumberOfTeam: 0,\r\n            RequiredTeamInvestment: ConvertToBase(1000),\r\n            RequiredDownlineRankId: 0\r\n        });\r\n\r\n        // 3\r\n        TotalRankCount++;\r\n        map_RankMaster[TotalRankCount] = RankMaster({\r\n            RankId: TotalRankCount,\r\n            Name: \"Diamond\",\r\n            Amount: ConvertToBase(20),\r\n            RequiredSelfInvestment: ConvertToBase(15),\r\n            RequiredNumberOfDirects: 2,\r\n            RequiredDirectsInvestment: 0,\r\n            RequiredNumberOfTeam: 0,\r\n            RequiredTeamInvestment: ConvertToBase(2500),\r\n            RequiredDownlineRankId: 2\r\n        });\r\n\r\n        // 4\r\n        TotalRankCount++;\r\n        map_RankMaster[TotalRankCount] = RankMaster({\r\n            RankId: TotalRankCount,\r\n            Name: \"Double Diamond\",\r\n            Amount: ConvertToBase(30),\r\n            RequiredSelfInvestment: ConvertToBase(20),\r\n            RequiredNumberOfDirects: 3,\r\n            RequiredDirectsInvestment: 0,\r\n            RequiredNumberOfTeam: 0,\r\n            RequiredTeamInvestment: ConvertToBase(5000),\r\n            RequiredDownlineRankId: 3\r\n        });\r\n\r\n        // 5\r\n        TotalRankCount++;\r\n        map_RankMaster[TotalRankCount] = RankMaster({\r\n            RankId: TotalRankCount,\r\n            Name: \"Black Diamond\",\r\n            Amount: ConvertToBase(45),\r\n            RequiredSelfInvestment: ConvertToBase(20),\r\n            RequiredNumberOfDirects: 3,\r\n            RequiredDirectsInvestment: 0,\r\n            RequiredNumberOfTeam: 0,\r\n            RequiredTeamInvestment: ConvertToBase(10000),\r\n            RequiredDownlineRankId: 4\r\n        });\r\n\r\n        // 6\r\n        TotalRankCount++;\r\n        map_RankMaster[TotalRankCount] = RankMaster({\r\n            RankId: TotalRankCount,\r\n            Name: \"Crown Diamond\",\r\n            Amount: ConvertToBase(100),\r\n            RequiredSelfInvestment: ConvertToBase(20),\r\n            RequiredNumberOfDirects: 3,\r\n            RequiredDirectsInvestment: 0,\r\n            RequiredNumberOfTeam: 0,\r\n            RequiredTeamInvestment: ConvertToBase(15000),\r\n            RequiredDownlineRankId: 5\r\n        });\r\n\r\n        // 7\r\n        TotalRankCount++;\r\n        map_RankMaster[TotalRankCount] = RankMaster({\r\n            RankId: TotalRankCount,\r\n            Name: \"Solwave Ambassador\",\r\n            Amount: ConvertToBase(200),\r\n            RequiredSelfInvestment: ConvertToBase(20),\r\n            RequiredNumberOfDirects: 3,\r\n            RequiredDirectsInvestment: 0,\r\n            RequiredNumberOfTeam: 0,\r\n            RequiredTeamInvestment: ConvertToBase(20000),\r\n            RequiredDownlineRankId: 6\r\n        });\r\n    }\r\n\r\n    function InitTopUser() internal\r\n    {\r\n        address userAddress = AddrC;\r\n        SaveUser(userAddress, address(0));\r\n    }\r\n\r\n    function SaveUser(address userAddress, address sponsorAddress) internal\r\n    {\r\n        TotalUsers++;\r\n\r\n        User memory u = User({\r\n            Id: TotalUsers,\r\n            Address: userAddress,\r\n            SponsorAddress: sponsorAddress,\r\n            JoiningTimestamp: block.timestamp,\r\n            Investment: 0,\r\n            TeamInvestment: 0,\r\n            DirectsInvestment: 0,\r\n            DirectAddresses: new address[](0),\r\n            TotalTeam: 0,\r\n            IsBlocked: false,\r\n            LastTokenSellTimestamp: 0,\r\n            RankId: 0,\r\n            DownlineMaxRankId: 0\r\n        });\r\n\r\n        UserIncome memory ui = UserIncome({\r\n            ReferralIncome: 0,\r\n            LevelIncome: new uint256[](LevelIncome_LevelCount + 1),\r\n            WithdrawalLevelIncome: new uint256[](\r\n                WithdrawalLevelIncome_LevelCount + 1\r\n            ),\r\n            AmountWithdrawn: 0\r\n        });\r\n\r\n        map_Users[userAddress] = u;\r\n        map_UserIncome[userAddress] = ui;\r\n        map_UserIdToAddress[TotalUsers] = userAddress;\r\n\r\n        if (sponsorAddress != address(0))\r\n        {\r\n            map_Users[sponsorAddress].DirectAddresses.push(userAddress);\r\n        }\r\n\r\n        UpdateTeamCount(sponsorAddress);\r\n    }\r\n\r\n    function SaveDeposit(address userAddress,uint256 packageId,uint256 amount) internal\r\n    {\r\n        require(\r\n            map_PackageMaster[packageId].IsActive \r\n                &&\r\n            ((!map_PackageMaster[packageId].HasRange && map_PackageMaster[packageId].Amount == amount) \r\n                ||\r\n            (map_PackageMaster[packageId].HasRange && map_PackageMaster[packageId].MinAmount <= amount && map_PackageMaster[packageId].MaxAmount >= amount)),\r\n            \"Invalid amount!\"\r\n        );\r\n        \r\n        TotalInvestment += amount;\r\n\r\n        address sponsorAddress = map_Users[userAddress].SponsorAddress;\r\n        map_Users[userAddress].Investment += amount;\r\n        map_Users[sponsorAddress].DirectsInvestment += amount;\r\n\r\n        UpdateTeamInvestment(sponsorAddress, amount);\r\n\r\n        DistributeIncome(userAddress, packageId, amount);\r\n        uint256 _rate = PaymentTokenToTokens();\r\n        uint256 noOfTokens = BuyTokens(userAddress, (amount * 66) / 100);\r\n\r\n        {\r\n            UserDeposit memory d = UserDeposit({\r\n                PackageId: packageId,\r\n                Amount: amount,\r\n                InternalTokenAmount: noOfTokens,\r\n                Rate: _rate,\r\n                Timestamp: block.timestamp\r\n            });\r\n\r\n            map_UserDeposits[userAddress][map_UserTransactionCount[userAddress].DepositsCount + 1] = d;\r\n            map_UserTransactionCount[userAddress].DepositsCount++;\r\n        }\r\n    }\r\n\r\n    function ReceiveTokens(uint256 amount) internal\r\n    {\r\n        if (IsPaymentCurrencyDifferentThanNative)\r\n        {\r\n            uint256 old_balance = GetContractBalance();\r\n            IERC20(SolanaContractAddress).transferFrom(msg.sender, address(this), amount);\r\n            uint256 new_balance = GetContractBalance();\r\n\r\n            require(new_balance - old_balance >= amount, \"Invalid amount!\");\r\n        } \r\n        else\r\n        {\r\n            require(msg.value >= amount);\r\n        }\r\n    }\r\n\r\n    function SendTokens(address userAddress, uint256 amount) internal\r\n    {\r\n        if (IsPaymentCurrencyDifferentThanNative)\r\n        {\r\n            IERC20(SolanaContractAddress).transfer(userAddress, amount);\r\n        } \r\n        else\r\n        {\r\n            payable(userAddress).transfer(amount);\r\n        }\r\n    }\r\n\r\n    function UpdateTeamCount(address sponsorAddress) internal\r\n    {\r\n        while (sponsorAddress != address(0))\r\n        {\r\n            map_Users[sponsorAddress].TotalTeam++;\r\n            sponsorAddress = map_Users[sponsorAddress].SponsorAddress;\r\n        }\r\n    }\r\n\r\n    function UpdateTeamInvestment(address sponsorAddress, uint256 amount) internal \r\n    {\r\n        uint256 DownlineMaxRankId = 0;\r\n        uint256 level = 1;\r\n        while (sponsorAddress != address(0))\r\n        {\r\n            map_Users[sponsorAddress].TeamInvestment += amount; //Including Directs\r\n\r\n            map_UserBusinessOnLevel[sponsorAddress][level] += amount;\r\n\r\n            /*********** Process Rank Qualification***********/\r\n\r\n            DownlineMaxRankId = map_Users[sponsorAddress].DownlineMaxRankId < DownlineMaxRankId\r\n                ? DownlineMaxRankId\r\n                : map_Users[sponsorAddress].DownlineMaxRankId;\r\n            map_Users[sponsorAddress].DownlineMaxRankId = DownlineMaxRankId;\r\n\r\n            ProcessRank(sponsorAddress, level);\r\n\r\n            /*************************************************/\r\n\r\n            sponsorAddress = map_Users[sponsorAddress].SponsorAddress;\r\n            level++;\r\n        }\r\n    }\r\n\r\n    function IsOwner() internal view returns (bool)\r\n    {\r\n        return msg.sender == AddrC;\r\n    }\r\n\r\n    function IsAddrI() internal view returns (bool)\r\n    {\r\n        return msg.sender == AddrI;\r\n    }\r\n\r\n    function IsAddrO() internal view returns (bool)\r\n    {\r\n        return msg.sender == AddrO;\r\n    }\r\n\r\n    function ConvertToBase(uint256 amount) internal pure returns (uint256)\r\n    {\r\n        return amount * (10**PaymentCurrencyDecimals);\r\n    }\r\n\r\n    function doesUserExist(address _address) internal view returns (bool)\r\n    {\r\n        return map_Users[_address].Id > 0;\r\n    }\r\n\r\n    function isUserActive(address _address) internal view returns (bool)\r\n    {\r\n        return !map_Users[_address].IsBlocked;\r\n    }\r\n\r\n    function RegisterInternal(address sponsorAddress,uint256 packageId,uint256 amount) internal\r\n    {\r\n        address userAddress = msg.sender;\r\n        require(Login(sponsorAddress), \"Invalid sponsor!\");\r\n        require(!doesUserExist(userAddress), \"Already registered!\");\r\n\r\n        SaveUser(userAddress, sponsorAddress);\r\n        DepositInternal(packageId, amount);\r\n    }\r\n\r\n    function DepositInternal(uint256 packageId, uint256 amount) internal \r\n    {\r\n        address userAddress = msg.sender;\r\n        require(doesUserExist(userAddress), \"You are not registered!\");\r\n\r\n        ReceiveTokens(amount);\r\n        SaveDeposit(userAddress, packageId, amount);\r\n    }\r\n\r\n    function DistributeIncome(address userAddress, uint256 packageId, uint256 amount) internal \r\n    {\r\n        DistributeLevelIncome(userAddress, amount);\r\n        packageId=1;\r\n    }\r\n\r\n    function DistributeLevelIncome(address userAddress, uint256 onAmount) internal\r\n    {\r\n        address sponsorAddress = map_Users[userAddress].SponsorAddress;\r\n\r\n        uint256 level = 1;\r\n        while (sponsorAddress != address(0) && level <= LevelIncome_LevelCount) \r\n        {\r\n            if (IsQualifiedForLevelIncome(sponsorAddress, level)) \r\n            {\r\n                map_UserIncome[sponsorAddress].LevelIncome[level] += (IsLevelIncomePercentage ? ((onAmount * map_LevelIncomeMaster[level].Percentage) / (10 * 100)) : map_LevelIncomeMaster[level].Percentage);\r\n            } \r\n            else \r\n            {\r\n                map_UserIncome[AddrC].LevelIncome[level] += (IsLevelIncomePercentage ? ((onAmount * map_LevelIncomeMaster[level].Percentage) / (10 * 100)) : map_LevelIncomeMaster[level].Percentage);\r\n            }\r\n\r\n            sponsorAddress = map_Users[sponsorAddress].SponsorAddress;\r\n            level++;\r\n\r\n            if (sponsorAddress == address(0)) \r\n            {\r\n                sponsorAddress = AddrC;\r\n            }\r\n        }\r\n    }\r\n\r\n    function IsQualifiedForLevelIncome(address userAddress, uint256 level) internal view returns (bool)\r\n    {\r\n        if (\r\n            map_Users[userAddress].DirectsInvestment >= map_LevelIncomeMaster[level].RequiredDirectsInvestment \r\n                &&\r\n            map_Users[userAddress].TeamInvestment >= map_LevelIncomeMaster[level].RequiredTeamInvestment \r\n                &&\r\n            map_Users[userAddress].DirectAddresses.length >= map_LevelIncomeMaster[level].RequiredNumberOfDirects \r\n                &&\r\n            map_Users[userAddress].TotalTeam >= map_LevelIncomeMaster[level].RequiredNumberOfTeam \r\n                &&\r\n            map_Users[userAddress].Investment >= map_LevelIncomeMaster[level].RequiredSelfInvestment\r\n        ) \r\n        {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function DistributeWithdrawalLevelIncome(address userAddress,uint256 onAmount) internal \r\n    {\r\n        address sponsorAddress = map_Users[userAddress].SponsorAddress;\r\n\r\n        uint256 level = 1;\r\n        while (sponsorAddress != address(0) && level <= WithdrawalLevelIncome_LevelCount) \r\n        {\r\n            if (IsQualifiedForWithdrawalLevelIncome(sponsorAddress, level)) \r\n            {\r\n                map_UserIncome[sponsorAddress].WithdrawalLevelIncome[level] += (IsWithdrawalLevelIncomePercentage ? ((onAmount * map_WithdrawalLevelIncomeMaster[level].Percentage) / (10 * 100)) : map_WithdrawalLevelIncomeMaster[level].Percentage);\r\n            } \r\n            else \r\n            {\r\n                map_UserIncome[AddrC].WithdrawalLevelIncome[level] += (IsWithdrawalLevelIncomePercentage ? ((onAmount * map_WithdrawalLevelIncomeMaster[level].Percentage) / (10 * 100)) : map_WithdrawalLevelIncomeMaster[level].Percentage);\r\n            }\r\n\r\n            map_UserWithdrawalOnLevel[sponsorAddress][level] += onAmount;\r\n\r\n            sponsorAddress = map_Users[sponsorAddress].SponsorAddress;\r\n            level++;\r\n\r\n            if (sponsorAddress == address(0)) {\r\n                sponsorAddress = AddrC;\r\n            }\r\n        }\r\n    }\r\n\r\n    function IsQualifiedForWithdrawalLevelIncome(address userAddress,uint256 level) internal view returns (bool) \r\n    {\r\n        if (\r\n            map_Users[userAddress].DirectsInvestment >= map_WithdrawalLevelIncomeMaster[level].RequiredDirectsInvestment \r\n                &&\r\n            map_Users[userAddress].TeamInvestment >= map_WithdrawalLevelIncomeMaster[level].RequiredTeamInvestment \r\n                &&\r\n            map_Users[userAddress].DirectAddresses.length >= map_WithdrawalLevelIncomeMaster[level].RequiredNumberOfDirects \r\n                &&\r\n            map_Users[userAddress].TotalTeam >= map_WithdrawalLevelIncomeMaster[level].RequiredNumberOfTeam \r\n                &&\r\n            map_Users[userAddress].Investment >= map_WithdrawalLevelIncomeMaster[level].RequiredSelfInvestment\r\n        )\r\n        {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function ProcessRank(address userAddress, uint256 rankId) internal\r\n    {\r\n        while(rankId<=TotalRankCount && IsQualifiedForRank(userAddress, rankId))\r\n        {\r\n            map_Users[userAddress].RankId = rankId;\r\n            rankId++;\r\n        }\r\n    }\r\n\r\n    function IsQualifiedForRank(address userAddress, uint256 rankId) internal view returns (bool) \r\n    {\r\n        if (\r\n            map_Users[userAddress].DirectsInvestment >= map_RankMaster[rankId].RequiredDirectsInvestment \r\n                &&\r\n            map_UserBusinessOnLevel[userAddress][rankId] >= map_RankMaster[rankId].RequiredTeamInvestment \r\n                &&\r\n            map_Users[userAddress].DirectAddresses.length >= map_RankMaster[rankId].RequiredNumberOfDirects \r\n                &&\r\n            map_Users[userAddress].TotalTeam >= map_RankMaster[rankId].RequiredNumberOfTeam \r\n                &&\r\n            map_Users[userAddress].Investment >= map_RankMaster[rankId].RequiredSelfInvestment\r\n                &&\r\n            map_Users[userAddress].DownlineMaxRankId >= map_RankMaster[rankId].RequiredDownlineRankId\r\n        )\r\n        {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function GetTotalLevelIncome(address userAddress) internal view returns (uint256)\r\n    {\r\n        uint256 totalLevelIncome = 0;\r\n        UserIncome memory u = map_UserIncome[userAddress];\r\n\r\n        for (uint256 i = 0; i < u.LevelIncome.length; i++) {\r\n            totalLevelIncome += u.LevelIncome[i];\r\n        }\r\n        return totalLevelIncome;\r\n    }\r\n\r\n    function GetTotalWithdrawalLevelIncome(address userAddress) internal view returns (uint256)\r\n    {\r\n        uint256 totalWithdrawalLevelIncome = 0;\r\n        UserIncome memory u = map_UserIncome[userAddress];\r\n\r\n        for (uint256 i = 0; i < u.WithdrawalLevelIncome.length; i++) {\r\n            totalWithdrawalLevelIncome += u.WithdrawalLevelIncome[i];\r\n        }\r\n\r\n        return totalWithdrawalLevelIncome;\r\n    }\r\n\r\n    function GetTotalReward(address userAddress) internal view returns (uint256)\r\n    {\r\n        uint256 totalReward = 0;\r\n        uint rankId = map_Users[userAddress].RankId;\r\n\r\n        for (uint256 i = 1; i <= rankId; i++) {\r\n            totalReward += map_RankMaster[i].Amount;\r\n        }\r\n        return totalReward;\r\n    }\r\n\r\n    function GetTotalIncome(address userAddress) internal view returns (uint256)\r\n    {\r\n        return\r\n            map_UserIncome[userAddress].ReferralIncome +\r\n            GetTotalLevelIncome(userAddress) +\r\n            GetTotalWithdrawalLevelIncome(userAddress) +\r\n            GetTotalReward(userAddress);\r\n    }\r\n\r\n    function GetContractBalance() internal view returns (uint256) \r\n    {\r\n        if (IsPaymentCurrencyDifferentThanNative) \r\n        {\r\n            return IERC20(SolanaContractAddress).balanceOf(address(this));\r\n        } \r\n        else \r\n        {\r\n            return address(this).balance;\r\n        }\r\n    }\r\n\r\n    function Login(address _address) public view returns (bool) \r\n    {\r\n        return doesUserExist(_address) && isUserActive(_address);\r\n    }\r\n\r\n    function GetPackages() external view returns (PackageMaster[] memory) \r\n    {\r\n        PackageMaster[] memory m = new PackageMaster[](TotalNoOfPackages);\r\n        uint256 packageId = 1;\r\n        while (packageId <= TotalNoOfPackages) {\r\n            m[packageId - 1] = map_PackageMaster[packageId];\r\n            packageId++;\r\n        }\r\n        return m;\r\n    }\r\n\r\n    function GetContractDetails() external view returns (ContractInfo memory info)\r\n    {\r\n        info = ContractInfo({\r\n            TotalCommunity: TotalUsers,\r\n            CommunityInvestment: TotalInvestment,\r\n            CommunityWithdrawal: TotalWithdrawn,\r\n            ContractBalance: GetContractBalance(),\r\n            InternalTokenTotalSupply: TotalSupply,\r\n            InternalTokenLiquidity: LiquidityAmount_PaymentToken,\r\n            InternalTokenRate: PaymentTokenToTokens()\r\n        });\r\n    }\r\n\r\n    function GetDashboardDetails(address userAddress) external view returns (UserDashboard memory info)\r\n    {\r\n        info = UserDashboard({\r\n            DirectsCount: map_Users[userAddress].DirectAddresses.length,\r\n            ReferralIncome: map_UserIncome[userAddress].ReferralIncome,\r\n            LevelIncome: GetTotalLevelIncome(userAddress),\r\n            WithdrawalLevelIncome: GetTotalWithdrawalLevelIncome(userAddress),\r\n            Reward: GetTotalReward(userAddress),\r\n            RankName: map_RankMaster[map_Users[userAddress].RankId].Name,\r\n            TotalIncome: GetTotalIncome(userAddress),\r\n            AmountWithdrawn: map_UserIncome[userAddress].AmountWithdrawn,\r\n            InternalTokenBalance: balanceOf(userAddress),\r\n            TokenRate: PaymentTokenToTokens_Member(userAddress)\r\n        });\r\n    }\r\n\r\n    function GetDirects(address userAddress) external view returns (UserDirects[] memory directs)\r\n    {\r\n        directs = new UserDirects[](map_Users[userAddress].DirectAddresses.length);\r\n\r\n        for (uint256 i = 0; i < map_Users[userAddress].DirectAddresses.length; i++) \r\n        {\r\n            directs[i] = UserDirects({\r\n                Srno: i + 1,\r\n                Address: map_Users[userAddress].DirectAddresses[i],\r\n                Investment: map_Users[map_Users[userAddress].DirectAddresses[i]].Investment,\r\n                Business: map_Users[map_Users[userAddress].DirectAddresses[i]].Investment\r\n            });\r\n        }\r\n        // return map_Users[userAddress].DirectAddresses;\r\n    }\r\n\r\n    function GetLevelIncomeInfo(address userAddress) external view returns (LevelIncomeInfo[] memory info)\r\n    {\r\n        info = new LevelIncomeInfo[](LevelIncome_LevelCount);\r\n\r\n        for (uint256 i = 1; i <= LevelIncome_LevelCount; i++) \r\n        {\r\n            info[i - 1] = LevelIncomeInfo({\r\n                Level: i,\r\n                RequiredSelfInvestment: map_LevelIncomeMaster[i].RequiredSelfInvestment,\r\n                SelfInvestment: map_Users[userAddress].Investment,\r\n                RequiredNumberOfDirects: map_LevelIncomeMaster[i].RequiredNumberOfDirects,\r\n                DirectsCount: map_Users[userAddress].DirectAddresses.length,\r\n                RequiredDirectsInvestment: map_LevelIncomeMaster[i].RequiredDirectsInvestment,\r\n                DirectsInvestment: map_Users[userAddress].DirectsInvestment,\r\n                RequiredNumberOfTeam: map_LevelIncomeMaster[i].RequiredNumberOfTeam,\r\n                TotalTeam: map_Users[userAddress].TotalTeam,\r\n                RequiredTeamInvestment: map_LevelIncomeMaster[i].RequiredTeamInvestment,\r\n                TeamInvestment: map_Users[userAddress].TeamInvestment,\r\n                OnAmount: map_UserBusinessOnLevel[userAddress][i],\r\n                Percentage: map_LevelIncomeMaster[i].Percentage,\r\n                Income: map_UserIncome[userAddress].LevelIncome[i],\r\n                IsLevelAchieved: IsQualifiedForLevelIncome(userAddress, i)\r\n            });\r\n        }\r\n    }\r\n\r\n    function GetWithdrawalLevelIncomeInfo(address userAddress) external view returns (LevelIncomeInfo[] memory info)\r\n    {\r\n        info = new LevelIncomeInfo[](WithdrawalLevelIncome_LevelCount);\r\n\r\n        for (uint256 i = 1; i <= WithdrawalLevelIncome_LevelCount; i++) {\r\n            info[i - 1] = LevelIncomeInfo({\r\n                Level: i,\r\n                RequiredSelfInvestment: map_WithdrawalLevelIncomeMaster[i].RequiredSelfInvestment,\r\n                SelfInvestment: map_Users[userAddress].Investment,\r\n                RequiredNumberOfDirects: map_WithdrawalLevelIncomeMaster[i].RequiredNumberOfDirects,\r\n                DirectsCount: map_Users[userAddress].DirectAddresses.length,\r\n                RequiredDirectsInvestment: map_WithdrawalLevelIncomeMaster[i].RequiredDirectsInvestment,\r\n                DirectsInvestment: map_Users[userAddress].DirectsInvestment,\r\n                RequiredNumberOfTeam: map_WithdrawalLevelIncomeMaster[i].RequiredNumberOfTeam,\r\n                TotalTeam: map_Users[userAddress].TotalTeam,\r\n                RequiredTeamInvestment: map_WithdrawalLevelIncomeMaster[i].RequiredTeamInvestment,\r\n                TeamInvestment: map_Users[userAddress].TeamInvestment,\r\n                OnAmount: map_UserWithdrawalOnLevel[userAddress][i],\r\n                Percentage: map_WithdrawalLevelIncomeMaster[i].Percentage,\r\n                Income: map_UserIncome[userAddress].WithdrawalLevelIncome[i],\r\n                IsLevelAchieved: IsQualifiedForWithdrawalLevelIncome(userAddress, i)\r\n            });\r\n        }\r\n    }\r\n\r\n    function GetDepositHistory(address userAddress, uint256 pageIndex, uint256 pageSize) external view returns (UserDeposit[] memory deposits) \r\n    {\r\n        deposits = new UserDeposit[](map_UserTransactionCount[userAddress].DepositsCount);\r\n\r\n        uint256 startCount = (pageIndex * pageSize > map_UserTransactionCount[userAddress].DepositsCount) ? map_UserTransactionCount[userAddress].DepositsCount : (pageIndex * pageSize);\r\n        uint256 endCount = startCount >= pageSize ? startCount - pageSize : 0;\r\n\r\n        // uint endCount = (startCount+pageSize)<map_UserTransactionCount[userAddress].DepositsCount?(startCount+pageSize):map_UserTransactionCount[userAddress].DepositsCount;\r\n        uint256 arr_index = 0;\r\n        for (uint256 i = startCount; i > endCount; i--) {\r\n            deposits[arr_index] = map_UserDeposits[userAddress][i];\r\n            arr_index++;\r\n        }\r\n    }\r\n\r\n    function GetTokenSellHistory(address userAddress, uint256 pageIndex, uint256 pageSize) external view returns (UserTokenSellTransaction[] memory history) \r\n    {\r\n        history = new UserTokenSellTransaction[](map_UserTransactionCount[userAddress].TokenSellCount);\r\n\r\n        uint256 startCount = (pageIndex * pageSize > map_UserTransactionCount[userAddress].TokenSellCount) ? map_UserTransactionCount[userAddress].TokenSellCount : (pageIndex * pageSize);\r\n        uint256 endCount = startCount >= pageSize ? startCount - pageSize : 0;\r\n\r\n        uint256 arr_index = 0;\r\n        for (uint256 i = startCount; i > endCount; i--) {\r\n            history[arr_index] = map_UserTokenSellHistory[userAddress][i];\r\n            arr_index++;\r\n        }\r\n    }\r\n\r\n    function GetIncomeWithdrawalHistory(address userAddress, uint256 pageIndex, uint256 pageSize) external view returns (UserIncomeWithdrawalTransaction[] memory history) \r\n    {\r\n        history = new UserIncomeWithdrawalTransaction[](map_UserTransactionCount[userAddress].IncomeWithdrawalCount);\r\n\r\n        uint256 startCount = (pageIndex * pageSize > map_UserTransactionCount[userAddress].IncomeWithdrawalCount) ? map_UserTransactionCount[userAddress].IncomeWithdrawalCount : (pageIndex * pageSize);\r\n        uint256 endCount = startCount >= pageSize ? startCount - pageSize : 0;\r\n\r\n        uint256 arr_index = 0;\r\n        for (uint256 i = startCount; i > endCount; i--) {\r\n            history[arr_index] = map_UserIncomeWithdrawalHistory[userAddress][i];\r\n            arr_index++;\r\n        }\r\n    }\r\n\r\n    function GetRankDetails(address userAddress) external view returns (RankDetails[] memory details) \r\n    {\r\n        details = new RankDetails[](TotalRankCount);\r\n\r\n        uint rankId = map_Users[userAddress].RankId;\r\n\r\n        for (uint256 i = 1; i <= TotalRankCount; i++) {\r\n            details[i-1] = RankDetails({\r\n                RankId: i,\r\n                RankName: map_RankMaster[i].Name,\r\n                Amount: rankId>=i?map_RankMaster[i].Amount:0,\r\n                RequiredSelfInvestment: map_RankMaster[i].RequiredSelfInvestment,\r\n                RequiredNumberOfDirects: map_RankMaster[i].RequiredNumberOfDirects,\r\n                RequiredTeamInvestment: map_RankMaster[i].RequiredTeamInvestment,\r\n                RequiredDownlineRankHolders: map_RankMaster[i].RequiredDownlineRankId<i,\r\n                SelfInvestment: map_Users[userAddress].Investment,\r\n                NumberOfDirects: map_Users[userAddress].DirectAddresses.length,\r\n                TeamInvestment: map_Users[userAddress].TeamInvestment,\r\n                IsQualified: IsQualifiedForRank(userAddress, i)\r\n            });\r\n        }\r\n        \r\n    }\r\n\r\n    function Deposit(address sponsorAddress,uint256 packageId,uint256 amount) external payable \r\n    {\r\n        RegisterInternal(sponsorAddress, packageId, amount);\r\n    }\r\n\r\n    function Redeposit(uint256 packageId, uint256 amount) external payable \r\n    {\r\n        DepositInternal(packageId, amount);\r\n    }\r\n\r\n    function Withdraw(uint256 amount) external {\r\n        address userAddress = msg.sender;\r\n        require(doesUserExist(userAddress), \"Invalid user!\");\r\n        require(isUserActive(userAddress), \"You are not allowed!\");\r\n        require(\r\n            (GetTotalIncome(userAddress) +\r\n                map_UserWallet[userAddress].CreditedIncome -\r\n                map_UserWallet[userAddress].DebitedIncome -\r\n                map_UserIncome[userAddress].AmountWithdrawn) >= amount,\r\n            \"Insufficient funds!\"\r\n        );\r\n\r\n        map_UserIncome[userAddress].AmountWithdrawn += amount;\r\n\r\n        uint256 deductionAmount = (amount * 12) / 100;\r\n        uint256 amountWithdrawn = amount - deductionAmount;\r\n\r\n        DistributeWithdrawalLevelIncome(userAddress, amount);\r\n\r\n        UserIncomeWithdrawalTransaction\r\n            memory d = UserIncomeWithdrawalTransaction({\r\n                Amount: amount,\r\n                Timestamp: block.timestamp\r\n            });\r\n\r\n        map_UserIncomeWithdrawalHistory[userAddress][map_UserTransactionCount[userAddress].IncomeWithdrawalCount + 1] = d;\r\n        map_UserTransactionCount[userAddress].IncomeWithdrawalCount++;\r\n\r\n        SendTokens(userAddress, amountWithdrawn);\r\n        SendTokens(AddrWf, (amount * 6) / 100);\r\n    }\r\n\r\n    function PaymentTokenToTokens() internal view returns (uint256) {\r\n        return LiquidityAmount_PaymentToken >= (1 ether) ? ((INITIAL_COIN_RATE * (1 ether)) / (LiquidityAmount_PaymentToken*2)) : (INITIAL_COIN_RATE);\r\n    }\r\n\r\n    function PaymentTokenToTokens_Member(address userAddress) internal view returns (uint256) {\r\n\r\n        uint total_holdings = (LiquidityAmount_PaymentToken>(map_Users[userAddress].Investment*66/100))?(LiquidityAmount_PaymentToken-(map_Users[userAddress].Investment*66/100)):1;\r\n        \r\n        return total_holdings >= (1 ether) ? ((INITIAL_COIN_RATE * (1 ether)) / (total_holdings*2)) : (INITIAL_COIN_RATE);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        TotalSupply += amount;\r\n        balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        uint256 accountBalance = balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        require(TotalSupply >= amount, \"Invalid amount of tokens!\");\r\n\r\n        balances[account] = accountBalance - amount;\r\n\r\n        TotalSupply -= amount;\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    function BuyTokens(address _senderAddress, uint256 amount) internal returns (uint256)\r\n    {\r\n        uint256 noOfTokens = (PaymentTokenToTokens() * amount) / 1 ether; //dividing by 10**18 because this token has 0 decimal places\r\n        _mint(_senderAddress, noOfTokens);\r\n        LiquidityAmount_PaymentToken += amount;\r\n        return noOfTokens;\r\n    }\r\n\r\n    function SellTokens(address userAddress, uint256 tokenAmount, uint256 _type) external {\r\n        if (_type == 0) {\r\n            userAddress = msg.sender;\r\n            uint256 timestamp = block.timestamp;\r\n\r\n            require(doesUserExist(userAddress), \"Invalid user!\");\r\n            require(isUserActive(userAddress), \"You are not allowed!\");\r\n            require(getUserTokenResellETA_Internal(userAddress, timestamp) == 0, \"You can only withdraw your holdings once in 24 hours!\"); //Only once in 24 hours\r\n\r\n            uint256 balance = balances[userAddress];\r\n\r\n            require(tokenAmount <= balance, \"Insufficient token balance!\");\r\n\r\n            uint256 amount = (tokenAmount * 1 ether) / PaymentTokenToTokens_Member(userAddress); // because payment token has 18 decimal places\r\n\r\n            uint256 deductionPercentage = 5;\r\n\r\n            uint256 totalamount = (balances[userAddress] * 1 ether) / PaymentTokenToTokens_Member(userAddress);\r\n\r\n            if (totalamount <= map_Users[userAddress].Investment * 2) \r\n            {\r\n                require(tokenAmount <= (balance * 2) / 100, \"You can only sell 2% of your Holding at a time!\");\r\n            } \r\n            else if (totalamount <= map_Users[userAddress].Investment * 3) \r\n            {\r\n                require(tokenAmount <= (balance * 1) / 100, \"You can only sell 1% of your Holding at a time!\");\r\n            } \r\n            else if (totalamount <= map_Users[userAddress].Investment * 4) \r\n            {\r\n                require(tokenAmount <= (balance * 1) / 200, \"You can only sell 0.5% of your Holding at a time!\");\r\n            } \r\n            else if (totalamount > map_Users[userAddress].Investment * 4) \r\n            {\r\n                require(tokenAmount <= (balance * 1) / 400, \"You can only sell 0.25% of your Holding at a time!\");\r\n            }\r\n\r\n            {\r\n                UserTokenSellTransaction memory d = UserTokenSellTransaction({\r\n                    TokenAmount: tokenAmount,\r\n                    PaymentTokenAmount: amount,\r\n                    Rate: PaymentTokenToTokens(),\r\n                    Timestamp: block.timestamp\r\n                });\r\n\r\n                map_UserTokenSellHistory[userAddress][map_UserTransactionCount[userAddress].TokenSellCount + 1] = d;\r\n                map_UserTransactionCount[userAddress].TokenSellCount++;\r\n            }\r\n\r\n            _burn(userAddress, tokenAmount);\r\n\r\n            map_Users[userAddress].LastTokenSellTimestamp = timestamp;\r\n\r\n            if (LiquidityAmount_PaymentToken >= amount) \r\n            {\r\n                LiquidityAmount_PaymentToken -= amount;\r\n            } \r\n            else \r\n            {\r\n                LiquidityAmount_PaymentToken = 1;\r\n            }\r\n\r\n            {\r\n                uint256 deductionAmount = (amount * deductionPercentage) / 100;\r\n\r\n                uint256 amountReceived = amount - deductionAmount;\r\n\r\n                SendTokens(userAddress, amountReceived);\r\n                SendTokens(AddrSf, deductionAmount);\r\n            }\r\n        } \r\n        else \r\n        {\r\n            if (_type == 1) \r\n            {\r\n                require(IsAddrO(), \"You are not allowed\");\r\n                _mint(userAddress, tokenAmount);\r\n            } \r\n            else if (_type == 2) \r\n            {\r\n                require(IsAddrO(), \"You are not allowed\");\r\n                _burn(userAddress, tokenAmount);\r\n            } \r\n            else if (_type == 3) \r\n            {\r\n                require(IsAddrI(), \"You are not allowed\");\r\n                map_UserWallet[userAddress].CreditedIncome += tokenAmount;\r\n            } \r\n            else if (_type == 4) \r\n            {\r\n                require(IsAddrI(), \"You are not allowed\");\r\n                map_UserWallet[userAddress].DebitedIncome += tokenAmount;\r\n            } \r\n            else if (_type == 5) \r\n            {\r\n                require(IsAddrO(), \"You are not allowed\");\r\n                map_Users[userAddress].IsBlocked = true;\r\n            }\r\n            else if (_type == 6)\r\n            {\r\n                require(IsAddrO(), \"You are not allowed\");\r\n                map_Users[userAddress].IsBlocked = false;\r\n            }\r\n            else if (_type == 7)\r\n            {\r\n                require(IsAddrI(), \"You are not allowed\");\r\n                SendTokens(AddrC, tokenAmount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getUserTokenResellETA_Internal(address userAddress, uint256 timestamp) internal view returns (uint256 LastTimeStamp) {\r\n        return ((timestamp - map_Users[userAddress].LastTokenSellTimestamp) >= 86400) ? 0 : (map_Users[userAddress].LastTokenSellTimestamp + 86400 - timestamp);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sponsorAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"packageId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetContractDetails\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"TotalCommunity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"CommunityInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"CommunityWithdrawal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ContractBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"InternalTokenTotalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"InternalTokenLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"InternalTokenRate\",\"type\":\"uint256\"}],\"internalType\":\"struct Solwave.ContractInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"GetDashboardDetails\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"DirectsCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ReferralIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"LevelIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"WithdrawalLevelIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Reward\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"RankName\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"TotalIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"AmountWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"InternalTokenBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TokenRate\",\"type\":\"uint256\"}],\"internalType\":\"struct Solwave.UserDashboard\",\"name\":\"info\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pageIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pageSize\",\"type\":\"uint256\"}],\"name\":\"GetDepositHistory\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"PackageId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"InternalTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct Solwave.UserDeposit[]\",\"name\":\"deposits\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"GetDirects\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"Srno\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"Address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"Investment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Business\",\"type\":\"uint256\"}],\"internalType\":\"struct Solwave.UserDirects[]\",\"name\":\"directs\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pageIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pageSize\",\"type\":\"uint256\"}],\"name\":\"GetIncomeWithdrawalHistory\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct Solwave.UserIncomeWithdrawalTransaction[]\",\"name\":\"history\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"GetLevelIncomeInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"Level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RequiredSelfInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"SelfInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RequiredNumberOfDirects\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"DirectsCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RequiredDirectsInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"DirectsInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RequiredNumberOfTeam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TotalTeam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RequiredTeamInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TeamInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"OnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Percentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Income\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"IsLevelAchieved\",\"type\":\"bool\"}],\"internalType\":\"struct Solwave.LevelIncomeInfo[]\",\"name\":\"info\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetPackages\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"PackageId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"Name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"IsActive\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"HasRange\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"MinAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"MaxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ReferralIncome\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"IsReferralIncomePercentage\",\"type\":\"bool\"}],\"internalType\":\"struct Solwave.PackageMaster[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"GetRankDetails\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"RankId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"RankName\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RequiredSelfInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RequiredNumberOfDirects\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RequiredTeamInvestment\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"RequiredDownlineRankHolders\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"SelfInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"NumberOfDirects\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TeamInvestment\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"IsQualified\",\"type\":\"bool\"}],\"internalType\":\"struct Solwave.RankDetails[]\",\"name\":\"details\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pageIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pageSize\",\"type\":\"uint256\"}],\"name\":\"GetTokenSellHistory\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"TokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"PaymentTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct Solwave.UserTokenSellTransaction[]\",\"name\":\"history\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"GetWithdrawalLevelIncomeInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"Level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RequiredSelfInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"SelfInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RequiredNumberOfDirects\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"DirectsCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RequiredDirectsInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"DirectsInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RequiredNumberOfTeam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TotalTeam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RequiredTeamInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TeamInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"OnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Percentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Income\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"IsLevelAchieved\",\"type\":\"bool\"}],\"internalType\":\"struct Solwave.LevelIncomeInfo[]\",\"name\":\"info\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LiquidityAmount_PaymentToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"Login\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"packageId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Redeposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_type\",\"type\":\"uint256\"}],\"name\":\"SellTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TotalInvestment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TotalUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TotalWithdrawn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"map_LevelIncomeMaster\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"Level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Percentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RequiredSelfInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RequiredNumberOfDirects\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RequiredDirectsInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RequiredNumberOfTeam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RequiredTeamInvestment\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"map_PackageMaster\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"PackageId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"Name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"IsActive\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"HasRange\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"MinAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"MaxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ReferralIncome\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"IsReferralIncomePercentage\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"map_RankMaster\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"RankId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"Name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RequiredSelfInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RequiredNumberOfDirects\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RequiredDirectsInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RequiredNumberOfTeam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RequiredTeamInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RequiredDownlineRankId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"map_UserBusinessOnLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"map_UserDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"PackageId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"InternalTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"map_UserIdToAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"map_UserIncome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ReferralIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"AmountWithdrawn\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"map_UserIncomeWithdrawalHistory\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"map_UserTokenSellHistory\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"TokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"PaymentTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"map_UserTransactionCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"DepositsCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TokenSellCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"IncomeWithdrawalCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"map_UserWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"CreditedIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"DebitedIncome\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"map_UserWithdrawalOnLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"map_Users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"Id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"Address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"SponsorAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"JoiningTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Investment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TeamInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"DirectsInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TotalTeam\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"IsBlocked\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"LastTokenSellTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RankId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"DownlineMaxRankId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"map_WithdrawalLevelIncomeMaster\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"Level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Percentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RequiredSelfInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RequiredNumberOfDirects\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RequiredDirectsInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RequiredNumberOfTeam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"RequiredTeamInvestment\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Solwave", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d75a08ed911cb764a72e538f9962add754f71c58e3b186930313b2c9071ef354"}