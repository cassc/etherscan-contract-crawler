{"SourceCode": "/**\r\n *Submitted for verification at BscScan.com on 2022-06-29\r\n*/\r\n\r\n// File: contracts/Context.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: contracts/IERC20.sol\r\n\r\n\r\npragma solidity 0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/Ownable.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\r\n\r\npragma solidity 0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor(address init_owner) {\r\n\t_owner = init_owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() external virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) external virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: contracts/LPStake.sol\r\n\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(\r\n            address(this).balance >= amount,\r\n            \"Address: insufficient balance\"\r\n        );\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(\r\n            success,\r\n            \"Address: unable to send value, recipient may have reverted\"\r\n        );\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data)\r\n    internal\r\n    returns (bytes memory)\r\n    {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return\r\n        functionCallWithValue(\r\n            target,\r\n            data,\r\n            value,\r\n            \"Address: low-level call with value failed\"\r\n        );\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(\r\n            address(this).balance >= value,\r\n            \"Address: insufficient balance for call\"\r\n        );\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) =\r\n        target.call{value: value}(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data)\r\n    internal\r\n    view\r\n    returns (bytes memory)\r\n    {\r\n        return\r\n        functionStaticCall(\r\n            target,\r\n            data,\r\n            \"Address: low-level static call failed\"\r\n        );\r\n    }\r\n\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data)\r\n    internal\r\n    returns (bytes memory)\r\n    {\r\n        return\r\n        functionDelegateCall(\r\n            target,\r\n            data,\r\n            \"Address: low-level delegate call failed\"\r\n        );\r\n    }\r\n\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) private pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transfer.selector, to, value)\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\r\n        );\r\n    }\r\n\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(token.approve.selector, spender, value)\r\n        );\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance =\r\n        token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(\r\n                token.approve.selector,\r\n                spender,\r\n                newAllowance\r\n            )\r\n        );\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance =\r\n        token.allowance(address(this), spender).sub(\r\n            value,\r\n            \"SafeERC20: decreased allowance below zero\"\r\n        );\r\n        _callOptionalReturn(\r\n            token,\r\n            abi.encodeWithSelector(\r\n                token.approve.selector,\r\n                spender,\r\n                newAllowance\r\n            )\r\n        );\r\n    }\r\n\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        bytes memory returndata =\r\n        address(token).functionCall(\r\n            data,\r\n            \"SafeERC20: low-level call failed\"\r\n        );\r\n        if (returndata.length > 0) {\r\n            require(\r\n                abi.decode(returndata, (bool)),\r\n                \"SafeERC20: ERC20 operation did not succeed\"\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\ncontract Pausable is Context {\r\n\r\n    event Paused(address account);\r\n\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    constructor() {\r\n        _paused = false;\r\n    }\r\n\r\n\r\n    function paused() external view returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n\r\n    modifier whenNotPaused() {\r\n        require(!_paused, \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n\r\n    modifier whenPaused() {\r\n        require(_paused, \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\ncontract LPStake is Ownable, ReentrancyGuard, Pausable {\r\n\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    address public immutable lpAddress;\r\n    address public immutable stAddress;\r\n\r\n    uint256 constant SECONDS_PER_MONTH = 2592000;\r\n    uint256 constant REWARD_SHARE_MULTIPLIER = 1e12;\r\n\r\n    uint256 public monthShare;  // share of this month \r\n    uint256 public lastStakeTime;  // Last UNIX timestampthat Token distribution occurs.\r\n    uint256 public accRewardTokenPerShare;  // Accumulated Token per share, times 1e12. See below.\r\n\r\n    uint256 public lpLockedTotal; //lp amount locked\r\n    uint256 public stRewardTotal; //STONE reward total\r\n\r\n    struct User {\r\n\t    uint256 amount;\t// How many LP the user has provided.\r\n            uint256 rewardDebt; // Reward debt. See explanation below.\r\n            uint256 rewardTotal; // Reward total mined.\r\n            uint256 rewardPayout; // Reward claimed.\r\n\t    bool isUsed;          // flag\r\n        //\r\n        // We do some fancy math here. Basically, any point in time, the amount of tokens \r\n        // entitled to a user but is pending to be distributed is:\r\n        //\r\n        //   pending reward = (user.amount * pool.accRewardTokenPerShare) - user.rewardDebt\r\n        //\r\n        // Whenever a user deposits or withdraws LP to a pool. Here's what happens:\r\n        //   1. The pool's `accRewardTokenPerShare` (and `lastStakeTime`) gets updated.\r\n        //   2. User receives the pending reward sent to his/her address.\r\n        //   3. User's `amount` gets updated.\r\n        //   4. User's `rewardDebt` gets updated.\r\n\r\n    }\r\n    mapping (address => User) private users;\r\n\r\n    event LPStaked(address indexed account, uint256 amount);\r\n    event LPUnstaked(address indexed account, uint256 amount);\r\n    event RewardClaimed(address indexed account, uint256 amount);\r\n    event SystemPaused(address indexed owner);\r\n    event SystemUnpaused(address indexed owner);\r\n\r\n    constructor(\r\n        address _stAddress,\r\n        address _lpAddress,\r\n\t    address _init_owner\r\n    ) Ownable (_init_owner){\r\n        lpAddress = _lpAddress;\r\n\t    stAddress = _stAddress;\r\n\t    lpLockedTotal = 0;\r\n\t    stRewardTotal = 0;\r\n\t    accRewardTokenPerShare = 0;\r\n\t    lastStakeTime = block.timestamp;\r\n        monthShare = 900_000 * 1 ether;\r\n    }\r\n\r\n    //get acc reward from last reward block \r\n    function getAccReward() internal view returns (uint256)\r\n    {\r\n\t    uint256 accReward = (block.timestamp - lastStakeTime) * monthShare / SECONDS_PER_MONTH;\r\n\t    return accReward;\r\n    }\r\n\r\n    //stake LP\r\n    function stake(uint256 _lpAmt)\r\n    external\r\n    whenNotPaused\r\n    nonReentrant\r\n    returns (uint256)\r\n    {\r\n\t    require(_lpAmt>0, \"_lpAmt is 0\");\r\n        IERC20(lpAddress).safeTransferFrom(\r\n            address(msg.sender),\r\n            address(this),\r\n            _lpAmt\r\n        );\r\n\r\n\t    uint256 accReward = getAccReward();\r\n\t    if(lpLockedTotal > 0)\r\n\t\t    accRewardTokenPerShare = accRewardTokenPerShare.add(accReward.mul(REWARD_SHARE_MULTIPLIER).div(lpLockedTotal));\r\n        lastStakeTime = block.timestamp;\r\n        lpLockedTotal = lpLockedTotal.add(_lpAmt);\r\n\r\n\t    emit LPStaked(msg.sender, _lpAmt);\r\n\r\n\t    User storage user = users[msg.sender];\r\n\t    if(user.isUsed == true)\r\n\t    {\r\n\t\t    uint256 reward = user.amount.mul(accRewardTokenPerShare).div(REWARD_SHARE_MULTIPLIER).sub(user.rewardDebt);\r\n\t\t    user.rewardTotal = user.rewardTotal.add(reward);\r\n\t\t    user.amount = user.amount.add(_lpAmt);\r\n\t\t    user.rewardDebt = user.amount.mul(accRewardTokenPerShare).div(REWARD_SHARE_MULTIPLIER);\r\n\t    }else\r\n\t\t    addUser(msg.sender, _lpAmt);\r\n\t    return accReward;\r\n    }\r\n    //unstake LP\r\n    function unstake(uint256 _lpAmt)\r\n    external\r\n    whenNotPaused\r\n    nonReentrant\r\n    returns (uint256)\r\n    {\r\n\t    User storage user = users[msg.sender];\r\n\t    require(user.isUsed == true, \"account no exists.\");\r\n\t    require(user.amount >= _lpAmt, \"invalid lpAmt\");\r\n\t    require(_lpAmt > 0, \"_lpAmt is 0\");\r\n\r\n\t    uint256 accReward = getAccReward();\r\n\t    if(lpLockedTotal > 0)\r\n\t\t    accRewardTokenPerShare = accRewardTokenPerShare.add(accReward.mul(REWARD_SHARE_MULTIPLIER).div(lpLockedTotal));\r\n        lastStakeTime = block.timestamp;\r\n\r\n\t    uint256 reward = user.amount.mul(accRewardTokenPerShare).div(REWARD_SHARE_MULTIPLIER).sub(user.rewardDebt);\r\n\t    user.rewardTotal = user.rewardTotal.add(reward);\r\n\r\n        lpLockedTotal = lpLockedTotal.sub(_lpAmt);\r\n\t    user.amount = user.amount.sub(_lpAmt);\r\n\t    user.rewardDebt = user.amount.mul(accRewardTokenPerShare).div(REWARD_SHARE_MULTIPLIER);\r\n\t    IERC20(lpAddress).transfer(msg.sender, _lpAmt);\r\n\r\n\t    emit LPUnstaked(msg.sender, _lpAmt);\r\n\t    if(user.amount == 0 && user.rewardPayout == user.rewardTotal)\r\n\t\t    removeUser(msg.sender);\r\n        return accReward;\r\n    }\r\n\r\n    //claim STONE\r\n    function claimReward()\r\n    external\r\n    nonReentrant\r\n    returns (uint256)\r\n    {\r\n\t    User storage user = users[msg.sender];\r\n\t    require(user.isUsed == true, \"account no exists.\");\r\n\r\n\t    uint256 accReward = getAccReward();\r\n\t    if(lpLockedTotal > 0)\r\n\t\t    accRewardTokenPerShare = accRewardTokenPerShare.add(accReward.mul(REWARD_SHARE_MULTIPLIER).div(lpLockedTotal));\r\n        lastStakeTime = block.timestamp;\r\n\r\n\t    uint256 reward = user.amount.mul(accRewardTokenPerShare).div(REWARD_SHARE_MULTIPLIER).sub(user.rewardDebt);\r\n\t    user.rewardDebt = user.amount.mul(accRewardTokenPerShare).div(REWARD_SHARE_MULTIPLIER);\r\n\t    user.rewardTotal = user.rewardTotal.add(reward);\r\n\r\n\t    uint256 realReward = user.rewardTotal.sub(user.rewardPayout);\r\n        uint256 stAmt = IERC20(stAddress).balanceOf(address(this));\r\n        if (realReward> stAmt) {\r\n            realReward = stAmt;\r\n        }\r\n\t    stRewardTotal = stRewardTotal.add(realReward);\r\n\t    user.rewardPayout = user.rewardPayout.add(realReward);\r\n\r\n        IERC20(stAddress).transfer(msg.sender, realReward);\r\n\t    emit RewardClaimed(msg.sender, realReward);\r\n\t    if(user.amount == 0 && user.rewardPayout == user.rewardTotal)\r\n\t\t    removeUser(msg.sender);\r\n        return realReward;\r\n    }\r\n\r\n    function addUser(address _account, uint256 _lpAmt) internal {\r\n    \tUser memory user = users[_account];\r\n\t    require(user.isUsed == false, \"account already exists\");\r\n\t    require(_lpAmt > 0, \"_lpAmt is 0\");\r\n\t    uint256 rewardDebt = _lpAmt.mul(accRewardTokenPerShare).div(REWARD_SHARE_MULTIPLIER);\r\n\t    users[_account] = User(_lpAmt, rewardDebt, 0, 0, true);\r\n    }\r\n\r\n    function removeUser(address account) internal {\r\n    \tUser memory user = users[account];\r\n\t    require(user.isUsed == true, \"account no exists\");\r\n\t    delete users[account];\r\n    }\r\n\r\n    function pause() external onlyOwner {\r\n        _pause();\r\n\t    emit SystemPaused(msg.sender);\r\n    }\r\n\r\n    function unpause() external onlyOwner {\r\n        _unpause();\r\n\t    emit SystemUnpaused(msg.sender);\r\n    }\r\n\r\n    // set month share for every month\r\n    function _setMonthShare(uint256 _month_share) external onlyOwner {\r\n\t    uint256 accReward = getAccReward();\r\n\t    if(lpLockedTotal > 0)\r\n\t\t    accRewardTokenPerShare = accRewardTokenPerShare.add(accReward.mul(REWARD_SHARE_MULTIPLIER).div(lpLockedTotal));\r\n\t    lastStakeTime = block.timestamp;\r\n    \tmonthShare = _month_share;    \r\n    }\r\n\r\n    function _withdrawERC20Token(address token, address recipient) external onlyOwner {\r\n        require(recipient != address(0), \"invalid address\");\r\n        require(recipient != token, \"invalid address\");\r\n\t    uint256 balance = IERC20(token).balanceOf(address(this));\r\n        if(balance > 0)\r\n            IERC20(token).transfer(msg.sender, balance);\r\n    }\r\n\r\n    //call functions\r\n    function getTotalLockedLP() external view returns (uint256){\r\n    \treturn lpLockedTotal;\r\n    }\r\n\r\n    // Reward available\r\n    function getPendingReward(address account) external view returns (uint256){\r\n\t    User memory user = users[account];\r\n\t    require(user.isUsed == true, \"account no exists.\");\r\n\t    uint256 accReward = getAccReward();\r\n\t    if(lpLockedTotal == 0)\r\n\t\t    return user.rewardTotal.add(user.amount.mul(accRewardTokenPerShare).div(REWARD_SHARE_MULTIPLIER).sub(user.rewardDebt)).sub(user.rewardPayout);\r\n\r\n\t    uint256 accr = accRewardTokenPerShare.add(accReward.mul(REWARD_SHARE_MULTIPLIER).div(lpLockedTotal));\r\n\t    uint256 reward = user.amount.mul(accr).div(REWARD_SHARE_MULTIPLIER).sub(user.rewardDebt);\r\n    \treturn user.rewardTotal.add(reward).sub(user.rewardPayout);\r\n    }\r\n \r\n    // Reward mined\r\n    function getTotalReward(address account) external view returns (uint256){\r\n\t    User memory user = users[account];\r\n\t    require(user.isUsed == true, \"account no exists.\");\r\n\t    uint256 accReward = getAccReward();\r\n\t    if(lpLockedTotal == 0)\r\n\t\t    return user.rewardTotal.add(user.amount.mul(accRewardTokenPerShare).div(REWARD_SHARE_MULTIPLIER).sub(user.rewardDebt));\r\n\t    uint256 accr = accRewardTokenPerShare.add(accReward.mul(REWARD_SHARE_MULTIPLIER).div(lpLockedTotal));\r\n\t    uint256 reward = user.amount.mul(accr).div(REWARD_SHARE_MULTIPLIER).sub(user.rewardDebt);\r\n    \treturn user.rewardTotal.add(reward);\r\n    }\r\n \r\n    // UserInfo\r\n    function getUserInfo(address account) external view returns(uint256, uint256, uint256){\r\n\t    User memory user = users[account];\r\n\t    require(user.isUsed == true, \"account no exists.\");\r\n\t    return(user.amount, user.rewardTotal, user.rewardPayout);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_lpAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_init_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LPStaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LPUnstaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"SystemPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"SystemUnpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_month_share\",\"type\":\"uint256\"}],\"name\":\"_setMonthShare\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"_withdrawERC20Token\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accRewardTokenPerShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getPendingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalLockedLP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getTotalReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastStakeTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpLockedTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"monthShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stRewardTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lpAmt\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lpAmt\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LPStake", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000c9ef9c76b2df7b544d6c0a4ca0fe92c0ec66c3c50000000000000000000000007ba30c5d31af4e1d14cd2de2a7ebb1a14c00ef7c00000000000000000000000021100806f82db0b871db684f82e46013725cefa9", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a6fc84a4c54e0fd47222e640cc6a31cf8b03d99a54b48433737b00fd44d553e2"}