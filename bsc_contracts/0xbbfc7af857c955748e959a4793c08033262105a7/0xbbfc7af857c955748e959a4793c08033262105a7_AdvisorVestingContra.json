{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/cryptopolis/AdvisorVesting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Cryptopolis\\n\\npragma solidity ^0.8.13;\\n\\nimport \\\"./openzepplin/token/ERC20/IERC20.sol\\\";\\nimport \\\"./openzepplin/utils/math/SafeMath.sol\\\";\\nimport \\\"./libs/baseObjects.sol\\\";\\n\\ncontract AdvisorVestingContract {\\n\\n    using SafeMath for uint256;\\n\\n    event StartBlockSet(uint256 startBlock);\\n    event ScheduleAdded(uint schedule);\\n    event RecipientAdded(address recipient, uint amount);\\n    event TokensReleased(uint schedule, address holder, address token, uint256 amount);\\n\\n    event NewPollCreated(BaseObjects.Poll _vote);\\n    event PollEnded(uint256 startBlock);\\n    event Voted(uint256 _pollId, bool _inFavour, address _voter);\\n    event VoteCanceled(uint256 _pollId, uint256 _option, address _voter, uint256 _noOfVotes);\\n    event StakingPoolLiquidityInitiated(uint256 _amount);\\n\\n    constructor(address _erc20Contract) {\\n        owner = msg.sender;\\n        erc20Contract = _erc20Contract;\\n    }\\n\\n    /**\\n     * @dev\\n     * public address for the owner of the contract\\n     */\\n    address public owner;\\n\\n    /**\\n     * @dev\\n     * public address of the erc20 contract linked to this vesting contract\\n     */\\n    address public erc20Contract;\\n\\n    /**\\n     * @dev\\n     * The current vesting start block\\n     */\\n    uint256 public startBlock;\\n\\n    /**\\n     * @dev\\n     * balances assigned to a wallet for a schedule\\n     */\\n    mapping (address => BaseObjects.Vester)  vesters;\\n\\n    // The total number of tokens managed by the contract\\n    uint256 public totalManaged;\\n\\n    // total amount the contract has released.\\n    uint256 public totalReleased;\\n\\n    // The recipients we know\\n    address[] public recipientsManaged;\\n\\n    /**\\n     * @dev\\n     * The schedules we are managing\\n     */\\n    BaseObjects.Schedule[] schedules;\\n    \\n    /**\\n     * @dev\\n     * array which holds all polls of this contract\\n     */\\n    BaseObjects.Poll[] public polls;\\n\\n    /**\\n     * @dev\\n     * mapping which stores wether an given address already voted on a given poll\\n     */\\n    mapping(address => mapping(uint => bool)) public votedCheck;\\n\\n    /**\\n     * @dev\\n     * access modifier for the owner\\n     */\\n    modifier onlyOwner {\\n        require(msg.sender == owner, \\\"The sender of the message needs to be the contract owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev\\n     * adds a schedule with the given data\\n     * @param _id is the id of the vote\\n     * @param _numBlocks is the total number of blocks the vesting runs over\\n     * @param _minBlockWait is the blocks a wallet needs to wait between two claims of vested token\\n     */\\n    function addSchedule(string calldata _id, uint256 _numBlocks, uint256 _minBlockWait) public onlyOwner {\\n        BaseObjects.Schedule memory schedule;\\n\\n        schedule.id = _id;\\n        schedule.numBlocks = _numBlocks;\\n        schedule.minBlockWait = _minBlockWait;\\n        schedule.totalVestings = SafeMath.div(_numBlocks, _minBlockWait);\\n        schedules.push(schedule);\\n        emit ScheduleAdded(schedules.length - 1);\\n    }\\n\\n    /**\\n     * @dev\\n     * sets a new start block for the vesting period\\n     * @param _newStartBlock is the new startblock to set\\n     *\\n     * Called by the owner once before the vesting start, can only be changed later using a poll. \\n     * The constructor sets the start block to zero, and it can therefore be set ONCE to kick off the\\n     * vesting without a poll.\\n     */\\n    function setStartBlock(uint256 _newStartBlock) public onlyOwner {\\n        require(startBlock == 0, \\\"You can now only update the start block using a poll\\\");\\n        startBlock = _newStartBlock;\\n        emit StartBlockSet(startBlock);\\n    }\\n\\n     /**\\n      * @dev Returns the amount of schedules we have\\n      */\\n    function getNumSchedules() public view returns (uint256) {\\n        return schedules.length;\\n    }\\n    \\n     /**\\n      * @dev Returns a specific schedule\\n      */\\n    function getSchedule(uint index) public view returns (BaseObjects.Schedule memory) {\\n        return schedules[index];\\n    }\\n    \\n     /**\\n      * @dev The amount of token managed by this contract\\n      */\\n    function getVestingLockedTokens() public view returns (uint256) {\\n        return(IERC20(erc20Contract).balanceOf(address(this)));\\n    }\\n    \\n     /**\\n      * @dev Add a wallet to be managed by the contract\\n      * @param _recipientAddress is the awallet which will be able to vest token\\n      * @param _amount is the amount of token the _recipientAddress can vest in total IN WEI\\n      * @param _schedule is the schedule this wallet runs on\\n      */\\n    function addRecipientWallet(address _recipientAddress, uint256 _amount, uint _schedule) public onlyOwner {\\n        require(vesters[_recipientAddress].totalReward == 0, \\\"Can't add the same recipient more than once\\\");\\n        require(totalManaged + _amount <= IERC20(erc20Contract).balanceOf(address(this)), \\\"There are not enough tokens available\\\");\\n\\n        BaseObjects.Vester memory vester;\\n        vester.vesterAddress = _recipientAddress;\\n\\n        require(schedules[_schedule].numBlocks > 0, \\\"Can't add the same recipient more than once\\\");\\n        vester.schedule = _schedule;\\n\\n        vester.rewardPerVestingPeriod = SafeMath.div(_amount, schedules[_schedule].totalVestings);\\n        vester.totalReward = _amount;\\n\\n        totalManaged += _amount;\\n        vesters[_recipientAddress] = vester;\\n        recipientsManaged.push(_recipientAddress);\\n\\n        emit RecipientAdded(_recipientAddress, _amount);\\n    }\\n\\n     /**\\n      * @dev Returns the amount of vesters we have\\n      */\\n    function getNumRecipients() public view returns (uint) {\\n        return recipientsManaged.length;\\n    }\\n    \\n     /**\\n      * @dev Returns the amount of vesters we have\\n      */\\n    function getRecipientAddress(uint index) public view returns (address) {\\n        return recipientsManaged[index];\\n    }\\n    \\n     /**\\n      * @dev Returns a specific vester\\n      */\\n    function getRecipientInfo(address recipientAddress) public view returns (BaseObjects.Vester memory) {\\n        return vesters[recipientAddress];\\n    }\\n    \\n     /**\\n      * @dev Calculate the amount that can be vested right now\\n      * @param _recipientAddress is the wallet to calculate the vesting amount for\\n      */\\n    function calculateVestingAmount(address _recipientAddress) internal view returns(uint256) {\\n        require(block.number > startBlock, \\\"Not started vesting yet\\\");\\n        require(startBlock > 0, \\\"Not started vesting yet\\\");\\n        uint256 lastVested = startBlock;\\n        if (vesters[_recipientAddress].lastVestedBlock > lastVested) {\\n            lastVested = vesters[_recipientAddress].lastVestedBlock;\\n        }\\n\\n        uint256 blocksToVest = block.number - lastVested;\\n        uint256 vestingsAvailableNow = SafeMath.div(blocksToVest, schedules[vesters[_recipientAddress].schedule].minBlockWait);\\n\\n        if (vestingsAvailableNow == 0) {\\n            return 0;\\n        }\\n        \\n        uint256 vestingAmountAvailableNow = SafeMath.mul(vesters[_recipientAddress].rewardPerVestingPeriod, vestingsAvailableNow);\\n        if (SafeMath.add(vestingAmountAvailableNow, vesters[_recipientAddress].claimedVestingRewards) > vesters[_recipientAddress].totalReward) {\\n            vestingAmountAvailableNow = SafeMath.sub(vesters[_recipientAddress].totalReward, vesters[_recipientAddress].claimedVestingRewards);\\n        }\\n\\n        return vestingAmountAvailableNow;\\n    }\\n\\n     /**\\n      * @dev Preview the amount that can be vested right now\\n      */\\n    function getVestingAmount(address recipientAddress) public view returns (uint256) {\\n        return calculateVestingAmount(recipientAddress);\\n    }\\n\\n     /**\\n      * @dev Perform the vesting right now\\n      */\\n    function vestAvailable() public {\\n        uint256 vestingAmount = calculateVestingAmount(msg.sender);\\n        vesters[msg.sender].lastVestedBlock = block.number;\\n        vesters[msg.sender].claimedVestingRewards += vestingAmount;\\n        totalManaged -= vestingAmount;\\n        totalReleased += vestingAmount;\\n        IERC20(erc20Contract).transfer(msg.sender, vestingAmount);\\n\\n        emit TokensReleased(vesters[msg.sender].schedule, msg.sender, erc20Contract, vestingAmount);\\n    }\\n\\n     /**\\n      * @dev Change the owner of the contract\\n      */\\n    function setOwner(address newOwnerAddress) public onlyOwner {\\n        owner = newOwnerAddress;\\n    }\\n\\n    /**\\n     *\\n     * @dev allows admin to create a poll\\n     * @param _text is the poll text\\n     * @param _endBlock holds the block at which the admin can close the poll\\n     *\\n     */\\n    function createPoll(string calldata _text, uint256 _endBlock, uint256 _newVestingStartBlock) public onlyOwner {\\n        if(polls.length > 0) {\\n            require(!polls[polls.length - 1].open, \\\"There can only be one open vote at a time\\\");\\n        }\\n        require(_newVestingStartBlock > _endBlock, \\\"The new vesting start block can not be before the poll end\\\");\\n        BaseObjects.Poll memory newPoll = BaseObjects.Poll(_text, _endBlock, _newVestingStartBlock, 0, 0, true);\\n        polls.push(newPoll);\\n        emit NewPollCreated(newPoll);\\n    }\\n\\n    /**\\n     *\\n     * @dev allows the admin to close an open poll\\n     *\\n     */\\n    function closeOpenPoll() public onlyOwner {\\n        require(polls[polls.length - 1].endBlock < block.number, \\\"The end block of this vote has not been reached yet\\\");\\n        polls[polls.length - 1].open = false;\\n        uint256 threshold = SafeMath.div(totalManaged, 2);\\n        if (polls[polls.length - 1].inFavour > threshold) {\\n            startBlock = polls[polls.length - 1].newVestingStartBlock;\\n        }\\n        emit PollEnded(startBlock);\\n    }\\n\\n    /**\\n     *\\n     * @dev allows a vesters to vote on a postponment.\\n     * @param _inFavour If the voter agrees on the postponement\\n     *\\n     */\\n    function voteOnPoll(bool _inFavour) public {\\n        require(vesters[msg.sender].totalReward > 0, \\\"Only recipients are allowed to vote\\\");\\n        require(polls.length > 0, \\\"There is no open poll\\\");\\n        require(polls[polls.length - 1].open, \\\"There is no open poll\\\");\\n        require(!votedCheck[msg.sender][polls.length - 1], \\\"Address already voted\\\");\\n        require(block.number <= polls[polls.length - 1].endBlock, \\\"The ending block of this poll was reached already\\\");\\n        votedCheck[msg.sender][polls.length - 1] = true;\\n        if (_inFavour) {\\n            polls[polls.length - 1].inFavour += vesters[msg.sender].totalReward;\\n        } else {\\n            polls[polls.length - 1].against += vesters[msg.sender].totalReward;\\n        }\\n        emit Voted(polls.length - 1, _inFavour, msg.sender);\\n    }   \\n\\n    /**\\n     *\\n     * @dev public getter which returns all information for a single poll\\n     * @param _index is the index of the poll to query for details\\n     *\\n     */\\n    function getPollDetails(uint _index) public view returns (BaseObjects.Poll memory) {\\n        BaseObjects.Poll memory newPoll = polls[_index];\\n        return newPoll;\\n    }\\n\\n    /**\\n     *\\n     * @dev internal helper to get the amount of polls\\n     *\\n     */\\n    function pollCount() public view returns (uint256) {\\n        return polls.length;\\n    }\\n\\n    /**\\n     *\\n     * @dev internal helper to check if the last poll is still open\\n     *\\n     */\\n    function checkIfPollIsOpen() internal view returns (bool) {\\n        return polls[polls.length - 1].open;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/cryptopolis/openzepplin/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/cryptopolis/openzepplin/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/cryptopolis/libs/baseObjects.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Cryptopolis\\n\\npragma solidity ^0.8.13;\\n\\nlibrary BaseObjects {\\n\\n    struct Poll {\\n        string pollText;\\n        uint256 endBlock;\\n        uint256 newVestingStartBlock;\\n        uint256 inFavour;\\n        uint256 against;\\n        bool open;\\n    }\\n\\n    struct Schedule {\\n        string id;               // eg. \\\"foundation\\\", \\\"marketing\\\" etc.\\n        uint256 numBlocks;       // number of blocks to vest over\\n        uint256 minBlockWait;    // number of blocks to wait after withdrawing\\n        uint256 totalVestings;   // The total number of vestings we expect\\n    }\\n\\n    struct Vester {\\n        address vesterAddress;          //address of the vester\\n        uint    schedule;               //schedule of the wallet\\n        uint256 lastVestedBlock;        // The block we last vested at\\n        uint256 rewardPerVestingPeriod; // the total amount of vesting rewards this vester can claim\\n        uint256 claimedVestingRewards;  // counts up from 0 until it reaches the rewardPerVestingPeriod\\n        uint256 totalReward;            // The total reward for this vester\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_erc20Contract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"pollText\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newVestingStartBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inFavour\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"against\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"open\",\"type\":\"bool\"}],\"indexed\":false,\"internalType\":\"struct BaseObjects.Poll\",\"name\":\"_vote\",\"type\":\"tuple\"}],\"name\":\"NewPollCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"}],\"name\":\"PollEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RecipientAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"schedule\",\"type\":\"uint256\"}],\"name\":\"ScheduleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"StakingPoolLiquidityInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startBlock\",\"type\":\"uint256\"}],\"name\":\"StartBlockSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"schedule\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_pollId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_option\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_noOfVotes\",\"type\":\"uint256\"}],\"name\":\"VoteCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_pollId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_inFavour\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_voter\",\"type\":\"address\"}],\"name\":\"Voted\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipientAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_schedule\",\"type\":\"uint256\"}],\"name\":\"addRecipientWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_id\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_numBlocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minBlockWait\",\"type\":\"uint256\"}],\"name\":\"addSchedule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"closeOpenPoll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_text\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_endBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newVestingStartBlock\",\"type\":\"uint256\"}],\"name\":\"createPoll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"erc20Contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumRecipients\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumSchedules\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getPollDetails\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"pollText\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newVestingStartBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inFavour\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"against\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"open\",\"type\":\"bool\"}],\"internalType\":\"struct BaseObjects.Poll\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRecipientAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipientAddress\",\"type\":\"address\"}],\"name\":\"getRecipientInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"vesterAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"schedule\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastVestedBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerVestingPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedVestingRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalReward\",\"type\":\"uint256\"}],\"internalType\":\"struct BaseObjects.Vester\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getSchedule\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"id\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"numBlocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBlockWait\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalVestings\",\"type\":\"uint256\"}],\"internalType\":\"struct BaseObjects.Schedule\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipientAddress\",\"type\":\"address\"}],\"name\":\"getVestingAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVestingLockedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pollCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"polls\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"pollText\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"endBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newVestingStartBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inFavour\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"against\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"open\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"recipientsManaged\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwnerAddress\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newStartBlock\",\"type\":\"uint256\"}],\"name\":\"setStartBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalManaged\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalReleased\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vestAvailable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_inFavour\",\"type\":\"bool\"}],\"name\":\"voteOnPoll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"votedCheck\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "AdvisorVestingContract", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "1", "ConstructorArguments": "000000000000000000000000ea395dfafed39924988b475f2ca7f4c72655203a", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}