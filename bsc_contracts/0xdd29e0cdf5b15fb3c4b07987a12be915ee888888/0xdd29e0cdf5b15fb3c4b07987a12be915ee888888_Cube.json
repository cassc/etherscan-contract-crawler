{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/Cube.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8;\\n\\nimport {ICube} from \\\"./ICube.sol\\\";\\nimport {Ownable} from \\\"openzeppelin-contracts/contracts/access/Ownable.sol\\\";\\nimport {ERC20} from \\\"openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\\\";\\n\\ncontract Cube is ICube, Ownable {\\n    bytes32 public immutable treeRoot;\\n\\n    uint256 constant _BASE_AMOUNT = 150000000000000000000;\\n    uint8 constant _MAX_CHILDREN_COUNT = 6;\\n    ERC20 _token;\\n    uint16 private _nodesCount = 0;\\n    uint8[6] private _depthToGift;\\n    uint8[5] private _depthToAdminReward;\\n    address[5] private _adminAddresses;\\n\\n    mapping(bytes32 => Node) private _nodes;\\n    mapping(bytes32 => uint256) private _balances;\\n    mapping(bytes32 => uint256) private _totalDeposited;\\n    mapping(bytes32 => uint256) private _currentDepositBalance;\\n    mapping(address => bytes32) private _nodeIdByWallet;\\n    mapping(bytes32 => Transfer[]) private _referralsUntransferedDeposits;\\n    mapping(bytes32 => mapping(uint8 => uint16)) private _referralsCountByDepth;\\n    mapping(bytes32 => uint256) private _accountLockTime;\\n    mapping(bytes32 => Transfer[]) private _referralsTransfers;\\n\\n    modifier checkNodeExistence(bytes32 nodeId) {\\n        require(isNode(nodeId), \\\"Error: node with current id does not exist.\\\");\\n        _;\\n    }\\n\\n    modifier checkNodeExistenceByWallet(address wallet) {\\n        require(\\n            getNodeIdByWallet(wallet) == 0,\\n            \\\"Error: node with current address already exist.\\\"\\n        );\\n        _;\\n    }\\n\\n    //constructor(address,address,uint8[6],address[5],uint8[5])\\n    constructor(\\n        address wallet,\\n        address _tokenAddress,\\n        uint8[6] memory depthToGift,\\n        address[5] memory adminAddresses,\\n        uint8[5] memory depthToAdminReward\\n    ) {\\n        _depthToGift = depthToGift;\\n        _adminAddresses = adminAddresses;\\n        _depthToAdminReward = depthToAdminReward;\\n        treeRoot = newNode(0, wallet);\\n        _token = ERC20(_tokenAddress);\\n    }\\n\\n    function _getTreeDepth(bytes32 _nodeId) private view returns (uint8 depth) {\\n        Node memory node = _nodes[_nodeId];\\n        depth = 0;\\n        while (node.parentId != 0) {\\n            node = _nodes[node.parentId];\\n            depth++;\\n        }\\n\\n        return depth;\\n    }\\n\\n    function _registerChild(\\n        bytes32 _parentId,\\n        bytes32 _newNodeId\\n    ) private returns (uint8 parentIndex) {\\n        _nodes[_parentId].children.push(_newNodeId);\\n        _accountLockTime[_parentId] = block.timestamp + 60 days;\\n        return uint8(getNodeChildrenCount(_parentId) - 1);\\n    }\\n\\n    function _updateReferralsCountByDepth(\\n        bytes32 _nodeId\\n    ) private returns (bool success) {\\n        Node memory node = _nodes[_nodeId];\\n        uint8 depth = 0;\\n        while (node.parentId != 0) {\\n            _referralsCountByDepth[node.parentId][depth]++;\\n            node = _nodes[node.parentId];\\n            depth++;\\n        }\\n        return true;\\n    }\\n\\n    function _newNode(\\n        bytes32 _parentId,\\n        bytes32 _newNodeId,\\n        address _wallet\\n    ) private returns (bool success) {\\n        Node memory node;\\n        node.isNode = true;\\n        node.id = _newNodeId;\\n        node.parentId = _parentId;\\n        if (_parentId > 0) {\\n            node.parentIndex = _registerChild(_parentId, _newNodeId);\\n        }\\n\\n        node.wallet = _wallet;\\n        node.canSell = false;\\n        _nodes[_newNodeId] = node;\\n        _balances[_newNodeId] = 0;\\n        _nodeIdByWallet[_wallet] = _newNodeId;\\n        _nodesCount++;\\n        return true;\\n    }\\n\\n    function _transferToAdmins(\\n        bytes32 _fromNode,\\n        uint256 _totalWithdraw\\n    ) private returns (bool success) {\\n        for (uint i = 0; i < _adminAddresses.length; ++i) {\\n            address adminAddress = _adminAddresses[i];\\n            uint amount = (_totalWithdraw * _depthToAdminReward[i]) / 1000;\\n            if (amount > 0) {\\n                _token.transfer(adminAddress, amount);\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        return _decreaseCurrentDeposit(_fromNode, _totalWithdraw);\\n    }\\n\\n    function _decreaseCurrentDeposit(\\n        bytes32 nodeId,\\n        uint256 transfered\\n    ) private returns (bool success) {\\n        require(\\n            _currentDepositBalance[nodeId] >= transfered,\\n            \\\"Error: cannot decrease zero deposit balance.\\\"\\n        );\\n        _currentDepositBalance[nodeId] -= transfered;\\n\\n        emit CurrentDepositDecreased(nodeId, transfered);\\n        return true;\\n    }\\n\\n    function _appendToArray(\\n        bytes32 nodeId,\\n        bytes32 referralId,\\n        address spender,\\n        uint256 amount,\\n        uint8 depth,\\n        uint256 timestamp\\n    ) public {\\n        for (\\n            uint i = 0;\\n            i < _referralsUntransferedDeposits[nodeId].length;\\n            i++\\n        ) {\\n            if (_referralsUntransferedDeposits[nodeId][i].amount == 0) {\\n                _referralsUntransferedDeposits[nodeId][i]\\n                    .referralId = referralId;\\n                _referralsUntransferedDeposits[nodeId][i].spender = spender;\\n\\n                _referralsUntransferedDeposits[nodeId][i].amount = amount;\\n\\n                _referralsUntransferedDeposits[nodeId][i].depth = depth;\\n                _referralsUntransferedDeposits[nodeId][i].timestamp = timestamp;\\n                return;\\n            }\\n        }\\n        Transfer memory referralsTransfer = Transfer(\\n            referralId,\\n            spender,\\n            amount,\\n            depth,\\n            timestamp\\n        );\\n        _referralsUntransferedDeposits[nodeId].push(referralsTransfer);\\n    }\\n\\n    function existPayment(\\n        bytes32 nodeId,\\n        bytes32 referralId,\\n        address spender,\\n        uint256 amount,\\n        uint8 depth,\\n        uint256 timestamp\\n    ) public returns (bool) {\\n        for (\\n            uint i = 0;\\n            i < _referralsUntransferedDeposits[nodeId].length;\\n            i++\\n        ) {\\n            if (\\n                _referralsUntransferedDeposits[nodeId][i].referralId ==\\n                referralId &&\\n                _referralsUntransferedDeposits[nodeId][i].spender == spender &&\\n                _referralsUntransferedDeposits[nodeId][i].amount == amount &&\\n                _referralsUntransferedDeposits[nodeId][i].depth == depth &&\\n                _referralsUntransferedDeposits[nodeId][i].timestamp == timestamp\\n            ) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    function _transferNodeReferralsMoney(\\n        bytes32 nodeId\\n    ) private returns (bool) {\\n        Node memory node = _nodes[nodeId];\\n        bytes32 parentId = _nodes[nodeId].parentId;\\n        uint8 depth = 1;\\n        uint totalAmount = 0;\\n        uint amount;\\n\\n        while (parentId != 0) {\\n            if (depth < 7) {\\n                amount = (_BASE_AMOUNT * _depthToGift[depth - 1]) / 100;\\n                if (amount > 0) {\\n                    if (\\n                        parentId == treeRoot ||\\n                        (getNodeActiveChildrenCount(parentId) >= depth &&\\n                            isActive(parentId))\\n                    ) {\\n                        Transfer memory referralsTransfer = Transfer(\\n                            node.id,\\n                            node.wallet,\\n                            amount,\\n                            depth,\\n                            block.timestamp\\n                        );\\n                        _token.transfer(_nodes[parentId].wallet, amount);\\n                        updateNodeBalance(parentId, amount);\\n                        _referralsTransfers[parentId].push(referralsTransfer);\\n                    } else {\\n                        if (\\n                            !existPayment(\\n                                parentId,\\n                                node.id,\\n                                node.wallet,\\n                                amount,\\n                                depth,\\n                                block.timestamp\\n                            )\\n                        ) {\\n                            _appendToArray(\\n                                parentId,\\n                                node.id,\\n                                node.wallet,\\n                                amount,\\n                                depth,\\n                                block.timestamp\\n                            );\\n                        }\\n                    }\\n                    _decreaseCurrentDeposit(node.id, amount);\\n                    totalAmount += amount;\\n                    parentId = _nodes[parentId].parentId;\\n                    depth++;\\n                } else {\\n                    break;\\n                }\\n            } else {\\n                break;\\n            }\\n        }\\n        if (\\n            _referralsUntransferedDeposits[_nodes[nodeId].parentId].length >\\n            0 &&\\n            isActive(_nodes[nodeId].parentId)\\n        ) {\\n            transferUntransferedDepositsByDepth(\\n                _nodes[nodeId].parentId,\\n                getNodeActiveChildrenCount(_nodes[nodeId].parentId)\\n            );\\n        }\\n        if (_BASE_AMOUNT - totalAmount > 0) {\\n            return _transferToAdmins(nodeId, _BASE_AMOUNT - totalAmount);\\n        }\\n        return true;\\n    }\\n\\n    function _deleteFromArray(\\n        bytes32 nodeId,\\n        bytes32 referralId,\\n        address spender,\\n        uint256 amount,\\n        uint8 depth,\\n        uint256 timestamp\\n    ) private {\\n        // uint index;\\n        for (\\n            uint i = 0;\\n            i < _referralsUntransferedDeposits[nodeId].length;\\n            i++\\n        ) {\\n            if (\\n                _referralsUntransferedDeposits[nodeId][i].referralId ==\\n                referralId &&\\n                _referralsUntransferedDeposits[nodeId][i].spender == spender &&\\n                _referralsUntransferedDeposits[nodeId][i].amount == amount &&\\n                _referralsUntransferedDeposits[nodeId][i].depth == depth &&\\n                _referralsUntransferedDeposits[nodeId][i].timestamp == timestamp\\n            ) {\\n                delete _referralsUntransferedDeposits[nodeId][i];\\n                break;\\n            }\\n        }\\n    }\\n\\n    function newNode(\\n        bytes32 parentId,\\n        address wallet\\n    )\\n        public\\n        virtual\\n        override\\n        onlyOwner\\n        checkNodeExistenceByWallet(wallet)\\n        returns (bytes32)\\n    {\\n        if (!isNode(parentId) && parentId > 0) revert();\\n        require(\\n            getNodeChildrenCount(parentId) < _MAX_CHILDREN_COUNT,\\n            \\\"Error: this user already has max count of children.\\\"\\n        );\\n        bytes32 newNodeId = keccak256(\\n            abi.encode(parentId, wallet, block.number)\\n        );\\n        _newNode(parentId, newNodeId, wallet);\\n        _updateReferralsCountByDepth(newNodeId);\\n        _accountLockTime[newNodeId] = block.timestamp + 3 days;\\n\\n        emit NewNodeCreated(newNodeId, wallet, parentId);\\n        return newNodeId;\\n    }\\n\\n    function updateNodeWallet(\\n        bytes32 nodeId,\\n        address wallet\\n    )\\n        public\\n        virtual\\n        override\\n        onlyOwner\\n        checkNodeExistence(nodeId)\\n        checkNodeExistenceByWallet(wallet)\\n        returns (bool)\\n    {\\n        require(\\n            _nodes[nodeId].canSell == true ||\\n                block.timestamp > _accountLockTime[nodeId],\\n            \\\"User not agree to sell account or not time yet\\\"\\n        );\\n\\n        Node storage node = _nodes[nodeId];\\n        {\\n            _nodeIdByWallet[node.wallet] = 0;\\n            node.wallet = wallet;\\n            _nodeIdByWallet[wallet] = nodeId;\\n        }\\n\\n        emit NodeWalletChanged(nodeId, wallet);\\n        return true;\\n    }\\n\\n    function getNode(address wallet) public view returns (Node memory) {\\n        bytes32 idx = getNodeIdByWallet(wallet);\\n        return _nodes[idx];\\n    }\\n\\n    function getNodeById(bytes32 nodeId) public view returns (Node memory) {\\n        return _nodes[nodeId];\\n    }\\n\\n    function updateNodeDeposit(\\n        bytes32 nodeId,\\n        uint256 deposit\\n    )\\n        public\\n        virtual\\n        override\\n        onlyOwner\\n        checkNodeExistence(nodeId)\\n        returns (bool)\\n    {\\n        require(\\n            _token.balanceOf(address(this)) >=\\n                (_BASE_AMOUNT + 5000000000000000000),\\n            \\\"Error: contract balance must be greater or equal than _BASE_AMOUNT\\\"\\n        );\\n        _token.transfer(msg.sender, 5000000000000000000);\\n        _totalDeposited[nodeId] += deposit;\\n        _currentDepositBalance[nodeId] += deposit;\\n        _accountLockTime[nodeId] = block.timestamp + 60 days;\\n\\n        emit NodeDeposited(nodeId, deposit);\\n        return _transferNodeReferralsMoney(nodeId);\\n    }\\n\\n    function updateNodeDepositSingleState(\\n        bytes32 nodeId,\\n        uint256 deposit\\n    ) public onlyOwner checkNodeExistence(nodeId) {\\n        _token.transfer(msg.sender, 5000000000000000000);\\n        _totalDeposited[nodeId] += deposit;\\n        _currentDepositBalance[nodeId] += deposit;\\n        _accountLockTime[nodeId] = block.timestamp + 60 days;\\n        emit NodeDeposited(nodeId, deposit);\\n    }\\n\\n    function updateNodeDepositSingleTransferReferals(\\n        bytes32 nodeId\\n    ) public onlyOwner checkNodeExistence(nodeId) returns (bool) {\\n        Node memory node = _nodes[nodeId];\\n        bytes32 parentId = _nodes[nodeId].parentId;\\n        uint8 depth = 1;\\n        uint totalAmount = 0;\\n        uint amount;\\n\\n        while (parentId != 0) {\\n            if (depth < 7) {\\n                amount = (_BASE_AMOUNT * _depthToGift[depth - 1]) / 100;\\n                if (amount > 0) {\\n                    if (\\n                        parentId == treeRoot ||\\n                        (getNodeActiveChildrenCount(parentId) >= depth &&\\n                            isActive(parentId))\\n                    ) {\\n                        Transfer memory referralsTransfer = Transfer(\\n                            node.id,\\n                            node.wallet,\\n                            amount,\\n                            depth,\\n                            block.timestamp\\n                        );\\n                        _token.transfer(_nodes[parentId].wallet, amount);\\n                        updateNodeBalance(parentId, amount);\\n                        _referralsTransfers[parentId].push(referralsTransfer);\\n                    } else {\\n                        if (\\n                            !existPayment(\\n                                parentId,\\n                                node.id,\\n                                node.wallet,\\n                                amount,\\n                                depth,\\n                                block.timestamp\\n                            )\\n                        ) {\\n                            _appendToArray(\\n                                parentId,\\n                                node.id,\\n                                node.wallet,\\n                                amount,\\n                                depth,\\n                                block.timestamp\\n                            );\\n                        }\\n                    }\\n                    _decreaseCurrentDeposit(node.id, amount);\\n                    totalAmount += amount;\\n                    parentId = _nodes[parentId].parentId;\\n                    depth++;\\n                } else {\\n                    break;\\n                }\\n            } else {\\n                break;\\n            }\\n        }\\n        if (_BASE_AMOUNT - totalAmount > 0) {\\n            return _transferToAdmins(nodeId, _BASE_AMOUNT - totalAmount);\\n        }\\n        return true;\\n    }\\n\\n    function updateNodeDepositSingleTransferUntransferedDepositsByDepth(\\n        bytes32 nodeId,\\n        bytes32 referralId,\\n        address spender,\\n        uint256 amount,\\n        uint8 depthTransfer,\\n        uint256 timestamp\\n    ) public virtual onlyOwner checkNodeExistence(nodeId) {\\n        Node memory node = _nodes[nodeId];\\n\\n        for (\\n            uint i = 0;\\n            i < _referralsUntransferedDeposits[node.id].length;\\n            i++\\n        ) {\\n            if (\\n                _referralsUntransferedDeposits[nodeId][i].referralId ==\\n                referralId &&\\n                _referralsUntransferedDeposits[nodeId][i].spender == spender &&\\n                _referralsUntransferedDeposits[nodeId][i].amount == amount &&\\n                _referralsUntransferedDeposits[nodeId][i].depth ==\\n                depthTransfer &&\\n                _referralsUntransferedDeposits[nodeId][i].timestamp == timestamp\\n            ) {\\n                _token.transfer(\\n                    node.wallet,\\n                    _referralsUntransferedDeposits[node.id][i].amount\\n                );\\n                updateNodeBalance(\\n                    node.id,\\n                    _referralsUntransferedDeposits[node.id][i].amount\\n                );\\n                _referralsTransfers[node.id].push(\\n                    _referralsUntransferedDeposits[node.id][i]\\n                );\\n                delete _referralsUntransferedDeposits[nodeId][i];\\n                break;\\n            }\\n        }\\n    }\\n\\n    function updateNodeBalance(\\n        bytes32 nodeId,\\n        uint256 transferedAmount\\n    )\\n        public\\n        virtual\\n        override\\n        onlyOwner\\n        checkNodeExistence(nodeId)\\n        returns (bool)\\n    {\\n        _balances[nodeId] += transferedAmount;\\n\\n        emit NodeBalanceChanged(nodeId, transferedAmount);\\n        return true;\\n    }\\n\\n    function transferUntransferedDeposits(\\n        bytes32 nodeId\\n    )\\n        public\\n        virtual\\n        override\\n        onlyOwner\\n        checkNodeExistence(nodeId)\\n        returns (bool)\\n    {\\n        Node memory node = _nodes[nodeId];\\n\\n        for (\\n            uint i = 0;\\n            i < _referralsUntransferedDeposits[node.id].length;\\n            i++\\n        ) {\\n            if (\\n                _referralsUntransferedDeposits[node.id][i].amount > 0 &&\\n                getNodeChildrenCount(node.id) == 6\\n            ) {\\n                _token.transfer(\\n                    node.wallet,\\n                    _referralsUntransferedDeposits[node.id][i].amount\\n                );\\n                updateNodeBalance(\\n                    node.id,\\n                    _referralsUntransferedDeposits[node.id][i].amount\\n                );\\n            }\\n        }\\n        delete _referralsUntransferedDeposits[node.id];\\n        return true;\\n    }\\n\\n    function transferUntransferedDepositsByDepth(\\n        bytes32 nodeId,\\n        uint8 depth\\n    ) public virtual onlyOwner checkNodeExistence(nodeId) returns (bool) {\\n        Node memory node = _nodes[nodeId];\\n        // uint k = 0;\\n        for (\\n            uint i = 0;\\n            i < _referralsUntransferedDeposits[node.id].length;\\n            i++\\n        ) {\\n            if (\\n                _referralsUntransferedDeposits[node.id][i].amount > 0 &&\\n                _referralsUntransferedDeposits[node.id][i].depth <= depth\\n            ) {\\n                _token.transfer(\\n                    node.wallet,\\n                    _referralsUntransferedDeposits[node.id][i].amount\\n                );\\n                updateNodeBalance(\\n                    node.id,\\n                    _referralsUntransferedDeposits[node.id][i].amount\\n                );\\n                _referralsTransfers[node.id].push(\\n                    _referralsUntransferedDeposits[node.id][i]\\n                );\\n\\n                _deleteFromArray(\\n                    node.id,\\n                    _referralsUntransferedDeposits[node.id][i].referralId,\\n                    _referralsUntransferedDeposits[node.id][i].spender,\\n                    _referralsUntransferedDeposits[node.id][i].amount,\\n                    _referralsUntransferedDeposits[node.id][i].depth,\\n                    _referralsUntransferedDeposits[node.id][i].timestamp\\n                );\\n                // k++;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    function transfer(\\n        address to,\\n        uint256 amount\\n    ) public virtual override onlyOwner returns (bool) {\\n        return _token.transfer(to, amount);\\n    }\\n\\n    function changeAdmin(\\n        address from,\\n        address to\\n    ) public virtual override onlyOwner returns (bool) {\\n        for (uint i = 0; i < _adminAddresses.length; i++) {\\n            if (_adminAddresses[i] == from) {\\n                _adminAddresses[i] = to;\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    function allowChangeWallet() public {\\n        bytes32 nodeId = getNodeIdByWallet(msg.sender);\\n        Node memory node = _nodes[nodeId];\\n        require(node.wallet == msg.sender, \\\"Please sign with node wallet\\\");\\n        _nodes[nodeId].canSell = true;\\n    }\\n\\n    function disallowChangeWallet() public {\\n        bytes32 nodeId = getNodeIdByWallet(msg.sender);\\n        Node memory node = _nodes[nodeId];\\n        require(node.wallet == msg.sender, \\\"Please sign with node wallet\\\");\\n        _nodes[nodeId].canSell = true;\\n    }\\n\\n    function isNode(\\n        bytes32 nodeId\\n    ) public view virtual override returns (bool) {\\n        return _nodes[nodeId].isNode;\\n    }\\n\\n    function isActive(\\n        bytes32 nodeId\\n    ) public view virtual override returns (bool) {\\n        return block.timestamp <= _accountLockTime[nodeId];\\n    }\\n\\n    function getNodeTimestamp(\\n        bytes32 nodeId\\n    ) public view virtual override returns (uint256) {\\n        return _accountLockTime[nodeId];\\n    }\\n\\n    function getNodesCount() public view virtual override returns (uint16) {\\n        return _nodesCount;\\n    }\\n\\n    function getReferralsTransfers(\\n        bytes32 nodeId\\n    ) public view virtual override returns (Transfer[] memory) {\\n        return _referralsTransfers[nodeId];\\n    }\\n\\n    function getReferralsTransfersByDepth(\\n        bytes32 nodeId,\\n        uint8 depth\\n    ) public view virtual override returns (Transfer[] memory) {\\n        Transfer[] memory transfers;\\n        uint item = 0;\\n\\n        for (uint i = 0; i < _referralsTransfers[nodeId].length; i++) {\\n            Transfer memory referralsTransfer = _referralsTransfers[nodeId][i];\\n            if (referralsTransfer.depth == depth) {\\n                transfers[item] = referralsTransfer;\\n                item++;\\n            }\\n        }\\n\\n        return transfers;\\n    }\\n\\n    function getReferralsUntransferedDeposits(\\n        bytes32 nodeId\\n    ) public view virtual override returns (Transfer[] memory) {\\n        return _referralsUntransferedDeposits[nodeId];\\n    }\\n\\n    function getReferralsUntransferedDepositsByDepth(\\n        bytes32 nodeId,\\n        uint8 depth\\n    ) public view virtual override returns (Transfer[] memory) {\\n        Transfer[] memory untransferedDeposits;\\n        uint item = 0;\\n\\n        for (\\n            uint i = 0;\\n            i < _referralsUntransferedDeposits[nodeId].length;\\n            i++\\n        ) {\\n            Transfer\\n                memory referralsUntransferedDeposit = _referralsUntransferedDeposits[\\n                    nodeId\\n                ][i];\\n            if (referralsUntransferedDeposit.depth == depth) {\\n                untransferedDeposits[item] = referralsUntransferedDeposit;\\n                item++;\\n            }\\n        }\\n\\n        return untransferedDeposits;\\n    }\\n\\n    function getReferralsCountByDepth(\\n        bytes32 nodeId,\\n        uint8 depth\\n    ) public view virtual override returns (uint16) {\\n        return _referralsCountByDepth[nodeId][depth - 1];\\n    }\\n\\n    function getNodeParentId(\\n        bytes32 nodeId\\n    ) public view virtual override returns (bytes32) {\\n        return _nodes[nodeId].parentId;\\n    }\\n\\n    function getNodeParentIndex(\\n        bytes32 nodeId\\n    ) public view virtual override returns (uint8) {\\n        return _nodes[nodeId].parentIndex;\\n    }\\n\\n    function getNodeChildren(\\n        bytes32 nodeId\\n    ) public view virtual override returns (bytes32[] memory children) {\\n        return _nodes[nodeId].children;\\n    }\\n\\n    function getNodeChildrenCount(\\n        bytes32 nodeId\\n    ) public view virtual override returns (uint8) {\\n        return uint8(_nodes[nodeId].children.length);\\n    }\\n\\n    function getNodeActiveChildrenCount(\\n        bytes32 nodeId\\n    ) public view virtual override returns (uint8) {\\n        uint8 count = 0;\\n        for (uint i = 0; i < _nodes[nodeId].children.length; i++) {\\n            if (_totalDeposited[_nodes[nodeId].children[i]] >= _BASE_AMOUNT) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    function getNodeWallet(\\n        bytes32 nodeId\\n    ) public view virtual override returns (address) {\\n        return _nodes[nodeId].wallet;\\n    }\\n\\n    function getNodeChildAtIndex(\\n        bytes32 nodeId,\\n        uint8 index\\n    ) public view virtual override returns (bytes32) {\\n        return _nodes[nodeId].children[index];\\n    }\\n\\n    function getNodeIdByWallet(\\n        address wallet\\n    ) public view virtual override returns (bytes32) {\\n        return _nodeIdByWallet[wallet];\\n    }\\n\\n    function getBalanceByNodeId(\\n        bytes32 nodeId\\n    ) public view virtual override returns (uint256) {\\n        return _balances[nodeId];\\n    }\\n\\n    function getChildrenBalances(\\n        bytes32 nodeId\\n    ) public view virtual override returns (uint256[6] memory balances) {\\n        Node memory parentNode = _nodes[nodeId];\\n        for (uint i = 0; i < parentNode.children.length; ++i) {\\n            balances[i] = _balances[parentNode.children[i]];\\n        }\\n        return balances;\\n    }\\n\\n    function getChildrenTotalBalances(\\n        bytes32 nodeId\\n    ) public view virtual override returns (uint256 total) {\\n        Node memory parentNode = _nodes[nodeId];\\n        for (uint i = 0; i < parentNode.children.length; ++i) {\\n            total += _balances[parentNode.children[i]];\\n        }\\n        return total;\\n    }\\n\\n    function getNodeCurrentDeposit(\\n        bytes32 nodeId\\n    ) public view virtual override returns (uint256) {\\n        return _currentDepositBalance[nodeId];\\n    }\\n\\n    function getNodeTotalDeposit(\\n        bytes32 nodeId\\n    ) public view virtual override returns (uint256) {\\n        return _totalDeposited[nodeId];\\n    }\\n\\n    function getChildrenCurrentDeposits(\\n        bytes32 nodeId\\n    )\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256[] memory childrenCurrentDeposits)\\n    {\\n        Node memory node = _nodes[nodeId];\\n        for (uint i = 0; i < node.children.length; ++i) {\\n            Node memory child = _nodes[node.children[i]];\\n            childrenCurrentDeposits[i] = _currentDepositBalance[child.id];\\n        }\\n        return childrenCurrentDeposits;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/ICube.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicensed\\n\\npragma solidity ^0.8.18;\\n\\ninterface ICube {\\n    struct Node {\\n        bool isNode;\\n        bytes32 id;\\n        bytes32 parentId;\\n        uint8 parentIndex;\\n        address wallet;\\n        bytes32[] children;\\n        bool canSell;\\n    }\\n\\n    struct Transfer {\\n        bytes32 referralId;\\n        address spender;\\n        uint256 amount;\\n        uint8 depth;\\n        uint256 timestamp;\\n    }\\n\\n    event NewNodeCreated(\\n        bytes32 indexed nodeId,\\n        address indexed wallet,\\n        bytes32 parentId\\n    );\\n    event NodePayed(bytes32 indexed nodeId, bool payed, uint256 balance);\\n    event NodeDeposited(bytes32 indexed nodeId, uint256 deposit);\\n    event CurrentDepositDecreased(bytes32 indexed nodeId, uint256 transfered);\\n    event NodeWalletChanged(bytes32 indexed nodeId, address wallet);\\n    event NodeBalanceChanged(bytes32 indexed nodeId, uint256 transfered);\\n    event ReferralReplaced(\\n        bytes32 indexed previousParentId,\\n        bytes32 indexed newParentId,\\n        uint8 parentIndex\\n    );\\n\\n    function newNode(\\n        bytes32 parentId,\\n        address wallet\\n    ) external returns (bytes32);\\n\\n    function updateNodeWallet(\\n        bytes32 nodeId,\\n        address wallet\\n    ) external returns (bool);\\n\\n    function updateNodeDeposit(\\n        bytes32 nodeId,\\n        uint256 deposit\\n    ) external returns (bool);\\n\\n    function updateNodeBalance(\\n        bytes32 nodeId,\\n        uint256 transfered\\n    ) external returns (bool);\\n\\n    function transferUntransferedDeposits(\\n        bytes32 nodeId\\n    ) external returns (bool);\\n\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    function changeAdmin(\\n        address from,\\n        address to\\n    ) external returns (bool success);\\n\\n    function isNode(bytes32 nodeId) external view returns (bool);\\n\\n    function isActive(bytes32 nodeId) external view returns (bool);\\n\\n    function getNodeTimestamp(bytes32 nodeId) external view returns (uint256);\\n\\n    function getNodesCount() external view returns (uint16);\\n\\n    function getReferralsTransfers(\\n        bytes32 nodeId\\n    ) external view returns (Transfer[] memory);\\n\\n    function getReferralsTransfersByDepth(\\n        bytes32 nodeId,\\n        uint8 depth\\n    ) external view returns (Transfer[] memory);\\n\\n    function getReferralsUntransferedDeposits(\\n        bytes32 nodeId\\n    ) external view returns (Transfer[] memory);\\n\\n    function getReferralsUntransferedDepositsByDepth(\\n        bytes32 nodeId,\\n        uint8 depth\\n    ) external view returns (Transfer[] memory);\\n\\n    function getReferralsCountByDepth(\\n        bytes32 nodeId,\\n        uint8 depth\\n    ) external view returns (uint16);\\n\\n    function getNodeParentId(bytes32 nodeId) external view returns (bytes32);\\n\\n    function getNodeParentIndex(bytes32 nodeId) external view returns (uint8);\\n\\n    function getNodeChildren(\\n        bytes32 nodeId\\n    ) external view returns (bytes32[] memory children);\\n\\n    function getNodeChildrenCount(bytes32 nodeId) external view returns (uint8);\\n    function getNodeActiveChildrenCount(bytes32 nodeId) external view returns (uint8);\\n\\n\\n    function getNodeWallet(bytes32 nodeId) external view returns (address);\\n\\n    function getNodeChildAtIndex(\\n        bytes32 nodeId,\\n        uint8 index\\n    ) external view returns (bytes32);\\n\\n    function getNodeIdByWallet(address wallet) external view returns (bytes32);\\n\\n    function getBalanceByNodeId(bytes32 nodeId) external view returns (uint256);\\n\\n    function getChildrenBalances(\\n        bytes32 nodeId\\n    ) external view returns (uint[6] memory balances);\\n    /// TODO: was uint256[] memory balances -> uint256[6] memory balances\\n\\n\\n    function getChildrenTotalBalances(\\n        bytes32 nodeId\\n    ) external view returns (uint256 total);\\n\\n    function getNodeCurrentDeposit(\\n        bytes32 nodeId\\n    ) external view returns (uint256);\\n\\n    function getNodeTotalDeposit(\\n        bytes32 nodeId\\n    ) external view returns (uint256);\\n\\n    function getChildrenCurrentDeposits(\\n        bytes32 nodeId\\n    ) external view returns (uint256[] memory childrenCurrentDeposits);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint8[6]\",\"name\":\"depthToGift\",\"type\":\"uint8[6]\"},{\"internalType\":\"address[5]\",\"name\":\"adminAddresses\",\"type\":\"address[5]\"},{\"internalType\":\"uint8[5]\",\"name\":\"depthToAdminReward\",\"type\":\"uint8[5]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"nodeId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"transfered\",\"type\":\"uint256\"}],\"name\":\"CurrentDepositDecreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"nodeId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"parentId\",\"type\":\"bytes32\"}],\"name\":\"NewNodeCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"nodeId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"transfered\",\"type\":\"uint256\"}],\"name\":\"NodeBalanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"nodeId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"}],\"name\":\"NodeDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"nodeId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"payed\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"NodePayed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"nodeId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"NodeWalletChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousParentId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newParentId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"parentIndex\",\"type\":\"uint8\"}],\"name\":\"ReferralReplaced\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"referralId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"depth\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"_appendToArray\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allowChangeWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disallowChangeWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"referralId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"depth\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"existPayment\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeId\",\"type\":\"bytes32\"}],\"name\":\"getBalanceByNodeId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeId\",\"type\":\"bytes32\"}],\"name\":\"getChildrenBalances\",\"outputs\":[{\"internalType\":\"uint256[6]\",\"name\":\"balances\",\"type\":\"uint256[6]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeId\",\"type\":\"bytes32\"}],\"name\":\"getChildrenCurrentDeposits\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"childrenCurrentDeposits\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeId\",\"type\":\"bytes32\"}],\"name\":\"getChildrenTotalBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"getNode\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isNode\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"parentId\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"parentIndex\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"children\",\"type\":\"bytes32[]\"},{\"internalType\":\"bool\",\"name\":\"canSell\",\"type\":\"bool\"}],\"internalType\":\"struct ICube.Node\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeId\",\"type\":\"bytes32\"}],\"name\":\"getNodeActiveChildrenCount\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeId\",\"type\":\"bytes32\"}],\"name\":\"getNodeById\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isNode\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"parentId\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"parentIndex\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"children\",\"type\":\"bytes32[]\"},{\"internalType\":\"bool\",\"name\":\"canSell\",\"type\":\"bool\"}],\"internalType\":\"struct ICube.Node\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeId\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"}],\"name\":\"getNodeChildAtIndex\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeId\",\"type\":\"bytes32\"}],\"name\":\"getNodeChildren\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"children\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeId\",\"type\":\"bytes32\"}],\"name\":\"getNodeChildrenCount\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeId\",\"type\":\"bytes32\"}],\"name\":\"getNodeCurrentDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"getNodeIdByWallet\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeId\",\"type\":\"bytes32\"}],\"name\":\"getNodeParentId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeId\",\"type\":\"bytes32\"}],\"name\":\"getNodeParentIndex\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeId\",\"type\":\"bytes32\"}],\"name\":\"getNodeTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeId\",\"type\":\"bytes32\"}],\"name\":\"getNodeTotalDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeId\",\"type\":\"bytes32\"}],\"name\":\"getNodeWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNodesCount\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeId\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"depth\",\"type\":\"uint8\"}],\"name\":\"getReferralsCountByDepth\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeId\",\"type\":\"bytes32\"}],\"name\":\"getReferralsTransfers\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"referralId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"depth\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct ICube.Transfer[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeId\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"depth\",\"type\":\"uint8\"}],\"name\":\"getReferralsTransfersByDepth\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"referralId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"depth\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct ICube.Transfer[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeId\",\"type\":\"bytes32\"}],\"name\":\"getReferralsUntransferedDeposits\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"referralId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"depth\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct ICube.Transfer[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeId\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"depth\",\"type\":\"uint8\"}],\"name\":\"getReferralsUntransferedDepositsByDepth\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"referralId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"depth\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct ICube.Transfer[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeId\",\"type\":\"bytes32\"}],\"name\":\"isActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeId\",\"type\":\"bytes32\"}],\"name\":\"isNode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"parentId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"newNode\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeId\",\"type\":\"bytes32\"}],\"name\":\"transferUntransferedDeposits\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeId\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"depth\",\"type\":\"uint8\"}],\"name\":\"transferUntransferedDepositsByDepth\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treeRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"transferedAmount\",\"type\":\"uint256\"}],\"name\":\"updateNodeBalance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"}],\"name\":\"updateNodeDeposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"}],\"name\":\"updateNodeDepositSingleState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeId\",\"type\":\"bytes32\"}],\"name\":\"updateNodeDepositSingleTransferReferals\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"referralId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"depthTransfer\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"updateNodeDepositSingleTransferUntransferedDepositsByDepth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"nodeId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"updateNodeWallet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Cube", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "000000000000000000000000888888f0550c41d32af5781f3985e2c663ef82a900000000000000000000000055d398326f99059ff775485246999027b319795500000000000000000000000000000000000000000000000000000000000000320000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000f000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000005000000000000000000000000e58ee8cde82d6fc77121c1fb553a32e1b266b9a2000000000000000000000000b25036cf4f20cb8e0c5320242c81b9784d33bfd8000000000000000000000000ee11690eb9273b6e67f824232c09a3e97af225710000000000000000000000000fa12fd19f65822c82e3467c03dea7bb1a731e87000000000000000000000000000000824b047e48db505c135e1735c4c6f7912000000000000000000000000000000000000000000000000000000000000000e100000000000000000000000000000000000000000000000000000000000000e100000000000000000000000000000000000000000000000000000000000000e100000000000000000000000000000000000000000000000000000000000000e10000000000000000000000000000000000000000000000000000000000000064", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}