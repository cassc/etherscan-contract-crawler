{"SourceCode": "pragma solidity 0.5.4;\r\n\r\ninterface IBEP20 {\r\n  function totalSupply() external view returns (uint256);\r\n  function balanceOf(address who) external view returns (uint256);\r\n  function allowance(address owner, address spender)\r\n  external view returns (uint256);\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n  function approve(address spender, uint256 value)\r\n  external returns (bool);\r\n  \r\n  function transferFrom(address from, address to, uint256 value)\r\n  external returns (bool);\r\n  function burn(uint256 value)\r\n  external returns (bool);\r\n  event Transfer(address indexed from,address indexed to,uint256 value);\r\n  event Approval(address indexed owner,address indexed spender,uint256 value);\r\n}\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract RAFFLESLOT {\r\n     using SafeMath for uint256;\r\n  \r\n     \r\n    struct User {\r\n        uint256 id;\r\n        address referrer;\r\n        mapping(uint8 => bool) levelActive;\r\n        mapping(uint8 => uint256) withdrawable;\r\n    }\r\n\r\n    mapping(address => address[]) public referrals;\r\n\r\n    mapping(uint8 => uint256) public globalCount;\r\n    mapping(uint8 => mapping(address => uint256)) public globalAddresstoId;\r\n    mapping(uint8 => mapping(uint256 => address)) public globalIndex;\r\n\r\n    mapping(address => User) public users;\r\n    mapping(uint => address) public idToAddress;\r\n    mapping(uint => address) public idToAddress2;\r\n\r\n    mapping(uint8 => uint256) public levelPrice;\r\n\r\n    uint256[] public REFERRAL_PERCENTS = [400, 50, 50, 50, 50];\r\n    uint256 public communityPercent=50;\r\n    uint256 public minWithdraw=1e18;\r\n    uint256 public lastUserId = 2; \r\n    \r\n    uint256 public  total_withdraw;\r\n\r\n    IBEP20 BUSD;\r\n\r\n    address public owner; \r\n    address public devAddress; \r\n    \r\n    event Registration(address indexed investor, address indexed referrer, uint256 indexed investorId, uint256 referrerId);\r\n    event Withdraw(address user, uint256 amount,uint8 level);\r\n    event ReferralReward(address  _user, address _from, uint256 reward, uint8 level, uint8 sublevel);\r\n    event CommunityReward(address  _user, address _from, uint256 reward, uint8 level, uint8 sublevel);\r\n    event BuyNewLevel(address  _user, uint256 userId, uint8 _level, address referrer, uint256 referrerId);\r\n        \r\n\r\n    constructor(address ownerAddress, address _devAddress, IBEP20 _BUSD) public \r\n    {\r\n        owner = ownerAddress;\r\n        devAddress=_devAddress;\r\n        BUSD = _BUSD;\r\n        User memory user = User({\r\n            id: 123456,\r\n            referrer: address(0)            \r\n        });\r\n        users[ownerAddress] = user;\r\n        idToAddress[1] = ownerAddress;\r\n        idToAddress2[123456] = ownerAddress;\r\n\r\n        for(uint8 i=1; i<13; i++){\r\n            globalCount[i]=1;\r\n            globalIndex[i][1]=ownerAddress;\r\n            users[ownerAddress].levelActive[i]=true;\r\n        }\r\n\r\n        levelPrice[1]=10e18;\r\n        levelPrice[2]=20e18;\r\n        levelPrice[3]=40e18;\r\n        levelPrice[4]=80e18;\r\n        levelPrice[5]=150e18;\r\n        levelPrice[6]=300e18;\r\n        levelPrice[7]=600e18;\r\n        levelPrice[8]=1200e18;\r\n        levelPrice[9]=2500e18;\r\n        levelPrice[10]=5000e18;\r\n        levelPrice[11]=10000e18;\r\n        levelPrice[12]=20000e18;\r\n    } \r\n    \r\n\r\n    function setWithdrawLimit(uint256 min_) public \r\n    {\r\n        require(msg.sender == owner, \"onlyOwner!\");\r\n        minWithdraw=min_;\r\n    }  \r\n\r\n     function registrationExt(address referrerAddress, uint256 id) external payable {\r\n        registration(msg.sender, referrerAddress, id);\r\n    }  \r\n  \r\n    function registration(address userAddress, address referrerAddress, uint256 id) private \r\n    {\r\n        require(!isUserExists(userAddress), \"user exists!\");\r\n        require(idToAddress2[id]==address(0) && id>=100000, \"Invalid ID\");\r\n        require(isUserExists(referrerAddress), \"referrer not exists!\");\r\n        \r\n        uint32 size;\r\n        assembly {\r\n            size := extcodesize(userAddress)\r\n        }\r\n        \r\n        require(size == 0, \"cannot be a contract!\");\r\n        \r\n        User memory user = User({\r\n            id: id,\r\n            referrer: referrerAddress\r\n        });\r\n        users[userAddress] = user;\r\n        idToAddress[lastUserId] = userAddress;\r\n        idToAddress2[id] = userAddress;\r\n        \r\n        users[userAddress].referrer = referrerAddress;\r\n        users[userAddress].levelActive[1]=true;\r\n        referrals[referrerAddress].push(userAddress);\r\n        globalCount[1]=globalCount[1]+1;\r\n        globalAddresstoId[1][userAddress]=globalCount[1];\r\n        globalIndex[1][globalCount[1]]=userAddress;\r\n\r\n        BUSD.transferFrom(msg.sender,address(this),levelPrice[1]);\r\n\r\n        address upline=referrerAddress;\r\n        uint256 leftPer=600;\r\n        for(uint8 i=0; i<5; i++)\r\n        {\r\n            uint256 reward=(levelPrice[1].mul(REFERRAL_PERCENTS[i])).div(1000);\r\n            users[upline].withdrawable[1]+=reward;\r\n            emit ReferralReward(upline, msg.sender, reward, 1, i+1);\r\n            upline=users[upline].referrer;\r\n            leftPer=leftPer-REFERRAL_PERCENTS[i];\r\n            if(upline==address(0))\r\n            {\r\n                BUSD.transfer(devAddress,(levelPrice[1].mul(leftPer)).div(1000));\r\n                break;\r\n            }\r\n        }\r\n\r\n        uint256 leftCom=400;\r\n        uint256 globalId=lastUserId-1;\r\n        for(uint8 j=1; j<=8; j++)\r\n        {\r\n            uint256 reward=(levelPrice[1].mul(communityPercent)).div(1000);\r\n            users[idToAddress[globalId]].withdrawable[1]+=reward;\r\n            emit CommunityReward(idToAddress[globalId], msg.sender, reward, 1, j);        \r\n            globalId--;\r\n            leftCom=leftCom-communityPercent;\r\n            if(globalId==0)\r\n            {\r\n                BUSD.transfer(devAddress,(levelPrice[1].mul(leftCom)).div(1000));\r\n                break;\r\n            }\r\n           \r\n        }\r\n\r\n        lastUserId++;\r\n        \r\n        emit Registration(userAddress, referrerAddress, users[userAddress].id, users[referrerAddress].id);\r\n    }\r\n\r\n    function buyLevel(uint8 level) public \r\n    {\r\n        require(isUserExists(msg.sender), \"user exists!\");\r\n        require(level<13, \"Max 12 Level!\");  \r\n        require(users[msg.sender].levelActive[level-1],\"Buy Previous Level First!\");\r\n        require(!users[msg.sender].levelActive[level],\"Level Already Activated!\");\r\n        BUSD.transferFrom(msg.sender,address(this),levelPrice[level]);\r\n        users[msg.sender].levelActive[level]=true;\r\n        globalCount[level]=globalCount[level]+1;\r\n        globalAddresstoId[level][msg.sender]=globalCount[level];\r\n        globalIndex[level][globalCount[level]]=msg.sender;\r\n        address upline=users[msg.sender].referrer;\r\n        uint256 leftPer=600;\r\n        for(uint8 i=0; i<5;)\r\n        {\r\n            if(users[upline].levelActive[level])\r\n            {\r\n                uint256 reward=(levelPrice[level].mul(REFERRAL_PERCENTS[i])).div(1000);\r\n                users[upline].withdrawable[level]+=reward;\r\n                emit ReferralReward(upline, msg.sender, reward, level, i+1);\r\n                leftPer=leftPer-REFERRAL_PERCENTS[i];\r\n                i++;\r\n            }\r\n            upline=users[upline].referrer;\r\n            if(upline==address(0))\r\n            {\r\n                BUSD.transfer(devAddress,(levelPrice[level].mul(leftPer)).div(1000));\r\n                break;\r\n            }\r\n        }\r\n\r\n        uint256 globalId=globalCount[level]-1;\r\n        uint8 j=1;\r\n        uint256 leftCom=400;\r\n        while(j<9)\r\n        {\r\n            if(users[globalIndex[level][globalId]].levelActive[level])\r\n            {\r\n                uint256 reward=(levelPrice[level].mul(communityPercent)).div(1000);\r\n                users[globalIndex[level][globalId]].withdrawable[level]+=reward;\r\n                emit CommunityReward(globalIndex[level][globalId], msg.sender, reward, level, j);\r\n                leftCom=leftCom-communityPercent;\r\n                j++;         \r\n            }\r\n            globalId--;\r\n            if(globalId==0)\r\n            {\r\n                BUSD.transfer(devAddress,(levelPrice[level].mul(leftCom)).div(1000));\r\n                break;\r\n            }\r\n        }\r\n        address refer= globalIndex[level][globalCount[level]-1];\r\n        emit BuyNewLevel(msg.sender, users[msg.sender].id, level, refer, users[refer].id);\r\n    }  \r\n\r\n    function withdraw(uint8 level) public{\r\n        require(isUserExists(msg.sender),\"User Not Exist!\");\r\n        require(users[msg.sender].withdrawable[level]>=minWithdraw,\"Minimum Withdraw !\");\r\n        uint256 payableAmount = users[msg.sender].withdrawable[level]/2;\r\n        BUSD.transfer(msg.sender,payableAmount);\r\n        if(msg.sender!=owner)\r\n        reInvest(msg.sender, payableAmount, level);\r\n        else\r\n        BUSD.transfer(devAddress,payableAmount);\r\n        emit Withdraw(msg.sender, users[msg.sender].withdrawable[level], level);\r\n        users[msg.sender].withdrawable[level]=0;\r\n    }\r\n  \r\n\r\n    function reInvest(address _user, uint256 investAmount, uint8 level) private {\r\n         address upline=users[_user].referrer;\r\n         uint8 i=0;\r\n         uint256 leftPer=600;\r\n        while(i<5)\r\n        {\r\n            if(users[upline].levelActive[level])\r\n            {\r\n                uint256 reward=(investAmount.mul(REFERRAL_PERCENTS[i])).div(1000);\r\n                users[upline].withdrawable[level]+=reward;\r\n                emit ReferralReward(upline, msg.sender, reward, level, i+1);\r\n                leftPer=leftPer-REFERRAL_PERCENTS[i];\r\n                i++;\r\n            }\r\n            upline=users[upline].referrer;\r\n            \r\n            if(upline==address(0))\r\n            {\r\n                BUSD.transfer(devAddress,(investAmount.mul(leftPer)).div(1000));\r\n                break;\r\n            }\r\n        }\r\n\r\n        uint256 globalId=globalAddresstoId[level][_user]-1;\r\n        uint8 j=1;\r\n        uint256 leftCom=400;\r\n        while(j<9)\r\n        {\r\n            if(users[globalIndex[level][globalId]].levelActive[level])\r\n            {\r\n                uint256 reward=(investAmount.mul(communityPercent)).div(1000);\r\n                users[globalIndex[level][globalId]].withdrawable[level]+=reward;\r\n                emit CommunityReward(globalIndex[level][globalId], msg.sender, reward, level, j);\r\n                leftCom=leftCom-communityPercent;\r\n                j++;\r\n            }          \r\n            globalId--;\r\n            \r\n            if(globalId==0)\r\n            {\r\n                BUSD.transfer(devAddress,(investAmount.mul(leftCom)).div(1000));\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getWithdrawAmt(address _user) public view returns(uint256[] memory){\r\n        uint256[] memory amt = new  uint256[](12);\r\n        uint8 i=0;\r\n        while(i<12){\r\n            amt[i]=users[_user].withdrawable[i+1];\r\n            i++;\r\n        }\r\n        return amt;\r\n    }\r\n   \r\n   \r\n    function isContract(address _address) public view returns (bool _isContract)\r\n    {\r\n          uint32 size;\r\n          assembly {\r\n            size := extcodesize(_address)\r\n          }\r\n          return (size > 0);\r\n    }   \r\n \r\n    \r\n    function isUserExists(address user) public view returns (bool) \r\n    {\r\n        return (users[user].id != 0);\r\n    }\r\n    \r\n    function bytesToAddress(bytes memory bys) private pure returns (address addr) {\r\n        assembly {\r\n            addr := mload(add(bys, 20))\r\n        }\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isContract\",\"outputs\":[{\"name\":\"_isContract\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getWithdrawAmt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"idToAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastUserId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"min_\",\"type\":\"uint256\"}],\"name\":\"setWithdrawLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isUserExists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"REFERRAL_PERCENTS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"communityPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"idToAddress2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"buyLevel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"globalIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"total_withdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"referrer\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minWithdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"globalAddresstoId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"globalCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"referrals\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"levelPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"referrerAddress\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"registrationExt\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"ownerAddress\",\"type\":\"address\"},{\"name\":\"_devAddress\",\"type\":\"address\"},{\"name\":\"_BUSD\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"investorId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"referrerId\",\"type\":\"uint256\"}],\"name\":\"Registration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"level\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"sublevel\",\"type\":\"uint8\"}],\"name\":\"ReferralReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"level\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"sublevel\",\"type\":\"uint8\"}],\"name\":\"CommunityReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"userId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_level\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"referrerId\",\"type\":\"uint256\"}],\"name\":\"BuyNewLevel\",\"type\":\"event\"}]", "ContractName": "RAFFLESLOT", "CompilerVersion": "v0.5.4+commit.9549d8ff", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000034e7b98618d8d5eb2f5e20e3f381c433aa8b97f6000000000000000000000000a39e7d11516bbfe5174e4fe59c684acff8c9c8ab000000000000000000000000e9e7cea3dedca5984780bafc599bd69add087d56", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://a088451b3c34f4fa6dbbb54b2c746cf8840c6819b70a9dd466b8f93476739407"}