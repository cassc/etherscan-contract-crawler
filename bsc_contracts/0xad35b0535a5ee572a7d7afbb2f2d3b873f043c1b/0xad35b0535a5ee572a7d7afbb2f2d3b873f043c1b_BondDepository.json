{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/bounds/BondDepository.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\ninterface IOwnable {\\n  function policy() external view returns (address);\\n\\n  function renounceManagement() external;\\n  \\n  function pushManagement( address newOwner_ ) external;\\n  \\n  function pullManagement() external;\\n}\\n\\ncontract Ownable is IOwnable {\\n\\n    address internal _owner;\\n    address internal _newOwner;\\n\\n    event OwnershipPushed(address indexed previousOwner, address indexed newOwner);\\n    event OwnershipPulled(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor () {\\n        _owner = msg.sender;\\n        emit OwnershipPushed( address(0), _owner );\\n    }\\n\\n    function policy() public view override returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyPolicy() {\\n        require( _owner == msg.sender, \\\"Ownable: caller is not the owner\\\" );\\n        _;\\n    }\\n\\n    function renounceManagement() public virtual override onlyPolicy() {\\n        emit OwnershipPushed( _owner, address(0) );\\n        _owner = address(0);\\n    }\\n\\n    function pushManagement( address newOwner_ ) public virtual override onlyPolicy() {\\n        require( newOwner_ != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipPushed( _owner, newOwner_ );\\n        _newOwner = newOwner_;\\n    }\\n    \\n    function pullManagement() public virtual override {\\n        require( msg.sender == _newOwner, \\\"Ownable: must be new owner to pull\\\");\\n        emit OwnershipPulled( _owner, _newOwner );\\n        _owner = _newOwner;\\n    }\\n}\\n\\nlibrary SafeMath {\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        return c;\\n    }\\n\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n\\n    function sqrrt(uint256 a) internal pure returns (uint c) {\\n        if (a > 3) {\\n            c = a;\\n            uint b = add( div( a, 2), 1 );\\n            while (b < c) {\\n                c = b;\\n                b = div( add( div( a, b ), b), 2 );\\n            }\\n        } else if (a != 0) {\\n            c = 1;\\n        }\\n    }\\n}\\n\\nlibrary Address {\\n\\n    function isContract(address account) internal view returns (bool) {\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            if (returndata.length > 0) {\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n\\n    function addressToString(address _address) internal pure returns(string memory) {\\n        bytes32 _bytes = bytes32(uint256(_address));\\n        bytes memory HEX = \\\"0123456789abcdef\\\";\\n        bytes memory _addr = new bytes(42);\\n\\n        _addr[0] = '0';\\n        _addr[1] = 'x';\\n\\n        for(uint256 i = 0; i < 20; i++) {\\n            _addr[2+i*2] = HEX[uint8(_bytes[i + 12] >> 4)];\\n            _addr[3+i*2] = HEX[uint8(_bytes[i + 12] & 0x0f)];\\n        }\\n\\n        return string(_addr);\\n\\n    }\\n}\\n\\ninterface IERC20 {\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\nabstract contract ERC20 is IERC20 {\\n\\n    using SafeMath for uint256;\\n\\n    // TODO comment actual hash value.\\n    bytes32 constant private ERC20TOKEN_ERC1820_INTERFACE_ID = keccak256( \\\"ERC20Token\\\" );\\n    \\n    mapping (address => uint256) internal _balances;\\n\\n    mapping (address => mapping (address => uint256)) internal _allowances;\\n\\n    uint256 internal _totalSupply;\\n\\n    string internal _name;\\n    \\n    string internal _symbol;\\n    \\n    uint8 internal _decimals;\\n\\n    constructor (string memory name_, string memory symbol_, uint8 decimals_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = decimals_;\\n    }\\n\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view override returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    function _mint(address account_, uint256 ammount_) internal virtual {\\n        require(account_ != address(0), \\\"ERC20: mint to the zero address\\\");\\n        _beforeTokenTransfer(address( this ), account_, ammount_);\\n        _totalSupply = _totalSupply.add(ammount_);\\n        _balances[account_] = _balances[account_].add(ammount_);\\n        emit Transfer(address( this ), account_, ammount_);\\n    }\\n\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n  function _beforeTokenTransfer( address from_, address to_, uint256 amount_ ) internal virtual { }\\n}\\n\\ninterface IERC2612Permit {\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function nonces(address owner) external view returns (uint256);\\n}\\n\\nlibrary Counters {\\n    using SafeMath for uint256;\\n\\n    struct Counter {\\n\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        counter._value += 1;\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        counter._value = counter._value.sub(1);\\n    }\\n}\\n\\nabstract contract ERC20Permit is ERC20, IERC2612Permit {\\n    using Counters for Counters.Counter;\\n\\n    mapping(address => Counters.Counter) private _nonces;\\n\\n    // keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n\\n    bytes32 public DOMAIN_SEPARATOR;\\n\\n    constructor() {\\n        uint256 chainID;\\n        assembly {\\n            chainID := chainid()\\n        }\\n\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                keccak256(bytes(name())),\\n                keccak256(bytes(\\\"1\\\")), // Version\\n                chainID,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"Permit: expired deadline\\\");\\n\\n        bytes32 hashStruct =\\n            keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, amount, _nonces[owner].current(), deadline));\\n\\n        bytes32 _hash = keccak256(abi.encodePacked(uint16(0x1901), DOMAIN_SEPARATOR, hashStruct));\\n\\n        address signer = ecrecover(_hash, v, r, s);\\n        require(signer != address(0) && signer == owner, \\\"ZeroSwapPermit: Invalid signature\\\");\\n\\n        _nonces[owner].increment();\\n        _approve(owner, spender, amount);\\n    }\\n\\n    function nonces(address owner) public view override returns (uint256) {\\n        return _nonces[owner].current();\\n    }\\n}\\n\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\\nlibrary FullMath {\\n    function fullMul(uint256 x, uint256 y) private pure returns (uint256 l, uint256 h) {\\n        uint256 mm = mulmod(x, y, uint256(-1));\\n        l = x * y;\\n        h = mm - l;\\n        if (mm < l) h -= 1;\\n    }\\n\\n    function fullDiv(\\n        uint256 l,\\n        uint256 h,\\n        uint256 d\\n    ) private pure returns (uint256) {\\n        uint256 pow2 = d & -d;\\n        d /= pow2;\\n        l /= pow2;\\n        l += h * ((-pow2) / pow2 + 1);\\n        uint256 r = 1;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        return l * r;\\n    }\\n\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 d\\n    ) internal pure returns (uint256) {\\n        (uint256 l, uint256 h) = fullMul(x, y);\\n        uint256 mm = mulmod(x, y, d);\\n        if (mm > l) h -= 1;\\n        l -= mm;\\n        require(h < d, 'FullMath::mulDiv: overflow');\\n        return fullDiv(l, h, d);\\n    }\\n}\\n\\nlibrary FixedPoint {\\n\\n    struct uq112x112 {\\n        uint224 _x;\\n    }\\n\\n    struct uq144x112 {\\n        uint256 _x;\\n    }\\n\\n    uint8 private constant RESOLUTION = 112;\\n    uint256 private constant Q112 = 0x10000000000000000000000000000;\\n    uint256 private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000;\\n    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\\n\\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\\n        return uint112(self._x >> RESOLUTION);\\n    }\\n\\n    function decode112with18(uq112x112 memory self) internal pure returns (uint) {\\n\\n        return uint(self._x) / 5192296858534827;\\n    }\\n\\n    function fraction(uint256 numerator, uint256 denominator) internal pure returns (uq112x112 memory) {\\n        require(denominator > 0, 'FixedPoint::fraction: division by zero');\\n        if (numerator == 0) return FixedPoint.uq112x112(0);\\n\\n        if (numerator <= uint144(-1)) {\\n            uint256 result = (numerator << RESOLUTION) / denominator;\\n            require(result <= uint224(-1), 'FixedPoint::fraction: overflow');\\n            return uq112x112(uint224(result));\\n        } else {\\n            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\\n            require(result <= uint224(-1), 'FixedPoint::fraction: overflow');\\n            return uq112x112(uint224(result));\\n        }\\n    }\\n}\\n\\ninterface ITreasury {\\n    function deposit( uint _amount, address _token, uint _profit ) external returns ( bool );\\n    function valueOf( address _token, uint _amount ) external view returns ( uint value_ );\\n}\\n\\ninterface IBondCalculator {\\n    function valuation( address _LP, uint _amount ) external view returns ( uint );\\n    function markdown( address _LP ) external view returns ( uint );\\n}\\n\\ninterface IStaking {\\n    function stake( uint _amount, address _recipient ) external returns ( bool );\\n}\\n\\ninterface IStakingHelper {\\n    function stake( uint _amount, address _recipient ) external;\\n}\\n\\ncontract BondDepository is Ownable {\\n\\n    using FixedPoint for *;\\n    using SafeERC20 for IERC20;\\n    using SafeMath for uint;\\n\\n\\n\\n\\n    /* ======== EVENTS ======== */\\n\\n    event BondCreated( uint deposit, uint indexed payout, uint indexed expires, uint indexed priceInUSD );\\n    event BondRedeemed( address indexed recipient, uint payout, uint remaining );\\n    event BondPriceChanged( uint indexed priceInUSD, uint indexed internalPrice, uint indexed debtRatio );\\n    event ControlVariableAdjustment( uint initialBCV, uint newBCV, uint adjustment, bool addition );\\n\\n\\n\\n\\n    /* ======== STATE VARIABLES ======== */\\n\\n    address public immutable RS; // token given as payment for bond\\n    address public immutable principle; // token used to create bond\\n    address public immutable treasury; // mints RS when receives principle\\n    address public DAO; // receives profit share from bond\\n\\n    bool public immutable isLiquidityBond; // LP and Reserve bonds are treated slightly different\\n    address public immutable bondCalculator; // calculates value of LP tokens\\n\\n    address public staking; // to auto-stake payout\\n    address public stakingHelper; // to stake and claim if no staking warmup\\n    bool public useHelper;\\n\\n    Terms public terms; // stores terms for new bonds\\n    Adjust public adjustment; // stores adjustment to BCV data\\n\\n    mapping( address => Bond ) public bondInfo; // stores bond information for depositors\\n\\n    uint public totalDebt; // total value of outstanding bonds; used for pricing\\n    uint public lastDecay; // reference block for debt decay\\n\\n\\n\\n\\n    /* ======== STRUCTS ======== */\\n\\n    // Info for creating new bonds\\n    struct Terms {\\n        uint controlVariable; // scaling variable for price\\n        uint vestingTerm; // in blocks\\n        uint minimumPrice; // vs principle value\\n        uint maxPayout; // in thousandths of a %. i.e. 500 = 0.5%\\n        uint fee; // as % of bond payout, in hundreths. ( 500 = 5% = 0.05 for every 1 paid)\\n        uint maxDebt; // 9 decimal debt ratio, max % total supply created as debt\\n    }\\n\\n    // Info for bond holder\\n    struct Bond {\\n        uint payout; // RS remaining to be paid\\n        uint vesting; // Blocks left to vest\\n        uint lastBlock; // Last interaction\\n        uint pricePaid; // In BUSD, for front end viewing\\n    }\\n\\n    // Info for incremental adjustments to control variable \\n    struct Adjust {\\n        bool add; // addition or subtraction\\n        uint rate; // increment\\n        uint target; // BCV when adjustment finished\\n        uint buffer; // minimum length (in blocks) between adjustments\\n        uint lastBlock; // block when last adjustment made\\n    }\\n\\n\\n\\n\\n    /* ======== INITIALIZATION ======== */\\n\\n    constructor ( \\n        address _RS,\\n        address _principle,\\n        address _treasury, \\n        address _DAO, \\n        address _bondCalculator\\n    ) {\\n        require( _RS != address(0) );\\n        RS = _RS;\\n        require( _principle != address(0) );\\n        principle = _principle;\\n        require( _treasury != address(0) );\\n        treasury = _treasury;\\n        require( _DAO != address(0) );\\n        DAO = _DAO;\\n        // bondCalculator should be address(0) if not LP bond\\n        bondCalculator = _bondCalculator;\\n        isLiquidityBond = ( _bondCalculator != address(0) );\\n    }\\n\\n    /**\\n     *  @notice initializes bond parameters\\n     *  @param _controlVariable uint\\n     *  @param _vestingTerm uint\\n     *  @param _minimumPrice uint\\n     *  @param _maxPayout uint\\n     *  @param _fee uint\\n     *  @param _maxDebt uint\\n     *  @param _initialDebt uint\\n     */\\n    function initializeBondTerms( \\n        uint _controlVariable, \\n        uint _vestingTerm,\\n        uint _minimumPrice,\\n        uint _maxPayout,\\n        uint _fee,\\n        uint _maxDebt,\\n        uint _initialDebt\\n    ) external onlyPolicy() {\\n        require( terms.controlVariable == 0, \\\"Bonds must be initialized from 0\\\" );\\n        terms = Terms ({\\n            controlVariable: _controlVariable,\\n            vestingTerm: _vestingTerm,\\n            minimumPrice: _minimumPrice,\\n            maxPayout: _maxPayout,\\n            fee: _fee,\\n            maxDebt: _maxDebt\\n        });\\n        totalDebt = _initialDebt;\\n        lastDecay = block.number;\\n    }\\n\\n\\n\\n    \\n    /* ======== POLICY FUNCTIONS ======== */\\n\\n    enum PARAMETER { VESTING, PAYOUT, FEE, DEBT }\\n    /**\\n     *  @notice set parameters for new bonds\\n     *  @param _parameter PARAMETER\\n     *  @param _input uint\\n     */\\n    function setBondTerms ( PARAMETER _parameter, uint _input ) external onlyPolicy() {\\n        if ( _parameter == PARAMETER.VESTING ) { // 0\\n            require( _input >= 10000, \\\"Vesting must be longer than 36 hours\\\" );\\n            terms.vestingTerm = _input;\\n        } else if ( _parameter == PARAMETER.PAYOUT ) { // 1\\n            require( _input <= 1000, \\\"Payout cannot be above 1 percent\\\" );\\n            terms.maxPayout = _input;\\n        } else if ( _parameter == PARAMETER.FEE ) { // 2\\n            require( _input <= 10000, \\\"DAO fee cannot exceed payout\\\" );\\n            terms.fee = _input;\\n        } else if ( _parameter == PARAMETER.DEBT ) { // 3\\n            terms.maxDebt = _input;\\n        }\\n    }\\n\\n    /**\\n     *  @notice set control variable adjustment\\n     *  @param _addition bool\\n     *  @param _increment uint\\n     *  @param _target uint\\n     *  @param _buffer uint\\n     */\\n    function setAdjustment ( \\n        bool _addition,\\n        uint _increment, \\n        uint _target,\\n        uint _buffer \\n    ) external onlyPolicy() {\\n        require( _increment <= terms.controlVariable.mul( 25 ).div( 1000 ), \\\"Increment too large\\\" );\\n\\n        adjustment = Adjust({\\n            add: _addition,\\n            rate: _increment,\\n            target: _target,\\n            buffer: _buffer,\\n            lastBlock: block.number\\n        });\\n    }\\n\\n    /**\\n     *  @notice set contract for auto stake\\n     *  @param _staking address\\n     *  @param _helper bool\\n     */\\n    function setStaking( address _staking, bool _helper ) external onlyPolicy() {\\n        require( _staking != address(0) );\\n        if ( _helper ) {\\n            useHelper = true;\\n            stakingHelper = _staking;\\n        } else {\\n            useHelper = false;\\n            staking = _staking;\\n        }\\n    }\\n\\n\\n    \\n\\n    /* ======== USER FUNCTIONS ======== */\\n\\n    /**\\n     *  @notice deposit bond\\n     *  @param _amount uint\\n     *  @param _maxPrice uint\\n     *  @param _depositor address\\n     *  @return uint\\n     */\\n    function deposit( \\n        uint _amount, \\n        uint _maxPrice,\\n        address _depositor\\n    ) external returns ( uint ) {\\n        require( _depositor != address(0), \\\"Invalid address\\\" );\\n\\n        decayDebt();\\n        require( totalDebt <= terms.maxDebt, \\\"Max capacity reached\\\" );\\n        \\n        uint priceInUSD = bondPriceInUSD(); // Stored in bond info\\n        uint nativePrice = _bondPrice();\\n\\n        require( _maxPrice >= nativePrice, \\\"Slippage limit: more than max price\\\" ); // slippage protection\\n        uint value = ITreasury( treasury ).valueOf( principle, _amount );\\n        uint payout = payoutFor( value ); // payout to bonder is computed \u5229\u606f\\n\\n        require( payout >= 10000000, \\\"Bond too small\\\" ); // must be > 0.01 RS ( underflow protection )\\n        require( payout <= maxPayout(), \\\"Bond too large\\\"); // size protection because there is no slippage\\n\\n        // profits are calculated\\n        uint fee = payout.mul( terms.fee ).div( 10000 );\\n        uint profit = value.sub( payout ).sub( fee );\\n\\n        /**\\n            principle is transferred in\\n            approved and\\n            deposited into the treasury, returning (_amount - profit) RS\\n         */\\n        IERC20( principle ).safeTransferFrom( msg.sender, address(this), _amount );\\n        IERC20( principle ).approve( address( treasury ), _amount );\\n        ITreasury( treasury ).deposit( _amount, principle, profit );\\n        \\n        if ( fee != 0 ) { // fee is transferred to dao \\n            IERC20( RS ).safeTransfer( DAO, fee ); \\n        }\\n        \\n        // total debt is increased\\n        totalDebt = totalDebt.add( value ); \\n                \\n        // depositor info is stored\\n        bondInfo[ _depositor ] = Bond({\\n            payout: bondInfo[ _depositor ].payout.add( payout ),\\n            vesting: terms.vestingTerm,\\n            lastBlock: block.number,\\n            pricePaid: priceInUSD\\n        });\\n\\n        // indexed events are emitted\\n        emit BondCreated( _amount, payout, block.number.add( terms.vestingTerm ), priceInUSD );\\n        emit BondPriceChanged( bondPriceInUSD(), _bondPrice(), debtRatio() );\\n\\n        adjust(); // control variable is adjusted\\n        return payout; \\n    }\\n\\n    /** \\n     *  @notice redeem bond for user\\n     *  @param _recipient address\\n     *  @param _stake bool\\n     *  @return uint\\n     */ \\n    function redeem( address _recipient, bool _stake ) external returns ( uint ) {        \\n        Bond memory info = bondInfo[ _recipient ];\\n        uint percentVested = percentVestedFor( _recipient ); // (blocks since last interaction / vesting term remaining)\\n\\n        if ( percentVested >= 10000 ) { // if fully vested\\n            delete bondInfo[ _recipient ]; // delete user info\\n            emit BondRedeemed( _recipient, info.payout, 0 ); // emit bond data\\n            return stakeOrSend( _recipient, _stake, info.payout ); // pay user everything due\\n\\n        } else { // if unfinished\\n            // calculate payout vested\\n            uint payout = info.payout.mul( percentVested ).div( 10000 );\\n\\n            // store updated deposit info\\n            bondInfo[ _recipient ] = Bond({\\n                payout: info.payout.sub( payout ),\\n                vesting: info.vesting.sub( block.number.sub( info.lastBlock ) ),\\n                lastBlock: block.number,\\n                pricePaid: info.pricePaid\\n            });\\n\\n            emit BondRedeemed( _recipient, payout, bondInfo[ _recipient ].payout );\\n            return stakeOrSend( _recipient, _stake, payout );\\n        }\\n    }\\n\\n\\n\\n    \\n    /* ======== INTERNAL HELPER FUNCTIONS ======== */\\n\\n    /**\\n     *  @notice allow user to stake payout automatically\\n     *  @param _stake bool\\n     *  @param _amount uint\\n     *  @return uint\\n     */\\n    function stakeOrSend( address _recipient, bool _stake, uint _amount ) internal returns ( uint ) {\\n        if ( !_stake ) { // if user does not want to stake\\n            IERC20( RS ).transfer( _recipient, _amount ); // send payout\\n        } else { // if user wants to stake\\n            if ( useHelper ) { // use if staking warmup is 0\\n                IERC20( RS ).approve( stakingHelper, _amount );\\n                IStakingHelper( stakingHelper ).stake( _amount, _recipient );\\n            } else {\\n                IERC20( RS ).approve( staking, _amount );\\n                IStaking( staking ).stake( _amount, _recipient );\\n            }\\n        }\\n        return _amount;\\n    }\\n\\n    /**\\n     *  @notice makes incremental adjustment to control variable\\n     */\\n    function adjust() internal {\\n        uint blockCanAdjust = adjustment.lastBlock.add( adjustment.buffer );\\n        if( adjustment.rate != 0 && block.number >= blockCanAdjust ) {\\n            uint initial = terms.controlVariable;\\n            if ( adjustment.add ) {\\n                terms.controlVariable = terms.controlVariable.add( adjustment.rate );\\n                if ( terms.controlVariable >= adjustment.target ) {\\n                    adjustment.rate = 0;\\n                }\\n            } else {\\n                terms.controlVariable = terms.controlVariable.sub( adjustment.rate );\\n                if ( terms.controlVariable <= adjustment.target ) {\\n                    adjustment.rate = 0;\\n                }\\n            }\\n            adjustment.lastBlock = block.number;\\n            emit ControlVariableAdjustment( initial, terms.controlVariable, adjustment.rate, adjustment.add );\\n        }\\n    }\\n\\n    /**\\n     *  @notice reduce total debt\\n     */\\n    function decayDebt() internal {\\n        totalDebt = totalDebt.sub( debtDecay() );\\n        lastDecay = block.number;\\n    }\\n\\n\\n\\n\\n    /* ======== VIEW FUNCTIONS ======== */\\n\\n    /**\\n     *  @notice determine maximum bond size\\n     *  @return uint\\n     */\\n    function maxPayout() public view returns ( uint ) {\\n        return IERC20( RS ).totalSupply().mul( terms.maxPayout ).div( 100000 );\\n    }\\n\\n    /**\\n     *  @notice calculate interest due for new bond\\n     *  @param _value uint\\n     *  @return uint\\n     */\\n    function payoutFor( uint _value ) public view returns ( uint ) {\\n        return FixedPoint.fraction( _value, bondPrice() ).decode112with18().div( 1e16 );\\n    }\\n\\n\\n    /**\\n     *  @notice calculate current bond premium\\n     *  @return price_ uint\\n     */\\n    function bondPrice() public view returns ( uint price_ ) {        \\n        price_ = terms.controlVariable.mul( debtRatio() ).add( 1000000000 ).div( 1e7 );\\n        if ( price_ < terms.minimumPrice ) {\\n            price_ = terms.minimumPrice;\\n        }\\n    }\\n\\n    /**\\n     *  @notice calculate current bond price and remove floor if above\\n     *  @return price_ uint\\n     */\\n    function _bondPrice() internal returns ( uint price_ ) {\\n        price_ = terms.controlVariable.mul( debtRatio() ).add( 1000000000 ).div( 1e7 );\\n        if ( price_ < terms.minimumPrice ) {\\n            price_ = terms.minimumPrice;        \\n        } else if ( terms.minimumPrice != 0 ) {\\n            terms.minimumPrice = 0;\\n        }\\n    }\\n\\n    /**\\n     *  @notice converts bond price to BUSD value\\n     *  @return price_ uint\\n     */\\n    function bondPriceInUSD() public view returns ( uint price_ ) {\\n        if( isLiquidityBond ) {\\n            price_ = bondPrice().mul( IBondCalculator( bondCalculator ).markdown( principle ) ).div( 100 );\\n        } else {\\n            price_ = bondPrice().mul( 10 ** IERC20( principle ).decimals() ).div( 100 );\\n        }\\n    }\\n\\n\\n    /**\\n     *  @notice calculate current ratio of debt to RS supply\\n     *  @return debtRatio_ uint\\n     */\\n    function debtRatio() public view returns ( uint debtRatio_ ) {   \\n        uint supply = IERC20( RS ).totalSupply();\\n        debtRatio_ = FixedPoint.fraction( \\n            currentDebt().mul( 1e9 ), \\n            supply\\n        ).decode112with18().div( 1e18 );\\n    }\\n\\n    /**\\n     *  @notice debt ratio in same terms for reserve or liquidity bonds\\n     *  @return uint\\n     */\\n    function standardizedDebtRatio() external view returns ( uint ) {\\n        if ( isLiquidityBond ) {\\n            return debtRatio().mul( IBondCalculator( bondCalculator ).markdown( principle ) ).div( 1e9 );\\n        } else {\\n            return debtRatio();\\n        }\\n    }\\n\\n    /**\\n     *  @notice calculate debt factoring in decay\\n     *  @return uint\\n     */\\n    function currentDebt() public view returns ( uint ) {\\n        return totalDebt.sub( debtDecay() );\\n    }\\n\\n    /**\\n     *  @notice amount to decay total debt by\\n     *  @return decay_ uint\\n     */\\n    function debtDecay() public view returns ( uint decay_ ) {\\n        uint blocksSinceLast = block.number.sub( lastDecay );\\n        decay_ = totalDebt.mul( blocksSinceLast ).div( terms.vestingTerm );\\n        if ( decay_ > totalDebt ) {\\n            decay_ = totalDebt;\\n        }\\n    }\\n\\n\\n    /**\\n     *  @notice calculate how far into vesting a depositor is\\n     *  @param _depositor address\\n     *  @return percentVested_ uint\\n     */\\n    function percentVestedFor( address _depositor ) public view returns ( uint percentVested_ ) {\\n        Bond memory bond = bondInfo[ _depositor ];\\n        uint blocksSinceLast = block.number.sub( bond.lastBlock );\\n        uint vesting = bond.vesting;\\n\\n        if ( vesting > 0 ) {\\n            percentVested_ = blocksSinceLast.mul( 10000 ).div( vesting );\\n        } else {\\n            percentVested_ = 0;\\n        }\\n    }\\n\\n    /**\\n     *  @notice calculate amount of RS available for claim by depositor\\n     *  @param _depositor address\\n     *  @return pendingPayout_ uint\\n     */\\n    function pendingPayoutFor( address _depositor ) external view returns ( uint pendingPayout_ ) {\\n        uint percentVested = percentVestedFor( _depositor );\\n        uint payout = bondInfo[ _depositor ].payout;\\n\\n        if ( percentVested >= 10000 ) {\\n            pendingPayout_ = payout;\\n        } else {\\n            pendingPayout_ = payout.mul( percentVested ).div( 10000 );\\n        }\\n    }\\n\\n\\n\\n\\n    /* ======= AUXILLIARY ======= */\\n\\n    /**\\n     *  @notice allow anyone to send lost tokens (excluding principle or RS) to the DAO\\n     *  @return bool\\n     */\\n    function recoverLostToken( address _token ) external returns ( bool ) {\\n        require( _token != RS );\\n        require( _token != principle );\\n        IERC20( _token ).safeTransfer( DAO, IERC20( _token ).balanceOf( address(this) ) );\\n        return true;\\n    }\\n\\n    function setTotalDebt(uint256 _newDebt) external onlyPolicy {\\n        totalDebt = _newDebt;\\n        lastDecay = block.number;\\n    }\\n\\n    function setDao(address _newDao) external onlyPolicy {\\n        DAO = _newDao;\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_RS\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_principle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_DAO\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bondCalculator\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"expires\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"priceInUSD\",\"type\":\"uint256\"}],\"name\":\"BondCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"priceInUSD\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"internalPrice\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"debtRatio\",\"type\":\"uint256\"}],\"name\":\"BondPriceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"name\":\"BondRedeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"initialBCV\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBCV\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"adjustment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"addition\",\"type\":\"bool\"}],\"name\":\"ControlVariableAdjustment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipPulled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipPushed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DAO\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adjustment\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"add\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"target\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buffer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bondCalculator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"bondInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"payout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vesting\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pricePaid\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bondPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bondPriceInUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"debtDecay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"decay_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"debtRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"debtRatio_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_controlVariable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_vestingTerm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minimumPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxPayout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_initialDebt\",\"type\":\"uint256\"}],\"name\":\"initializeBondTerms\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isLiquidityBond\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastDecay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxPayout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"payoutFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"}],\"name\":\"pendingPayoutFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pendingPayout_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"}],\"name\":\"percentVestedFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"percentVested_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"policy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"principle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pullManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner_\",\"type\":\"address\"}],\"name\":\"pushManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"recoverLostToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_stake\",\"type\":\"bool\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_addition\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_increment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_target\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_buffer\",\"type\":\"uint256\"}],\"name\":\"setAdjustment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum BondDepository.PARAMETER\",\"name\":\"_parameter\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_input\",\"type\":\"uint256\"}],\"name\":\"setBondTerms\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newDao\",\"type\":\"address\"}],\"name\":\"setDao\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staking\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_helper\",\"type\":\"bool\"}],\"name\":\"setStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newDebt\",\"type\":\"uint256\"}],\"name\":\"setTotalDebt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"staking\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingHelper\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"standardizedDebtRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"terms\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"controlVariable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestingTerm\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPayout\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"useHelper\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "BondDepository", "CompilerVersion": "v0.7.5+commit.eb77ed08", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c25b7244e192d531495c400c64ea914a77e730a200000000000000000000000095a1199eba84ac5f19546519e287d43d2f0e1b41000000000000000000000000d055fe3b8de27a730e3b57bf108648ee01c960550000000000000000000000008ef2dd80b448ce112379e144011ee05c4b9edc4f0000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}