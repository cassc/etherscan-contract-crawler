{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@mimic-fi/v2-bridge-connector/contracts/IBridgeConnector.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.8.0;\\n\\nimport '@mimic-fi/v2-registry/contracts/implementations/IImplementation.sol';\\n\\n/**\\n * @title IBridgeConnector\\n * @dev Bridge Connector interface to bridge tokens between different chains. It must follow IImplementation interface.\\n */\\ninterface IBridgeConnector is IImplementation {\\n    /**\\n     * @dev Enum identifying the sources proposed: Hop only for now.\\n     */\\n    enum Source {\\n        Hop\\n    }\\n\\n    /**\\n     * @dev Bridge assets to a different chain\\n     * @param source Source to execute the requested bridge op\\n     * @param chainId ID of the destination chain\\n     * @param token Address of the token to be bridged\\n     * @param amountIn Amount of tokens to be bridged\\n     * @param minAmountOut Minimum amount of tokens willing to receive on the destination chain\\n     * @param recipient Address that will receive the tokens on the destination chain\\n     * @param data ABI encoded data that will depend on the requested source\\n     */\\n    function bridge(\\n        uint8 source,\\n        uint256 chainId,\\n        address token,\\n        uint256 amountIn,\\n        uint256 minAmountOut,\\n        address recipient,\\n        bytes memory data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-helpers/contracts/auth/Authorizer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport './IAuthorizer.sol';\\n\\n/**\\n * @title Authorizer\\n * @dev Authorization module to be used by contracts that need to implement permissions for their methods.\\n * It provides a permissions model to list who is allowed to call what function in a contract. And only accounts\\n * authorized to manage those permissions are the ones that are allowed to authorize or unauthorize accounts.\\n */\\ncontract Authorizer is IAuthorizer {\\n    // Constant used to denote that a permission is open to anyone\\n    address public constant ANY_ADDRESS = address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);\\n\\n    // Internal mapping to tell who is allowed to do what indexed by (account, function selector)\\n    mapping (address => mapping (bytes4 => bool)) private authorized;\\n\\n    /**\\n     * @dev Modifier that should be used to tag protected functions\\n     */\\n    modifier auth() {\\n        _authenticate(msg.sender, msg.sig);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Tells whether someone is allowed to call a function or not. It returns true if it's allowed to anyone.\\n     * @param who Address asking permission for\\n     * @param what Function selector asking permission for\\n     */\\n    function isAuthorized(address who, bytes4 what) public view override returns (bool) {\\n        return authorized[ANY_ADDRESS][what] || authorized[who][what];\\n    }\\n\\n    /**\\n     * @dev Authorizes someone to call a function. Sender must be authorize to do so.\\n     * @param who Address to be authorized\\n     * @param what Function selector to be granted\\n     */\\n    function authorize(address who, bytes4 what) external override auth {\\n        _authorize(who, what);\\n    }\\n\\n    /**\\n     * @dev Unauthorizes someone to call a function. Sender must be authorize to do so.\\n     * @param who Address to be unauthorized\\n     * @param what Function selector to be revoked\\n     */\\n    function unauthorize(address who, bytes4 what) external override auth {\\n        _unauthorize(who, what);\\n    }\\n\\n    /**\\n     * @dev Internal function to authenticate someone over a function.\\n     * It reverts if the given account is not authorized to call the requested function.\\n     * @param who Address to be authenticated\\n     * @param what Function selector to be authenticated\\n     */\\n    function _authenticate(address who, bytes4 what) internal view {\\n        require(isAuthorized(who, what), 'AUTH_SENDER_NOT_ALLOWED');\\n    }\\n\\n    /**\\n     * @dev Internal function to authorize someone to call a function\\n     * @param who Address to be authorized\\n     * @param what Function selector to be granted\\n     */\\n    function _authorize(address who, bytes4 what) internal {\\n        authorized[who][what] = true;\\n        emit Authorized(who, what);\\n    }\\n\\n    /**\\n     * @dev Internal function to unauthorize someone to call a function\\n     * @param who Address to be unauthorized\\n     * @param what Function selector to be revoked\\n     */\\n    function _unauthorize(address who, bytes4 what) internal {\\n        authorized[who][what] = false;\\n        emit Unauthorized(who, what);\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-helpers/contracts/auth/IAuthorizer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.8.0;\\n\\n/**\\n * @title IAuthorizer\\n */\\ninterface IAuthorizer {\\n    /**\\n     * @dev Emitted when an account is authorized to call a function\\n     */\\n    event Authorized(address indexed who, bytes4 what);\\n\\n    /**\\n     * @dev Emitted when an account is unauthorized to call a function\\n     */\\n    event Unauthorized(address indexed who, bytes4 what);\\n\\n    /**\\n     * @dev Authorizes someone to call a function. Sender must be authorize to do so.\\n     * @param who Address to be authorized\\n     * @param what Function selector to be granted\\n     */\\n    function authorize(address who, bytes4 what) external;\\n\\n    /**\\n     * @dev Unauthorizes someone to call a function. Sender must be authorize to do so.\\n     * @param who Address to be unauthorized\\n     * @param what Function selector to be revoked\\n     */\\n    function unauthorize(address who, bytes4 what) external;\\n\\n    /**\\n     * @dev Tells whether someone is allowed to call a function or not. It returns true if it's allowed to anyone.\\n     * @param who Address asking permission for\\n     * @param what Function selector asking permission for\\n     */\\n    function isAuthorized(address who, bytes4 what) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-helpers/contracts/math/FixedPoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title FixedPoint\\n * @dev Math library to operate with fixed point values with 18 decimals\\n */\\nlibrary FixedPoint {\\n    // 1 in fixed point value: 18 decimal places\\n    uint256 internal constant ONE = 1e18;\\n\\n    /**\\n     * @dev Multiplies two fixed point numbers rounding down\\n     */\\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 product = a * b;\\n            require(a == 0 || product / a == b, 'MUL_OVERFLOW');\\n            return product / ONE;\\n        }\\n    }\\n\\n    /**\\n     * @dev Multiplies two fixed point numbers rounding up\\n     */\\n    function mulUp(uint256 a, uint256 b) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 product = a * b;\\n            require(a == 0 || product / a == b, 'MUL_OVERFLOW');\\n            return product == 0 ? 0 : (((product - 1) / ONE) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Divides two fixed point numbers rounding down\\n     */\\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\\n        unchecked {\\n            require(b != 0, 'ZERO_DIVISION');\\n            if (a == 0) return 0;\\n            uint256 aInflated = a * ONE;\\n            require(aInflated / a == ONE, 'DIV_INTERNAL');\\n            return aInflated / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Divides two fixed point numbers rounding up\\n     */\\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\\n        unchecked {\\n            require(b != 0, 'ZERO_DIVISION');\\n            if (a == 0) return 0;\\n            uint256 aInflated = a * ONE;\\n            require(aInflated / a == ONE, 'DIV_INTERNAL');\\n            return ((aInflated - 1) / b) + 1;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-helpers/contracts/math/UncheckedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title UncheckedMath\\n * @dev Math library to perform unchecked operations\\n */\\nlibrary UncheckedMath {\\n    /**\\n     * @dev Unsafely adds two unsigned integers\\n     */\\n    function uncheckedAdd(uint256 a, uint256 b) internal pure returns (uint256) {\\n        unchecked {\\n            return a + b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Unsafely subtracts two unsigned integers\\n     */\\n    function uncheckedSub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        unchecked {\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Unsafely multiplies two unsigned integers\\n     */\\n    function uncheckedMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        unchecked {\\n            return a * b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Unsafely multiplies two signed integers\\n     */\\n    function uncheckedMul(int256 a, int256 b) internal pure returns (int256) {\\n        unchecked {\\n            return a * b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Unsafely divides two unsigned integers\\n     */\\n    function uncheckedDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        unchecked {\\n            return a / b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-helpers/contracts/utils/Arrays.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '../math/UncheckedMath.sol';\\n\\n/**\\n * @title Arrays\\n * @dev Helper methods to operate arrays\\n */\\nlibrary Arrays {\\n    using UncheckedMath for uint256;\\n\\n    /**\\n     * @dev Tells if an array of addresses includes the given ones\\n     */\\n    function includes(address[] memory arr, address a, address b) internal pure returns (bool) {\\n        bool containsA;\\n        bool containsB;\\n        for (uint256 i = 0; i < arr.length; i = i.uncheckedAdd(1)) {\\n            if (arr[i] == a) containsA = true;\\n            if (arr[i] == b) containsB = true;\\n        }\\n        return containsA && containsB;\\n    }\\n\\n    /**\\n     * @dev Builds an array of addresses based on the given ones\\n     */\\n    function from(address a, address b) internal pure returns (address[] memory result) {\\n        result = new address[](2);\\n        result[0] = a;\\n        result[1] = b;\\n    }\\n\\n    /**\\n     * @dev Builds an array of addresses based on the given ones\\n     */\\n    function from(address a, address[] memory b, address c) internal pure returns (address[] memory result) {\\n        // No need for checked math since we are simply adding one to a memory array's length\\n        result = new address[](b.length.uncheckedAdd(2));\\n        result[0] = a;\\n\\n        // No need for checked math since we are using it to compute indexes manually, always within boundaries\\n        for (uint256 i = 0; i < b.length; i = i.uncheckedAdd(1)) result[i.uncheckedAdd(1)] = b[i];\\n        result[b.length.uncheckedAdd(1)] = c;\\n    }\\n\\n    /**\\n     * @dev Builds an array of addresses based on the given ones\\n     */\\n    function from(address a, address[] memory b, address[] memory c) internal pure returns (address[] memory result) {\\n        // No need for checked math since we are simply adding two memory array's length\\n        result = new address[](b.length.uncheckedAdd(c.length).uncheckedAdd(1));\\n        result[0] = a;\\n\\n        // No need for checked math since we are using it to compute indexes manually, always within boundaries\\n        for (uint256 i = 0; i < b.length; i = i.uncheckedAdd(1)) {\\n            result[i.uncheckedAdd(1)] = b[i];\\n        }\\n\\n        // No need for checked math since we are using it to compute indexes manually, always within boundaries\\n        for (uint256 i = 0; i < c.length; i = i.uncheckedAdd(1)) {\\n            result[b.length.uncheckedAdd(1).uncheckedAdd(i)] = c[i];\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-helpers/contracts/utils/Denominations.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Denominations\\n * @dev Provides a list of ground denominations for those tokens that cannot be represented by an ERC20.\\n * For now, the only needed is the native token that could be ETH, MATIC, or other depending on the layer being operated.\\n */\\nlibrary Denominations {\\n    address internal constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    // Fiat currencies follow https://en.wikipedia.org/wiki/ISO_4217\\n    address internal constant USD = address(840);\\n\\n    function isNativeToken(address token) internal pure returns (bool) {\\n        return token == NATIVE_TOKEN;\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-helpers/contracts/utils/ERC20Helpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\\n\\nimport './Denominations.sol';\\n\\n/**\\n * @title ERC20Helpers\\n * @dev Provides a list of ERC20 helper methods\\n */\\nlibrary ERC20Helpers {\\n    function approve(address token, address to, uint256 amount) internal {\\n        SafeERC20.safeApprove(IERC20(token), to, 0);\\n        SafeERC20.safeApprove(IERC20(token), to, amount);\\n    }\\n\\n    function transfer(address token, address to, uint256 amount) internal {\\n        if (Denominations.isNativeToken(token)) Address.sendValue(payable(to), amount);\\n        else SafeERC20.safeTransfer(IERC20(token), to, amount);\\n    }\\n\\n    function balanceOf(address token, address account) internal view returns (uint256) {\\n        if (Denominations.isNativeToken(token)) return address(account).balance;\\n        else return IERC20(token).balanceOf(address(account));\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-helpers/contracts/utils/IWrappedNativeToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\n/**\\n * @title IWrappedNativeToken\\n */\\ninterface IWrappedNativeToken is IERC20 {\\n    /**\\n     * @dev Wraps msg.value into the wrapped-native token\\n     */\\n    function deposit() external payable;\\n\\n    /**\\n     * @dev Unwraps requested amount to the native token\\n     */\\n    function withdraw(uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-price-oracle/contracts/feeds/IPriceFeedProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.8.0;\\n\\n/**\\n * @title IPriceFeedProvider\\n * @dev Contract providing price feed references for (base, quote) token pairs\\n */\\ninterface IPriceFeedProvider {\\n    /**\\n     * @dev Emitted every time a price feed is set for (base, quote) pair\\n     */\\n    event PriceFeedSet(address indexed base, address indexed quote, address feed);\\n\\n    /**\\n     * @dev Tells the price feed address for (base, quote) pair. It returns the zero address if there is no one set.\\n     * @param base Token to be rated\\n     * @param quote Token used for the price rate\\n     */\\n    function getPriceFeed(address base, address quote) external view returns (address);\\n\\n    /**\\n     * @dev Sets a of price feed\\n     * @param base Token base to be set\\n     * @param quote Token quote to be set\\n     * @param feed Price feed to be set\\n     */\\n    function setPriceFeed(address base, address quote, address feed) external;\\n\\n    /**\\n     * @dev Sets a list of price feeds\\n     * @param bases List of token bases to be set\\n     * @param quotes List of token quotes to be set\\n     * @param feeds List of price feeds to be set\\n     */\\n    function setPriceFeeds(address[] memory bases, address[] memory quotes, address[] memory feeds) external;\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-price-oracle/contracts/feeds/PriceFeedProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@mimic-fi/v2-helpers/contracts/math/UncheckedMath.sol';\\n\\nimport './IPriceFeedProvider.sol';\\n\\n/**\\n * @title IPriceFeedProvider\\n * @dev Contract providing price feed references for (base, quote) token pairs\\n */\\ncontract PriceFeedProvider is IPriceFeedProvider {\\n    using UncheckedMath for uint256;\\n\\n    // Mapping of price feeds from \\\"token A\\\" to \\\"token B\\\"\\n    mapping (address => mapping (address => address)) private _priceFeeds;\\n\\n    /**\\n     * @dev Tells the price feed address for (base, quote) pair. It returns the zero address if there is no one set.\\n     * @param base Token to be rated\\n     * @param quote Token used for the price rate\\n     */\\n    function getPriceFeed(address base, address quote) external view override returns (address) {\\n        return _priceFeeds[base][quote];\\n    }\\n\\n    /**\\n     * @dev Sets a of price feed\\n     * @param base Token base to be set\\n     * @param quote Token quote to be set\\n     * @param feed Price feed to be set\\n     */\\n    function setPriceFeed(address base, address quote, address feed) public virtual override {\\n        _priceFeeds[base][quote] = feed;\\n        emit PriceFeedSet(base, quote, feed);\\n    }\\n\\n    /**\\n     * @dev Sets a list of price feeds. Sender must be authorized.\\n     * @param bases List of token bases to be set\\n     * @param quotes List of token quotes to be set\\n     * @param feeds List of price feeds to be set\\n     */\\n    function setPriceFeeds(address[] memory bases, address[] memory quotes, address[] memory feeds)\\n        public\\n        virtual\\n        override\\n    {\\n        require(bases.length == quotes.length, 'SET_FEEDS_INVALID_QUOTES_LENGTH');\\n        require(bases.length == feeds.length, 'SET_FEEDS_INVALID_FEEDS_LENGTH');\\n        for (uint256 i = 0; i < bases.length; i = i.uncheckedAdd(1)) setPriceFeed(bases[i], quotes[i], feeds[i]);\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-price-oracle/contracts/oracle/IPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.8.0;\\n\\nimport '@mimic-fi/v2-registry/contracts/implementations/IImplementation.sol';\\n\\n/**\\n * @title IPriceOracle\\n * @dev Oracle that interfaces with external feeds to provide quotes for tokens based on any other token.\\n * It must support also `IImplementation`.\\n */\\ninterface IPriceOracle is IImplementation {\\n    /**\\n     * @dev Tells the price of a token (base) in a given quote. The response is expressed using the corresponding\\n     * number of decimals so that when performing a fixed point product of it by a `base` amount it results in\\n     * a value expressed in `quote` decimals. For example, if `base` is ETH and `quote` is USDC, then the returned\\n     * value is expected to be expressed using 6 decimals:\\n     *\\n     * FixedPoint.mul(X[ETH], price[USDC/ETH]) = FixedPoint.mul(X[18], price[6]) = X * price [6]\\n     *\\n     * @param provider Contract providing the price feeds to use by the oracle\\n     * @param base Token to rate\\n     * @param quote Token used for the price rate\\n     */\\n    function getPrice(address provider, address base, address quote) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-registry/contracts/implementations/BaseAuthorizedImplementation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@mimic-fi/v2-helpers/contracts/auth/Authorizer.sol';\\n\\nimport './BaseImplementation.sol';\\n\\n/**\\n * @title BaseAuthorizedImplementation\\n * @dev BaseImplementation using the Authorizer mixin. Base implementations that want to use the Authorizer\\n * permissions mechanism should inherit from this contract instead.\\n */\\nabstract contract BaseAuthorizedImplementation is BaseImplementation, Authorizer {\\n    /**\\n     * @dev Creates a new BaseAuthorizedImplementation\\n     * @param admin Address to be granted authorize and unauthorize permissions\\n     * @param registry Address of the Mimic Registry\\n     */\\n    constructor(address admin, address registry) BaseImplementation(registry) {\\n        _authorize(admin, Authorizer.authorize.selector);\\n        _authorize(admin, Authorizer.unauthorize.selector);\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-registry/contracts/implementations/BaseImplementation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/proxy/utils/Initializable.sol';\\n\\nimport './IImplementation.sol';\\nimport '../registry/IRegistry.sol';\\n\\n/**\\n * @title BaseImplementation\\n * @dev This implementation contract comes with an immutable reference to an implementations registry where it should\\n * be registered as well (checked during initialization). It allows requesting new instances of other registered\\n * implementations to as another safety check to make sure valid instances are referenced in case it's needed.\\n */\\nabstract contract BaseImplementation is IImplementation {\\n    // Immutable implementations registry reference\\n    address public immutable override registry;\\n\\n    /**\\n     * @dev Creates a new BaseImplementation\\n     * @param _registry Address of the Mimic Registry where dependencies will be validated against\\n     */\\n    constructor(address _registry) {\\n        registry = _registry;\\n    }\\n\\n    /**\\n     * @dev Internal function to validate a new dependency that must be registered as stateless.\\n     * It checks the new dependency is registered, not deprecated, and stateless.\\n     * @param dependency New stateless dependency to be set\\n     */\\n    function _validateStatelessDependency(address dependency) internal view {\\n        require(_validateDependency(dependency), 'DEPENDENCY_NOT_STATELESS');\\n    }\\n\\n    /**\\n     * @dev Internal function to validate a new dependency that cannot be registered as stateless.\\n     * It checks the new dependency is registered, not deprecated, and not stateful.\\n     * @param dependency New stateful dependency to be set\\n     */\\n    function _validateStatefulDependency(address dependency) internal view {\\n        require(!_validateDependency(dependency), 'DEPENDENCY_NOT_STATEFUL');\\n    }\\n\\n    /**\\n     * @dev Internal function to validate a new dependency. It checks the dependency is registered and not deprecated.\\n     * @param dependency New dependency to be set\\n     * @return Whether the dependency is stateless or not\\n     */\\n    function _validateDependency(address dependency) private view returns (bool) {\\n        (bool stateless, bool deprecated, bytes32 namespace) = IRegistry(registry).implementationData(dependency);\\n        require(namespace != bytes32(0), 'DEPENDENCY_NOT_REGISTERED');\\n        require(!deprecated, 'DEPENDENCY_DEPRECATED');\\n        return stateless;\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-registry/contracts/implementations/IImplementation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.8.0;\\n\\n// solhint-disable func-name-mixedcase\\n\\n/**\\n * @title IImplementation\\n * @dev Implementation interface that must be followed for implementations to be registered in the Mimic Registry\\n */\\ninterface IImplementation {\\n    /**\\n     * @dev Tells the namespace under which the implementation is registered in the Mimic Registry\\n     */\\n    function NAMESPACE() external view returns (bytes32);\\n\\n    /**\\n     * @dev Tells the address of the Mimic Registry\\n     */\\n    function registry() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-registry/contracts/implementations/InitializableAuthorizedImplementation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@mimic-fi/v2-helpers/contracts/auth/Authorizer.sol';\\n\\nimport './InitializableImplementation.sol';\\n\\n/**\\n * @title InitializableAuthorizedImplementation\\n * @dev InitializableImplementation using the Authorizer mixin. Initializable implementations that want to use the\\n * Authorizer permissions mechanism should inherit from this contract instead.\\n */\\nabstract contract InitializableAuthorizedImplementation is InitializableImplementation, Authorizer {\\n    /**\\n     * @dev Creates a new InitializableAuthorizedImplementation\\n     * @param registry Address of the Mimic Registry\\n     */\\n    constructor(address registry) InitializableImplementation(registry) {\\n        // solhint-disable-previous-line no-empty-blocks\\n    }\\n\\n    /**\\n     * @dev Initialization function that authorizes an admin account to authorize and unauthorize accounts.\\n     * Note this function can only be called from a function marked with the `initializer` modifier.\\n     * @param admin Address to be granted authorize and unauthorize permissions\\n     */\\n    function _initialize(address admin) internal onlyInitializing {\\n        _initialize();\\n        _authorize(admin, Authorizer.authorize.selector);\\n        _authorize(admin, Authorizer.unauthorize.selector);\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-registry/contracts/implementations/InitializableImplementation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/proxy/utils/Initializable.sol';\\n\\nimport './BaseImplementation.sol';\\n\\n/**\\n * @title InitializableImplementation\\n * @dev Implementation contract to be used through proxies. Inheriting contracts are meant to be initialized through\\n * initialization functions instead of constructor functions. It allows re-using the same logic contract while making\\n * deployments cheaper.\\n */\\nabstract contract InitializableImplementation is BaseImplementation, Initializable {\\n    /**\\n     * @dev Creates a new BaseImplementation. Note that initializers are disabled at creation time.\\n     */\\n    constructor(address registry) BaseImplementation(registry) {\\n        _disableInitializers();\\n    }\\n\\n    /**\\n     * @dev Initialization function.\\n     * Note this function can only be called from a function marked with the `initializer` modifier.\\n     */\\n    function _initialize() internal view onlyInitializing {\\n        // solhint-disable-previous-line no-empty-blocks\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-registry/contracts/registry/IRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.8.0;\\n\\nimport '@mimic-fi/v2-helpers/contracts/auth/IAuthorizer.sol';\\n\\n/**\\n * @title IRegistry\\n * @dev Registry interface, it must follow the IAuthorizer interface.\\n */\\ninterface IRegistry is IAuthorizer {\\n    /**\\n     * @dev Emitted every time a new implementation is registered\\n     */\\n    event Registered(bytes32 indexed namespace, address indexed implementation, bool stateless);\\n\\n    /**\\n     * @dev Emitted every time an implementation is deprecated\\n     */\\n    event Deprecated(bytes32 indexed namespace, address indexed implementation);\\n\\n    /**\\n     * @dev Tells the data of an implementation:\\n     * @param implementation Address of the implementation to request it's data\\n     */\\n    function implementationData(address implementation)\\n        external\\n        view\\n        returns (bool stateless, bool deprecated, bytes32 namespace);\\n\\n    /**\\n     * @dev Tells if a specific implementation is registered under a certain namespace and it's not deprecated\\n     * @param namespace Namespace asking for\\n     * @param implementation Address of the implementation to be checked\\n     */\\n    function isActive(bytes32 namespace, address implementation) external view returns (bool);\\n\\n    /**\\n     * @dev Registers a new implementation for a given namespace\\n     * @param namespace Namespace to be used for the implementation\\n     * @param implementation Address of the implementation to be registered\\n     * @param stateless Whether the implementation is stateless or not\\n     */\\n    function register(bytes32 namespace, address implementation, bool stateless) external;\\n\\n    /**\\n     * @dev Deprecates a registered implementation\\n     * @param implementation Address of the implementation to be deprecated\\n     */\\n    function deprecate(address implementation) external;\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-smart-vault/contracts/helpers/BridgeConnectorLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/utils/Address.sol';\\n\\nimport '@mimic-fi/v2-bridge-connector/contracts/IBridgeConnector.sol';\\n\\n/**\\n * @title BridgeConnectorLib\\n * @dev Library used to delegate-call bridge ops and decode return data correctly\\n */\\nlibrary BridgeConnectorLib {\\n    /**\\n     * @dev Delegate-calls a bridge to the bridge connector and decodes de expected data\\n     * IMPORTANT! This helper method does not check any of the given params, these should be checked beforehand.\\n     */\\n    function bridge(\\n        address connector,\\n        uint8 source,\\n        uint256 chainId,\\n        address token,\\n        uint256 amountIn,\\n        uint256 minAmountOut,\\n        address recipient,\\n        bytes memory data\\n    ) internal {\\n        bytes memory bridgeData = abi.encodeWithSelector(\\n            IBridgeConnector.bridge.selector,\\n            source,\\n            chainId,\\n            token,\\n            amountIn,\\n            minAmountOut,\\n            recipient,\\n            data\\n        );\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = connector.delegatecall(bridgeData);\\n        Address.verifyCallResult(success, returndata, 'BRIDGE_CALL_REVERTED');\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-smart-vault/contracts/helpers/StrategyLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/utils/Address.sol';\\n\\nimport '@mimic-fi/v2-strategies/contracts/IStrategy.sol';\\n\\n/**\\n * @title StrategyLib\\n * @dev Library used to delegate-call to strategy and decode return data correctly\\n */\\nlibrary StrategyLib {\\n    /**\\n     * @dev Delegate-calls a claim to a strategy and decodes de expected data\\n     * IMPORTANT! This helper method does not check any of the given params, these should be checked beforehand.\\n     */\\n    function claim(address strategy, bytes memory data) internal returns (address[] memory, uint256[] memory) {\\n        bytes memory claimData = abi.encodeWithSelector(IStrategy.claim.selector, data);\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = strategy.delegatecall(claimData);\\n        Address.verifyCallResult(success, returndata, 'CLAIM_CALL_REVERTED');\\n        return abi.decode(returndata, (address[], uint256[]));\\n    }\\n\\n    /**\\n     * @dev Delegate-calls a join to a strategy and decodes de expected data\\n     * IMPORTANT! This helper method does not check any of the given params, these should be checked beforehand.\\n     */\\n    function join(\\n        address strategy,\\n        address[] memory tokensIn,\\n        uint256[] memory amountsIn,\\n        uint256 slippage,\\n        bytes memory data\\n    ) internal returns (address[] memory tokensOut, uint256[] memory amountsOut, uint256 value) {\\n        bytes memory joinData = abi.encodeWithSelector(IStrategy.join.selector, tokensIn, amountsIn, slippage, data);\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = strategy.delegatecall(joinData);\\n        Address.verifyCallResult(success, returndata, 'JOIN_CALL_REVERTED');\\n        return abi.decode(returndata, (address[], uint256[], uint256));\\n    }\\n\\n    /**\\n     * @dev Delegate-calls a exit to a strategy and decodes de expected data\\n     * IMPORTANT! This helper method does not check any of the given params, these should be checked beforehand.\\n     */\\n    function exit(\\n        address strategy,\\n        address[] memory tokensIn,\\n        uint256[] memory amountsIn,\\n        uint256 slippage,\\n        bytes memory data\\n    ) internal returns (address[] memory tokensOut, uint256[] memory amountsOut, uint256 value) {\\n        bytes memory exitData = abi.encodeWithSelector(IStrategy.exit.selector, tokensIn, amountsIn, slippage, data);\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = strategy.delegatecall(exitData);\\n        Address.verifyCallResult(success, returndata, 'EXIT_CALL_REVERTED');\\n        return abi.decode(returndata, (address[], uint256[], uint256));\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-smart-vault/contracts/helpers/SwapConnectorLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/utils/Address.sol';\\n\\nimport '@mimic-fi/v2-swap-connector/contracts/ISwapConnector.sol';\\n\\n/**\\n * @title SwapConnectorLib\\n * @dev Library used to delegate-call swaps and decode return data correctly\\n */\\nlibrary SwapConnectorLib {\\n    /**\\n     * @dev Delegate-calls a swap to the swap connector and decodes de expected data\\n     * IMPORTANT! This helper method does not check any of the given params, these should be checked beforehand.\\n     */\\n    function swap(\\n        address connector,\\n        uint8 source,\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 amountIn,\\n        uint256 minAmountOut,\\n        bytes memory data\\n    ) internal returns (uint256 amountOut) {\\n        bytes memory swapData = abi.encodeWithSelector(\\n            ISwapConnector.swap.selector,\\n            source,\\n            tokenIn,\\n            tokenOut,\\n            amountIn,\\n            minAmountOut,\\n            data\\n        );\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = connector.delegatecall(swapData);\\n        Address.verifyCallResult(success, returndata, 'SWAP_CALL_REVERTED');\\n        return abi.decode(returndata, (uint256));\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-smart-vault/contracts/ISmartVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@mimic-fi/v2-helpers/contracts/auth/IAuthorizer.sol';\\nimport '@mimic-fi/v2-price-oracle/contracts/feeds/IPriceFeedProvider.sol';\\nimport '@mimic-fi/v2-registry/contracts/implementations/IImplementation.sol';\\n\\n/**\\n * @title ISmartVault\\n * @dev Mimic Smart Vault interface to manage assets. It must support also `IImplementation` and `IAuthorizer`\\n */\\ninterface ISmartVault is IPriceFeedProvider, IImplementation, IAuthorizer {\\n    enum SwapLimit {\\n        Slippage,\\n        MinAmountOut\\n    }\\n\\n    enum BridgeLimit {\\n        Slippage,\\n        MinAmountOut\\n    }\\n\\n    /**\\n     * @dev Emitted every time a new strategy is set for the Smart Vault\\n     */\\n    event StrategySet(address indexed strategy, bool allowed);\\n\\n    /**\\n     * @dev Emitted every time a new price oracle is set for the Smart Vault\\n     */\\n    event PriceOracleSet(address indexed priceOracle);\\n\\n    /**\\n     * @dev Emitted every time a new swap connector is set for the Smart Vault\\n     */\\n    event SwapConnectorSet(address indexed swapConnector);\\n\\n    /**\\n     * @dev Emitted every time a new bridge connector is set for the Smart Vault\\n     */\\n    event BridgeConnectorSet(address indexed bridgeConnector);\\n\\n    /**\\n     * @dev Emitted every time a new fee collector is set\\n     */\\n    event FeeCollectorSet(address indexed feeCollector);\\n\\n    /**\\n     * @dev Emitted every time the withdraw fee percentage is set\\n     */\\n    event WithdrawFeeSet(uint256 pct, uint256 cap, address token, uint256 period);\\n\\n    /**\\n     * @dev Emitted every time the performance fee percentage is set\\n     */\\n    event PerformanceFeeSet(uint256 pct, uint256 cap, address token, uint256 period);\\n\\n    /**\\n     * @dev Emitted every time the swap fee percentage is set\\n     */\\n    event SwapFeeSet(uint256 pct, uint256 cap, address token, uint256 period);\\n\\n    /**\\n     * @dev Emitted every time the bridge fee percentage is set\\n     */\\n    event BridgeFeeSet(uint256 pct, uint256 cap, address token, uint256 period);\\n\\n    /**\\n     * @dev Emitted every time `call` is called\\n     */\\n    event Call(address indexed target, bytes callData, uint256 value, bytes result, bytes data);\\n\\n    /**\\n     * @dev Emitted every time `collect` is called\\n     */\\n    event Collect(address indexed token, address indexed from, uint256 collected, bytes data);\\n\\n    /**\\n     * @dev Emitted every time `withdraw` is called\\n     */\\n    event Withdraw(address indexed token, address indexed recipient, uint256 withdrawn, uint256 fee, bytes data);\\n\\n    /**\\n     * @dev Emitted every time `wrap` is called\\n     */\\n    event Wrap(uint256 amount, uint256 wrapped, bytes data);\\n\\n    /**\\n     * @dev Emitted every time `unwrap` is called\\n     */\\n    event Unwrap(uint256 amount, uint256 unwrapped, bytes data);\\n\\n    /**\\n     * @dev Emitted every time `claim` is called\\n     */\\n    event Claim(address indexed strategy, address[] tokens, uint256[] amounts, bytes data);\\n\\n    /**\\n     * @dev Emitted every time `join` is called\\n     */\\n    event Join(\\n        address indexed strategy,\\n        address[] tokensIn,\\n        uint256[] amountsIn,\\n        address[] tokensOut,\\n        uint256[] amountsOut,\\n        uint256 value,\\n        uint256 slippage,\\n        bytes data\\n    );\\n\\n    /**\\n     * @dev Emitted every time `exit` is called\\n     */\\n    event Exit(\\n        address indexed strategy,\\n        address[] tokensIn,\\n        uint256[] amountsIn,\\n        address[] tokensOut,\\n        uint256[] amountsOut,\\n        uint256 value,\\n        uint256[] fees,\\n        uint256 slippage,\\n        bytes data\\n    );\\n\\n    /**\\n     * @dev Emitted every time `swap` is called\\n     */\\n    event Swap(\\n        uint8 indexed source,\\n        address indexed tokenIn,\\n        address indexed tokenOut,\\n        uint256 amountIn,\\n        uint256 amountOut,\\n        uint256 minAmountOut,\\n        uint256 fee,\\n        bytes data\\n    );\\n\\n    /**\\n     * @dev Emitted every time `bridge` is called\\n     */\\n    event Bridge(\\n        uint8 indexed source,\\n        uint256 indexed chainId,\\n        address indexed token,\\n        uint256 amountIn,\\n        uint256 minAmountOut,\\n        uint256 fee,\\n        address recipient,\\n        bytes data\\n    );\\n\\n    /**\\n     * @dev Tells a strategy is allowed or not\\n     * @param strategy Address of the strategy being queried\\n     */\\n    function isStrategyAllowed(address strategy) external view returns (bool);\\n\\n    /**\\n     * @dev Tells the invested value for a strategy\\n     * @param strategy Address of the strategy querying the invested value of\\n     */\\n    function investedValue(address strategy) external view returns (uint256);\\n\\n    /**\\n     * @dev Tells the last value accrued for a strategy. Note this value can be outdated.\\n     * @param strategy Address of the strategy querying the last value of\\n     */\\n    function lastValue(address strategy) external view returns (uint256);\\n\\n    /**\\n     * @dev Tells the price oracle associated to a Smart Vault\\n     */\\n    function priceOracle() external view returns (address);\\n\\n    /**\\n     * @dev Tells the swap connector associated to a Smart Vault\\n     */\\n    function swapConnector() external view returns (address);\\n\\n    /**\\n     * @dev Tells the bridge connector associated to a Smart Vault\\n     */\\n    function bridgeConnector() external view returns (address);\\n\\n    /**\\n     * @dev Tells the address where fees will be deposited\\n     */\\n    function feeCollector() external view returns (address);\\n\\n    /**\\n     * @dev Tells the withdraw fee configuration\\n     */\\n    function withdrawFee()\\n        external\\n        view\\n        returns (uint256 pct, uint256 cap, address token, uint256 period, uint256 totalCharged, uint256 nextResetTime);\\n\\n    /**\\n     * @dev Tells the performance fee configuration\\n     */\\n    function performanceFee()\\n        external\\n        view\\n        returns (uint256 pct, uint256 cap, address token, uint256 period, uint256 totalCharged, uint256 nextResetTime);\\n\\n    /**\\n     * @dev Tells the swap fee configuration\\n     */\\n    function swapFee()\\n        external\\n        view\\n        returns (uint256 pct, uint256 cap, address token, uint256 period, uint256 totalCharged, uint256 nextResetTime);\\n\\n    /**\\n     * @dev Tells the bridge fee configuration\\n     */\\n    function bridgeFee()\\n        external\\n        view\\n        returns (uint256 pct, uint256 cap, address token, uint256 period, uint256 totalCharged, uint256 nextResetTime);\\n\\n    /**\\n     * @dev Tells the address of the wrapped native token\\n     */\\n    function wrappedNativeToken() external view returns (address);\\n\\n    /**\\n     * @dev Sets a new strategy as allowed or not for a Smart Vault\\n     * @param strategy Address of the strategy to be set\\n     * @param allowed Whether the strategy is allowed or not\\n     */\\n    function setStrategy(address strategy, bool allowed) external;\\n\\n    /**\\n     * @dev Sets a new price oracle to a Smart Vault\\n     * @param newPriceOracle Address of the new price oracle to be set\\n     */\\n    function setPriceOracle(address newPriceOracle) external;\\n\\n    /**\\n     * @dev Sets a new swap connector to a Smart Vault\\n     * @param newSwapConnector Address of the new swap connector to be set\\n     */\\n    function setSwapConnector(address newSwapConnector) external;\\n\\n    /**\\n     * @dev Sets a new bridge connector to a Smart Vault\\n     * @param newBridgeConnector Address of the new bridge connector to be set\\n     */\\n    function setBridgeConnector(address newBridgeConnector) external;\\n\\n    /**\\n     * @dev Sets a new fee collector\\n     * @param newFeeCollector Address of the new fee collector to be set\\n     */\\n    function setFeeCollector(address newFeeCollector) external;\\n\\n    /**\\n     * @dev Sets a new withdraw fee configuration\\n     * @param pct Withdraw fee percentage to be set\\n     * @param cap New maximum amount of withdraw fees to be charged per period\\n     * @param token Address of the token cap to be set\\n     * @param period New cap period length in seconds for the withdraw fee\\n     */\\n    function setWithdrawFee(uint256 pct, uint256 cap, address token, uint256 period) external;\\n\\n    /**\\n     * @dev Sets a new performance fee configuration\\n     * @param pct Performance fee percentage to be set\\n     * @param cap New maximum amount of performance fees to be charged per period\\n     * @param token Address of the token cap to be set\\n     * @param period New cap period length in seconds for the performance fee\\n     */\\n    function setPerformanceFee(uint256 pct, uint256 cap, address token, uint256 period) external;\\n\\n    /**\\n     * @dev Sets a new swap fee configuration\\n     * @param pct Swap fee percentage to be set\\n     * @param cap New maximum amount of swap fees to be charged per period\\n     * @param token Address of the token cap to be set\\n     * @param period New cap period length in seconds for the swap fee\\n     */\\n    function setSwapFee(uint256 pct, uint256 cap, address token, uint256 period) external;\\n\\n    /**\\n     * @dev Sets a new bridge fee configuration\\n     * @param pct Bridge fee percentage to be set\\n     * @param cap New maximum amount of bridge fees to be charged per period\\n     * @param token Address of the token cap to be set\\n     * @param period New cap period length in seconds for the bridge fee\\n     */\\n    function setBridgeFee(uint256 pct, uint256 cap, address token, uint256 period) external;\\n\\n    /**\\n     * @dev Tells the price of a token (base) in a given quote\\n     * @param base Token to rate\\n     * @param quote Token used for the price rate\\n     */\\n    function getPrice(address base, address quote) external view returns (uint256);\\n\\n    /**\\n     * @dev Execute an arbitrary call from a Smart Vault\\n     * @param target Address where the call will be sent\\n     * @param callData Calldata to be used for the call\\n     * @param value Value in wei that will be attached to the call\\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\\n     * @return result Call response if it was successful, otherwise it reverts\\n     */\\n    function call(address target, bytes memory callData, uint256 value, bytes memory data)\\n        external\\n        returns (bytes memory result);\\n\\n    /**\\n     * @dev Collect tokens from a sender to a Smart Vault\\n     * @param token Address of the token to be collected\\n     * @param from Address where the tokens will be transfer from\\n     * @param amount Amount of tokens to be transferred\\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\\n     * @return collected Amount of tokens assigned to the Smart Vault\\n     */\\n    function collect(address token, address from, uint256 amount, bytes memory data)\\n        external\\n        returns (uint256 collected);\\n\\n    /**\\n     * @dev Withdraw tokens to an external account\\n     * @param token Address of the token to be withdrawn\\n     * @param amount Amount of tokens to withdraw\\n     * @param recipient Address where the tokens will be transferred to\\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\\n     * @return withdrawn Amount of tokens transferred to the recipient address\\n     */\\n    function withdraw(address token, uint256 amount, address recipient, bytes memory data)\\n        external\\n        returns (uint256 withdrawn);\\n\\n    /**\\n     * @dev Wrap an amount of native tokens to the wrapped ERC20 version of it\\n     * @param amount Amount of native tokens to be wrapped\\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\\n     * @return wrapped Amount of tokens wrapped\\n     */\\n    function wrap(uint256 amount, bytes memory data) external returns (uint256 wrapped);\\n\\n    /**\\n     * @dev Unwrap an amount of wrapped native tokens\\n     * @param amount Amount of wrapped native tokens to unwrapped\\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\\n     * @return unwrapped Amount of tokens unwrapped\\n     */\\n    function unwrap(uint256 amount, bytes memory data) external returns (uint256 unwrapped);\\n\\n    /**\\n     * @dev Claim strategy rewards\\n     * @param strategy Address of the strategy to claim rewards\\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\\n     * @return tokens Addresses of the tokens received as rewards\\n     * @return amounts Amounts of the tokens received as rewards\\n     */\\n    function claim(address strategy, bytes memory data)\\n        external\\n        returns (address[] memory tokens, uint256[] memory amounts);\\n\\n    /**\\n     * @dev Join a strategy with an amount of tokens\\n     * @param strategy Address of the strategy to join\\n     * @param tokensIn List of token addresses to join with\\n     * @param amountsIn List of token amounts to join with\\n     * @param slippage Slippage that will be used to compute the join\\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\\n     * @return tokensOut List of token addresses received after the join\\n     * @return amountsOut List of token amounts received after the join\\n     */\\n    function join(\\n        address strategy,\\n        address[] memory tokensIn,\\n        uint256[] memory amountsIn,\\n        uint256 slippage,\\n        bytes memory data\\n    ) external returns (address[] memory tokensOut, uint256[] memory amountsOut);\\n\\n    /**\\n     * @dev Exit a strategy\\n     * @param strategy Address of the strategy to exit\\n     * @param tokensIn List of token addresses to exit with\\n     * @param amountsIn List of token amounts to exit with\\n     * @param slippage Slippage that will be used to compute the exit\\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\\n     * @return tokensOut List of token addresses received after the exit\\n     * @return amountsOut List of token amounts received after the exit\\n     */\\n    function exit(\\n        address strategy,\\n        address[] memory tokensIn,\\n        uint256[] memory amountsIn,\\n        uint256 slippage,\\n        bytes memory data\\n    ) external returns (address[] memory tokensOut, uint256[] memory amountsOut);\\n\\n    /**\\n     * @dev Swaps two tokens\\n     * @param source Source to request the swap. It depends on the Swap Connector attached to a Smart Vault.\\n     * @param tokenIn Token being sent\\n     * @param tokenOut Token being received\\n     * @param amountIn Amount of tokenIn being swapped\\n     * @param limitType Swap limit to be applied: slippage or min amount out\\n     * @param limitAmount Amount of the swap limit to be applied depending on limitType\\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\\n     * @return amountOut Received amount of tokens out\\n     */\\n    function swap(\\n        uint8 source,\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 amountIn,\\n        SwapLimit limitType,\\n        uint256 limitAmount,\\n        bytes memory data\\n    ) external returns (uint256 amountOut);\\n\\n    /**\\n     * @dev Bridge assets to another chain\\n     * @param source Source to request the bridge. It depends on the Bridge Connector attached to a Smart Vault.\\n     * @param chainId ID of the destination chain\\n     * @param token Address of the token to be bridged\\n     * @param amount Amount of tokens to be bridged\\n     * @param limitType Swap limit to be applied: slippage or min amount out\\n     * @param limitAmount Amount of the swap limit to be applied depending on limitType\\n     * @param recipient Address that will receive the tokens on the destination chain\\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\\n     * @return bridged Amount requested to be bridged after fees\\n     */\\n    function bridge(\\n        uint8 source,\\n        uint256 chainId,\\n        address token,\\n        uint256 amount,\\n        BridgeLimit limitType,\\n        uint256 limitAmount,\\n        address recipient,\\n        bytes memory data\\n    ) external returns (uint256 bridged);\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-smart-vault/contracts/ISmartVaultsFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.8.0;\\n\\nimport '@mimic-fi/v2-registry/contracts/implementations/IImplementation.sol';\\n\\n/**\\n * @title ISmartVaultsFactory\\n * @dev Smart Vaults Factory interface, it must follow the IImplementation interface.\\n */\\ninterface ISmartVaultsFactory is IImplementation {\\n    /**\\n     * @dev Emitted every time a new Smart Vault instance is created\\n     */\\n    event Created(address indexed implementation, address indexed instance, bytes initializeResult);\\n\\n    /**\\n     * @dev Tells the implementation associated to a contract instance\\n     * @param instance Address of the instance to request it's implementation\\n     */\\n    function implementationOf(address instance) external view returns (address);\\n\\n    /**\\n     * @dev Creates a new Smart Vault pointing to a registered implementation\\n     * @param salt Salt bytes to derivate the address of the new instance\\n     * @param implementation Address of the implementation to be instanced\\n     * @param initializeData Arbitrary data to be sent after deployment\\n     * @return instance Address of the new instance created\\n     */\\n    function create(bytes32 salt, address implementation, bytes memory initializeData) external returns (address);\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-smart-vault/contracts/SmartVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\\nimport '@openzeppelin/contracts/utils/Address.sol';\\nimport '@openzeppelin/contracts/utils/math/Math.sol';\\n\\nimport '@mimic-fi/v2-bridge-connector/contracts/IBridgeConnector.sol';\\nimport '@mimic-fi/v2-helpers/contracts/math/FixedPoint.sol';\\nimport '@mimic-fi/v2-helpers/contracts/math/UncheckedMath.sol';\\nimport '@mimic-fi/v2-helpers/contracts/utils/Denominations.sol';\\nimport '@mimic-fi/v2-helpers/contracts/utils/IWrappedNativeToken.sol';\\nimport '@mimic-fi/v2-price-oracle/contracts/oracle/IPriceOracle.sol';\\nimport '@mimic-fi/v2-price-oracle/contracts/feeds/PriceFeedProvider.sol';\\nimport '@mimic-fi/v2-strategies/contracts/IStrategy.sol';\\nimport '@mimic-fi/v2-swap-connector/contracts/ISwapConnector.sol';\\nimport '@mimic-fi/v2-registry/contracts/implementations/InitializableAuthorizedImplementation.sol';\\n\\nimport './ISmartVault.sol';\\nimport './helpers/StrategyLib.sol';\\nimport './helpers/SwapConnectorLib.sol';\\nimport './helpers/BridgeConnectorLib.sol';\\n\\n/**\\n * @title Smart Vault\\n * @dev Smart Vault contract where funds are being held offering a bunch of primitives to allow users model any\\n * type of action to manage them, these are: collector, withdraw, swap, bridge, join, exit, bridge, wrap, and unwrap.\\n *\\n * It inherits from InitializableAuthorizedImplementation which means it's implementation can be cloned\\n * from the Mimic Registry and should be initialized depending on each case.\\n */\\ncontract SmartVault is ISmartVault, PriceFeedProvider, InitializableAuthorizedImplementation {\\n    using SafeERC20 for IERC20;\\n    using FixedPoint for uint256;\\n    using UncheckedMath for uint256;\\n    using StrategyLib for address;\\n    using SwapConnectorLib for address;\\n    using BridgeConnectorLib for address;\\n\\n    // Namespace under which the Smart Vault is registered in the Mimic Registry\\n    bytes32 public constant override NAMESPACE = keccak256('SMART_VAULT');\\n\\n    /**\\n     * @dev Fee configuration parameters\\n     * @param pct Percentage expressed using 16 decimals (1e18 = 100%)\\n     * @param cap Maximum amount of fees to be charged per period\\n     * @param token Address of the token to express the cap amount\\n     * @param period Period length in seconds\\n     * @param totalCharged Total amount of fees charged in the current period\\n     * @param nextResetTime Current cap period end date\\n     */\\n    struct Fee {\\n        uint256 pct;\\n        uint256 cap;\\n        address token;\\n        uint256 period;\\n        uint256 totalCharged;\\n        uint256 nextResetTime;\\n    }\\n\\n    // Price oracle reference\\n    address public override priceOracle;\\n\\n    // Swap connector reference\\n    address public override swapConnector;\\n\\n    // Bridge connector reference\\n    address public override bridgeConnector;\\n\\n    // List of allowed strategies indexed by strategy address\\n    mapping (address => bool) public override isStrategyAllowed;\\n\\n    // List of invested values indexed by strategy address\\n    mapping (address => uint256) public override investedValue;\\n\\n    // Fee collector address where fees will be deposited\\n    address public override feeCollector;\\n\\n    // Withdraw fee configuration\\n    Fee public override withdrawFee;\\n\\n    // Performance fee configuration\\n    Fee public override performanceFee;\\n\\n    // Swap fee configuration\\n    Fee public override swapFee;\\n\\n    // Bridge fee configuration\\n    Fee public override bridgeFee;\\n\\n    // Wrapped native token reference\\n    address public immutable override wrappedNativeToken;\\n\\n    /**\\n     * @dev Creates a new Smart Vault implementation with references that should be shared among all implementations\\n     * @param _wrappedNativeToken Address of the wrapped native token to be used\\n     * @param _registry Address of the Mimic Registry to be referenced\\n     */\\n    constructor(address _wrappedNativeToken, address _registry) InitializableAuthorizedImplementation(_registry) {\\n        wrappedNativeToken = _wrappedNativeToken;\\n    }\\n\\n    /**\\n     * @dev Initializes the Smart Vault instance\\n     * @param admin Address that will be granted with admin rights\\n     */\\n    function initialize(address admin) external initializer {\\n        _initialize(admin);\\n    }\\n\\n    /**\\n     * @dev It allows receiving native token transfers\\n     */\\n    receive() external payable {\\n        // solhint-disable-previous-line no-empty-blocks\\n    }\\n\\n    /**\\n     * @dev Sets a new strategy as allowed or not for a Smart Vault. Sender must be authorized.\\n     * @param strategy Address of the strategy to be set\\n     * @param allowed Whether the strategy is allowed or not\\n     */\\n    function setStrategy(address strategy, bool allowed) external override auth {\\n        _setStrategy(strategy, allowed);\\n    }\\n\\n    /**\\n     * @dev Sets a new price oracle to a Smart Vault. Sender must be authorized.\\n     * @param newPriceOracle Address of the new price oracle to be set\\n     */\\n    function setPriceOracle(address newPriceOracle) external override auth {\\n        _setPriceOracle(newPriceOracle);\\n    }\\n\\n    /**\\n     * @dev Sets a new swap connector to a Smart Vault. Sender must be authorized.\\n     * @param newSwapConnector Address of the new swap connector to be set\\n     */\\n    function setSwapConnector(address newSwapConnector) external override auth {\\n        _setSwapConnector(newSwapConnector);\\n    }\\n\\n    /**\\n     * @dev Sets a new bridge connector to a Smart Vault. Sender must be authorized.\\n     * @param newBridgeConnector Address of the new bridge connector to be set\\n     */\\n    function setBridgeConnector(address newBridgeConnector) external override auth {\\n        _setBridgeConnector(newBridgeConnector);\\n    }\\n\\n    /**\\n     * @dev Sets a new fee collector. Sender must be authorized.\\n     * @param newFeeCollector Address of the new fee collector to be set\\n     */\\n    function setFeeCollector(address newFeeCollector) external override auth {\\n        _setFeeCollector(newFeeCollector);\\n    }\\n\\n    /**\\n     * @dev Sets a new withdraw fee. Sender must be authorized.\\n     * @param pct Withdraw fee percentage to be set\\n     * @param cap New maximum amount of withdraw fees to be charged per period\\n     * @param token Address of the token cap to be set\\n     * @param period New cap period length in seconds for the withdraw fee\\n     */\\n    function setWithdrawFee(uint256 pct, uint256 cap, address token, uint256 period) external override auth {\\n        _setFeeConfiguration(withdrawFee, pct, cap, token, period);\\n        emit WithdrawFeeSet(pct, cap, token, period);\\n    }\\n\\n    /**\\n     * @dev Sets a new performance fee. Sender must be authorized.\\n     * @param pct Performance fee percentage to be set\\n     * @param cap New maximum amount of performance fees to be charged per period\\n     * @param token Address of the token cap to be set\\n     * @param period New cap period length in seconds for the performance fee\\n     */\\n    function setPerformanceFee(uint256 pct, uint256 cap, address token, uint256 period) external override auth {\\n        _setFeeConfiguration(performanceFee, pct, cap, token, period);\\n        emit PerformanceFeeSet(pct, cap, token, period);\\n    }\\n\\n    /**\\n     * @dev Sets a new swap fee. Sender must be authorized.\\n     * @param pct New swap fee percentage to be set\\n     * @param cap New maximum amount of swap fees to be charged per period\\n     * @param token Address of the token cap to be set\\n     * @param period New cap period length in seconds for the swap fee\\n     */\\n    function setSwapFee(uint256 pct, uint256 cap, address token, uint256 period) external override auth {\\n        _setFeeConfiguration(swapFee, pct, cap, token, period);\\n        emit SwapFeeSet(pct, cap, token, period);\\n    }\\n\\n    /**\\n     * @dev Sets a new bridge fee. Sender must be authorized.\\n     * @param pct New bridge fee percentage to be set\\n     * @param cap New maximum amount of bridge fees to be charged per period\\n     * @param token Address of the token cap to be set\\n     * @param period New cap period length in seconds for the bridge fee\\n     */\\n    function setBridgeFee(uint256 pct, uint256 cap, address token, uint256 period) external override auth {\\n        _setFeeConfiguration(bridgeFee, pct, cap, token, period);\\n        emit BridgeFeeSet(pct, cap, token, period);\\n    }\\n\\n    /**\\n     * @dev Sets a of price feed\\n     * @param base Token base to be set\\n     * @param quote Token quote to be set\\n     * @param feed Price feed to be set\\n     */\\n    function setPriceFeed(address base, address quote, address feed)\\n        public\\n        override(IPriceFeedProvider, PriceFeedProvider)\\n        auth\\n    {\\n        super.setPriceFeed(base, quote, feed);\\n    }\\n\\n    /**\\n     * @dev Tells the price of a token (base) in a given quote\\n     * @param base Token to rate\\n     * @param quote Token used for the price rate\\n     */\\n    function getPrice(address base, address quote) public view override returns (uint256) {\\n        return IPriceOracle(priceOracle).getPrice(address(this), base, quote);\\n    }\\n\\n    /**\\n     * @dev Tells the last value accrued for a strategy. Note this value can be outdated.\\n     * @param strategy Address of the strategy querying the last value of\\n     */\\n    function lastValue(address strategy) public view override returns (uint256) {\\n        return IStrategy(strategy).lastValue(address(this));\\n    }\\n\\n    /**\\n     * @dev Execute an arbitrary call from a Smart Vault. Sender must be authorized.\\n     * @param target Address where the call will be sent\\n     * @param data Calldata to be used for the call\\n     * @param value Value in wei that will be attached to the call\\n     * @return result Call response if it was successful, otherwise it reverts\\n     */\\n    function call(address target, bytes memory callData, uint256 value, bytes memory data)\\n        external\\n        override\\n        auth\\n        returns (bytes memory result)\\n    {\\n        result = Address.functionCallWithValue(target, callData, value, 'SMART_VAULT_ARBITRARY_CALL_FAIL');\\n        emit Call(target, callData, value, result, data);\\n    }\\n\\n    /**\\n     * @dev Collect tokens from an external account to a Smart Vault. Sender must be authorized.\\n     * @param token Address of the token to be collected\\n     * @param from Address where the tokens will be transfer from\\n     * @param amount Amount of tokens to be transferred\\n     * @param data Extra data only logged\\n     * @return collected Amount of tokens collected\\n     */\\n    function collect(address token, address from, uint256 amount, bytes memory data)\\n        external\\n        override\\n        auth\\n        returns (uint256 collected)\\n    {\\n        require(amount > 0, 'COLLECT_AMOUNT_ZERO');\\n\\n        uint256 previousBalance = IERC20(token).balanceOf(address(this));\\n        IERC20(token).safeTransferFrom(from, address(this), amount);\\n        uint256 currentBalance = IERC20(token).balanceOf(address(this));\\n\\n        collected = currentBalance - previousBalance;\\n        emit Collect(token, from, collected, data);\\n    }\\n\\n    /**\\n     * @dev Withdraw tokens to an external account. Sender must be authorized.\\n     * @param token Address of the token to be withdrawn\\n     * @param amount Amount of tokens to withdraw\\n     * @param recipient Address where the tokens will be transferred to\\n     * @param data Extra data only logged\\n     * @return withdrawn Amount of tokens transferred to the recipient address\\n     */\\n    function withdraw(address token, uint256 amount, address recipient, bytes memory data)\\n        external\\n        override\\n        auth\\n        returns (uint256 withdrawn)\\n    {\\n        require(amount > 0, 'WITHDRAW_AMOUNT_ZERO');\\n        require(recipient != address(0), 'RECIPIENT_ZERO');\\n\\n        uint256 withdrawFeeAmount = recipient == feeCollector ? 0 : _payFee(token, amount, withdrawFee);\\n        withdrawn = amount - withdrawFeeAmount;\\n        _safeTransfer(token, recipient, withdrawn);\\n        emit Withdraw(token, recipient, withdrawn, withdrawFeeAmount, data);\\n    }\\n\\n    /**\\n     * @dev Wrap an amount of native tokens to the wrapped ERC20 version of it. Sender must be authorized.\\n     * @param amount Amount of native tokens to be wrapped\\n     * @param data Extra data only logged\\n     * @return wrapped Amount of tokens wrapped\\n     */\\n    function wrap(uint256 amount, bytes memory data) external override auth returns (uint256 wrapped) {\\n        require(amount > 0, 'WRAP_AMOUNT_ZERO');\\n        require(address(this).balance >= amount, 'WRAP_INSUFFICIENT_AMOUNT');\\n\\n        IWrappedNativeToken wrappedToken = IWrappedNativeToken(wrappedNativeToken);\\n        uint256 previousBalance = wrappedToken.balanceOf(address(this));\\n        wrappedToken.deposit{ value: amount }();\\n        uint256 currentBalance = wrappedToken.balanceOf(address(this));\\n\\n        wrapped = currentBalance - previousBalance;\\n        emit Wrap(amount, wrapped, data);\\n    }\\n\\n    /**\\n     * @dev Unwrap an amount of wrapped native tokens. Sender must be authorized.\\n     * @param amount Amount of wrapped native tokens to unwrapped\\n     * @param data Extra data only logged\\n     * @return unwrapped Amount of tokens unwrapped\\n     */\\n    function unwrap(uint256 amount, bytes memory data) external override auth returns (uint256 unwrapped) {\\n        require(amount > 0, 'UNWRAP_AMOUNT_ZERO');\\n\\n        uint256 previousBalance = address(this).balance;\\n        IWrappedNativeToken(wrappedNativeToken).withdraw(amount);\\n        uint256 currentBalance = address(this).balance;\\n\\n        unwrapped = currentBalance - previousBalance;\\n        emit Unwrap(amount, unwrapped, data);\\n    }\\n\\n    /**\\n     * @dev Claim strategy rewards. Sender must be authorized.\\n     * @param strategy Address of the strategy to claim rewards\\n     * @param data Extra data passed to the strategy and logged\\n     * @return tokens Addresses of the tokens received as rewards\\n     * @return amounts Amounts of the tokens received as rewards\\n     */\\n    function claim(address strategy, bytes memory data)\\n        external\\n        override\\n        auth\\n        returns (address[] memory tokens, uint256[] memory amounts)\\n    {\\n        require(isStrategyAllowed[strategy], 'STRATEGY_NOT_ALLOWED');\\n        (tokens, amounts) = strategy.claim(data);\\n        emit Claim(strategy, tokens, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Join a strategy with an amount of tokens. Sender must be authorized.\\n     * @param strategy Address of the strategy to join\\n     * @param tokensIn List of token addresses to join with\\n     * @param amountsIn List of token amounts to join with\\n     * @param slippage Slippage that will be used to compute the join\\n     * @param data Extra data passed to the strategy and logged\\n     * @return tokensOut List of token addresses received after the join\\n     * @return amountsOut List of token amounts received after the join\\n     */\\n    function join(\\n        address strategy,\\n        address[] memory tokensIn,\\n        uint256[] memory amountsIn,\\n        uint256 slippage,\\n        bytes memory data\\n    ) external override auth returns (address[] memory tokensOut, uint256[] memory amountsOut) {\\n        require(isStrategyAllowed[strategy], 'STRATEGY_NOT_ALLOWED');\\n        require(slippage <= FixedPoint.ONE, 'JOIN_SLIPPAGE_ABOVE_ONE');\\n        require(tokensIn.length == amountsIn.length, 'JOIN_INPUT_INVALID_LENGTH');\\n\\n        uint256 value;\\n        (tokensOut, amountsOut, value) = strategy.join(tokensIn, amountsIn, slippage, data);\\n        require(tokensOut.length == amountsOut.length, 'JOIN_OUTPUT_INVALID_LENGTH');\\n\\n        investedValue[strategy] = investedValue[strategy] + value;\\n        emit Join(strategy, tokensIn, amountsIn, tokensOut, amountsOut, value, slippage, data);\\n    }\\n\\n    /**\\n     * @dev Exit a strategy. Sender must be authorized.\\n     * @param strategy Address of the strategy to exit\\n     * @param tokensIn List of token addresses to exit with\\n     * @param amountsIn List of token amounts to exit with\\n     * @param slippage Slippage that will be used to compute the exit\\n     * @param data Extra data passed to the strategy and logged\\n     * @return tokensOut List of token addresses received after the exit\\n     * @return amountsOut List of token amounts received after the exit\\n     */\\n    function exit(\\n        address strategy,\\n        address[] memory tokensIn,\\n        uint256[] memory amountsIn,\\n        uint256 slippage,\\n        bytes memory data\\n    ) external override auth returns (address[] memory tokensOut, uint256[] memory amountsOut) {\\n        require(isStrategyAllowed[strategy], 'STRATEGY_NOT_ALLOWED');\\n        require(investedValue[strategy] > 0, 'EXIT_NO_INVESTED_VALUE');\\n        require(slippage <= FixedPoint.ONE, 'EXIT_SLIPPAGE_ABOVE_ONE');\\n        require(tokensIn.length == amountsIn.length, 'EXIT_INPUT_INVALID_LENGTH');\\n\\n        uint256 value;\\n        (tokensOut, amountsOut, value) = strategy.exit(tokensIn, amountsIn, slippage, data);\\n        require(tokensOut.length == amountsOut.length, 'EXIT_OUTPUT_INVALID_LENGTH');\\n        uint256[] memory performanceFeeAmounts = new uint256[](amountsOut.length);\\n\\n        // It can rely on the last updated value since we have just exited, no need to compute current value\\n        uint256 valueBeforeExit = lastValue(strategy) + value;\\n        if (valueBeforeExit <= investedValue[strategy]) {\\n            // There were losses, invested value is simply reduced using the exited ratio compared to the value\\n            // before exit. Invested value is round up to avoid interpreting losses due to rounding errors\\n            investedValue[strategy] -= investedValue[strategy].mulUp(value).divUp(valueBeforeExit);\\n        } else {\\n            // If value gains are greater than the exit value, it means only gains are being withdrawn. In that case\\n            // the taxable amount is the entire exited amount, otherwise it should be the equivalent gains ratio of it.\\n            uint256 valueGains = valueBeforeExit.uncheckedSub(investedValue[strategy]);\\n            bool onlyGains = valueGains >= value;\\n\\n            // If the exit value is greater than the value gains, the invested value should be reduced by the portion\\n            // of the invested value being exited. Otherwise, it's still the same, only gains are being withdrawn.\\n            // No need for checked math as we are checking it manually beforehand\\n            uint256 decrement = onlyGains ? 0 : value.uncheckedSub(valueGains);\\n            investedValue[strategy] = investedValue[strategy] - decrement;\\n\\n            // Compute performance fees per token out\\n            for (uint256 i = 0; i < tokensOut.length; i = i.uncheckedAdd(1)) {\\n                address token = tokensOut[i];\\n                uint256 amount = amountsOut[i];\\n                uint256 taxableAmount = onlyGains ? amount : ((amount * valueGains) / value);\\n                uint256 feeAmount = _payFee(token, taxableAmount, performanceFee);\\n                amountsOut[i] = amount - feeAmount;\\n                performanceFeeAmounts[i] = feeAmount;\\n            }\\n        }\\n\\n        emit Exit(strategy, tokensIn, amountsIn, tokensOut, amountsOut, value, performanceFeeAmounts, slippage, data);\\n    }\\n\\n    /**\\n     * @dev Swaps two tokens. Sender must be authorized.\\n     * @param source Source to request the swap: Uniswap V2, Uniswap V3, Balancer V2, or Paraswap V5.\\n     * @param tokenIn Token being sent\\n     * @param tokenOut Token being received\\n     * @param amountIn Amount of tokenIn being swapped\\n     * @param limitType Swap limit to be applied: slippage or min amount out\\n     * @param limitAmount Amount of the swap limit to be applied depending on limitType\\n     * @param data Encoded data to specify different swap parameters depending on the source picked\\n     * @return amountOut Received amount of tokens out\\n     */\\n    function swap(\\n        uint8 source,\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 amountIn,\\n        SwapLimit limitType,\\n        uint256 limitAmount,\\n        bytes memory data\\n    ) external override auth returns (uint256 amountOut) {\\n        require(tokenIn != tokenOut, 'SWAP_SAME_TOKEN');\\n        require(swapConnector != address(0), 'SWAP_CONNECTOR_NOT_SET');\\n\\n        uint256 minAmountOut;\\n        if (limitType == SwapLimit.MinAmountOut) {\\n            minAmountOut = limitAmount;\\n        } else if (limitType == SwapLimit.Slippage) {\\n            require(limitAmount <= FixedPoint.ONE, 'SWAP_SLIPPAGE_ABOVE_ONE');\\n            uint256 price = getPrice(tokenIn, tokenOut);\\n            // No need for checked math as we are checking it manually beforehand\\n            // Always round up the expected min amount out. Limit amount is slippage.\\n            minAmountOut = amountIn.mulUp(price).mulUp(FixedPoint.ONE.uncheckedSub(limitAmount));\\n        } else {\\n            revert('SWAP_INVALID_LIMIT_TYPE');\\n        }\\n\\n        uint256 preBalanceIn = IERC20(tokenIn).balanceOf(address(this));\\n        uint256 preBalanceOut = IERC20(tokenOut).balanceOf(address(this));\\n        swapConnector.swap(source, tokenIn, tokenOut, amountIn, minAmountOut, data);\\n\\n        uint256 postBalanceIn = IERC20(tokenIn).balanceOf(address(this));\\n        require(postBalanceIn >= preBalanceIn - amountIn, 'SWAP_BAD_TOKEN_IN_BALANCE');\\n\\n        uint256 amountOutBeforeFees = IERC20(tokenOut).balanceOf(address(this)) - preBalanceOut;\\n        require(amountOutBeforeFees >= minAmountOut, 'SWAP_MIN_AMOUNT');\\n\\n        uint256 swapFeeAmount = _payFee(tokenOut, amountOutBeforeFees, swapFee);\\n        amountOut = amountOutBeforeFees - swapFeeAmount;\\n        emit Swap(source, tokenIn, tokenOut, amountIn, amountOut, minAmountOut, swapFeeAmount, data);\\n    }\\n\\n    /**\\n     * @dev Bridge assets to another chain\\n     * @param source Source to request the bridge. It depends on the Bridge Connector attached to a Smart Vault.\\n     * @param chainId ID of the destination chain\\n     * @param token Address of the token to be bridged\\n     * @param amount Amount of tokens to be bridged\\n     * @param limitType Bridge limit to be applied: slippage or min amount out\\n     * @param limitAmount Amount of the swap limit to be applied depending on limitType\\n     * @param recipient Address that will receive the tokens on the destination chain\\n     * @param data Encoded data to specify different bridge parameters depending on the source picked\\n     * @return bridged Amount requested to be bridged after fees\\n     */\\n    function bridge(\\n        uint8 source,\\n        uint256 chainId,\\n        address token,\\n        uint256 amount,\\n        BridgeLimit limitType,\\n        uint256 limitAmount,\\n        address recipient,\\n        bytes memory data\\n    ) external override auth returns (uint256 bridged) {\\n        require(block.chainid != chainId, 'BRIDGE_SAME_CHAIN');\\n        require(recipient != address(0), 'BRIDGE_RECIPIENT_ZERO');\\n        require(bridgeConnector != address(0), 'BRIDGE_CONNECTOR_NOT_SET');\\n\\n        uint256 bridgeFeeAmount = _payFee(token, amount, bridgeFee);\\n        bridged = amount - bridgeFeeAmount;\\n\\n        uint256 minAmountOut;\\n        if (limitType == BridgeLimit.MinAmountOut) {\\n            minAmountOut = limitAmount;\\n        } else if (limitType == BridgeLimit.Slippage) {\\n            require(limitAmount <= FixedPoint.ONE, 'BRIDGE_SLIPPAGE_ABOVE_ONE');\\n            // No need for checked math as we are checking it manually beforehand\\n            // Always round up the expected min amount out. Limit amount is slippage.\\n            minAmountOut = bridged.mulUp(FixedPoint.ONE.uncheckedSub(limitAmount));\\n        } else {\\n            revert('BRIDGE_INVALID_LIMIT_TYPE');\\n        }\\n\\n        uint256 preBalanceIn = IERC20(token).balanceOf(address(this));\\n        bridgeConnector.bridge(source, chainId, token, bridged, minAmountOut, recipient, data);\\n        uint256 postBalanceIn = IERC20(token).balanceOf(address(this));\\n        require(postBalanceIn >= preBalanceIn - bridged, 'BRIDGE_BAD_TOKEN_IN_BALANCE');\\n\\n        emit Bridge(source, chainId, token, bridged, minAmountOut, bridgeFeeAmount, recipient, data);\\n    }\\n\\n    /**\\n     * @dev Internal function to pay the amount of fees to be charged based on a fee configuration to the fee collector\\n     * @param token Token being charged\\n     * @param amount Token amount to be taxed with fees\\n     * @param fee Fee configuration to be applied\\n     * @return paidAmount Amount of fees paid to the fee collector\\n     */\\n    function _payFee(address token, uint256 amount, Fee storage fee) internal returns (uint256 paidAmount) {\\n        // Fee amounts are always rounded down\\n        uint256 feeAmount = amount.mulDown(fee.pct);\\n\\n        // If cap amount or cap period are not set, charge the entire amount\\n        if (fee.token == address(0) || fee.cap == 0 || fee.period == 0) {\\n            _safeTransfer(token, feeCollector, feeAmount);\\n            return feeAmount;\\n        }\\n\\n        // Reset cap totalizator if necessary\\n        if (block.timestamp >= fee.nextResetTime) {\\n            fee.totalCharged = 0;\\n            fee.nextResetTime = block.timestamp + fee.period;\\n        }\\n\\n        // Calc fee amount in the fee token used for the cap\\n        uint256 feeTokenPrice = getPrice(token, fee.token);\\n        uint256 feeAmountInFeeToken = feeAmount.mulDown(feeTokenPrice);\\n\\n        // Compute fee amount picking the minimum between the chargeable amount and the remaining part for the cap\\n        if (fee.totalCharged + feeAmountInFeeToken <= fee.cap) {\\n            paidAmount = feeAmount;\\n            fee.totalCharged += feeAmountInFeeToken;\\n        } else if (fee.totalCharged < fee.cap) {\\n            paidAmount = (fee.cap.uncheckedSub(fee.totalCharged) * feeAmount) / feeAmountInFeeToken;\\n            fee.totalCharged = fee.cap;\\n        } else {\\n            // This case is when the total charged amount is already greater than the cap amount. It could happen if\\n            // the cap amounts is decreased or if the cap token is changed. In this case the total charged amount is\\n            // not updated, and the amount to paid is zero.\\n            paidAmount = 0;\\n        }\\n\\n        // Pay fee amount to the fee collector\\n        _safeTransfer(token, feeCollector, paidAmount);\\n    }\\n\\n    /**\\n     * @dev Internal method to transfer ERC20 or native tokens from a Smart Vault\\n     * @param token Address of the ERC20 token to transfer\\n     * @param to Address transferring the tokens to\\n     * @param amount Amount of tokens to transfer\\n     */\\n    function _safeTransfer(address token, address to, uint256 amount) internal {\\n        if (amount == 0) return;\\n        if (Denominations.isNativeToken(token)) Address.sendValue(payable(to), amount);\\n        else IERC20(token).safeTransfer(to, amount);\\n    }\\n\\n    /**\\n     * @dev Sets a new strategy as allowed or not\\n     * @param strategy Address of the strategy to be set\\n     * @param allowed Whether the strategy is allowed or not\\n     */\\n    function _setStrategy(address strategy, bool allowed) internal {\\n        if (allowed) _validateStatelessDependency(strategy);\\n        isStrategyAllowed[strategy] = allowed;\\n        emit StrategySet(strategy, allowed);\\n    }\\n\\n    /**\\n     * @dev Sets a new price oracle\\n     * @param newPriceOracle New price oracle to be set\\n     */\\n    function _setPriceOracle(address newPriceOracle) internal {\\n        _validateStatelessDependency(newPriceOracle);\\n        priceOracle = newPriceOracle;\\n        emit PriceOracleSet(newPriceOracle);\\n    }\\n\\n    /**\\n     * @dev Sets a new swap connector\\n     * @param newSwapConnector New swap connector to be set\\n     */\\n    function _setSwapConnector(address newSwapConnector) internal {\\n        _validateStatelessDependency(newSwapConnector);\\n        swapConnector = newSwapConnector;\\n        emit SwapConnectorSet(newSwapConnector);\\n    }\\n\\n    /**\\n     * @dev Sets a new bridge connector\\n     * @param newBridgeConnector New bridge connector to be set\\n     */\\n    function _setBridgeConnector(address newBridgeConnector) internal {\\n        _validateStatelessDependency(newBridgeConnector);\\n        bridgeConnector = newBridgeConnector;\\n        emit BridgeConnectorSet(newBridgeConnector);\\n    }\\n\\n    /**\\n     * @dev Internal method to set the fee collector\\n     * @param newFeeCollector New fee collector to be set\\n     */\\n    function _setFeeCollector(address newFeeCollector) internal {\\n        require(newFeeCollector != address(0), 'FEE_COLLECTOR_ZERO');\\n        feeCollector = newFeeCollector;\\n        emit FeeCollectorSet(newFeeCollector);\\n    }\\n\\n    /**\\n     * @dev Internal method to set a new fee cap configuration\\n     * @param fee Fee configuration to be updated\\n     * @param pct Fee percentage to be set\\n     * @param cap New maximum amount of fees to be charged per period\\n     * @param token Address of the token cap to be set\\n     * @param period New cap period length in seconds\\n     */\\n    function _setFeeConfiguration(Fee storage fee, uint256 pct, uint256 cap, address token, uint256 period) internal {\\n        require(pct <= FixedPoint.ONE, 'FEE_PCT_ABOVE_ONE');\\n\\n        // If there is no fee percentage, there must not be a fee cap\\n        bool isZeroCap = token == address(0) && cap == 0 && period == 0;\\n        require(pct != 0 || isZeroCap, 'INVALID_CAP_WITH_FEE_ZERO');\\n\\n        // If there is a cap, all values must be non-zero\\n        bool isNonZeroCap = token != address(0) && cap != 0 && period != 0;\\n        require(isZeroCap || isNonZeroCap, 'INCONSISTENT_CAP_VALUES');\\n\\n        // Changing the fee percentage does not affect the totalizator at all, it only affects future fee charges\\n        fee.pct = pct;\\n\\n        // Changing the fee cap amount does not affect the totalizator, it only applies when changing the for the total\\n        // charged amount. Note that it can happen that the cap amount is lower than the total charged amount if the\\n        // cap amount is lowered. However, there shouldn't be any accounting issues with that.\\n        fee.cap = cap;\\n\\n        // Changing the cap period only affects the end time of the next period, but not the end date of the current one\\n        fee.period = period;\\n\\n        // Therefore, only clean the totalizators if the cap is being removed\\n        if (isZeroCap) {\\n            fee.totalCharged = 0;\\n            fee.nextResetTime = 0;\\n        } else {\\n            // If cap values are not zero, set the next reset time if it wasn't set already\\n            // Otherwise, if the cap token is being changed the total charged amount must be updated accordingly\\n            if (fee.nextResetTime == 0) {\\n                fee.nextResetTime = block.timestamp + period;\\n            } else if (fee.token != token) {\\n                uint256 newTokenPrice = getPrice(fee.token, token);\\n                fee.totalCharged = fee.totalCharged.mulDown(newTokenPrice);\\n            }\\n        }\\n\\n        // Finally simply set the new requested token\\n        fee.token = token;\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-smart-vaults-base/contracts/actions/BaseAction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\\n\\nimport '@mimic-fi/v2-smart-vault/contracts/ISmartVault.sol';\\nimport '@mimic-fi/v2-helpers/contracts/auth/Authorizer.sol';\\nimport '@mimic-fi/v2-helpers/contracts/utils/Denominations.sol';\\nimport '@mimic-fi/v2-helpers/contracts/utils/ERC20Helpers.sol';\\nimport '@mimic-fi/v2-registry/contracts/implementations/BaseAuthorizedImplementation.sol';\\n\\nimport './IAction.sol';\\n\\n/**\\n * @title BaseAction\\n * @dev Simple action implementation with a Smart Vault reference and using the Authorizer mixin\\n */\\ncontract BaseAction is IAction, BaseAuthorizedImplementation, ReentrancyGuard {\\n    bytes32 public constant override NAMESPACE = keccak256('ACTION');\\n\\n    // Smart Vault reference\\n    ISmartVault public override smartVault;\\n\\n    /**\\n     * @dev Emitted every time a new smart vault is set\\n     */\\n    event SmartVaultSet(address indexed smartVault);\\n\\n    /**\\n     * @dev Creates a new BaseAction\\n     * @param admin Address to be granted authorize and unauthorize permissions\\n     * @param registry Address of the Mimic Registry\\n     */\\n    constructor(address admin, address registry) BaseAuthorizedImplementation(admin, registry) {\\n        // solhint-disable-previous-line no-empty-blocks\\n    }\\n\\n    /**\\n     * @dev Sets the Smart Vault tied to the Action. Sender must be authorized. It can be set only once.\\n     * @param newSmartVault Address of the smart vault to be set\\n     */\\n    function setSmartVault(address newSmartVault) external auth {\\n        require(address(smartVault) == address(0), 'SMART_VAULT_ALREADY_SET');\\n        smartVault = ISmartVault(newSmartVault);\\n        emit SmartVaultSet(newSmartVault);\\n    }\\n\\n    /**\\n     * @dev Tells the balance of the Smart Vault for a given token\\n     * @param token Address of the token querying the balance of\\n     * @notice Denominations.NATIVE_TOKEN_ADDRESS can be used to query the native token balance\\n     */\\n    function _balanceOf(address token) internal view returns (uint256) {\\n        return ERC20Helpers.balanceOf(token, address(smartVault));\\n    }\\n\\n    /**\\n     * @dev Tells the wrapped native token address if the given address is the native token\\n     * @param token Address of the token to be checked\\n     */\\n    function _wrappedIfNative(address token) internal view returns (address) {\\n        return Denominations.isNativeToken(token) ? smartVault.wrappedNativeToken() : token;\\n    }\\n\\n    /**\\n     * @dev Tells whether the given token is either the native or wrapped native token\\n     * @param token Address of the token being queried\\n     */\\n    function _isWrappedOrNativeToken(address token) internal view returns (bool) {\\n        return Denominations.isNativeToken(token) || token == smartVault.wrappedNativeToken();\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-smart-vaults-base/contracts/actions/IAction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.8.0;\\n\\nimport '@mimic-fi/v2-smart-vault/contracts/ISmartVault.sol';\\nimport '@mimic-fi/v2-helpers/contracts/auth/IAuthorizer.sol';\\n\\n/**\\n * @title IAction\\n * @dev Action interface it must follow the IAuthorizer interface\\n */\\ninterface IAction is IAuthorizer {\\n    /**\\n     * @dev Emitted every time an action is executed\\n     */\\n    event Executed();\\n\\n    /**\\n     * @dev Tells the address of the Smart Vault tied to it, it cannot be changed\\n     */\\n    function smartVault() external view returns (ISmartVault);\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-smart-vaults-base/contracts/actions/ReceiverAction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\\nimport '@openzeppelin/contracts/utils/Address.sol';\\n\\nimport './BaseAction.sol';\\n\\nabstract contract ReceiverAction is BaseAction {\\n    using SafeERC20 for IERC20;\\n\\n    receive() external payable {\\n        // solhint-disable-previous-line no-empty-blocks\\n    }\\n\\n    function transferToSmartVault(address token, uint256 amount) external auth {\\n        _transferToSmartVault(token, amount);\\n    }\\n\\n    function _transferToSmartVault(address token, uint256 amount) internal {\\n        ERC20Helpers.transfer(token, address(smartVault), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-smart-vaults-base/contracts/actions/RelayedAction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nimport '@mimic-fi/v2-helpers/contracts/math/FixedPoint.sol';\\nimport '@mimic-fi/v2-helpers/contracts/utils/Denominations.sol';\\n\\nimport './BaseAction.sol';\\n\\n/**\\n * @title RelayedAction\\n * @dev Action that offers a relayed mechanism to allow reimbursing tx costs after execution in any ERC20 token.\\n * This type of action at least require having withdraw permissions from the Smart Vault tied to it.\\n */\\nabstract contract RelayedAction is BaseAction {\\n    using FixedPoint for uint256;\\n\\n    // Base gas amount charged to cover default amounts\\n    // solhint-disable-next-line func-name-mixedcase\\n    function BASE_GAS() external view virtual returns (uint256);\\n\\n    // Note to be used to mark tx cost payments\\n    bytes private constant REDEEM_GAS_NOTE = bytes('RELAYER');\\n\\n    // Internal variable used to allow a better developer experience to reimburse tx gas cost\\n    uint256 private _initialGas;\\n\\n    // Gas price limit expressed in the native token, if surpassed it wont relay the transaction\\n    uint256 public gasPriceLimit;\\n\\n    // Total transaction cost limit expressed in the native token, if surpassed it wont relay the transaction\\n    uint256 public txCostLimit;\\n\\n    // List of allowed relayers indexed by address\\n    mapping (address => bool) public isRelayer;\\n\\n    /**\\n     * @dev Emitted every time the relayers list is changed\\n     */\\n    event RelayerSet(address indexed relayer, bool allowed);\\n\\n    /**\\n     * @dev Emitted every time the relayer limits are set\\n     */\\n    event LimitsSet(uint256 gasPriceLimit, uint256 txCostLimit);\\n\\n    /**\\n     * @dev Modifier that can be used to reimburse the gas cost of the tagged function paying in a specific token\\n     */\\n    modifier redeemGas(address token) {\\n        _initRelayedTx();\\n        _;\\n        _payRelayedTx(token);\\n    }\\n\\n    /**\\n     * @dev Sets a relayer address. Sender must be authorized.\\n     * @param relayer Address of the relayer to be set\\n     * @param allowed Whether it should be allowed or not\\n     */\\n    function setRelayer(address relayer, bool allowed) external auth {\\n        isRelayer[relayer] = allowed;\\n        emit RelayerSet(relayer, allowed);\\n    }\\n\\n    /**\\n     * @dev Sets the relayer limits. Sender must be authorized.\\n     * @param _gasPriceLimit New gas price limit to be set\\n     * @param _txCostLimit New total cost limit to be set\\n     */\\n    function setLimits(uint256 _gasPriceLimit, uint256 _txCostLimit) external auth {\\n        gasPriceLimit = _gasPriceLimit;\\n        txCostLimit = _txCostLimit;\\n        emit LimitsSet(_gasPriceLimit, _txCostLimit);\\n    }\\n\\n    /**\\n     * @dev Internal init hook used for relayed txs. It checks tx limit validations only when the sender is a relayer.\\n     */\\n    function _initRelayedTx() internal {\\n        if (!isRelayer[msg.sender]) return;\\n        _initialGas = gasleft();\\n        uint256 limit = gasPriceLimit;\\n        require(limit == 0 || tx.gasprice <= limit, 'GAS_PRICE_ABOVE_LIMIT');\\n    }\\n\\n    /**\\n     * @dev Internal function to pay for a relayed tx. Only when the sender is marked as a relayer.\\n     * @param token Address of the token to use in order to pay the tx cost\\n     * @return Amount of tokens paid to reimburse the tx cost\\n     */\\n    function _payRelayedTx(address token) internal returns (uint256) {\\n        (bool success, uint256 price) = _tryGetNativeTokenPriceIn(token);\\n        if (success) return _payRelayedTx(token, price);\\n        delete _initialGas;\\n        return 0;\\n    }\\n\\n    /**\\n     * @dev Internal after call hook where tx cost is reimbursed. Only when the sender is marked as a relayer.\\n     * @param token Address of the token to use in order to pay the tx cost\\n     * @param price Price of the native token expressed in the given token quote\\n     * @return Amount of tokens paid to reimburse the tx cost\\n     */\\n    function _payRelayedTx(address token, uint256 price) internal returns (uint256) {\\n        if (!isRelayer[msg.sender]) return 0;\\n        require(_initialGas > 0, 'RELAYED_TX_NOT_INITIALIZED');\\n\\n        uint256 limit = txCostLimit;\\n        uint256 totalGas = _initialGas - gasleft();\\n        uint256 totalCostNative = (totalGas + RelayedAction(this).BASE_GAS()) * tx.gasprice;\\n        require(limit == 0 || totalCostNative <= limit, 'TX_COST_ABOVE_LIMIT');\\n\\n        // Total cost is rounded down to make sure we always match at least the threshold\\n        uint256 totalCostToken = totalCostNative.mulDown(price);\\n        smartVault.withdraw(token, totalCostToken, smartVault.feeCollector(), REDEEM_GAS_NOTE);\\n\\n        delete _initialGas;\\n        return totalCostToken;\\n    }\\n\\n    /**\\n     * @dev Tries getting the price of the native token quoted in a another token\\n     * @param token Address of the token to quote the native token in\\n     * @return success Whether the price query to the smart vault succeeded or not\\n     * @return price The price fetched or zero if the query didn't succeed\\n     */\\n    function _tryGetNativeTokenPriceIn(address token) internal view virtual returns (bool success, uint256 price) {\\n        if (_isWrappedOrNativeToken(token)) return (true, FixedPoint.ONE);\\n        try smartVault.getPrice(smartVault.wrappedNativeToken(), token) returns (uint256 result) {\\n            return (true, result);\\n        } catch {\\n            return (false, 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-smart-vaults-base/contracts/actions/TimeLockedAction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nimport './BaseAction.sol';\\n\\n/**\\n * @title Time-locked action\\n * @dev Action that offers a time-lock mechanism to allow executing it only once during a set period of time\\n */\\nabstract contract TimeLockedAction is BaseAction {\\n    // Period in seconds\\n    uint256 public period;\\n\\n    // Next timestamp in the future when the action can be executed again\\n    uint256 public nextResetTime;\\n\\n    /**\\n     * @dev Emitted every time a time-lock is set\\n     */\\n    event TimeLockSet(uint256 period);\\n\\n    /**\\n     * @dev Creates a new time-locked action\\n     */\\n    constructor() {\\n        nextResetTime = block.timestamp;\\n    }\\n\\n    /**\\n     * @dev Sets a new period for the time-locked action\\n     * @param newPeriod New period to be set\\n     */\\n    function setTimeLock(uint256 newPeriod) external auth {\\n        period = newPeriod;\\n        emit TimeLockSet(newPeriod);\\n    }\\n\\n    /**\\n     * @dev Internal function to tell whether the current time-lock has passed\\n     */\\n    function _passesTimeLock() internal view returns (bool) {\\n        return block.timestamp >= nextResetTime;\\n    }\\n\\n    /**\\n     * @dev Internal function to validate the time-locked action\\n     */\\n    function _validateTimeLock() internal {\\n        require(_passesTimeLock(), 'TIME_LOCK_NOT_EXPIRED');\\n        nextResetTime = block.timestamp + period;\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-smart-vaults-base/contracts/actions/TokenThresholdAction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@mimic-fi/v2-helpers/contracts/math/FixedPoint.sol';\\n\\nimport './BaseAction.sol';\\n\\n/**\\n * @title TokenThresholdAction\\n * @dev Action that offers a token threshold limit. It can be used for minimum swap amounts, or minimum withdrawal\\n * amounts, etc. This type of action does not require any specific permission on the Smart Vault.\\n */\\nabstract contract TokenThresholdAction is BaseAction {\\n    using FixedPoint for uint256;\\n\\n    address public thresholdToken;\\n    uint256 public thresholdAmount;\\n\\n    event ThresholdSet(address indexed token, uint256 amount);\\n\\n    /**\\n     * @dev Sets a new threshold configuration. Sender must be authorized.\\n     * @param token New token threshold to be set\\n     * @param amount New amount threshold to be set\\n     */\\n    function setThreshold(address token, uint256 amount) external auth {\\n        thresholdToken = token;\\n        thresholdAmount = amount;\\n        emit ThresholdSet(token, amount);\\n    }\\n\\n    /**\\n     * @dev Internal function to check the set threshold\\n     * @param token Token address of the given amount to evaluate the threshold\\n     * @param amount Amount of tokens to validate the threshold\\n     */\\n    function _passesThreshold(address token, uint256 amount) internal view returns (bool) {\\n        uint256 price = smartVault.getPrice(_wrappedIfNative(token), thresholdToken);\\n        // Result balance is rounded down to make sure we always match at least the threshold\\n        return amount.mulDown(price) >= thresholdAmount;\\n    }\\n\\n    /**\\n     * @dev Internal function to validate the set threshold\\n     * @param token Token address of the given amount to evaluate the threshold\\n     * @param amount Amount of tokens to validate the threshold\\n     */\\n    function _validateThreshold(address token, uint256 amount) internal view {\\n        require(_passesThreshold(token, amount), 'MIN_THRESHOLD_NOT_MET');\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-smart-vaults-base/contracts/actions/WithdrawalAction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nimport './BaseAction.sol';\\n\\n/**\\n * @title Withdrawal action\\n * @dev Action that offers a recipient address where funds can be withdrawn. This type of action at least require\\n * having withdraw permissions from the Smart Vault tied to it.\\n */\\nabstract contract WithdrawalAction is BaseAction {\\n    // Address where tokens will be transferred to\\n    address public recipient;\\n\\n    /**\\n     * @dev Emitted every time the recipient is set\\n     */\\n    event RecipientSet(address indexed recipient);\\n\\n    /**\\n     * @dev Sets the recipient address. Sender must be authorized.\\n     * @param newRecipient Address of the new recipient to be set\\n     */\\n    function setRecipient(address newRecipient) external auth {\\n        require(newRecipient != address(0), 'RECIPIENT_ZERO');\\n        recipient = newRecipient;\\n        emit RecipientSet(newRecipient);\\n    }\\n\\n    /**\\n     * @dev Internal function to withdraw all the available balance of a token from the Smart Vault to the recipient\\n     * @param token Address of the token to be withdrawn\\n     */\\n    function _withdraw(address token) internal {\\n        uint256 balance = _balanceOf(token);\\n        _withdraw(token, balance);\\n    }\\n\\n    /**\\n     * @dev Internal function to withdraw a specific amount of a token from the Smart Vault to the recipient\\n     * @param token Address of the token to be withdrawn\\n     * @param amount Amount of tokens to be withdrawn\\n     */\\n    function _withdraw(address token, uint256 amount) internal {\\n        smartVault.withdraw(token, amount, recipient, new bytes(0));\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-smart-vaults-base/contracts/deploy/Deployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@mimic-fi/v2-smart-vault/contracts/SmartVault.sol';\\nimport '@mimic-fi/v2-smart-vault/contracts/ISmartVaultsFactory.sol';\\nimport '@mimic-fi/v2-helpers/contracts/auth/IAuthorizer.sol';\\nimport '@mimic-fi/v2-helpers/contracts/math/UncheckedMath.sol';\\nimport '@mimic-fi/v2-registry/contracts/registry/IRegistry.sol';\\n\\nimport '../actions/ReceiverAction.sol';\\nimport '../actions/RelayedAction.sol';\\nimport '../actions/TimeLockedAction.sol';\\nimport '../actions/TokenThresholdAction.sol';\\nimport '../actions/WithdrawalAction.sol';\\n\\n/**\\n * @title Deployer\\n * @dev Deployer library offering a bunch of set-up methods to deploy and customize smart vaults\\n */\\nlibrary Deployer {\\n    using UncheckedMath for uint256;\\n\\n    // Namespace to use by this deployer to fetch ISmartVaultFactory implementations from the Mimic Registry\\n    bytes32 private constant SMART_VAULT_FACTORY_NAMESPACE = keccak256('SMART_VAULTS_FACTORY');\\n\\n    // Namespace to use by this deployer to fetch ISmartVault implementations from the Mimic Registry\\n    bytes32 private constant SMART_VAULT_NAMESPACE = keccak256('SMART_VAULT');\\n\\n    // Namespace to use by this deployer to fetch IStrategy implementations from the Mimic Registry\\n    bytes32 private constant STRATEGY_NAMESPACE = keccak256('STRATEGY');\\n\\n    // Namespace to use by this deployer to fetch IPriceOracle implementations from the Mimic Registry\\n    bytes32 private constant PRICE_ORACLE_NAMESPACE = keccak256('PRICE_ORACLE');\\n\\n    // Namespace to use by this deployer to fetch ISwapConnector implementations from the Mimic Registry\\n    bytes32 private constant SWAP_CONNECTOR_NAMESPACE = keccak256('SWAP_CONNECTOR');\\n\\n    // Namespace to use by this deployer to fetch IBridgeConnector implementations from the Mimic Registry\\n    bytes32 private constant BRIDGE_CONNECTOR_NAMESPACE = keccak256('BRIDGE_CONNECTOR');\\n\\n    /**\\n     * @dev Smart vault params\\n     * @param factory Address of the factory that will be used to deploy an instance of the Smart Vault implementation\\n     * @param impl Address of the Smart Vault implementation to be used\\n     * @param salt Salt bytes to derivate the address of the new Smart Vault instance\\n     * @param admin Address that will be granted with admin rights for the deployed Smart Vault\\n     * @param bridgeConnector Optional Bridge Connector to set for the Smart Vault\\n     * @param swapConnector Optional Swap Connector to set for the Smart Vault\\n     * @param strategies List of strategies to be allowed for the Smart Vault\\n     * @param priceOracle Optional Price Oracle to set for the Smart Vault\\n     * @param priceFeedParams List of price feeds to be set for the Smart Vault\\n     * @param feeCollector Address to be set as the fee collector\\n     * @param swapFee Swap fee params\\n     * @param bridgeFee Bridge fee params\\n     * @param withdrawFee Withdraw fee params\\n     * @param performanceFee Performance fee params\\n     */\\n    struct SmartVaultParams {\\n        address factory;\\n        address impl;\\n        bytes32 salt;\\n        address admin;\\n        address[] strategies;\\n        address bridgeConnector;\\n        address swapConnector;\\n        address priceOracle;\\n        PriceFeedParams[] priceFeedParams;\\n        address feeCollector;\\n        address feeCollectorAdmin;\\n        SmartVaultFeeParams swapFee;\\n        SmartVaultFeeParams bridgeFee;\\n        SmartVaultFeeParams withdrawFee;\\n        SmartVaultFeeParams performanceFee;\\n    }\\n\\n    /**\\n     * @dev Smart Vault price feed params\\n     * @param base Base token of the price feed\\n     * @param quote Quote token of the price feed\\n     * @param feed Address of the price feed\\n     */\\n    struct PriceFeedParams {\\n        address base;\\n        address quote;\\n        address feed;\\n    }\\n\\n    /**\\n     * @dev Smart Vault fee configuration parameters\\n     * @param pct Percentage expressed using 16 decimals (1e18 = 100%)\\n     * @param cap Maximum amount of fees to be charged per period\\n     * @param token Address of the token to express the cap amount\\n     * @param period Period length in seconds\\n     */\\n    struct SmartVaultFeeParams {\\n        uint256 pct;\\n        uint256 cap;\\n        address token;\\n        uint256 period;\\n    }\\n\\n    /**\\n     * @dev Relayed action params\\n     * @param relayers List of addresses to be marked as allowed executors and in particular as authorized relayers\\n     * @param gasPriceLimit Gas price limit to be used for the relayed action\\n     * @param txCostLimit Total transaction cost limit to be used for the relayed action\\n     */\\n    struct RelayedActionParams {\\n        address[] relayers;\\n        uint256 gasPriceLimit;\\n        uint256 txCostLimit;\\n    }\\n\\n    /**\\n     * @dev Token threshold action params\\n     * @param token Address of the token of the threshold\\n     * @param amount Amount of tokens of the threshold\\n     */\\n    struct TokenThresholdActionParams {\\n        address token;\\n        uint256 amount;\\n    }\\n\\n    /**\\n     * @dev Time-locked action params\\n     * @param period Period in seconds to be set for the time lock\\n     */\\n    struct TimeLockedActionParams {\\n        uint256 period;\\n    }\\n\\n    /**\\n     * @dev Withdrawal action params\\n     * @param recipient Address that will receive the funds from the withdraw action\\n     */\\n    struct WithdrawalActionParams {\\n        address recipient;\\n    }\\n\\n    /**\\n     * @dev Create a new Smart Vault instance\\n     * @param registry Address of the registry to validate the Smart Vault implementation\\n     * @param params Params to customize the Smart Vault to be deployed\\n     * @param transferPermissions Whether the Smart Vault admin permissions should be transfer to the admin right after\\n     * creating the Smart Vault. Sometimes this is not desired if further customization might take in place.\\n     */\\n    function createSmartVault(IRegistry registry, SmartVaultParams memory params, bool transferPermissions)\\n        external\\n        returns (SmartVault smartVault)\\n    {\\n        require(params.admin != address(0), 'SMART_VAULT_ADMIN_ZERO');\\n        require(params.feeCollectorAdmin != address(0), 'SMART_VAULT_FEE_ADMIN_ZERO');\\n\\n        // Clone requested Smart Vault implementation and initialize\\n        require(registry.isActive(SMART_VAULT_FACTORY_NAMESPACE, params.factory), 'BAD_SMART_VAULT_FACTORY_IMPL');\\n        ISmartVaultsFactory factory = ISmartVaultsFactory(params.factory);\\n\\n        bytes memory initializeData = abi.encodeWithSelector(SmartVault.initialize.selector, address(this));\\n        bytes32 senderSalt = keccak256(abi.encodePacked(msg.sender, params.salt));\\n        smartVault = SmartVault(payable(factory.create(senderSalt, params.impl, initializeData)));\\n\\n        // Authorize admin to perform any action except setting the fee collector, see below\\n        smartVault.authorize(params.admin, smartVault.collect.selector);\\n        smartVault.authorize(params.admin, smartVault.withdraw.selector);\\n        smartVault.authorize(params.admin, smartVault.wrap.selector);\\n        smartVault.authorize(params.admin, smartVault.unwrap.selector);\\n        smartVault.authorize(params.admin, smartVault.claim.selector);\\n        smartVault.authorize(params.admin, smartVault.join.selector);\\n        smartVault.authorize(params.admin, smartVault.exit.selector);\\n        smartVault.authorize(params.admin, smartVault.swap.selector);\\n        smartVault.authorize(params.admin, smartVault.bridge.selector);\\n        smartVault.authorize(params.admin, smartVault.setStrategy.selector);\\n        smartVault.authorize(params.admin, smartVault.setPriceFeed.selector);\\n        smartVault.authorize(params.admin, smartVault.setPriceFeeds.selector);\\n        smartVault.authorize(params.admin, smartVault.setPriceOracle.selector);\\n        smartVault.authorize(params.admin, smartVault.setSwapConnector.selector);\\n        smartVault.authorize(params.admin, smartVault.setBridgeConnector.selector);\\n        smartVault.authorize(params.admin, smartVault.setWithdrawFee.selector);\\n        smartVault.authorize(params.admin, smartVault.setPerformanceFee.selector);\\n        smartVault.authorize(params.admin, smartVault.setSwapFee.selector);\\n        smartVault.authorize(params.admin, smartVault.setBridgeFee.selector);\\n\\n        // Set price feeds if any\\n        if (params.priceFeedParams.length > 0) {\\n            smartVault.authorize(address(this), smartVault.setPriceFeed.selector);\\n            for (uint256 i = 0; i < params.priceFeedParams.length; i = i.uncheckedAdd(1)) {\\n                PriceFeedParams memory feedParams = params.priceFeedParams[i];\\n                smartVault.setPriceFeed(feedParams.base, feedParams.quote, feedParams.feed);\\n            }\\n            smartVault.unauthorize(address(this), smartVault.setPriceFeed.selector);\\n        }\\n\\n        // Set price oracle if given\\n        if (params.priceOracle != address(0)) {\\n            require(registry.isActive(PRICE_ORACLE_NAMESPACE, params.priceOracle), 'BAD_PRICE_ORACLE_DEPENDENCY');\\n            smartVault.authorize(address(this), smartVault.setPriceOracle.selector);\\n            smartVault.setPriceOracle(params.priceOracle);\\n            smartVault.unauthorize(address(this), smartVault.setPriceOracle.selector);\\n        }\\n\\n        // Set strategies if any\\n        if (params.strategies.length > 0) {\\n            smartVault.authorize(address(this), smartVault.setStrategy.selector);\\n            for (uint256 i = 0; i < params.strategies.length; i = i.uncheckedAdd(1)) {\\n                require(registry.isActive(STRATEGY_NAMESPACE, params.strategies[i]), 'BAD_STRATEGY_DEPENDENCY');\\n                smartVault.setStrategy(params.strategies[i], true);\\n            }\\n            smartVault.unauthorize(address(this), smartVault.setStrategy.selector);\\n        }\\n\\n        // Set swap connector if given\\n        if (params.swapConnector != address(0)) {\\n            require(registry.isActive(SWAP_CONNECTOR_NAMESPACE, params.swapConnector), 'BAD_SWAP_CONNECTOR_DEPENDENCY');\\n            smartVault.authorize(address(this), smartVault.setSwapConnector.selector);\\n            smartVault.setSwapConnector(params.swapConnector);\\n            smartVault.unauthorize(address(this), smartVault.setSwapConnector.selector);\\n        }\\n\\n        // Set bridge connector if given\\n        if (params.bridgeConnector != address(0)) {\\n            bool isActive = registry.isActive(BRIDGE_CONNECTOR_NAMESPACE, params.bridgeConnector);\\n            require(isActive, 'BAD_BRIDGE_CONNECTOR_DEPENDENCY');\\n            smartVault.authorize(address(this), smartVault.setBridgeConnector.selector);\\n            smartVault.setBridgeConnector(params.bridgeConnector);\\n            smartVault.unauthorize(address(this), smartVault.setBridgeConnector.selector);\\n        }\\n\\n        // If no fee collector is given, make sure no fee amounts are requested too\\n        smartVault.authorize(params.feeCollectorAdmin, smartVault.setFeeCollector.selector);\\n        if (params.feeCollector != address(0)) {\\n            smartVault.authorize(address(this), smartVault.setFeeCollector.selector);\\n            smartVault.setFeeCollector(params.feeCollector);\\n            smartVault.unauthorize(address(this), smartVault.setFeeCollector.selector);\\n        } else {\\n            bool noFees = params.withdrawFee.pct == 0 &&\\n                params.swapFee.pct == 0 &&\\n                params.bridgeFee.pct == 0 &&\\n                params.performanceFee.pct == 0;\\n            require(noFees, 'SMART_VAULT_FEES_NO_COLLECTOR');\\n        }\\n\\n        // Set withdraw fee if not zero\\n        SmartVaultFeeParams memory withdrawFee = params.withdrawFee;\\n        if (withdrawFee.pct != 0) {\\n            smartVault.authorize(address(this), smartVault.setWithdrawFee.selector);\\n            smartVault.setWithdrawFee(withdrawFee.pct, withdrawFee.cap, withdrawFee.token, withdrawFee.period);\\n            smartVault.unauthorize(address(this), smartVault.setWithdrawFee.selector);\\n        }\\n\\n        // Set swap fee if not zero\\n        SmartVaultFeeParams memory swapFee = params.swapFee;\\n        if (swapFee.pct != 0) {\\n            smartVault.authorize(address(this), smartVault.setSwapFee.selector);\\n            smartVault.setSwapFee(swapFee.pct, swapFee.cap, swapFee.token, swapFee.period);\\n            smartVault.unauthorize(address(this), smartVault.setSwapFee.selector);\\n        }\\n\\n        // Set bridge fee if not zero\\n        SmartVaultFeeParams memory bridgeFee = params.bridgeFee;\\n        if (bridgeFee.pct != 0) {\\n            smartVault.authorize(address(this), smartVault.setBridgeFee.selector);\\n            smartVault.setBridgeFee(bridgeFee.pct, bridgeFee.cap, bridgeFee.token, bridgeFee.period);\\n            smartVault.unauthorize(address(this), smartVault.setBridgeFee.selector);\\n        }\\n\\n        // Set performance fee if not zero\\n        SmartVaultFeeParams memory perfFee = params.performanceFee;\\n        if (perfFee.pct != 0) {\\n            smartVault.authorize(address(this), smartVault.setPerformanceFee.selector);\\n            smartVault.setPerformanceFee(perfFee.pct, perfFee.cap, perfFee.token, perfFee.period);\\n            smartVault.unauthorize(address(this), smartVault.setPerformanceFee.selector);\\n        }\\n\\n        if (transferPermissions) transferAdminPermissions(smartVault, params.admin);\\n    }\\n\\n    /**\\n     * @dev Set up a base action\\n     * @param action Base action to be set up\\n     * @param admin Address that will be granted with admin rights for the Base Action\\n     * @param smartVault Address of the Smart Vault to be set in the Base Action\\n     */\\n    function setupBaseAction(BaseAction action, address admin, address smartVault) external {\\n        require(admin != address(0), 'BASE_ACTION_ADMIN_ZERO');\\n        action.authorize(admin, action.setSmartVault.selector);\\n        action.authorize(address(this), action.setSmartVault.selector);\\n        action.setSmartVault(smartVault);\\n        action.unauthorize(address(this), action.setSmartVault.selector);\\n    }\\n\\n    /**\\n     * @dev Set up a list of executors for a given action\\n     * @param action Action whose executors are being allowed\\n     * @param executors List of addresses to be allowed to call the given action\\n     * @param callSelector Selector of the function to allow the list of executors\\n     */\\n    function setupActionExecutors(BaseAction action, address[] memory executors, bytes4 callSelector) external {\\n        for (uint256 i = 0; i < executors.length; i = i.uncheckedAdd(1)) {\\n            action.authorize(executors[i], callSelector);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set up a Relayed action\\n     * @param action Relayed action to be configured\\n     * @param admin Address that will be granted with admin rights for the Relayed action\\n     * @param params Params to customize the Relayed action\\n     */\\n    function setupRelayedAction(RelayedAction action, address admin, RelayedActionParams memory params) external {\\n        // Authorize admin to set relayers and txs limits\\n        require(admin != address(0), 'RELAYED_ACTION_ADMIN_ZERO');\\n        action.authorize(admin, action.setLimits.selector);\\n        action.authorize(admin, action.setRelayer.selector);\\n\\n        // Authorize relayers to call action\\n        action.authorize(address(this), action.setRelayer.selector);\\n        for (uint256 i = 0; i < params.relayers.length; i = i.uncheckedAdd(1)) {\\n            action.setRelayer(params.relayers[i], true);\\n        }\\n        action.unauthorize(address(this), action.setRelayer.selector);\\n\\n        // Set relayed transactions limits\\n        action.authorize(address(this), action.setLimits.selector);\\n        action.setLimits(params.gasPriceLimit, params.txCostLimit);\\n        action.unauthorize(address(this), action.setLimits.selector);\\n    }\\n\\n    /**\\n     * @dev Set up a Token Threshold action\\n     * @param action Token threshold action to be configured\\n     * @param admin Address that will be granted with admin rights for the Token Threshold action\\n     * @param params Params to customize the Token Threshold action\\n     */\\n    function setupTokenThresholdAction(\\n        TokenThresholdAction action,\\n        address admin,\\n        TokenThresholdActionParams memory params\\n    ) external {\\n        require(admin != address(0), 'TOKEN_THRESHOLD_ADMIN_ZERO');\\n        action.authorize(admin, action.setThreshold.selector);\\n        action.authorize(address(this), action.setThreshold.selector);\\n        action.setThreshold(params.token, params.amount);\\n        action.unauthorize(address(this), action.setThreshold.selector);\\n    }\\n\\n    /**\\n     * @dev Set up a Time-locked action\\n     * @param action Time-locked action to be configured\\n     * @param admin Address that will be granted with admin rights for the Time-locked action\\n     * @param params Params to customize the Time-locked action\\n     */\\n    function setupTimeLockedAction(TimeLockedAction action, address admin, TimeLockedActionParams memory params)\\n        external\\n    {\\n        require(admin != address(0), 'TIME_LOCKED_ACTION_ADMIN_ZERO');\\n        action.authorize(admin, action.setTimeLock.selector);\\n        action.authorize(address(this), action.setTimeLock.selector);\\n        action.setTimeLock(params.period);\\n        action.unauthorize(address(this), action.setTimeLock.selector);\\n    }\\n\\n    /**\\n     * @dev Set up a Withdrawal action\\n     * @param action Relayed action to be configured\\n     * @param admin Address that will be granted with admin rights for the Withdrawal action\\n     * @param params Params to customize the Withdrawal action\\n     */\\n    function setupWithdrawalAction(WithdrawalAction action, address admin, WithdrawalActionParams memory params)\\n        external\\n    {\\n        require(admin != address(0), 'WITHDRAWAL_ACTION_ADMIN_ZERO');\\n        action.authorize(admin, action.setRecipient.selector);\\n        action.authorize(address(this), action.setRecipient.selector);\\n        action.setRecipient(params.recipient);\\n        action.unauthorize(address(this), action.setRecipient.selector);\\n    }\\n\\n    /**\\n     * @dev Set up a Receiver action\\n     * @param action Relayed action to be configured\\n     * @param admin Address that will be granted with admin rights for the Receiver action\\n     */\\n    function setupReceiverAction(ReceiverAction action, address admin) external {\\n        require(admin != address(0), 'RECEIVER_ACTION_ADMIN_ZERO');\\n        action.authorize(admin, action.transferToSmartVault.selector);\\n    }\\n\\n    /**\\n     * @dev Transfer admin rights from the deployer to another account\\n     * @param target Contract whose permissions are being transferred\\n     * @param to Address that will receive the admin rights\\n     */\\n    function transferAdminPermissions(IAuthorizer target, address to) public {\\n        require(to != address(0), 'ADMIN_PERMISSIONS_TRANSFER_ZERO');\\n        grantAdminPermissions(target, to);\\n        revokeAdminPermissions(target, address(this));\\n    }\\n\\n    /**\\n     * @dev Grant admin permissions to an account\\n     * @param target Contract whose permissions are being granted\\n     * @param to Address that will receive the admin rights\\n     */\\n    function grantAdminPermissions(IAuthorizer target, address to) public {\\n        target.authorize(to, target.authorize.selector);\\n        target.authorize(to, target.unauthorize.selector);\\n    }\\n\\n    /**\\n     * @dev Revoke admin permissions from an account\\n     * @param target Contract whose permissions are being revoked\\n     * @param from Address that will be revoked\\n     */\\n    function revokeAdminPermissions(IAuthorizer target, address from) public {\\n        target.unauthorize(from, target.authorize.selector);\\n        target.unauthorize(from, target.unauthorize.selector);\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-strategies/contracts/IStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@mimic-fi/v2-registry/contracts/implementations/IImplementation.sol';\\n\\n/**\\n * @title IStrategy\\n * @dev Strategy interface required by Mimic Smart Vaults. It must follow the IImplementation interface.\\n */\\ninterface IStrategy is IImplementation {\\n    /**\\n     * @dev Tokens accepted to join the strategy\\n     */\\n    function joinTokens() external view returns (address[] memory);\\n\\n    /**\\n     * @dev Tokens accepted to exit the strategy\\n     */\\n    function exitTokens() external view returns (address[] memory);\\n\\n    /**\\n     * @dev Tells how much a value unit means expressed in the asset token.\\n     * For example, if a strategy has a value of 100 in T0, and then it has a value of 120 in T1,\\n     * and the value rate is 1.5, it means the strategy has earned 30 strategy tokens between T0 and T1.\\n     */\\n    function valueRate() external view returns (uint256);\\n\\n    /**\\n     * @dev Tells the last value an account has over time. Note this value can be outdated: there could be rewards to\\n     * be claimed that will affect the accrued value. For example, if an account has a value of 100 in T0, and then it\\n     * has a value of 120 in T1, it means it gained a 20% between T0 and T1.\\n     * @param account Address of the account querying the last value of\\n     */\\n    function lastValue(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Claim any existing rewards\\n     * @param data Arbitrary extra data\\n     * @return tokens Addresses of the tokens received as rewards\\n     * @return amounts Amounts of the tokens received as rewards\\n     */\\n    function claim(bytes memory data) external returns (address[] memory tokens, uint256[] memory amounts);\\n\\n    /**\\n     * @dev Join the interfaced DeFi protocol\\n     * @param tokensIn List of token addresses to join with\\n     * @param amountsIn List of token amounts to join with\\n     * @param slippage Slippage value to join with\\n     * @param data Arbitrary extra data\\n     * @return tokensOut List of token addresses received after the join\\n     * @return amountsOut List of token amounts received after the join\\n     * @return value Value represented by the joined amount\\n     */\\n    function join(address[] memory tokensIn, uint256[] memory amountsIn, uint256 slippage, bytes memory data)\\n        external\\n        returns (address[] memory tokensOut, uint256[] memory amountsOut, uint256 value);\\n\\n    /**\\n     * @dev Exit the interfaced DeFi protocol\\n     * @param tokensIn List of token addresses to exit with\\n     * @param amountsIn List of token amounts to exit with\\n     * @param slippage Slippage value to exit with\\n     * @param data Arbitrary extra data\\n     * @return tokensOut List of token addresses received after the exit\\n     * @return amountsOut List of token amounts received after the exit\\n     * @return value Value represented by the exited amount\\n     */\\n    function exit(address[] memory tokensIn, uint256[] memory amountsIn, uint256 slippage, bytes memory data)\\n        external\\n        returns (address[] memory tokensOut, uint256[] memory amountsOut, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-swap-connector/contracts/ISwapConnector.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.8.0;\\n\\nimport '@mimic-fi/v2-registry/contracts/implementations/IImplementation.sol';\\n\\n/**\\n * @title ISwapConnector\\n * @dev Swap Connector interface to perform token swaps. It must follow the IImplementation interface.\\n */\\ninterface ISwapConnector is IImplementation {\\n    /**\\n     * @dev Enum identifying the sources proposed: Uniswap V2, Uniswap V3, Balancer V2, Paraswap V5, 1inch V5, and Hop.\\n     */\\n    enum Source {\\n        UniswapV2,\\n        UniswapV3,\\n        BalancerV2,\\n        ParaswapV5,\\n        OneInchV5,\\n        Hop\\n    }\\n\\n    /**\\n     * @dev Swaps two tokens\\n     * @param source Source to execute the requested swap\\n     * @param tokenIn Token being sent\\n     * @param tokenOut Token being received\\n     * @param amountIn Amount of tokenIn being swapped\\n     * @param minAmountOut Minimum amount of tokenOut willing to receive\\n     * @param data Encoded data to specify different swap parameters depending on the source picked\\n     */\\n    function swap(\\n        uint8 source,\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 amountIn,\\n        uint256 minAmountOut,\\n        bytes memory data\\n    ) external returns (uint256 amountOut);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\\n     * initialization.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`.\\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\\n        // This gives `2**k < a <= 2**(k+1)` \u2192 `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1;\\n        uint256 x = a;\\n        if (x >> 128 > 0) {\\n            x >>= 128;\\n            result <<= 64;\\n        }\\n        if (x >> 64 > 0) {\\n            x >>= 64;\\n            result <<= 32;\\n        }\\n        if (x >> 32 > 0) {\\n            x >>= 32;\\n            result <<= 16;\\n        }\\n        if (x >> 16 > 0) {\\n            x >>= 16;\\n            result <<= 8;\\n        }\\n        if (x >> 8 > 0) {\\n            x >>= 8;\\n            result <<= 4;\\n        }\\n        if (x >> 4 > 0) {\\n            x >>= 4;\\n            result <<= 2;\\n        }\\n        if (x >> 2 > 0) {\\n            result <<= 1;\\n        }\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = sqrt(a);\\n        if (rounding == Rounding.Up && result * result < a) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableSet.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.\\n *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n *  In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        return _values(set._inner);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/actions/BaseClaimer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@mimic-fi/v2-helpers/contracts/math/FixedPoint.sol';\\nimport '@mimic-fi/v2-smart-vaults-base/contracts/actions/BaseAction.sol';\\nimport '@mimic-fi/v2-smart-vaults-base/contracts/actions/TokenThresholdAction.sol';\\nimport '@mimic-fi/v2-smart-vaults-base/contracts/actions/RelayedAction.sol';\\n\\nimport '../interfaces/IFeeClaimer.sol';\\n\\n// solhint-disable avoid-low-level-calls\\n\\nabstract contract BaseClaimer is BaseAction, TokenThresholdAction, RelayedAction {\\n    address public feeClaimer;\\n\\n    event FeeClaimerSet(address indexed feeClaimer);\\n\\n    constructor(address admin, address registry) BaseAction(admin, registry) {\\n        // solhint-disable-previous-line no-empty-blocks\\n    }\\n\\n    function setFeeClaimer(address newFeeClaimer) external auth {\\n        feeClaimer = newFeeClaimer;\\n        emit FeeClaimerSet(newFeeClaimer);\\n    }\\n\\n    function canExecute(address token) external view virtual returns (bool);\\n\\n    function claimableBalance(address token) public view returns (uint256) {\\n        return IFeeClaimer(feeClaimer).getBalance(token, address(smartVault));\\n    }\\n\\n    function totalBalance(address token) public view returns (uint256) {\\n        return claimableBalance(token) + _balanceOf(token);\\n    }\\n\\n    function _claim(address token) internal {\\n        if (claimableBalance(token) == 0) return;\\n        bytes memory data = abi.encodeWithSelector(IFeeClaimer.withdrawAllERC20.selector, token, smartVault);\\n        bytes memory response = smartVault.call(feeClaimer, data, 0, new bytes(0));\\n        require(abi.decode(response, (bool)), 'FEE_CLAIMER_WITHDRAW_FAILED');\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/actions/ConnextBridger.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\\n\\nimport '@mimic-fi/v2-helpers/contracts/math/FixedPoint.sol';\\nimport '@mimic-fi/v2-smart-vaults-base/contracts/actions/BaseAction.sol';\\nimport '@mimic-fi/v2-smart-vaults-base/contracts/actions/TokenThresholdAction.sol';\\nimport '@mimic-fi/v2-smart-vaults-base/contracts/actions/RelayedAction.sol';\\n\\ncontract ConnextBridger is BaseAction, TokenThresholdAction, RelayedAction {\\n    using FixedPoint for uint256;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    // Base gas amount charged to cover gas payment\\n    uint256 public constant override BASE_GAS = 60e3;\\n\\n    // Connext bridge connector source ID\\n    uint8 public constant CONNEXT_BRIDGE_SOURCE = 2;\\n\\n    uint256 public maxRelayerFeePct;\\n    uint256 public destinationChainId;\\n    EnumerableSet.AddressSet private allowedTokens;\\n\\n    event AllowedTokenSet(address indexed token, bool allowed);\\n    event MaxRelayerFeePctSet(uint256 maxFeePct);\\n    event DestinationChainIdSet(uint256 indexed chainId);\\n\\n    struct Config {\\n        address admin;\\n        address registry;\\n        address smartVault;\\n        address[] allowedTokens;\\n        uint256 maxRelayerFeePct;\\n        uint256 destinationChainId;\\n        address thresholdToken;\\n        uint256 thresholdAmount;\\n        address relayer;\\n        uint256 gasPriceLimit;\\n    }\\n\\n    constructor(Config memory config) BaseAction(config.admin, config.registry) {\\n        require(address(config.smartVault) != address(0), 'SMART_VAULT_ZERO');\\n        smartVault = ISmartVault(config.smartVault);\\n        emit SmartVaultSet(config.smartVault);\\n\\n        _setMaxRelayerFeePct(config.maxRelayerFeePct);\\n        _setDestinationChainId(config.destinationChainId);\\n        for (uint256 i = 0; i < config.allowedTokens.length; i++) _setAllowedToken(config.allowedTokens[i], true);\\n\\n        thresholdToken = config.thresholdToken;\\n        thresholdAmount = config.thresholdAmount;\\n        emit ThresholdSet(config.thresholdToken, config.thresholdAmount);\\n\\n        isRelayer[config.relayer] = true;\\n        emit RelayerSet(config.relayer, true);\\n\\n        gasPriceLimit = config.gasPriceLimit;\\n        emit LimitsSet(config.gasPriceLimit, 0);\\n    }\\n\\n    function getAllowedTokensLength() external view returns (uint256) {\\n        return allowedTokens.length();\\n    }\\n\\n    function getAllowedTokens() external view returns (address[] memory) {\\n        return allowedTokens.values();\\n    }\\n\\n    function isTokenAllowed(address token) public view returns (bool) {\\n        return allowedTokens.contains(token);\\n    }\\n\\n    function setMaxRelayerFeePct(uint256 newMaxRelayerFeePct) external auth {\\n        _setMaxRelayerFeePct(newMaxRelayerFeePct);\\n    }\\n\\n    function setAllowedToken(address token, bool allowed) external auth {\\n        _setAllowedToken(token, allowed);\\n    }\\n\\n    function setDestinationChainId(uint256 chainId) external auth {\\n        _setDestinationChainId(chainId);\\n    }\\n\\n    function call(address token, uint256 amount, uint256 relayerFee) external auth nonReentrant {\\n        _initRelayedTx();\\n        require(amount > 0, 'BRIDGER_AMOUNT_ZERO');\\n        require(isTokenAllowed(token), 'BRIDGER_TOKEN_NOT_ALLOWED');\\n        require(destinationChainId != 0, 'BRIDGER_DEST_CHAIN_NOT_SET');\\n        require(relayerFee.divUp(amount) <= maxRelayerFeePct, 'BRIDGER_RELAYER_FEE_ABOVE_MAX');\\n        _validateThreshold(token, amount);\\n\\n        emit Executed();\\n        uint256 gasRefund = _payRelayedTx(token);\\n        uint256 amountToBridge = amount - gasRefund;\\n        uint256 minAmountOut = amountToBridge - relayerFee;\\n\\n        smartVault.bridge(\\n            CONNEXT_BRIDGE_SOURCE,\\n            destinationChainId,\\n            token,\\n            amountToBridge,\\n            ISmartVault.BridgeLimit.MinAmountOut,\\n            minAmountOut,\\n            address(smartVault),\\n            abi.encode(relayerFee)\\n        );\\n    }\\n\\n    function _setAllowedToken(address token, bool allowed) private {\\n        require(token != address(0), 'BRIDGER_TOKEN_ZERO');\\n        if (allowed ? allowedTokens.add(token) : allowedTokens.remove(token)) {\\n            emit AllowedTokenSet(token, allowed);\\n        }\\n    }\\n\\n    function _setMaxRelayerFeePct(uint256 newMaxRelayerFeePct) private {\\n        require(newMaxRelayerFeePct <= FixedPoint.ONE, 'BRIDGER_RELAYER_FEE_PCT_GT_ONE');\\n        maxRelayerFeePct = newMaxRelayerFeePct;\\n        emit MaxRelayerFeePctSet(newMaxRelayerFeePct);\\n    }\\n\\n    function _setDestinationChainId(uint256 chainId) private {\\n        require(chainId != block.chainid, 'BRIDGER_SAME_CHAIN_ID');\\n        destinationChainId = chainId;\\n        emit DestinationChainIdSet(chainId);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/actions/ERC20Claimer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/utils/cryptography/ECDSA.sol';\\nimport '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\\n\\nimport '@mimic-fi/v2-helpers/contracts/math/FixedPoint.sol';\\nimport '@mimic-fi/v2-helpers/contracts/math/UncheckedMath.sol';\\nimport '@mimic-fi/v2-swap-connector/contracts/ISwapConnector.sol';\\n\\nimport './BaseClaimer.sol';\\n\\ncontract ERC20Claimer is BaseClaimer {\\n    using FixedPoint for uint256;\\n    using UncheckedMath for uint256;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    // Base gas amount charged to cover gas payment\\n    uint256 public constant override BASE_GAS = 53e3;\\n\\n    address public swapSigner;\\n    uint256 public maxSlippage;\\n    EnumerableSet.AddressSet private ignoredTokenSwaps;\\n\\n    event SwapSignerSet(address indexed swapSigner);\\n    event MaxSlippageSet(uint256 maxSlippage);\\n    event IgnoreTokenSwapSet(address indexed token, bool ignored);\\n\\n    constructor(address admin, address registry) BaseClaimer(admin, registry) {\\n        // solhint-disable-previous-line no-empty-blocks\\n    }\\n\\n    function setSwapSigner(address newSwapSigner) external auth {\\n        swapSigner = newSwapSigner;\\n        emit SwapSignerSet(newSwapSigner);\\n    }\\n\\n    function setMaxSlippage(uint256 newMaxSlippage) external auth {\\n        require(newMaxSlippage <= FixedPoint.ONE, 'CLAIMER_SLIPPAGE_ABOVE_ONE');\\n        maxSlippage = newMaxSlippage;\\n        emit MaxSlippageSet(newMaxSlippage);\\n    }\\n\\n    function setIgnoreTokenSwaps(address[] memory tokens, bool[] memory ignores) external auth {\\n        require(tokens.length == ignores.length, 'IGNORE_SWAP_TOKENS_INVALID_LEN');\\n        for (uint256 i = 0; i < tokens.length; i = i.uncheckedAdd(1)) {\\n            if (ignores[i]) ignoredTokenSwaps.add(tokens[i]);\\n            else ignoredTokenSwaps.remove(tokens[i]);\\n            emit IgnoreTokenSwapSet(tokens[i], ignores[i]);\\n        }\\n    }\\n\\n    function isTokenSwapIgnored(address token) public view returns (bool) {\\n        return ignoredTokenSwaps.contains(token);\\n    }\\n\\n    function getIgnoredTokenSwaps() external view returns (address[] memory) {\\n        return ignoredTokenSwaps.values();\\n    }\\n\\n    function canExecute(address token) external view override returns (bool) {\\n        return !_isWrappedOrNativeToken(token) && totalBalance(token) > 0;\\n    }\\n\\n    function call(\\n        address tokenIn,\\n        uint256 amountIn,\\n        uint256 minAmountOut,\\n        uint256 expectedAmountOut,\\n        uint256 deadline,\\n        bytes memory data,\\n        bytes memory sig\\n    ) external auth nonReentrant {\\n        _initRelayedTx();\\n        (address token, uint256 price) = _call(tokenIn, amountIn, minAmountOut, expectedAmountOut, deadline, data, sig);\\n        _payRelayedTx(token, price);\\n    }\\n\\n    function _call(\\n        address tokenIn,\\n        uint256 amountIn,\\n        uint256 minAmountOut,\\n        uint256 expectedAmountOut,\\n        uint256 deadline,\\n        bytes memory data,\\n        bytes memory sig\\n    ) internal returns (address payingGasToken, uint256 payingGasTokenPrice) {\\n        require(!_isWrappedOrNativeToken(tokenIn), 'ERC20_CLAIMER_INVALID_TOKEN');\\n\\n        address wrappedNativeToken = smartVault.wrappedNativeToken();\\n        _validateSig(tokenIn, wrappedNativeToken, amountIn, minAmountOut, expectedAmountOut, deadline, data, sig);\\n\\n        if (isTokenSwapIgnored(tokenIn)) {\\n            // The threshold must be checked against the claimable balance, not against the amount out. The amount out\\n            // is computed considering both the claimable balance and the smart vault balance in case of a swap, but\\n            // if the token in is ignored, the smart vault balance must be ignored.\\n            // We can leverage the call information to rate the claimable balance in the wrapped native token:\\n            uint256 wrappedNativeTokenPrice = amountIn.divUp(expectedAmountOut);\\n            uint256 wrappedNativeTokenClaimableBalance = claimableBalance(tokenIn).divDown(wrappedNativeTokenPrice);\\n            _validateThreshold(wrappedNativeToken, wrappedNativeTokenClaimableBalance);\\n\\n            _claim(tokenIn);\\n            payingGasToken = tokenIn;\\n            payingGasTokenPrice = wrappedNativeTokenPrice;\\n        } else {\\n            // The threshold must be checked against the total balance (claimable balance + smart vault balance) which\\n            // is already contemplated in the amount out. We use the min amount out as it represents the minimum\\n            // amount of token out tokens we will receive for the swap to validate the threshold.\\n            _validateThreshold(wrappedNativeToken, minAmountOut);\\n            _validateSlippage(minAmountOut, expectedAmountOut);\\n\\n            _claim(tokenIn);\\n            smartVault.swap(\\n                uint8(ISwapConnector.Source.ParaswapV5),\\n                tokenIn,\\n                wrappedNativeToken,\\n                amountIn,\\n                ISmartVault.SwapLimit.MinAmountOut,\\n                minAmountOut,\\n                data\\n            );\\n\\n            payingGasToken = wrappedNativeToken;\\n            payingGasTokenPrice = FixedPoint.ONE;\\n        }\\n\\n        emit Executed();\\n    }\\n\\n    function _validateSlippage(uint256 minAmountOut, uint256 expectedAmountOut) internal view {\\n        require(minAmountOut <= expectedAmountOut, 'MIN_AMOUNT_GT_EXPECTED_AMOUNT');\\n        uint256 slippage = FixedPoint.ONE - minAmountOut.divUp(expectedAmountOut);\\n        require(slippage <= maxSlippage, 'CLAIMER_SLIPPAGE_TOO_BIG');\\n    }\\n\\n    function _validateSig(\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 amountIn,\\n        uint256 minAmountOut,\\n        uint256 expectedAmountOut,\\n        uint256 deadline,\\n        bytes memory data,\\n        bytes memory sig\\n    ) internal view {\\n        bytes32 message = _hash(tokenIn, tokenOut, amountIn, minAmountOut, expectedAmountOut, deadline, data);\\n        address signer = ECDSA.recover(ECDSA.toEthSignedMessageHash(message), sig);\\n        require(signer == swapSigner, 'INVALID_SWAP_SIGNATURE');\\n        require(block.timestamp <= deadline, 'SWAP_DEADLINE_EXPIRED');\\n    }\\n\\n    function _hash(\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 amountIn,\\n        uint256 minAmountOut,\\n        uint256 expectedAmountOut,\\n        uint256 deadline,\\n        bytes memory data\\n    ) private pure returns (bytes32) {\\n        bool isBuy = false;\\n        return\\n            keccak256(\\n                abi.encodePacked(tokenIn, tokenOut, isBuy, amountIn, minAmountOut, expectedAmountOut, deadline, data)\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/actions/ERC20Claimer2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/utils/cryptography/ECDSA.sol';\\nimport '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\\n\\nimport '@mimic-fi/v2-helpers/contracts/math/FixedPoint.sol';\\nimport '@mimic-fi/v2-helpers/contracts/math/UncheckedMath.sol';\\nimport '@mimic-fi/v2-swap-connector/contracts/ISwapConnector.sol';\\n\\nimport './BaseClaimer.sol';\\n\\ncontract ERC20Claimer2 is BaseClaimer {\\n    using FixedPoint for uint256;\\n    using UncheckedMath for uint256;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    // Base gas amount charged to cover gas payment\\n    uint256 public constant override BASE_GAS = 60e3;\\n\\n    address public tokenOut;\\n    address public swapSigner;\\n    uint256 public maxSlippage;\\n    EnumerableSet.AddressSet private ignoredTokenSwaps;\\n\\n    event TokenOutSet(address indexed tokenOut);\\n    event SwapSignerSet(address indexed swapSigner);\\n    event MaxSlippageSet(uint256 maxSlippage);\\n    event IgnoreTokenSwapSet(address indexed token, bool ignored);\\n\\n    struct Config {\\n        address admin;\\n        address registry;\\n        address smartVault;\\n        address feeClaimer;\\n        address tokenOut;\\n        address swapSigner;\\n        uint256 maxSlippage;\\n        address[] ignoreTokens;\\n        address thresholdToken;\\n        uint256 thresholdAmount;\\n        address relayer;\\n        uint256 gasPriceLimit;\\n    }\\n\\n    constructor(Config memory config) BaseClaimer(config.admin, config.registry) {\\n        smartVault = ISmartVault(config.smartVault);\\n        emit SmartVaultSet(config.smartVault);\\n\\n        feeClaimer = config.feeClaimer;\\n        emit FeeClaimerSet(config.feeClaimer);\\n\\n        _setTokenOut(config.tokenOut);\\n        _setSwapSigner(config.swapSigner);\\n        _setMaxSlippage(config.maxSlippage);\\n        for (uint256 i = 0; i < config.ignoreTokens.length; i++) {\\n            _setIgnoreTokenSwap(config.ignoreTokens[i], true);\\n        }\\n\\n        thresholdToken = config.thresholdToken;\\n        thresholdAmount = config.thresholdAmount;\\n        emit ThresholdSet(config.thresholdToken, config.thresholdAmount);\\n\\n        isRelayer[config.relayer] = true;\\n        emit RelayerSet(config.relayer, true);\\n\\n        gasPriceLimit = config.gasPriceLimit;\\n        emit LimitsSet(config.gasPriceLimit, 0);\\n    }\\n\\n    function setTokenOut(address newTokenOut) external auth {\\n        _setTokenOut(newTokenOut);\\n    }\\n\\n    function setSwapSigner(address newSwapSigner) external auth {\\n        _setSwapSigner(newSwapSigner);\\n    }\\n\\n    function setMaxSlippage(uint256 newMaxSlippage) external auth {\\n        _setMaxSlippage(newMaxSlippage);\\n    }\\n\\n    function setIgnoreTokenSwaps(address[] memory tokens, bool[] memory ignores) external auth {\\n        require(tokens.length == ignores.length, 'IGNORE_SWAP_TOKENS_INVALID_LEN');\\n        for (uint256 i = 0; i < tokens.length; i = i.uncheckedAdd(1)) {\\n            _setIgnoreTokenSwap(tokens[i], ignores[i]);\\n        }\\n    }\\n\\n    function isTokenSwapIgnored(address token) public view returns (bool) {\\n        return ignoredTokenSwaps.contains(token);\\n    }\\n\\n    function getIgnoredTokenSwaps() external view returns (address[] memory) {\\n        return ignoredTokenSwaps.values();\\n    }\\n\\n    function canExecute(address token) external view override returns (bool) {\\n        return !Denominations.isNativeToken(token) && totalBalance(token) > 0;\\n    }\\n\\n    function call(\\n        address tokenIn,\\n        uint256 amountIn,\\n        uint256 minAmountOut,\\n        uint256 expectedAmountOut,\\n        uint256 deadline,\\n        bytes memory data,\\n        bytes memory sig\\n    ) external auth nonReentrant redeemGas(tokenOut) {\\n        require(!Denominations.isNativeToken(tokenIn), 'ERC20_CLAIMER_INVALID_TOKEN');\\n        _validateSig(tokenIn, amountIn, minAmountOut, expectedAmountOut, deadline, data, sig);\\n\\n        if (isTokenSwapIgnored(tokenIn)) {\\n            // The threshold must be checked against the claimable balance, not against the amount out. The amount out\\n            // is computed considering both the claimable balance and the smart vault balance in case of a swap, but\\n            // if the token in is ignored, the smart vault balance must be ignored.\\n            // We can leverage the call information to rate the claimable balance in the token out:\\n            uint256 tokenOutPrice = amountIn.divUp(expectedAmountOut);\\n            uint256 tokenOutClaimableBalance = claimableBalance(tokenIn).divDown(tokenOutPrice);\\n            _validateThreshold(tokenOut, tokenOutClaimableBalance);\\n\\n            _claim(tokenIn);\\n        } else {\\n            // The threshold must be checked against the total balance (claimable balance + smart vault balance) which\\n            // is already contemplated in the amount out. We use the min amount out as it represents the minimum\\n            // amount of token out tokens we will receive for the swap to validate the threshold.\\n            _validateThreshold(tokenOut, minAmountOut);\\n            _validateSlippage(minAmountOut, expectedAmountOut);\\n\\n            _claim(tokenIn);\\n            smartVault.swap(\\n                uint8(ISwapConnector.Source.ParaswapV5),\\n                tokenIn,\\n                tokenOut,\\n                amountIn,\\n                ISmartVault.SwapLimit.MinAmountOut,\\n                minAmountOut,\\n                data\\n            );\\n        }\\n\\n        emit Executed();\\n    }\\n\\n    function _setTokenOut(address newTokenOut) internal {\\n        tokenOut = newTokenOut;\\n        emit TokenOutSet(newTokenOut);\\n    }\\n\\n    function _setSwapSigner(address newSwapSigner) internal {\\n        swapSigner = newSwapSigner;\\n        emit SwapSignerSet(newSwapSigner);\\n    }\\n\\n    function _setMaxSlippage(uint256 newMaxSlippage) internal {\\n        require(newMaxSlippage <= FixedPoint.ONE, 'CLAIMER_SLIPPAGE_ABOVE_ONE');\\n        maxSlippage = newMaxSlippage;\\n        emit MaxSlippageSet(newMaxSlippage);\\n    }\\n\\n    function _setIgnoreTokenSwap(address token, bool ignore) internal {\\n        if (ignore) ignoredTokenSwaps.add(token);\\n        else ignoredTokenSwaps.remove(token);\\n        emit IgnoreTokenSwapSet(token, ignore);\\n    }\\n\\n    function _validateSlippage(uint256 minAmountOut, uint256 expectedAmountOut) internal view {\\n        require(minAmountOut <= expectedAmountOut, 'MIN_AMOUNT_GT_EXPECTED_AMOUNT');\\n        uint256 slippage = FixedPoint.ONE - minAmountOut.divUp(expectedAmountOut);\\n        require(slippage <= maxSlippage, 'CLAIMER_SLIPPAGE_TOO_BIG');\\n    }\\n\\n    function _validateSig(\\n        address tokenIn,\\n        uint256 amountIn,\\n        uint256 minAmountOut,\\n        uint256 expectedAmountOut,\\n        uint256 deadline,\\n        bytes memory data,\\n        bytes memory sig\\n    ) internal view {\\n        bytes32 message = _hash(tokenIn, amountIn, minAmountOut, expectedAmountOut, deadline, data);\\n        address signer = ECDSA.recover(ECDSA.toEthSignedMessageHash(message), sig);\\n        require(signer == swapSigner, 'INVALID_SWAP_SIGNATURE');\\n        require(block.timestamp <= deadline, 'SWAP_DEADLINE_EXPIRED');\\n    }\\n\\n    function _hash(\\n        address tokenIn,\\n        uint256 amountIn,\\n        uint256 minAmountOut,\\n        uint256 expectedAmountOut,\\n        uint256 deadline,\\n        bytes memory data\\n    ) private view returns (bytes32) {\\n        bool isBuy = false;\\n        return\\n            keccak256(\\n                abi.encodePacked(tokenIn, tokenOut, isBuy, amountIn, minAmountOut, expectedAmountOut, deadline, data)\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/actions/FantomBridger.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\\n\\nimport '@mimic-fi/v2-helpers/contracts/math/FixedPoint.sol';\\nimport '@mimic-fi/v2-smart-vaults-base/contracts/actions/BaseAction.sol';\\nimport '@mimic-fi/v2-smart-vaults-base/contracts/actions/TokenThresholdAction.sol';\\nimport '@mimic-fi/v2-smart-vaults-base/contracts/actions/RelayedAction.sol';\\n\\nimport '../interfaces/IFantomAsset.sol';\\n\\ncontract FantomBridger is BaseAction, TokenThresholdAction, RelayedAction {\\n    using FixedPoint for uint256;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    // Base gas amount charged to cover gas payment\\n    uint256 public constant override BASE_GAS = 60e3;\\n\\n    EnumerableSet.AddressSet private allowedTokens;\\n\\n    event AllowedTokenSet(address indexed token, bool allowed);\\n\\n    struct Config {\\n        address admin;\\n        address registry;\\n        address smartVault;\\n        address[] allowedTokens;\\n        address thresholdToken;\\n        uint256 thresholdAmount;\\n        address relayer;\\n        uint256 gasPriceLimit;\\n    }\\n\\n    constructor(Config memory config) BaseAction(config.admin, config.registry) {\\n        require(address(config.smartVault) != address(0), 'SMART_VAULT_ZERO');\\n        smartVault = ISmartVault(config.smartVault);\\n        emit SmartVaultSet(config.smartVault);\\n\\n        for (uint256 i = 0; i < config.allowedTokens.length; i++) _setAllowedToken(config.allowedTokens[i], true);\\n\\n        thresholdToken = config.thresholdToken;\\n        thresholdAmount = config.thresholdAmount;\\n        emit ThresholdSet(config.thresholdToken, config.thresholdAmount);\\n\\n        isRelayer[config.relayer] = true;\\n        emit RelayerSet(config.relayer, true);\\n\\n        gasPriceLimit = config.gasPriceLimit;\\n        emit LimitsSet(config.gasPriceLimit, 0);\\n    }\\n\\n    function getAllowedTokensLength() external view returns (uint256) {\\n        return allowedTokens.length();\\n    }\\n\\n    function getAllowedTokens() external view returns (address[] memory) {\\n        return allowedTokens.values();\\n    }\\n\\n    function isTokenAllowed(address token) public view returns (bool) {\\n        return allowedTokens.contains(token);\\n    }\\n\\n    function setAllowedToken(address token, bool allowed) external auth {\\n        _setAllowedToken(token, allowed);\\n    }\\n\\n    function call(address token, uint256 amount) external auth nonReentrant {\\n        _initRelayedTx();\\n        require(amount > 0, 'BRIDGER_AMOUNT_ZERO');\\n        require(isTokenAllowed(token), 'BRIDGER_TOKEN_NOT_ALLOWED');\\n        _validateThreshold(token, amount);\\n\\n        emit Executed();\\n        uint256 gasRefund = _payRelayedTx(token);\\n        uint256 bridgeAmount = amount - gasRefund;\\n\\n        // solhint-disable-next-line func-name-mixedcase\\n        bytes memory data = abi.encodeWithSelector(IFantomAsset.Swapout.selector, bridgeAmount, address(smartVault));\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        smartVault.call(token, data, 0, new bytes(0));\\n    }\\n\\n    function _setAllowedToken(address token, bool allowed) private {\\n        require(token != address(0), 'BRIDGER_TOKEN_ZERO');\\n        if (allowed ? allowedTokens.add(token) : allowedTokens.remove(token)) {\\n            emit AllowedTokenSet(token, allowed);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/actions/MetamaskClaimer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/utils/cryptography/ECDSA.sol';\\n\\nimport '@mimic-fi/v2-helpers/contracts/math/FixedPoint.sol';\\nimport '@mimic-fi/v2-smart-vaults-base/contracts/actions/BaseAction.sol';\\nimport '@mimic-fi/v2-smart-vaults-base/contracts/actions/RelayedAction.sol';\\n\\nimport '../interfaces/IGnosisSafe.sol';\\nimport '../interfaces/IMetamaskFeeDistributor.sol';\\n\\nimport 'hardhat/console.sol';\\n\\ncontract MetamaskClaimer is BaseAction, RelayedAction {\\n    using ECDSA for bytes32;\\n    using FixedPoint for uint256;\\n\\n    // Base gas amount charged to cover gas payment\\n    uint256 public constant override BASE_GAS = 55e3;\\n\\n    // Address of the gnosis safe owning th metamask fee shares\\n    address public safe;\\n\\n    // Address of the metamask fee distributor contract\\n    address public metamaskFeeDistributor;\\n\\n    // Address of the token to cover the relayed gas costs\\n    address public gasToken;\\n\\n    /**\\n     * @dev Emitted every time a new safe is set\\n     */\\n    event SafeSet(address indexed safe);\\n\\n    /**\\n     * @dev Emitted every time a new metamask fee distributor is set\\n     */\\n    event MetamaskFeeDistributorSet(address indexed metamaskFeeDistributor);\\n\\n    /**\\n     * @dev Emitted every time a new gas token is set\\n     */\\n    event GasTokenSet(address indexed gasToken);\\n\\n    /**\\n     * @dev Metamask claimer action config. Only used in the constructor.\\n     */\\n    struct Config {\\n        address admin;\\n        address registry;\\n        address smartVault;\\n        address safe;\\n        address metamaskFeeDistributor;\\n        address relayer;\\n        address gasToken;\\n        uint256 gasPriceLimit;\\n    }\\n\\n    /**\\n     * @dev Creates a new metamask claimer action\\n     */\\n    constructor(Config memory config) BaseAction(config.admin, config.registry) {\\n        require(address(config.smartVault) != address(0), 'SMART_VAULT_ZERO');\\n        smartVault = ISmartVault(config.smartVault);\\n        emit SmartVaultSet(config.smartVault);\\n\\n        _setSafe(config.safe);\\n        _setMetamaskFeeDistributor(config.metamaskFeeDistributor);\\n\\n        isRelayer[config.relayer] = true;\\n        emit RelayerSet(config.relayer, true);\\n\\n        _setGasToken(config.gasToken);\\n        gasPriceLimit = config.gasPriceLimit;\\n        emit LimitsSet(config.gasPriceLimit, 0);\\n    }\\n\\n    /**\\n     * @dev Sets safe reference. Sender must be authorized.\\n     * @param newSafe Address of the new safe to be set\\n     */\\n    function setSafe(address newSafe) external auth {\\n        _setSafe(newSafe);\\n    }\\n\\n    /**\\n     * @dev Sets metamask fee distributor reference. Sender must be authorized.\\n     * @param newMetamaskFeeDistributor Address of the new metamask fee distributor to be set\\n     */\\n    function setMetamaskFeeDistributor(address newMetamaskFeeDistributor) external auth {\\n        _setMetamaskFeeDistributor(newMetamaskFeeDistributor);\\n    }\\n\\n    /**\\n     * @dev Sets the paying gas token. Sender must be authorized.\\n     * @param newGasToken Address of the new gas token to pay for relayed transactions\\n     */\\n    function setGasToken(address newGasToken) external auth {\\n        _setGasToken(newGasToken);\\n    }\\n\\n    /**\\n     * @dev Claims all the available balance for a given token in the metamask fee distributor\\n     * @param token Address of the token to be claimed\\n     */\\n    function call(address token) external auth nonReentrant redeemGas(gasToken) {\\n        require(IGnosisSafe(safe).isOwner(address(smartVault)), 'SMART_VAULT_NOT_SAFE_OWNER');\\n\\n        uint256 balance = IMetamaskFeeDistributor(metamaskFeeDistributor).available(token, safe);\\n        require(balance > 0, 'METAMASK_CLAIMER_AMOUNT_ZERO');\\n\\n        bytes memory contractSignature = abi.encodePacked(\\n            uint256(uint160(address(smartVault))),\\n            bytes32(0),\\n            bytes1(0x01)\\n        );\\n\\n        _claimTokens(token, contractSignature);\\n        _transferTokens(token, balance, contractSignature);\\n        emit Executed();\\n    }\\n\\n    /**\\n     * @dev Executes a transaction on the safe to claim all the available tokens in metamask's distributor\\n     * @param token Address of the token to be claimed\\n     * @param contractSignature Signature for the safe\\n     */\\n    function _claimTokens(address token, bytes memory contractSignature) internal {\\n        address[] memory tokens = new address[](1);\\n        tokens[0] = token;\\n        bytes memory metamaskClaimData = abi.encodeWithSelector(IMetamaskFeeDistributor.withdraw.selector, tokens);\\n        bytes memory safeClaimData = abi.encodeWithSelector(\\n            IGnosisSafe.execTransaction.selector,\\n            metamaskFeeDistributor,\\n            0,\\n            metamaskClaimData,\\n            IGnosisSafe.Operation.Call,\\n            0,\\n            0,\\n            0,\\n            address(0),\\n            address(0),\\n            contractSignature\\n        );\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        smartVault.call(safe, safeClaimData, 0, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Executes a transaction on the safe to transfer an amount of tokens to the smart vault\\n     * @param token Address of the token to be transferred\\n     * @param amount Amount of tokens to be transferred\\n     * @param contractSignature Signature for the safe\\n     */\\n    function _transferTokens(address token, uint256 amount, bytes memory contractSignature) internal {\\n        bytes memory tokenTransferData = abi.encodeWithSelector(IERC20.transfer.selector, address(smartVault), amount);\\n        bytes memory safeTransferData = abi.encodeWithSelector(\\n            IGnosisSafe.execTransaction.selector,\\n            token,\\n            0,\\n            tokenTransferData,\\n            IGnosisSafe.Operation.Call,\\n            0,\\n            0,\\n            0,\\n            address(0),\\n            address(0),\\n            contractSignature\\n        );\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        smartVault.call(safe, safeTransferData, 0, new bytes(0));\\n    }\\n\\n    /**\\n     * @dev Sets safe reference\\n     * @param newSafe Address of the new safe to be set\\n     */\\n    function _setSafe(address newSafe) private {\\n        safe = newSafe;\\n        emit SafeSet(newSafe);\\n    }\\n\\n    /**\\n     * @dev Sets metamask fee distributor reference\\n     * @param newMetamaskFeeDistributor Address of the new metamask fee distributor to be set\\n     */\\n    function _setMetamaskFeeDistributor(address newMetamaskFeeDistributor) private {\\n        metamaskFeeDistributor = newMetamaskFeeDistributor;\\n        emit MetamaskFeeDistributorSet(newMetamaskFeeDistributor);\\n    }\\n\\n    /**\\n     * @dev Sets the paying gas token\\n     * @param newGasToken Address of the new gas token to pay for relayed transactions\\n     */\\n    function _setGasToken(address newGasToken) private {\\n        require(newGasToken != address(0), 'GAS_TOKEN_ZERO');\\n        gasToken = newGasToken;\\n        emit GasTokenSet(newGasToken);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/actions/NativeClaimer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport './BaseClaimer.sol';\\n\\ncontract NativeClaimer is BaseClaimer {\\n    // Base gas amount charged to cover gas payment\\n    uint256 public constant override BASE_GAS = 65e3;\\n\\n    constructor(address admin, address registry) BaseClaimer(admin, registry) {\\n        // solhint-disable-previous-line no-empty-blocks\\n    }\\n\\n    function canExecute(address token) external view override returns (bool) {\\n        return\\n            _isWrappedOrNativeToken(token) &&\\n            _passesThreshold(smartVault.wrappedNativeToken(), _thresholdBalance(token));\\n    }\\n\\n    function call(address token) external auth nonReentrant redeemGas(_wrappedIfNative(token)) {\\n        require(_isWrappedOrNativeToken(token), 'NATIVE_CLAIMER_INVALID_TOKEN');\\n        _validateThreshold(smartVault.wrappedNativeToken(), _thresholdBalance(token));\\n\\n        _claim(token);\\n        if (Denominations.isNativeToken(token)) smartVault.wrap(address(smartVault).balance, new bytes(0));\\n        emit Executed();\\n    }\\n\\n    function _thresholdBalance(address token) internal view returns (uint256) {\\n        uint256 amountToClaim = claimableBalance(token);\\n        uint256 wrappableBalance = Denominations.isNativeToken(token) ? address(smartVault).balance : 0;\\n        return amountToClaim + wrappableBalance;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/actions/SwapFeeSetter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@mimic-fi/v2-smart-vaults-base/contracts/actions/TimeLockedAction.sol';\\n\\ncontract SwapFeeSetter is BaseAction, TimeLockedAction {\\n    struct Fee {\\n        uint256 pct;\\n        uint256 cap;\\n        address token;\\n        uint256 period;\\n    }\\n\\n    Fee[] public fees;\\n    uint256 public nextFeeIndex;\\n\\n    event FeesSet(Fee[] fees);\\n\\n    constructor(address admin, address registry) BaseAction(admin, registry) {\\n        // solhint-disable-previous-line no-empty-blocks\\n    }\\n\\n    function canExecute() external view returns (bool) {\\n        return fees.length > 0 && nextFeeIndex < fees.length && _passesTimeLock();\\n    }\\n\\n    function setFees(Fee[] memory _fees) external auth {\\n        require(fees.length == 0, 'FEES_ALREADY_SET');\\n        for (uint256 i = 0; i < _fees.length; i++) fees.push(_fees[i]);\\n        emit FeesSet(_fees);\\n    }\\n\\n    function call() external auth nonReentrant {\\n        require(fees.length > 0, 'FEES_NOT_SET');\\n        require(nextFeeIndex < fees.length, 'FEE_CONFIGS_ALREADY_EXECUTED');\\n        _validateTimeLock();\\n\\n        Fee memory fee = fees[nextFeeIndex++];\\n        smartVault.setSwapFee(fee.pct, fee.cap, fee.token, fee.period);\\n        emit Executed();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/actions/Withdrawer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@mimic-fi/v2-smart-vaults-base/contracts/actions/BaseAction.sol';\\nimport '@mimic-fi/v2-smart-vaults-base/contracts/actions/RelayedAction.sol';\\nimport '@mimic-fi/v2-smart-vaults-base/contracts/actions/TimeLockedAction.sol';\\nimport '@mimic-fi/v2-smart-vaults-base/contracts/actions/TokenThresholdAction.sol';\\nimport '@mimic-fi/v2-smart-vaults-base/contracts/actions/WithdrawalAction.sol';\\n\\ncontract Withdrawer is BaseAction, RelayedAction, TimeLockedAction, TokenThresholdAction, WithdrawalAction {\\n    // Base gas amount charged to cover gas payment\\n    uint256 public constant override BASE_GAS = 100e3;\\n\\n    constructor(\\n        address _smartVault,\\n        address _recipient,\\n        uint256 _timeLock,\\n        address _thresholdToken,\\n        uint256 _thresholdAmount,\\n        address _relayer,\\n        uint256 _gasPriceLimit,\\n        uint256 _txCostLimit,\\n        address _admin,\\n        address _registry\\n    ) BaseAction(_admin, _registry) {\\n        require(_smartVault != address(0), 'WITHDRAWER_SMART_VAULT_ZERO');\\n        smartVault = ISmartVault(_smartVault);\\n        emit SmartVaultSet(_smartVault);\\n\\n        require(_recipient != address(0), 'WITHDRAWER_RECIPIENT_ZERO');\\n        recipient = _recipient;\\n        emit RecipientSet(_recipient);\\n\\n        if (_timeLock > 0) {\\n            period = _timeLock;\\n            emit TimeLockSet(_timeLock);\\n        }\\n\\n        if (_thresholdToken != address(0) && _thresholdAmount > 0) {\\n            thresholdToken = _thresholdToken;\\n            thresholdAmount = _thresholdAmount;\\n            emit ThresholdSet(_thresholdToken, _thresholdAmount);\\n        }\\n\\n        if (_relayer != address(0)) {\\n            isRelayer[_relayer] = true;\\n            emit RelayerSet(_relayer, true);\\n        }\\n\\n        if (_gasPriceLimit > 0 || _txCostLimit > 0) {\\n            gasPriceLimit = _gasPriceLimit;\\n            txCostLimit = _txCostLimit;\\n            emit LimitsSet(_gasPriceLimit, _txCostLimit);\\n        }\\n    }\\n\\n    function call(address token) external auth nonReentrant {\\n        _initRelayedTx();\\n        _validateTimeLock();\\n\\n        uint256 amount = _balanceOf(token);\\n        _validateThreshold(token, amount);\\n        emit Executed();\\n\\n        _payRelayedTx(token);\\n        _withdraw(token);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/actions/WormholeBridger.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\\n\\nimport '@mimic-fi/v2-helpers/contracts/math/FixedPoint.sol';\\nimport '@mimic-fi/v2-smart-vaults-base/contracts/actions/BaseAction.sol';\\nimport '@mimic-fi/v2-smart-vaults-base/contracts/actions/TokenThresholdAction.sol';\\nimport '@mimic-fi/v2-smart-vaults-base/contracts/actions/RelayedAction.sol';\\n\\ncontract WormholeBridger is BaseAction, TokenThresholdAction, RelayedAction {\\n    using FixedPoint for uint256;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    // Base gas amount charged to cover gas payment\\n    uint256 public constant override BASE_GAS = 60e3;\\n\\n    // Wormhole bridge connector source ID\\n    uint8 public constant WORMHOLE_BRIDGE_SOURCE = 3;\\n\\n    uint256 public maxRelayerFeePct;\\n    uint256 public destinationChainId;\\n    EnumerableSet.AddressSet private allowedTokens;\\n\\n    event AllowedTokenSet(address indexed token, bool allowed);\\n    event MaxRelayerFeePctSet(uint256 maxFeePct);\\n    event DestinationChainIdSet(uint256 indexed chainId);\\n\\n    struct Config {\\n        address admin;\\n        address registry;\\n        address smartVault;\\n        address[] allowedTokens;\\n        uint256 maxRelayerFeePct;\\n        uint256 destinationChainId;\\n        address thresholdToken;\\n        uint256 thresholdAmount;\\n        address relayer;\\n        uint256 gasPriceLimit;\\n    }\\n\\n    constructor(Config memory config) BaseAction(config.admin, config.registry) {\\n        require(address(config.smartVault) != address(0), 'SMART_VAULT_ZERO');\\n        smartVault = ISmartVault(config.smartVault);\\n        emit SmartVaultSet(config.smartVault);\\n\\n        _setMaxRelayerFeePct(config.maxRelayerFeePct);\\n        _setDestinationChainId(config.destinationChainId);\\n        for (uint256 i = 0; i < config.allowedTokens.length; i++) _setAllowedToken(config.allowedTokens[i], true);\\n\\n        thresholdToken = config.thresholdToken;\\n        thresholdAmount = config.thresholdAmount;\\n        emit ThresholdSet(config.thresholdToken, config.thresholdAmount);\\n\\n        isRelayer[config.relayer] = true;\\n        emit RelayerSet(config.relayer, true);\\n\\n        gasPriceLimit = config.gasPriceLimit;\\n        emit LimitsSet(config.gasPriceLimit, 0);\\n    }\\n\\n    function getAllowedTokensLength() external view returns (uint256) {\\n        return allowedTokens.length();\\n    }\\n\\n    function getAllowedTokens() external view returns (address[] memory) {\\n        return allowedTokens.values();\\n    }\\n\\n    function isTokenAllowed(address token) public view returns (bool) {\\n        return allowedTokens.contains(token);\\n    }\\n\\n    function setMaxRelayerFeePct(uint256 newMaxRelayerFeePct) external auth {\\n        _setMaxRelayerFeePct(newMaxRelayerFeePct);\\n    }\\n\\n    function setAllowedToken(address token, bool allowed) external auth {\\n        _setAllowedToken(token, allowed);\\n    }\\n\\n    function setDestinationChainId(uint256 chainId) external auth {\\n        _setDestinationChainId(chainId);\\n    }\\n\\n    function call(address token, uint256 amount, uint256 relayerFee) external auth nonReentrant {\\n        _initRelayedTx();\\n        require(amount > 0, 'BRIDGER_AMOUNT_ZERO');\\n        require(isTokenAllowed(token), 'BRIDGER_TOKEN_NOT_ALLOWED');\\n        require(destinationChainId != 0, 'BRIDGER_DEST_CHAIN_NOT_SET');\\n        require(relayerFee.divUp(amount) <= maxRelayerFeePct, 'BRIDGER_RELAYER_FEE_ABOVE_MAX');\\n        _validateThreshold(token, amount);\\n\\n        emit Executed();\\n        uint256 gasRefund = _payRelayedTx(token);\\n        uint256 amountToBridge = amount - gasRefund;\\n        uint256 minAmountOut = amountToBridge - relayerFee;\\n\\n        smartVault.bridge(\\n            WORMHOLE_BRIDGE_SOURCE,\\n            destinationChainId,\\n            token,\\n            amountToBridge,\\n            ISmartVault.BridgeLimit.MinAmountOut,\\n            minAmountOut,\\n            address(smartVault),\\n            new bytes(0)\\n        );\\n    }\\n\\n    function _setAllowedToken(address token, bool allowed) private {\\n        require(token != address(0), 'BRIDGER_TOKEN_ZERO');\\n        if (allowed ? allowedTokens.add(token) : allowedTokens.remove(token)) {\\n            emit AllowedTokenSet(token, allowed);\\n        }\\n    }\\n\\n    function _setMaxRelayerFeePct(uint256 newMaxRelayerFeePct) private {\\n        require(newMaxRelayerFeePct <= FixedPoint.ONE, 'BRIDGER_RELAYER_FEE_PCT_GT_ONE');\\n        maxRelayerFeePct = newMaxRelayerFeePct;\\n        emit MaxRelayerFeePctSet(newMaxRelayerFeePct);\\n    }\\n\\n    function _setDestinationChainId(uint256 chainId) private {\\n        require(chainId != block.chainid, 'BRIDGER_SAME_CHAIN_ID');\\n        destinationChainId = chainId;\\n        emit DestinationChainIdSet(chainId);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IEIP1271.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IEIP1271 {\\n    // bytes4 internal constant EIP1271_MAGIC_VALUE = 0x20c13b0b;\\n\\n    /**\\n     * @notice Legacy EIP1271 method to validate a signature.\\n     * @param data Arbitrary length data signed on the behalf of address(this).\\n     * @param signature Signature byte array associated with _data.\\n     *\\n     * MUST return the bytes4 magic value 0x20c13b0b when function passes.\\n     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\\n     * MUST allow external calls\\n     */\\n    function isValidSignature(bytes memory data, bytes memory signature) external view returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFantomAsset.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\ninterface IFantomAsset {\\n    // solhint-disable-next-line func-name-mixedcase\\n    function Swapout(uint256 amount, address bindaddr) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFeeClaimer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\ninterface IFeeClaimer {\\n    function augustusSwapper() external view returns (address);\\n\\n    function getBalance(address token, address partner) external view returns (uint256);\\n\\n    function registerFee(address account, address token, uint256 fee) external;\\n\\n    function withdrawAllERC20(address token, address recipient) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGnosisSafe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\ninterface IGnosisSafe {\\n    enum Operation {\\n        Call,\\n        DelegateCall\\n    }\\n\\n    function isOwner(address owner) external view returns (bool);\\n\\n    /// @dev Allows to execute a Safe transaction confirmed by required number of owners and then pays the account that submitted the transaction.\\n    ///      Note: The fees are always transferred, even if the user transaction fails.\\n    /// @param to Destination address of Safe transaction.\\n    /// @param value Ether value of Safe transaction.\\n    /// @param data Data payload of Safe transaction.\\n    /// @param operation Operation type of Safe transaction.\\n    /// @param safeTxGas Gas that should be used for the Safe transaction.\\n    /// @param baseGas Gas costs that are independent of the transaction execution(e.g. base transaction fee, signature check, payment of the refund)\\n    /// @param gasPrice Gas price that should be used for the payment calculation.\\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\\n    /// @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})\\n    function execTransaction(\\n        address to,\\n        uint256 value,\\n        bytes calldata data,\\n        Operation operation,\\n        uint256 safeTxGas,\\n        uint256 baseGas,\\n        uint256 gasPrice,\\n        address gasToken,\\n        address payable refundReceiver,\\n        bytes memory signatures\\n    ) external payable returns (bool success);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMetamaskFeeDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\ninterface IMetamaskFeeDistributor {\\n    /**\\n     * @dev Returns the amount of ETH or ERC20 tokens a recipient can withdraw\\n     * @param token Token address (address(0) for ETH)\\n     * @param recipient Address of the recipient\\n     */\\n    function available(address token, address recipient) external view returns (uint256);\\n\\n    /**\\n     * @dev Withdraws the specified tokens or ETH\\n     * @param tokens Array of tokens to withdraw\\n     */\\n    function withdraw(address[] calldata tokens) external;\\n}\\n\"\r\n    },\r\n    \"contracts/SmartVaultDeployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@mimic-fi/v2-helpers/contracts/utils/Arrays.sol';\\nimport '@mimic-fi/v2-helpers/contracts/math/UncheckedMath.sol';\\nimport '@mimic-fi/v2-registry/contracts/registry/IRegistry.sol';\\nimport '@mimic-fi/v2-smart-vault/contracts/SmartVault.sol';\\nimport '@mimic-fi/v2-smart-vaults-base/contracts/deploy/Deployer.sol';\\n\\nimport './actions/ERC20Claimer.sol';\\nimport './actions/NativeClaimer.sol';\\nimport './actions/SwapFeeSetter.sol';\\n\\n// solhint-disable avoid-low-level-calls\\n\\ncontract SmartVaultDeployer {\\n    using UncheckedMath for uint256;\\n\\n    struct Params {\\n        address mimic;\\n        IRegistry registry;\\n        ERC20ClaimerActionParams erc20ClaimerActionParams;\\n        NativeClaimerActionParams nativeClaimerActionParams;\\n        SwapFeeSetterActionParams swapFeeSetterActionParams;\\n        Deployer.SmartVaultParams smartVaultParams;\\n    }\\n\\n    struct NativeClaimerActionParams {\\n        address impl;\\n        address admin;\\n        address[] managers;\\n        FeeClaimerParams feeClaimerParams;\\n    }\\n\\n    struct ERC20ClaimerActionParams {\\n        address impl;\\n        address admin;\\n        address[] managers;\\n        address swapSigner;\\n        uint256 maxSlippage;\\n        address[] tokenSwapIgnores;\\n        FeeClaimerParams feeClaimerParams;\\n    }\\n\\n    struct FeeClaimerParams {\\n        address feeClaimer;\\n        Deployer.RelayedActionParams relayedActionParams;\\n        Deployer.TokenThresholdActionParams tokenThresholdActionParams;\\n    }\\n\\n    struct SwapFeeSetterActionParams {\\n        address impl;\\n        address admin;\\n        address[] managers;\\n        Deployer.SmartVaultFeeParams[] feeParams;\\n        Deployer.TimeLockedActionParams timeLockedActionParams;\\n    }\\n\\n    function deploy(Params memory params) external {\\n        SmartVault smartVault = Deployer.createSmartVault(params.registry, params.smartVaultParams, false);\\n        _setupERC20ClaimerAction(smartVault, params.erc20ClaimerActionParams, params.mimic);\\n        _setupNativeClaimerAction(smartVault, params.nativeClaimerActionParams, params.mimic);\\n        _setupSwapFeeSetterAction(smartVault, params.swapFeeSetterActionParams, params.mimic);\\n        Deployer.grantAdminPermissions(smartVault, params.mimic);\\n        Deployer.transferAdminPermissions(smartVault, params.smartVaultParams.admin);\\n    }\\n\\n    function _setupSwapFeeSetterAction(SmartVault smartVault, SwapFeeSetterActionParams memory params, address mimic)\\n        internal\\n    {\\n        // Create and setup action\\n        SwapFeeSetter setter = SwapFeeSetter(params.impl);\\n        Deployer.setupBaseAction(setter, params.admin, address(smartVault));\\n        address[] memory executors = Arrays.from(params.admin, params.managers, new address[](0));\\n        Deployer.setupActionExecutors(setter, executors, setter.call.selector);\\n        Deployer.setupTimeLockedAction(setter, params.admin, params.timeLockedActionParams);\\n\\n        // Set fees, no need to authorize admin, fees can only be set once\\n        setter.authorize(address(this), setter.setFees.selector);\\n        setter.setFees(_castToFeeParams(params.feeParams));\\n        setter.unauthorize(address(this), setter.setFees.selector);\\n        Deployer.grantAdminPermissions(setter, mimic);\\n        Deployer.transferAdminPermissions(setter, params.admin);\\n\\n        // Authorize action to withdraw and set swap fee\\n        smartVault.authorize(address(setter), smartVault.withdraw.selector);\\n        smartVault.authorize(address(setter), smartVault.setSwapFee.selector);\\n        smartVault.unauthorize(params.admin, smartVault.setSwapFee.selector);\\n    }\\n\\n    function _setupNativeClaimerAction(SmartVault smartVault, NativeClaimerActionParams memory params, address mimic)\\n        internal\\n    {\\n        // Create and setup action\\n        NativeClaimer claimer = NativeClaimer(params.impl);\\n        Deployer.setupBaseAction(claimer, params.admin, address(smartVault));\\n        address[] memory executors = Arrays.from(\\n            params.admin,\\n            params.managers,\\n            params.feeClaimerParams.relayedActionParams.relayers\\n        );\\n        Deployer.setupActionExecutors(claimer, executors, claimer.call.selector);\\n        Deployer.setupRelayedAction(claimer, params.admin, params.feeClaimerParams.relayedActionParams);\\n        _setupBaseClaimerAction(claimer, params.admin, params.feeClaimerParams);\\n        Deployer.grantAdminPermissions(claimer, mimic);\\n        Deployer.transferAdminPermissions(claimer, params.admin);\\n\\n        // Authorize action to call and wrap\\n        smartVault.authorize(address(claimer), smartVault.call.selector);\\n        smartVault.authorize(address(claimer), smartVault.wrap.selector);\\n        smartVault.authorize(address(claimer), smartVault.withdraw.selector);\\n    }\\n\\n    function _setupERC20ClaimerAction(SmartVault smartVault, ERC20ClaimerActionParams memory params, address mimic)\\n        internal\\n    {\\n        // Create and setup action\\n        ERC20Claimer claimer = ERC20Claimer(params.impl);\\n        Deployer.setupBaseAction(claimer, params.admin, address(smartVault));\\n        address[] memory executors = Arrays.from(\\n            params.admin,\\n            params.managers,\\n            params.feeClaimerParams.relayedActionParams.relayers\\n        );\\n        Deployer.setupActionExecutors(claimer, executors, claimer.call.selector);\\n        Deployer.setupRelayedAction(claimer, params.admin, params.feeClaimerParams.relayedActionParams);\\n        _setupBaseClaimerAction(claimer, params.admin, params.feeClaimerParams);\\n        _setupSwapSignerAction(claimer, params.admin, params.swapSigner);\\n        _setupMaxSlippageAction(claimer, params.admin, params.maxSlippage);\\n        _setupTokenSwapIgnoresAction(claimer, params.admin, params.tokenSwapIgnores);\\n        Deployer.grantAdminPermissions(claimer, mimic);\\n        Deployer.transferAdminPermissions(claimer, params.admin);\\n\\n        // Authorize action to call and swap\\n        smartVault.authorize(address(claimer), smartVault.call.selector);\\n        smartVault.authorize(address(claimer), smartVault.swap.selector);\\n        smartVault.authorize(address(claimer), smartVault.withdraw.selector);\\n    }\\n\\n    function _setupBaseClaimerAction(BaseClaimer claimer, address admin, FeeClaimerParams memory params) internal {\\n        Deployer.setupTokenThresholdAction(claimer, admin, params.tokenThresholdActionParams);\\n\\n        claimer.authorize(admin, claimer.setFeeClaimer.selector);\\n        claimer.authorize(address(this), claimer.setFeeClaimer.selector);\\n        claimer.setFeeClaimer(params.feeClaimer);\\n        claimer.unauthorize(address(this), claimer.setFeeClaimer.selector);\\n    }\\n\\n    function _setupSwapSignerAction(ERC20Claimer claimer, address admin, address signer) internal {\\n        claimer.authorize(admin, claimer.setSwapSigner.selector);\\n        claimer.authorize(address(this), claimer.setSwapSigner.selector);\\n        claimer.setSwapSigner(signer);\\n        claimer.unauthorize(address(this), claimer.setSwapSigner.selector);\\n    }\\n\\n    function _setupMaxSlippageAction(ERC20Claimer claimer, address admin, uint256 maxSlippage) internal {\\n        claimer.authorize(admin, claimer.setMaxSlippage.selector);\\n        claimer.authorize(address(this), claimer.setMaxSlippage.selector);\\n        claimer.setMaxSlippage(maxSlippage);\\n        claimer.unauthorize(address(this), claimer.setMaxSlippage.selector);\\n    }\\n\\n    function _setupTokenSwapIgnoresAction(ERC20Claimer claimer, address admin, address[] memory ignores) internal {\\n        claimer.authorize(admin, claimer.setIgnoreTokenSwaps.selector);\\n        claimer.authorize(address(this), claimer.setIgnoreTokenSwaps.selector);\\n        claimer.setIgnoreTokenSwaps(ignores, _trues(ignores.length));\\n        claimer.unauthorize(address(this), claimer.setIgnoreTokenSwaps.selector);\\n    }\\n\\n    function _castToFeeParams(Deployer.SmartVaultFeeParams[] memory params)\\n        internal\\n        pure\\n        returns (SwapFeeSetter.Fee[] memory result)\\n    {\\n        assembly {\\n            result := params\\n        }\\n    }\\n\\n    function _trues(uint256 length) internal pure returns (bool[] memory arr) {\\n        arr = new bool[](length);\\n        for (uint256 i = 0; i < length; i = i.uncheckedAdd(1)) arr[i] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/FantomAssetMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\\n\\ncontract FantomAssetMock is ERC20 {\\n    event LogSwapout(address indexed account, address indexed bindaddr, uint256 amount);\\n\\n    constructor(string memory symbol) ERC20(symbol, symbol) {\\n        // solhint-disable-previous-line no-empty-blocks\\n    }\\n\\n    function mint(address account, uint256 amount) external {\\n        _mint(account, amount);\\n    }\\n\\n    function burn(address account, uint256 amount) external {\\n        _burn(account, amount);\\n    }\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function Swapout(uint256 amount, address bindaddr) public returns (bool) {\\n        require(bindaddr != address(0), 'bind address is the zero address');\\n        _burn(msg.sender, amount);\\n        emit LogSwapout(msg.sender, bindaddr, amount);\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/FeeClaimerMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/utils/Address.sol';\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\\n\\nimport '@mimic-fi/v2-helpers/contracts/utils/Denominations.sol';\\nimport '@mimic-fi/v2-helpers/contracts/utils/ERC20Helpers.sol';\\n\\nimport '../interfaces/IFeeClaimer.sol';\\n\\ncontract FeeClaimerMock is IFeeClaimer {\\n    bool public fail;\\n\\n    receive() external payable {\\n        // solhint-disable-previous-line no-empty-blocks\\n    }\\n\\n    function mockFail(bool _fail) external {\\n        fail = _fail;\\n    }\\n\\n    function augustusSwapper() external pure override returns (address) {\\n        return address(0);\\n    }\\n\\n    function getBalance(address token, address) external view override returns (uint256) {\\n        return ERC20Helpers.balanceOf(token, address(this));\\n    }\\n\\n    function registerFee(address, address, uint256) external override {\\n        // solhint-disable-previous-line no-empty-blocks\\n    }\\n\\n    function withdrawAllERC20(address token, address recipient) external override returns (bool) {\\n        uint256 balance = ERC20Helpers.balanceOf(token, address(this));\\n        if (balance > 0) ERC20Helpers.transfer(token, recipient, balance);\\n        return !fail;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/test/MetamaskFeeDistributorMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nimport '../interfaces/IMetamaskFeeDistributor.sol';\\n\\ncontract MetamaskFeeDistributorMock is IMetamaskFeeDistributor {\\n    // List of assigned balances from token => owner => balance\\n    mapping (address => mapping (address => uint256)) internal _balances;\\n\\n    function available(address token, address owner) public view override returns (uint256) {\\n        return _balances[token][owner];\\n    }\\n\\n    function assign(address token, uint256 amount, address owner) external {\\n        IERC20(token).transferFrom(msg.sender, address(this), amount);\\n        _balances[token][owner] += amount;\\n    }\\n\\n    function withdraw(address[] memory tokens) external override {\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            uint256 amount = available(tokens[i], msg.sender);\\n            _balances[tokens[i]][msg.sender] -= amount;\\n            IERC20(tokens[i]).transfer(msg.sender, amount);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"hardhat/console.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"registry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"smartVault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"safe\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"metamaskFeeDistributor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"gasToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasPriceLimit\",\"type\":\"uint256\"}],\"internalType\":\"struct MetamaskClaimer.Config\",\"name\":\"config\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"what\",\"type\":\"bytes4\"}],\"name\":\"Authorized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Executed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gasToken\",\"type\":\"address\"}],\"name\":\"GasTokenSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasPriceLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"txCostLimit\",\"type\":\"uint256\"}],\"name\":\"LimitsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"metamaskFeeDistributor\",\"type\":\"address\"}],\"name\":\"MetamaskFeeDistributorSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"RelayerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"safe\",\"type\":\"address\"}],\"name\":\"SafeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"smartVault\",\"type\":\"address\"}],\"name\":\"SmartVaultSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"what\",\"type\":\"bytes4\"}],\"name\":\"Unauthorized\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ANY_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BASE_GAS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NAMESPACE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"what\",\"type\":\"bytes4\"}],\"name\":\"authorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"call\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasPriceLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"what\",\"type\":\"bytes4\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isRelayer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metamaskFeeDistributor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safe\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGasToken\",\"type\":\"address\"}],\"name\":\"setGasToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gasPriceLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_txCostLimit\",\"type\":\"uint256\"}],\"name\":\"setLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMetamaskFeeDistributor\",\"type\":\"address\"}],\"name\":\"setMetamaskFeeDistributor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"setRelayer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newSafe\",\"type\":\"address\"}],\"name\":\"setSafe\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newSmartVault\",\"type\":\"address\"}],\"name\":\"setSmartVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"smartVault\",\"outputs\":[{\"internalType\":\"contract ISmartVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"txCostLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"what\",\"type\":\"bytes4\"}],\"name\":\"unauthorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MetamaskClaimer", "CompilerVersion": "v0.8.3+commit.8d00100c", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "00000000000000000000000071007481ba4d4c34eeb9f1288e591be61a9c607f000000000000000000000000de6d4872c0c8167fb4f405c7854fd2fed7edca21000000000000000000000000d5b927956057075377263aab7f8afc12f85100db000000000000000000000000cbb65ad3e64f404b5411486e15561bfb645ce642000000000000000000000000e5e7116ab49666e9791f53aed4f5b7207770879d000000000000000000000000b3afb6db38a8e72905165c1fbb96772e635607900000000000000000000000002170ed0880ac9a755fd29b2688956bd959f933f800000000000000000000000000000000000000000000000000000002540be400", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}