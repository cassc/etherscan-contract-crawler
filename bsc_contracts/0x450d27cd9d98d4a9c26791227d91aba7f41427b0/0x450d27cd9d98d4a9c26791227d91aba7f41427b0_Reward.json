{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.2;\r\n\r\nabstract contract ERC20 {\r\n    function name() external view virtual returns (string memory);\r\n    function symbol() external view virtual returns (string memory);\r\n    function decimals() external view virtual returns (uint8);\r\n    function totalSupply() external view virtual returns (uint256);\r\n    function balanceOf(address _owner) external view virtual returns (uint256);\r\n    function allowance(address _owner, address _spender) external view virtual returns (uint256);\r\n    function transfer(address _to, uint256 _value) external virtual returns (bool);\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    ) external virtual returns (bool);\r\n\r\n    function approve(address _spender, uint256 _value) external virtual returns (bool);\r\n}\r\n\r\nabstract contract StakeContract {\r\n    struct ParticipantInfo {\r\n        uint deposits;\r\n        uint withdrawals;\r\n        uint stakes;\r\n        uint unstakes;\r\n        uint claims;\r\n    }\r\n\r\n    //function feeTo() external view virtual returns (address);\r\n    //function owner() external view virtual returns (address);\r\n    function participants(address player) external view virtual returns (ParticipantInfo memory);\r\n}\r\n\r\ncontract Reward\r\n{\r\n    uint256 ONE_HUNDRED     = 100000000000000000000;\r\n\r\n    struct RewardModel {\r\n        uint code;\r\n        uint frequencyinseconds;\r\n        uint mindeposittimes;\r\n        uint minwithdrawtimes;\r\n        uint minstaketimes;\r\n        uint minunstaketimes;\r\n        uint minbalanceincoin;\r\n        address coinaddresstocheckbalance;\r\n        uint256 maxprizeinpercent;\r\n        uint256 minprizeinpercent;\r\n        address coinprizeaddress;\r\n        uint256 bag;\r\n        uint active;\r\n    }\r\n\r\n    struct PrizeModel{\r\n        uint code;\r\n        uint256 value;\r\n        uint time;\r\n    }\r\n\r\n    //Reward records code => RewardModel\r\n    mapping(uint => RewardModel) internal records;\r\n\r\n    //Player prize address => code => PrizeModel\r\n    mapping(address => mapping(uint => PrizeModel)) public lastprize;\r\n\r\n    event OnPrize(address player, uint code, uint time, uint256 value, uint256 bag);\r\n\r\n    address public owner;\r\n    address public stakecontract;\r\n\r\n    constructor(address _stakecontract) {\r\n        owner = msg.sender;\r\n        stakecontract = _stakecontract;\r\n    }\r\n\r\n    function setOwner(address _newValue) public returns (bool success)\r\n    {\r\n        require(msg.sender == owner, 'Forbidden');\r\n\r\n        owner = _newValue;\r\n        return true;\r\n    }\r\n\r\n    function setReward(uint _code, uint _frequencyinseconds, uint _mindeposittimes, uint _minwithdrawtimes, uint _minstaketimes, uint _minunstaketimes,\r\n                        uint _minbalanceincoin, address _coinaddresstocheckbalance, uint256 _maxprizeinpercent, uint256 _minprizeinpercent,\r\n                        address _coinprizeaddress) external returns (bool success)\r\n    {\r\n\r\n        require(_minprizeinpercent <= ONE_HUNDRED, \"IP\"); //Invalid percent value\r\n        require(_maxprizeinpercent <= ONE_HUNDRED, \"IP\"); //Invalid percent value\r\n\r\n        records[_code].code                         = _code;\r\n        records[_code].frequencyinseconds           = _frequencyinseconds;\r\n        records[_code].mindeposittimes              = _mindeposittimes;\r\n        records[_code].minwithdrawtimes             = _minwithdrawtimes;\r\n        records[_code].minstaketimes                = _minstaketimes;\r\n        records[_code].minunstaketimes              = _minunstaketimes;\r\n        records[_code].minbalanceincoin             = _minbalanceincoin;\r\n        records[_code].coinaddresstocheckbalance    = _coinaddresstocheckbalance;\r\n        records[_code].maxprizeinpercent            = _maxprizeinpercent;\r\n        records[_code].minprizeinpercent            = _minprizeinpercent;\r\n        records[_code].coinprizeaddress             = _coinprizeaddress;\r\n        //records[_code].bag                          = 0;\r\n        records[_code].active                       = 1;\r\n\r\n        return true;\r\n    }\r\n\r\n    function getReward(uint _code) external view returns (RewardModel memory result)\r\n    {\r\n        return records[_code];\r\n    }\r\n\r\n    function setRewardActiveValue(uint _code, uint _newValue) public returns (bool success)\r\n    {\r\n        require(msg.sender == owner, 'Forbidden');\r\n\r\n        records[_code].active = _newValue;\r\n        return true;\r\n    }\r\n\r\n    function setStakeContract(address _stakecontract) external\r\n    {\r\n        require(msg.sender == owner, 'FN'); //Forbidden\r\n        stakecontract = _stakecontract;\r\n    }\r\n\r\n    function setBagValue(uint _code, uint256 _value) external returns (bool success)\r\n    {\r\n        require(msg.sender == owner, 'FN'); //Forbidden\r\n        records[_code].bag = _value;\r\n\r\n        return true;\r\n    }\r\n\r\n    function depositTokenToBag(uint _code, uint256 _value) external returns (bool success)\r\n    {\r\n        require(records[_code].coinprizeaddress != address(0), 'IA'); //Invalid Contract Address\r\n\r\n        //Receive token for bag\r\n        ERC20(records[_code].coinprizeaddress).transferFrom(msg.sender, address(this), _value);\r\n        records[_code].bag = safeAdd(records[_code].bag, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function getStakeParticipantInfo(address _player) public view returns(StakeContract.ParticipantInfo memory result)\r\n    {\r\n        StakeContract.ParticipantInfo memory info = StakeContract(stakecontract).participants(_player);\r\n        return info;\r\n    }\r\n\r\n    function checkAvailability(address _player, uint _code) public view returns (uint success)\r\n    {\r\n        //Check is active\r\n        if(records[_code].active == 0)\r\n        {\r\n            return 0;\r\n        }\r\n\r\n        //Check has any activated trigger\r\n        if(records[_code].frequencyinseconds == 0 &&\r\n            records[_code].mindeposittimes == 0 &&\r\n            records[_code].minwithdrawtimes == 0 &&\r\n            records[_code].minstaketimes == 0 &&\r\n            records[_code].minunstaketimes == 0 &&\r\n            records[_code].minbalanceincoin == 0)\r\n        {\r\n            return 2;\r\n        }\r\n\r\n        //Check data consistency\r\n        if(records[_code].coinaddresstocheckbalance == address(0))\r\n        {\r\n            if(records[_code].minbalanceincoin > 0)\r\n            {\r\n                return 3; //Has min balance but undefined coin address \r\n            }\r\n        }\r\n\r\n        if(records[_code].maxprizeinpercent == 0 && records[_code].minprizeinpercent == 0)\r\n        {\r\n            return 4; //No prize percent\r\n        }\r\n\r\n        if(records[_code].maxprizeinpercent < records[_code].minprizeinpercent)\r\n        {\r\n            return 4; //Inconsistent prize percent Max less than Min\r\n        }\r\n\r\n        if(records[_code].coinprizeaddress == address(0))\r\n        {\r\n            return 5; //Undefined coin prize\r\n        }\r\n\r\n        //Check bag balance\r\n        if(records[_code].bag == 0)\r\n        {\r\n            return 6; //Empty bag\r\n        }\r\n\r\n        if(ERC20(records[_code].coinprizeaddress).balanceOf(address(this)) == 0)\r\n        {\r\n            return 7; //Empty balance for prize\r\n        }\r\n\r\n        //Check parameters\r\n        StakeContract.ParticipantInfo memory playerInfo = StakeContract(stakecontract).participants(_player);\r\n        \r\n        if(playerInfo.deposits < records[_code].mindeposittimes)\r\n        {\r\n            return 8; //Deposit requirements\r\n        }\r\n\r\n        if(playerInfo.withdrawals < records[_code].minwithdrawtimes)\r\n        {\r\n            return 9; //Withdraw requirements\r\n        }\r\n\r\n        if(playerInfo.stakes < records[_code].minstaketimes)\r\n        {\r\n            return 10; //Stakes requirements\r\n        }\r\n\r\n        if(playerInfo.unstakes < records[_code].minunstaketimes)\r\n        {\r\n            return 11; //Unstakes requirements\r\n        }\r\n\r\n        if(records[_code].minbalanceincoin > 0)\r\n        {\r\n            uint256 playerBalance = ERC20(records[_code].coinaddresstocheckbalance).balanceOf(_player);\r\n            if(playerBalance < records[_code].minbalanceincoin)\r\n            {\r\n                return 12; //Minimum balance requirements\r\n            }\r\n        }\r\n\r\n        //Check time\r\n        uint secPassed = block.timestamp - lastprize[_player][_code].time;\r\n        if(secPassed < records[_code].frequencyinseconds)\r\n        {\r\n            return 100; //Time-lock\r\n        }\r\n\r\n\r\n        return 1;\r\n    }\r\n\r\n    function getPrizeValue(uint _code) external view returns (uint256 result)\r\n    {\r\n        uint256 bagPercent = rgn(records[_code].minprizeinpercent ,records[_code].maxprizeinpercent); //Eg 10 (10000000000000000000)\r\n        \r\n        require(bagPercent > 0, 'IBP'); //Invalid bag percentage\r\n        require(bagPercent <= ONE_HUNDRED, \"IP\");  //Invalid percent value\r\n\r\n        uint256 prizevalue = safeDiv(safeMul(records[_code].bag, bagPercent), ONE_HUNDRED);\r\n\r\n        return prizevalue;\r\n    }\r\n\r\n    function claim(address _player, uint _code, uint256 prizevalue) external returns (bool success)\r\n    {\r\n        require( checkAvailability(_player, _code) == 1, 'NA' ); //Prize not available\r\n\r\n        require(records[_code].maxprizeinpercent > 0, 'IBP'); //Invalid bag percentage\r\n        require(records[_code].maxprizeinpercent <= ONE_HUNDRED, \"IP\");  //Invalid percent value\r\n        require(prizevalue > 0, 'ZV'); //Zero value\r\n        require(prizevalue <= records[_code].bag, 'OB'); //Over bag value\r\n\r\n        uint256 maxprizevalue = safeDiv(safeMul(records[_code].bag, records[_code].maxprizeinpercent), ONE_HUNDRED);\r\n        require(prizevalue <= maxprizevalue, 'OP'); //Over prize\r\n        \r\n        require(records[_code].coinprizeaddress != address(0), 'IA'); //Invalid Contract Address\r\n\r\n        require(ERC20(records[_code].coinprizeaddress).balanceOf(address(this)) >= prizevalue, 'NB'); //No Balance\r\n\r\n        //Pay the prize\r\n        ERC20(records[_code].coinprizeaddress).transfer(msg.sender, prizevalue);\r\n\r\n        //Write event log\r\n        emit OnPrize(_player, _code, block.timestamp, prizevalue, records[_code].bag);\r\n\r\n        //Update bag\r\n        records[_code].bag = safeSub(records[_code].bag, prizevalue);\r\n\r\n        //Update prize record\r\n        lastprize[_player][_code].time = block.timestamp;\r\n        lastprize[_player][_code].value = prizevalue;\r\n\r\n        return true; \r\n    }\r\n\r\n    function rgn(uint256 min, uint256 max) internal view returns (uint256) \r\n    {\r\n        if(min > max)\r\n        {\r\n            return 0;\r\n        }\r\n\r\n        if(min == max)\r\n        {\r\n            return min;\r\n        }\r\n\r\n        uint256 randomnumber = uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty, msg.sender))) % (safeSub(max, min));\r\n        randomnumber = safeAdd(randomnumber, min);\r\n        return randomnumber;\r\n    }\r\n    \r\n\r\n    /*\r\n    function getStakeFeeTo() public view returns(address result) \r\n    {\r\n        address sfeeTo = StakeContract(stakecontract).feeTo();\r\n        return sfeeTo;\r\n    }\r\n\r\n    function getStakeOwner() public view returns(address result) \r\n    {\r\n        address sOwner = StakeContract(stakecontract).owner();\r\n        return sOwner;\r\n    }\r\n    */\r\n\r\n    //Safe Math Functions\r\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"OADD\"); //STAKE: SafeMath: addition overflow\r\n\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        return safeSub(a, b, \"OSUB\"); //STAKE: subtraction overflow\r\n    }\r\n\r\n    function safeSub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) \r\n    {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        if (a == 0) \r\n        {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"OMUL\"); //STAKE: multiplication overflow\r\n\r\n        return c;\r\n    }\r\n\r\n    function safeMulFloat(uint256 a, uint256 b, uint decimals) internal pure returns(uint256)\r\n    {\r\n        if (a == 0 || decimals == 0)  \r\n        {\r\n            return 0;\r\n        }\r\n\r\n        uint result = safeDiv(safeMul(a, b), safePow(10, uint256(decimals)));\r\n\r\n        return result;\r\n    }\r\n\r\n    function safePow(uint256 n, uint256 e) internal pure returns(uint256)\r\n    {\r\n\r\n        if (e == 0) \r\n        {\r\n            return 1;\r\n        } \r\n        else if (e == 1) \r\n        {\r\n            return n;\r\n        } \r\n        else \r\n        {\r\n            uint256 p = safePow(n,  safeDiv(e, 2));\r\n            p = safeMul(p, p);\r\n\r\n            if (safeMod(e, 2) == 1) \r\n            {\r\n                p = safeMul(p, n);\r\n            }\r\n\r\n            return p;\r\n        }\r\n    }\r\n\r\n    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        return safeDiv(a, b, \"ZDIV\"); //STAKE: division by zero\r\n    }\r\n\r\n    function safeDiv(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) \r\n    {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function safeMod(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        return safeMod(a, b, \"ZMOD\"); //STAKE: modulo by zero\r\n    }\r\n\r\n    function safeMod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) \r\n    {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakecontract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"code\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bag\",\"type\":\"uint256\"}],\"name\":\"OnPrize\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_player\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_code\",\"type\":\"uint256\"}],\"name\":\"checkAvailability\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"success\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_player\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_code\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prizevalue\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_code\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"depositTokenToBag\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_code\",\"type\":\"uint256\"}],\"name\":\"getPrizeValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_code\",\"type\":\"uint256\"}],\"name\":\"getReward\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"code\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"frequencyinseconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mindeposittimes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minwithdrawtimes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minstaketimes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minunstaketimes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minbalanceincoin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coinaddresstocheckbalance\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxprizeinpercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minprizeinpercent\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"coinprizeaddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"bag\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"active\",\"type\":\"uint256\"}],\"internalType\":\"struct Reward.RewardModel\",\"name\":\"result\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_player\",\"type\":\"address\"}],\"name\":\"getStakeParticipantInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"deposits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unstakes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claims\",\"type\":\"uint256\"}],\"internalType\":\"struct StakeContract.ParticipantInfo\",\"name\":\"result\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lastprize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"code\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_code\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setBagValue\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newValue\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_code\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_frequencyinseconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_mindeposittimes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minwithdrawtimes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minstaketimes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minunstaketimes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minbalanceincoin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_coinaddresstocheckbalance\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxprizeinpercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minprizeinpercent\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_coinprizeaddress\",\"type\":\"address\"}],\"name\":\"setReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_code\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newValue\",\"type\":\"uint256\"}],\"name\":\"setRewardActiveValue\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakecontract\",\"type\":\"address\"}],\"name\":\"setStakeContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakecontract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Reward", "CompilerVersion": "v0.8.2+commit.661d1103", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000009879ad9bc4bb3450f50104ac45f1ee18c3701b38", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://72d8a76fa6ccce430f709e585b6d13570dba7f2dde393ef11a992e61e15168bb"}