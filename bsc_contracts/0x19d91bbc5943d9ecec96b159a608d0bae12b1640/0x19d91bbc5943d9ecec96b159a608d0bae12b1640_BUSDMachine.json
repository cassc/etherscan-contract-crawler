{"SourceCode": "pragma solidity 0.5.8;\r\n\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n    function totalSupply() external view returns (uint256);\r\n    function limitSupply() external view returns (uint256);\r\n    function availableSupply() external view returns (uint256);\r\n    function balanceOf(address who) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n    address busd = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56; // live busd\r\n    //address busd = 0x78867BbEeF44f2326bF8DDd1941a4439382EF2A7; // testnet busd\r\n    IERC20 token;\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n    uint256 internal _limitSupply;\r\n\r\n    string internal _name;\r\n    string internal _symbol;\r\n    uint8 internal _decimals;\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function limitSupply() public view returns (uint256) {\r\n        return _limitSupply;\r\n    }\r\n    \r\n    function availableSupply() public view returns (uint256) {\r\n        return _limitSupply.sub(_totalSupply);\r\n    }    \r\n\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount);\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n        require(availableSupply() >= amount, \"Supply exceed\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        \r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _balances[account] = _balances[account].sub(amount);\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n}\r\n\r\ncontract ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 amount, address token, bytes calldata extraData) external;\r\n}\r\n\r\ncontract Token is ERC20 {\r\n    mapping (address => bool) private _contracts;\r\n\r\n    constructor() public {\r\n        _name = \"BUSDMachine v3.0\";\r\n        _symbol = \"BUSDM3\";\r\n        _decimals = 18;\r\n        _limitSupply = 1000000e18;\r\n    }\r\n\r\n    function approveAndCall(address spender, uint256 amount, bytes memory extraData) public returns (bool) {\r\n        require(approve(spender, amount));\r\n\r\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, amount, address(this), extraData);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint256 value) public returns (bool) {\r\n\r\n        if (_contracts[to]) {\r\n            approveAndCall(to, value, new bytes(0));\r\n        } else {\r\n            super.transfer(to, value);\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract BUSDMachine is Token {\r\n    \r\n    uint private startTime = 1663250400; // Thursday, September 15, 2022 2:00:00 PM (GMT)\r\n    \r\n    address payable private ADMIN;\r\n    address payable private DEV_1;\r\n    address payable private DES_1;\r\n    address payable private ADM_1;\r\n    address payable private VID_1;\r\n    address payable private MAR_1;\r\n\r\n    uint public totalUsers; \r\n    uint public totalBUSDStaked; \r\n    uint public totalTokenStaked;\r\n    \r\n    uint8[] private REF_BONUSES             = [20];\r\n    uint private constant DEV_FEE           = 20;                   // Base 2% multipled * 5 = 10% total\r\n    uint private constant INITIAL_TOKENS    = 50000 ether;    \r\n\r\n    uint private constant PERCENT_DIVIDER   = 1000;\r\n    uint private constant PRICE_DIVIDER     = 1 ether;\r\n    uint private constant TIME_STEP         = 1 days;\r\n    uint private constant TIME_TO_UNSTAKE   = 7 days;\r\n\r\n    uint public MIN_INVEST_AMOUNT = 50 ether;\r\n    uint public BUSD_DAILYPROFIT  = 15;\r\n    uint public TOKEN_DAILYPROFIT = 25;\r\n\r\n    mapping(address => User) private users;\r\n    mapping(uint => uint) private sold; \r\n    \r\n    struct Stake {\r\n        uint checkpoint;\r\n        uint totalStaked; \r\n        uint lastStakeTime;\r\n        uint unClaimedTokens;        \r\n    }\r\n    \r\n    struct User {\r\n        address referrer;\r\n        Stake sM;\r\n        Stake sT;  \r\n\t\tuint256 bonus;\r\n\t\tuint256 totalBonus;\r\n        uint totaReferralBonus;\r\n        uint[1] levels;\r\n    }\r\n    \r\n    event TokenOperation(address indexed account, string txType, uint tokenAmount, uint trxAmount);\r\n\r\n    constructor() public {\r\n        token = IERC20(busd);\r\n\r\n        ADMIN = msg.sender;\r\n        DEV_1 = msg.sender;                                  // e\r\n        DES_1 = 0x8165fB391265196BBD20d6bDB601dd214b247211;  // 0\r\n        ADM_1 = 0x94AaA0b7f9223b32c521B7Fb83f575d319F99C0b;  // o         \r\n        VID_1 = 0xA44868F180dB97C7893fcE9A2d2BDC783ccE6Fcd;  // E        \r\n        MAR_1 = 0xdd7e9F8F4DAd0464Df3283B864cE691B001066F9;  // t\r\n       \r\n        _mint(MAR_1, INITIAL_TOKENS);  \r\n    }       \r\n    \r\n    modifier onlyOwner {\r\n        require(msg.sender == ADMIN, \"Only owner can call this function\");\r\n        _;\r\n    } \r\n    \r\n    function stakeBUSD(address referrer,  uint256 _amount) public payable {\r\n        require (block.timestamp > startTime);               \r\n        require (_amount >= MIN_INVEST_AMOUNT);                 \r\n        token.transferFrom(msg.sender, address(this), _amount);     \r\n        \r\n\t\tuint fee = _amount.mul(DEV_FEE).div(PERCENT_DIVIDER);  \r\n\r\n        token.transfer(DEV_1, fee);\r\n        token.transfer(DES_1, fee);     \r\n        token.transfer(ADM_1, fee);\r\n        token.transfer(VID_1, fee);\r\n\r\n        token.transfer(MAR_1, fee);     \r\n\r\n\t\tUser storage user = users[msg.sender];\r\n\t\t\r\n\t\tif (user.referrer == address(0) && msg.sender != ADMIN) {\r\n\t\t\tif (users[referrer].sM.totalStaked == 0) {\r\n\t\t\t\treferrer = ADMIN;\r\n\t\t\t}\r\n\t\t\tuser.referrer = referrer;\r\n\t\t\taddress upline = user.referrer;\r\n\t\t\tfor (uint256 i = 0; i < REF_BONUSES.length; i++) {\r\n\t\t\t\tif (upline != address(0)) {\r\n\t\t\t\t\tusers[upline].levels[i] = users[upline].levels[i].add(1);\r\n\t\t\t\t\tupline = users[upline].referrer;\r\n\t\t\t\t} else break;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (user.referrer != address(0)) {\r\n\t\t\taddress upline = user.referrer;\r\n\t\t\tfor (uint256 i = 0; i < REF_BONUSES.length; i++) {\r\n\t\t\t\tif (upline == address(0)) {\r\n\t\t\t\t    upline = ADMIN;\r\n\t\t\t\t}\r\n\t\t\t\tuint256 amount = _amount.mul(REF_BONUSES[i]).div(PERCENT_DIVIDER);\r\n\t\t\t\tusers[upline].bonus = users[upline].bonus.add(amount);\r\n\t\t\t\tusers[upline].totalBonus = users[upline].totalBonus.add(amount);\r\n\t\t\t\tupline = users[upline].referrer;\r\n\t\t\t}\r\n\t\t} \r\n\r\n        if (user.sM.totalStaked == 0) {\r\n            user.sM.checkpoint = maxVal(now, startTime);\r\n            totalUsers++;\r\n        } else {\r\n            updateStakeBUSD_IP(msg.sender);\r\n        }\r\n      \r\n        user.sM.lastStakeTime = now;\r\n        user.sM.totalStaked = user.sM.totalStaked.add(_amount);\r\n        totalBUSDStaked = totalBUSDStaked.add(_amount);\r\n    }\r\n    \r\n    function stakeToken(uint tokenAmount) public {\r\n        require (block.timestamp > startTime);       \r\n        User storage user = users[msg.sender];\r\n        require(now >= startTime, \"Stake not available yet\");\r\n        require(tokenAmount <= balanceOf(msg.sender), \"Insufficient Token Balance\");\r\n\r\n        if (user.sT.totalStaked == 0) {\r\n            user.sT.checkpoint = now;\r\n        } else {\r\n            updateStakeToken_IP(msg.sender);\r\n        }\r\n        \r\n        _transfer(msg.sender, address(this), tokenAmount);\r\n        user.sT.lastStakeTime = now;\r\n        user.sT.totalStaked = user.sT.totalStaked.add(tokenAmount);\r\n        totalTokenStaked = totalTokenStaked.add(tokenAmount); \r\n    } \r\n    \r\n    function unStakeToken() public {\r\n        User storage user = users[msg.sender];\r\n        require(now > user.sT.lastStakeTime.add(TIME_TO_UNSTAKE));\r\n        updateStakeToken_IP(msg.sender);\r\n        uint tokenAmount = user.sT.totalStaked;\r\n        user.sT.totalStaked = 0;\r\n        totalTokenStaked = totalTokenStaked.sub(tokenAmount); \r\n        uint256 halfTokenAmount = tokenAmount.div(2);\r\n\r\n        _transfer(address(this), msg.sender, tokenAmount);      // send full to msg.sender\r\n        _burn(msg.sender, halfTokenAmount);                     // burn half from the users wallet\r\n    }  \r\n    \r\n    function updateStakeBUSD_IP(address _addr) private {\r\n        User storage user = users[_addr];\r\n        uint256 amount = getStakeBUSD_IP(_addr);\r\n        if(amount > 0) {\r\n            user.sM.unClaimedTokens = user.sM.unClaimedTokens.add(amount);\r\n            user.sM.checkpoint = now;\r\n        }\r\n    } \r\n    \r\n    function getStakeBUSD_IP(address _addr) view private returns(uint256 value) {\r\n        User storage user = users[_addr];\r\n        uint256 fr = user.sM.checkpoint;\r\n        if (startTime > now) {\r\n          fr = now; \r\n        }\r\n        uint256 Tarif = BUSD_DAILYPROFIT;\r\n        uint256 to = now;\r\n        if(fr < to) {\r\n            value = user.sM.totalStaked.mul(to - fr).mul(Tarif).div(TIME_STEP).div(PERCENT_DIVIDER);\r\n        } else {\r\n            value = 0;\r\n        }\r\n        return value;\r\n    }  \r\n    \r\n    function updateStakeToken_IP(address _addr) private {\r\n        User storage user = users[_addr];\r\n        uint256 amount = getStakeToken_IP(_addr);\r\n        if(amount > 0) {\r\n            user.sT.unClaimedTokens = user.sT.unClaimedTokens.add(amount);\r\n            user.sT.checkpoint = now;\r\n        }\r\n    } \r\n    \r\n    function getStakeToken_IP(address _addr) view private returns(uint256 value) {\r\n        User storage user = users[_addr];\r\n        uint256 fr = user.sT.checkpoint;\r\n        if (startTime > now) {\r\n          fr = now; \r\n        }\r\n        uint256 Tarif = TOKEN_DAILYPROFIT;\r\n        uint256 to = now;\r\n        if(fr < to) {\r\n            value = user.sT.totalStaked.mul(to - fr).mul(Tarif).div(TIME_STEP).div(PERCENT_DIVIDER);\r\n        } else {\r\n            value = 0;\r\n        }\r\n        return value;\r\n    }      \r\n    \r\n    function claimToken_M() public {\r\n        User storage user = users[msg.sender];\r\n       \r\n        updateStakeBUSD_IP(msg.sender);\r\n        uint tokenAmount = user.sM.unClaimedTokens;  \r\n        user.sM.unClaimedTokens = 0;                 \r\n        \r\n        _mint(msg.sender, tokenAmount);\r\n        emit TokenOperation(msg.sender, \"CLAIM\", tokenAmount, 0);\r\n    }    \r\n    \r\n    function claimToken_T() public {\r\n        User storage user = users[msg.sender];\r\n       \r\n        updateStakeToken_IP(msg.sender);\r\n        uint tokenAmount = user.sT.unClaimedTokens; \r\n        user.sT.unClaimedTokens = 0; \r\n        \r\n        _mint(msg.sender, tokenAmount);\r\n        emit TokenOperation(msg.sender, \"CLAIM\", tokenAmount, 0);\r\n    }     \r\n    \r\n    function sellToken(uint tokenAmount) public {\r\n        tokenAmount = minVal(tokenAmount, balanceOf(msg.sender));\r\n        require(tokenAmount > 0, \"Token amount can not be 0\");\r\n        \r\n        sold[getCurrentDay()] = sold[getCurrentDay()].add(tokenAmount);\r\n        uint BUSDAmount = tokenToBUSD(tokenAmount);\r\n    \r\n        require(getContractBUSDBalance() > BUSDAmount, \"Insufficient Contract Balance\");\r\n        _burn(msg.sender, tokenAmount);\r\n\r\n       token.transfer(msg.sender, BUSDAmount);\r\n        \r\n        emit TokenOperation(msg.sender, \"SELL\", tokenAmount, BUSDAmount);\r\n    }\r\n    \r\n\tfunction withdrawRef() public {\r\n\t\tUser storage user = users[msg.sender];\r\n\t\t\r\n\t\tuint totalAmount = getUserReferralBonus(msg.sender);\r\n\t\trequire(totalAmount > 0, \"User has no dividends\");\r\n        user.bonus = 0;\r\n\t\t//msg.sender.transfer(totalAmount);\r\n\t\ttoken.transfer(msg.sender, totalAmount);\r\n\t}\t    \r\n\r\n    function getUserUnclaimedTokens_M(address _addr) public view returns(uint value) {\r\n        User storage user = users[_addr];\r\n        return getStakeBUSD_IP(_addr).add(user.sM.unClaimedTokens); \r\n    }\r\n    \r\n    function getUserUnclaimedTokens_T(address _addr) public view returns(uint value) {\r\n        User storage user = users[_addr];\r\n        return getStakeToken_IP(_addr).add(user.sT.unClaimedTokens); \r\n    }  \r\n       \r\n\tfunction getContractBUSDBalance() public view returns (uint) {\r\n\t    // return address(this).balance;\r\n\t    return token.balanceOf(address(this));\r\n\t}  \r\n\t\r\n\tfunction getContractTokenBalance() public view returns (uint) {\r\n\t\treturn balanceOf(address(this));\r\n\t}  \r\n\t\r\n\tfunction getAPY_M() public view returns (uint) {\r\n\t\treturn BUSD_DAILYPROFIT.mul(365).div(10);\r\n\t}\r\n\t\r\n\tfunction getAPY_T() public view returns (uint) {\r\n\t\treturn TOKEN_DAILYPROFIT.mul(365).div(10);\r\n\t}\t\r\n\t\r\n\tfunction getUserBUSDBalance(address _addr) public view returns (uint) {\r\n\t\treturn address(_addr).balance;\r\n\t}\t\r\n\t\r\n\tfunction getUserTokenBalance(address _addr) public view returns (uint) {\r\n\t\treturn balanceOf(_addr);\r\n\t}\r\n\t\r\n\tfunction getUserBUSDStaked(address _addr) public view returns (uint) {\r\n\t\treturn users[_addr].sM.totalStaked;\r\n\t}\t\r\n\t\r\n\tfunction getUserTokenStaked(address _addr) public view returns (uint) {\r\n\t\treturn users[_addr].sT.totalStaked;\r\n\t}\r\n\t\r\n\tfunction getUserTimeToUnstake(address _addr) public view returns (uint) {\r\n\t\treturn  minZero(users[_addr].sT.lastStakeTime.add(TIME_TO_UNSTAKE), now);\r\n\t}\t\r\n\t\r\n    function getTokenPrice() public view returns(uint) {\r\n        uint d1 = getContractBUSDBalance().mul(PRICE_DIVIDER);\r\n        uint d2 = availableSupply().add(1);\r\n        return d1.div(d2);\r\n    } \r\n\r\n    function BUSDToToken(uint BUSDAmount) public view returns(uint) {\r\n        return BUSDAmount.mul(PRICE_DIVIDER).div(getTokenPrice());\r\n    }\r\n\r\n    function tokenToBUSD(uint tokenAmount) public view returns(uint) {\r\n        return tokenAmount.mul(getTokenPrice()).div(PRICE_DIVIDER);\r\n    } \t\r\n\r\n\tfunction getUserDownlineCount(address userAddress) public view returns(uint) {\r\n\t\treturn (users[userAddress].levels[0]);\r\n\t}  \r\n\t\r\n\tfunction getUserReferralBonus(address userAddress) public view returns(uint) {\r\n\t\treturn users[userAddress].bonus;\r\n\t}\r\n\r\n\tfunction getUserReferralTotalBonus(address userAddress) public view returns(uint) {\r\n\t\treturn users[userAddress].totalBonus;\r\n\t}\r\n\t\r\n\tfunction getUserReferralWithdrawn(address userAddress) public view returns(uint256) {\r\n\t\treturn users[userAddress].totalBonus.sub(users[userAddress].bonus);\r\n\t}\t\r\n    \r\n\tfunction getContractLaunchTime() public view returns(uint) {\r\n\t\treturn minZero(startTime, block.timestamp);\r\n\t}\r\n\t\r\n    function getCurrentDay() public view returns (uint) {\r\n        return minZero(now, startTime).div(TIME_STEP);\r\n    }\t\r\n    \r\n    function getTokenSoldToday() public view returns (uint) {\r\n        return sold[getCurrentDay()];\r\n    }   \r\n    \r\n \r\n    function getTimeToNextDay() public view returns (uint) {\r\n        uint t = minZero(now, startTime);\r\n        uint g = getCurrentDay().mul(TIME_STEP);\r\n        return g.add(TIME_STEP).sub(t);\r\n    }  \r\n\r\n  \r\n    function minZero(uint a, uint b) private pure returns(uint) {\r\n        if (a > b) {\r\n           return a - b; \r\n        } else {\r\n           return 0;    \r\n        }    \r\n    }   \r\n    \r\n    function maxVal(uint a, uint b) private pure returns(uint) {\r\n        if (a > b) {\r\n           return a; \r\n        } else {\r\n           return b;    \r\n        }    \r\n    }\r\n    \r\n    function minVal(uint a, uint b) private pure returns(uint) {\r\n        if (a > b) {\r\n           return b; \r\n        } else {\r\n           return a;    \r\n        }    \r\n    }    \r\n}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getUserTimeToUnstake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"BUSDAmount\",\"type\":\"uint256\"}],\"name\":\"BUSDToToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserDownlineCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"sellToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"limitSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokenStaked\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"tokenToBUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContractTokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAPY_T\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAPY_M\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserReferralTotalBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unStakeToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"referrer\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"stakeBUSD\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContractBUSDBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenSoldToday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserReferralWithdrawn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getUserBUSDBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBUSDStaked\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"availableSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_DAILYPROFIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getUserUnclaimedTokens_M\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_INVEST_AMOUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTimeToNextDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getUserTokenStaked\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getUserBUSDStaked\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalUsers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawRef\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"stakeToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContractLaunchTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimToken_M\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getUserUnclaimedTokens_T\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimToken_T\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserReferralBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BUSD_DAILYPROFIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getUserTokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"txType\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"trxAmount\",\"type\":\"uint256\"}],\"name\":\"TokenOperation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]", "ContractName": "BUSDMachine", "CompilerVersion": "v0.5.8+commit.23d335f2", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://6221a5e835236af8be80ff7e1ac400cfaba3e09c6b81fafbfbde78c7fd10015b"}