{"SourceCode": "{{\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"runs\": 200,\r\n      \"enabled\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/common/governance/IGovernance.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\ninterface IGovernance {\\n    function update(address target, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"contracts/common/Registry.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\nimport {Governable} from \\\"./governance/Governable.sol\\\";\\nimport {IWithdrawManager} from \\\"../root/withdrawManager/IWithdrawManager.sol\\\";\\n\\n\\ncontract Registry is Governable {\\n    // @todo hardcode constants\\n    bytes32 private constant WETH_TOKEN = keccak256(\\\"wethToken\\\");\\n    bytes32 private constant DEPOSIT_MANAGER = keccak256(\\\"depositManager\\\");\\n    bytes32 private constant STAKE_MANAGER = keccak256(\\\"stakeManager\\\");\\n    bytes32 private constant VALIDATOR_SHARE = keccak256(\\\"validatorShare\\\");\\n    bytes32 private constant WITHDRAW_MANAGER = keccak256(\\\"withdrawManager\\\");\\n    bytes32 private constant CHILD_CHAIN = keccak256(\\\"childChain\\\");\\n    bytes32 private constant STATE_SENDER = keccak256(\\\"stateSender\\\");\\n    bytes32 private constant SLASHING_MANAGER = keccak256(\\\"slashingManager\\\");\\n\\n    address public erc20Predicate;\\n    address public erc721Predicate;\\n\\n    mapping(bytes32 => address) public contractMap;\\n    mapping(address => address) public rootToChildToken;\\n    mapping(address => address) public childToRootToken;\\n    mapping(address => bool) public proofValidatorContracts;\\n    mapping(address => bool) public isERC721;\\n\\n    enum Type {Invalid, ERC20, ERC721, Custom}\\n    struct Predicate {\\n        Type _type;\\n    }\\n    mapping(address => Predicate) public predicates;\\n\\n    event TokenMapped(address indexed rootToken, address indexed childToken);\\n    event ProofValidatorAdded(address indexed validator, address indexed from);\\n    event ProofValidatorRemoved(address indexed validator, address indexed from);\\n    event PredicateAdded(address indexed predicate, address indexed from);\\n    event PredicateRemoved(address indexed predicate, address indexed from);\\n    event ContractMapUpdated(bytes32 indexed key, address indexed previousContract, address indexed newContract);\\n\\n    constructor(address _governance) public Governable(_governance) {}\\n\\n    function updateContractMap(bytes32 _key, address _address) external onlyGovernance {\\n        emit ContractMapUpdated(_key, contractMap[_key], _address);\\n        contractMap[_key] = _address;\\n    }\\n\\n    /**\\n     * @dev Map root token to child token\\n     * @param _rootToken Token address on the root chain\\n     * @param _childToken Token address on the child chain\\n     * @param _isERC721 Is the token being mapped ERC721\\n     */\\n    function mapToken(\\n        address _rootToken,\\n        address _childToken,\\n        bool _isERC721\\n    ) external onlyGovernance {\\n        require(_rootToken != address(0x0) && _childToken != address(0x0), \\\"INVALID_TOKEN_ADDRESS\\\");\\n        rootToChildToken[_rootToken] = _childToken;\\n        childToRootToken[_childToken] = _rootToken;\\n        isERC721[_rootToken] = _isERC721;\\n        IWithdrawManager(contractMap[WITHDRAW_MANAGER]).createExitQueue(_rootToken);\\n        emit TokenMapped(_rootToken, _childToken);\\n    }\\n\\n    function addErc20Predicate(address predicate) public onlyGovernance {\\n        require(predicate != address(0x0), \\\"Can not add null address as predicate\\\");\\n        erc20Predicate = predicate;\\n        addPredicate(predicate, Type.ERC20);\\n    }\\n\\n    function addErc721Predicate(address predicate) public onlyGovernance {\\n        erc721Predicate = predicate;\\n        addPredicate(predicate, Type.ERC721);\\n    }\\n\\n    function addPredicate(address predicate, Type _type) public onlyGovernance {\\n        require(predicates[predicate]._type == Type.Invalid, \\\"Predicate already added\\\");\\n        predicates[predicate]._type = _type;\\n        emit PredicateAdded(predicate, msg.sender);\\n    }\\n\\n    function removePredicate(address predicate) public onlyGovernance {\\n        require(predicates[predicate]._type != Type.Invalid, \\\"Predicate does not exist\\\");\\n        delete predicates[predicate];\\n        emit PredicateRemoved(predicate, msg.sender);\\n    }\\n\\n    function getValidatorShareAddress() public view returns (address) {\\n        return contractMap[VALIDATOR_SHARE];\\n    }\\n\\n    function getWethTokenAddress() public view returns (address) {\\n        return contractMap[WETH_TOKEN];\\n    }\\n\\n    function getDepositManagerAddress() public view returns (address) {\\n        return contractMap[DEPOSIT_MANAGER];\\n    }\\n\\n    function getStakeManagerAddress() public view returns (address) {\\n        return contractMap[STAKE_MANAGER];\\n    }\\n\\n    function getSlashingManagerAddress() public view returns (address) {\\n        return contractMap[SLASHING_MANAGER];\\n    }\\n\\n    function getWithdrawManagerAddress() public view returns (address) {\\n        return contractMap[WITHDRAW_MANAGER];\\n    }\\n\\n    function getChildChainAndStateSender() public view returns (address, address) {\\n        return (contractMap[CHILD_CHAIN], contractMap[STATE_SENDER]);\\n    }\\n\\n    function isTokenMapped(address _token) public view returns (bool) {\\n        return rootToChildToken[_token] != address(0x0);\\n    }\\n\\n    function isTokenMappedAndIsErc721(address _token) public view returns (bool) {\\n        require(isTokenMapped(_token), \\\"TOKEN_NOT_MAPPED\\\");\\n        return isERC721[_token];\\n    }\\n\\n    function isTokenMappedAndGetPredicate(address _token) public view returns (address) {\\n        if (isTokenMappedAndIsErc721(_token)) {\\n            return erc721Predicate;\\n        }\\n        return erc20Predicate;\\n    }\\n\\n    function isChildTokenErc721(address childToken) public view returns (bool) {\\n        address rootToken = childToRootToken[childToken];\\n        require(rootToken != address(0x0), \\\"Child token is not mapped\\\");\\n        return isERC721[rootToken];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/governance/Governable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\nimport {IGovernance} from \\\"./IGovernance.sol\\\";\\n\\ncontract Governable {\\n    IGovernance public governance;\\n\\n    constructor(address _governance) public {\\n        governance = IGovernance(_governance);\\n    }\\n\\n    modifier onlyGovernance() {\\n        _assertGovernance();\\n        _;\\n    }\\n\\n    function _assertGovernance() private view {\\n        require(\\n            msg.sender == address(governance),\\n            \\\"Only governance contract is authorized\\\"\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/staking/EventsHub.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\nimport {Registry} from \\\"../common/Registry.sol\\\";\\nimport {Initializable} from \\\"../common/mixin/Initializable.sol\\\";\\n\\ncontract IStakeManagerEventsHub {\\n    struct Validator {\\n        uint256 amount;\\n        uint256 reward;\\n        uint256 activationEpoch;\\n        uint256 deactivationEpoch;\\n        uint256 jailTime;\\n        address signer;\\n        address contractAddress;\\n    }\\n\\n    mapping(uint256 => Validator) public validators;\\n}\\n\\ncontract EventsHub is Initializable {\\n    Registry public registry;\\n\\n    modifier onlyValidatorContract(uint256 validatorId) {\\n        address _contract;\\n        (, , , , , , _contract) = IStakeManagerEventsHub(registry.getStakeManagerAddress()).validators(validatorId);\\n        require(_contract == msg.sender, \\\"not validator\\\");\\n        _;\\n    }\\n\\n    modifier onlyStakeManager() {\\n        require(registry.getStakeManagerAddress() == msg.sender,\\n        \\\"Invalid sender, not stake manager\\\");\\n        _;\\n    }\\n\\n    function initialize(Registry _registry) external initializer {\\n        registry = _registry;\\n    }\\n\\n    event ShareBurnedWithId(\\n        uint256 indexed validatorId,\\n        address indexed user,\\n        uint256 indexed amount,\\n        uint256 tokens,\\n        uint256 nonce\\n    );\\n\\n    function logShareBurnedWithId(\\n        uint256 validatorId,\\n        address user,\\n        uint256 amount,\\n        uint256 tokens,\\n        uint256 nonce\\n    ) public onlyValidatorContract(validatorId) {\\n        emit ShareBurnedWithId(validatorId, user, amount, tokens, nonce);\\n    }\\n\\n    event DelegatorUnstakeWithId(\\n        uint256 indexed validatorId,\\n        address indexed user,\\n        uint256 amount,\\n        uint256 nonce\\n    );\\n\\n    function logDelegatorUnstakedWithId(\\n        uint256 validatorId,\\n        address user,\\n        uint256 amount,\\n        uint256 nonce\\n    ) public onlyValidatorContract(validatorId) {\\n        emit DelegatorUnstakeWithId(validatorId, user, amount, nonce);\\n    }\\n\\n    event RewardParams(\\n        uint256 rewardDecreasePerCheckpoint,\\n        uint256 maxRewardedCheckpoints,\\n        uint256 checkpointRewardDelta\\n    );\\n\\n    function logRewardParams(\\n        uint256 rewardDecreasePerCheckpoint,\\n        uint256 maxRewardedCheckpoints,\\n        uint256 checkpointRewardDelta\\n    ) public onlyStakeManager {\\n        emit RewardParams(rewardDecreasePerCheckpoint, maxRewardedCheckpoints, checkpointRewardDelta);\\n    }\\n\\n    event UpdateCommissionRate(\\n        uint256 indexed validatorId,\\n        uint256 indexed newCommissionRate,\\n        uint256 indexed oldCommissionRate\\n    );\\n\\n    function logUpdateCommissionRate(\\n        uint256 validatorId,\\n        uint256 newCommissionRate,\\n        uint256 oldCommissionRate\\n    ) public onlyStakeManager {\\n        emit UpdateCommissionRate(\\n            validatorId,\\n            newCommissionRate,\\n            oldCommissionRate\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/mixin/Initializable.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\ncontract Initializable {\\n    bool inited = false;\\n\\n    modifier initializer() {\\n        require(!inited, \\\"already inited\\\");\\n        inited = true;\\n        \\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/root/withdrawManager/IWithdrawManager.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\n\\ncontract IWithdrawManager {\\n    function createExitQueue(address token) external;\\n\\n    function verifyInclusion(\\n        bytes calldata data,\\n        uint8 offset,\\n        bool verifyTxInclusion\\n    ) external view returns (uint256 age);\\n\\n    function addExitToQueue(\\n        address exitor,\\n        address childToken,\\n        address rootToken,\\n        uint256 exitAmountOrTokenId,\\n        bytes32 txHash,\\n        bool isRegularExit,\\n        uint256 priority\\n    ) external;\\n\\n    function addInput(\\n        uint256 exitId,\\n        uint256 age,\\n        address utxoOwner,\\n        address token\\n    ) external;\\n\\n    function challengeExit(\\n        uint256 exitId,\\n        uint256 inputId,\\n        bytes calldata challengeData,\\n        address adjudicatorPredicate\\n    ) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"language\": \"Solidity\"\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"DelegatorUnstakeWithId\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardDecreasePerCheckpoint\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxRewardedCheckpoints\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"checkpointRewardDelta\",\"type\":\"uint256\"}],\"name\":\"RewardParams\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"ShareBurnedWithId\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newCommissionRate\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldCommissionRate\",\"type\":\"uint256\"}],\"name\":\"UpdateCommissionRate\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract Registry\",\"name\":\"_registry\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"logDelegatorUnstakedWithId\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardDecreasePerCheckpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxRewardedCheckpoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"checkpointRewardDelta\",\"type\":\"uint256\"}],\"name\":\"logRewardParams\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"logShareBurnedWithId\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"validatorId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newCommissionRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oldCommissionRate\",\"type\":\"uint256\"}],\"name\":\"logUpdateCommissionRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"contract Registry\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "EventsHub", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}