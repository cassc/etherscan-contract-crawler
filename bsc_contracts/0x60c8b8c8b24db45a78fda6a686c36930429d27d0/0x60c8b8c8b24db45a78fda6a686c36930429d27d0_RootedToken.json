{"SourceCode": "{\"Address.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\nlibrary Address {\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        assembly { size := extcodesize(account) }\\n        return size \\u003e 0;\\n    }\\n\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            if (returndata.length \\u003e 0) {\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\"},\"AddressRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\nimport \\\"./Owned.sol\\\";\\n\\ncontract AddressRegistry is Owned {\\n\\n    address public transferGate;\\n    \\n    mapping (address =\\u003e bool) public freeParticipantControllers;\\n    mapping (address =\\u003e bool) public freeParticipant;\\n    mapping (address =\\u003e bool) public blacklist;\\n    mapping (address =\\u003e bool) public trustedHolder;\\n\\n    modifier transferGateOnly() {\\n        require (msg.sender == transferGate, \\\"Transfer Gate only\\\");\\n        _;\\n    }\\n\\n    function setTransferGate(address _transferGate) public ownerOnly() {\\n        transferGate = _transferGate;\\n    }\\n\\n    function setFreeParticipantController(address freeParticipantController, bool allow) public transferGateOnly() {\\n        freeParticipantControllers[freeParticipantController] = allow;\\n    }\\n\\n    function setFreeParticipant(address participant, bool free) public transferGateOnly() {\\n        freeParticipant[participant] = free;\\n    }\\n\\n    function setTrustedWallet(address holder, bool trusted) public transferGateOnly() {\\n        trustedHolder[holder] = trusted;\\n    }\\n\\n    function setBlackListed(address account, bool blacklisted) public ownerOnly() {\\n        blacklist[account] = blacklisted;\\n    }\\n}\"},\"BurnPit.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.7.4;\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\ncontract BurnPit {\\r\\n\\r\\n    address public rootedToken;\\r\\n\\r\\n    constructor (address _rootedToken) {\\r\\n        rootedToken = _rootedToken;\\r\\n    }\\r\\n    \\r\\n    function tokensBurned() external view returns (uint256) {\\r\\n        return IERC20(rootedToken).balanceOf(address(this));\\r\\n    }\\r\\n}\"},\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this;\\n        return msg.data;\\n    }\\n}\"},\"Counters.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\nlibrary Counters {\\n    struct Counter {\\n        uint256 _value;\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        counter._value += 1;\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value \\u003e 0, \\\"Counter: decrement overflow\\\");\\n        counter._value = value - 1;\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\"},\"EliteFloorCalculator.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\nimport \\\"./IFloorCalculator.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./ISwapRouter02.sol\\\";\\nimport \\\"./ISwapFactory.sol\\\";\\nimport \\\"./TokensRecoverable.sol\\\";\\nimport \\\"./EnumerableSet.sol\\\";\\n\\ncontract EliteFloorCalculator is IFloorCalculator, TokensRecoverable {\\n    using SafeMath for uint256;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    IERC20 immutable rootedToken;\\n    address immutable rootedElitePair;\\n    address immutable rootedBasePair;\\n    ISwapRouter02 immutable internal swapRouter;\\n    ISwapFactory immutable internal swapFactory;\\n    EnumerableSet.AddressSet ignoredAddresses;\\n\\n    constructor(IERC20 _rootedToken, IERC20 _eliteToken, IERC20 _baseToken, ISwapFactory _swapFactory, ISwapRouter02 _swapRouter) {\\n        rootedToken = _rootedToken;\\n        swapFactory = _swapFactory;\\n        swapRouter = _swapRouter;\\n\\n        rootedElitePair = _swapFactory.getPair(address(_eliteToken), address(_rootedToken));\\n        rootedBasePair = _swapFactory.getPair(address(_baseToken), address(_rootedToken));\\n    }    \\n\\n\\n    function setIgnoreAddresses(address ignoredAddress, bool add) public ownerOnly() {\\n        if (add) { \\n            ignoredAddresses.add(ignoredAddress); \\n        } else { \\n            ignoredAddresses.remove(ignoredAddress); \\n        }\\n    }\\n\\n    function isIgnoredAddress(address ignoredAddress) public view returns (bool) {\\n        return ignoredAddresses.contains(ignoredAddress);\\n    }\\n\\n    function ignoredAddressCount() public view returns (uint256) {\\n        return ignoredAddresses.length();\\n    }\\n\\n    function ignoredAddressAt(uint256 index) public view returns (address) {\\n        return ignoredAddresses.at(index);\\n    }\\n\\n    function ignoredAddressesTotalBalance() public view returns (uint256) {\\n        uint256 total = 0;\\n        for (uint i = 0; i \\u003c ignoredAddresses.length(); i++) {\\n            total = total.add(rootedToken.balanceOf(ignoredAddresses.at(i)));\\n        }\\n\\n        return total;\\n    }\\n\\n    function calculateSubFloor(IERC20 baseToken, IERC20 eliteToken) public override view returns (uint256) {\\n        uint256 totalRootedInPairs = rootedToken.balanceOf(rootedElitePair).add(rootedToken.balanceOf(rootedBasePair));\\n        uint256 totalBaseAndEliteInPairs = eliteToken.balanceOf(rootedElitePair).add(baseToken.balanceOf(rootedBasePair));\\n        uint256 rootedCirculatingSupply = rootedToken.totalSupply().sub(totalRootedInPairs).sub(ignoredAddressesTotalBalance());\\n        uint256 amountUntilFloor = swapRouter.getAmountOut(rootedCirculatingSupply, totalRootedInPairs, totalBaseAndEliteInPairs);\\n\\n        uint256 totalExcessInPools = totalBaseAndEliteInPairs.sub(amountUntilFloor);\\n        uint256 previouslySwept = eliteToken.totalSupply().sub(baseToken.balanceOf(address(eliteToken)));\\n        \\n        if (previouslySwept \\u003e= totalExcessInPools) { return 0; }\\n\\n        return totalExcessInPools.sub(previouslySwept);\\n    }\\n}\"},\"EliteFloorCalculatorV1.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\nimport \\\"./IFloorCalculator.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./SwapLibrary.sol\\\";\\nimport \\\"./ISwapFactory.sol\\\";\\nimport \\\"./TokensRecoverable.sol\\\";\\nimport \\\"./EnumerableSet.sol\\\";\\n\\ncontract EliteFloorCalculatorV1 is IFloorCalculator, TokensRecoverable {\\n    using SafeMath for uint256;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    IERC20 immutable rootedToken;\\n    ISwapFactory immutable swapFactory;\\n    EnumerableSet.AddressSet ignoredAddresses;\\n\\n    constructor(IERC20 _rootedToken, ISwapFactory _swapFactory) {\\n        rootedToken = _rootedToken;\\n        swapFactory = _swapFactory;\\n    }    \\n\\n    function setIgnoreAddresses(address ignoredAddress, bool add) public ownerOnly() {\\n        if (add) { \\n            ignoredAddresses.add(ignoredAddress); \\n        } else { \\n            ignoredAddresses.remove(ignoredAddress); \\n        }\\n    }\\n\\n    function isIgnoredAddress(address ignoredAddress) public view returns (bool) {\\n        return ignoredAddresses.contains(ignoredAddress);\\n    }\\n\\n    function ignoredAddressCount() public view returns (uint256) {\\n        return ignoredAddresses.length();\\n    }\\n\\n    function ignoredAddressAt(uint256 index) public view returns (address) {\\n        return ignoredAddresses.at(index);\\n    }\\n\\n    function ignoredAddressesTotalBalance() public view returns (uint256) {\\n        uint256 total = 0;\\n        for (uint i = 0; i \\u003c ignoredAddresses.length(); i++) {\\n            total = total.add(rootedToken.balanceOf(ignoredAddresses.at(i)));\\n        }\\n\\n        return total;\\n    }\\n\\n    function calculateExcessInPool(IERC20 token, address pair, uint256 liquidityShare, uint256 rootedTokenTotalSupply, uint256 rootedTokenPoolsLiquidity) internal view returns (uint256) {\\n        uint256 freeRootedToken = (rootedTokenTotalSupply.sub(rootedTokenPoolsLiquidity)).mul(liquidityShare).div(1e12);\\n\\n        uint256 sellAllProceeds = 0;\\n        if (freeRootedToken \\u003e 0) {\\n            address[] memory path = new address[](2);\\n            path[0] = address(rootedToken);\\n            path[1] = address(token);\\n            uint256[] memory amountsOut = SwapLibrary.getAmountsOut(address(swapFactory), freeRootedToken, path);\\n            sellAllProceeds = amountsOut[1];\\n        }\\n\\n        uint256 backingInPool = token.balanceOf(pair);\\n        if (backingInPool \\u003c= sellAllProceeds) { return 0; }\\n        uint256 excessInPool = backingInPool - sellAllProceeds;\\n\\n        return excessInPool;\\n    }\\n\\n    function calculateExcessInPools(IERC20 baseToken, IERC20 eliteToken) public view returns (uint256) {\\n        address rootedElitePair = SwapLibrary.pairFor(address(swapFactory), address(rootedToken), address(eliteToken));\\n        address rootedBasePair = SwapLibrary.pairFor(address(swapFactory), address(rootedToken), address(baseToken));   \\n        \\n        uint256 rootedTokenTotalSupply = rootedToken.totalSupply().sub(ignoredAddressesTotalBalance());\\n        uint256 rootedTokenPoolsLiquidity = rootedToken.balanceOf(rootedElitePair).add(rootedToken.balanceOf(rootedBasePair));\\n        uint256 baseTokenPoolsLiquidity = eliteToken.balanceOf(rootedElitePair).add(baseToken.balanceOf(rootedBasePair));\\n\\n        uint256 rootedLiquidityShareInElitePair = rootedToken.balanceOf(rootedElitePair).mul(1e12).div(rootedTokenPoolsLiquidity);\\n        uint256 eliteLiquidityShareInElitePair = eliteToken.balanceOf(rootedElitePair).mul(1e12).div(baseTokenPoolsLiquidity);\\n        uint256 avgLiquidityShareInElitePair = (rootedLiquidityShareInElitePair.add(eliteLiquidityShareInElitePair)).div(2);\\n        uint256 one = 1e12;\\n\\n        uint256 excessInElitePool = calculateExcessInPool(eliteToken, rootedElitePair, avgLiquidityShareInElitePair, rootedTokenTotalSupply, rootedTokenPoolsLiquidity);\\n        uint256 excessInBasePool = calculateExcessInPool(baseToken, rootedBasePair, (one).sub(avgLiquidityShareInElitePair), rootedTokenTotalSupply, rootedTokenPoolsLiquidity);\\n        return excessInElitePool.add(excessInBasePool);\\n    }\\n\\n    function calculateSubFloor(IERC20 baseToken, IERC20 eliteToken) public override view returns (uint256) {        \\n        uint256 excessInPools = calculateExcessInPools(baseToken, eliteToken);\\n        uint256 requiredBacking = eliteToken.totalSupply().sub(excessInPools);\\n        uint256 currentBacking = baseToken.balanceOf(address(eliteToken));\\n        if (requiredBacking \\u003e= currentBacking) { return 0; }\\n        return currentBacking - requiredBacking;\\n    }\\n}\"},\"EliteToken.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\nimport \\\"./ERC31337.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\n\\ncontract EliteToken is ERC31337 {\\n    using Address for address;\\n    using SafeMath for uint256;\\n    \\n    mapping (address =\\u003e bool) public freeParticipantControllers;\\n    mapping (address =\\u003e bool) public freeParticipants; \\n\\n    mapping (address =\\u003e bool) public burnRateControllers;\\n\\n    uint16 burnRate;\\n\\n    constructor (IERC20 _wrappedToken) ERC31337(_wrappedToken, \\\"Degen Protocol Liquidity\\\", \\\"eSH33P\\\") { }    \\n\\n    function setFreeParticipantController(address freeParticipantController, bool allow) public ownerOnly() {\\n        freeParticipantControllers[freeParticipantController] = allow;\\n    }\\n\\n    function setFreeParticipant(address participant, bool free) public {\\n        require (msg.sender == owner || freeParticipantControllers[msg.sender], \\\"Not an owner or free participant controller\\\");\\n        freeParticipants[participant] = free;\\n    }\\n\\n    function setBurnRateController(address burnRateController, bool allow) public ownerOnly() {\\n        burnRateControllers[burnRateController] = allow;\\n    }\\n\\n    function setBurnRate(uint16 _burnRate) public {\\n        require (msg.sender == owner || burnRateControllers[msg.sender], \\\"Not an owner or burn rate controller\\\");\\n        require (_burnRate \\u003c= 10000, \\\"But rate must be less or equal to 100%\\\");\\n       \\n        burnRate = _burnRate;\\n    }\\n\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual override {\\n        require(sender != address(0), \\\"EliteToken: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"EliteToken: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n        uint256 remaining = amount;\\n\\n        if (!freeParticipants[sender] \\u0026\\u0026 !freeParticipants[recipient] \\u0026\\u0026 burnRate \\u003e 0) {\\n            uint256 burn = amount * burnRate / 10000;\\n            amount = remaining = remaining.sub(burn, \\\"Burn too much\\\");\\n            _burn(sender, burn);\\n        }\\n        \\n        _balanceOf[sender] = _balanceOf[sender].sub(amount, \\\"EliteToken: transfer amount exceeds balance\\\");\\n        _balanceOf[recipient] = _balanceOf[recipient].add(remaining);\\n        \\n        emit Transfer(sender, recipient, remaining);\\n    }\\n}\"},\"EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity \\u003e=0.6.0 \\u003c0.8.0;\\n\\nlibrary EnumerableSet {\\n    struct Set {\\n        bytes32[] _values;\\n        mapping (bytes32 =\\u003e uint256) _indexes;\\n    }\\n\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            set._values[toDeleteIndex] = lastvalue;\\n            set._indexes[lastvalue] = toDeleteIndex + 1;\\n            set._values.pop();\\n\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length \\u003e index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(value)));\\n    }\\n\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint256(_at(set._inner, index)));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\"},\"ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\nabstract contract ERC165 is IERC165 {\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\"},\"ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\nimport \\\"./SafeMath.sol\\\";\\n\\nimport \\\"./IERC20.sol\\\";\\n\\nabstract contract ERC20 is IERC20 {\\n    using SafeMath for uint256;\\n\\n    string public override name;\\n    string public override symbol;\\n    \\n    uint8 public override decimals = 18;\\n\\n    uint256 public override totalSupply;\\n\\n    mapping (address =\\u003e uint256) internal _balanceOf;\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) public override allowance;\\n\\n    constructor (string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    function balanceOf(address a) public virtual override view returns (uint256) { return _balanceOf[a]; }\\n\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        uint256 oldAllowance = allowance[sender][msg.sender];\\n        if (oldAllowance != uint256(-1)) {\\n            _approve(sender, msg.sender, oldAllowance.sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        }\\n        return true;\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(msg.sender, spender, allowance[msg.sender][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(msg.sender, spender, allowance[msg.sender][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balanceOf[sender] = _balanceOf[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balanceOf[recipient] = _balanceOf[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        totalSupply = totalSupply.add(amount);\\n        _balanceOf[account] = _balanceOf[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balanceOf[account] = _balanceOf[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        totalSupply = totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        allowance[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    function _setupDecimals(uint8 _decimals) internal {\\n        decimals = _decimals;\\n    }\\n\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\"},\"ERC31337.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\nimport \\\"./SafeERC20.sol\\\";\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./IERC31337.sol\\\";\\nimport \\\"./IFloorCalculator.sol\\\";\\n\\nimport \\\"./WrappedERC20.sol\\\";\\n\\ncontract ERC31337 is WrappedERC20, IERC31337 {\\n    using SafeERC20 for IERC20;\\n\\n    IFloorCalculator public override floorCalculator;\\n    \\n    mapping (address =\\u003e bool) public override sweepers;\\n\\n    constructor(IERC20 _wrappedToken, string memory _name, string memory _symbol) WrappedERC20(_wrappedToken, _name, _symbol) {}\\n\\n    function setFloorCalculator(IFloorCalculator _floorCalculator) public override ownerOnly() {\\n        floorCalculator = _floorCalculator;\\n    }\\n\\n    function setSweeper(address sweeper, bool allow) public override ownerOnly() {\\n        sweepers[sweeper] = allow;\\n    }\\n\\n    function sweepFloor(address to) public override returns (uint256 amountSwept) {\\n        require (to != address(0));\\n        require (sweepers[msg.sender], \\\"Sweepers only\\\");\\n        amountSwept = floorCalculator.calculateSubFloor(wrappedToken, this);\\n        if (amountSwept \\u003e 0) {\\n            wrappedToken.safeTransfer(to, amountSwept);\\n        }\\n    }\\n}\"},\"ERC721.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"./IERC721Metadata.sol\\\";\\nimport \\\"./Address.sol\\\";\\nimport \\\"./Context.sol\\\";\\nimport \\\"./Strings.sol\\\";\\nimport \\\"./ERC165.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./Owned.sol\\\";\\n\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata, Owned {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    mapping(uint256 =\\u003e address) private _owners;\\n    mapping(address =\\u003e uint256) private _balances;\\n    mapping(uint256 =\\u003e address) private _tokenApprovals;\\n    mapping(address =\\u003e mapping(address =\\u003e bool)) private _operatorApprovals;\\n\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n        return _balances[owner];\\n    }\\n\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _owners[tokenId];\\n        require(owner != address(0), \\\"ERC721: owner query for nonexistent token\\\");\\n        return owner;\\n    }\\n\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length \\u003e 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\n    }\\n\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()), \\\"ERC721: approve caller is not owner nor approved for all\\\");\\n        _approve(to, tokenId);\\n    }\\n\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(operator != _msgSender(), \\\"ERC721: approve to caller\\\");\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _owners[tokenId] != address(0);\\n    }\\n\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ERC721.ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\\n        _mint(to, tokenId);\\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n        \\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n        _approve(address(0), tokenId);\\n\\n        _balances[owner] -= 1;\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n        _approve(address(0), tokenId);\\n        \\n        _balances[from] -= 1;\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual {}\\n}\"},\"ERC721URIStorage.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\nimport \\\"./ERC721.sol\\\";\\n\\nabstract contract ERC721URIStorage is ERC721 {\\n    using Strings for uint256;\\n\\n    mapping(uint256 =\\u003e string) private _tokenURIs;\\n\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721URIStorage: URI query for nonexistent token\\\");\\n\\n        string memory _tokenURI = _tokenURIs[tokenId];\\n        string memory base = _baseURI();\\n\\n        if (bytes(base).length == 0) {\\n            return _tokenURI;\\n        }\\n\\n        if (bytes(_tokenURI).length \\u003e 0) {\\n            return string(abi.encodePacked(base, _tokenURI));\\n        }\\n\\n        return super.tokenURI(tokenId);\\n    }\\n\\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\\n        require(_exists(tokenId), \\\"ERC721URIStorage: URI set of nonexistent token\\\");\\n        _tokenURIs[tokenId] = _tokenURI;\\n    }\\n\\n    function _burn(uint256 tokenId) internal virtual override {\\n        super._burn(tokenId);\\n\\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\\n            delete _tokenURIs[tokenId];\\n        }\\n    }\\n}\"},\"FeeSplitter.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\nimport \\\"./Address.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./SafeERC20.sol\\\";\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./IGatedERC20.sol\\\";\\nimport \\u0027./ISwapRouter02.sol\\u0027;\\n\\nimport \\\"./TokensRecoverable.sol\\\";\\n\\ncontract FeeSplitter is TokensRecoverable {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n    using Address for address;\\n    \\n    address public devAddress;\\n\\n    ISwapRouter02 public immutable router;\\n\\n    mapping (IGatedERC20 =\\u003e uint256) public sellRates;\\n    mapping (IGatedERC20 =\\u003e uint256) public keepRates;\\n\\n    mapping (IGatedERC20 =\\u003e address[]) public chainTokenFeeCollectors;\\n    mapping (IGatedERC20 =\\u003e uint256[]) public chainTokenFeeRates;\\n\\n    mapping (IGatedERC20 =\\u003e address[]) public rootedTokenFeeCollectors;\\n    mapping (IGatedERC20 =\\u003e uint256[]) public rootedTokenFeeRates;\\n\\n    mapping (IGatedERC20 =\\u003e address[]) public sellPaths;\\n\\n    constructor(address _devAddress, ISwapRouter02 _router) {\\n        devAddress = _devAddress;\\n        router = _router;\\n    }\\n\\n    function setDevAddress(address _devAddress) public ownerOnly() {\\n        devAddress = _devAddress;\\n    }\\n\\n    function setFees(IGatedERC20 token, uint256 sellRate, uint256 keepRate) public ownerOnly() {\\n        require (sellRate + keepRate == 10000, \\\"Total fee rate must be 100%\\\");\\n\\n        sellRates[token] = sellRate;\\n        keepRates[token] = keepRate;\\n        \\n        token.approve(address(router), uint256(-1));\\n    }\\n\\n    function setChainTokenFeeCollectors(IGatedERC20 token, address[] memory collectors, uint256[] memory rates) public ownerOnly() {\\n        require (collectors.length == rates.length, \\\"Fee Collectors and Rates must be the same size\\\");\\n        require (collectors[0] == devAddress, \\\"First address must be dev address, second address must be rootFeeder address\\\");\\n        \\n        uint256 totalRate = 0;\\n        for (uint256 i = 0; i \\u003c rates.length; i++) {\\n            totalRate = totalRate + rates[i];\\n        }\\n        \\n        require (totalRate == 10000, \\\"Total fee rate must be 100%\\\");\\n\\n        chainTokenFeeCollectors[token] = collectors;\\n        chainTokenFeeRates[token] = rates;\\n    }\\n\\n    function setRootedTokenFeeCollectors(IGatedERC20 token, address[] memory collectors, uint256[] memory rates) public ownerOnly() {\\n        require (collectors.length == rates.length, \\\"Fee Collectors and Rates must be the same size\\\");\\n        \\n        uint256 totalRate = 0;\\n        for (uint256 i = 0; i \\u003c rates.length; i++) {\\n            totalRate = totalRate + rates[i];\\n        }\\n\\n        require (totalRate == 10000, \\\"Total fee rate must be 100%\\\");\\n\\n        rootedTokenFeeCollectors[token] = collectors;\\n        rootedTokenFeeRates[token] = rates;\\n    }\\n\\n    function setSellPath(IGatedERC20 token, address[] memory path) public ownerOnly() {\\n        require (path[0] == address(token), \\\"Invalid path\\\");\\n\\n        sellPaths[token] = path;\\n    }\\n\\n    function payFees(IGatedERC20 token) public {\\n        uint256 balance = token.balanceOf(address(this));\\n        require (balance \\u003e 0, \\\"Nothing to pay\\\");\\n\\n        // If sell percentage of a token is more than zero, process the sell and distribute tokens\\n        if (sellRates[token] \\u003e 0) {\\n            uint256 sellAmount = sellRates[token] * balance / 10000;\\n            \\n            // Get the path of token to token\\n            address[] memory path = sellPaths[token];\\n\\n            // Carry out the swap\\n            uint256[] memory amounts = router.swapExactTokensForTokens(sellAmount, 0, path, address(this), block.timestamp);\\n \\n            // Get the collectors and rates for the token\\n            address[] memory collectors = chainTokenFeeCollectors[token];\\n            uint256[] memory rates = chainTokenFeeRates[token];\\n\\n            // Distribute the tokens\\n            uint256 lastIndex = path.length - 1;\\n            distribute(IERC20(path[lastIndex]), amounts[lastIndex], collectors, rates);\\n        }\\n\\n        // If keep percentage of a token is more than zero, distribute tokens\\n        if (keepRates[token] \\u003e 0) {\\n            uint256 keepAmount = keepRates[token] * balance / 10000;\\n            address[] memory collectors = rootedTokenFeeCollectors[token];\\n            uint256[] memory rates = rootedTokenFeeRates[token];\\n            distribute(token, keepAmount, collectors, rates);\\n        }\\n    }\\n    \\n    function distribute(IERC20 token, uint256 amount, address[] memory collectors, uint256[] memory rates) private {\\n        for (uint256 i = 0; i \\u003c collectors.length; i++) {\\n            address collector = collectors[i];\\n            uint256 rate = rates[i];\\n\\n            if (rate \\u003e 0) {\\n                uint256 feeAmount = rate * amount / 10000;\\n                token.transfer(collector, feeAmount);\\n            }\\n        }\\n    }\\n}\"},\"GatedERC20.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./SafeMath.sol\\\";\\n\\nimport \\\"./IGatedERC20.sol\\\";\\nimport \\\"./ITransferGate.sol\\\";\\n\\nimport \\\"./TokensRecoverable.sol\\\";\\n\\nimport \\\"./ERC20.sol\\\";\\n\\nabstract contract GatedERC20 is ERC20, TokensRecoverable, IGatedERC20 {\\n    using SafeMath for uint256;\\n\\n    ITransferGate public override transferGate;\\n\\n    constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) {}\\n\\n    function setTransferGate(ITransferGate _transferGate) public override ownerOnly() {\\n        transferGate = _transferGate;\\n    }\\n\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual override {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        ITransferGate _transferGate = transferGate;\\n        uint256 remaining = amount;\\n        \\n        if (address(_transferGate) != address(0)) {\\n            address splitter = _transferGate.feeSplitter();\\n            uint256 fees = _transferGate.handleTransfer(msg.sender, sender, recipient, amount);\\n            if (fees \\u003e 0) {\\n               _balanceOf[splitter] = _balanceOf[splitter].add(fees);\\n                emit Transfer(sender, splitter, fees);\\n                remaining = remaining.sub(fees);\\n            }           \\n        }\\n\\n        _balanceOf[sender] = _balanceOf[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balanceOf[recipient] = _balanceOf[recipient].add(remaining);\\n        emit Transfer(sender, recipient, remaining);\\n    }\\n\\n    function burn(uint256 amount) public override {\\n        _burn(msg.sender, amount);\\n    }\\n}\"},\"IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\ninterface IERC165 {\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\ninterface IERC20 {\\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\n\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address _account) external view returns (uint256);\\n    function transfer(address _recipient, uint256 _amount) external returns (bool);\\n    function allowance(address _owner, address _spender) external view returns (uint256);\\n    function approve(address _spender, uint256 _amount) external returns (bool);\\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n}\"},\"IERC31337.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\nimport \\\"./IWrappedERC20.sol\\\";\\nimport \\\"./IFloorCalculator.sol\\\";\\n\\ninterface IERC31337 is IWrappedERC20 {\\n    function floorCalculator() external view returns (IFloorCalculator);\\n    function sweepers(address _sweeper) external view returns (bool);\\n    \\n    function setFloorCalculator(IFloorCalculator _floorCalculator) external;\\n    function setSweeper(address _sweeper, bool _allow) external;\\n    function sweepFloor(address _to) external returns (uint256 amountSwept);\\n}\"},\"IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\ninterface IERC721 is IERC165 {\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n    function approve(address to, uint256 tokenId) external;\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n    function setApprovalForAll(address operator, bool _approved) external;\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\"},\"IERC721Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\nimport \\\"./IERC721.sol\\\";\\n\\ninterface IERC721Metadata is IERC721 {\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\"},\"IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\ninterface IERC721Receiver {\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\\n}\"},\"IFloorCalculator.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IFloorCalculator {\\n    function calculateSubFloor(IERC20 baseToken, IERC20 eliteToken) external view returns (uint256);\\n}\"},\"IGatedERC20.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./ITransferGate.sol\\\";\\n\\ninterface IGatedERC20 is IERC20 {\\n    function transferGate() external view returns (ITransferGate);\\n\\n    function setTransferGate(ITransferGate _transferGate) external;\\n    function burn(uint256 amount) external;\\n}\"},\"ILiquidityController.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\ninterface ILiquidityController {\\n    function balancePriceBase(uint256 amount) external;\\n    function balancePriceElite(uint256 amount) external;\\n    function removeBuyAndTax(uint256 amount, address token, uint16 tax, uint256 time) external;\\n    function buyAndTax(address token, uint256 amountToSpend, uint16 tax, uint256 time) external;\\n    function sweepFloor() external;\\n    function zapEliteToBase(uint256 liquidity) external;\\n    function zapBaseToElite(uint256 liquidity) external;\\n    function wrapToElite(uint256 baseAmount) external;\\n    function unwrapElite(uint256 eliteAmount) external;\\n    function addLiquidity(address eliteOrBase, uint256 baseAmount) external;\\n    function removeLiquidity(address eliteOrBase, uint256 tokens) external;    \\n    function buyRooted(address token, uint256 amountToSpend) external;\\n    function sellRooted(address token, uint256 amountToSpend) external;   \\n}\"},\"ILiquidityLockedERC20.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\nimport \\\"./ISwapPair.sol\\\";\\n\\ninterface ILiquidityLockedERC20 {\\n    function setLiquidityLock(ISwapPair _liquidityPair, bool _locked) external;\\n}\"},\"IMarketDistribution.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\ninterface IMarketDistribution {\\n    function distributionComplete() external view returns (bool);\\n    function vestingPeriodStartTime() external view returns (uint256); \\n    function vestingPeriodEndTime() external view returns (uint256);\\n    \\n    function distribute() external;        \\n    function claim(address account) external returns (uint256);\\n    function claimReferralRewards(address account, uint256 referralShare) external;\\n}\"},\"IMarketGeneration.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\ninterface IMarketGeneration {\\n    function contribution(address) external view returns (uint256);\\n    function referralPoints(address) external view returns (uint256);    \\n    function totalContribution() external view returns (uint256);\\n    function totalReferralPoints() external view returns (uint256);\\n}\"},\"IOwned.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\ninterface IOwned {\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function owner() external view returns (address);\\n\\n    function transferOwnership(address newOwner) external;\\n    function claimOwnership() external;\\n}\"},\"ISwapCallee.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity \\u003e=0.5.0;\\n\\ninterface ISwapCallee {\\n    function swapCall(address sender, uint amount0, uint amount1, bytes calldata data) external;\\n}\"},\"ISwapERC20.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity \\u003e=0.5.0;\\n\\ninterface ISwapERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n}\"},\"ISwapFactory.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\ninterface ISwapFactory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\"},\"ISwapPair.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\ninterface ISwapPair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\"},\"ISwapRouter01.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\ninterface ISwapRouter01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\"},\"ISwapRouter02.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\nimport \\u0027./ISwapRouter01.sol\\u0027;\\n\\ninterface ISwapRouter02 is ISwapRouter01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint amountETH);\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\\n}\"},\"ITokensRecoverable.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface ITokensRecoverable {\\n    function recoverTokens(IERC20 token) external;\\n}\"},\"ITransferGate.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\ninterface ITransferGate {\\n    function feeSplitter() external view returns (address);\\n    function handleTransfer(address msgSender, address from, address to, uint256 amount) external returns (uint256);\\n}\"},\"IWBNB.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\ninterface IWBNB {    \\n    function deposit() external payable;\\n}\"},\"IWrappedERC20.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./IWrappedERC20Events.sol\\\";\\n\\ninterface IWrappedERC20 is IERC20, IWrappedERC20Events {\\n    function wrappedToken() external view returns (IERC20);\\n    function depositTokens(uint256 _amount) external;\\n    function withdrawTokens(uint256 _amount) external;\\n}\"},\"IWrappedERC20Events.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\ninterface IWrappedERC20Events {\\n    event Deposit(address indexed from, uint256 amount);\\n    event Withdrawal(address indexed to, uint256 amount);\\n}\\n\"},\"LiquidityController.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\nimport \\\"./TokensRecoverable.sol\\\";\\nimport \\\"./IERC31337.sol\\\";\\nimport \\\"./ISwapRouter02.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./RootedTransferGate.sol\\\";\\nimport \\\"./ISwapFactory.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./ILiquidityController.sol\\\";\\nimport \\\"./IFloorCalculator.sol\\\";\\n\\ncontract LiquidityController is TokensRecoverable, ILiquidityController {\\n    using SafeMath for uint256;\\n\\n    ISwapRouter02 immutable swapRouter;\\n    ISwapFactory immutable swapFactory;\\n    IERC20 immutable rooted;\\n    IERC20 immutable base;\\n    IERC31337 immutable elite;\\n    IERC20 immutable rootedEliteLP;\\n    IERC20 immutable rootedBaseLP;\\n    IFloorCalculator public calculator;\\n    RootedTransferGate public gate;\\n    mapping(address =\\u003e bool) public liquidityControllers;\\n\\n    constructor(ISwapRouter02 _swapRouter, IERC20 _base, IERC20 _rooted, IERC31337 _elite, IFloorCalculator _calculator, RootedTransferGate _gate) {\\n        swapRouter = _swapRouter;\\n        base = _base;\\n        elite = _elite;\\n        rooted = _rooted;\\n        calculator = _calculator;\\n        gate = _gate;\\n\\n        ISwapFactory _swapFactory = ISwapFactory(_swapRouter.factory());\\n        swapFactory = _swapFactory;        \\n        \\n        _base.approve(address(_elite), uint256(-1));\\n        _base.approve(address(_swapRouter), uint256(-1));\\n        _rooted.approve(address(_swapRouter), uint256(-1));\\n        IERC20 _rootedBaseLP = IERC20(_swapFactory.getPair(address(_base), address(_rooted)));\\n        _rootedBaseLP.approve(address(_swapRouter), uint256(-1));\\n        rootedBaseLP = _rootedBaseLP;\\n        _elite.approve(address(_swapRouter), uint256(-1));\\n        IERC20 _rootedEliteLP = IERC20(_swapFactory.getPair(address(_elite), address(_rooted)));\\n        _rootedEliteLP.approve(address(_swapRouter), uint256(-1));\\n        rootedEliteLP = _rootedEliteLP;\\n    }\\n\\n    modifier liquidityControllerOnly() {\\n        require(liquidityControllers[msg.sender], \\\"Not a Liquidity Controller\\\");\\n        _;\\n    }\\n\\n    // Owner function to enable other contracts or addresses to use the Liquidity Controller\\n    function setLiquidityController(address controlAddress, bool controller) public ownerOnly() {\\n        liquidityControllers[controlAddress] = controller;\\n    }\\n\\n    function setCalculatorAndGate(IFloorCalculator _calculator, RootedTransferGate _gate) public ownerOnly() {\\n        calculator = _calculator;\\n        gate = _gate;\\n    }\\n\\n    // Removes liquidity, buys from either pool, sets a temporary dump tax\\n    function removeBuyAndTax(uint256 amount, address token, uint16 tax, uint256 time) public override liquidityControllerOnly() {\\n        gate.setUnrestricted(true);\\n        amount = removeLiq(token, amount);\\n        buyRootedToken(token, amount);\\n        gate.setDumpTax(tax, time);\\n        gate.setUnrestricted(false);\\n    }\\n\\n    // Use Base tokens held by this contract to buy from the Base Pool and sell in the Elite Pool\\n    function balancePriceBase(uint256 amount) public override liquidityControllerOnly() {\\n        amount = buyRootedToken(address(base), amount);\\n        amount = sellRootedToken(address(elite), amount);\\n        elite.withdrawTokens(amount);\\n    }\\n\\n    // Use Base tokens held by this contract to buy from the Elite Pool and sell in the Base Pool\\n    function balancePriceElite(uint256 amount) public override liquidityControllerOnly() {        \\n        elite.depositTokens(amount);\\n        amount = buyRootedToken(address(elite), amount);\\n        amount = sellRootedToken(address(base), amount);\\n    }\\n\\n    // Uses value in the controller to buy\\n    function buyAndTax(address token, uint256 amountToSpend, uint16 tax, uint256 time) public override liquidityControllerOnly() {\\n        buyRootedToken(token, amountToSpend);\\n        gate.setDumpTax(tax, time);\\n    }\\n\\n    // Sweeps the Base token under the floor to this address\\n    function sweepFloor() public override liquidityControllerOnly() {\\n        elite.sweepFloor(address(this));\\n    }\\n\\n    // Move liquidity from Elite pool ---\\u003e\\u003e Base pool\\n    function zapEliteToBase(uint256 liquidity) public override liquidityControllerOnly() {       \\n        gate.setUnrestricted(true);\\n        liquidity = removeLiq(address(elite), liquidity);\\n        elite.withdrawTokens(liquidity);\\n        addLiq(address(base), liquidity);\\n        gate.setUnrestricted(false);\\n    }\\n\\n    // Move liquidity from Base pool ---\\u003e\\u003e Elite pool\\n    function zapBaseToElite(uint256 liquidity) public override liquidityControllerOnly() {\\n        gate.setUnrestricted(true);\\n        liquidity = removeLiq(address(base), liquidity);\\n        elite.depositTokens(liquidity);\\n        addLiq(address(elite), liquidity);\\n        gate.setUnrestricted(false);\\n    }\\n\\n    function wrapToElite(uint256 baseAmount) public override liquidityControllerOnly() {\\n        elite.depositTokens(baseAmount);\\n    }\\n\\n    function unwrapElite(uint256 eliteAmount) public override liquidityControllerOnly() {\\n        elite.withdrawTokens(eliteAmount);\\n    }\\n\\n    function addLiquidity(address eliteOrBase, uint256 baseAmount) public override liquidityControllerOnly() {\\n        gate.setUnrestricted(true);\\n        addLiq(eliteOrBase, baseAmount);\\n        gate.setUnrestricted(false);\\n    }\\n\\n    function removeLiquidity(address eliteOrBase, uint256 tokens) public override liquidityControllerOnly() {\\n        gate.setUnrestricted(true);\\n        removeLiq(eliteOrBase, tokens);\\n        gate.setUnrestricted(false);\\n    }\\n\\n    function buyRooted(address token, uint256 amountToSpend) public override liquidityControllerOnly() {\\n        buyRootedToken(token, amountToSpend);\\n    }\\n\\n    function sellRooted(address token, uint256 amountToSpend) public override liquidityControllerOnly() {\\n        sellRootedToken(token, amountToSpend);\\n    }\\n\\n    function transferTokens(address token, address to, uint256 amount) public liquidityControllerOnly() {\\n        IERC20(token).transfer(to, amount);\\n    }\\n\\n    function addLiq(address eliteOrBase, uint256 baseAmount) internal {\\n        swapRouter.addLiquidity(address(eliteOrBase), address(rooted), baseAmount, rooted.balanceOf(address(this)), 0, 0, address(this), block.timestamp);\\n    }\\n\\n    function removeLiq(address eliteOrBase, uint256 tokens) internal returns (uint256) {\\n        (tokens, ) = swapRouter.removeLiquidity(address(eliteOrBase), address(rooted), tokens, 0, 0, address(this), block.timestamp);\\n        return tokens;\\n    }\\n\\n    function buyRootedToken(address token, uint256 amountToSpend) internal returns (uint256) {\\n        uint256[] memory amounts = swapRouter.swapExactTokensForTokens(amountToSpend, 0, buyPath(token), address(this), block.timestamp);\\n        amountToSpend = amounts[1];\\n        return amountToSpend;\\n    }\\n\\n    function sellRootedToken(address token, uint256 amountToSpend) internal returns (uint256) {\\n        uint256[] memory amounts = swapRouter.swapExactTokensForTokens(amountToSpend, 0, sellPath(token), address(this), block.timestamp);\\n        amountToSpend = amounts[1];\\n        return amountToSpend;\\n    }\\n\\n    function buyPath(address token) internal view returns (address[] memory) {\\n        address[] memory path = new address[](2);\\n        path[0] = address(token);\\n        path[1] = address(rooted);\\n        return path;\\n    }\\n\\n    function sellPath(address token) internal view returns (address[] memory) {\\n        address[] memory path = new address[](2);\\n        path[0] = address(rooted);\\n        path[1] = address(token);\\n        return path;\\n    }\\n}\"},\"LiquidityLockedERC20.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\nimport \\\"./ERC20.sol\\\";\\n\\nimport \\\"./ISwapPair.sol\\\";\\nimport \\\"./ILiquidityLockedERC20.sol\\\";\\n\\nimport \\\"./Owned.sol\\\";\\n\\nimport \\\"./GatedERC20.sol\\\";\\n\\nabstract contract LiquidityLockedERC20 is GatedERC20, ILiquidityLockedERC20 {\\n    mapping (ISwapPair =\\u003e bool) public liquidityPairLocked;\\n    mapping (address =\\u003e bool) public liquidityController;\\n\\n    struct CallRecord {\\n        address origin;\\n        uint32 blockNumber;\\n        bool transferFrom;\\n    }\\n\\n    CallRecord balanceAllowed;\\n\\n    constructor(string memory _name, string memory _symbol) GatedERC20(_name, _symbol) { }\\n\\n    function setLiquidityLock(ISwapPair _liquidityPair, bool _locked) public override {\\n        require (liquidityController[msg.sender], \\\"Liquidity controller only\\\");\\n        require (_liquidityPair.token0() == address(this) || _liquidityPair.token1() == address(this), \\\"Unrelated pair\\\");\\n        liquidityPairLocked[_liquidityPair] = _locked;\\n    }\\n\\n    function setLiquidityController(address _liquidityController, bool _canControl) public ownerOnly() {\\n        liquidityController[_liquidityController] = _canControl;\\n    }\\n\\n    function balanceOf(address account) public override view returns (uint256) {\\n        ISwapPair pair = ISwapPair(address(msg.sender));\\n        if (liquidityPairLocked[pair]) {\\n            CallRecord memory last = balanceAllowed;\\n            require (last.origin == tx.origin \\u0026\\u0026 last.blockNumber == block.number, \\\"Liquidity is locked\\\");\\n            if (last.transferFrom) {\\n                (uint256 reserve0, uint256 reserve1,) = pair.getReserves();\\n                IERC20 token0 = IERC20(pair.token0());\\n                if (address(token0) == address(this)) {\\n                    require (IERC20(pair.token1()).balanceOf(address(pair)) \\u003c reserve1, \\\"Liquidity is locked\\\");\\n                }\\n                else {\\n                    require (token0.balanceOf(address(pair)) \\u003c reserve0, \\\"Liquidity is locked\\\");\\n                }\\n            }\\n        }\\n        return super.balanceOf(account);\\n    }\\n\\n    function allowBalance(bool _transferFrom) private {\\n        CallRecord memory last = balanceAllowed;\\n        CallRecord memory allow = CallRecord({ \\n            origin: tx.origin,\\n            blockNumber: uint32(block.number),\\n            transferFrom: _transferFrom\\n        });\\n        require (last.origin != allow.origin || last.blockNumber != allow.blockNumber || last.transferFrom != allow.transferFrom, \\\"Liquidity is locked (Please try again next block)\\\");\\n        balanceAllowed = allow;\\n    }\\n\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {        \\n        if (liquidityPairLocked[ISwapPair(address(msg.sender))]) {\\n            allowBalance(false);\\n        } else {\\n            balanceAllowed = CallRecord({ origin: address(0), blockNumber: 0, transferFrom: false });\\n        }\\n        return super.transfer(recipient, amount);\\n    }\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        if (liquidityPairLocked[ISwapPair(recipient)]) {\\n            allowBalance(true);\\n        } else {\\n            balanceAllowed = CallRecord({ origin: address(0), blockNumber: 0, transferFrom: false });\\n        }\\n        return super.transferFrom(sender, recipient, amount);\\n    }\\n}\"},\"MarketDistribution.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\nimport \\\"./IMarketDistribution.sol\\\";\\nimport \\\"./IMarketGeneration.sol\\\";\\nimport \\\"./RootedToken.sol\\\";\\nimport \\\"./RootedTransferGate.sol\\\";\\nimport \\\"./TokensRecoverable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./IERC31337.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./ISwapRouter02.sol\\\";\\nimport \\\"./ISwapFactory.sol\\\";\\nimport \\\"./ISwapPair.sol\\\";\\nimport \\\"./SafeERC20.sol\\\";\\n\\ncontract MarketDistribution is TokensRecoverable, IMarketDistribution {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    bool public override distributionComplete;\\n\\n    ISwapRouter02 swapRouter;\\n    ISwapFactory swapFactory;\\n\\n    IMarketGeneration public marketGeneration;\\n    RootedToken public rootedToken;\\n    IERC31337 public eliteToken;\\n    IERC20 public baseToken;\\n\\n    address public devAddress;\\n\\n    address public userClaimContract;\\n    address public liquidityController;\\n    \\n    ISwapPair public rootedEliteLP;\\n    ISwapPair public rootedBaseLP;\\n\\n    uint256 public constant rootedTokenSupply = 1e24; // 1 million\\n\\n    uint256 public totalBaseTokenCollected;\\n    uint256 public totalBoughtForContributors;\\n\\n    mapping (address =\\u003e uint256) public claimTime;\\n    mapping (address =\\u003e uint256) public totalClaim;\\n    mapping (address =\\u003e uint256) public remainingClaim;\\n    \\n    uint256 public totalBoughtForReferrals;\\n    uint256 public recoveryDate = block.timestamp + 2592000; // 1 Month\\n\\n    uint16 public preBuyForReferralsPercent;\\n    uint16 public preBuyForContributorsPercent;\\n    uint16 public preBuyForMarketStabilizationPercent;\\n\\n    uint256 public override vestingPeriodStartTime;\\n    uint256 public override vestingPeriodEndTime; \\n    \\n    uint256 public vestingDuration;\\n    uint256 public rootedBottom;\\n\\n    constructor(address _devAddress, address _userClaimContract) {\\n        devAddress = _devAddress;\\n        userClaimContract = _userClaimContract;\\n    }\\n\\n    function init(\\n        RootedToken _rootedToken, \\n        IERC31337 _eliteToken, \\n        address _liquidityController,\\n        ISwapRouter02 _swapRouter, \\n        IMarketGeneration _marketGeneration,\\n        uint256 _vestingDuration, \\n        uint16 _preBuyForReferralsPercent, \\n        uint16 _preBuyForContributorsPercent, \\n        uint16 _preBuyForMarketStabilizationPercent) public ownerOnly() {        \\n        rootedToken = _rootedToken;\\n        eliteToken = _eliteToken;\\n        baseToken = _eliteToken.wrappedToken();\\n        liquidityController = _liquidityController;\\n        swapRouter = _swapRouter;\\n        swapFactory = ISwapFactory(_swapRouter.factory());\\n        marketGeneration = _marketGeneration;\\n        vestingDuration = _vestingDuration;\\n        preBuyForReferralsPercent = _preBuyForReferralsPercent;\\n        preBuyForContributorsPercent = _preBuyForContributorsPercent;\\n        preBuyForMarketStabilizationPercent = _preBuyForMarketStabilizationPercent;\\n    }\\n\\n    function setupEliteRooted() public {\\n        rootedEliteLP = ISwapPair(swapFactory.getPair(address(eliteToken), address(rootedToken)));\\n        if (address(rootedEliteLP) == address(0)) \\n        {\\n            rootedEliteLP = ISwapPair(swapFactory.createPair(address(eliteToken), address(rootedToken)));\\n            require (address(rootedEliteLP) != address(0));\\n        }\\n    }\\n\\n    function setupBaseRooted() public {\\n        rootedBaseLP = ISwapPair(swapFactory.getPair(address(baseToken), address(rootedToken)));\\n        if (address(rootedBaseLP) == address(0)) {\\n            rootedBaseLP = ISwapPair(swapFactory.createPair(address(baseToken), address(rootedToken)));\\n            require (address(rootedBaseLP) != address(0));\\n        }\\n    }\\n\\n    function completeSetup() public ownerOnly() {   \\n        require (address(rootedEliteLP) != address(0), \\\"Rooted Elite pool is not created\\\");\\n        require (address(rootedBaseLP) != address(0), \\\"Rooted Base pool is not created\\\");   \\n\\n        eliteToken.approve(address(swapRouter), uint256(-1));\\n        rootedToken.approve(address(swapRouter), uint256(-1));\\n        baseToken.safeApprove(address(swapRouter), uint256(-1));\\n        baseToken.safeApprove(address(eliteToken), uint256(-1));\\n        rootedBaseLP.approve(address(swapRouter), uint256(-1));\\n        rootedEliteLP.approve(address(swapRouter), uint256(-1));\\n    }\\n\\n    function distribute() public override {\\n        require (msg.sender == address(marketGeneration), \\\"Unauthorized\\\");\\n        require (!distributionComplete, \\\"Distribution complete\\\");\\n   \\n        vestingPeriodStartTime = block.timestamp;\\n        vestingPeriodEndTime = block.timestamp + vestingDuration;\\n        distributionComplete = true;\\n\\n        totalBaseTokenCollected = baseToken.balanceOf(address(marketGeneration));\\n        baseToken.safeTransferFrom(msg.sender, address(this), totalBaseTokenCollected);  \\n\\n        RootedTransferGate gate = RootedTransferGate(address(rootedToken.transferGate()));\\n\\n        gate.setUnrestricted(true);\\n        rootedToken.mint(rootedTokenSupply);\\n\\n        rootedToken.transfer(userClaimContract, 537000000000000000000000);\\n\\n        createRootedEliteLiquidity();\\n\\n        eliteToken.sweepFloor(address(this));        \\n        eliteToken.depositTokens(baseToken.balanceOf(address(this)));\\n                \\n        buyTheBottom();\\n        preBuyForReferrals();\\n        preBuyForContributors();\\n        sellTheTop();\\n\\n        uint256 devShare = totalBaseTokenCollected * 600 / 10000;\\n        baseToken.transfer(devAddress, devShare);\\n\\n        baseToken.transfer(liquidityController, baseToken.balanceOf(address(this)));\\n\\n        createRootedBaseLiquidity();       \\n\\n        gate.setUnrestricted(false);\\n    }\\n    \\n    function createRootedEliteLiquidity() private {\\n        eliteToken.depositTokens(baseToken.balanceOf(address(this)));\\n        swapRouter.addLiquidity(address(eliteToken), address(rootedToken), eliteToken.balanceOf(address(this)), rootedToken.balanceOf(address(this)), 0, 0, address(this), block.timestamp);\\n    }\\n\\n    function buyTheBottom() private {\\n        uint256 amount = totalBaseTokenCollected * preBuyForMarketStabilizationPercent / 10000;  \\n        uint256[] memory amounts = swapRouter.swapExactTokensForTokens(amount, 0, eliteRootedPath(), address(this), block.timestamp);        \\n        rootedBottom = amounts[1];\\n    }\\n\\n    function sellTheTop() private {\\n        uint256[] memory amounts = swapRouter.swapExactTokensForTokens(rootedBottom, 0, rootedElitePath(), address(this), block.timestamp);\\n        uint256 eliteAmount = amounts[1];\\n        eliteToken.withdrawTokens(eliteAmount);\\n    }   \\n    \\n    function preBuyForReferrals() private {\\n        uint256 amount = totalBaseTokenCollected * preBuyForReferralsPercent / 10000;\\n        uint256[] memory amounts = swapRouter.swapExactTokensForTokens(amount, 0, eliteRootedPath(), address(this), block.timestamp);\\n        totalBoughtForReferrals = amounts[1];\\n    }\\n\\n    function preBuyForContributors() private {\\n        uint256 preBuyAmount = totalBaseTokenCollected * preBuyForContributorsPercent / 10000;\\n        uint256 eliteBalance = eliteToken.balanceOf(address(this));\\n        uint256 amount = preBuyAmount \\u003e eliteBalance ? eliteBalance : preBuyAmount;\\n        uint256[] memory amounts = swapRouter.swapExactTokensForTokens(amount, 0, eliteRootedPath(), address(this), block.timestamp);\\n        totalBoughtForContributors = amounts[1];\\n    }\\n\\n    function createRootedBaseLiquidity() private {\\n        uint256 elitePerLpToken = eliteToken.balanceOf(address(rootedEliteLP)).mul(1e18).div(rootedEliteLP.totalSupply());\\n        uint256 lpAmountToRemove = baseToken.balanceOf(address(eliteToken)).mul(1e18).div(elitePerLpToken);\\n        \\n        (uint256 eliteAmount, uint256 rootedAmount) = swapRouter.removeLiquidity(address(eliteToken), address(rootedToken), lpAmountToRemove, 0, 0, address(this), block.timestamp);\\n        \\n        uint256 baseInElite = baseToken.balanceOf(address(eliteToken));\\n        uint256 baseAmount = eliteAmount \\u003e baseInElite ? baseInElite : eliteAmount;       \\n        \\n        eliteToken.withdrawTokens(baseAmount);\\n        swapRouter.addLiquidity(address(baseToken), address(rootedToken), baseAmount, rootedAmount, 0, 0, liquidityController, block.timestamp);\\n        rootedEliteLP.transfer(liquidityController, rootedEliteLP.balanceOf(address(this)));\\n        eliteToken.transfer(liquidityController, eliteToken.balanceOf(address(this)));\\n    }\\n\\n    function eliteRootedPath() private view returns (address[] memory) {\\n        address[] memory path = new address[](2);\\n        path[0] = address(eliteToken);\\n        path[1] = address(rootedToken);\\n        return path;\\n    }\\n\\n    function rootedElitePath() private view returns (address[] memory) {\\n        address[] memory path = new address[](2);\\n        path[0] = address(rootedToken);\\n        path[1] = address(eliteToken);\\n        return path;\\n    }\\n    \\n    function getTotalClaim(address account) public view returns (uint256) {\\n        uint256 contribution = marketGeneration.contribution(account);\\n        return contribution == 0 ? 0 : contribution.mul(totalBoughtForContributors).div(marketGeneration.totalContribution());\\n    }\\n\\n    function getReferralClaim(address account) public view returns (uint256) {\\n        uint256 referralShare = marketGeneration.referralPoints(account);\\n        return referralShare == 0 ? 0 : referralShare.mul(totalBoughtForReferrals).div(marketGeneration.totalReferralPoints());\\n    }\\n\\n    function claim(address account) public override returns (uint256) {\\n        require (distributionComplete, \\\"Distribution is not completed\\\");\\n        require (msg.sender == address(marketGeneration), \\\"Unauthorized\\\");\\n\\n        if (totalClaim[account] == 0) {\\n            totalClaim[account] = remainingClaim[account] = getTotalClaim(account);\\n        }\\n\\n        uint256 share = totalClaim[account];\\n        uint256 endTime = vestingPeriodEndTime \\u003e block.timestamp ? block.timestamp : vestingPeriodEndTime;\\n\\n        require (claimTime[account] \\u003c endTime, \\\"Already claimed\\\");\\n\\n        uint256 claimStartTime = claimTime[account] == 0 ? vestingPeriodStartTime : claimTime[account];\\n        share = (endTime.sub(claimStartTime)).mul(share).div(vestingDuration);\\n        claimTime[account] = block.timestamp;\\n        remainingClaim[account] -= share;\\n        rootedToken.transfer(account, share);\\n\\n        return share;\\n    }\\n\\n    function claimReferralRewards(address account, uint256 referralShare) public override {\\n        require (distributionComplete, \\\"Distribution is not completed\\\");\\n        require (msg.sender == address(marketGeneration), \\\"Unauthorized\\\");\\n\\n        uint256 share = referralShare.mul(totalBoughtForReferrals).div(marketGeneration.totalReferralPoints());\\n        rootedToken.transfer(account, share);\\n    }\\n\\n    function canRecoverTokens(IERC20 token) internal override view returns (bool) { \\n        return block.timestamp \\u003e recoveryDate || token != rootedToken;\\n    }\\n}\"},\"MarketGeneration.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\nimport \\\"./IMarketDistribution.sol\\\";\\nimport \\\"./IMarketGeneration.sol\\\";\\nimport \\\"./TokensRecoverable.sol\\\";\\nimport \\\"./SafeERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./IWBNB.sol\\\";\\n\\ncontract MarketGeneration is TokensRecoverable, IMarketGeneration {\\n    using SafeERC20 for IERC20;\\n    using SafeMath for uint256;\\n\\n    modifier active() {\\n        require (isActive, \\\"Distribution not active\\\");\\n        _;\\n    }\\n\\n    IERC20 public baseToken;\\n    IMarketDistribution public marketDistribution;\\n\\n    address public immutable devAddress;    \\n\\n    bool public isActive;\\n\\n    uint256 public refundsAllowedUntil;\\n\\n    uint256 public override totalReferralPoints;\\n    uint256 public override totalContribution;\\n\\n    mapping (address =\\u003e uint256) public override contribution;\\n    mapping (address =\\u003e uint256) public override referralPoints;\\n    \\n    constructor(address _devAddress) {\\n        devAddress = _devAddress;\\n    }\\n\\n    receive() external payable active() {\\n        contribute(address(0));\\n    }\\n\\n    function init(IERC20 _baseToken) public ownerOnly() {\\n        require (!isActive \\u0026\\u0026 block.timestamp \\u003e= refundsAllowedUntil, \\\"Already activated\\\");\\n        baseToken = _baseToken;\\n    }\\n\\n    function activate(IMarketDistribution _marketDistribution) public ownerOnly() {\\n        require (!isActive \\u0026\\u0026 block.timestamp \\u003e= refundsAllowedUntil, \\\"Already activated\\\");        \\n        require (address(_marketDistribution) != address(0));\\n        marketDistribution = _marketDistribution;\\n        isActive = true;\\n    }\\n\\n    function setMarketDistribution(IMarketDistribution _marketDistribution) public ownerOnly() active() {\\n        require (address(_marketDistribution) != address(0), \\\"Invalid market distribution\\\");\\n        if (_marketDistribution == marketDistribution) { return; }\\n        marketDistribution = _marketDistribution;\\n        refundsAllowedUntil = block.timestamp + 86400;\\n    }\\n\\n    function complete() public ownerOnly() active() {\\n        require (block.timestamp \\u003e= refundsAllowedUntil, \\\"Refund period is still active\\\");\\n        isActive = false;\\n        if (address(this).balance == 0) { return; }\\n        IWBNB(address(baseToken)).deposit{ value: address(this).balance }();\\n        baseToken.safeApprove(address(marketDistribution), uint256(-1));\\n\\n        marketDistribution.distribute();\\n    }\\n\\n    function allowRefunds() public ownerOnly() active() {\\n        isActive = false;\\n        refundsAllowedUntil = uint256(-1);\\n    }\\n\\n    function refund(uint256 amount) private {\\n        (bool success,) = msg.sender.call{ value: amount }(\\\"\\\");\\n        require (success, \\\"Refund transfer failed\\\");  \\n          \\n        totalContribution -= amount;\\n        contribution[msg.sender] = 0;\\n\\n        uint256 refPoints = referralPoints[msg.sender];\\n\\n        if (refPoints \\u003e 0) {\\n            totalReferralPoints -= refPoints;\\n            referralPoints[msg.sender] = 0;\\n        }\\n    }\\n\\n    function claim() public {\\n        uint256 amount = contribution[msg.sender];\\n        uint256 claimedAmount = 0;\\n\\n        require (amount \\u003e 0, \\\"Nothing to claim\\\");\\n        \\n        if (refundsAllowedUntil \\u003e block.timestamp) {\\n            refund(amount);\\n        } else {\\n            claimedAmount = marketDistribution.claim(msg.sender);\\n        }\\n    }\\n\\n    function claimReferralRewards() public {\\n        require (referralPoints[msg.sender] \\u003e 0, \\\"No rewards to claim\\\");\\n        \\n        uint256 refShare = referralPoints[msg.sender];\\n        referralPoints[msg.sender] = 0;\\n        marketDistribution.claimReferralRewards(msg.sender, refShare);\\n    }\\n\\n    function contribute(address referral) public payable active() {\\n        if (referral == address(0) || referral == msg.sender) {\\n            referralPoints[devAddress] += msg.value;\\n            totalReferralPoints += msg.value;\\n        } else {\\n            referralPoints[msg.sender] += msg.value;\\n            referralPoints[referral] += msg.value;\\n            totalReferralPoints +=(msg.value + msg.value);\\n        }\\n\\n        contribution[msg.sender] += msg.value;\\n        totalContribution += msg.value;\\n    }\\n}\"},\"MarketingFundWallet.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.7.4;\\r\\n\\r\\nimport \\\"./Address.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./SafeERC20.sol\\\";\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\nimport \\\"./Whitelist.sol\\\";\\r\\nimport \\\"./TokensRecoverable.sol\\\";\\r\\n\\r\\ncontract MarketingFundWallet is Whitelist, TokensRecoverable {\\r\\n    using Address for address;\\r\\n    using SafeMath for uint256;\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    string constant public name = \\\"Marketing Fund Wallet\\\";\\r\\n\\r\\n    event onDeposit(address indexed token, address indexed from, uint256 amount, uint256 timestamp);\\r\\n    event onTransfer(address indexed from, address indexed to, uint256 amount, uint256 timestamp);\\r\\n    event onTransferTokens(address indexed from, address indexed to, address indexed token, uint256 amount, uint256 timestamp);\\r\\n\\r\\n    constructor() {\\r\\n        transferOwnership(msg.sender);\\r\\n    }\\r\\n\\r\\n    receive() external payable {\\r\\n        emit onDeposit(address(0), msg.sender, msg.value, block.timestamp);\\r\\n    }\\r\\n\\r\\n    function transfer(address _recipient, uint256 _amount) public onlyWhitelisted {\\r\\n        payable(_recipient).transfer(_amount);\\r\\n        emit onTransfer(msg.sender, _recipient, _amount, block.timestamp);\\r\\n    }\\r\\n\\r\\n    function transferTokens(address _token, address _recipient, uint256 _amount) public onlyWhitelisted {\\r\\n        require(IERC20(_token).transfer(_recipient, _amount));\\r\\n        emit onTransferTokens(msg.sender, _recipient, _token, _amount, block.timestamp);\\r\\n    }\\r\\n}\"},\"Math.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity \\u003e=0.5.16;\\n\\nlibrary Math {\\n    function min(uint x, uint y) internal pure returns (uint z) {\\n        z = x \\u003c y ? x : y;\\n    }\\n\\n    function sqrt(uint y) internal pure returns (uint z) {\\n        if (y \\u003e 3) {\\n            z = y;\\n            uint x = y / 2 + 1;\\n            while (x \\u003c z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\"},\"Migrations.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity \\u003e=0.4.22 \\u003c0.8.0;\\n\\ncontract Migrations {\\n  address public owner = msg.sender;\\n  uint public last_completed_migration;\\n\\n  modifier restricted() {\\n    require(\\n      msg.sender == owner,\\n      \\\"This function is restricted to the contract\\u0027s owner\\\"\\n    );\\n    _;\\n  }\\n\\n  function setCompleted(uint completed) public restricted {\\n    last_completed_migration = completed;\\n  }\\n}\\n\"},\"NFTRewardsWallet.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.7.4;\\r\\n\\r\\nimport \\\"./Address.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./SafeERC20.sol\\\";\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\nimport \\\"./Whitelist.sol\\\";\\r\\nimport \\\"./TokensRecoverable.sol\\\";\\r\\n\\r\\ncontract NFTRewardsWallet is Whitelist, TokensRecoverable {\\r\\n    using Address for address;\\r\\n    using SafeMath for uint256;\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    string constant public name = \\\"NFT Rewards Wallet\\\";\\r\\n\\r\\n    event onDeposit(address indexed token, address indexed from, uint256 amount, uint256 timestamp);\\r\\n    event onTransfer(address indexed from, address indexed to, uint256 amount, uint256 timestamp);\\r\\n    event onTransferTokens(address indexed from, address indexed to, address indexed token, uint256 amount, uint256 timestamp);\\r\\n\\r\\n    constructor() {\\r\\n        transferOwnership(msg.sender);\\r\\n    }\\r\\n\\r\\n    receive() external payable {\\r\\n        emit onDeposit(address(0), msg.sender, msg.value, block.timestamp);\\r\\n    }\\r\\n\\r\\n    function transfer(address _recipient, uint256 _amount) public onlyWhitelisted {\\r\\n        payable(_recipient).transfer(_amount);\\r\\n        emit onTransfer(msg.sender, _recipient, _amount, block.timestamp);\\r\\n    }\\r\\n\\r\\n    function transferTokens(address _token, address _recipient, uint256 _amount) public onlyWhitelisted {\\r\\n        require(IERC20(_token).transfer(_recipient, _amount));\\r\\n        emit onTransferTokens(msg.sender, _recipient, _token, _amount, block.timestamp);\\r\\n    }\\r\\n}\"},\"Owned.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\nimport \\\"./IOwned.sol\\\";\\n\\nabstract contract Owned is IOwned {\\n    address public override owner = msg.sender;\\n    address internal pendingOwner;\\n\\n    modifier ownerOnly() {\\n        require (msg.sender == owner, \\\"Owner only\\\");\\n        _;\\n    }\\n\\n    function transferOwnership(address newOwner) public override ownerOnly() {\\n        pendingOwner = newOwner;\\n    }\\n\\n    function claimOwnership() public override {\\n        require (pendingOwner == msg.sender);\\n        pendingOwner = address(0);\\n        emit OwnershipTransferred(owner, msg.sender);\\n        owner = msg.sender;\\n    }\\n}\"},\"PieFundWallet.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.7.4;\\r\\n\\r\\nimport \\\"./Address.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./SafeERC20.sol\\\";\\r\\n\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\nimport \\\"./Whitelist.sol\\\";\\r\\nimport \\\"./TokensRecoverable.sol\\\";\\r\\n\\r\\ncontract PieFundWallet is Whitelist, TokensRecoverable {\\r\\n    using Address for address;\\r\\n    using SafeMath for uint256;\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    string constant public name = \\\"PIE Fund Wallet\\\";\\r\\n\\r\\n    event onDeposit(address indexed token, address indexed from, uint256 amount, uint256 timestamp);\\r\\n    event onTransfer(address indexed from, address indexed to, uint256 amount, uint256 timestamp);\\r\\n    event onTransferTokens(address indexed from, address indexed to, address indexed token, uint256 amount, uint256 timestamp);\\r\\n\\r\\n    constructor() {\\r\\n        transferOwnership(msg.sender);\\r\\n    }\\r\\n\\r\\n    receive() external payable {\\r\\n        emit onDeposit(address(0), msg.sender, msg.value, block.timestamp);\\r\\n    }\\r\\n\\r\\n    function transfer(address _recipient, uint256 _amount) public onlyWhitelisted {\\r\\n        payable(_recipient).transfer(_amount);\\r\\n        emit onTransfer(msg.sender, _recipient, _amount, block.timestamp);\\r\\n    }\\r\\n\\r\\n    function transferTokens(address _token, address _recipient, uint256 _amount) public onlyWhitelisted {\\r\\n        require(IERC20(_token).transfer(_recipient, _amount));\\r\\n        emit onTransferTokens(msg.sender, _recipient, _token, _amount, block.timestamp);\\r\\n    }\\r\\n}\"},\"ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\nabstract contract ReentrancyGuard {\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\"},\"RootedToken.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\nimport \\\"./LiquidityLockedERC20.sol\\\";\\n\\ncontract RootedToken is LiquidityLockedERC20(\\\"Degen Protocol Elite\\\", \\\"SH33P\\\") {\\n    address public minter;\\n\\n    function setMinter(address _minter) public ownerOnly() {\\n        minter = _minter;\\n    }\\n\\n    function mint(uint256 amount) public {\\n        require(msg.sender == minter, \\\"Not a minter\\\");\\n        require(this.totalSupply() == 0, \\\"Already minted\\\");\\n        _mint(msg.sender, amount);\\n    }\\n}\"},\"RootedTransferGate.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\nimport \\\"./Address.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./ISwapPair.sol\\\";\\nimport \\\"./ILiquidityLockedERC20.sol\\\";\\nimport \\\"./ISwapRouter02.sol\\\";\\nimport \\\"./SafeERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./TokensRecoverable.sol\\\";\\nimport \\\"./ITransferGate.sol\\\";\\nimport \\\"./AddressRegistry.sol\\\";\\n\\ncontract RootedTransferGate is TokensRecoverable, ITransferGate {   \\n    using Address for address;\\n    using SafeERC20 for IERC20;\\n    using SafeMath for uint256;\\n\\n    ISwapPair public mainPool;\\n    ISwapRouter02 immutable internal swapRouter;\\n    ILiquidityLockedERC20 immutable internal rootedToken;\\n    AddressRegistry public addressRegistry;\\n\\n    bool public unrestricted;\\n    mapping (address =\\u003e bool) public unrestrictedControllers;\\n    mapping (address =\\u003e bool) public feeControllers;\\n    mapping (address =\\u003e uint16) public poolsTaxRates;\\n\\n    address public override feeSplitter;\\n\\n    uint16 public feesRate;\\n    uint16 public dumpTaxStartRate; \\n    \\n    uint256 public dumpTaxDurationInSeconds;\\n    uint256 public dumpTaxEndTimestamp;\\n\\n    constructor(ILiquidityLockedERC20 _rootedToken, ISwapRouter02 _swapRouter) {\\n        rootedToken = _rootedToken;\\n        swapRouter = _swapRouter;\\n    }\\n\\n    function setUnrestrictedController(address unrestrictedController, bool allow) public ownerOnly() {\\n        unrestrictedControllers[unrestrictedController] = allow;\\n    }\\n    \\n    function setFeeControllers(address feeController, bool allow) public ownerOnly() {\\n        feeControllers[feeController] = allow;\\n    }\\n\\n    function setFreeParticipantController(address freeParticipantController, bool allow) public ownerOnly() {\\n        addressRegistry.setFreeParticipantController(freeParticipantController, allow);\\n    }\\n\\n    function setTrustedWallet(address trustedWallet, bool allow) public ownerOnly() {\\n        addressRegistry.setTrustedWallet(trustedWallet, allow);\\n    }\\n\\n    function setFreeParticipant(address participant, bool free) public {\\n        require (msg.sender == owner || addressRegistry.freeParticipantControllers(msg.sender), \\\"Not an owner or free participant controller\\\");\\n        addressRegistry.setFreeParticipant(participant, free);\\n    }\\n\\n    function setFeeSplitter(address _feeSplitter) public ownerOnly() {\\n        feeSplitter = _feeSplitter;\\n    }\\n\\n    function setUnrestricted(bool _unrestricted) public {\\n        require (unrestrictedControllers[msg.sender], \\\"Not an unrestricted controller\\\");\\n        unrestricted = _unrestricted;\\n        rootedToken.setLiquidityLock(mainPool, !_unrestricted);\\n    }\\n\\n    function setAddressRegistry(AddressRegistry _addressRegistry) public ownerOnly() {\\n        addressRegistry = _addressRegistry;\\n    }\\n\\n    function setMainPool(ISwapPair _mainPool) public ownerOnly() {\\n        mainPool = _mainPool;\\n    }\\n\\n     function setPoolTaxRate(address pool, uint16 taxRate) public ownerOnly() {\\n        require (taxRate \\u003c= 10000, \\\"Fee rate must be less than or equal to 100%\\\");\\n        poolsTaxRates[pool] = taxRate;        \\n    }\\n\\n    function setDumpTax(uint16 startTaxRate, uint256 durationInSeconds) public {\\n        require (feeControllers[msg.sender] || msg.sender == owner, \\\"Not an owner or fee controller\\\");\\n        require (startTaxRate \\u003c= 10000, \\\"Dump tax rate must be less than or equal to 100%\\\");\\n\\n        dumpTaxStartRate = startTaxRate;\\n        dumpTaxDurationInSeconds = durationInSeconds;\\n        dumpTaxEndTimestamp = block.timestamp + durationInSeconds;\\n    }\\n\\n    function getDumpTax() public view returns (uint256) {\\n        if (block.timestamp \\u003e= dumpTaxEndTimestamp) {\\n            return 0;\\n        }\\n        \\n        return dumpTaxStartRate*(dumpTaxEndTimestamp - block.timestamp)*1e18/dumpTaxDurationInSeconds/1e18;\\n    }\\n\\n    function setFees(uint16 _feesRate) public {\\n        require (feeControllers[msg.sender] || msg.sender == owner, \\\"Not an owner or fee controller\\\");\\n        require (_feesRate \\u003c= 10000, \\\"Fee rate must be less than or equal to 100%\\\");\\n        feesRate = _feesRate;\\n    }\\n\\n    function handleTransfer(address, address from, address to, uint256 amount) public virtual override returns (uint256) {\\n        if (unrestricted || addressRegistry.freeParticipant(from) || addressRegistry.freeParticipant(to)) {\\n            return 0;\\n        }\\n\\n        if (addressRegistry.blacklist(from) || addressRegistry.blacklist(to)) {\\n            return amount;\\n        }\\n\\n        uint16 poolTaxRate = poolsTaxRates[to];\\n\\n        uint256 dumpTaxInEffect = getDumpTax();\\n\\n        if (addressRegistry.trustedHolder(from) || addressRegistry.trustedHolder(to)) {\\n            dumpTaxInEffect = 0;\\n        }\\n\\n        if (poolTaxRate \\u003e feesRate) {\\n            uint256 totalTax = dumpTaxInEffect + poolTaxRate;\\n            return totalTax \\u003e= 10000 ? amount : amount * totalTax / 10000;\\n        }\\n\\n        return amount * feesRate / 10000;\\n    }   \\n}\"},\"SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\nimport \\\"./Address.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\nimport \\\"./IERC20.sol\\\";\\n\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {        \\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length \\u003e 0) {\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\nlibrary SafeMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n        return c;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n    \\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        return c;\\n    }\\n\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\"},\"StakingToken.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./TokensRecoverable.sol\\\";\\n\\ncontract StakingToken is ERC20(\\\"SH33P Staking\\\", \\\"xSH33P\\\"), TokensRecoverable {\\n    using SafeMath for uint256;\\n    IERC20 public immutable rooted;\\n\\n    mapping(uint256 =\\u003e uint256) public startingTaxRateForStake;\\n\\n    constructor(IERC20 _rooted) {\\n        rooted = _rooted;\\n    }\\n\\n    ////////////////////\\n    // VIEW FUNCTIONS //\\n    ////////////////////\\n\\n    function getRootedToStake(uint256 amount) public view returns (uint256) {\\n        uint256 totalRooted = rooted.balanceOf(address(this));\\n        uint256 totalShares = this.totalSupply();\\n\\n        if (totalShares == 0 || totalRooted == 0) {\\n            return amount;\\n        } else {\\n            return amount.mul(totalShares).div(totalRooted);\\n        }\\n    }\\n\\n    function getStakeToRooted(uint256 share) public view returns (uint256) {\\n        uint256 totalShares = this.totalSupply();\\n        return share.mul(rooted.balanceOf(address(this))).div(totalShares);\\n    }\\n\\n    /////////////////////\\n    // WRITE FUNCTIONS //\\n    /////////////////////\\n\\n    // Stake rooted, get staking shares\\n    function stake(uint256 amount) public {\\n        uint256 totalRooted = rooted.balanceOf(address(this));\\n        uint256 totalShares = this.totalSupply();\\n\\n        if (totalShares == 0 || totalRooted == 0) {\\n            _mint(msg.sender, amount);\\n        } else {\\n            uint256 mintAmount = amount.mul(totalShares).div(totalRooted);\\n            _mint(msg.sender, mintAmount);\\n        }\\n\\n        rooted.transferFrom(msg.sender, address(this), amount);\\n    }\\n\\n    // Unstake shares, claim back rooted\\n    function unstake(uint256 share) public {\\n        uint256 totalShares = this.totalSupply();\\n        uint256 unstakeAmount = share.mul(rooted.balanceOf(address(this))).div(totalShares);\\n\\n        _burn(msg.sender, share);\\n        rooted.transfer(msg.sender, unstakeAmount);\\n    }\\n\\n    function canRecoverTokens(IERC20 token) internal override view returns (bool) { \\n        return address(token) != address(this) \\u0026\\u0026 address(token) != address(rooted); \\n    }\\n}\"},\"Strings.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp \\u003e\\u003e= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i \\u003e 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value \\u0026 0xf];\\n            value \\u003e\\u003e= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\"},\"SwapLibrary.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\nimport \\\"./SafeMath.sol\\\";\\n\\nimport \\\"./ISwapPair.sol\\\";\\n\\nlibrary SwapLibrary {\\n    using SafeMath for uint;\\n\\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\\n        require(tokenA != tokenB, \\u0027SwapLibrary: IDENTICAL_ADDRESSES\\u0027);\\n        (token0, token1) = tokenA \\u003c tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        require(token0 != address(0), \\u0027SwapLibrary: ZERO_ADDRESS\\u0027);\\n    }\\n\\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\\n        pair = address(uint(keccak256(abi.encodePacked(\\n                hex\\u0027ff\\u0027,\\n                factory,\\n                keccak256(abi.encodePacked(token0, token1)),\\n                hex\\u002700fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5\\u0027 // init code hash\\n            ))));\\n    }\\n\\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\\n        (address token0,) = sortTokens(tokenA, tokenB);\\n        pairFor(factory, tokenA, tokenB);\\n        (uint reserve0, uint reserve1,) = ISwapPair(pairFor(factory, tokenA, tokenB)).getReserves();\\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\n    }\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\\n        require(amountA \\u003e 0, \\u0027SwapLibrary: INSUFFICIENT_AMOUNT\\u0027);\\n        require(reserveA \\u003e 0 \\u0026\\u0026 reserveB \\u003e 0, \\u0027SwapLibrary: INSUFFICIENT_LIQUIDITY\\u0027);\\n        amountB = amountA.mul(reserveB) / reserveA;\\n    }\\n\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\\n        require(amountIn \\u003e 0, \\u0027SwapLibrary: INSUFFICIENT_INPUT_AMOUNT\\u0027);\\n        require(reserveIn \\u003e 0 \\u0026\\u0026 reserveOut \\u003e 0, \\u0027SwapLibrary: INSUFFICIENT_LIQUIDITY\\u0027);\\n        uint amountInWithFee = amountIn.mul(998);\\n        uint numerator = amountInWithFee.mul(reserveOut);\\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\\n        amountOut = numerator / denominator;\\n    }\\n\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\\n        require(amountOut \\u003e 0, \\u0027SwapLibrary: INSUFFICIENT_OUTPUT_AMOUNT\\u0027);\\n        require(reserveIn \\u003e 0 \\u0026\\u0026 reserveOut \\u003e 0, \\u0027SwapLibrary: INSUFFICIENT_LIQUIDITY\\u0027);\\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\\n        uint denominator = reserveOut.sub(amountOut).mul(998);\\n        amountIn = (numerator / denominator).add(1);\\n    }\\n\\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\\n        require(path.length \\u003e= 2, \\u0027SwapLibrary: INVALID_PATH\\u0027);\\n        amounts = new uint[](path.length);\\n        amounts[0] = amountIn;\\n        for (uint i; i \\u003c path.length - 1; i++) {\\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\\n        }\\n    }\\n\\n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\\n        require(path.length \\u003e= 2, \\u0027SwapLibrary: INVALID_PATH\\u0027);\\n        amounts = new uint[](path.length);\\n        amounts[amounts.length - 1] = amountOut;\\n        for (uint i = path.length - 1; i \\u003e 0; i--) {\\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\\n        }\\n    }\\n}\"},\"TeamSplitter.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.7.4;\\r\\n\\r\\nimport \\\"./Address.sol\\\";\\r\\nimport \\\"./SafeMath.sol\\\";\\r\\nimport \\\"./SafeERC20.sol\\\";\\r\\n\\r\\nimport \\\"./TokensRecoverable.sol\\\";\\r\\nimport \\\"./Whitelist.sol\\\";\\r\\n\\r\\ncontract TeamSplitter is Whitelist, TokensRecoverable {\\r\\n    using SafeMath for uint256;\\r\\n    using SafeERC20 for IERC20;\\r\\n    using Address for address;\\r\\n\\r\\n    mapping (IERC20 =\\u003e address[]) public feeCollectors;\\r\\n    mapping (IERC20 =\\u003e uint256[]) public feeRates;\\r\\n\\r\\n    constructor() {\\r\\n    }\\r\\n\\r\\n    function setFees(IERC20 token, uint256 burnRate, address[] memory collectors, uint256[] memory rates) public ownerOnly() {\\r\\n        \\r\\n        uint256 totalRate = burnRate;\\r\\n\\r\\n        for (uint256 i = 0; i \\u003c rates.length; i++) {\\r\\n            totalRate = totalRate + rates[i];\\r\\n        }\\r\\n\\r\\n        require (totalRate == 10000, \\\"Total fee rate must be 100%\\\");\\r\\n        \\r\\n        if (token.balanceOf(address(this)) \\u003e 0) {\\r\\n            distribute(token);\\r\\n        }\\r\\n\\r\\n        feeCollectors[token] = collectors;\\r\\n        feeRates[token] = rates;\\r\\n    }\\r\\n\\r\\n    function distribute(IERC20 token) public {\\r\\n        uint256 balance = token.balanceOf(address(this));\\r\\n        require (balance \\u003e 0, \\\"Nothing to pay\\\");\\r\\n\\r\\n        address[] memory collectors = feeCollectors[token];\\r\\n        uint256[] memory rates = feeRates[token];\\r\\n\\r\\n        for (uint256 i = 0; i \\u003c collectors.length; i++) {\\r\\n            address collector = collectors[i];\\r\\n            uint256 rate = rates[i];\\r\\n\\r\\n            if (rate \\u003e 0) {\\r\\n                uint256 feeAmount = rate * balance / 10000;\\r\\n                token.transfer(collector, feeAmount);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function canRecoverTokens(IERC20 token) internal override view returns (bool) {\\r\\n        address[] memory collectors = feeCollectors[IERC20(address(token))];\\r\\n        return address(token) != address(this) \\u0026\\u0026 collectors.length == 0; \\r\\n    }\\r\\n}\"},\"TokenMigrator.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\nimport \\u0027./Address.sol\\u0027;\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./SafeERC20.sol\\\";\\n\\nimport \\u0027./IERC20.sol\\u0027;\\n\\nimport \\u0027./Owned.sol\\u0027;\\nimport \\u0027./TokensRecoverable.sol\\u0027;\\n\\ncontract TokenMigrator is Owned, TokensRecoverable {\\n    using Address for address;\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    IERC20 public token;\\n\\n    struct UserData {\\n        uint256 amount;\\n        uint256 claimed;\\n        uint256 lastClaimTimestamp;\\n    }\\n\\n    uint256 public totalClaimed;\\n    uint256 public totalClaimers;\\n\\n    mapping(address =\\u003e UserData) public users;\\n\\n    /////////////////////\\n    // CONTRACT EVENTS //\\n    /////////////////////\\n\\n    event ClaimTokens(address indexed user, uint256 amount, uint256 timestamp);\\n\\n    ////////////////////////////\\n    // CONSTRUCTOR \\u0026 FALLBACK //\\n    ////////////////////////////\\n\\n    constructor() {\\n\\n    }\\n\\n    receive() payable external {\\n\\n    }\\n\\n    ////////////////////\\n    // VIEW FUNCTIONS //\\n    ////////////////////\\n\\n    // Get balance of the distributed token in this contract\\n    function tokenBalance() public view returns (uint256) {\\n        return token.balanceOf(address(this));\\n    }\\n\\n    // Get the amount of tokens available for a user to claim\\n    function availableOf(address _user) public view returns (uint256) {\\n        return (users[_user].amount.sub(users[_user].claimed));\\n    }\\n\\n    // Get the total claimable amount of tokens for a user\\n    function claimableOf(address _user) public view returns (uint256) {\\n        return (users[_user].amount);\\n    }\\n\\n    // Get the amount of tokens already claimed by a user\\n    function claimedOf(address _user) public view returns (uint256) {\\n        return (users[_user].claimed);\\n    }\\n\\n    /////////////////////\\n    // WRITE FUNCTIONS //\\n    /////////////////////\\n\\n    // Claim tokens\\n    function claim() public returns (bool _success) {\\n        uint256 amount = availableOf(msg.sender);\\n        require(amount \\u003e 0, \\\"Nothing to claim\\\");\\n        \\n        users[msg.sender].claimed = users[msg.sender].claimed.add(amount);\\n\\n        token.transfer(msg.sender, amount);\\n\\n        totalClaimed = totalClaimed.add(amount);\\n        totalClaimers = totalClaimers.add(1);\\n\\n        users[msg.sender].lastClaimTimestamp = block.timestamp;\\n\\n        emit ClaimTokens(msg.sender, amount, block.timestamp);\\n        return true;\\n    }\\n\\n    //////////////////////////\\n    // RESTRICTED FUNCTIONS //\\n    //////////////////////////\\n\\n    // Set token to be claimed\\n    function setToken(address _token) public ownerOnly() {\\n        token = IERC20(_token);\\n    }\\n\\n    // Add users to the distribution\\n    function batchAddUsers(address[] memory _users, uint256[] memory _amounts) public ownerOnly() {\\n        require(_users.length == _amounts.length, \\\"Invalid input\\\");\\n        for (uint256 i = 0; i \\u003c _users.length; i++) {\\n            _addUser(_users[i], _amounts[i]);\\n        }\\n    }\\n\\n    ////////////////////////\\n    // INTERNAL FUNCTIONS //\\n    ////////////////////////\\n\\n    function _addUser(address _user, uint256 _amount) internal {\\n        users[_user].amount = users[_user].amount.add(_amount);\\n    }\\n}\"},\"TokensRecoverable.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\nimport \\\"./SafeERC20.sol\\\";\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./ITokensRecoverable.sol\\\";\\n\\nimport \\\"./Owned.sol\\\";\\n\\nabstract contract TokensRecoverable is Owned, ITokensRecoverable {\\n    using SafeERC20 for IERC20;\\n\\n    function recoverTokens(IERC20 token) public override ownerOnly() {\\n        require (canRecoverTokens(token));\\n        token.safeTransfer(msg.sender, token.balanceOf(address(this)));\\n    }\\n\\n    function canRecoverTokens(IERC20 token) internal virtual view returns (bool) { \\n        return address(token) != address(this); \\n    }\\n}\"},\"UQ112x112.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity \\u003e=0.5.16;\\n\\nlibrary UQ112x112 {\\n    uint224 constant Q112 = 2**112;\\n\\n    function encode(uint112 y) internal pure returns (uint224 z) {\\n        z = uint224(y) * Q112;\\n    }\\n\\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\\n        z = x / uint224(y);\\n    }\\n}\"},\"Whitelist.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.7.4;\\n\\nimport \\\"./Owned.sol\\\";\\n\\ncontract Whitelist is Owned {\\n\\n    modifier onlyWhitelisted() {\\n        if(active){\\n            require(whitelist[msg.sender], \\u0027not whitelisted\\u0027);\\n        }\\n        _;\\n    }\\n\\n    bool active = true;\\n\\n    mapping(address =\\u003e bool) public whitelist;\\n\\n    event WhitelistedAddressAdded(address addr);\\n    event WhitelistedAddressRemoved(address addr);\\n\\n    function activateDeactivateWhitelist() public ownerOnly() {\\n        active = !active;\\n    }\\n\\n    function addAddressToWhitelist(address addr) public ownerOnly() returns(bool success) {\\n        if (!whitelist[addr]) {\\n            whitelist[addr] = true;\\n            emit WhitelistedAddressAdded(addr);\\n            success = true;\\n        }\\n    }\\n\\n    function addAddressesToWhitelist(address[] calldata addrs) public ownerOnly() returns(bool success) {\\n        for (uint256 i = 0; i \\u003c addrs.length; i++) {\\n            if (addAddressToWhitelist(addrs[i])) {\\n                success = true;\\n            }\\n        }\\n    }\\n\\n    function removeAddressFromWhitelist(address addr) ownerOnly() public returns(bool success) {\\n        if (whitelist[addr]) {\\n            whitelist[addr] = false;\\n            emit WhitelistedAddressRemoved(addr);\\n            success = true;\\n        }\\n    }\\n\\n    function removeAddressesFromWhitelist(address[] calldata addrs) ownerOnly() public returns(bool success) {\\n        for (uint256 i = 0; i \\u003c addrs.length; i++) {\\n            if (removeAddressFromWhitelist(addrs[i])) {\\n                success = true;\\n            }\\n        }\\n    }\\n}\"},\"WrappedERC20.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.7.4;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./SafeERC20.sol\\\";\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./IWrappedERC20.sol\\\";\\n\\nimport \\\"./TokensRecoverable.sol\\\";\\n\\nimport \\\"./ERC20.sol\\\";\\n\\ncontract WrappedERC20 is ERC20, IWrappedERC20, TokensRecoverable {\\n    using SafeERC20 for IERC20;\\n    using SafeMath for uint256;\\n\\n    IERC20 public immutable override wrappedToken;\\n\\n    constructor (IERC20 _wrappedToken, string memory _name, string memory _symbol) ERC20(_name, _symbol) {        \\n        if (_wrappedToken.decimals() != 18) {\\n            _setupDecimals(_wrappedToken.decimals());\\n        }\\n        wrappedToken = _wrappedToken;\\n    }\\n\\n    function depositTokens(uint256 _amount) public override {\\n        _beforeDepositTokens(_amount);\\n        uint256 myBalance = wrappedToken.balanceOf(address(this));\\n        wrappedToken.safeTransferFrom(msg.sender, address(this), _amount);\\n        uint256 received = wrappedToken.balanceOf(address(this)).sub(myBalance);\\n        _mint(msg.sender, received);\\n        emit Deposit(msg.sender, _amount);\\n    }\\n\\n    function withdrawTokens(uint256 _amount) public override {\\n        _beforeWithdrawTokens(_amount);\\n        _burn(msg.sender, _amount);\\n        uint256 myBalance = wrappedToken.balanceOf(address(this));\\n        wrappedToken.safeTransfer(msg.sender, _amount);\\n        require (wrappedToken.balanceOf(address(this)) == myBalance.sub(_amount), \\\"Transfer not exact\\\");\\n        emit Withdrawal(msg.sender, _amount);\\n    }\\n\\n    function canRecoverTokens(IERC20 token) internal virtual override view returns (bool) {\\n        return token != this \\u0026\\u0026 token != wrappedToken;\\n    }\\n\\n    function _beforeDepositTokens(uint256 _amount) internal virtual view { }\\n    function _beforeWithdrawTokens(uint256 _amount) internal virtual view { }\\n}\"}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"liquidityController\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISwapPair\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"liquidityPairLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"recoverTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_liquidityController\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_canControl\",\"type\":\"bool\"}],\"name\":\"setLiquidityController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISwapPair\",\"name\":\"_liquidityPair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_locked\",\"type\":\"bool\"}],\"name\":\"setLiquidityLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_minter\",\"type\":\"address\"}],\"name\":\"setMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ITransferGate\",\"name\":\"_transferGate\",\"type\":\"address\"}],\"name\":\"setTransferGate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferGate\",\"outputs\":[{\"internalType\":\"contract ITransferGate\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "RootedToken", "CompilerVersion": "v0.7.4+commit.3f05b770", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://1dbc1b1378ec6465ba01ca2cede20777fc470590bd00f957419fb3ae2e0f2db2"}