{"SourceCode": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity 0.6.12;\r\n\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor() internal {}\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract Manageable is Context {\r\n    address private _manager;\r\n\r\n    event ManagementTransferred(address indexed previousManager, address indexed newManager);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial manager.\r\n     */\r\n    constructor() internal {\r\n        address msgSender = _msgSender();\r\n        _manager = msgSender;\r\n        emit ManagementTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current manager.\r\n     */\r\n    function manager() public view returns (address) {\r\n        return _manager;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the manager.\r\n     */\r\n    modifier onlyManager() {\r\n        require(_manager == _msgSender(), 'Manageable: caller is not the manager');\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without manager. It will not be possible to call\r\n     * `onlyManager` functions anymore. Can only be called by the current manager.\r\n     *\r\n     * NOTE: Renouncing management will leave the contract without an manager,\r\n     * thereby removing any functionality that is only available to the manager.\r\n     */\r\n    function renounceManagement() public onlyManager {\r\n        emit ManagementTransferred(_manager, address(0));\r\n        _manager = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers management of the contract to a new account (`newManager`).\r\n     * Can only be called by the current manager.\r\n     */\r\n    function transferManagement(address newManager) public onlyManager {\r\n        _transferManagement(newManager);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers management of the contract to a new account (`newManager`).\r\n     */\r\n    function _transferManagement(address newManager) internal {\r\n        require(newManager != address(0), 'Manageable: new manager is the zero address');\r\n        emit ManagementTransferred(_manager, newManager);\r\n        _manager = newManager;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), 'Ownable: caller is not the owner');\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), 'Ownable: new owner is the zero address');\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ninterface IBEP20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the token decimals.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Returns the token symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token name.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the bep token owner.\r\n     */\r\n    function getOwner() external view returns (address);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, 'SafeMath: addition overflow');\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, 'SafeMath: subtraction overflow');\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, 'SafeMath: multiplication overflow');\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, 'SafeMath: division by zero');\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, 'SafeMath: modulo by zero');\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        z = x < y ? x : y;\r\n    }\r\n\r\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\r\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint256 x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            codehash := extcodehash(account)\r\n        }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, 'Address: insufficient balance');\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{value: amount}('');\r\n        require(success, 'Address: unable to send value, recipient may have reverted');\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, 'Address: low-level call failed');\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, 'Address: low-level call with value failed');\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, 'Address: insufficient balance for call');\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 weiValue,\r\n        string memory errorMessage\r\n    ) private returns (bytes memory) {\r\n        require(isContract(target), 'Address: call to non-contract');\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract BEP20 is Context, IBEP20, Ownable {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\r\n     * a default value of 18.\r\n     *\r\n     * To select a different value for {decimals}, use {_setupDecimals}.\r\n     *\r\n     * All three of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor(string memory name, string memory symbol) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = 18;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the bep token owner.\r\n     */\r\n    function getOwner() external override view returns (address) {\r\n        return owner();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the token name.\r\n     */\r\n    function name() public override view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the token decimals.\r\n     */\r\n    function decimals() public override view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the token symbol.\r\n     */\r\n    function symbol() public override view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev See {BEP20-totalSupply}.\r\n     */\r\n    function totalSupply() public override view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {BEP20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public override view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {BEP20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {BEP20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public override view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {BEP20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {BEP20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {BEP20};\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for `sender`'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(\r\n            sender,\r\n            _msgSender(),\r\n            _allowances[sender][_msgSender()].sub(amount, 'BEP20: transfer amount exceeds allowance')\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {BEP20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {BEP20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(\r\n            _msgSender(),\r\n            spender,\r\n            _allowances[_msgSender()][spender].sub(subtractedValue, 'BEP20: decreased allowance below zero')\r\n        );\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `msg.sender`, decreasing the total supply.\r\n     *\r\n     */\r\n    function burn(uint256 amount) public returns (bool) {\r\n        _burn(_msgSender(), amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(sender != address(0), 'BEP20: transfer from the zero address');\r\n        require(recipient != address(0), 'BEP20: transfer to the zero address');\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, 'BEP20: transfer amount exceeds balance');\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), 'BEP20: mint to the zero address');\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0), 'BEP20: burn from the zero address');\r\n\r\n        _balances[account] = _balances[account].sub(amount, 'BEP20: burn amount exceeds balance');\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal {\r\n        require(owner != address(0), 'BEP20: approve from the zero address');\r\n        require(spender != address(0), 'BEP20: approve to the zero address');\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\r\n     * from the caller's allowance.\r\n     *\r\n     * See {_burn} and {_approve}.\r\n     */\r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _burn(account, amount);\r\n        _approve(\r\n            account,\r\n            _msgSender(),\r\n            _allowances[account][_msgSender()].sub(amount, 'BEP20: burn amount exceeds allowance')\r\n        );\r\n    }\r\n}\r\n\r\nlibrary SafeBEP20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IBEP20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IBEP20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IBEP20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(\r\n        IBEP20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            'SafeBEP20: approve from non-zero to non-zero allowance'\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IBEP20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IBEP20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(\r\n            value,\r\n            'SafeBEP20: decreased allowance below zero'\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IBEP20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, 'SafeBEP20: low-level call failed');\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), 'SafeBEP20: BEP20 operation did not succeed');\r\n        }\r\n    }\r\n}\r\n\r\ninterface ISphynxPair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n    function swapFee() external view returns (uint32);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n    function setSwapFee(uint32) external;\r\n}\r\n\r\ninterface ISphynxFactory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n    function setSwapFee(address _pair, uint32 _swapFee) external;\r\n}\r\n\r\ninterface ISphynxRouter01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut, uint swapFee) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut, uint swapFee) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\n\r\ninterface ISphynxRouter02 is ISphynxRouter01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\n\r\ninterface AggregatorV3Interface {\r\n\tfunction decimals() external view returns (uint8);\r\n\r\n\tfunction description() external view returns (string memory);\r\n\r\n\tfunction version() external view returns (uint256);\r\n\r\n\t// getRoundData and latestRoundData should both raise \"No data present\"\r\n\t// if they do not have data to report, instead of returning unset values\r\n\t// which could be misinterpreted as actual reported values.\r\n\tfunction getRoundData(uint80 _roundId)\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (\r\n\t\t\tuint80 roundId,\r\n\t\t\tint256 answer,\r\n\t\t\tuint256 startedAt,\r\n\t\t\tuint256 updatedAt,\r\n\t\t\tuint80 answeredInRound\r\n\t\t);\r\n\r\n\tfunction latestRoundData()\r\n\t\texternal\r\n\t\tview\r\n\t\treturns (\r\n\t\t\tuint80 roundId,\r\n\t\t\tint256 answer,\r\n\t\t\tuint256 startedAt,\r\n\t\t\tuint256 updatedAt,\r\n\t\t\tuint80 answeredInRound\r\n\t\t);\r\n}\r\n\r\ncontract SphynxToken is BEP20, Manageable {\r\n\tusing SafeMath for uint256;\r\n\r\n\tISphynxRouter02 public sphynxSwapRouter;\r\n\taddress public sphynxSwapPair;\r\n\r\n\tbool private swapping;\r\n\r\n\taddress public masterChef;\r\n\taddress public sphynxBridge;\r\n\r\n\taddress payable public marketingWallet = payable(0x982687617bc9a76420138a0F82b2fC1B8B11BbE3);\r\n\taddress payable public developmentWallet = payable(0x4A48062b88d5B8e9f0B7A5149F87288899C2d7f9);\r\n\taddress public lotteryAddress;\r\n\r\n\tuint256 public usdAmountToSwap = 500;\r\n\r\n\tuint256 public marketingFee;\r\n\tuint256 public developmentFee;\r\n\tuint256 public lotteryFee;\r\n\tuint256 public totalFees;\r\n\tuint256 public blockNumber;\r\n\r\n\tbool public SwapAndLiquifyEnabled = false;\r\n\tbool public sendToLottery = false;\r\n\r\n\tAggregatorV3Interface internal priceFeed;\r\n\r\n\t// exlcude from fees and max transaction amount\r\n\tmapping(address => bool) private _isExcludedFromFees;\r\n\r\n\t// getting fee addresses\r\n\tmapping(address => bool) public _isGetFees;\r\n\r\n\t// store addresses that are automated market maker pairs. Any transfer to these addresses\r\n\t// could be subject to a maximum transfer amount\r\n\tmapping(address => bool) public automatedMarketMakerPairs;\r\n\r\n\tmodifier onlyMasterChefAndBridge() {\r\n\t\trequire(msg.sender == masterChef || msg.sender == sphynxBridge, 'Permission Denied');\r\n\t\t_;\r\n\t}\r\n\r\n\t// Contract Events\r\n\tevent ExcludeFromFees(address indexed account, bool isExcluded);\r\n\tevent GetFee(address indexed account, bool isGetFee);\r\n\tevent ExcludeMultipleAccountsFromFees(address[] accounts, bool isExcluded);\r\n\tevent SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\r\n\tevent MarketingWalletUpdated(address indexed newMarketingWallet, address indexed oldMarketingWallet);\r\n\tevent DevelopmentWalletUpdated(address indexed newDevelopmentWallet, address indexed oldDevelopmentWallet);\r\n\tevent LotteryAddressUpdated(address indexed newLotteryAddress, address indexed oldLotteryAddress);\r\n\tevent UpdateSphynxSwapRouter(address indexed newAddress, address indexed oldAddress);\r\n\tevent SwapAndLiquify(uint256 tokensSwapped, uint256 ethReceived, uint256 tokensIntoLiqudity);\r\n\tevent UpdateSwapAndLiquify(bool value);\r\n\tevent UpdateSendToLottery(bool value);\r\n\tevent SetMarketingFee(uint256 value);\r\n\tevent SetDevelopmentFee(uint256 value);\r\n\tevent SetLotteryFee(uint256 value);\r\n\tevent SetAllFeeToZero(uint256 marketingFee, uint256 developmentFee, uint256 lotteryFee);\r\n\tevent MaxFees(uint256 marketingFee, uint256 developmentFee, uint256 lotteryFee);\r\n\tevent SetUsdAmountToSwap(uint256 usdAmountToSwap);\r\n\tevent SetBlockNumber(uint256 blockNumber);\r\n\tevent UpdateMasterChef(address masterChef);\r\n\tevent UpdateSphynxBridge(address sphynxBridge);\r\n\r\n\tconstructor() public BEP20('Sphynx Token', 'SPHYNX') {\r\n\t\tuint256 _marketingFee = 5;\r\n\t\tuint256 _developmentFee = 5;\r\n\t\tuint256 _lotteryFee = 1;\r\n\r\n\t\tmarketingFee = _marketingFee;\r\n\t\tdevelopmentFee = _developmentFee;\r\n\t\tlotteryFee = _lotteryFee;\r\n\t\ttotalFees = _marketingFee.add(_developmentFee);\r\n\t\tblockNumber = 0;\r\n\r\n\t\tISphynxRouter02 _sphynxSwapRouter = ISphynxRouter02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D); // mainnet\r\n\t\t// Create a sphynxswap pair for SPHYNX\r\n\t\taddress _sphynxSwapPair = ISphynxFactory(_sphynxSwapRouter.factory()).createPair(address(this), _sphynxSwapRouter.WETH());\r\n\r\n\t\tsphynxSwapRouter = _sphynxSwapRouter;\r\n\t\tsphynxSwapPair = _sphynxSwapPair;\r\n\r\n\t\t_setAutomatedMarketMakerPair(sphynxSwapPair, true);\r\n\r\n\t\t// exclude from paying fees or having max transaction amount\r\n\t\texcludeFromFees(marketingWallet, true);\r\n\t\texcludeFromFees(developmentWallet, true);\r\n\t\texcludeFromFees(address(this), true);\r\n\t\texcludeFromFees(owner(), true);\r\n\r\n\t\t// set getFee addresses\r\n\t\t_isGetFees[address(_sphynxSwapRouter)] = true;\r\n\t\t_isGetFees[_sphynxSwapPair] = true;\r\n\t\tpriceFeed = AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\r\n\r\n\t\t_mint(owner(), 1000000000 * (10**18));\r\n\t}\r\n\r\n\treceive() external payable {}\r\n\r\n\t// mint function for masterchef;\r\n\tfunction mint(address to, uint256 amount) public onlyMasterChefAndBridge {\r\n\t\t_mint(to, amount);\r\n\t}\r\n\r\n\tfunction updateSwapAndLiquifiy(bool value) public onlyManager {\r\n\t\tSwapAndLiquifyEnabled = value;\r\n\t\temit UpdateSwapAndLiquify(value);\r\n\t}\r\n\r\n\tfunction updateSendToLottery(bool value) public onlyManager {\r\n\t\tsendToLottery = value;\r\n\t\temit UpdateSendToLottery(value);\r\n\t}\r\n\r\n\tfunction setMarketingFee(uint256 value) external onlyManager {\r\n\t\trequire(value <= 5, 'SPHYNX: Invalid marketingFee');\r\n\t\tmarketingFee = value;\r\n\t\ttotalFees = marketingFee.add(developmentFee);\r\n\t\temit SetMarketingFee(value);\r\n\t}\r\n\r\n\tfunction setDevelopmentFee(uint256 value) external onlyManager {\r\n\t\trequire(value <= 5, 'SPHYNX: Invalid developmentFee');\r\n\t\tdevelopmentFee = value;\r\n\t\ttotalFees = marketingFee.add(developmentFee);\r\n\t\temit SetDevelopmentFee(value);\r\n\t}\r\n\r\n\tfunction setLotteryFee(uint256 value) external onlyManager {\r\n\t\trequire(value <= 1, 'SPHYNX: Invalid lotteryFee');\r\n\t\tlotteryFee = value;\r\n\t\temit SetLotteryFee(value);\r\n\t}\r\n\r\n\tfunction setAllFeeToZero() external onlyOwner {\r\n\t\tmarketingFee = 0;\r\n\t\tdevelopmentFee = 0;\r\n\t\tlotteryFee = 0;\r\n\t\ttotalFees = 0;\r\n\t\temit SetAllFeeToZero(marketingFee, developmentFee, lotteryFee);\r\n\t}\r\n\r\n\tfunction maxFees() external onlyOwner {\r\n\t\tmarketingFee = 5;\r\n\t\tdevelopmentFee = 5;\r\n\t\tlotteryFee = 1;\r\n\t\ttotalFees = marketingFee.add(developmentFee);\r\n\t\temit MaxFees(marketingFee, developmentFee, lotteryFee);\r\n\t}\r\n\r\n\tfunction updateSphynxSwapRouter(address newAddress) public onlyManager {\r\n\t\trequire(newAddress != address(sphynxSwapRouter), 'SPHYNX: The router already has that address');\r\n\t\temit UpdateSphynxSwapRouter(newAddress, address(sphynxSwapRouter));\r\n\t\tsphynxSwapRouter = ISphynxRouter02(newAddress);\r\n\t\taddress _sphynxSwapPair;\r\n\t\t_sphynxSwapPair = ISphynxFactory(sphynxSwapRouter.factory()).getPair(address(this), sphynxSwapRouter.WETH());\r\n\t\tif(_sphynxSwapPair == address(0)) {\r\n\t\t\t_sphynxSwapPair = ISphynxFactory(sphynxSwapRouter.factory()).createPair(address(this), sphynxSwapRouter.WETH());\r\n\t\t}\r\n\t\t_setAutomatedMarketMakerPair(sphynxSwapPair, false);\r\n\t\tsphynxSwapPair = _sphynxSwapPair;\r\n\t\t_setAutomatedMarketMakerPair(sphynxSwapPair, true);\r\n\t}\r\n\r\n\tfunction updateMasterChef(address _masterChef) public onlyManager {\r\n\t\trequire(masterChef != _masterChef, 'SPHYNX: MasterChef already exists!');\r\n\t\tmasterChef = _masterChef;\r\n\t\temit UpdateMasterChef(_masterChef);\r\n\t}\r\n\r\n\tfunction updateSphynxBridge(address _sphynxBridge) public onlyManager {\r\n\t\trequire(sphynxBridge != _sphynxBridge, 'SPHYNX: SphynxBridge already exists!');\r\n\t\t_isExcludedFromFees[sphynxBridge] = false;\r\n\t\tsphynxBridge = _sphynxBridge;\r\n\t\t_isExcludedFromFees[sphynxBridge] = true;\r\n\t\temit UpdateSphynxBridge(_sphynxBridge);\r\n\t}\r\n\r\n\tfunction excludeFromFees(address account, bool excluded) public onlyManager {\r\n\t\trequire(_isExcludedFromFees[account] != excluded, \"SPHYNX: Account is already the value of 'excluded'\");\r\n\t\t_isExcludedFromFees[account] = excluded;\r\n\r\n\t\temit ExcludeFromFees(account, excluded);\r\n\t}\r\n\r\n\tfunction setFeeAccount(address account, bool isGetFee) public onlyManager {\r\n\t\trequire(_isGetFees[account] != isGetFee, \"SPHYNX: Account is already the value of 'isGetFee'\");\r\n\t\t_isGetFees[account] = isGetFee;\r\n\r\n\t\temit GetFee(account, isGetFee);\r\n\t}\r\n\r\n\tfunction excludeMultipleAccountsFromFees(address[] calldata accounts, bool excluded) public onlyOwner {\r\n\t\tfor (uint256 i = 0; i < accounts.length; i++) {\r\n\t\t\t_isExcludedFromFees[accounts[i]] = excluded;\r\n\t\t}\r\n\r\n\t\temit ExcludeMultipleAccountsFromFees(accounts, excluded);\r\n\t}\r\n\r\n\tfunction setAutomatedMarketMakerPair(address pair, bool value) public onlyManager {\r\n\t\t_setAutomatedMarketMakerPair(pair, value);\r\n\t}\r\n\r\n\tfunction _setAutomatedMarketMakerPair(address pair, bool value) private {\r\n\t\trequire(automatedMarketMakerPairs[pair] != value, 'SPHYNX: Automated market maker pair is already set to that value');\r\n\t\tautomatedMarketMakerPairs[pair] = value;\r\n\r\n\t\temit SetAutomatedMarketMakerPair(pair, value);\r\n\t}\r\n\r\n\tfunction setUsdAmountToSwap(uint256 _usdAmount) public onlyManager {\r\n\t\tusdAmountToSwap = _usdAmount;\r\n\t\temit SetUsdAmountToSwap(usdAmountToSwap);\r\n\t}\r\n\r\n\tfunction updateMarketingWallet(address newMarketingWallet) public onlyManager {\r\n\t\trequire(newMarketingWallet != marketingWallet, 'SPHYNX: The marketing wallet is already this address');\r\n\t\texcludeFromFees(newMarketingWallet, true);\r\n\t\texcludeFromFees(marketingWallet, false);\r\n\t\temit MarketingWalletUpdated(newMarketingWallet, marketingWallet);\r\n\t\tmarketingWallet = payable(newMarketingWallet);\r\n\t}\r\n\r\n\tfunction updateDevelopmentgWallet(address newDevelopmentWallet) public onlyManager {\r\n\t\trequire(newDevelopmentWallet != developmentWallet, 'SPHYNX: The development wallet is already this address');\r\n\t\texcludeFromFees(newDevelopmentWallet, true);\r\n\t\texcludeFromFees(developmentWallet, false);\r\n\t\temit DevelopmentWalletUpdated(newDevelopmentWallet, developmentWallet);\r\n\t\tdevelopmentWallet = payable(newDevelopmentWallet);\r\n\t}\r\n\r\n\tfunction updateLotteryAddress(address newLotteryAddress) public onlyManager {\r\n\t\trequire(newLotteryAddress != lotteryAddress, 'SPHYNX: The lottery wallet is already this address');\r\n\t\texcludeFromFees(newLotteryAddress, true);\r\n\t\texcludeFromFees(lotteryAddress, false);\r\n\t\temit LotteryAddressUpdated(newLotteryAddress, lotteryAddress);\r\n\t\tlotteryAddress = newLotteryAddress;\r\n\t}\r\n\r\n\tfunction setBlockNumber() public onlyOwner {\r\n\t\tblockNumber = block.number;\r\n\t\temit SetBlockNumber(blockNumber);\r\n\t}\r\n\r\n\tfunction isExcludedFromFees(address account) public view returns (bool) {\r\n\t\treturn _isExcludedFromFees[account];\r\n\t}\r\n\r\n\tfunction _transfer(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 amount\r\n\t) internal override {\r\n\t\trequire(from != address(0), 'BEP20: transfer from the zero address');\r\n\t\trequire(to != address(0), 'BEP20: transfer to the zero address');\r\n\r\n\t\tif (amount == 0) {\r\n\t\t\tsuper._transfer(from, to, 0);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n        if(SwapAndLiquifyEnabled) {\r\n            uint256 contractTokenBalance = balanceOf(address(this));\r\n            uint256 bnbTokenAmount = _getTokenAmountFromBNB();\r\n\r\n\t\t    bool canSwap = contractTokenBalance >= bnbTokenAmount;\r\n\r\n            if (canSwap && !swapping && !automatedMarketMakerPairs[from]) {\r\n                swapping = true;\r\n\r\n                // Set number of tokens to sell to bnbTokenAmount\r\n                contractTokenBalance = bnbTokenAmount;\r\n                swapTokens(contractTokenBalance);\r\n                swapping = false;\r\n            }\r\n        }\r\n\r\n\t\t// indicates if fee should be deducted from transfer\r\n\t\tbool takeFee = true;\r\n\r\n\t\t// if any account belongs to _isExcludedFromFee account then remove the fee\r\n\t\tif (_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\r\n\t\t\ttakeFee = false;\r\n\t\t}\r\n\r\n\t\tif (takeFee) {\r\n\t\t\tif (block.number - blockNumber <= 10) {\r\n\t\t\t\tuint256 afterBalance = balanceOf(to) + amount;\r\n\t\t\t\trequire(afterBalance <= 250000 * (10**18), 'Owned amount exceeds the maxOwnedAmount');\r\n\t\t\t}\r\n\t\t\tuint256 fees;\r\n\t\t\tif (_isGetFees[from] || _isGetFees[to]) {\r\n\t\t\t\tif (block.number - blockNumber <= 5) {\r\n\t\t\t\t\tfees = amount.mul(99).div(10**2);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tfees = amount.mul(totalFees).div(10**2);\r\n\t\t\t\t\tif (sendToLottery) {\r\n\t\t\t\t\t\tuint256 lotteryAmount = amount.mul(lotteryFee).div(10**2);\r\n\t\t\t\t\t\tamount = amount.sub(lotteryAmount);\r\n\t\t\t\t\t\tsuper._transfer(from, lotteryAddress, lotteryAmount);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tamount = amount.sub(fees);\r\n\t\t\t\tsuper._transfer(from, address(this), fees);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tsuper._transfer(from, to, amount);\r\n\t}\r\n\r\n\tfunction swapTokens(uint256 tokenAmount) private {\r\n\t\tswapTokensForEth(tokenAmount);\r\n\t\tuint256 swappedBNB = address(this).balance;\r\n\t\tuint256 marketingBNB = swappedBNB.mul(marketingFee).div(totalFees);\r\n\t\tuint256 developmentBNB = swappedBNB.sub(marketingBNB);\r\n\t\ttransferBNBToMarketingWallet(marketingBNB);\r\n\t\ttransferBNBToDevelopmentWallet(developmentBNB);\r\n\t}\r\n\r\n\t// Swap tokens on PacakeSwap\r\n\tfunction swapTokensForEth(uint256 tokenAmount) private {\r\n\t\t// generate the sphynxswap pair path of token -> weth\r\n\t\taddress[] memory path = new address[](2);\r\n\t\tpath[0] = address(this);\r\n\t\tpath[1] = sphynxSwapRouter.WETH();\r\n\r\n\t\t_approve(address(this), address(sphynxSwapRouter), tokenAmount);\r\n\r\n\t\t// make the swap\r\n\t\tsphynxSwapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n\t\t\ttokenAmount,\r\n\t\t\t0, // accept any amount of ETH\r\n\t\t\tpath,\r\n\t\t\taddress(this),\r\n\t\t\tblock.timestamp\r\n\t\t);\r\n\t}\r\n\r\n\tfunction getNativeAmountFromUSD() public returns (uint256 amount) {\r\n\t\t(\r\n            uint80 roundID, \r\n            int price,\r\n            uint startedAt,\r\n            uint timeStamp,\r\n            uint80 answeredInRound\r\n        ) = priceFeed.latestRoundData();\r\n        amount = usdAmountToSwap.mul(10 ** 10).div(uint256(price));\r\n\t}\r\n\r\n\tfunction _getTokenAmountFromBNB() internal returns (uint256) {\r\n\t\tuint256 tokenAmount;\r\n\t\taddress[] memory path = new address[](2);\r\n\t\tpath[0] = sphynxSwapRouter.WETH();\r\n\t\tpath[1] = address(this);\r\n\r\n\t\tuint256 nativeAmountToSwap = getNativeAmountFromUSD();\r\n\t\tuint256[] memory amounts = sphynxSwapRouter.getAmountsOut(nativeAmountToSwap, path);\r\n\t\ttokenAmount = amounts[1];\r\n\t\treturn tokenAmount;\r\n\t}\r\n\r\n\tfunction transferBNBToMarketingWallet(uint256 amount) private {\r\n\t\tmarketingWallet.transfer(amount);\r\n\t}\r\n\r\n\tfunction transferBNBToDevelopmentWallet(uint256 amount) private {\r\n\t\tdevelopmentWallet.transfer(amount);\r\n\t}\r\n}\r\n\r\n// Have fun reading it. Hopefully it's bug-free. God bless.\r\ncontract SphynxMasterChefWithLockStaking is Ownable {\r\n    using SafeMath for uint256;\r\n    using SafeBEP20 for IBEP20;\r\n\r\n    // Info of each user.\r\n    struct UserInfo {\r\n        uint256 amount; // How many LP tokens the user has provided.\r\n        uint256 rewardDebt; // Reward debt. See explanation below.\r\n        //\r\n        // We do some fancy math here. Basically, any point in time, the amount of Sphynxs\r\n        // entitled to a user but is pending to be distributed is:\r\n        //\r\n        //   pending reward = (user.amount * pool.accsphynxPerShare) - user.rewardDebt\r\n        //\r\n        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\r\n        //   1. The pool's `accsphynxPerShare` (and `lastRewardBlock`) gets updated.\r\n        //   2. User receives the pending reward sent to his/her address.\r\n        //   3. User's `amount` gets updated.\r\n        //   4. User's `rewardDebt` gets updated.\r\n    }\r\n\r\n    // Info of each pool.\r\n    struct PoolInfo {\r\n        IBEP20 lpToken; // Address of LP token contract.\r\n        uint256 allocPoint; // How many allocation points assigned to this pool. sphynxs to distribute per block.\r\n        uint256 lastRewardBlock; // Last block number that sphynxs distribution occurs.\r\n        uint256 accSphynxPerShare; // Accumulated Sphynxs per share, times 1e12. See below.\r\n    }\r\n\r\n    // The sphynx TOKEN!\r\n    SphynxToken public sphynx;\r\n    // sphynx tokens created per block.\r\n    uint256 public sphynxPerBlock;\r\n    // Bonus muliplier for early sphynx makers.\r\n    uint256 public BONUS_MULTIPLIER = 1;\r\n\r\n    uint256 public stakedTokens;\r\n\r\n    uint256 public rewardBalance;\r\n\r\n    // Info of each pool.\r\n    PoolInfo[] public poolInfo;\r\n    // Info of each user that stakes LP tokens.\r\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\r\n    // Total allocation poitns. Must be the sum of all allocation points in all pools.\r\n    uint256 public totalAllocPoint = 0;\r\n    // The block number when sphynx mining starts.\r\n    uint256 public startBlock;\r\n    uint256 public stakingTime;\r\n    uint256 public stakingPeriods = 3 days;\r\n    uint256 public lockPeriods = 30 days;\r\n    uint256 public penaltyFee = 50; // initial penaltyFee 50%\r\n\r\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\r\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\r\n    event EmergencyWithdraw(\r\n        address indexed user,\r\n        uint256 indexed pid,\r\n        uint256 amount\r\n    );\r\n    event SetDev(address newDev);\r\n\r\n    constructor(\r\n        SphynxToken _sphynx,\r\n        uint256 _sphynxPerBlock,\r\n        uint256 _startBlock,\r\n        uint256 _startTime\r\n    ) public {\r\n        sphynx = _sphynx;\r\n        sphynxPerBlock = _sphynxPerBlock;\r\n        startBlock = _startBlock;\r\n        stakingTime = _startTime;\r\n\r\n        // staking pool\r\n        poolInfo.push(\r\n            PoolInfo({\r\n                lpToken: _sphynx,\r\n                allocPoint: 100,\r\n                lastRewardBlock: startBlock,\r\n                accSphynxPerShare: 0\r\n            })\r\n        );\r\n\r\n        totalAllocPoint = 100;\r\n        stakedTokens = 0;\r\n    }\r\n\r\n    function updateLockPeriods(uint256 _lockPeriods) external onlyOwner {\r\n        lockPeriods = _lockPeriods;\r\n    }\r\n\r\n    function updateStakingPeriods(uint256 _stakingPeriods) external onlyOwner {\r\n        stakingPeriods = _stakingPeriods;\r\n    }\r\n\r\n    function updateStakingTime(uint256 _stakingTime) external onlyOwner {\r\n        stakingTime = _stakingTime;\r\n    }\r\n\r\n    function updatePenaltyFee(uint256 _penaltyFee) external onlyOwner {\r\n        require(_penaltyFee <= 80, \"over-max-percent\");\r\n        penaltyFee = _penaltyFee;\r\n    }\r\n\r\n    function updateMultiplier(uint256 multiplierNumber) public onlyOwner {\r\n        BONUS_MULTIPLIER = multiplierNumber;\r\n    }\r\n\r\n    function poolLength() external view returns (uint256) {\r\n        return poolInfo.length;\r\n    }\r\n\r\n    function depositRewardToken() external payable onlyOwner {\r\n        rewardBalance = rewardBalance.add(msg.value);\r\n    }\r\n\r\n    function emergencyWithdrawRewardToken(uint256 _amount) external payable onlyOwner {\r\n        rewardBalance = rewardBalance.sub(_amount);\r\n        address payable _msgSender = payable(msg.sender);\r\n        _msgSender.transfer(_amount);\r\n    }\r\n\r\n    function stakingAvailable() public view returns (bool _available) {\r\n        uint256 currentTime = block.timestamp;\r\n        uint256 _stakingTime = stakingTime;\r\n        if (\r\n            _stakingTime <= currentTime &&\r\n            currentTime <= (_stakingTime + stakingPeriods)\r\n        ) {\r\n            _available = true;\r\n        } else if (\r\n            currentTime > (lockPeriods + _stakingTime + stakingPeriods)\r\n        ) {\r\n            uint256 times = currentTime\r\n                .sub(_stakingTime)\r\n                .sub(stakingPeriods)\r\n                .div(lockPeriods);\r\n            if (times != 0) {\r\n                _stakingTime = _stakingTime.add(stakingPeriods).add(\r\n                    lockPeriods.mul(times)\r\n                );\r\n            }\r\n            if (\r\n                _stakingTime <= currentTime &&\r\n                currentTime <= (_stakingTime + stakingPeriods)\r\n            ) {\r\n                _available = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Add a new lp to the pool. Can only be called by the owner.\r\n    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.\r\n    function add(\r\n        uint256 _allocPoint,\r\n        IBEP20 _lpToken,\r\n        bool _withUpdate\r\n    ) public onlyOwner {\r\n        if (_withUpdate) {\r\n            massUpdatePools();\r\n        }\r\n        uint256 lastRewardBlock = block.number > startBlock\r\n            ? block.number\r\n            : startBlock;\r\n        totalAllocPoint = totalAllocPoint.add(_allocPoint);\r\n        poolInfo.push(\r\n            PoolInfo({\r\n                lpToken: _lpToken,\r\n                allocPoint: _allocPoint,\r\n                lastRewardBlock: lastRewardBlock,\r\n                accSphynxPerShare: 0\r\n            })\r\n        );\r\n    }\r\n\r\n    // Update the given pool's sphynx allocation point. Can only be called by the owner.\r\n    function set(\r\n        uint256 _pid,\r\n        uint256 _allocPoint,\r\n        bool _withUpdate\r\n    ) public onlyOwner {\r\n        if (_withUpdate) {\r\n            massUpdatePools();\r\n        }\r\n        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(\r\n            _allocPoint\r\n        );\r\n        poolInfo[_pid].allocPoint = _allocPoint;\r\n    }\r\n\r\n    // Return reward multiplier over the given _from to _to block.\r\n    function getMultiplier(uint256 _from, uint256 _to)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _to.sub(_from).mul(BONUS_MULTIPLIER);\r\n    }\r\n\r\n    // View function to see pending sphynxs on frontend.\r\n    function pendingSphynx(uint256 _pid, address _user)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][_user];\r\n        uint256 accSphynxPerShare = pool.accSphynxPerShare;\r\n        uint256 lpSupply = stakedTokens;\r\n        if (_pid != 0) {\r\n            lpSupply = pool.lpToken.balanceOf(address(this));\r\n        }\r\n\r\n        if (block.number > pool.lastRewardBlock && lpSupply != 0) {\r\n            uint256 multiplier = getMultiplier(\r\n                pool.lastRewardBlock,\r\n                block.number\r\n            );\r\n            uint256 sphynxReward = multiplier\r\n                .mul(sphynxPerBlock)\r\n                .mul(pool.allocPoint)\r\n                .div(totalAllocPoint);\r\n            accSphynxPerShare = accSphynxPerShare.add(\r\n                sphynxReward.mul(1e12).div(lpSupply)\r\n            );\r\n        }\r\n        return\r\n            user.amount.mul(accSphynxPerShare).div(1e12).sub(user.rewardDebt);\r\n    }\r\n\r\n    // Update reward variables for all pools. Be careful of gas spending!\r\n    function massUpdatePools() public {\r\n        uint256 length = poolInfo.length;\r\n        for (uint256 pid = 0; pid < length; ++pid) {\r\n            updatePool(pid);\r\n        }\r\n    }\r\n\r\n    // Update reward variables of the given pool to be up-to-date.\r\n    function updatePool(uint256 _pid) public {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        if (block.number <= pool.lastRewardBlock) {\r\n            return;\r\n        }\r\n        uint256 lpSupply = stakedTokens;\r\n        if (_pid != 0) {\r\n            lpSupply = pool.lpToken.balanceOf(address(this));\r\n        }\r\n\r\n        if (lpSupply == 0) {\r\n            pool.lastRewardBlock = block.number;\r\n            return;\r\n        }\r\n        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\r\n        uint256 sphynxReward = multiplier\r\n            .mul(sphynxPerBlock)\r\n            .mul(pool.allocPoint)\r\n            .div(totalAllocPoint);\r\n\r\n        pool.accSphynxPerShare = pool.accSphynxPerShare.add(\r\n            sphynxReward.mul(1e12).div(lpSupply)\r\n        );\r\n        pool.lastRewardBlock = block.number;\r\n    }\r\n\r\n    function _availableStaking() internal {\r\n        uint256 currentTime = block.timestamp;\r\n        bool flag = false;\r\n        if (\r\n            stakingTime <= currentTime &&\r\n            currentTime <= (stakingTime + stakingPeriods)\r\n        ) {\r\n            flag = true;\r\n        } else if (currentTime > (lockPeriods + stakingTime + stakingPeriods)) {\r\n            uint256 times = currentTime\r\n                .sub(stakingTime)\r\n                .sub(stakingPeriods)\r\n                .div(lockPeriods);\r\n            stakingTime = stakingTime.add(stakingPeriods).add(\r\n                lockPeriods.mul(times)\r\n            );\r\n            if (\r\n                stakingTime <= currentTime &&\r\n                currentTime <= (stakingTime + stakingPeriods)\r\n            ) {\r\n                flag = true;\r\n            }\r\n        }\r\n        require(flag, \"not-able-to-staking\");\r\n    }\r\n\r\n    // Deposit LP tokens to MasterChef for sphynx allocation.\r\n    function deposit(uint256 _pid, uint256 _amount) public payable {\r\n        require(_pid != 0, \"deposit sphynx by staking\");\r\n\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][msg.sender];\r\n        updatePool(_pid);\r\n        if (user.amount > 0) {\r\n            uint256 pending = user\r\n                .amount\r\n                .mul(pool.accSphynxPerShare)\r\n                .div(1e12)\r\n                .sub(user.rewardDebt);\r\n            if (pending > 0) {\r\n                safeSphynxTransfer(msg.sender, pending);\r\n            }\r\n        }\r\n        if (_amount > 0) {\r\n            _availableStaking();\r\n            pool.lpToken.safeTransferFrom(\r\n                address(msg.sender),\r\n                address(this),\r\n                _amount\r\n            );\r\n            user.amount = user.amount.add(_amount);\r\n        }\r\n        user.rewardDebt = user.amount.mul(pool.accSphynxPerShare).div(1e12);\r\n        emit Deposit(msg.sender, _pid, _amount);\r\n    }\r\n\r\n    // Withdraw LP tokens from MasterChef.\r\n    function withdraw(uint256 _pid, uint256 _amount) public payable {\r\n        require(_pid != 0, \"withdraw sphynx by unstaking\");\r\n\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][msg.sender];\r\n        require(user.amount >= _amount, \"withdraw: not good\");\r\n        updatePool(_pid);\r\n        uint256 pending = user.amount.mul(pool.accSphynxPerShare).div(1e12).sub(\r\n            user.rewardDebt\r\n        );\r\n        if (pending > 0) {\r\n            safeSphynxTransfer(msg.sender, pending);\r\n        }\r\n        if (_amount > 0) {\r\n            user.amount = user.amount.sub(_amount);\r\n            bool _available = stakingAvailable();\r\n            if (_available) {\r\n                pool.lpToken.safeTransfer(address(msg.sender), _amount);\r\n            } else {\r\n                uint256 _penaltyFee = _amount.mul(penaltyFee).div(100);\r\n                pool.lpToken.safeTransfer(owner(), _penaltyFee);\r\n                pool.lpToken.safeTransfer(address(msg.sender), _amount.sub(_penaltyFee));\r\n            }\r\n        }\r\n        user.rewardDebt = user.amount.mul(pool.accSphynxPerShare).div(1e12);\r\n        emit Withdraw(msg.sender, _pid, _amount);\r\n    }\r\n\r\n    // Stake sphynx tokens to MasterChef\r\n    function enterStaking(uint256 _amount) public payable {\r\n        PoolInfo storage pool = poolInfo[0];\r\n        UserInfo storage user = userInfo[0][msg.sender];\r\n        updatePool(0);\r\n        uint256 pending;\r\n        if (user.amount > 0) {\r\n            pending = user\r\n                .amount\r\n                .mul(pool.accSphynxPerShare)\r\n                .div(1e12)\r\n                .sub(user.rewardDebt);\r\n        }\r\n        if (_amount > 0) {\r\n            _availableStaking();\r\n            pool.lpToken.safeTransferFrom(\r\n                address(msg.sender),\r\n                address(this),\r\n                _amount\r\n            );\r\n            user.amount = user.amount.add(_amount);\r\n            stakedTokens = stakedTokens.add(_amount);\r\n        }\r\n        user.rewardDebt = user.amount.mul(pool.accSphynxPerShare).div(1e12);\r\n\r\n        if (pending > 0) {\r\n            safeSphynxTransfer(msg.sender, pending);\r\n        }\r\n        emit Deposit(msg.sender, 0, _amount);\r\n    }\r\n\r\n    // Withdraw sphynx tokens from STAKING.\r\n    function leaveStaking(uint256 _amount) public payable {\r\n        PoolInfo storage pool = poolInfo[0];\r\n        UserInfo storage user = userInfo[0][msg.sender];\r\n        require(user.amount >= _amount, \"withdraw: not good\");\r\n        updatePool(0);\r\n        uint256 pending = user.amount.mul(pool.accSphynxPerShare).div(1e12).sub(\r\n            user.rewardDebt\r\n        );\r\n        if (_amount > 0) {\r\n            user.amount = user.amount.sub(_amount);\r\n            stakedTokens = stakedTokens.sub(_amount);\r\n            bool _available = stakingAvailable();\r\n            if (_available) {\r\n                pool.lpToken.safeTransfer(address(msg.sender), _amount);\r\n            } else {\r\n                uint256 _penaltyFee = _amount.mul(penaltyFee).div(100);\r\n                pool.lpToken.safeTransfer(owner(), _penaltyFee);\r\n                pool.lpToken.safeTransfer(address(msg.sender), _amount.sub(_penaltyFee));\r\n            }\r\n        }\r\n        user.rewardDebt = user.amount.mul(pool.accSphynxPerShare).div(1e12);\r\n\r\n        if (pending > 0) {\r\n            safeSphynxTransfer(msg.sender, pending);\r\n        }\r\n\r\n        emit Withdraw(msg.sender, 0, _amount);\r\n    }\r\n\r\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\r\n    function emergencyWithdraw(uint256 _pid) public {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n        UserInfo storage user = userInfo[_pid][msg.sender];\r\n        pool.lpToken.safeTransfer(address(msg.sender), user.amount);\r\n        emit EmergencyWithdraw(msg.sender, _pid, user.amount);\r\n        user.amount = 0;\r\n        user.rewardDebt = 0;\r\n    }\r\n\r\n    // Safe sphynx transfer function, just in case if rounding error causes pool to not have enough sphynxs.\r\n    function safeSphynxTransfer(address _to, uint256 _amount) internal {\r\n        rewardBalance = rewardBalance.sub(_amount);\r\n        address payable _msgSender = payable(msg.sender);\r\n        _msgSender.transfer(_amount);\r\n    }\r\n\r\n    // Sphynx has to add hidden dummy pools inorder to alter the emission, here we make it simple and transparent to all.\r\n    function updateEmissionRate(uint256 _perBlock) public onlyOwner {\r\n        massUpdatePools();\r\n        sphynxPerBlock = _perBlock;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract SphynxToken\",\"name\":\"_sphynx\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_sphynxPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newDev\",\"type\":\"address\"}],\"name\":\"SetDev\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BONUS_MULTIPLIER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"contract IBEP20\",\"name\":\"_lpToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_withUpdate\",\"type\":\"bool\"}],\"name\":\"add\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositRewardToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"emergencyWithdrawRewardToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"enterStaking\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_to\",\"type\":\"uint256\"}],\"name\":\"getMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"leaveStaking\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockPeriods\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"massUpdatePools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"penaltyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingSphynx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolInfo\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accSphynxPerShare\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_withUpdate\",\"type\":\"bool\"}],\"name\":\"set\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sphynx\",\"outputs\":[{\"internalType\":\"contract SphynxToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sphynxPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingAvailable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_available\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingPeriods\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAllocPoint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_perBlock\",\"type\":\"uint256\"}],\"name\":\"updateEmissionRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lockPeriods\",\"type\":\"uint256\"}],\"name\":\"updateLockPeriods\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"multiplierNumber\",\"type\":\"uint256\"}],\"name\":\"updateMultiplier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_penaltyFee\",\"type\":\"uint256\"}],\"name\":\"updatePenaltyFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"updatePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakingPeriods\",\"type\":\"uint256\"}],\"name\":\"updateStakingPeriods\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakingTime\",\"type\":\"uint256\"}],\"name\":\"updateStakingTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "SphynxMasterChefWithLockStaking", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000028470adc7fef2e29e38632d8c17748f53c04e2e0000000000000000000000000000000000000000000000000000009184e72a00000000000000000000000000000000000000000000000000000000000012c84740000000000000000000000000000000000000000000000000000000062d6ef69", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6532df3c9d02f936a4142a55bacb1bac80184c56351bb10f1417954e11be9d98"}