{"SourceCode": "{\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n  function _msgSender() internal view virtual returns (address) {\\n    return msg.sender;\\n  }\\n\\n  function _msgData() internal view virtual returns (bytes calldata) {\\n    return msg.data;\\n  }\\n}\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n  address private _owner;\\n\\n  event OwnershipTransferred(\\n    address indexed previousOwner,\\n    address indexed newOwner\\n  );\\n\\n  /**\\n   * @dev Returns the address of the current owner.\\n   */\\n  function owner() public view returns (address) {\\n    return _owner;\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Leaves the contract without owner. It will not be possible to call\\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\\n   *\\n   * NOTE: Renouncing ownership will leave the contract without an owner,\\n   * thereby removing any functionality that is only available to the owner.\\n   */\\n  function renounceOwnership() public onlyOwner {\\n    _transferOwnership(address(0));\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Can only be called by the current owner.\\n   */\\n  function transferOwnership(address newOwner) public onlyOwner {\\n    require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n    _transferOwnership(newOwner);\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Internal function without access restriction.\\n   */\\n  function _transferOwnership(address newOwner) internal {\\n    address oldOwner = _owner;\\n    _owner = newOwner;\\n    emit OwnershipTransferred(oldOwner, newOwner);\\n  }\\n}\\n\"},\"SSETokenTimeLock.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n// SSETimeLockWallet - Develoaped by www.soroosh.app\\n\\npragma solidity ^0.8.16;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\ninterface IBEP20 {\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function balanceOf(address account) external view returns (uint256);\\n}\\n\\ncontract SSETokenTimeLock is Ownable {\\n\\n    // creation time of the token\\n    uint256 public immutable creationTime;\\n    \\n    // Number of tokens which is released after each period.\\n    uint256 private immutable periodicReleaseNum;\\n    \\n    //  Release period in seconds.\\n    uint256 public constant PERIOD = 15552000; // (seconds in 6 month)\\n    \\n    // Number of tokens that has been withdrawn already.\\n    uint256 private _withdrawnTokens;\\n    \\n    IBEP20 private immutable _token;\\n    \\n    event TokenWithdrawn(uint indexed previousAmount, uint indexed newAmount);\\n\\n\\n    /// @dev creates timelocked wallet with given info.\\n    /// @param token_ tokenContract address.\\n    /// @param periodicReleaseNum_ periodic release number.\\n    constructor(IBEP20 token_, uint256 periodicReleaseNum_, address owner_) {\\n        _transferOwnership(owner_);\\n        _token = token_;\\n        creationTime = 1682943000;\\n        periodicReleaseNum = periodicReleaseNum_;\\n    }\\n\\n    /// @dev withdraws token from wallet if it has enough balance.\\n    /// @param amount_ amount of withdrawal.\\n    /// @param beneficiary_ destination address.\\n    function withdraw(uint256 amount_, address beneficiary_) public onlyOwner {\\n        require(availableTokens() \\u003e= amount_);\\n        uint256 oldAmount  = _withdrawnTokens;\\n        _withdrawnTokens += amount_;\\n        emit TokenWithdrawn(oldAmount, _withdrawnTokens);\\n        require(token().transfer(beneficiary_, amount_));\\n    }\\n    \\n    /// @dev returns token.\\n    function token() public view returns (IBEP20) {\\n        return _token;\\n    }\\n\\n    /// @dev returns periodic release number.\\n    function getPeriodicReleaseNum() public view returns (uint256) {\\n        return periodicReleaseNum;\\n    }\\n\\n    /// @dev returns amount of withdrawan tokens.\\n    function withdrawnTokens() public view returns (uint256) {\\n        return _withdrawnTokens;\\n    }\\n    \\n    /// @dev returns available balance to withdraw.\\n    function availableTokens() public view returns (uint256) {\\n        uint256 passedTime = block.timestamp - creationTime;\\n        return ((passedTime / PERIOD) * periodicReleaseNum) - _withdrawnTokens;\\n    }\\n\\n    /// @dev returns total locked balance of token.\\n    function lockedTokens() public view returns (uint256) {\\n        uint256 balance = timeLockWalletBalance();\\n        return balance - availableTokens();\\n    }\\n\\n    /// @dev returns total balance of the token.\\n    function timeLockWalletBalance() public view returns (uint256) {\\n        uint256 balance = token().balanceOf(address(this));\\n        return balance;\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"periodicReleaseNum_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"previousAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"TokenWithdrawn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"availableTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"creationTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPeriodicReleaseNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeLockWalletBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"beneficiary_\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawnTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "SSETokenTimeLock", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000006a1225c87f15da91e2fa5ee7b2075e2e3a9dbc3900000000000000000000000000000000000000000000106eb45579944880000000000000000000000000000042a440fed0dd7da9970cc842ebbe4e1f4d202da9", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://40ab1c6942919b0075b509ae444982e3ef992d3b0ef77edaa4f19cc523c772a0"}