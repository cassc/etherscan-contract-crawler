{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract Ownable {\r\n    address private _owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    constructor () {\r\n        address msgSender = msg.sender;\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n    modifier onlyOwner() {\r\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        uint256 c = a + b;\r\n        if (c < a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b > a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a % b;\r\n    }\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ncontract Node {\r\n}\r\n\r\ncontract Bottom is Ownable {\r\n    IERC20 public usdt;\r\n    constructor (address usdt_) {\r\n        usdt = IERC20(usdt_);\r\n    }\r\n\r\n    function transferOut(address account, uint256 amount) public onlyOwner{\r\n        usdt.transfer(account, amount);\r\n    }\r\n}\r\n\r\ncontract CLUB is IERC20, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) internal _balances;\r\n    mapping (address => mapping (address => uint256)) internal _allowances;\r\n    uint256 internal _totalSupply;\r\n\r\n    string private _name = \"CLUB\";\r\n    string private _symbol = \"CLUB\";\r\n    uint8 private _decimals = 18;\r\n\r\n    mapping(address => bool) public fromWhiteList;\r\n    mapping(address => bool) public pairList;\r\n\r\n    address public _team = 0x14F14F306d635C2b2EC24fb39dA7D84e9B8D4cFD;\r\n    IERC20 public usdt;\r\n    IUniswapV2Router02 public uniswapV2Router;\r\n\r\n    address public uniswapV2Pair;\r\n    address public union;   //1\r\n    address public board;   //2\r\n    Bottom public bottom;\r\n    uint256 public unionPct = 3;\r\n    uint256 public boardPct = 4;\r\n    uint256 public bottomPct = 2;\r\n\r\n    //Bottom param\r\n    uint256 public _ratio = 10000; // /100\r\n    uint256 public _limit = 10000 * 1e18;\r\n    uint256 public _pct = 3;\r\n\r\n    bool inSwapAndLiquify;\r\n    bool public swapAndLiquifyEnabled = true;\r\n    uint256 public numTokensSellToAddToLiquidity = 0.1 * 1e18;\r\n    uint256 public total = 2100 * 1e18;\r\n    address public dead = 0x000000000000000000000000000000000000dEaD;\r\n    uint256 public toPool = 2000 * 1e18;\r\n\r\n    //Node param\r\n    mapping(address => bool) public nodeWhiteList;\r\n    address[] shareholders1;\r\n    mapping (address => uint256) shareholderIndexes1;\r\n    mapping(address => bool) private _updated1;\r\n    uint256 currentIndex1;\r\n    uint256 public limit1 = 1400 * 1e18;\r\n    \r\n    address[] shareholders2;\r\n    mapping (address => uint256) shareholderIndexes2;\r\n    mapping(address => bool) private _updated2;\r\n    uint256 currentIndex2;\r\n    uint256 public limit2 = 600 * 1e18;\r\n\r\n    uint256 public distributorTime;\r\n    uint256 public distributorGas = 500000;\r\n    uint256 public minPeriod = 10 minutes;\r\n    uint256 public minAmount = 0.0001 * 1e18;\r\n    uint256 public minBalance = 0.1 * 1e18;\r\n    address private fromAddress;\r\n    address private toAddress;\r\n\r\n    constructor (address _usdt, address _router) {\r\n        usdt = IERC20(_usdt);\r\n        uniswapV2Router = IUniswapV2Router02(_router);\r\n        union = address(new Node());\r\n        board = address(new Node());\r\n        bottom = new Bottom(address(usdt));\r\n        // Create a uniswap pair for this new token\r\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory())\r\n        .createPair(address(this), address(usdt));\r\n\r\n        _mint(owner(), toPool);\r\n        address team = 0xC3c6f15244a45B74B8083af1DFEd1C543cfD326e;\r\n        _mint(team, total.sub(toPool));\r\n\r\n        fromWhiteList[team] = true;\r\n        fromWhiteList[owner()] = true;\r\n        fromWhiteList[address(this)] = true;\r\n        pairList[uniswapV2Pair] = true;\r\n    }\r\n\r\n    modifier lockTheSwap {\r\n        inSwapAndLiquify = true;\r\n        _;\r\n        inSwapAndLiquify = false;\r\n    }\r\n\r\n    //Bottom param change\r\n    function changeBottomLimit(uint256 limit, uint256 pct) public onlyOwner{\r\n        _limit = limit;\r\n        _pct = pct;\r\n    }\r\n\r\n    function changeBottomRatio(uint256 ratio) public onlyOwner{\r\n        _ratio = ratio;\r\n    }\r\n\r\n    function changeMin(uint256 _distributorGas, uint256 _minPeriod, uint256 _minAmount, uint256 _minBalance) public onlyOwner{\r\n        distributorGas = _distributorGas;\r\n        minPeriod = _minPeriod;\r\n        minAmount = _minAmount;\r\n        minBalance = _minBalance;\r\n    }\r\n\r\n    function changeLimits(uint256 _limit1, uint256 _limit2) public onlyOwner{\r\n        limit1 = _limit1;\r\n        limit2 = _limit2;\r\n    }\r\n\r\n    //Token param change\r\n    function setPairList(address[] memory addrs, bool flag) public onlyOwner() {\r\n        for(uint i=0;i<addrs.length;i++){\r\n            pairList[addrs[i]] = flag;\r\n        }\r\n    }\r\n\r\n    function setWhiteList(address[] memory addrs, bool flag) public onlyOwner() {\r\n        for(uint i=0;i<addrs.length;i++){\r\n            fromWhiteList[addrs[i]] = flag;\r\n        }\r\n    }\r\n\r\n    function changeSwapAndLiquifyEnabled(bool _swapAndLiquifyEnabled) public onlyOwner(){\r\n        swapAndLiquifyEnabled = _swapAndLiquifyEnabled;\r\n    }\r\n\r\n    function changeRouterAddress(address newRouter) public onlyOwner() {\r\n        uniswapV2Router = IUniswapV2Router02(newRouter);\r\n        uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), address(usdt));\r\n    }\r\n\r\n    function changeNumToAddToLiquidity(uint256 num) public onlyOwner() {\r\n        numTokensSellToAddToLiquidity = num;\r\n    }\r\n    \r\n    //Node param change\r\n    function setNodeWhiteList(address[] memory addrs, bool flag) public onlyOwner() {\r\n        for(uint i=0;i<addrs.length;i++){\r\n            nodeWhiteList[addrs[i]] = flag;\r\n        }\r\n    }\r\n\r\n    function process1(uint256 gas) private {\r\n        address pool = union;\r\n        uint256 shareholderCount = shareholders1.length;\r\n        if(shareholderCount == 0) return;\r\n        uint256 nowbanance = balanceOf(pool);\r\n        uint256 gasUsed = 0;\r\n        uint256 gasLeft = gasleft();\r\n\r\n        uint256 iterations = 0;\r\n        while(gasUsed < gas && iterations < shareholderCount) {\r\n            if(currentIndex1 >= shareholderCount){\r\n                currentIndex1 = 0;\r\n            }\r\n\r\n            uint256 amount = nowbanance.mul(IERC20(uniswapV2Pair).balanceOf(shareholders1[currentIndex1])).div(IERC20(uniswapV2Pair).totalSupply());\r\n            if(amount < minAmount) {\r\n                currentIndex1++;\r\n                iterations++;\r\n                return;\r\n            }\r\n            if(balanceOf(pool) < amount ) return;\r\n            distributeDividend(pool, shareholders1[currentIndex1], amount);\r\n\r\n            gasUsed = gasUsed.add(gasLeft.sub(gasleft()));\r\n            gasLeft = gasleft();\r\n            currentIndex1++;\r\n            iterations++;\r\n        }\r\n    }\r\n\r\n    function setShare1(address shareholder) private {\r\n        if(_updated1[shareholder] ){      \r\n            if(IERC20(uniswapV2Pair).balanceOf(shareholder) == 0) quitShare1(shareholder);              \r\n            return;  \r\n        }\r\n        if(IERC20(uniswapV2Pair).balanceOf(shareholder) == 0) return;\r\n        addShareholder1(shareholder);\r\n        _updated1[shareholder] = true;\r\n    }\r\n    function addShareholder1(address shareholder) internal {\r\n        shareholderIndexes1[shareholder] = shareholders1.length;\r\n        shareholders1.push(shareholder);\r\n    }\r\n    function quitShare1(address shareholder) private {\r\n        removeShareholder1(shareholder);   \r\n        _updated1[shareholder] = false; \r\n    }\r\n    function removeShareholder1(address shareholder) internal {\r\n        shareholders1[shareholderIndexes1[shareholder]] = shareholders1[shareholders1.length-1];\r\n        shareholderIndexes1[shareholders1[shareholders1.length-1]] = shareholderIndexes1[shareholder];\r\n        shareholders1.pop();\r\n    }\r\n    \r\n    function process2(uint256 gas) private {\r\n        address pool = board;\r\n        uint256 shareholderCount = shareholders2.length;\r\n        if(shareholderCount == 0) return;\r\n        uint256 nowbanance = balanceOf(pool);\r\n        uint256 gasUsed = 0;\r\n        uint256 gasLeft = gasleft();\r\n\r\n        uint256 iterations = 0;\r\n        while(gasUsed < gas && iterations < shareholderCount) {\r\n            if(currentIndex2 >= shareholderCount){\r\n                currentIndex2 = 0;\r\n            }\r\n\r\n            uint256 amount = nowbanance.mul(IERC20(uniswapV2Pair).balanceOf(shareholders2[currentIndex2])).div(IERC20(uniswapV2Pair).totalSupply());\r\n            if(amount < minAmount) {\r\n                currentIndex2++;\r\n                iterations++;\r\n                return;\r\n            }\r\n            if(balanceOf(pool) < amount ) return;\r\n            distributeDividend(pool, shareholders2[currentIndex2], amount);\r\n\r\n            gasUsed = gasUsed.add(gasLeft.sub(gasleft()));\r\n            gasLeft = gasleft();\r\n            currentIndex2++;\r\n            iterations++;\r\n        }\r\n    }\r\n\r\n    function setShare2(address shareholder) private {\r\n        if(_updated2[shareholder] ){      \r\n            if(IERC20(uniswapV2Pair).balanceOf(shareholder) == 0) quitShare2(shareholder);              \r\n            return;  \r\n        }\r\n        if(IERC20(uniswapV2Pair).balanceOf(shareholder) == 0) return;\r\n        addShareholder2(shareholder);\r\n        _updated2[shareholder] = true;\r\n    }\r\n    function addShareholder2(address shareholder) internal {\r\n        shareholderIndexes2[shareholder] = shareholders2.length;\r\n        shareholders2.push(shareholder);\r\n    }\r\n    function quitShare2(address shareholder) private {\r\n        removeShareholder2(shareholder);   \r\n        _updated2[shareholder] = false; \r\n    }\r\n    function removeShareholder2(address shareholder) internal {\r\n        shareholders2[shareholderIndexes2[shareholder]] = shareholders2[shareholders2.length-1];\r\n        shareholderIndexes2[shareholders2[shareholders2.length-1]] = shareholderIndexes2[shareholder];\r\n        shareholders2.pop();\r\n    }\r\n   \r\n    function distributeDividend(address pool, address shareholder ,uint256 amount) internal {\r\n        _balances[pool] = _balances[pool].sub(amount);\r\n        _balances[shareholder] = _balances[shareholder].add(amount);\r\n        emit Transfer(pool, shareholder, amount);\r\n    }\r\n\r\n    function getShareholdersLength() public view returns(uint256,uint256){\r\n        return (shareholders1.length, shareholders2.length);\r\n    }\r\n\r\n    function getList(uint256 typeNum, uint256 start, uint256 length) public view returns(address[] memory addrs, uint256[] memory bals){\r\n        address[] memory list = typeNum == 2 ? shareholders2 : shareholders1;\r\n        uint256 end = (start+length) < list.length ? (start+length) : list.length;\r\n        (,length) = end.trySub(start);\r\n        addrs = new address[](length);\r\n        bals = new uint256[](length);\r\n        IERC20 pair = IERC20(uniswapV2Pair);\r\n        for(uint i=start; i<end; i++){\r\n            addrs[i-start] = list[i];\r\n            bals[i-start] = pair.balanceOf(list[i]);\r\n        }\r\n    }\r\n\r\n    function getLPPrice() public view returns (uint256) {\r\n        IUniswapV2Pair pair = IUniswapV2Pair(address(uniswapV2Pair));\r\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\r\n        uint256 totalLP = pair.totalSupply();\r\n        if(totalLP == 0) return 0;\r\n        if(address(usdt)==pair.token0()){\r\n            return reserve0.mul(2e18).div(totalLP);\r\n        }else{\r\n            return reserve1.mul(2e18).div(totalLP);\r\n        }\r\n    }\r\n\r\n    function name() public view virtual returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view virtual returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view virtual returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    function swapTokensForToken(uint256 tokenAmount) private lockTheSwap {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = address(usdt);\r\n\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n\r\n        uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0,\r\n            path,\r\n            address(bottom),\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        uint256 contractTokenBalance = balanceOf(address(this));\r\n        bool overMinTokenBalance = contractTokenBalance >= numTokensSellToAddToLiquidity;\r\n        if (\r\n            overMinTokenBalance &&\r\n            !inSwapAndLiquify &&\r\n            sender != uniswapV2Pair &&\r\n            swapAndLiquifyEnabled\r\n        ) {\r\n            contractTokenBalance = numTokensSellToAddToLiquidity;\r\n            swapTokensForToken(contractTokenBalance);\r\n            uint256 balance = usdt.balanceOf(address(bottom));\r\n            if(balance >= _limit){\r\n                try bottom.transferOut(_team, balance.mul(_pct).div(100)) {} catch{}\r\n            }\r\n        }\r\n\r\n        if(recipient == dead && amount == 1e18){\r\n            uint256 balance = usdt.balanceOf(address(bottom));\r\n            uint256 usdtAmount = amount.mul(_ratio).div(100);\r\n            try bottom.transferOut(sender, balance.min(usdtAmount)) {} catch{}\r\n        }\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n\r\n        if(!inSwapAndLiquify && !fromWhiteList[sender] && pairList[recipient]){\r\n            uint256 toSwap = amount.mul(bottomPct).div(100);\r\n            uint256 toUnion = amount.mul(unionPct).div(100);\r\n            uint256 toBoard = amount.mul(boardPct).div(100);\r\n            _balances[address(this)] = _balances[address(this)].add(toSwap);\r\n            emit Transfer(sender, address(this), toSwap);\r\n\r\n            _balances[address(union)] = _balances[address(union)].add(toUnion);\r\n            emit Transfer(sender, address(union), toUnion);\r\n\r\n            _balances[address(board)] = _balances[address(board)].add(toBoard);\r\n            emit Transfer(sender, address(board), toBoard);\r\n\r\n            amount = amount.sub(toSwap).sub(toUnion).sub(toBoard);\r\n        }\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n\r\n        if(fromAddress == address(0) )fromAddress = sender;\r\n        if(toAddress == address(0) )toAddress = recipient;  \r\n        if(fromAddress != uniswapV2Pair ) {\r\n            setShare1(fromAddress);\r\n            setShare2(fromAddress);\r\n        }\r\n        if(toAddress != uniswapV2Pair ) {\r\n            setShare1(toAddress);\r\n            setShare2(toAddress);\r\n        }\r\n        \r\n        fromAddress = sender;\r\n        toAddress = recipient;\r\n         if((balanceOf(union) >= minBalance || balanceOf(board) >= minBalance) && \r\n            sender != address(this) && distributorTime.add(minPeriod) <= block.timestamp) {\r\n            if(balanceOf(union) >= minBalance) process1(distributorGas.div(2));\r\n            if(balanceOf(board) >= minBalance) process2(distributorGas.div(2));\r\n            distributorTime = block.timestamp;\r\n        }\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _setupDecimals(uint8 decimals_) internal virtual {\r\n        _decimals = decimals_;\r\n    }\r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_usdt\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_limit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_pct\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_ratio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_team\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"board\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"boardPct\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bottom\",\"outputs\":[{\"internalType\":\"contract Bottom\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bottomPct\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pct\",\"type\":\"uint256\"}],\"name\":\"changeBottomLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ratio\",\"type\":\"uint256\"}],\"name\":\"changeBottomRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_limit1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_limit2\",\"type\":\"uint256\"}],\"name\":\"changeLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_distributorGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minBalance\",\"type\":\"uint256\"}],\"name\":\"changeMin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"changeNumToAddToLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRouter\",\"type\":\"address\"}],\"name\":\"changeRouterAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_swapAndLiquifyEnabled\",\"type\":\"bool\"}],\"name\":\"changeSwapAndLiquifyEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dead\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributorGas\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributorTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"fromWhiteList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLPPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"typeNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"getList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"bals\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getShareholdersLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"limit1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"limit2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nodeWhiteList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numTokensSellToAddToLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pairList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"flag\",\"type\":\"bool\"}],\"name\":\"setNodeWhiteList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"flag\",\"type\":\"bool\"}],\"name\":\"setPairList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"flag\",\"type\":\"bool\"}],\"name\":\"setWhiteList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapAndLiquifyEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"total\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"union\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unionPct\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdt\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "CLUB", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000055d398326f99059ff775485246999027b319795500000000000000000000000010ed43c718714eb63d5aa57b78b54704e256024e", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a6e51522262f4ffda03548f748975ae3115c559d7edb7590edc0551b5afbb6de"}