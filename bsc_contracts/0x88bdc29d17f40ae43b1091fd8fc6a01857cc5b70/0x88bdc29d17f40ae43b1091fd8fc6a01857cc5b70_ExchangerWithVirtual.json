{"SourceCode": "/*\n\n\u2588\u2588\u2557  \u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2557   \u2588\u2588\u2557\n\u2588\u2588\u2551  \u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557 \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557 \u2588\u2588\u2551 \u255a\u2550\u2550\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\n\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551 \u2588\u2588\u2551   \u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2551   \u2588\u2588\u2588\u2554\u255d  \u2588\u2588\u2551   \u2588\u2588\u2551 \u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\n\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551 \u2588\u2588\u2551   \u2588\u2588\u2551 \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557 \u2588\u2588\u2551  \u2588\u2588\u2588\u2554\u255d   \u2588\u2588\u2551   \u2588\u2588\u2551 \u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\n\u2588\u2588\u2551  \u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2551  \u2588\u2588\u2551 \u2588\u2588\u2551 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\n\u255a\u2550\u255d  \u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u255d  \u255a\u2550\u255d \u255a\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d\n\n* Horizon Protocol: ExchangerWithVirtualSynth.sol\n*\n* Latest source (may be newer): https://github.com/Horizon-Protocol/Horizon-Smart-Contract/blob/master/contracts/ExchangerWithVirtualSynth.sol\n* Docs: https://docs.horizonprotocol.com/\n*\n* Contract Dependencies: \n*\t- Exchanger\n*\t- IAddressResolver\n*\t- IExchanger\n*\t- MinimalProxyFactory\n*\t- MixinResolver\n*\t- MixinSystemSettings\n*\t- Owned\n* Libraries: \n*\t- SafeDecimalMath\n*\t- SafeMath\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2022 Horizon Protocol\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n\n\n\npragma solidity ^0.5.16;\n\n// https://docs.synthetix.io/contracts/source/contracts/owned\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        _onlyOwner();\n        _;\n    }\n\n    function _onlyOwner() private view {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iaddressresolver\ninterface IAddressResolver {\n    function getAddress(bytes32 name) external view returns (address);\n\n    function getSynth(bytes32 key) external view returns (address);\n\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address);\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/isynth\ninterface ISynth {\n    // Views\n    function currencyKey() external view returns (bytes32);\n\n    function transferableSynths(address account) external view returns (uint);\n\n    // Mutative functions\n    function transferAndSettle(address to, uint value) external returns (bool);\n\n    function transferFromAndSettle(\n        address from,\n        address to,\n        uint value\n    ) external returns (bool);\n\n    // Restricted: used internally to Synthetix\n    function burn(address account, uint amount) external;\n\n    function issue(address account, uint amount) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iissuer\ninterface IIssuer {\n    // Views\n    function anySynthOrSNXRateIsInvalid() external view returns (bool anyRateInvalid);\n\n    function availableCurrencyKeys() external view returns (bytes32[] memory);\n\n    function availableSynthCount() external view returns (uint);\n\n    function availableSynths(uint index) external view returns (ISynth);\n\n    function canBurnSynths(address account) external view returns (bool);\n\n    function collateral(address account) external view returns (uint);\n\n    function collateralisationRatio(address issuer) external view returns (uint);\n\n    function collateralisationRatioAndAnyRatesInvalid(address _issuer)\n        external\n        view\n        returns (uint cratio, bool anyRateIsInvalid);\n\n    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint debtBalance);\n\n    function issuanceRatio() external view returns (uint);\n\n    function lastIssueEvent(address account) external view returns (uint);\n\n    function maxIssuableSynths(address issuer) external view returns (uint maxIssuable);\n\n    function minimumStakeTime() external view returns (uint);\n\n    function remainingIssuableSynths(address issuer)\n        external\n        view\n        returns (\n            uint maxIssuable,\n            uint alreadyIssued,\n            uint totalSystemDebt\n        );\n\n    function synths(bytes32 currencyKey) external view returns (ISynth);\n\n    function getSynths(bytes32[] calldata currencyKeys) external view returns (ISynth[] memory);\n\n    function synthsByAddress(address synthAddress) external view returns (bytes32);\n\n    function totalIssuedSynths(bytes32 currencyKey, bool excludeOtherCollateral) external view returns (uint);\n\n    function transferableSynthetixAndAnyRateIsInvalid(address account, uint balance)\n        external\n        view\n        returns (uint transferable, bool anyRateIsInvalid);\n\n    // Restricted: used internally to Synthetix\n    function issueSynths(address from, uint amount) external;\n\n    function issueSynthsOnBehalf(\n        address issueFor,\n        address from,\n        uint amount\n    ) external;\n\n    function issueMaxSynths(address from) external;\n\n    function issueMaxSynthsOnBehalf(address issueFor, address from) external;\n\n    function burnSynths(address from, uint amount) external;\n\n    function burnSynthsOnBehalf(\n        address burnForAddress,\n        address from,\n        uint amount\n    ) external;\n\n    function burnSynthsToTarget(address from) external;\n\n    function burnSynthsToTargetOnBehalf(address burnForAddress, address from) external;\n\n    function burnForRedemption(\n        address deprecatedSynthProxy,\n        address account,\n        uint balance\n    ) external;\n\n    function liquidateDelinquentAccount(\n        address account,\n        uint zUSDAmount,\n        address liquidator\n    ) external returns (uint totalRedeemed, uint amountToLiquidate);\n}\n\n\n// Inheritance\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/addressresolver\ncontract AddressResolver is Owned, IAddressResolver {\n    mapping(bytes32 => address) public repository;\n\n    constructor(address _owner) public Owned(_owner) {}\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function importAddresses(bytes32[] calldata names, address[] calldata destinations) external onlyOwner {\n        require(names.length == destinations.length, \"Input lengths must match\");\n\n        for (uint i = 0; i < names.length; i++) {\n            bytes32 name = names[i];\n            address destination = destinations[i];\n            repository[name] = destination;\n            emit AddressImported(name, destination);\n        }\n    }\n\n    /* ========= PUBLIC FUNCTIONS ========== */\n\n    function rebuildCaches(MixinResolver[] calldata destinations) external {\n        for (uint i = 0; i < destinations.length; i++) {\n            destinations[i].rebuildCache();\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    function areAddressesImported(bytes32[] calldata names, address[] calldata destinations) external view returns (bool) {\n        for (uint i = 0; i < names.length; i++) {\n            if (repository[names[i]] != destinations[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function getAddress(bytes32 name) external view returns (address) {\n        return repository[name];\n    }\n\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address) {\n        address _foundAddress = repository[name];\n        require(_foundAddress != address(0), reason);\n        return _foundAddress;\n    }\n\n    function getSynth(bytes32 key) external view returns (address) {\n        IIssuer issuer = IIssuer(repository[\"Issuer\"]);\n        require(address(issuer) != address(0), \"Cannot find Issuer address\");\n        return address(issuer.synths(key));\n    }\n\n    /* ========== EVENTS ========== */\n\n    event AddressImported(bytes32 name, address destination);\n}\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/mixinresolver\ncontract MixinResolver {\n    AddressResolver public resolver;\n\n    mapping(bytes32 => address) private addressCache;\n\n    constructor(address _resolver) internal {\n        resolver = AddressResolver(_resolver);\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function combineArrays(bytes32[] memory first, bytes32[] memory second)\n        internal\n        pure\n        returns (bytes32[] memory combination)\n    {\n        combination = new bytes32[](first.length + second.length);\n\n        for (uint i = 0; i < first.length; i++) {\n            combination[i] = first[i];\n        }\n\n        for (uint j = 0; j < second.length; j++) {\n            combination[first.length + j] = second[j];\n        }\n    }\n\n    /* ========== PUBLIC FUNCTIONS ========== */\n\n    // Note: this function is public not external in order for it to be overridden and invoked via super in subclasses\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {}\n\n    function rebuildCache() public {\n        bytes32[] memory requiredAddresses = resolverAddressesRequired();\n        // The resolver must call this function whenver it updates its state\n        for (uint i = 0; i < requiredAddresses.length; i++) {\n            bytes32 name = requiredAddresses[i];\n            // Note: can only be invoked once the resolver has all the targets needed added\n            address destination =\n                resolver.requireAndGetAddress(name, string(abi.encodePacked(\"Resolver missing target: \", name)));\n            addressCache[name] = destination;\n            emit CacheUpdated(name, destination);\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    function isResolverCached() external view returns (bool) {\n        bytes32[] memory requiredAddresses = resolverAddressesRequired();\n        for (uint i = 0; i < requiredAddresses.length; i++) {\n            bytes32 name = requiredAddresses[i];\n            // false if our cache is invalid or if the resolver doesn't have the required address\n            if (resolver.getAddress(name) != addressCache[name] || addressCache[name] == address(0)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function requireAndGetAddress(bytes32 name) internal view returns (address) {\n        address _foundAddress = addressCache[name];\n        require(_foundAddress != address(0), string(abi.encodePacked(\"Missing address: \", name)));\n        return _foundAddress;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event CacheUpdated(bytes32 name, address destination);\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iflexiblestorage\ninterface IFlexibleStorage {\n    // Views\n    function getUIntValue(bytes32 contractName, bytes32 record) external view returns (uint);\n\n    function getUIntValues(bytes32 contractName, bytes32[] calldata records) external view returns (uint[] memory);\n\n    function getIntValue(bytes32 contractName, bytes32 record) external view returns (int);\n\n    function getIntValues(bytes32 contractName, bytes32[] calldata records) external view returns (int[] memory);\n\n    function getAddressValue(bytes32 contractName, bytes32 record) external view returns (address);\n\n    function getAddressValues(bytes32 contractName, bytes32[] calldata records) external view returns (address[] memory);\n\n    function getBoolValue(bytes32 contractName, bytes32 record) external view returns (bool);\n\n    function getBoolValues(bytes32 contractName, bytes32[] calldata records) external view returns (bool[] memory);\n\n    function getBytes32Value(bytes32 contractName, bytes32 record) external view returns (bytes32);\n\n    function getBytes32Values(bytes32 contractName, bytes32[] calldata records) external view returns (bytes32[] memory);\n\n    // Mutative functions\n    function deleteUIntValue(bytes32 contractName, bytes32 record) external;\n\n    function deleteIntValue(bytes32 contractName, bytes32 record) external;\n\n    function deleteAddressValue(bytes32 contractName, bytes32 record) external;\n\n    function deleteBoolValue(bytes32 contractName, bytes32 record) external;\n\n    function deleteBytes32Value(bytes32 contractName, bytes32 record) external;\n\n    function setUIntValue(\n        bytes32 contractName,\n        bytes32 record,\n        uint value\n    ) external;\n\n    function setUIntValues(\n        bytes32 contractName,\n        bytes32[] calldata records,\n        uint[] calldata values\n    ) external;\n\n    function setIntValue(\n        bytes32 contractName,\n        bytes32 record,\n        int value\n    ) external;\n\n    function setIntValues(\n        bytes32 contractName,\n        bytes32[] calldata records,\n        int[] calldata values\n    ) external;\n\n    function setAddressValue(\n        bytes32 contractName,\n        bytes32 record,\n        address value\n    ) external;\n\n    function setAddressValues(\n        bytes32 contractName,\n        bytes32[] calldata records,\n        address[] calldata values\n    ) external;\n\n    function setBoolValue(\n        bytes32 contractName,\n        bytes32 record,\n        bool value\n    ) external;\n\n    function setBoolValues(\n        bytes32 contractName,\n        bytes32[] calldata records,\n        bool[] calldata values\n    ) external;\n\n    function setBytes32Value(\n        bytes32 contractName,\n        bytes32 record,\n        bytes32 value\n    ) external;\n\n    function setBytes32Values(\n        bytes32 contractName,\n        bytes32[] calldata records,\n        bytes32[] calldata values\n    ) external;\n}\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/mixinsystemsettings\ncontract MixinSystemSettings is MixinResolver {\n    bytes32 internal constant SETTING_CONTRACT_NAME = \"SystemSettings\";\n\n    bytes32 internal constant SETTING_WAITING_PERIOD_SECS = \"waitingPeriodSecs\";\n    bytes32 internal constant SETTING_PRICE_DEVIATION_THRESHOLD_FACTOR = \"priceDeviationThresholdFactor\";\n    bytes32 internal constant SETTING_ISSUANCE_RATIO = \"issuanceRatio\";\n    bytes32 internal constant SETTING_FEE_PERIOD_DURATION = \"feePeriodDuration\";\n    bytes32 internal constant SETTING_TARGET_THRESHOLD = \"targetThreshold\";\n    bytes32 internal constant SETTING_LIQUIDATION_DELAY = \"liquidationDelay\";\n    bytes32 internal constant SETTING_LIQUIDATION_RATIO = \"liquidationRatio\";\n    bytes32 internal constant SETTING_LIQUIDATION_PENALTY = \"liquidationPenalty\";\n    bytes32 internal constant SETTING_RATE_STALE_PERIOD = \"rateStalePeriod\";\n    bytes32 internal constant SETTING_EXCHANGE_FEE_RATE = \"exchangeFeeRate\";\n    bytes32 internal constant SETTING_MINIMUM_STAKE_TIME = \"minimumStakeTime\";\n    bytes32 internal constant SETTING_AGGREGATOR_WARNING_FLAGS = \"aggregatorWarningFlags\";\n    bytes32 internal constant SETTING_TRADING_REWARDS_ENABLED = \"tradingRewardsEnabled\";\n    bytes32 internal constant SETTING_DEBT_SNAPSHOT_STALE_TIME = \"debtSnapshotStaleTime\";\n    bytes32 internal constant SETTING_CROSS_DOMAIN_DEPOSIT_GAS_LIMIT = \"crossDomainDepositGasLimit\";\n    bytes32 internal constant SETTING_CROSS_DOMAIN_ESCROW_GAS_LIMIT = \"crossDomainEscrowGasLimit\";\n    bytes32 internal constant SETTING_CROSS_DOMAIN_REWARD_GAS_LIMIT = \"crossDomainRewardGasLimit\";\n    bytes32 internal constant SETTING_CROSS_DOMAIN_WITHDRAWAL_GAS_LIMIT = \"crossDomainWithdrawalGasLimit\";\n    bytes32 internal constant SETTING_ETHER_WRAPPER_MAX_ETH = \"etherWrapperMaxETH\";\n    bytes32 internal constant SETTING_ETHER_WRAPPER_MINT_FEE_RATE = \"etherWrapperMintFeeRate\";\n    bytes32 internal constant SETTING_ETHER_WRAPPER_BURN_FEE_RATE = \"etherWrapperBurnFeeRate\";\n\n    bytes32 internal constant CONTRACT_FLEXIBLESTORAGE = \"FlexibleStorage\";\n\n    enum CrossDomainMessageGasLimits {Deposit, Escrow, Reward, Withdrawal}\n\n    constructor(address _resolver) internal MixinResolver(_resolver) {}\n\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {\n        addresses = new bytes32[](1);\n        addresses[0] = CONTRACT_FLEXIBLESTORAGE;\n    }\n\n    function flexibleStorage() internal view returns (IFlexibleStorage) {\n        return IFlexibleStorage(requireAndGetAddress(CONTRACT_FLEXIBLESTORAGE));\n    }\n\n    function _getGasLimitSetting(CrossDomainMessageGasLimits gasLimitType) internal pure returns (bytes32) {\n        if (gasLimitType == CrossDomainMessageGasLimits.Deposit) {\n            return SETTING_CROSS_DOMAIN_DEPOSIT_GAS_LIMIT;\n        } else if (gasLimitType == CrossDomainMessageGasLimits.Escrow) {\n            return SETTING_CROSS_DOMAIN_ESCROW_GAS_LIMIT;\n        } else if (gasLimitType == CrossDomainMessageGasLimits.Reward) {\n            return SETTING_CROSS_DOMAIN_REWARD_GAS_LIMIT;\n        } else if (gasLimitType == CrossDomainMessageGasLimits.Withdrawal) {\n            return SETTING_CROSS_DOMAIN_WITHDRAWAL_GAS_LIMIT;\n        } else {\n            revert(\"Unknown gas limit type\");\n        }\n    }\n\n    function getCrossDomainMessageGasLimit(CrossDomainMessageGasLimits gasLimitType) internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, _getGasLimitSetting(gasLimitType));\n    }\n\n    function getTradingRewardsEnabled() internal view returns (bool) {\n        return flexibleStorage().getBoolValue(SETTING_CONTRACT_NAME, SETTING_TRADING_REWARDS_ENABLED);\n    }\n\n    function getWaitingPeriodSecs() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_WAITING_PERIOD_SECS);\n    }\n\n    function getPriceDeviationThresholdFactor() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_PRICE_DEVIATION_THRESHOLD_FACTOR);\n    }\n\n    function getIssuanceRatio() internal view returns (uint) {\n        // lookup on flexible storage directly for gas savings (rather than via SystemSettings)\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ISSUANCE_RATIO);\n    }\n\n    function getFeePeriodDuration() internal view returns (uint) {\n        // lookup on flexible storage directly for gas savings (rather than via SystemSettings)\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_FEE_PERIOD_DURATION);\n    }\n\n    function getTargetThreshold() internal view returns (uint) {\n        // lookup on flexible storage directly for gas savings (rather than via SystemSettings)\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_TARGET_THRESHOLD);\n    }\n\n    function getLiquidationDelay() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_DELAY);\n    }\n\n    function getLiquidationRatio() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_RATIO);\n    }\n\n    function getLiquidationPenalty() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_PENALTY);\n    }\n\n    function getRateStalePeriod() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_RATE_STALE_PERIOD);\n    }\n\n    function getExchangeFeeRate(bytes32 currencyKey) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_EXCHANGE_FEE_RATE, currencyKey))\n            );\n    }\n\n    function getMinimumStakeTime() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_MINIMUM_STAKE_TIME);\n    }\n\n    function getAggregatorWarningFlags() internal view returns (address) {\n        return flexibleStorage().getAddressValue(SETTING_CONTRACT_NAME, SETTING_AGGREGATOR_WARNING_FLAGS);\n    }\n\n    function getDebtSnapshotStaleTime() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_DEBT_SNAPSHOT_STALE_TIME);\n    }\n\n    function getEtherWrapperMaxETH() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ETHER_WRAPPER_MAX_ETH);\n    }\n\n    function getEtherWrapperMintFeeRate() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ETHER_WRAPPER_MINT_FEE_RATE);\n    }\n\n    function getEtherWrapperBurnFeeRate() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ETHER_WRAPPER_BURN_FEE_RATE);\n    }\n}\n\n\ninterface IVirtualSynth {\n    // Views\n    function balanceOfUnderlying(address account) external view returns (uint);\n\n    function rate() external view returns (uint);\n\n    function readyToSettle() external view returns (bool);\n\n    function secsLeftInWaitingPeriod() external view returns (uint);\n\n    function settled() external view returns (bool);\n\n    function synth() external view returns (ISynth);\n\n    // Mutative functions\n    function settle(address account) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iexchanger\ninterface IExchanger {\n    // Views\n    function calculateAmountAfterSettlement(\n        address from,\n        bytes32 currencyKey,\n        uint amount,\n        uint refunded\n    ) external view returns (uint amountAfterSettlement);\n\n    function isSynthRateInvalid(bytes32 currencyKey) external view returns (bool);\n\n    function maxSecsLeftInWaitingPeriod(address account, bytes32 currencyKey) external view returns (uint);\n\n    function settlementOwing(address account, bytes32 currencyKey)\n        external\n        view\n        returns (\n            uint reclaimAmount,\n            uint rebateAmount,\n            uint numEntries\n        );\n\n    function hasWaitingPeriodOrSettlementOwing(address account, bytes32 currencyKey) external view returns (bool);\n\n    function feeRateForExchange(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey)\n        external\n        view\n        returns (uint exchangeFeeRate);\n\n    function getAmountsForExchange(\n        uint sourceAmount,\n        bytes32 sourceCurrencyKey,\n        bytes32 destinationCurrencyKey\n    )\n        external\n        view\n        returns (\n            uint amountReceived,\n            uint fee,\n            uint exchangeFeeRate\n        );\n\n    function priceDeviationThresholdFactor() external view returns (uint);\n\n    function waitingPeriodSecs() external view returns (uint);\n\n    // Mutative functions\n    function exchange(\n        address exchangeForAddress,\n        address from,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address destinationAddress,\n        bool virtualSynth,\n        address rewardAddress,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived, IVirtualSynth vSynth);\n\n    function settle(address from, bytes32 currencyKey)\n        external\n        returns (\n            uint reclaimed,\n            uint refunded,\n            uint numEntries\n        );\n\n    function setLastExchangeRateForSynth(bytes32 currencyKey, uint rate) external;\n\n    function resetLastExchangeRate(bytes32[] calldata currencyKeys) external;\n\n    function suspendSynthWithInvalidRate(bytes32 currencyKey) external;\n}\n\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\n\n// Libraries\n\n\n// https://docs.synthetix.io/contracts/source/libraries/safedecimalmath\nlibrary SafeDecimalMath {\n    using SafeMath for uint;\n\n    /* Number of decimal places in the representations. */\n    uint8 public constant decimals = 18;\n    uint8 public constant highPrecisionDecimals = 27;\n\n    /* The number representing 1.0. */\n    uint public constant UNIT = 10**uint(decimals);\n\n    /* The number representing 1.0 for higher fidelity numbers. */\n    uint public constant PRECISE_UNIT = 10**uint(highPrecisionDecimals);\n    uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint(highPrecisionDecimals - decimals);\n\n    /**\n     * @return Provides an interface to UNIT.\n     */\n    function unit() external pure returns (uint) {\n        return UNIT;\n    }\n\n    /**\n     * @return Provides an interface to PRECISE_UNIT.\n     */\n    function preciseUnit() external pure returns (uint) {\n        return PRECISE_UNIT;\n    }\n\n    /**\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\n     * decimals.\n     *\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\n     * so that product must be less than 2**256. As this is an integer division,\n     * the internal division always rounds down. This helps save on gas. Rounding\n     * is more expensive on gas.\n     */\n    function multiplyDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        return x.mul(y) / UNIT;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of the specified precision unit.\n     *\n     * @dev The operands should be in the form of a the specified unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function _multiplyDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a precise unit.\n     *\n     * @dev The operands should be in the precise unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a standard unit.\n     *\n     * @dev The operands should be in the standard unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is a high\n     * precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\n     * this is an integer division, the result is always rounded down.\n     * This helps save on gas. Rounding is more expensive on gas.\n     */\n    function divideDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Reintroduce the UNIT factor that will be divided out by y. */\n        return x.mul(UNIT).div(y);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * decimal in the precision unit specified in the parameter.\n     *\n     * @dev y is divided after the product of x and the specified precision unit\n     * is evaluated, so the product of x and the specified precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function _divideDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);\n\n        if (resultTimesTen % 10 >= 5) {\n            resultTimesTen += 10;\n        }\n\n        return resultTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * standard precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and the standard precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * high precision decimal.\n     *\n     * @dev y is divided after the product of x and the high precision unit\n     * is evaluated, so the product of x and the high precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @dev Convert a standard decimal representation to a high precision one.\n     */\n    function decimalToPreciseDecimal(uint i) internal pure returns (uint) {\n        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\n    }\n\n    /**\n     * @dev Convert a high precision decimal to a standard decimal representation.\n     */\n    function preciseDecimalToDecimal(uint i) internal pure returns (uint) {\n        uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    // Computes `a - b`, setting the value to 0 if b > a.\n    function floorsub(uint a, uint b) internal pure returns (uint) {\n        return b >= a ? 0 : a - b;\n    }\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/isystemstatus\ninterface ISystemStatus {\n    struct Status {\n        bool canSuspend;\n        bool canResume;\n    }\n\n    struct Suspension {\n        bool suspended;\n        // reason is an integer code,\n        // 0 => no reason, 1 => upgrading, 2+ => defined by system usage\n        uint248 reason;\n    }\n\n    // Views\n    function accessControl(bytes32 section, address account) external view returns (bool canSuspend, bool canResume);\n\n    function requireSystemActive() external view;\n\n    function requireIssuanceActive() external view;\n\n    function requireExchangeActive() external view;\n\n    function requireExchangeBetweenSynthsAllowed(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view;\n\n    function requireSynthActive(bytes32 currencyKey) external view;\n\n    function requireSynthsActive(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view;\n\n    function systemSuspension() external view returns (bool suspended, uint248 reason);\n\n    function issuanceSuspension() external view returns (bool suspended, uint248 reason);\n\n    function exchangeSuspension() external view returns (bool suspended, uint248 reason);\n\n    function synthExchangeSuspension(bytes32 currencyKey) external view returns (bool suspended, uint248 reason);\n\n    function synthSuspension(bytes32 currencyKey) external view returns (bool suspended, uint248 reason);\n\n    function getSynthExchangeSuspensions(bytes32[] calldata synths)\n        external\n        view\n        returns (bool[] memory exchangeSuspensions, uint256[] memory reasons);\n\n    function getSynthSuspensions(bytes32[] calldata synths)\n        external\n        view\n        returns (bool[] memory suspensions, uint256[] memory reasons);\n\n    // Restricted functions\n    function suspendSynth(bytes32 currencyKey, uint256 reason) external;\n\n    function updateAccessControl(\n        bytes32 section,\n        address account,\n        bool canSuspend,\n        bool canResume\n    ) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/ierc20\ninterface IERC20 {\n    // ERC20 Optional Views\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    // Views\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address owner) external view returns (uint);\n\n    function allowance(address owner, address spender) external view returns (uint);\n\n    // Mutative functions\n    function transfer(address to, uint value) external returns (bool);\n\n    function approve(address spender, uint value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint value\n    ) external returns (bool);\n\n    // Events\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iexchangestate\ninterface IExchangeState {\n    // Views\n    struct ExchangeEntry {\n        bytes32 src;\n        uint amount;\n        bytes32 dest;\n        uint amountReceived;\n        uint exchangeFeeRate;\n        uint timestamp;\n        uint roundIdForSrc;\n        uint roundIdForDest;\n    }\n\n    function getLengthOfEntries(address account, bytes32 currencyKey) external view returns (uint);\n\n    function getEntryAt(\n        address account,\n        bytes32 currencyKey,\n        uint index\n    )\n        external\n        view\n        returns (\n            bytes32 src,\n            uint amount,\n            bytes32 dest,\n            uint amountReceived,\n            uint exchangeFeeRate,\n            uint timestamp,\n            uint roundIdForSrc,\n            uint roundIdForDest\n        );\n\n    function getMaxTimestamp(address account, bytes32 currencyKey) external view returns (uint);\n\n    // Mutative functions\n    function appendExchangeEntry(\n        address account,\n        bytes32 src,\n        uint amount,\n        bytes32 dest,\n        uint amountReceived,\n        uint exchangeFeeRate,\n        uint timestamp,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    ) external;\n\n    function removeEntries(address account, bytes32 currencyKey) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iexchangerates\ninterface IExchangeRates {\n    // Structs\n    struct RateAndUpdatedTime {\n        uint216 rate;\n        uint40 time;\n    }\n\n    struct InversePricing {\n        uint entryPoint;\n        uint upperLimit;\n        uint lowerLimit;\n        bool frozenAtUpperLimit;\n        bool frozenAtLowerLimit;\n    }\n\n    // Views\n    function aggregators(bytes32 currencyKey) external view returns (address);\n\n    function aggregatorWarningFlags() external view returns (address);\n\n    function anyRateIsInvalid(bytes32[] calldata currencyKeys) external view returns (bool);\n\n    function canFreezeRate(bytes32 currencyKey) external view returns (bool);\n\n    function currentRoundForRate(bytes32 currencyKey) external view returns (uint);\n\n    function currenciesUsingAggregator(address aggregator) external view returns (bytes32[] memory);\n\n    function effectiveValue(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external view returns (uint value);\n\n    function effectiveValueAndRates(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    )\n        external\n        view\n        returns (\n            uint value,\n            uint sourceRate,\n            uint destinationRate\n        );\n\n    function effectiveValueAtRound(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    ) external view returns (uint value);\n\n    function getCurrentRoundId(bytes32 currencyKey) external view returns (uint);\n\n    function getLastRoundIdBeforeElapsedSecs(\n        bytes32 currencyKey,\n        uint startingRoundId,\n        uint startingTimestamp,\n        uint timediff\n    ) external view returns (uint);\n\n    function inversePricing(bytes32 currencyKey)\n        external\n        view\n        returns (\n            uint entryPoint,\n            uint upperLimit,\n            uint lowerLimit,\n            bool frozenAtUpperLimit,\n            bool frozenAtLowerLimit\n        );\n\n    function lastRateUpdateTimes(bytes32 currencyKey) external view returns (uint256);\n\n    function oracle() external view returns (address);\n\n    function rateAndTimestampAtRound(bytes32 currencyKey, uint roundId) external view returns (uint rate, uint time);\n\n    function rateAndUpdatedTime(bytes32 currencyKey) external view returns (uint rate, uint time);\n\n    function rateAndInvalid(bytes32 currencyKey) external view returns (uint rate, bool isInvalid);\n\n    function rateForCurrency(bytes32 currencyKey) external view returns (uint);\n\n    function rateIsFlagged(bytes32 currencyKey) external view returns (bool);\n\n    function rateIsFrozen(bytes32 currencyKey) external view returns (bool);\n\n    function rateIsInvalid(bytes32 currencyKey) external view returns (bool);\n\n    function rateIsStale(bytes32 currencyKey) external view returns (bool);\n\n    function rateStalePeriod() external view returns (uint);\n\n    function ratesAndUpdatedTimeForCurrencyLastNRounds(bytes32 currencyKey, uint numRounds)\n        external\n        view\n        returns (uint[] memory rates, uint[] memory times);\n\n    function ratesAndInvalidForCurrencies(bytes32[] calldata currencyKeys)\n        external\n        view\n        returns (uint[] memory rates, bool anyRateInvalid);\n\n    function ratesForCurrencies(bytes32[] calldata currencyKeys) external view returns (uint[] memory);\n\n    // Mutative functions\n    function freezeRate(bytes32 currencyKey) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/isynthetix\ninterface ISynthetix {\n    // Views\n    function anySynthOrSNXRateIsInvalid() external view returns (bool anyRateInvalid);\n\n    function availableCurrencyKeys() external view returns (bytes32[] memory);\n\n    function availableSynthCount() external view returns (uint);\n\n    function availableSynths(uint index) external view returns (ISynth);\n\n    function collateral(address account) external view returns (uint);\n\n    function collateralisationRatio(address issuer) external view returns (uint);\n\n    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint);\n\n    function isWaitingPeriod(bytes32 currencyKey) external view returns (bool);\n\n    function maxIssuableSynths(address issuer) external view returns (uint maxIssuable);\n\n    function remainingIssuableSynths(address issuer)\n        external\n        view\n        returns (\n            uint maxIssuable,\n            uint alreadyIssued,\n            uint totalSystemDebt\n        );\n\n    function synths(bytes32 currencyKey) external view returns (ISynth);\n\n    function synthsByAddress(address synthAddress) external view returns (bytes32);\n\n    function totalIssuedSynths(bytes32 currencyKey) external view returns (uint);\n\n    function totalIssuedSynthsExcludeOtherCollateral(bytes32 currencyKey) external view returns (uint);\n\n    function transferableSynthetix(address account) external view returns (uint transferable);\n\n    // Mutative Functions\n    function burnSynths(uint amount) external;\n\n    function burnSynthsOnBehalf(address burnForAddress, uint amount) external;\n\n    function burnSynthsToTarget() external;\n\n    function burnSynthsToTargetOnBehalf(address burnForAddress) external;\n\n    function exchange(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external returns (uint amountReceived);\n\n    function exchangeOnBehalf(\n        address exchangeForAddress,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external returns (uint amountReceived);\n\n    function exchangeWithTracking(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address rewardAddress,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived);\n\n    function exchangeWithTrackingForInitiator(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address rewardAddress,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived);\n\n    function exchangeOnBehalfWithTracking(\n        address exchangeForAddress,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address rewardAddress,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived);\n\n    function exchangeWithVirtual(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived, IVirtualSynth vSynth);\n\n    function issueMaxSynths() external;\n\n    function issueMaxSynthsOnBehalf(address issueForAddress) external;\n\n    function issueSynths(uint amount) external;\n\n    function issueSynthsOnBehalf(address issueForAddress, uint amount) external;\n\n    function mint() external returns (bool);\n\n    function settle(bytes32 currencyKey)\n        external\n        returns (\n            uint reclaimed,\n            uint refunded,\n            uint numEntries\n        );\n\n    // Liquidations\n    function liquidateDelinquentAccount(address account, uint zUSDAmount) external returns (bool);\n\n    // Restricted Functions\n\n    function mintSecondary(address account, uint amount) external;\n\n    function mintSecondaryRewards(uint amount) external;\n\n    function burnSecondary(address account, uint amount) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/ifeepool\ninterface IFeePool {\n    // Views\n\n    // solhint-disable-next-line func-name-mixedcase\n    function FEE_ADDRESS() external view returns (address);\n\n    function feesAvailable(address account) external view returns (uint, uint);\n\n    function feePeriodDuration() external view returns (uint);\n\n    function isFeesClaimable(address account) external view returns (bool);\n\n    function targetThreshold() external view returns (uint);\n\n    function totalFeesAvailable() external view returns (uint);\n\n    function totalRewardsAvailable() external view returns (uint);\n\n    // Mutative Functions\n    function claimFees() external returns (bool);\n\n    function claimOnBehalf(address claimingForAddress) external returns (bool);\n\n    function closeCurrentFeePeriod() external;\n\n    // Restricted: used internally to Synthetix\n    function appendAccountIssuanceRecord(\n        address account,\n        uint lockedAmount,\n        uint debtEntryIndex\n    ) external;\n\n    function recordFeePaid(uint zUSDAmount) external;\n\n    function setRewardsToDistribute(uint amount) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/idelegateapprovals\ninterface IDelegateApprovals {\n    // Views\n    function canBurnFor(address authoriser, address delegate) external view returns (bool);\n\n    function canIssueFor(address authoriser, address delegate) external view returns (bool);\n\n    function canClaimFor(address authoriser, address delegate) external view returns (bool);\n\n    function canExchangeFor(address authoriser, address delegate) external view returns (bool);\n\n    // Mutative\n    function approveAllDelegatePowers(address delegate) external;\n\n    function removeAllDelegatePowers(address delegate) external;\n\n    function approveBurnOnBehalf(address delegate) external;\n\n    function removeBurnOnBehalf(address delegate) external;\n\n    function approveIssueOnBehalf(address delegate) external;\n\n    function removeIssueOnBehalf(address delegate) external;\n\n    function approveClaimOnBehalf(address delegate) external;\n\n    function removeClaimOnBehalf(address delegate) external;\n\n    function approveExchangeOnBehalf(address delegate) external;\n\n    function removeExchangeOnBehalf(address delegate) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/itradingrewards\ninterface ITradingRewards {\n    /* ========== VIEWS ========== */\n\n    function getAvailableRewards() external view returns (uint);\n\n    function getUnassignedRewards() external view returns (uint);\n\n    function getRewardsToken() external view returns (address);\n\n    function getPeriodController() external view returns (address);\n\n    function getCurrentPeriod() external view returns (uint);\n\n    function getPeriodIsClaimable(uint periodID) external view returns (bool);\n\n    function getPeriodIsFinalized(uint periodID) external view returns (bool);\n\n    function getPeriodRecordedFees(uint periodID) external view returns (uint);\n\n    function getPeriodTotalRewards(uint periodID) external view returns (uint);\n\n    function getPeriodAvailableRewards(uint periodID) external view returns (uint);\n\n    function getUnaccountedFeesForAccountForPeriod(address account, uint periodID) external view returns (uint);\n\n    function getAvailableRewardsForAccountForPeriod(address account, uint periodID) external view returns (uint);\n\n    function getAvailableRewardsForAccountForPeriods(address account, uint[] calldata periodIDs)\n        external\n        view\n        returns (uint totalRewards);\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function claimRewardsForPeriod(uint periodID) external;\n\n    function claimRewardsForPeriods(uint[] calldata periodIDs) external;\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function recordExchangeFeeForAccount(uint usdFeeAmount, address account) external;\n\n    function closeCurrentPeriodWithRewards(uint rewards) external;\n\n    function recoverTokens(address tokenAddress, address recoverAddress) external;\n\n    function recoverUnassignedRewardTokens(address recoverAddress) external;\n\n    function recoverAssignedRewardTokensAndDestroyPeriod(address recoverAddress, uint periodID) external;\n\n    function setPeriodController(address newPeriodController) external;\n}\n\n\n// Inheritance\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/proxy\ncontract Proxy is Owned {\n    Proxyable public target;\n\n    constructor(address _owner) public Owned(_owner) {}\n\n    function setTarget(Proxyable _target) external onlyOwner {\n        target = _target;\n        emit TargetUpdated(_target);\n    }\n\n    function _emit(\n        bytes calldata callData,\n        uint numTopics,\n        bytes32 topic1,\n        bytes32 topic2,\n        bytes32 topic3,\n        bytes32 topic4\n    ) external onlyTarget {\n        uint size = callData.length;\n        bytes memory _callData = callData;\n\n        assembly {\n            /* The first 32 bytes of callData contain its length (as specified by the abi).\n             * Length is assumed to be a uint256 and therefore maximum of 32 bytes\n             * in length. It is also leftpadded to be a multiple of 32 bytes.\n             * This means moving call_data across 32 bytes guarantees we correctly access\n             * the data itself. */\n            switch numTopics\n                case 0 {\n                    log0(add(_callData, 32), size)\n                }\n                case 1 {\n                    log1(add(_callData, 32), size, topic1)\n                }\n                case 2 {\n                    log2(add(_callData, 32), size, topic1, topic2)\n                }\n                case 3 {\n                    log3(add(_callData, 32), size, topic1, topic2, topic3)\n                }\n                case 4 {\n                    log4(add(_callData, 32), size, topic1, topic2, topic3, topic4)\n                }\n        }\n    }\n\n    // solhint-disable no-complex-fallback\n    function() external payable {\n        // Mutable call setting Proxyable.messageSender as this is using call not delegatecall\n        target.setMessageSender(msg.sender);\n\n        assembly {\n            let free_ptr := mload(0x40)\n            calldatacopy(free_ptr, 0, calldatasize)\n\n            /* We must explicitly forward ether to the underlying contract as well. */\n            let result := call(gas, sload(target_slot), callvalue, free_ptr, calldatasize, 0, 0)\n            returndatacopy(free_ptr, 0, returndatasize)\n\n            if iszero(result) {\n                revert(free_ptr, returndatasize)\n            }\n            return(free_ptr, returndatasize)\n        }\n    }\n\n    modifier onlyTarget {\n        require(Proxyable(msg.sender) == target, \"Must be proxy target\");\n        _;\n    }\n\n    event TargetUpdated(Proxyable newTarget);\n}\n\n\n// Inheritance\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/proxyable\ncontract Proxyable is Owned {\n    // This contract should be treated like an abstract contract\n\n    /* The proxy this contract exists behind. */\n    Proxy public proxy;\n    Proxy public integrationProxy;\n\n    /* The caller of the proxy, passed through to this contract.\n     * Note that every function using this member must apply the onlyProxy or\n     * optionalProxy modifiers, otherwise their invocations can use stale values. */\n    address public messageSender;\n\n    constructor(address payable _proxy) internal {\n        // This contract is abstract, and thus cannot be instantiated directly\n        require(owner != address(0), \"Owner must be set\");\n\n        proxy = Proxy(_proxy);\n        emit ProxyUpdated(_proxy);\n    }\n\n    function setProxy(address payable _proxy) external onlyOwner {\n        proxy = Proxy(_proxy);\n        emit ProxyUpdated(_proxy);\n    }\n\n    function setIntegrationProxy(address payable _integrationProxy) external onlyOwner {\n        integrationProxy = Proxy(_integrationProxy);\n    }\n\n    function setMessageSender(address sender) external onlyProxy {\n        messageSender = sender;\n    }\n\n    modifier onlyProxy {\n        _onlyProxy();\n        _;\n    }\n\n    function _onlyProxy() private view {\n        require(Proxy(msg.sender) == proxy || Proxy(msg.sender) == integrationProxy, \"Only the proxy can call\");\n    }\n\n    modifier optionalProxy {\n        _optionalProxy();\n        _;\n    }\n\n    function _optionalProxy() private {\n        if (Proxy(msg.sender) != proxy && Proxy(msg.sender) != integrationProxy && messageSender != msg.sender) {\n            messageSender = msg.sender;\n        }\n    }\n\n    modifier optionalProxy_onlyOwner {\n        _optionalProxy_onlyOwner();\n        _;\n    }\n\n    // solhint-disable-next-line func-name-mixedcase\n    function _optionalProxy_onlyOwner() private {\n        if (Proxy(msg.sender) != proxy && Proxy(msg.sender) != integrationProxy && messageSender != msg.sender) {\n            messageSender = msg.sender;\n        }\n        require(messageSender == owner, \"Owner only function\");\n    }\n\n    event ProxyUpdated(address proxyAddress);\n}\n\n\n// Inheritance\n\n\n// Libraries\n\n\n// Internal references\n\n\n// Used to have strongly-typed access to internal mutative functions in Synthetix\ninterface ISynthetixInternal {\n    function emitExchangeTracking(\n        bytes32 trackingCode,\n        bytes32 toCurrencyKey,\n        uint256 toAmount,\n        uint256 fee\n    ) external;\n\n    function emitSynthExchange(\n        address account,\n        bytes32 fromCurrencyKey,\n        uint fromAmount,\n        bytes32 toCurrencyKey,\n        uint toAmount,\n        address toAddress\n    ) external;\n\n    function emitExchangeReclaim(\n        address account,\n        bytes32 currencyKey,\n        uint amount\n    ) external;\n\n    function emitExchangeRebate(\n        address account,\n        bytes32 currencyKey,\n        uint amount\n    ) external;\n}\n\ninterface IExchangerInternalDebtCache {\n    function updateCachedSynthDebtsWithRates(bytes32[] calldata currencyKeys, uint[] calldata currencyRates) external;\n\n    function updateCachedSynthDebts(bytes32[] calldata currencyKeys) external;\n}\n\n// https://docs.synthetix.io/contracts/source/contracts/exchanger\ncontract Exchanger is Owned, MixinSystemSettings, IExchanger {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    struct ExchangeEntrySettlement {\n        bytes32 src;\n        uint amount;\n        bytes32 dest;\n        uint reclaim;\n        uint rebate;\n        uint srcRoundIdAtPeriodEnd;\n        uint destRoundIdAtPeriodEnd;\n        uint timestamp;\n    }\n\n    bytes32 public constant CONTRACT_NAME = \"Exchanger\";\n\n    bytes32 private constant zUSD = \"zUSD\";\n\n    // SIP-65: Decentralized circuit breaker\n    uint public constant CIRCUIT_BREAKER_SUSPENSION_REASON = 65;\n\n    mapping(bytes32 => uint) public lastExchangeRate;\n\n    /* ========== ADDRESS RESOLVER CONFIGURATION ========== */\n\n    bytes32 private constant CONTRACT_SYSTEMSTATUS = \"SystemStatus\";\n    bytes32 private constant CONTRACT_EXCHANGESTATE = \"ExchangeState\";\n    bytes32 private constant CONTRACT_EXRATES = \"ExchangeRates\";\n    bytes32 private constant CONTRACT_SYNTHETIX = \"Synthetix\";\n    bytes32 private constant CONTRACT_FEEPOOL = \"FeePool\";\n    bytes32 private constant CONTRACT_TRADING_REWARDS = \"TradingRewards\";\n    bytes32 private constant CONTRACT_DELEGATEAPPROVALS = \"DelegateApprovals\";\n    bytes32 private constant CONTRACT_ISSUER = \"Issuer\";\n    bytes32 private constant CONTRACT_DEBTCACHE = \"DebtCache\";\n\n    constructor(address _owner, address _resolver) public Owned(_owner) MixinSystemSettings(_resolver) {}\n\n    /* ========== VIEWS ========== */\n\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {\n        bytes32[] memory existingAddresses = MixinSystemSettings.resolverAddressesRequired();\n        bytes32[] memory newAddresses = new bytes32[](9);\n        newAddresses[0] = CONTRACT_SYSTEMSTATUS;\n        newAddresses[1] = CONTRACT_EXCHANGESTATE;\n        newAddresses[2] = CONTRACT_EXRATES;\n        newAddresses[3] = CONTRACT_SYNTHETIX;\n        newAddresses[4] = CONTRACT_FEEPOOL;\n        newAddresses[5] = CONTRACT_TRADING_REWARDS;\n        newAddresses[6] = CONTRACT_DELEGATEAPPROVALS;\n        newAddresses[7] = CONTRACT_ISSUER;\n        newAddresses[8] = CONTRACT_DEBTCACHE;\n        addresses = combineArrays(existingAddresses, newAddresses);\n    }\n\n    function systemStatus() internal view returns (ISystemStatus) {\n        return ISystemStatus(requireAndGetAddress(CONTRACT_SYSTEMSTATUS));\n    }\n\n    function exchangeState() internal view returns (IExchangeState) {\n        return IExchangeState(requireAndGetAddress(CONTRACT_EXCHANGESTATE));\n    }\n\n    function exchangeRates() internal view returns (IExchangeRates) {\n        return IExchangeRates(requireAndGetAddress(CONTRACT_EXRATES));\n    }\n\n    function synthetix() internal view returns (ISynthetix) {\n        return ISynthetix(requireAndGetAddress(CONTRACT_SYNTHETIX));\n    }\n\n    function feePool() internal view returns (IFeePool) {\n        return IFeePool(requireAndGetAddress(CONTRACT_FEEPOOL));\n    }\n\n    function tradingRewards() internal view returns (ITradingRewards) {\n        return ITradingRewards(requireAndGetAddress(CONTRACT_TRADING_REWARDS));\n    }\n\n    function delegateApprovals() internal view returns (IDelegateApprovals) {\n        return IDelegateApprovals(requireAndGetAddress(CONTRACT_DELEGATEAPPROVALS));\n    }\n\n    function issuer() internal view returns (IIssuer) {\n        return IIssuer(requireAndGetAddress(CONTRACT_ISSUER));\n    }\n\n    function debtCache() internal view returns (IExchangerInternalDebtCache) {\n        return IExchangerInternalDebtCache(requireAndGetAddress(CONTRACT_DEBTCACHE));\n    }\n\n    function maxSecsLeftInWaitingPeriod(address account, bytes32 currencyKey) public view returns (uint) {\n        return secsLeftInWaitingPeriodForExchange(exchangeState().getMaxTimestamp(account, currencyKey));\n    }\n\n    function waitingPeriodSecs() external view returns (uint) {\n        return getWaitingPeriodSecs();\n    }\n\n    function tradingRewardsEnabled() external view returns (bool) {\n        return getTradingRewardsEnabled();\n    }\n\n    function priceDeviationThresholdFactor() external view returns (uint) {\n        return getPriceDeviationThresholdFactor();\n    }\n\n    function settlementOwing(address account, bytes32 currencyKey)\n        public\n        view\n        returns (\n            uint reclaimAmount,\n            uint rebateAmount,\n            uint numEntries\n        )\n    {\n        (reclaimAmount, rebateAmount, numEntries, ) = _settlementOwing(account, currencyKey);\n    }\n\n    // Internal function to emit events for each individual rebate and reclaim entry\n    function _settlementOwing(address account, bytes32 currencyKey)\n        internal\n        view\n        returns (\n            uint reclaimAmount,\n            uint rebateAmount,\n            uint numEntries,\n            ExchangeEntrySettlement[] memory\n        )\n    {\n        // Need to sum up all reclaim and rebate amounts for the user and the currency key\n        numEntries = exchangeState().getLengthOfEntries(account, currencyKey);\n\n        // For each unsettled exchange\n        ExchangeEntrySettlement[] memory settlements = new ExchangeEntrySettlement[](numEntries);\n        for (uint i = 0; i < numEntries; i++) {\n            uint reclaim;\n            uint rebate;\n            // fetch the entry from storage\n            IExchangeState.ExchangeEntry memory exchangeEntry = _getExchangeEntry(account, currencyKey, i);\n\n            // determine the last round ids for src and dest pairs when period ended or latest if not over\n            (uint srcRoundIdAtPeriodEnd, uint destRoundIdAtPeriodEnd) = getRoundIdsAtPeriodEnd(exchangeEntry);\n\n            // given these round ids, determine what effective value they should have received\n            uint destinationAmount =\n                exchangeRates().effectiveValueAtRound(\n                    exchangeEntry.src,\n                    exchangeEntry.amount,\n                    exchangeEntry.dest,\n                    srcRoundIdAtPeriodEnd,\n                    destRoundIdAtPeriodEnd\n                );\n\n            // and deduct the fee from this amount using the exchangeFeeRate from storage\n            uint amountShouldHaveReceived = _getAmountReceivedForExchange(destinationAmount, exchangeEntry.exchangeFeeRate);\n\n            // SIP-65 settlements where the amount at end of waiting period is beyond the threshold, then\n            // settle with no reclaim or rebate\n            if (!_isDeviationAboveThreshold(exchangeEntry.amountReceived, amountShouldHaveReceived)) {\n                if (exchangeEntry.amountReceived > amountShouldHaveReceived) {\n                    // if they received more than they should have, add to the reclaim tally\n                    reclaim = exchangeEntry.amountReceived.sub(amountShouldHaveReceived);\n                    reclaimAmount = reclaimAmount.add(reclaim);\n                } else if (amountShouldHaveReceived > exchangeEntry.amountReceived) {\n                    // if less, add to the rebate tally\n                    rebate = amountShouldHaveReceived.sub(exchangeEntry.amountReceived);\n                    rebateAmount = rebateAmount.add(rebate);\n                }\n            }\n\n            settlements[i] = ExchangeEntrySettlement({\n                src: exchangeEntry.src,\n                amount: exchangeEntry.amount,\n                dest: exchangeEntry.dest,\n                reclaim: reclaim,\n                rebate: rebate,\n                srcRoundIdAtPeriodEnd: srcRoundIdAtPeriodEnd,\n                destRoundIdAtPeriodEnd: destRoundIdAtPeriodEnd,\n                timestamp: exchangeEntry.timestamp\n            });\n        }\n\n        return (reclaimAmount, rebateAmount, numEntries, settlements);\n    }\n\n    function _getExchangeEntry(\n        address account,\n        bytes32 currencyKey,\n        uint index\n    ) internal view returns (IExchangeState.ExchangeEntry memory) {\n        (\n            bytes32 src,\n            uint amount,\n            bytes32 dest,\n            uint amountReceived,\n            uint exchangeFeeRate,\n            uint timestamp,\n            uint roundIdForSrc,\n            uint roundIdForDest\n        ) = exchangeState().getEntryAt(account, currencyKey, index);\n\n        return\n            IExchangeState.ExchangeEntry({\n                src: src,\n                amount: amount,\n                dest: dest,\n                amountReceived: amountReceived,\n                exchangeFeeRate: exchangeFeeRate,\n                timestamp: timestamp,\n                roundIdForSrc: roundIdForSrc,\n                roundIdForDest: roundIdForDest\n            });\n    }\n\n    function hasWaitingPeriodOrSettlementOwing(address account, bytes32 currencyKey) external view returns (bool) {\n        if (maxSecsLeftInWaitingPeriod(account, currencyKey) != 0) {\n            return true;\n        }\n\n        (uint reclaimAmount, , , ) = _settlementOwing(account, currencyKey);\n\n        return reclaimAmount > 0;\n    }\n\n    /* ========== SETTERS ========== */\n\n    function calculateAmountAfterSettlement(\n        address from,\n        bytes32 currencyKey,\n        uint amount,\n        uint refunded\n    ) public view returns (uint amountAfterSettlement) {\n        amountAfterSettlement = amount;\n\n        // balance of a synth will show an amount after settlement\n        uint balanceOfSourceAfterSettlement = IERC20(address(issuer().synths(currencyKey))).balanceOf(from);\n\n        // when there isn't enough supply (either due to reclamation settlement or because the number is too high)\n        if (amountAfterSettlement > balanceOfSourceAfterSettlement) {\n            // then the amount to exchange is reduced to their remaining supply\n            amountAfterSettlement = balanceOfSourceAfterSettlement;\n        }\n\n        if (refunded > 0) {\n            amountAfterSettlement = amountAfterSettlement.add(refunded);\n        }\n    }\n\n    function isSynthRateInvalid(bytes32 currencyKey) external view returns (bool) {\n        return _isSynthRateInvalid(currencyKey, exchangeRates().rateForCurrency(currencyKey));\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n    function exchange(\n        address exchangeForAddress,\n        address from,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address destinationAddress,\n        bool virtualSynth,\n        address rewardAddress,\n        bytes32 trackingCode\n    ) external onlySynthetixorSynth returns (uint amountReceived, IVirtualSynth vSynth) {\n        uint fee;\n        if (from != exchangeForAddress) {\n            require(delegateApprovals().canExchangeFor(exchangeForAddress, from), \"Not approved to act on behalf\");\n        }\n\n        (amountReceived, fee, vSynth) = _exchange(\n            exchangeForAddress,\n            sourceCurrencyKey,\n            sourceAmount,\n            destinationCurrencyKey,\n            destinationAddress,\n            virtualSynth\n        );\n\n        if (fee > 0 && rewardAddress != address(0) && getTradingRewardsEnabled()) {\n            tradingRewards().recordExchangeFeeForAccount(fee, rewardAddress);\n        }\n\n        if (trackingCode != bytes32(0)) {\n            ISynthetixInternal(address(synthetix())).emitExchangeTracking(\n                trackingCode,\n                destinationCurrencyKey,\n                amountReceived,\n                fee\n            );\n        }\n    }\n\n    function _suspendIfRateInvalid(bytes32 currencyKey, uint rate) internal returns (bool circuitBroken) {\n        if (_isSynthRateInvalid(currencyKey, rate)) {\n            systemStatus().suspendSynth(currencyKey, CIRCUIT_BREAKER_SUSPENSION_REASON);\n            circuitBroken = true;\n        } else {\n            lastExchangeRate[currencyKey] = rate;\n        }\n    }\n\n    function _updateSNXIssuedDebtOnExchange(bytes32[2] memory currencyKeys, uint[2] memory currencyRates) internal {\n        bool includesSUSD = currencyKeys[0] == zUSD || currencyKeys[1] == zUSD;\n        uint numKeys = includesSUSD ? 2 : 3;\n\n        bytes32[] memory keys = new bytes32[](numKeys);\n        keys[0] = currencyKeys[0];\n        keys[1] = currencyKeys[1];\n\n        uint[] memory rates = new uint[](numKeys);\n        rates[0] = currencyRates[0];\n        rates[1] = currencyRates[1];\n\n        if (!includesSUSD) {\n            keys[2] = zUSD; // And we'll also update zUSD to account for any fees if it wasn't one of the exchanged currencies\n            rates[2] = SafeDecimalMath.unit();\n        }\n\n        // Note that exchanges can't invalidate the debt cache, since if a rate is invalid,\n        // the exchange will have failed already.\n        debtCache().updateCachedSynthDebtsWithRates(keys, rates);\n    }\n\n    function _settleAndCalcSourceAmountRemaining(\n        uint sourceAmount,\n        address from,\n        bytes32 sourceCurrencyKey\n    ) internal returns (uint sourceAmountAfterSettlement) {\n        (, uint refunded, uint numEntriesSettled) = _internalSettle(from, sourceCurrencyKey, false);\n\n        sourceAmountAfterSettlement = sourceAmount;\n\n        // when settlement was required\n        if (numEntriesSettled > 0) {\n            // ensure the sourceAmount takes this into account\n            sourceAmountAfterSettlement = calculateAmountAfterSettlement(from, sourceCurrencyKey, sourceAmount, refunded);\n        }\n    }\n\n    function _exchange(\n        address from,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address destinationAddress,\n        bool virtualSynth\n    )\n        internal\n        returns (\n            uint amountReceived,\n            uint fee,\n            IVirtualSynth vSynth\n        )\n    {\n        _ensureCanExchange(sourceCurrencyKey, sourceAmount, destinationCurrencyKey);\n\n        uint sourceAmountAfterSettlement = _settleAndCalcSourceAmountRemaining(sourceAmount, from, sourceCurrencyKey);\n\n        // If, after settlement the user has no balance left (highly unlikely), then return to prevent\n        // emitting events of 0 and don't revert so as to ensure the settlement queue is emptied\n        if (sourceAmountAfterSettlement == 0) {\n            return (0, 0, IVirtualSynth(0));\n        }\n\n        uint exchangeFeeRate;\n        uint sourceRate;\n        uint destinationRate;\n\n        // Note: `fee` is denominated in the destinationCurrencyKey.\n        (amountReceived, fee, exchangeFeeRate, sourceRate, destinationRate) = _getAmountsForExchangeMinusFees(\n            sourceAmountAfterSettlement,\n            sourceCurrencyKey,\n            destinationCurrencyKey\n        );\n\n        // SIP-65: Decentralized Circuit Breaker\n        if (\n            _suspendIfRateInvalid(sourceCurrencyKey, sourceRate) ||\n            _suspendIfRateInvalid(destinationCurrencyKey, destinationRate)\n        ) {\n            return (0, 0, IVirtualSynth(0));\n        }\n\n        // Note: We don't need to check their balance as the burn() below will do a safe subtraction which requires\n        // the subtraction to not overflow, which would happen if their balance is not sufficient.\n\n        vSynth = _convert(\n            sourceCurrencyKey,\n            from,\n            sourceAmountAfterSettlement,\n            destinationCurrencyKey,\n            amountReceived,\n            destinationAddress,\n            virtualSynth\n        );\n\n        // When using a virtual synth, it becomes the destinationAddress for event and settlement tracking\n        if (vSynth != IVirtualSynth(0)) {\n            destinationAddress = address(vSynth);\n        }\n\n        // Remit the fee if required\n        if (fee > 0) {\n            // Normalize fee to zUSD\n            // Note: `fee` is being reused to avoid stack too deep errors.\n            fee = exchangeRates().effectiveValue(destinationCurrencyKey, fee, zUSD);\n\n            // Remit the fee in zUSDs\n            issuer().synths(zUSD).issue(feePool().FEE_ADDRESS(), fee);\n\n            // Tell the fee pool about this\n            feePool().recordFeePaid(fee);\n        }\n\n        // Note: As of this point, `fee` is denominated in zUSD.\n\n        // Nothing changes as far as issuance data goes because the total value in the system hasn't changed.\n        // But we will update the debt snapshot in case exchange rates have fluctuated since the last exchange\n        // in these currencies\n        _updateSNXIssuedDebtOnExchange([sourceCurrencyKey, destinationCurrencyKey], [sourceRate, destinationRate]);\n\n        // Let the DApps know there was a Synth exchange\n        ISynthetixInternal(address(synthetix())).emitSynthExchange(\n            from,\n            sourceCurrencyKey,\n            sourceAmountAfterSettlement,\n            destinationCurrencyKey,\n            amountReceived,\n            destinationAddress\n        );\n\n        // iff the waiting period is gt 0\n        if (getWaitingPeriodSecs() > 0) {\n            // persist the exchange information for the dest key\n            appendExchange(\n                destinationAddress,\n                sourceCurrencyKey,\n                sourceAmountAfterSettlement,\n                destinationCurrencyKey,\n                amountReceived,\n                exchangeFeeRate\n            );\n        }\n    }\n\n    function _convert(\n        bytes32 sourceCurrencyKey,\n        address from,\n        uint sourceAmountAfterSettlement,\n        bytes32 destinationCurrencyKey,\n        uint amountReceived,\n        address recipient,\n        bool virtualSynth\n    ) internal returns (IVirtualSynth vSynth) {\n        // Burn the source amount\n        issuer().synths(sourceCurrencyKey).burn(from, sourceAmountAfterSettlement);\n\n        // Issue their new synths\n        ISynth dest = issuer().synths(destinationCurrencyKey);\n\n        if (virtualSynth) {\n            Proxyable synth = Proxyable(address(dest));\n            vSynth = _createVirtualSynth(IERC20(address(synth.proxy())), recipient, amountReceived, destinationCurrencyKey);\n            dest.issue(address(vSynth), amountReceived);\n        } else {\n            dest.issue(recipient, amountReceived);\n        }\n    }\n\n    function _createVirtualSynth(\n        IERC20,\n        address,\n        uint,\n        bytes32\n    ) internal returns (IVirtualSynth) {\n        revert(\"Cannot be run on this layer\");\n    }\n\n    // Note: this function can intentionally be called by anyone on behalf of anyone else (the caller just pays the gas)\n    function settle(address from, bytes32 currencyKey)\n        external\n        returns (\n            uint reclaimed,\n            uint refunded,\n            uint numEntriesSettled\n        )\n    {\n        systemStatus().requireSynthActive(currencyKey);\n        return _internalSettle(from, currencyKey, true);\n    }\n\n    function suspendSynthWithInvalidRate(bytes32 currencyKey) external {\n        systemStatus().requireSystemActive();\n        require(issuer().synths(currencyKey) != ISynth(0), \"No such synth\");\n        require(_isSynthRateInvalid(currencyKey, exchangeRates().rateForCurrency(currencyKey)), \"Synth price is valid\");\n        systemStatus().suspendSynth(currencyKey, CIRCUIT_BREAKER_SUSPENSION_REASON);\n    }\n\n    // SIP-78\n    function setLastExchangeRateForSynth(bytes32 currencyKey, uint rate) external onlyExchangeRates {\n        require(rate > 0, \"Rate must be above 0\");\n        lastExchangeRate[currencyKey] = rate;\n    }\n\n    // SIP-139\n    function resetLastExchangeRate(bytes32[] calldata currencyKeys) external onlyOwner {\n        (uint[] memory rates, bool anyRateInvalid) = exchangeRates().ratesAndInvalidForCurrencies(currencyKeys);\n\n        require(!anyRateInvalid, \"Rates for given synths not valid\");\n\n        for (uint i = 0; i < currencyKeys.length; i++) {\n            lastExchangeRate[currencyKeys[i]] = rates[i];\n        }\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function _ensureCanExchange(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) internal view {\n        require(sourceCurrencyKey != destinationCurrencyKey, \"Can't be same synth\");\n        require(sourceAmount > 0, \"Zero amount\");\n\n        bytes32[] memory synthKeys = new bytes32[](2);\n        synthKeys[0] = sourceCurrencyKey;\n        synthKeys[1] = destinationCurrencyKey;\n        require(!exchangeRates().anyRateIsInvalid(synthKeys), \"Src/dest rate invalid or not found\");\n    }\n\n    function _isSynthRateInvalid(bytes32 currencyKey, uint currentRate) internal view returns (bool) {\n        if (currentRate == 0) {\n            return true;\n        }\n\n        uint lastRateFromExchange = lastExchangeRate[currencyKey];\n\n        if (lastRateFromExchange > 0) {\n            return _isDeviationAboveThreshold(lastRateFromExchange, currentRate);\n        }\n\n        // if no last exchange for this synth, then we need to look up last 3 rates (+1 for current rate)\n        (uint[] memory rates, ) = exchangeRates().ratesAndUpdatedTimeForCurrencyLastNRounds(currencyKey, 4);\n\n        // start at index 1 to ignore current rate\n        for (uint i = 1; i < rates.length; i++) {\n            // ignore any empty rates in the past (otherwise we will never be able to get validity)\n            if (rates[i] > 0 && _isDeviationAboveThreshold(rates[i], currentRate)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    function _isDeviationAboveThreshold(uint base, uint comparison) internal view returns (bool) {\n        if (base == 0 || comparison == 0) {\n            return true;\n        }\n\n        uint factor;\n        if (comparison > base) {\n            factor = comparison.divideDecimal(base);\n        } else {\n            factor = base.divideDecimal(comparison);\n        }\n\n        return factor >= getPriceDeviationThresholdFactor();\n    }\n\n    function _internalSettle(\n        address from,\n        bytes32 currencyKey,\n        bool updateCache\n    )\n        internal\n        returns (\n            uint reclaimed,\n            uint refunded,\n            uint numEntriesSettled\n        )\n    {\n        require(maxSecsLeftInWaitingPeriod(from, currencyKey) == 0, \"Cannot settle during waiting period\");\n\n        (uint reclaimAmount, uint rebateAmount, uint entries, ExchangeEntrySettlement[] memory settlements) =\n            _settlementOwing(from, currencyKey);\n\n        if (reclaimAmount > rebateAmount) {\n            reclaimed = reclaimAmount.sub(rebateAmount);\n            reclaim(from, currencyKey, reclaimed);\n        } else if (rebateAmount > reclaimAmount) {\n            refunded = rebateAmount.sub(reclaimAmount);\n            refund(from, currencyKey, refunded);\n        }\n\n        // by checking a reclaim or refund we also check that the currency key is still a valid synth,\n        // as the deviation check will return 0 if the synth has been removed.\n        if (updateCache && (reclaimed > 0 || refunded > 0)) {\n            bytes32[] memory key = new bytes32[](1);\n            key[0] = currencyKey;\n            debtCache().updateCachedSynthDebts(key);\n        }\n\n        // emit settlement event for each settled exchange entry\n        for (uint i = 0; i < settlements.length; i++) {\n            emit ExchangeEntrySettled(\n                from,\n                settlements[i].src,\n                settlements[i].amount,\n                settlements[i].dest,\n                settlements[i].reclaim,\n                settlements[i].rebate,\n                settlements[i].srcRoundIdAtPeriodEnd,\n                settlements[i].destRoundIdAtPeriodEnd,\n                settlements[i].timestamp\n            );\n        }\n\n        numEntriesSettled = entries;\n\n        // Now remove all entries, even if no reclaim and no rebate\n        exchangeState().removeEntries(from, currencyKey);\n    }\n\n    function reclaim(\n        address from,\n        bytes32 currencyKey,\n        uint amount\n    ) internal {\n        // burn amount from user\n        issuer().synths(currencyKey).burn(from, amount);\n        ISynthetixInternal(address(synthetix())).emitExchangeReclaim(from, currencyKey, amount);\n    }\n\n    function refund(\n        address from,\n        bytes32 currencyKey,\n        uint amount\n    ) internal {\n        // issue amount to user\n        issuer().synths(currencyKey).issue(from, amount);\n        ISynthetixInternal(address(synthetix())).emitExchangeRebate(from, currencyKey, amount);\n    }\n\n    function secsLeftInWaitingPeriodForExchange(uint timestamp) internal view returns (uint) {\n        uint _waitingPeriodSecs = getWaitingPeriodSecs();\n        if (timestamp == 0 || now >= timestamp.add(_waitingPeriodSecs)) {\n            return 0;\n        }\n\n        return timestamp.add(_waitingPeriodSecs).sub(now);\n    }\n\n    function feeRateForExchange(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey)\n        external\n        view\n        returns (uint exchangeFeeRate)\n    {\n        exchangeFeeRate = _feeRateForExchange(sourceCurrencyKey, destinationCurrencyKey);\n    }\n\n    function _feeRateForExchange(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey)\n        internal\n        view\n        returns (uint exchangeFeeRate)\n    {\n        // Get the exchange fee rate as per destination currencyKey\n        exchangeFeeRate = getExchangeFeeRate(destinationCurrencyKey);\n\n        if (sourceCurrencyKey == zUSD || destinationCurrencyKey == zUSD) {\n            return exchangeFeeRate;\n        }\n\n        // Is this a swing trade? long to short or short to long skipping zUSD.\n        if (\n            (sourceCurrencyKey[0] == 0x7a && destinationCurrencyKey[0] == 0x69) ||\n            (sourceCurrencyKey[0] == 0x69 && destinationCurrencyKey[0] == 0x7a)\n        ) {\n            // Double the exchange fee\n            exchangeFeeRate = exchangeFeeRate.mul(2);\n        }\n\n        return exchangeFeeRate;\n    }\n\n    function getAmountsForExchange(\n        uint sourceAmount,\n        bytes32 sourceCurrencyKey,\n        bytes32 destinationCurrencyKey\n    )\n        external\n        view\n        returns (\n            uint amountReceived,\n            uint fee,\n            uint exchangeFeeRate\n        )\n    {\n        (amountReceived, fee, exchangeFeeRate, , ) = _getAmountsForExchangeMinusFees(\n            sourceAmount,\n            sourceCurrencyKey,\n            destinationCurrencyKey\n        );\n    }\n\n    function _getAmountsForExchangeMinusFees(\n        uint sourceAmount,\n        bytes32 sourceCurrencyKey,\n        bytes32 destinationCurrencyKey\n    )\n        internal\n        view\n        returns (\n            uint amountReceived,\n            uint fee,\n            uint exchangeFeeRate,\n            uint sourceRate,\n            uint destinationRate\n        )\n    {\n        uint destinationAmount;\n        (destinationAmount, sourceRate, destinationRate) = exchangeRates().effectiveValueAndRates(\n            sourceCurrencyKey,\n            sourceAmount,\n            destinationCurrencyKey\n        );\n        exchangeFeeRate = _feeRateForExchange(sourceCurrencyKey, destinationCurrencyKey);\n        amountReceived = _getAmountReceivedForExchange(destinationAmount, exchangeFeeRate);\n        fee = destinationAmount.sub(amountReceived);\n    }\n\n    function _getAmountReceivedForExchange(uint destinationAmount, uint exchangeFeeRate)\n        internal\n        pure\n        returns (uint amountReceived)\n    {\n        amountReceived = destinationAmount.multiplyDecimal(SafeDecimalMath.unit().sub(exchangeFeeRate));\n    }\n\n    function appendExchange(\n        address account,\n        bytes32 src,\n        uint amount,\n        bytes32 dest,\n        uint amountReceived,\n        uint exchangeFeeRate\n    ) internal {\n        IExchangeRates exRates = exchangeRates();\n        uint roundIdForSrc = exRates.getCurrentRoundId(src);\n        uint roundIdForDest = exRates.getCurrentRoundId(dest);\n        exchangeState().appendExchangeEntry(\n            account,\n            src,\n            amount,\n            dest,\n            amountReceived,\n            exchangeFeeRate,\n            now,\n            roundIdForSrc,\n            roundIdForDest\n        );\n\n        emit ExchangeEntryAppended(\n            account,\n            src,\n            amount,\n            dest,\n            amountReceived,\n            exchangeFeeRate,\n            roundIdForSrc,\n            roundIdForDest\n        );\n    }\n\n    function getRoundIdsAtPeriodEnd(IExchangeState.ExchangeEntry memory exchangeEntry)\n        internal\n        view\n        returns (uint srcRoundIdAtPeriodEnd, uint destRoundIdAtPeriodEnd)\n    {\n        IExchangeRates exRates = exchangeRates();\n        uint _waitingPeriodSecs = getWaitingPeriodSecs();\n\n        srcRoundIdAtPeriodEnd = exRates.getLastRoundIdBeforeElapsedSecs(\n            exchangeEntry.src,\n            exchangeEntry.roundIdForSrc,\n            exchangeEntry.timestamp,\n            _waitingPeriodSecs\n        );\n        destRoundIdAtPeriodEnd = exRates.getLastRoundIdBeforeElapsedSecs(\n            exchangeEntry.dest,\n            exchangeEntry.roundIdForDest,\n            exchangeEntry.timestamp,\n            _waitingPeriodSecs\n        );\n    }\n\n    // ========== MODIFIERS ==========\n\n    modifier onlySynthetixorSynth() {\n        ISynthetix _synthetix = synthetix();\n        require(\n            msg.sender == address(_synthetix) || _synthetix.synthsByAddress(msg.sender) != bytes32(0),\n            \"Exchanger: Only synthetix or a synth contract can perform this action\"\n        );\n        _;\n    }\n\n    modifier onlyExchangeRates() {\n        IExchangeRates _exchangeRates = exchangeRates();\n        require(msg.sender == address(_exchangeRates), \"Restricted to ExchangeRates\");\n        _;\n    }\n\n    // ========== EVENTS ==========\n    event ExchangeEntryAppended(\n        address indexed account,\n        bytes32 src,\n        uint256 amount,\n        bytes32 dest,\n        uint256 amountReceived,\n        uint256 exchangeFeeRate,\n        uint256 roundIdForSrc,\n        uint256 roundIdForDest\n    );\n\n    event ExchangeEntrySettled(\n        address indexed from,\n        bytes32 src,\n        uint256 amount,\n        bytes32 dest,\n        uint256 reclaim,\n        uint256 rebate,\n        uint256 srcRoundIdAtPeriodEnd,\n        uint256 destRoundIdAtPeriodEnd,\n        uint256 exchangeTimestamp\n    );\n}\n\n\n// https://docs.synthetix.io/contracts/source/contracts/minimalproxyfactory\ncontract MinimalProxyFactory {\n    function _cloneAsMinimalProxy(address _base, string memory _revertMsg) internal returns (address clone) {\n        bytes memory createData = _generateMinimalProxyCreateData(_base);\n\n        assembly {\n            clone := create(\n                0, // no value\n                add(createData, 0x20), // data\n                55 // data is always 55 bytes (10 constructor + 45 code)\n            )\n        }\n\n        // If CREATE fails for some reason, address(0) is returned\n        require(clone != address(0), _revertMsg);\n    }\n\n    function _generateMinimalProxyCreateData(address _base) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                //---- constructor -----\n                bytes10(0x3d602d80600a3d3981f3),\n                //---- proxy code -----\n                bytes10(0x363d3d373d3d3d363d73),\n                _base,\n                bytes15(0x5af43d82803e903d91602b57fd5bf3)\n            );\n    }\n}\n\n\n// Inheritance\n\n\n// Internal references\n\n\ninterface IVirtualSynthInternal {\n    function initialize(\n        IERC20 _synth,\n        IAddressResolver _resolver,\n        address _recipient,\n        uint _amount,\n        bytes32 _currencyKey\n    ) external;\n}\n\n// https://docs.synthetix.io/contracts/source/contracts/exchangerwithvirtualsynth\ncontract ExchangerWithVirtualSynth is MinimalProxyFactory, Exchanger {\n    bytes32 public constant CONTRACT_NAME = \"ExchangerWithVirtualSynth\";\n\n    constructor(address _owner, address _resolver) public MinimalProxyFactory() Exchanger(_owner, _resolver) {}\n\n    /* ========== ADDRESS RESOLVER CONFIGURATION ========== */\n\n    bytes32 private constant CONTRACT_VIRTUALSYNTH_MASTERCOPY = \"VirtualSynthMastercopy\";\n\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {\n        bytes32[] memory existingAddresses = Exchanger.resolverAddressesRequired();\n        bytes32[] memory newAddresses = new bytes32[](1);\n        newAddresses[0] = CONTRACT_VIRTUALSYNTH_MASTERCOPY;\n        addresses = combineArrays(existingAddresses, newAddresses);\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function _virtualSynthMastercopy() internal view returns (address) {\n        return requireAndGetAddress(CONTRACT_VIRTUALSYNTH_MASTERCOPY);\n    }\n\n    function _createVirtualSynth(\n        IERC20 synth,\n        address recipient,\n        uint amount,\n        bytes32 currencyKey\n    ) internal returns (IVirtualSynth) {\n        // prevent inverse synths from being allowed due to purgeability\n        require(currencyKey[0] != 0x69, \"Cannot virtualize this synth\");\n\n        IVirtualSynthInternal vSynth =\n            IVirtualSynthInternal(_cloneAsMinimalProxy(_virtualSynthMastercopy(), \"Could not create new vSynth\"));\n        vSynth.initialize(synth, resolver, recipient, amount, currencyKey);\n        emit VirtualSynthCreated(address(synth), recipient, address(vSynth), currencyKey, amount);\n\n        return IVirtualSynth(address(vSynth));\n    }\n\n    event VirtualSynthCreated(\n        address indexed synth,\n        address indexed recipient,\n        address vSynth,\n        bytes32 currencyKey,\n        uint amount\n    );\n}\n\n    ", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_resolver\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"CacheUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"src\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"dest\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"exchangeFeeRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"roundIdForSrc\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"roundIdForDest\",\"type\":\"uint256\"}],\"name\":\"ExchangeEntryAppended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"src\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"dest\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reclaim\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rebate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"srcRoundIdAtPeriodEnd\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"destRoundIdAtPeriodEnd\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"exchangeTimestamp\",\"type\":\"uint256\"}],\"name\":\"ExchangeEntrySettled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"synth\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vSynth\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"VirtualSynthCreated\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"CIRCUIT_BREAKER_SUSPENSION_REASON\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_NAME\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refunded\",\"type\":\"uint256\"}],\"name\":\"calculateAmountAfterSettlement\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountAfterSettlement\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"exchangeForAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"sourceCurrencyKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"sourceAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"destinationCurrencyKey\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"destinationAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"virtualSynth\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"rewardAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"trackingCode\",\"type\":\"bytes32\"}],\"name\":\"exchange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountReceived\",\"type\":\"uint256\"},{\"internalType\":\"contract IVirtualSynth\",\"name\":\"vSynth\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sourceCurrencyKey\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"destinationCurrencyKey\",\"type\":\"bytes32\"}],\"name\":\"feeRateForExchange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"exchangeFeeRate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sourceAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"sourceCurrencyKey\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"destinationCurrencyKey\",\"type\":\"bytes32\"}],\"name\":\"getAmountsForExchange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountReceived\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"exchangeFeeRate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"}],\"name\":\"hasWaitingPeriodOrSettlementOwing\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isResolverCached\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"}],\"name\":\"isSynthRateInvalid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"lastExchangeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"}],\"name\":\"maxSecsLeftInWaitingPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceDeviationThresholdFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"rebuildCache\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"currencyKeys\",\"type\":\"bytes32[]\"}],\"name\":\"resetLastExchangeRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"resolver\",\"outputs\":[{\"internalType\":\"contract AddressResolver\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"resolverAddressesRequired\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"addresses\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"setLastExchangeRateForSynth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"}],\"name\":\"settle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reclaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refunded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numEntriesSettled\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"}],\"name\":\"settlementOwing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reclaimAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rebateAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numEntries\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"currencyKey\",\"type\":\"bytes32\"}],\"name\":\"suspendSynthWithInvalidRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tradingRewardsEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"waitingPeriodSecs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ExchangerWithVirtualSynth", "CompilerVersion": "v0.5.16+commit.9c3226ce", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000003a10a18ca6d9378010d446068d2fd4de5d272915000000000000000000000000263a8220e9351c5d0cc13567db4d7bf58e7470c6", "EVMVersion": "Default", "Library": "SafeDecimalMath:bd782d595df5fb4baf6eb5fca4d1ff2adc9cf856", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}