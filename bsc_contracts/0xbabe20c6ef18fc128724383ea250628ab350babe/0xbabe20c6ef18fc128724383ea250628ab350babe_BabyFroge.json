{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/BabyFroge.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\\nabstract contract Context {\\n    function _msgSender() internal view returns (address payable) {\\n        return payable(msg.sender);\\n    }\\n\\n    function _msgData() internal view returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\\ncontract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor(address owner_) {\\n        _owner = owner_;\\n        emit OwnershipTransferred(address(0), owner_);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(\\n            newOwner != address(0),\\n            \\\"Ownable: new owner is the zero address\\\"\\n        );\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\\nlibrary SafeMath {\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n}\\n\\ncontract BabyFroge is IERC20, Ownable {\\n    using SafeMath for uint256;\\n\\n    string private constant _name = \\\"BabyFroge\\\";\\n    string private constant _symbol = \\\"BABYFROGE\\\";\\n    uint256 private constant _totalSupply = 420_000_069 ether;\\n    uint8 private constant _decimals = 18;\\n\\n    uint256 public constant feeTeam = 1;\\n    uint256 public constant feeMarketing = 2;\\n    uint256 public constant feeLp = 1;\\n    uint256 public constant feeBurn = 1;\\n    uint256 public constant feeTotal = feeTeam + feeMarketing + feeLp + feeBurn;\\n\\n    IPancakeRouter public constant router =\\n        IPancakeRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\\n    address public immutable pair;\\n\\n    mapping(address => uint256) private _balances;\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n    mapping(address => bool) public isFeeExempt;\\n\\n    address public marketingFeeReceiver =\\n        0x173628795ad1954a11f5870dD2882A0C8dE485A2;\\n    address public teamFeeReceiver = 0xE7E431fb662Fc5C8062B8808fd2f0f40209472d4;\\n    address public feeExemptSetter = teamFeeReceiver;\\n\\n    uint256 public smallSwapThreshold = (_totalSupply * 2) / 10000;\\n    uint256 public largeSwapThreshold = (_totalSupply * 3) / 10000;\\n    uint256 public swapThreshold = smallSwapThreshold;\\n    bool public claimingFees = true;\\n    bool public alternateSwaps = true;\\n    bool private inSwap;\\n\\n    modifier swapping() {\\n        inSwap = true;\\n        _;\\n        inSwap = false;\\n    }\\n\\n    modifier onlyFeeExemptSetter() {\\n        require(msg.sender == feeExemptSetter, \\\"Not fee exempt setter\\\");\\n        _;\\n    }\\n\\n    constructor(address _owner) Ownable(_owner) {\\n        pair = IPancakeFactory(router.factory()).createPair(\\n            address(this),\\n            router.WETH()\\n        );\\n        _allowances[address(this)][address(router)] = type(uint256).max;\\n\\n        isFeeExempt[teamFeeReceiver] = true;\\n        isFeeExempt[marketingFeeReceiver] = true;\\n        isFeeExempt[address(0xdead)] = true;\\n        isFeeExempt[address(this)] = true;\\n        isFeeExempt[_owner] = true;\\n\\n        _balances[_owner] = _totalSupply;\\n        emit Transfer(address(0), _owner, _totalSupply);\\n    }\\n\\n    receive() external payable {}\\n\\n    function totalSupply() external pure override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function decimals() external pure returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function name() external pure returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() external pure returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function allowance(\\n        address holder,\\n        address spender\\n    ) external view override returns (uint256) {\\n        return _allowances[holder][spender];\\n    }\\n\\n    function approve(\\n        address spender,\\n        uint256 amount\\n    ) public override returns (bool) {\\n        _allowances[msg.sender][spender] = amount;\\n        emit Approval(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) external override returns (bool) {\\n        return _transferFrom(msg.sender, recipient, amount);\\n    }\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external override returns (bool) {\\n        if (_allowances[sender][msg.sender] != type(uint256).max) {\\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender]\\n                .sub(amount, \\\"Insufficient Allowance\\\");\\n        }\\n\\n        return _transferFrom(sender, recipient, amount);\\n    }\\n\\n    function _transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal returns (bool) {\\n        if (inSwap) {\\n            return _basicTransfer(sender, recipient, amount);\\n        }\\n\\n        if (shouldSwapBack()) {\\n            swapBack();\\n        }\\n\\n        _balances[sender] = _balances[sender].sub(\\n            amount,\\n            \\\"Insufficient Balance\\\"\\n        );\\n        uint256 received = shouldTakeFee(msg.sender, sender, recipient)\\n            ? amount - takeFee(sender, amount)\\n            : amount;\\n        _balances[recipient] += received;\\n\\n        emit Transfer(sender, recipient, received);\\n        return true;\\n    }\\n\\n    function _basicTransfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal returns (bool) {\\n        _balances[sender] = _balances[sender].sub(\\n            amount,\\n            \\\"Insufficient Balance\\\"\\n        );\\n        _balances[recipient] += amount;\\n        emit Transfer(sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function shouldTakeFee(\\n        address operator,\\n        address sender,\\n        address recipient\\n    ) internal view returns (bool) {\\n        return\\n            !isFeeExempt[operator] &&\\n            !isFeeExempt[sender] &&\\n            !isFeeExempt[recipient];\\n    }\\n\\n    function takeFee(\\n        address sender,\\n        uint256 amount\\n    ) internal returns (uint256 fees) {\\n        fees = (amount * feeTotal) / 100;\\n        _balances[address(this)] += fees;\\n        emit Transfer(sender, address(this), fees);\\n    }\\n\\n    function clearStuckBalance() external {\\n        require(msg.sender == teamFeeReceiver, \\\"Unauthorized\\\");\\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\\\"\\\");\\n        require(success);\\n    }\\n\\n    function clearForeignToken(\\n        address tokenAddress,\\n        uint256 tokens\\n    ) external returns (bool) {\\n        require(msg.sender == teamFeeReceiver, \\\"Unauthorized\\\");\\n        require(tokenAddress != address(this), \\\"Not allowed\\\");\\n        if (tokens == 0) {\\n            tokens = IERC20(tokenAddress).balanceOf(address(this));\\n        }\\n        return IERC20(tokenAddress).transfer(msg.sender, tokens);\\n    }\\n\\n    function shouldSwapBack() internal view returns (bool) {\\n        return\\n            msg.sender != pair &&\\n            !inSwap &&\\n            claimingFees &&\\n            _balances[address(this)] >= swapThreshold;\\n    }\\n\\n    function setSwapBackSettings(\\n        bool _enabled,\\n        uint256 _amountS,\\n        uint256 _amountL,\\n        bool _alternate\\n    ) external onlyFeeExemptSetter {\\n        require(_amountS > _totalSupply / 100000, \\\"Invalid threshold\\\");\\n        require(_amountL > _totalSupply / 100000, \\\"Invalid threshold\\\");\\n        require(_amountS < _totalSupply / 100, \\\"Invalid threshold\\\");\\n        require(_amountL < _totalSupply / 100, \\\"Invalid threshold\\\");\\n        require(_amountL >= _amountS, \\\"Invalid threshold\\\");\\n\\n        alternateSwaps = _alternate;\\n        claimingFees = _enabled;\\n        smallSwapThreshold = _amountS;\\n        largeSwapThreshold = _amountL;\\n        swapThreshold = smallSwapThreshold;\\n    }\\n\\n    function setIsFeeExempt(\\n        address holder,\\n        bool exempt\\n    ) external onlyFeeExemptSetter {\\n        isFeeExempt[holder] = exempt;\\n    }\\n\\n    function transferFeeExemptSetter(\\n        address _feeExemptSetter\\n    ) external onlyFeeExemptSetter {\\n        feeExemptSetter = _feeExemptSetter;\\n    }\\n\\n    function renounceFeeExemptSetter() external onlyFeeExemptSetter {\\n        feeExemptSetter = address(0);\\n    }\\n\\n    function setFeeReceivers(\\n        address _marketingFeeReceiver,\\n        address _teamFeeReceiver\\n    ) external {\\n        require(msg.sender == teamFeeReceiver, \\\"Unauthorized\\\");\\n        require(_teamFeeReceiver != address(0), \\\"Invalid receiver\\\");\\n        require(_marketingFeeReceiver != address(0), \\\"Invalid receiver\\\");\\n        marketingFeeReceiver = _marketingFeeReceiver;\\n        teamFeeReceiver = _teamFeeReceiver;\\n    }\\n\\n    function swapBack() internal swapping {\\n        // 1. burn\\n        _basicTransfer(\\n            address(this),\\n            address(0xdead),\\n            (swapThreshold * feeBurn) / 100\\n        );\\n\\n        // 2. swap\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = router.WETH();\\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            (swapThreshold * (feeMarketing + feeTeam + feeLp / 2)) / 100,\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n        uint256 amountBNB = address(this).balance;\\n\\n        // 3. add LP\\n        (, uint256 valueAddedToLiquidity, ) = router.addLiquidityETH{\\n            value: (amountBNB * feeLp) /\\n                2 /\\n                (feeMarketing + feeTeam + feeLp / 2)\\n        }(\\n            address(this),\\n            (swapThreshold * feeLp) / 2 / 100,\\n            0,\\n            0,\\n            address(0xdead), // burn\\n            block.timestamp\\n        );\\n\\n        // 4. distribute bnb\\n        uint256 valueMarketing = ((amountBNB - valueAddedToLiquidity) *\\n            feeMarketing) / (feeTeam + feeMarketing);\\n        marketingFeeReceiver.call{value: valueMarketing}(\\\"\\\");\\n        teamFeeReceiver.call{\\n            value: (amountBNB - valueAddedToLiquidity - valueMarketing)\\n        }(\\\"\\\");\\n\\n        swapThreshold = !alternateSwaps\\n            ? swapThreshold\\n            : swapThreshold == smallSwapThreshold\\n            ? largeSwapThreshold\\n            : smallSwapThreshold;\\n    }\\n}\\n\\ninterface IPancakeFactory {\\n    function createPair(\\n        address tokenA,\\n        address tokenB\\n    ) external returns (address pair);\\n}\\n\\ninterface IPancakePair {\\n    function sync() external;\\n}\\n\\ninterface IPancakeRouter {\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    )\\n        external\\n        payable\\n        returns (uint amountToken, uint amountETH, uint liquidity);\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 42069\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"alternateSwaps\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimingFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"clearForeignToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clearStuckBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeExemptSetter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeLp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeMarketing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeTeam\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isFeeExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"largeSwapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingFeeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceFeeExemptSetter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IPancakeRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_marketingFeeReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_teamFeeReceiver\",\"type\":\"address\"}],\"name\":\"setFeeReceivers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsFeeExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_amountS\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountL\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_alternate\",\"type\":\"bool\"}],\"name\":\"setSwapBackSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"smallSwapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"teamFeeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeExemptSetter\",\"type\":\"address\"}],\"name\":\"transferFeeExemptSetter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "BabyFroge", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "42069", "ConstructorArguments": "00000000000000000000000022ed46fa0ca18962495890441a50baf38600ec7d", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}