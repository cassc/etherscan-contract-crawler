{"SourceCode": "{\"Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nlibrary Address {\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size \\u003e 0;\\n    }\\n\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(\\n            address(this).balance \\u003e= amount,\\n            \\\"Address: insufficient balance\\\"\\n        );\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(\\n            success,\\n            \\\"Address: unable to send value, recipient may have reverted\\\"\\n        );\\n    }\\n\\n    function functionCall(address target, bytes memory data)\\n        internal\\n        returns (bytes memory)\\n    {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCallWithValue(\\n                target,\\n                data,\\n                value,\\n                \\\"Address: low-level call with value failed\\\"\\n            );\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(\\n            address(this).balance \\u003e= value,\\n            \\\"Address: insufficient balance for call\\\"\\n        );\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n        (bool success, bytes memory returndata) =\\n            target.call{value: value}(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function functionStaticCall(address target, bytes memory data)\\n        internal\\n        view\\n        returns (bytes memory)\\n    {\\n        return\\n            functionStaticCall(\\n                target,\\n                data,\\n                \\\"Address: low-level static call failed\\\"\\n            );\\n    }\\n\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function functionDelegateCall(address target, bytes memory data)\\n        internal\\n        returns (bytes memory)\\n    {\\n        return\\n            functionDelegateCall(\\n                target,\\n                data,\\n                \\\"Address: low-level delegate call failed\\\"\\n            );\\n    }\\n\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) private pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            if (returndata.length \\u003e 0) {\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"},\"Antiwhale.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"./Tokenomics.sol\\\";\\n\\nabstract contract Antiwhale is Tokenomics {\\n    /**\\n     * @dev Returns the total sum of fees (in percents / per-mille - this depends on the FEES_DIVISOR value)\\n     */\\n    function _getAntiwhaleFees(uint256, uint256)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return sumOfFees;\\n    }\\n}\\n\"},\"BaseRfiToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"./Presaleable.sol\\\";\\nimport \\\"./Tokenomics.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./IERC20Metadata.sol\\\";\\nimport \\\"./IPancakeV2Factory.sol\\\";\\nimport \\\"./IPancakeV2Router.sol\\\";\\nimport \\\"./Address.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\n\\nabstract contract BaseRfiToken is\\n    IERC20,\\n    IERC20Metadata,\\n    Ownable,\\n    Presaleable,\\n    Tokenomics\\n{\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    mapping(address =\\u003e uint256) internal _reflectedBalances;\\n    mapping(address =\\u003e uint256) internal _balances;\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) internal _allowances;\\n\\n    mapping(address =\\u003e bool) internal _isExcludedFromFee;\\n    mapping(address =\\u003e bool) internal _isExcludedFromRewards;\\n    address[] private _excluded;\\n\\n    constructor() {\\n        _reflectedBalances[owner()] = _reflectedSupply;\\n\\n        // exclude owner and this contract from fee\\n        _isExcludedFromFee[owner()] = true;\\n        _isExcludedFromFee[address(this)] = true;\\n\\n        // exclude the owner and this contract from rewards\\n        _exclude(owner());\\n        _exclude(address(this));\\n\\n        emit Transfer(address(0), owner(), TOTAL_SUPPLY);\\n    }\\n\\n    /** Functions required by IERC20Metadat **/\\n    function name() external pure override returns (string memory) {\\n        return NAME;\\n    }\\n\\n    function symbol() external pure override returns (string memory) {\\n        return SYMBOL;\\n    }\\n\\n    function decimals() external pure override returns (uint8) {\\n        return DECIMALS;\\n    }\\n\\n    /** Functions required by IERC20 **/\\n    function totalSupply() external pure override returns (uint256) {\\n        return TOTAL_SUPPLY;\\n    }\\n\\n    function balanceOf(address account) public view override returns (uint256) {\\n        if (_isExcludedFromRewards[account]) return _balances[account];\\n        return tokenFromReflection(_reflectedBalances[account]);\\n    }\\n\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        override\\n        returns (bool)\\n    {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(address spender, uint256 amount)\\n        external\\n        override\\n        returns (bool)\\n    {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(\\n            sender,\\n            _msgSender(),\\n            _allowances[sender][_msgSender()].sub(\\n                amount,\\n                \\\"ERC20: transfer amount exceeds allowance\\\"\\n            )\\n        );\\n        return true;\\n    }\\n\\n    function burn(uint256 amount) external {\\n        address sender = _msgSender();\\n        require(\\n            sender != address(0),\\n            \\\"BaseRfiToken: burn from the zero address\\\"\\n        );\\n        require(\\n            sender != address(burnAddress),\\n            \\\"BaseRfiToken: burn from the burn address\\\"\\n        );\\n\\n        uint256 balance = balanceOf(sender);\\n        require(balance \\u003e= amount, \\\"BaseRfiToken: burn amount exceeds balance\\\");\\n\\n        uint256 reflectedAmount = amount.mul(_getCurrentRate());\\n\\n        // remove the amount from the sender\\u0027s balance first\\n        _reflectedBalances[sender] = _reflectedBalances[sender].sub(\\n            reflectedAmount\\n        );\\n        if (_isExcludedFromRewards[sender])\\n            _balances[sender] = _balances[sender].sub(amount);\\n\\n        _burnTokens(sender, amount, reflectedAmount);\\n    }\\n\\n    function _burnTokens(\\n        address sender,\\n        uint256 tBurn,\\n        uint256 rBurn\\n    ) internal {\\n        _reflectedBalances[burnAddress] = _reflectedBalances[burnAddress].add(\\n            rBurn\\n        );\\n        if (_isExcludedFromRewards[burnAddress])\\n            _balances[burnAddress] = _balances[burnAddress].add(tBurn);\\n\\n        /**\\n         * @dev Emit the event so that the burn address balance is updated (on bscscan)\\n         */\\n        emit Transfer(sender, burnAddress, tBurn);\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue)\\n        public\\n        virtual\\n        returns (bool)\\n    {\\n        _approve(\\n            _msgSender(),\\n            spender,\\n            _allowances[_msgSender()][spender].add(addedValue)\\n        );\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue)\\n        public\\n        virtual\\n        returns (bool)\\n    {\\n        _approve(\\n            _msgSender(),\\n            spender,\\n            _allowances[_msgSender()][spender].sub(\\n                subtractedValue,\\n                \\\"ERC20: decreased allowance below zero\\\"\\n            )\\n        );\\n        return true;\\n    }\\n\\n    function isExcludedFromReward(address account)\\n        external\\n        view\\n        returns (bool)\\n    {\\n        return _isExcludedFromRewards[account];\\n    }\\n\\n    /**\\n     * @dev Calculates and returns the reflected amount for the given amount with or without\\n     * the transfer fees (deductTransferFee true/false)\\n     */\\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        require(tAmount \\u003c= TOTAL_SUPPLY, \\\"Amount must be less than supply\\\");\\n        if (!deductTransferFee) {\\n            (uint256 rAmount, , , , ) = _getValues(tAmount, 0);\\n            return rAmount;\\n        } else {\\n            (, uint256 rTransferAmount, , , ) =\\n                _getValues(tAmount, _getSumOfFees(_msgSender(), tAmount));\\n            return rTransferAmount;\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates and returns the amount of tokens corresponding to the given reflected amount.\\n     */\\n    function tokenFromReflection(uint256 rAmount)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        require(\\n            rAmount \\u003c= _reflectedSupply,\\n            \\\"Amount must be less than total reflections\\\"\\n        );\\n        uint256 currentRate = _getCurrentRate();\\n        return rAmount.div(currentRate);\\n    }\\n\\n    function excludeFromReward(address account) external onlyOwner() {\\n        require(!_isExcludedFromRewards[account], \\\"Account is not included\\\");\\n        _exclude(account);\\n    }\\n\\n    function _exclude(address account) internal {\\n        if (_reflectedBalances[account] \\u003e 0) {\\n            _balances[account] = tokenFromReflection(\\n                _reflectedBalances[account]\\n            );\\n        }\\n        _isExcludedFromRewards[account] = true;\\n        _excluded.push(account);\\n    }\\n\\n    function includeInReward(address account) external onlyOwner() {\\n        require(_isExcludedFromRewards[account], \\\"Account is not excluded\\\");\\n        for (uint256 i = 0; i \\u003c _excluded.length; i++) {\\n            if (_excluded[i] == account) {\\n                _excluded[i] = _excluded[_excluded.length - 1];\\n                _balances[account] = 0;\\n                _isExcludedFromRewards[account] = false;\\n                _excluded.pop();\\n                break;\\n            }\\n        }\\n    }\\n\\n    function setExcludedFromFee(address account, bool value)\\n        external\\n        onlyOwner\\n    {\\n        _isExcludedFromFee[account] = value;\\n    }\\n\\n    function isExcludedFromFee(address account) public view returns (bool) {\\n        return _isExcludedFromFee[account];\\n    }\\n\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal {\\n        require(\\n            owner != address(0),\\n            \\\"BaseRfiToken: approve from the zero address\\\"\\n        );\\n        require(\\n            spender != address(0),\\n            \\\"BaseRfiToken: approve to the zero address\\\"\\n        );\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    function _isUnlimitedSender(address account) internal view returns (bool) {\\n        // the owner should be the only whitelisted sender\\n        return (account == owner());\\n    }\\n\\n    function _isUnlimitedRecipient(address account)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        // the owner should be a white-listed recipient\\n        // and anyone should be able to burn tokens\\n        return (account == owner() || account == burnAddress);\\n    }\\n\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) private {\\n        require(\\n            sender != address(0),\\n            \\\"BaseRfiToken: transfer from the zero address\\\"\\n        );\\n        require(\\n            recipient != address(0),\\n            \\\"BaseRfiToken: transfer to the zero address\\\"\\n        );\\n        require(\\n            sender != address(burnAddress),\\n            \\\"BaseRfiToken: transfer from the burn address\\\"\\n        );\\n        require(amount \\u003e 0, \\\"Transfer amount must be greater than zero\\\");\\n\\n        // indicates whether or not feee should be deducted from the transfer\\n        bool takeFee = true;\\n\\n        if (isInPresale) {\\n            takeFee = false;\\n        } else {\\n            /**\\n             * Check the amount is within the max allowed limit as long as a\\n             * unlimited sender/recepient is not involved in the transaction\\n             */\\n            if (\\n                amount \\u003e maxTransactionAmount \\u0026\\u0026\\n                !_isUnlimitedSender(sender) \\u0026\\u0026\\n                !_isUnlimitedRecipient(recipient)\\n            ) {\\n                revert(\\\"Transfer amount exceeds the maxTxAmount.\\\");\\n            }\\n            /**\\n             * The pair needs to excluded from the max wallet balance check;\\n             * selling tokens is sending them back to the pair (without this\\n             * check, selling tokens would not work if the pair\\u0027s balance\\n             * was over the allowed max)\\n             *\\n             * Note: This does NOT take into account the fees which will be deducted\\n             *       from the amount. As such it could be a bit confusing\\n             */\\n            if (\\n                maxWalletBalance \\u003e 0 \\u0026\\u0026\\n                !_isUnlimitedSender(sender) \\u0026\\u0026\\n                !_isUnlimitedRecipient(recipient) \\u0026\\u0026\\n                !_isV2Pair(recipient)\\n            ) {\\n                uint256 recipientBalance = balanceOf(recipient);\\n                require(\\n                    recipientBalance + amount \\u003c= maxWalletBalance,\\n                    \\\"New balance would exceed the maxWalletBalance\\\"\\n                );\\n            }\\n        }\\n\\n        // if any account belongs to _isExcludedFromFee account then remove the fee\\n        if (_isExcludedFromFee[sender] || _isExcludedFromFee[recipient]) {\\n            takeFee = false;\\n        }\\n\\n        _beforeTokenTransfer(sender, recipient, amount, takeFee);\\n        _transferTokens(sender, recipient, amount, takeFee);\\n    }\\n\\n    function _transferTokens(\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        bool takeFee\\n    ) private {\\n        uint256 sumOfFees = _getSumOfFees(sender, amount);\\n        if (!takeFee) {\\n            sumOfFees = 0;\\n        }\\n\\n        (\\n            uint256 rAmount,\\n            uint256 rTransferAmount,\\n            uint256 tAmount,\\n            uint256 tTransferAmount,\\n            uint256 currentRate\\n        ) = _getValues(amount, sumOfFees);\\n\\n        /**\\n         * Sender\\u0027s and Recipient\\u0027s reflected balances must be always updated regardless of\\n         * whether they are excluded from rewards or not.\\n         */\\n\\n        _reflectedBalances[sender] = _reflectedBalances[sender].sub(rAmount);\\n        _reflectedBalances[recipient] = _reflectedBalances[recipient].add(\\n            rTransferAmount\\n        );\\n\\n        /**\\n         * Update the true/nominal balances for excluded accounts\\n         */\\n\\n        if (_isExcludedFromRewards[sender]) {\\n            _balances[sender] = _balances[sender].sub(tAmount);\\n        }\\n        if (_isExcludedFromRewards[recipient]) {\\n            _balances[recipient] = _balances[recipient].add(tTransferAmount);\\n        }\\n\\n        _takeFees(amount, currentRate, sumOfFees);\\n        emit Transfer(sender, recipient, tTransferAmount);\\n    }\\n\\n    function _takeFees(\\n        uint256 amount,\\n        uint256 currentRate,\\n        uint256 sumOfFees\\n    ) private {\\n        if (sumOfFees \\u003e 0 \\u0026\\u0026 !isInPresale) {\\n            _takeTransactionFees(amount, currentRate);\\n        }\\n    }\\n\\n    function _getValues(uint256 tAmount, uint256 feesSum)\\n        internal\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        uint256 tTotalFees = tAmount.mul(feesSum).div(FEES_DIVISOR);\\n        uint256 tTransferAmount = tAmount.sub(tTotalFees);\\n        uint256 currentRate = _getCurrentRate();\\n        uint256 rAmount = tAmount.mul(currentRate);\\n        uint256 rTotalFees = tTotalFees.mul(currentRate);\\n        uint256 rTransferAmount = rAmount.sub(rTotalFees);\\n\\n        return (\\n            rAmount,\\n            rTransferAmount,\\n            tAmount,\\n            tTransferAmount,\\n            currentRate\\n        );\\n    }\\n\\n    function _getCurrentRate() internal view returns (uint256) {\\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\\n        return rSupply.div(tSupply);\\n    }\\n\\n    function _getCurrentSupply() internal view returns (uint256, uint256) {\\n        uint256 rSupply = _reflectedSupply;\\n        uint256 tSupply = TOTAL_SUPPLY;\\n\\n        /**\\n         * The code below removes balances of addresses excluded from rewards from\\n         * rSupply and tSupply, which effectively increases the % of transaction fees\\n         * delivered to non-excluded holders\\n         */\\n\\n        for (uint256 i = 0; i \\u003c _excluded.length; i++) {\\n            if (\\n                _reflectedBalances[_excluded[i]] \\u003e rSupply ||\\n                _balances[_excluded[i]] \\u003e tSupply\\n            ) return (_reflectedSupply, TOTAL_SUPPLY);\\n            rSupply = rSupply.sub(_reflectedBalances[_excluded[i]]);\\n            tSupply = tSupply.sub(_balances[_excluded[i]]);\\n        }\\n        if (tSupply == 0 || rSupply \\u003c _reflectedSupply.div(TOTAL_SUPPLY))\\n            return (_reflectedSupply, TOTAL_SUPPLY);\\n        return (rSupply, tSupply);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens.\\n     */\\n    function _beforeTokenTransfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount,\\n        bool takeFee\\n    ) internal virtual;\\n\\n    /**\\n     * @dev Returns the total sum of fees to be processed in each transaction.\\n     */\\n\\n    function _getSumOfFees(address sender, uint256 amount)\\n        internal\\n        view\\n        virtual\\n        returns (uint256);\\n\\n    /**\\n     * @dev A delegate which should return true if the given address is the V2 Pair and false otherwise\\n     */\\n    function _isV2Pair(address account) internal view virtual returns (bool);\\n\\n    /**\\n     * @dev Redistributes the specified amount among the current holders via the reflect.finance\\n     * algorithm, i.e. by updating the _reflectedSupply (_rSupply) which ultimately adjusts the\\n     * current rate used by `tokenFromReflection` and, in turn, the value returns from `balanceOf`.\\n     * This is the bit of clever math which allows rfi to redistribute the fee without\\n     * having to iterate through all holders.\\n     */\\n    function _redistribute(\\n        uint256 amount,\\n        uint256 currentRate,\\n        uint256 fee,\\n        uint256 index\\n    ) internal {\\n        uint256 tFee = amount.mul(fee).div(FEES_DIVISOR);\\n        uint256 rFee = tFee.mul(currentRate);\\n\\n        _reflectedSupply = _reflectedSupply.sub(rFee);\\n        _addFeeCollectedAmount(index, tFee);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before the `Transfer` event is emitted if fees are enabled for the transfer\\n     */\\n    function _takeTransactionFees(uint256 amount, uint256 currentRate)\\n        internal\\n        virtual;\\n}\\n\"},\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this;\\n        return msg.data;\\n    }\\n}\\n\"},\"GorgeousToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n// GORGEOUS - Gorgeous: BEP20 token contract\\n// Telegram: https://t.me/gorgeoustoken\\n// Website: https://www.higorgeous.io/\\n\\n// TOKENOMICS\\n// ----------------------------------------------------------------------------\\n// Symbol: GORGEOUS\\n// Name: Gorgeous\\n// Total supply: 100,000,000.000000000000000000\\n// Decimals: 9\\n// ----------------------------------------------------------------------------\\n// Max buy 1% max, hold 4%\\n// 20% Burnt to dead wallet\\n// 70% Liquidity \\u0026 Pre-sale on DxSale\\n// Ownership renounced\\n// ----------------------------------------------------------------------------\\n// Redistribution fee: 15% burn (1% Burn, 4% Back to the Liquidity Pool, 3% To charity wallet, 3% To operating wallet, 4% Redistributed to Holders)\\n// ----------------------------------------------------------------------------\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"./BaseRfiToken.sol\\\";\\nimport \\\"./Liquifier.sol\\\";\\nimport \\\"./Antiwhale.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\nabstract contract GorgeousToken is BaseRfiToken, Liquifier, Antiwhale {\\n    using SafeMath for uint256;\\n\\n    constructor(Env _env) {\\n        initializeLiquiditySwapper(\\n            _env,\\n            maxTransactionAmount,\\n            numberOfTokensToSwapToLiquidity\\n        );\\n\\n        // exclude the pair address from rewards - we don\\u0027t want to redistribute\\n        // tx fees to these two; redistribution is only for holders.\\n        _exclude(_pair);\\n        _exclude(burnAddress);\\n    }\\n\\n    function _isV2Pair(address account) internal view override returns (bool) {\\n        return (account == _pair);\\n    }\\n\\n    function _getSumOfFees(address sender, uint256 amount)\\n        internal\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _getAntiwhaleFees(balanceOf(sender), amount);\\n    }\\n\\n    function _beforeTokenTransfer(\\n        address sender,\\n        address,\\n        uint256,\\n        bool\\n    ) internal override {\\n        if (!isInPresale) {\\n            uint256 contractTokenBalance = balanceOf(address(this));\\n            liquify(contractTokenBalance, sender);\\n        }\\n    }\\n\\n    function _takeTransactionFees(uint256 amount, uint256 currentRate)\\n        internal\\n        override\\n    {\\n        if (isInPresale) {\\n            return;\\n        }\\n\\n        uint256 feesCount = _getFeesCount();\\n        for (uint256 index = 0; index \\u003c feesCount; index++) {\\n            (FeeType name, uint256 value, address recipient, ) = _getFee(index);\\n            // no need to check value \\u003c 0 as the value is uint (i.e. from 0 to 2^256-1)\\n            if (value == 0) continue;\\n\\n            if (name == FeeType.Rfi) {\\n                _redistribute(amount, currentRate, value, index);\\n            } else if (name == FeeType.Burn) {\\n                _burn(amount, currentRate, value, index);\\n            } else {\\n                _takeFee(amount, currentRate, value, recipient, index);\\n            }\\n        }\\n    }\\n\\n    function _burn(\\n        uint256 amount,\\n        uint256 currentRate,\\n        uint256 fee,\\n        uint256 index\\n    ) private {\\n        uint256 tBurn = amount.mul(fee).div(FEES_DIVISOR);\\n        uint256 rBurn = tBurn.mul(currentRate);\\n\\n        _burnTokens(address(this), tBurn, rBurn);\\n        _addFeeCollectedAmount(index, tBurn);\\n    }\\n\\n    function _takeFee(\\n        uint256 amount,\\n        uint256 currentRate,\\n        uint256 fee,\\n        address recipient,\\n        uint256 index\\n    ) private {\\n        uint256 tAmount = amount.mul(fee).div(FEES_DIVISOR);\\n        uint256 rAmount = tAmount.mul(currentRate);\\n\\n        _reflectedBalances[recipient] = _reflectedBalances[recipient].add(\\n            rAmount\\n        );\\n        if (_isExcludedFromRewards[recipient])\\n            _balances[recipient] = _balances[recipient].add(tAmount);\\n\\n        _addFeeCollectedAmount(index, tAmount);\\n    }\\n\\n    function _approveDelegate(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal override {\\n        _approve(owner, spender, amount);\\n    }\\n}\\n\\ncontract Gorgeous is GorgeousToken {\\n    constructor() GorgeousToken(Env.MainnetV2) {\\n        _approve(owner(), address(_router), ~uint256(0));\\n    }\\n}\\n\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\"},\"IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IERC20Metadata is IERC20 {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n}\\n\"},\"IPancakeV2Factory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IPancakeV2Factory {\\n    event PairCreated(\\n        address indexed token0,\\n        address indexed token1,\\n        address pair,\\n        uint256\\n    );\\n\\n    function createPair(address tokenA, address tokenB)\\n        external\\n        returns (address pair);\\n}\\n\"},\"IPancakeV2Router.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IPancakeV2Router {\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256 amountToken,\\n            uint256 amountETH,\\n            uint256 liquidity\\n        );\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n}\\n\"},\"Liquifier.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./Manageable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./IPancakeV2Factory.sol\\\";\\nimport \\\"./IPancakeV2Router.sol\\\";\\n\\nabstract contract Liquifier is Ownable, Manageable {\\n    using SafeMath for uint256;\\n\\n    uint256 private withdrawableBalance;\\n\\n    enum Env {Testnet, MainnetV1, MainnetV2}\\n    Env private _env;\\n\\n    // PancakeSwap V1\\n    address private _mainnetRouterV1Address =\\n        0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F;\\n    // PancakeSwap V2\\n    address private _mainnetRouterV2Address =\\n        0x10ED43C718714eb63d5aA57B78B54704E256024E;\\n    // Testnet\\n    // address private _testnetRouterAddress = 0xD99D1c33F9fC3444f8101754aBC46c52416550D1;\\n    // PancakeSwap Testnet = https://pancake.kiemtienonline360.com/\\n    address private _testnetRouterAddress =\\n        0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3;\\n\\n    IPancakeV2Router internal _router;\\n    address internal _pair;\\n\\n    bool private inSwapAndLiquify;\\n    bool private swapAndLiquifyEnabled = true;\\n\\n    uint256 private maxTransactionAmount;\\n    uint256 private numberOfTokensToSwapToLiquidity;\\n\\n    modifier lockTheSwap {\\n        inSwapAndLiquify = true;\\n        _;\\n        inSwapAndLiquify = false;\\n    }\\n\\n    event RouterSet(address indexed router);\\n    event SwapAndLiquify(\\n        uint256 tokensSwapped,\\n        uint256 ethReceived,\\n        uint256 tokensIntoLiquidity\\n    );\\n    event SwapAndLiquifyEnabledUpdated(bool enabled);\\n    event LiquidityAdded(\\n        uint256 tokenAmountSent,\\n        uint256 ethAmountSent,\\n        uint256 liquidity\\n    );\\n\\n    receive() external payable {}\\n\\n    function initializeLiquiditySwapper(\\n        Env env,\\n        uint256 maxTx,\\n        uint256 liquifyAmount\\n    ) internal {\\n        _env = env;\\n        if (_env == Env.MainnetV1) {\\n            _setRouterAddress(_mainnetRouterV1Address);\\n        } else if (_env == Env.MainnetV2) {\\n            _setRouterAddress(_mainnetRouterV2Address);\\n        }\\n        /*(_env == Env.Testnet)*/\\n        else {\\n            _setRouterAddress(_testnetRouterAddress);\\n        }\\n\\n        maxTransactionAmount = maxTx;\\n        numberOfTokensToSwapToLiquidity = liquifyAmount;\\n    }\\n\\n    /**\\n     * NOTE: passing the `contractTokenBalance` here is preferred to creating `balanceOfDelegate`\\n     */\\n    function liquify(uint256 contractTokenBalance, address sender) internal {\\n        if (contractTokenBalance \\u003e= maxTransactionAmount)\\n            contractTokenBalance = maxTransactionAmount;\\n\\n        bool isOverRequiredTokenBalance =\\n            (contractTokenBalance \\u003e= numberOfTokensToSwapToLiquidity);\\n\\n        /**\\n         * - first check if the contract has collected enough tokens to swap and liquify\\n         * - then check swap and liquify is enabled\\n         * - then make sure not to get caught in a circular liquidity event\\n         * - finally, don\\u0027t swap \\u0026 liquify if the sender is the uniswap pair\\n         */\\n        if (\\n            isOverRequiredTokenBalance \\u0026\\u0026\\n            swapAndLiquifyEnabled \\u0026\\u0026\\n            !inSwapAndLiquify \\u0026\\u0026\\n            (sender != _pair)\\n        ) {\\n            // TODO check if the `(sender != _pair)` is necessary because that basically\\n            // stops swap and liquify for all \\\"buy\\\" transactions\\n            _swapAndLiquify(contractTokenBalance);\\n        }\\n    }\\n\\n    /**\\n     * @dev sets the router address and created the router, factory pair to enable\\n     * swapping and liquifying (contract) tokens\\n     */\\n    function _setRouterAddress(address router) private {\\n        IPancakeV2Router _newPancakeRouter = IPancakeV2Router(router);\\n        _pair = IPancakeV2Factory(_newPancakeRouter.factory()).createPair(\\n            address(this),\\n            _newPancakeRouter.WETH()\\n        );\\n        _router = _newPancakeRouter;\\n        emit RouterSet(router);\\n    }\\n\\n    function _swapAndLiquify(uint256 amount) private lockTheSwap {\\n        // split the contract balance into halves\\n        uint256 half = amount.div(2);\\n        uint256 otherHalf = amount.sub(half);\\n\\n        // capture the contract\\u0027s current ETH balance.\\n        // this is so that we can capture exactly the amount of ETH that the\\n        // swap creates, and not make the liquidity event include any ETH that\\n        // has been manually sent to the contract\\n        uint256 initialBalance = address(this).balance;\\n\\n        // swap tokens for ETH\\n        _swapTokensForEth(half); // \\u003c- this breaks the ETH -\\u003e HATE swap when swap+liquify is triggered\\n\\n        // how much ETH did we just swap into?\\n        uint256 newBalance = address(this).balance.sub(initialBalance);\\n\\n        // add liquidity to uniswap\\n        _addLiquidity(otherHalf, newBalance);\\n\\n        emit SwapAndLiquify(half, newBalance, otherHalf);\\n    }\\n\\n    function _swapTokensForEth(uint256 tokenAmount) private {\\n        // generate the uniswap pair path of token -\\u003e weth\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = _router.WETH();\\n\\n        _approveDelegate(address(this), address(_router), tokenAmount);\\n\\n        // make the swap\\n        _router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            tokenAmount,\\n            // The minimum amount of output tokens that must be received for the transaction not to revert.\\n            // 0 = accept any amount (slippage is inevitable)\\n            0,\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n\\n    function _addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\\n        // approve token transfer to cover all possible scenarios\\n        _approveDelegate(address(this), address(_router), tokenAmount);\\n\\n        // add the liquidity\\n        (uint256 tokenAmountSent, uint256 ethAmountSent, uint256 liquidity) =\\n            _router.addLiquidityETH{value: ethAmount}(\\n                address(this),\\n                tokenAmount,\\n                // Bounds the extent to which the WETH/token price can go up before the transaction reverts.\\n                // Must be \\u003c= amountTokenDesired; 0 = accept any amount (slippage is inevitable)\\n                0,\\n                // Bounds the extent to which the token/WETH price can go up before the transaction reverts.\\n                // 0 = accept any amount (slippage is inevitable)\\n                0,\\n                // this is a centralized risk if the owner\\u0027s account is ever compromised (see Certik SSL-04)\\n                owner(),\\n                block.timestamp\\n            );\\n\\n        // fix the forever locked BNBs as per the certik\\u0027s audit\\n        /**\\n         * The swapAndLiquify function converts half of the contractTokenBalance SafeMoon tokens to BNB.\\n         * For every swapAndLiquify function call, a small amount of BNB remains in the contract.\\n         * This amount grows over time with the swapAndLiquify function being called throughout the life\\n         * of the contract. The Safemoon contract does not contain a method to withdraw these funds,\\n         * and the BNB will be locked in the Safemoon contract forever.\\n         */\\n        withdrawableBalance = address(this).balance;\\n        emit LiquidityAdded(tokenAmountSent, ethAmountSent, liquidity);\\n    }\\n\\n    /**\\n     * @dev Sets the uniswapV2 pair (router \\u0026 factory) for swapping and liquifying tokens\\n     */\\n    function setRouterAddress(address router) external onlyManager() {\\n        _setRouterAddress(router);\\n    }\\n\\n    /**\\n     * @dev Sends the swap and liquify flag to the provided value. If set to `false` tokens collected in the contract will\\n     * NOT be converted into liquidity.\\n     */\\n    function setSwapAndLiquifyEnabled(bool enabled) external onlyManager {\\n        swapAndLiquifyEnabled = enabled;\\n        emit SwapAndLiquifyEnabledUpdated(swapAndLiquifyEnabled);\\n    }\\n\\n    /**\\n     * @dev The owner can withdraw ETH(BNB) collected in the contract from `swapAndLiquify`\\n     * or if someone (accidentally) sends ETH/BNB directly to the contract.\\n     *\\n     * Note: This addresses the contract flaw pointed out in the Certik Audit of Safemoon (SSL-03):\\n     *\\n     * The swapAndLiquify function converts half of the contractTokenBalance SafeMoon tokens to BNB.\\n     * For every swapAndLiquify function call, a small amount of BNB remains in the contract.\\n     * This amount grows over time with the swapAndLiquify function being called\\n     * throughout the life of the contract. The Safemoon contract does not contain a method\\n     * to withdraw these funds, and the BNB will be locked in the Safemoon contract forever.\\n     * https://www.certik.org/projects/safemoon\\n     */\\n    function withdrawLockedEth(address payable recipient)\\n        external\\n        onlyManager()\\n    {\\n        require(\\n            recipient != address(0),\\n            \\\"Cannot withdraw the ETH balance to the zero address\\\"\\n        );\\n        require(\\n            withdrawableBalance \\u003e 0,\\n            \\\"The ETH balance must be greater than 0\\\"\\n        );\\n\\n        // prevent re-entrancy attacks\\n        uint256 amount = withdrawableBalance;\\n        withdrawableBalance = 0;\\n        recipient.transfer(amount);\\n    }\\n\\n    /**\\n     * @dev Use this delegate instead of having (unnecessarily) extend `BaseRfiToken` to gained access\\n     * to the `_approve` function.\\n     */\\n    function _approveDelegate(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual;\\n}\\n\"},\"Manageable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"./Context.sol\\\";\\n\\nabstract contract Manageable is Context {\\n    address private _manager;\\n    event ManagementTransferred(\\n        address indexed previousManager,\\n        address indexed newManager\\n    );\\n\\n    constructor() {\\n        address msgSender = _msgSender();\\n        _manager = msgSender;\\n        emit ManagementTransferred(address(0), msgSender);\\n    }\\n\\n    function manager() public view returns (address) {\\n        return _manager;\\n    }\\n\\n    modifier onlyManager() {\\n        require(\\n            _manager == _msgSender(),\\n            \\\"Manageable: caller is not the manager\\\"\\n        );\\n        _;\\n    }\\n\\n    function transferManagement(address newManager)\\n        external\\n        virtual\\n        onlyManager\\n    {\\n        emit ManagementTransferred(_manager, newManager);\\n        _manager = newManager;\\n    }\\n}\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"./Context.sol\\\";\\n\\nabstract contract Ownable is Context {\\n    address private _owner;\\n    address private _previousOwner;\\n    uint256 private _lockTime;\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    constructor() {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(\\n            newOwner != address(0),\\n            \\\"Ownable: new owner is the zero address\\\"\\n        );\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n\\n    function getUnlockTime() public view returns (uint256) {\\n        return _lockTime;\\n    }\\n\\n    function lock(uint256 time) public virtual onlyOwner {\\n        _previousOwner = _owner;\\n        _owner = address(0);\\n        _lockTime = block.timestamp + time;\\n        emit OwnershipTransferred(_owner, address(0));\\n    }\\n\\n    function unlock() public virtual {\\n        require(\\n            _previousOwner == msg.sender,\\n            \\\"Only the previous owner can unlock onwership\\\"\\n        );\\n        require(block.timestamp \\u003e _lockTime, \\\"The contract is still locked\\\");\\n        emit OwnershipTransferred(_owner, _previousOwner);\\n        _owner = _previousOwner;\\n    }\\n}\\n\"},\"Presaleable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"./Manageable.sol\\\";\\n\\nabstract contract Presaleable is Manageable {\\n    bool internal isInPresale;\\n\\n    function setPreselableEnabled(bool value) external onlyManager {\\n        isInPresale = value;\\n    }\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nlibrary SafeMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {return a + b;}\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {return a - b;}\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {return a * b;}\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {return a / b;}\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {return a % b;}\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked { require(b \\u003c= a, errorMessage); return a - b; }\\n    }\\n}\"},\"Tokenomics.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"./Presaleable.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\nabstract contract Tokenomics {\\n    using SafeMath for uint256;\\n\\n    // --------------------- Token Settings ------------------- //\\n\\n    string internal constant NAME = \\\"Gorgeous\\\";\\n    string internal constant SYMBOL = \\\"GORGEOUS\\\";\\n\\n    uint16 internal constant FEES_DIVISOR = 10**3;\\n    uint8 internal constant DECIMALS = 9;\\n    uint256 internal constant ZEROES = 10**DECIMALS;\\n\\n    uint256 private constant MAX = ~uint256(0);\\n    uint256 internal constant TOTAL_SUPPLY = 100000000 * ZEROES;\\n    uint256 internal _reflectedSupply = (MAX - (MAX % TOTAL_SUPPLY));\\n\\n    /**\\n     * @dev Set the maximum transaction amount allowed in a transfer.\\n     */\\n    uint256 internal constant maxTransactionAmount = TOTAL_SUPPLY / 100; // 1% of the total supply\\n\\n    /**\\n     * @dev Set the maximum allowed balance in a wallet.\\n     */\\n    uint256 internal constant maxWalletBalance = TOTAL_SUPPLY / 25; // 4% of the total supply\\n\\n    /**\\n     * @dev Set the number of tokens to swap and add to liquidity.\\n     *\\n     * Whenever the contract\\u0027s balance reaches this number of tokens, swap \\u0026 liquify will be\\n     * executed in the very next transfer (via the `_beforeTokenTransfer`)\\n     *\\n     * 1 of each transaction will be first sent to the contract address. Once the contract\\u0027s balance\\n     *  reaches `numberOfTokensToSwapToLiquidity` the `swapAndLiquify` of `Liquifier` will be executed.\\n     *  Half of the tokens will be swapped for ETH (or BNB on BSC) and together with the other\\n     *  half converted into a Token-ETH/Token-BNB LP Token.\\n     */\\n    uint256 internal constant numberOfTokensToSwapToLiquidity =\\n        TOTAL_SUPPLY / 1000; // 0.1% of the total supply\\n\\n    // --------------------- Fees Settings ------------------- //\\n\\n    /**\\n     * @dev Wallets for feeType.External\\n     */\\n    address internal charityAddress =\\n        0xe2377D5b852CE0B8995C31B201699C31D8566A0b;\\n    address internal marketingAddress =\\n        0x559acE6C43266065D0C5eBe7cf18c33e648AAA6E;\\n\\n    /**\\n     * @dev Wallets for feeType.Burn\\n     */\\n    address internal burnAddress = 0x000000000000000000000000000000000000dEaD;\\n\\n    enum FeeType {Antiwhale, Burn, Liquidity, Rfi, External}\\n    struct Fee {\\n        FeeType name;\\n        uint256 value;\\n        address recipient;\\n        uint256 total;\\n    }\\n\\n    Fee[] internal fees;\\n    uint256 internal sumOfFees;\\n\\n    constructor() {\\n        _addFees();\\n    }\\n\\n    function _addFee(\\n        FeeType name,\\n        uint256 value,\\n        address recipient\\n    ) private {\\n        fees.push(Fee(name, value, recipient, 0));\\n        sumOfFees += value;\\n    }\\n\\n    function _addFees() private {\\n        /**\\n         * The value of fees is given in part per 1000 (based on the value of FEES_DIVISOR),\\n         * e.g. for 5% use 50, for 3.5% use 35, etc.\\n         */\\n        _addFee(FeeType.Rfi, 40, address(this));\\n\\n        _addFee(FeeType.Burn, 10, burnAddress);\\n        _addFee(FeeType.Liquidity, 40, address(this));\\n        _addFee(FeeType.External, 30, charityAddress);\\n        _addFee(FeeType.External, 30, marketingAddress);\\n    }\\n\\n    function _getFeesCount() internal view returns (uint256) {\\n        return fees.length;\\n    }\\n\\n    function _getFeeStruct(uint256 index) private view returns (Fee storage) {\\n        require(\\n            index \\u003e= 0 \\u0026\\u0026 index \\u003c fees.length,\\n            \\\"FeesSettings._getFeeStruct: Fee index out of bounds\\\"\\n        );\\n        return fees[index];\\n    }\\n\\n    function _getFee(uint256 index)\\n        internal\\n        view\\n        returns (\\n            FeeType,\\n            uint256,\\n            address,\\n            uint256\\n        )\\n    {\\n        Fee memory fee = _getFeeStruct(index);\\n        return (fee.name, fee.value, fee.recipient, fee.total);\\n    }\\n\\n    function _addFeeCollectedAmount(uint256 index, uint256 amount) internal {\\n        Fee storage fee = _getFeeStruct(index);\\n        fee.total = fee.total.add(amount);\\n    }\\n\\n    // function getCollectedFeeTotal(uint256 index) external view returns (uint256){\\n    function getCollectedFeeTotal(uint256 index)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        Fee memory fee = _getFeeStruct(index);\\n        return fee.total;\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountSent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethAmountSent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"name\":\"LiquidityAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousManager\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"ManagementTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"}],\"name\":\"RouterSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiquidity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"SwapAndLiquifyEnabledUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUnlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"deductTransferFee\",\"type\":\"bool\"}],\"name\":\"reflectionFromToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setExcludedFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setPreselableEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"}],\"name\":\"setRouterAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setSwapAndLiquifyEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"transferManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"withdrawLockedEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Gorgeous", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://39667f6c5e8b02956a676fb401218b8351d45f7b6df7285411fb899fb59759dd"}