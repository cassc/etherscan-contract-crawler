{"SourceCode": "{\"EcosystemSwapper.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.14;\\n\\nimport \\\"./IUniswapV2Router02.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IStable {\\n    function sell(uint256 tokenAmount) external returns (uint256);\\n    function mintWithBacking(uint256 numTokens, address recipient) external returns (uint256);\\n    function burn(uint256 amount) external;\\n}\\n\\ninterface IToken {\\n    function buyFee() external view returns (uint256);\\n    function sellFee() external view returns (uint256);\\n    function buyFeeRecipient() external view returns (address);\\n    function sellFeeRecipient() external view returns (address);\\n}\\n\\ninterface IInfinity {\\n    function buy(address recipient) external payable;\\n    function sell(uint256 amount) external returns (bool);\\n}\\n\\ncontract EcosystemSwapper {\\n\\n    // Pancake Router\\n    IUniswapV2Router02 public constant router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\\n\\n    // Normal Tokens\\n    address public constant MDB = 0x0557a288A93ed0DF218785F2787dac1cd077F8f3;\\n    address public constant INFINITY = 0xaCC966B91100f879C9eD4839ed2F77c70E3E97eD;\\n    address public constant BUSD = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56;\\n\\n    // Stable Tokens\\n    address public constant MDBP = 0x9f8BB16f49393eeA4331A39B69071759e54e16ea;\\n    address public constant PHOENIX = 0xfc62b18CAC1343bd839CcbEDB9FC3382a84219B9;\\n\\n    // Stable Fees\\n    uint256 public constant MDBPBuyFee = 75;\\n    uint256 public constant MDBPSellFee = 25;\\n    uint256 public constant PHOENIXFee = 200;\\n    \\n    uint256 private constant FEE_DENOM = 10**4;\\n\\n    function swap(address fromToken, address toToken, uint256 amount) external payable {\\n\\n        // process Txs with ETH as the fromToken\\n        if (fromToken == address(0)) {\\n\\n            _bnbToToken(toToken);\\n\\n        } else {\\n            \\n            // transfer in `amount` of `fromToken`\\n            _transferIn(fromToken, amount);\\n\\n            // BUSD -\\u003e toToken\\n            if (fromToken == BUSD) {\\n\\n                if (isStable(toToken)) {\\n                    _mintStable(toToken);\\n                } else {\\n\\n                    // BUSD -\\u003e BNB\\n                    _tokenToBnb(BUSD);\\n\\n                    // BNB -\\u003e Token\\n                    _bnbToToken(toToken);\\n                    \\n                }\\n\\n            } else if (fromToken == MDB) {\\n                \\n                // MDB -\\u003e BNB\\n                _tokenToBnb(MDB);\\n\\n                // BNB -\\u003e Asset\\n                _bnbToToken(toToken);\\n\\n            } else if (fromToken == INFINITY) {\\n\\n                if (toToken == PHOENIX) {\\n                    _tokenToToken(fromToken, toToken);\\n                } else if (toToken == MDBP) {\\n                    _tokenToToken(INFINITY, PHOENIX);\\n                    _sellStable(PHOENIX);\\n                    _mintStable(MDBP);\\n                } else {\\n                    _tokenToBnb(fromToken);\\n                    _bnbToToken(toToken);\\n                }\\n\\n            } else if (fromToken == PHOENIX) {\\n\\n                if (toToken == INFINITY) {\\n                    _tokenToToken(fromToken, toToken);\\n                } else if (toToken == BUSD) {\\n                    _sellStable(fromToken);\\n                } else {\\n                    _sellStable(fromToken);\\n                    if (toToken == MDBP) {\\n                        _mintStable(MDBP);\\n                    } else {\\n                        _tokenToBnb(BUSD);\\n                        _bnbToToken(toToken);\\n                    }\\n                }\\n\\n            } else if (fromToken == MDBP) {\\n\\n                if (toToken == MDB) {\\n                    _tokenToToken(fromToken, toToken);\\n                } else if (toToken == BUSD) {\\n                    _sellStable(fromToken);\\n                } else {\\n                    _sellStable(fromToken);\\n                    if (toToken == PHOENIX) {\\n                        _mintStable(PHOENIX);\\n                    } else {\\n                        _tokenToBnb(BUSD);\\n                        _bnbToToken(toToken);\\n                    }\\n                }\\n\\n\\n            } else {\\n\\n                _tokenToBnb(fromToken);\\n                _bnbToToken(toToken);\\n\\n            }\\n\\n        }\\n\\n        if (toToken == address(0)) {\\n            (bool s,) = payable(msg.sender).call{value: address(this).balance}(\\\"\\\");\\n            require(s);\\n        } else {\\n            uint256 endBalance = IERC20(toToken).balanceOf(address(this));\\n            if (endBalance \\u003e 0) {\\n                IERC20(toToken).transfer(msg.sender, endBalance);\\n            }\\n        }\\n    }\\n\\n    function _tokenToBnb(address token) internal {\\n\\n        _processFee(token, false);\\n\\n        uint256 amount = IERC20(token).balanceOf(address(this));\\n\\n        if (token == INFINITY) {\\n            \\n            IERC20(INFINITY).approve(address(router), amount);\\n\\n            address[] memory path = new address[](2);\\n            path[0] = INFINITY;\\n            path[1] = PHOENIX;\\n\\n            router.swapExactTokensForTokensSupportingFeeOnTransferTokens(amount, 1, path, address(this), block.timestamp + 100);\\n            delete path;\\n\\n            _sellStable(PHOENIX);\\n            _tokenToBnb(BUSD);\\n\\n        } else {\\n\\n            IERC20(token).approve(address(router), amount);\\n\\n            address[] memory path = new address[](2);\\n            path[0] = token;\\n            path[1] = router.WETH();\\n\\n            router.swapExactTokensForETHSupportingFeeOnTransferTokens(amount, 1, path, address(this), block.timestamp + 100);\\n            delete path;\\n        }\\n    }\\n\\n    function _bnbToToken(address token) internal {\\n\\n        uint256 amount = address(this).balance;\\n\\n        if (token == address(0)) {\\n            return;\\n        }\\n\\n        if (isStable(token)) {\\n            _bnbToStable(token, amount);\\n            return;\\n        }\\n\\n        if (token == INFINITY) {\\n\\n            IInfinity(token).buy{value: amount}(address(this));\\n\\n        } else {\\n\\n            address[] memory path = new address[](2);\\n            path[0] = router.WETH();\\n            path[1] = token;\\n\\n            router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: amount}(1, path, address(this), block.timestamp + 100);\\n            delete path;\\n        }\\n\\n        _processFee(token, true);\\n    }\\n\\n    function _bnbToStable(address token, uint amount) internal {\\n\\n        (bool s,) = payable(token).call{value: amount}(\\\"\\\");\\n        require(s);\\n\\n        _processFee(token, true);\\n    }\\n\\n    function _sellStable(address token) internal {\\n\\n        _processFee(token, false);\\n        IStable(token).sell(IERC20(token).balanceOf(address(this)));\\n    }\\n\\n    function _mintStable(address token) internal {\\n\\n        uint amount = IERC20(BUSD).balanceOf(address(this));\\n        IERC20(BUSD).approve(token, amount);\\n        IStable(token).mintWithBacking(amount, address(this));\\n\\n        _processFee(token, true);\\n    }\\n\\n    function _tokenToToken(address fromToken, address toToken) internal {\\n        \\n        // process sell fee\\n        _processFee(fromToken, false);\\n\\n        // fetch new sell amount\\n        uint256 amount = IERC20(fromToken).balanceOf(address(this));\\n\\n        // approve router\\n        IERC20(fromToken).approve(address(router), amount);\\n\\n        // build path\\n        address[] memory path = new address[](2);\\n        path[0] = fromToken;\\n        path[1] = toToken;\\n\\n        // make swap\\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(amount, 1, path, address(this), block.timestamp + 100);\\n\\n        // clear memory\\n        delete path;\\n\\n        // process buy fee\\n        _processFee(toToken, true);\\n    }\\n\\n    function isStable(address token) public pure returns (bool) {\\n        return token == MDBP || token == PHOENIX;\\n    }\\n\\n    function _transferIn(address token, uint256 amount) internal {\\n        require(\\n            IERC20(token).allowance(msg.sender, address(this)) \\u003e= amount,\\n            \\u0027Insufficient Allowance\\u0027\\n        );\\n        require(\\n            IERC20(token).transferFrom(msg.sender, address(this), amount),\\n            \\u0027ERR Transfer From\\u0027\\n        );\\n        uint256 balance = IERC20(token).balanceOf(address(this));\\n        require(balance \\u003e 0, \\u0027Zero Balance\\u0027);\\n    }\\n\\n    function _processFee(address token, bool isBuy) internal {\\n\\n        if (token == MDB || token == INFINITY) {\\n\\n            uint256 fee = isBuy ? IToken(token).buyFee() : IToken(token).sellFee();\\n            address recipient = isBuy ? IToken(token).buyFeeRecipient() : IToken(token).sellFeeRecipient();\\n\\n            uint256 balance = IERC20(token).balanceOf(address(this));\\n\\n            if (balance \\u003e FEE_DENOM) {\\n                IERC20(token).transfer(\\n                    recipient, \\n                    ( balance * fee ) / FEE_DENOM\\n                );\\n            }\\n\\n        } else if (token == MDBP || token == PHOENIX) {\\n\\n            uint256 fee = token == MDBP ? isBuy ? MDBPBuyFee : MDBPSellFee : PHOENIXFee;\\n            uint256 balance = IERC20(token).balanceOf(address(this));\\n\\n            if (balance \\u003e FEE_DENOM) {\\n                IStable(token).burn(\\n                    ( balance * fee ) / FEE_DENOM\\n                );\\n            }\\n            \\n        }\\n\\n    }\\n\\n\\n    receive() external payable {}\\n}\"},\"IERC20.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.14;\\n\\ninterface IERC20 {\\n\\n    function totalSupply() external view returns (uint256);\\n    \\n    function symbol() external view returns(string memory);\\n    \\n    function name() external view returns(string memory);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n    \\n    /**\\n     * @dev Returns the number of decimal places\\n     */\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"},\"IUniswapV2Router02.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.14;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n    external\\n    payable\\n    returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n    external\\n    returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n    external\\n    returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n    external\\n    payable\\n    returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\"}}", "ABI": "[{\"inputs\":[],\"name\":\"BUSD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INFINITY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MDB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MDBP\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MDBPBuyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MDBPSellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PHOENIX\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PHOENIXFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"isStable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "EcosystemSwapper", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://1b7178a3df0f7b5d0030eec3a71278fe2539cd136cb859e72cfdfe716d175480"}