{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/old/IUniswapV2Router01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"contracts/stakingV2/IContractsLibraryStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\nimport \\\"../old/IUniswapV2Router01.sol\\\";\\n\\nabstract contract IContractsLibraryStaking {\\n    function BUSD() external view virtual returns (address);\\n\\n    function WBNB() external view virtual returns (address);\\n\\n    function ROUTER() external view virtual returns (IUniswapV2Router01);\\n\\n    function getBusdToBNBToToken(\\n        address token,\\n        uint _amount\\n    ) external view virtual returns (uint256);\\n\\n    function getTokensToBNBtoBusd(\\n        address token,\\n        uint _amount\\n    ) external view virtual returns (uint256);\\n\\n    function getTokensToBnb(\\n        address token,\\n        uint _amount\\n    ) external view virtual returns (uint256);\\n\\n    function getBnbToTokens(\\n        address token,\\n        uint _amount\\n    ) public view virtual returns (uint256);\\n\\n    function getTokenToBnbToAltToken(\\n        address token,\\n        address altToken,\\n        uint _amount\\n    ) public view virtual returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/stakingV2/satking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./StakingState.sol\\\";\\nimport \\\"./IContractsLibraryStaking.sol\\\";\\n\\ncontract tokenStakingV2 is StakingState, ReentrancyGuard {\\n    using SafeMath for uint;\\n    IContractsLibraryStaking public contractsLibrary;\\n    address public oWallet;\\n    address public mWallet;\\n    address public devFeeAddress;\\n    // \\tuint internal constant PERCENT_DIVIDER = 1000; // 1000 = 100%, 100 = 10%, 10 = 1%, 1 = 0.1%\\n    struct Pool {\\n        address token;\\n        address rewardToken;\\n        uint minimumDeposit;\\n        uint roi;\\n        uint fee;\\n        uint referrerPercent;\\n        uint rquirePool;\\n        uint requireAmount;\\n        uint blockTimeStep;\\n        bool isActived;\\n    }\\n\\n    // Info of each user.\\n    struct UserInfo {\\n        address user;\\n        address referrer;\\n        uint investment;\\n        uint stakingValue;\\n        uint rewardLockedUp;\\n        uint totalDeposit;\\n        uint totalWithdrawn;\\n        uint nextWithdraw;\\n        uint unlockDate;\\n        uint depositCheckpoint;\\n        uint busdTotalDeposit;\\n    }\\n\\n    struct RefData {\\n        address referrer;\\n        uint amount;\\n        bool exists;\\n    }\\n\\n    mapping(address => RefData) public referrers;\\n\\n    uint public constant minPool = 1;\\n    uint public poolsLength = 0;\\n    mapping(uint => mapping(address => UserInfo)) public users;\\n\\n    mapping(address => uint) public lastBlock;\\n    mapping(uint => Pool) public pools;\\n\\n    event Newbie(address user);\\n    event NewDeposit(address indexed user, uint256 amount);\\n    event Withdrawn(address indexed user, uint256 amount);\\n    event RefBonus(\\n        address indexed referrer,\\n        address indexed referral,\\n        uint256 indexed level,\\n        uint256 amount\\n    );\\n    event FeePayed(address indexed user, uint256 totalAmount);\\n    event Reinvestment(address indexed user, uint256 amount);\\n    event ForceWithdraw(address indexed user, uint256 amount);\\n\\n    constructor(\\n        address _library,\\n        address _token,\\n        address _oWallet,\\n        address _mWallet,\\n        address _operator\\n    ) {\\n        devAddress = msg.sender;\\n        contractsLibrary = IContractsLibraryStaking(_library);\\n        oWallet = _oWallet;\\n        mWallet = _mWallet;\\n        operatorAddress = _operator;\\n        devFeeAddress = msg.sender;\\n\\n        pools[1] = Pool({\\n            token: _token,\\n            rewardToken: _token,\\n            minimumDeposit: 0.1 ether,\\n            roi: 5,\\n            fee: 20,\\n            referrerPercent: REFERRER_PERCENTS,\\n            rquirePool: 0,\\n            requireAmount: 0,\\n            blockTimeStep: BLOCK_TIME_STEP,\\n            isActived: true\\n        });\\n\\n        pools[2] = Pool({\\n            token: _token,\\n            rewardToken: _token,\\n            minimumDeposit: 0.1 ether,\\n            roi: 11,\\n            fee: 20,\\n            referrerPercent: REFERRER_PERCENTS,\\n            rquirePool: 0,\\n            requireAmount: 0,\\n            blockTimeStep: BLOCK_TIME_STEP * 4,\\n            isActived: true\\n        });\\n\\n        pools[3] = Pool({\\n            token: _token,\\n            rewardToken: _token,\\n            minimumDeposit: 0.1 ether,\\n            roi: 12,\\n            fee: 20,\\n            referrerPercent: REFERRER_PERCENTS,\\n            rquirePool: 0,\\n            requireAmount: 0,\\n            blockTimeStep: BLOCK_TIME_STEP * 6,\\n            isActived: true\\n        });\\n\\n        pools[4] = Pool({\\n            token: _token,\\n            rewardToken: _token,\\n            minimumDeposit: 0.1 ether,\\n            roi: 13,\\n            fee: 20,\\n            referrerPercent: REFERRER_PERCENTS,\\n            rquirePool: 0,\\n            requireAmount: 0,\\n            blockTimeStep: BLOCK_TIME_STEP * 8,\\n            isActived: true\\n        });\\n\\n        pools[5] = Pool({\\n            token: _token,\\n            rewardToken: _token,\\n            minimumDeposit: 0.1 ether,\\n            roi: 14,\\n            fee: 20,\\n            referrerPercent: REFERRER_PERCENTS,\\n            rquirePool: 0,\\n            requireAmount: 0,\\n            blockTimeStep: BLOCK_TIME_STEP * 10,\\n            isActived: true\\n        });\\n\\n        pools[6] = Pool({\\n            token: _token,\\n            rewardToken: _token,\\n            minimumDeposit: 0.1 ether,\\n            roi: 15,\\n            fee: 20,\\n            referrerPercent: REFERRER_PERCENTS,\\n            rquirePool: 0,\\n            requireAmount: 0,\\n            blockTimeStep: BLOCK_TIME_STEP * 12,\\n            isActived: true\\n        });\\n\\n        poolsLength = 6;\\n    }\\n\\n    function setoWallet(address _oWallet) external onlyOwner {\\n        oWallet = _oWallet;\\n    }\\n\\n    function setmWallet(address _mWallet) external onlyOwner {\\n        mWallet = _mWallet;\\n    }\\n\\n    function setDevFeeAddress(address _devFeeAddress) external onlyOwner {\\n        devFeeAddress = _devFeeAddress;\\n    }\\n\\n    modifier tenBlocks() {\\n        require(block.number.sub(lastBlock[msg.sender]) > 10, \\\"wait 10 blocks\\\");\\n        _;\\n        lastBlock[msg.sender] = block.number;\\n    }\\n\\n    function isContract(address addr) internal view returns (bool) {\\n        uint size;\\n        assembly {\\n            size := extcodesize(addr)\\n        }\\n        return size > 0;\\n    }\\n\\n    modifier isNotContract() {\\n        require(!isContract(msg.sender), \\\"contract not allowed\\\");\\n        _;\\n    }\\n\\n    function invest(\\n        uint _pool,\\n        uint amount,\\n        address _referrer\\n    )\\n        external\\n        nonReentrant\\n        whenNotPaused\\n        tenBlocks\\n        isNotContract\\n        hasNotStoppedProduction\\n    {\\n        require(_pool >= minPool && _pool <= poolsLength, \\\"Invalid pool\\\");\\n        UserInfo storage user = users[_pool][msg.sender];\\n        Pool memory pool = pools[_pool];\\n        require(pool.isActived, \\\"Pool is not actived\\\");\\n        if (pool.rquirePool > 0) {\\n            require(\\n                users[pool.rquirePool][msg.sender].totalDeposit >=\\n                    pool.requireAmount,\\n                \\\"Require amount\\\"\\n            );\\n        }\\n        if (pool.minimumDeposit > 0) {\\n            require(amount >= pool.minimumDeposit, \\\"Minimum deposit\\\");\\n        }\\n\\n        IERC20(pool.token).transferFrom(msg.sender, address(this), amount);\\n\\n        RefData storage refData = referrers[msg.sender];\\n        if (!refData.exists) {\\n            refData.exists = true;\\n            totalUsers++;\\n            emit Newbie(msg.sender);\\n            if (\\n                refData.referrer == address(0) &&\\n                _referrer != address(0) &&\\n                _referrer != msg.sender &&\\n                msg.sender != referrers[_referrer].referrer\\n            ) {\\n                refData.referrer = _referrer;\\n            }\\n        }\\n\\n        uint refAmount = amount.mul(pool.referrerPercent).div(PERCENT_DIVIDER);\\n\\n        if (referrer_is_allowed && refData.referrer != address(0)) {\\n            referrers[refData.referrer].amount += refAmount;\\n            IERC20(pools[_pool].token).transfer(refData.referrer, refAmount);\\n            emit RefBonus(refData.referrer, msg.sender, 1, refAmount);\\n        }\\n\\n        if (user.user == address(0)) {\\n            user.user = msg.sender;\\n            investors[_pool][totalUsers] = msg.sender;\\n        }\\n        updateDeposit(msg.sender, _pool);\\n\\n        if (pool.fee > 0) {\\n            uint fee = amount.mul(pool.fee).div(PERCENT_DIVIDER);\\n            uint toDev = fee.div(4);\\n            uint toMwallet = toDev;\\n            uint toOwallet = fee.sub(toDev).sub(toMwallet);\\n            IERC20(pools[_pool].token).transfer(devFeeAddress, toDev);\\n            IERC20(pools[_pool].token).transfer(mWallet, toMwallet);\\n            IERC20(pools[_pool].token).transfer(oWallet, toOwallet);\\n\\n            emit FeePayed(msg.sender, fee);\\n        }\\n\\n        users[_pool][msg.sender].investment += amount;\\n\\n        if (pool.token == pool.rewardToken) {\\n            users[_pool][msg.sender].stakingValue += amount;\\n        } else if (pool.rewardToken == address(0)) {\\n            users[_pool][msg.sender].stakingValue += contractsLibrary\\n                .getTokensToBnb(pool.token, amount);\\n        } else {\\n            users[_pool][msg.sender].stakingValue += contractsLibrary\\n                .getTokenToBnbToAltToken(pool.token, pool.rewardToken, amount);\\n        }\\n        users[_pool][msg.sender].totalDeposit += amount;\\n\\n        totalInvested[_pool] += amount;\\n        totalDeposits[_pool]++;\\n\\n        if (user.nextWithdraw == 0) {\\n            user.nextWithdraw = block.timestamp + HARVEST_DELAY;\\n        }\\n\\n        user.unlockDate = block.timestamp + pool.blockTimeStep;\\n\\n        emit NewDeposit(msg.sender, amount);\\n    }\\n\\n    function payToUser(uint _pool, bool _withdraw) internal {\\n        require(userCanwithdraw(msg.sender, _pool), \\\"User cannot withdraw\\\");\\n        require(_pool >= minPool && _pool <= poolsLength, \\\"Invalid pool\\\");\\n        require(pools[_pool].isActived, \\\"Pool is not actived\\\");\\n        updateDeposit(msg.sender, _pool);\\n        uint fromVault;\\n        if (_withdraw) {\\n            require(\\n                block.timestamp >= users[_pool][msg.sender].unlockDate,\\n                \\\"Token is locked\\\"\\n            );\\n            fromVault = users[_pool][msg.sender].investment;\\n            delete users[_pool][msg.sender].investment;\\n            delete users[_pool][msg.sender].stakingValue;\\n            delete users[_pool][msg.sender].nextWithdraw;\\n        } else {\\n            users[_pool][msg.sender].nextWithdraw =\\n                block.timestamp +\\n                HARVEST_DELAY;\\n        }\\n        uint formThis = users[_pool][msg.sender].rewardLockedUp;\\n        delete users[_pool][msg.sender].rewardLockedUp;\\n        uint _toWithdraw = formThis;\\n        totalWithdrawn[_pool] += _toWithdraw;\\n        users[_pool][msg.sender].totalWithdrawn += _toWithdraw;\\n        if (fromVault > 0) {\\n            require(\\n                IERC20(pools[_pool].token).balanceOf(address(this)) >=\\n                    fromVault,\\n                \\\"Not enough tokens in contract\\\"\\n            );\\n            IERC20(pools[_pool].token).transfer(msg.sender, fromVault);\\n        }\\n        address tokenReward = pools[_pool].rewardToken;\\n        if (tokenReward == address(0)) {\\n            payable(msg.sender).transfer(formThis);\\n        } else {\\n            IERC20(tokenReward).transfer(msg.sender, formThis);\\n        }\\n        emit Withdrawn(msg.sender, _toWithdraw);\\n    }\\n\\n    function harvest(\\n        uint _pool\\n    )\\n        external\\n        nonReentrant\\n        whenNotPaused\\n        tenBlocks\\n        isNotContract\\n        hasNotStoppedProduction\\n    {\\n        payToUser(_pool, false);\\n    }\\n\\n    function withdraw(\\n        uint _pool\\n    )\\n        external\\n        nonReentrant\\n        whenNotPaused\\n        tenBlocks\\n        isNotContract\\n        hasNotStoppedProduction\\n    {\\n        payToUser(_pool, true);\\n    }\\n\\n    // function reinvest(\\n    //     uint _pool\\n    // )\\n    //     external\\n    //     nonReentrant\\n    //     whenNotPaused\\n    //     tenBlocks\\n    //     isNotContract\\n    //     hasNotStoppedProduction\\n    // {\\n    //     require(userCanwithdraw(msg.sender, _pool), \\\"User cannot reinvest\\\");\\n    //     require(_pool >= minPool && _pool <= poolsLength, \\\"Invalid pool\\\");\\n    //     updateDeposit(msg.sender, _pool);\\n    //     users[_pool][msg.sender].nextWithdraw = block.timestamp + HARVEST_DELAY;\\n    //     uint pending = users[_pool][msg.sender].rewardLockedUp;\\n    //     Pool memory pool = pools[_pool];\\n    //     users[_pool][msg.sender].stakingValue += pending;\\n    //     delete users[_pool][msg.sender].rewardLockedUp;\\n    //     totalReinvested += pending;\\n    //     totalReinvestCount++;\\n    //     if (pool.rewardToken != address(0) && pool.token == pool.rewardToken) {\\n    //         users[_pool][msg.sender].investment += pending;\\n    //         IERC20(pools[_pool].token).transfer(address(vault), pending);\\n    //     }\\n    //     emit Reinvestment(msg.sender, pending);\\n    // }\\n\\n    function forceWithdraw(\\n        uint _pool\\n    ) external nonReentrant whenNotPaused tenBlocks isNotContract {\\n        require(userCanwithdraw(msg.sender, _pool), \\\"User cannot withdraw\\\");\\n        require(_pool >= minPool && _pool <= poolsLength, \\\"Invalid pool\\\");\\n        require(\\n            block.timestamp >= users[_pool][msg.sender].unlockDate,\\n            \\\"Token is locked\\\"\\n        );\\n        uint toTransfer = users[_pool][msg.sender].investment;\\n        delete users[_pool][msg.sender].rewardLockedUp;\\n        delete users[_pool][msg.sender].investment;\\n        delete users[_pool][msg.sender].stakingValue;\\n        delete users[_pool][msg.sender].nextWithdraw;\\n        delete users[_pool][msg.sender].unlockDate;\\n        users[_pool][msg.sender].totalWithdrawn += toTransfer;\\n        delete users[_pool][msg.sender].depositCheckpoint;\\n        totalWithdrawn[_pool] += toTransfer;\\n        require(\\n            IERC20(pools[_pool].token).balanceOf(address(this)) >= toTransfer,\\n            \\\"Not enough tokens in contract\\\"\\n        );\\n        IERC20(pools[_pool].token).transfer(msg.sender, toTransfer);\\n    }\\n\\n    function getReward(\\n        uint _weis,\\n        uint _seconds,\\n        uint _pool\\n    ) public view returns (uint) {\\n        return\\n            (_weis * _seconds * pools[_pool].roi) /\\n            (TIME_STEP * PERCENT_DIVIDER);\\n    }\\n\\n    function userCanwithdraw(\\n        address user,\\n        uint _pool\\n    ) public view returns (bool) {\\n        if (block.timestamp > users[_pool][user].nextWithdraw) {\\n            if (users[_pool][user].stakingValue > 0) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    function getDeltaPendingRewards(\\n        address _user,\\n        uint _pool\\n    ) public view returns (uint) {\\n        if (users[_pool][_user].depositCheckpoint == 0) {\\n            return 0;\\n        }\\n        uint time = block.timestamp;\\n        if (stopProductionDate > 0 && time > stopProductionDate) {\\n            time = stopProductionDate;\\n        }\\n        return\\n            getReward(\\n                users[_pool][_user].stakingValue,\\n                time.sub(users[_pool][_user].depositCheckpoint),\\n                _pool\\n            );\\n    }\\n\\n    function getUserTotalPendingRewards(\\n        address _user,\\n        uint _pool\\n    ) public view returns (uint) {\\n        return\\n            users[_pool][_user].rewardLockedUp +\\n            getDeltaPendingRewards(_user, _pool);\\n    }\\n\\n    function updateDeposit(address _user, uint _pool) internal {\\n        users[_pool][_user].rewardLockedUp = getUserTotalPendingRewards(\\n            _user,\\n            _pool\\n        );\\n        users[_pool][_user].depositCheckpoint = block.timestamp;\\n    }\\n\\n    function getUser(\\n        address _user,\\n        uint _pool\\n    ) external view returns (UserInfo memory userInfo_, uint pendingRewards) {\\n        userInfo_ = users[_pool][_user];\\n        pendingRewards = getUserTotalPendingRewards(_user, _pool);\\n    }\\n\\n    function getAllUsers(uint _pool) external view returns (UserInfo[] memory) {\\n        UserInfo[] memory result = new UserInfo[](totalUsers);\\n        for (uint i = 0; i < totalUsers; i++) {\\n            result[i] = users[_pool][investors[_pool][i]];\\n        }\\n        return result;\\n    }\\n\\n    function getUserByIndex(\\n        uint _pool,\\n        uint _index\\n    ) external view returns (UserInfo memory) {\\n        require(_index < totalUsers, \\\"Index out of bounds\\\");\\n        return users[_pool][investors[_pool][_index]];\\n    }\\n\\n    function addPool(\\n        address _token,\\n        address _rewardToken,\\n        uint _minimumDeposit,\\n        uint roi,\\n        uint _fee,\\n        uint _referrerPercent,\\n        uint _requirePool,\\n        uint _requireAmount,\\n        uint _blockDuration\\n    ) external onlyOwner {\\n        poolsLength++;\\n        pools[poolsLength] = Pool({\\n            token: _token,\\n            rewardToken: _rewardToken,\\n            minimumDeposit: _minimumDeposit,\\n            roi: roi,\\n            fee: _fee,\\n            referrerPercent: _referrerPercent,\\n            rquirePool: _requirePool,\\n            requireAmount: _requireAmount,\\n            blockTimeStep: _blockDuration,\\n            isActived: true\\n        });\\n    }\\n\\n    function changeFee(uint _pool, uint _fee) external onlyOwner {\\n        require(_pool >= minPool && _pool <= poolsLength, \\\"Invalid pool\\\");\\n        pools[_pool].fee = _fee;\\n    }\\n\\n    function setRefPercent(uint _pool, uint _percent) external onlyOwner {\\n        require(_pool >= minPool && _pool <= poolsLength, \\\"Invalid pool\\\");\\n        require(_percent < PERCENT_DIVIDER, \\\"Invalid percent\\\");\\n        pools[_pool].referrerPercent = _percent;\\n    }\\n\\n    // function removePool(uint _pool) external onlyOwner {\\n    //     require(_pool >= minPool && _pool <= poolsLength, \\\"Invalid pool\\\");\\n    //     delete pools[_pool];\\n    // }\\n\\n    function setPoolStatus(uint _pool, bool _isActive) external onlyOwner {\\n        require(_pool >= minPool && _pool <= poolsLength, \\\"Invalid pool\\\");\\n        pools[_pool].isActived = _isActive;\\n    }\\n\\n    fallback() external payable {}\\n\\n    receive() external payable {}\\n\\n    function takeBNB() external onlyOperator {\\n        payable(msg.sender).transfer(address(this).balance);\\n    }\\n\\n    function takeTokens(address _token, uint _bal) external onlyOperator {\\n        IERC20(_token).transfer(msg.sender, _bal);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/stakingV2/StakingState.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\ncontract StakingState {\\n    address public devAddress;\\n    address public operatorAddress;\\n    mapping(uint => mapping(uint => address)) public investors;\\n    uint internal constant TIME_STEP = 1 days;\\n    uint internal constant HARVEST_DELAY = 1 days;\\n    uint internal constant BLOCK_TIME_STEP = 15 days;\\n    uint internal constant PERCENT_DIVIDER = 1000;\\n    uint internal constant REFERRER_PERCENTS = 50;\\n\\n    uint public initDate;\\n\\n    uint internal totalUsers;\\n    mapping(uint => uint) internal totalInvested;\\n    mapping(uint => uint) internal totalWithdrawn;\\n    mapping(uint => uint) internal totalReinvested;\\n    mapping(uint => uint) internal totalDeposits;\\n    mapping(uint => uint) internal totalReinvestCount;\\n    uint public stopProductionDate;\\n    bool public stopProductionVar;\\n    bool public referrer_is_allowed = true;\\n\\n    event Paused(address account);\\n    event Unpaused(address account);\\n\\n    modifier hasStoppedProduction() {\\n        require(hasStoppedProductionView(), \\\"Production is not stopped\\\");\\n        _;\\n    }\\n\\n    modifier hasNotStoppedProduction() {\\n        require(!hasStoppedProductionView(), \\\"Production is stopped\\\");\\n        _;\\n    }\\n\\n    function hasStoppedProductionView() public view returns (bool) {\\n        return stopProductionVar;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(devAddress == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    modifier onlyOperator() {\\n        require(\\n            operatorAddress == msg.sender,\\n            \\\"Ownable: caller is not the operator\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier whenNotPaused() {\\n        require(initDate > 0, \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    modifier whenPaused() {\\n        require(initDate == 0, \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    function stopProduction() external onlyOwner {\\n        stopProductionVar = true;\\n        stopProductionDate = block.timestamp;\\n    }\\n\\n    function unpause() external whenPaused onlyOwner {\\n        initDate = block.timestamp;\\n        emit Unpaused(msg.sender);\\n    }\\n\\n    function isPaused() public view returns (bool) {\\n        return initDate == 0;\\n    }\\n\\n    function getDAte() external view returns (uint) {\\n        return block.timestamp;\\n    }\\n\\n    function getPublicData(uint _pool)\\n        external\\n        view\\n        returns (\\n            uint totalUsers_,\\n            uint totalInvested_,\\n            uint totalDeposits_,\\n            uint totalReinvested_,\\n            uint totalReinvestCount_,\\n            uint totalWithdrawn_,\\n            bool isPaused_\\n        )\\n    {\\n        totalUsers_ = totalUsers;\\n        totalInvested_ = totalInvested[_pool];\\n        totalDeposits_ = totalDeposits[_pool];\\n        totalReinvested_ = totalReinvested[_pool];\\n        totalReinvestCount_ = totalReinvestCount[_pool];\\n        totalWithdrawn_ = totalWithdrawn[_pool];\\n        isPaused_ = isPaused();\\n    }\\n\\n    function getAllInvestors(\\n        uint _pool\\n    ) external view returns (address[] memory) {\\n        address[] memory investorsList = new address[](totalUsers);\\n        for (uint i = 0; i < totalUsers; i++) {\\n            investorsList[i] = investors[_pool][i];\\n        }\\n        return investorsList;\\n    }\\n\\n    function getInvestorByIndex(\\n        uint _pool,\\n        uint index\\n    ) external view returns (address) {\\n        require(index < totalUsers, \\\"Index out of range\\\");\\n        return investors[_pool][index];\\n    }\\n\\n    function setReferrerIsAllowed(\\n        bool _referrer_is_allowed\\n    ) external onlyOwner {\\n        referrer_is_allowed = _referrer_is_allowed;\\n    }\\n\\n    function changeOperator(\\n        address _operatorAddress\\n    ) external onlyOperator {\\n        operatorAddress = _operatorAddress;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_library\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_mWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"name\":\"FeePayed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ForceWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NewDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"Newbie\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RefBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Reinvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minimumDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roi\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_referrerPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_requirePool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_requireAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_blockDuration\",\"type\":\"uint256\"}],\"name\":\"addPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"changeFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operatorAddress\",\"type\":\"address\"}],\"name\":\"changeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractsLibrary\",\"outputs\":[{\"internalType\":\"contract IContractsLibraryStaking\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devFeeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"forceWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"getAllInvestors\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"getAllUsers\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"investment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardLockedUp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextWithdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositCheckpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"busdTotalDeposit\",\"type\":\"uint256\"}],\"internalType\":\"struct tokenStakingV2.UserInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDAte\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"getDeltaPendingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getInvestorByIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"getPublicData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalUsers_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalInvested_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposits_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalReinvested_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalReinvestCount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn_\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isPaused_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_weis\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_seconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"getReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"getUser\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"investment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardLockedUp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextWithdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositCheckpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"busdTotalDeposit\",\"type\":\"uint256\"}],\"internalType\":\"struct tokenStakingV2.UserInfo\",\"name\":\"userInfo_\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"pendingRewards\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getUserByIndex\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"investment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardLockedUp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextWithdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositCheckpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"busdTotalDeposit\",\"type\":\"uint256\"}],\"internalType\":\"struct tokenStakingV2.UserInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"getUserTotalPendingRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hasStoppedProductionView\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"invest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"investors\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operatorAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pools\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minimumDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roi\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referrerPercent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rquirePool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requireAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockTimeStep\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActived\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referrer_is_allowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_devFeeAddress\",\"type\":\"address\"}],\"name\":\"setDevFeeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isActive\",\"type\":\"bool\"}],\"name\":\"setPoolStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_percent\",\"type\":\"uint256\"}],\"name\":\"setRefPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_referrer_is_allowed\",\"type\":\"bool\"}],\"name\":\"setReferrerIsAllowed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_mWallet\",\"type\":\"address\"}],\"name\":\"setmWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oWallet\",\"type\":\"address\"}],\"name\":\"setoWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopProduction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopProductionDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopProductionVar\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"takeBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_bal\",\"type\":\"uint256\"}],\"name\":\"takeTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"userCanwithdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"investment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakingValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardLockedUp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextWithdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositCheckpoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"busdTotalDeposit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pool\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "tokenStakingV2", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "000000000000000000000000391e8447dc03c973230e4c388f611e546d63e1fe00000000000000000000000083d3c2d1a55687498df6800c5f173ec6a7556089000000000000000000000000afeb4d20c1877d501f0fa7f13d37566b05f3c5da00000000000000000000000007f7afb8831456039078328741e07b865391d4be0000000000000000000000004be8d2fec7b081cce9f42f111516c5f7cebab470", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}