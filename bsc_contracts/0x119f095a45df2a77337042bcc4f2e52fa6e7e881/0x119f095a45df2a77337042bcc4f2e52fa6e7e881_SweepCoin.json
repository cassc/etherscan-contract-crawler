{"SourceCode": "{\"Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.1;\\n\\nlibrary Address {\\n    function isContract(address account) internal view returns (bool) {\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != accountHash \\u0026\\u0026 codehash != 0x0);\\n    }\\n\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\n        (bool success, ) =recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n}\\n\"},\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.1;\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this;\\n        return msg.data;\\n    }\\n}\\n\"},\"ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\u0027./IERC165.sol\\u0027;\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"},\"ERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./Address.sol\\\";\\nimport \\\"./Context.sol\\\";\\nimport \\\"./Strings.sol\\\";\\nimport \\\"./ERC165.sol\\\";\\n\\n\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 =\\u003e address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping(address =\\u003e uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 =\\u003e address) private _tokenApprovals;\\n\\n    //\u5730\u5740\u6240\u6709\u7684tokenID  address =\\u003e tokenids\\n    mapping(address =\\u003e uint256[]) private _ownerTokens;\\n\\n\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address =\\u003e mapping(address =\\u003e bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n        interfaceId == type(IERC721).interfaceId ||\\n        interfaceId == type(IERC721Metadata).interfaceId ||\\n        super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _owners[tokenId];\\n        require(owner != address(0), \\\"ERC721: owner query for nonexistent token\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length \\u003e 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overriden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _owners[tokenId] != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ERC721.ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _mint(to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, _data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n        require(tokenId \\u003e 0, \\\"ERC721: Illegal tokenId\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        _modifyOwnerTokens(address(0), to, tokenId);\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721.ownerOf(tokenId);\\n\\n        _modifyOwnerTokens(owner, address(0), tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        _balances[owner] -= 1;\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _balances[from] -= 1;\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        _modifyOwnerTokens(from, to, tokenId);\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    function ownerTokens(address owner_) public view returns (uint256 [] memory){\\n        return _ownerTokens[owner_];\\n    }\\n\\n\\n    function _modifyOwnerTokens(address from_, address to_, uint256 tokenId_) internal virtual {\\n        // _ownerTokens  address =\\u003e  tokenId [ 1,2,3,4]\\n        require(_exists(tokenId_), \\\"ERC721: token already minted\\\");\\n        if (from_ != address(0) \\u0026\\u0026 !from_.isContract()) {\\n            uint256 [] memory tempTokens = _ownerTokens[from_];\\n            _ownerTokens[from_] = [0];\\n            for (uint8 i = 0; i \\u003c tempTokens.length; i++) {\\n                if (tempTokens[i] != tokenId_ \\u0026\\u0026 tempTokens[i] != 0) {\\n                    _ownerTokens[from_].push(tempTokens[i]);\\n                }\\n            }\\n        }\\n\\n        if (to_ != address(0) \\u0026\\u0026 !to_.isContract()) {\\n            _ownerTokens[to_].push(tokenId_);\\n        }\\n\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits a {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits a {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(\\n        address owner,\\n        address operator,\\n        bool approved\\n    ) internal virtual {\\n        require(owner != operator, \\\"ERC721: approve to caller\\\");\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``\\u0027s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``\\u0027s `tokenId` will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n}\\n\"},\"ERC721Enumerable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.1;\\n\\nimport \\\"./ERC721.sol\\\";\\nimport \\\"./IERC721Enumerable.sol\\\";\\n\\n/**\\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\\n * enumerability of all the token ids in the contract as well as all token ids owned by each\\n * account.\\n */\\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\\n    // Mapping from owner to list of owned token IDs\\n    mapping(address =\\u003e mapping(uint256 =\\u003e uint256)) private _ownedTokens;\\n\\n    // Mapping from token ID to index of the owner tokens list\\n    mapping(uint256 =\\u003e uint256) private _ownedTokensIndex;\\n\\n    // Array with all token ids, used for enumeration\\n    uint256[] private _allTokens;\\n\\n    // Mapping from token id to position in the allTokens array\\n    mapping(uint256 =\\u003e uint256) private _allTokensIndex;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\\n        require(index \\u003c ERC721.balanceOf(owner), \\\"ERC721Enumerable: owner index out of bounds\\\");\\n        return _ownedTokens[owner][index];\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _allTokens.length;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenByIndex}.\\n     */\\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\\n        require(index \\u003c ERC721Enumerable.totalSupply(), \\\"ERC721Enumerable: global index out of bounds\\\");\\n        return _allTokens[index];\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``\\u0027s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``\\u0027s `tokenId` will be burned.\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual override {\\n        super._beforeTokenTransfer(from, to, tokenId);\\n\\n        if (from == address(0)) {\\n            _addTokenToAllTokensEnumeration(tokenId);\\n        } else if (from != to) {\\n            _removeTokenFromOwnerEnumeration(from, tokenId);\\n        }\\n        if (to == address(0)) {\\n            _removeTokenFromAllTokensEnumeration(tokenId);\\n        } else if (to != from) {\\n            _addTokenToOwnerEnumeration(to, tokenId);\\n        }\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension\\u0027s ownership-tracking data structures.\\n     * @param to address representing the new owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\\n     */\\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\\n        uint256 length = ERC721.balanceOf(to);\\n        _ownedTokens[to][length] = tokenId;\\n        _ownedTokensIndex[tokenId] = length;\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension\\u0027s token tracking data structures.\\n     * @param tokenId uint256 ID of the token to be added to the tokens list\\n     */\\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\\n        _allTokensIndex[tokenId] = _allTokens.length;\\n        _allTokens.push(tokenId);\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension\\u0027s ownership-tracking data structures. Note that\\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\\n     * @param from address representing the previous owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\\n     */\\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\\n        // To prevent a gap in from\\u0027s tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n\\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary\\n        if (tokenIndex != lastTokenIndex) {\\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\\n\\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token\\u0027s index\\n        }\\n\\n        // This also deletes the contents at the last position of the array\\n        delete _ownedTokensIndex[tokenId];\\n        delete _ownedTokens[from][lastTokenIndex];\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension\\u0027s token tracking data structures.\\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\\n     */\\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n\\n        uint256 lastTokenIndex = _allTokens.length - 1;\\n        uint256 tokenIndex = _allTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\\n        // an \\u0027if\\u0027 statement (like in _removeTokenFromOwnerEnumeration)\\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\\n\\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token\\u0027s index\\n\\n        // This also deletes the contents at the last position of the array\\n        delete _allTokensIndex[tokenId];\\n        _allTokens.pop();\\n    }\\n}\\n\"},\"IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"},\"IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``\\u0027s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"},\"IERC721Enumerable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.1;\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``\\u0027s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.1;\\n\\nimport \\\"./Context.sol\\\";\\n\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor() {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"},\"SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.1;\\n\\nimport \\\"./Address.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(ERC20 token, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    function safeApprove(ERC20 token, address spender, uint256 value) internal {\\n        require((value == 0) || (token.allowance(address(this), spender) == 0), \\\"SafeERC20: approve from non-zero to non-zero allowance\\\");\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(ERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(ERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function callOptionalReturn(ERC20 token, bytes memory data) private {\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length \\u003e 0) {\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\\ninterface ERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.1;\\n\\nlibrary SafeMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        uint256 c = a - b;\\n        return c;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003e 0, errorMessage);\\n        uint256 c = a / b;\\n        return c;\\n    }\\n\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"},\"Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI\\u0027s implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp \\u003e\\u003e= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i \\u003e 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value \\u0026 0xf];\\n            value \\u003e\\u003e= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"},\"SweepCoin.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.1;\\n\\nimport \\u0027./SafeMath.sol\\u0027;\\nimport \\u0027./SweepCoinAirdrop.sol\\u0027;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address who) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\ncontract SweepCoin is IERC20 {\\n    using SafeMath for uint256;\\n\\n    uint256   private _decimals;\\n    string  private _name;\\n    string  private _symbol;\\n    uint256 internal _totalSupply;\\n\\n    address private _owner;\\n    uint256 public _burnValue;\\n    mapping(address =\\u003e uint256) public _burnValueMap;\\n\\n    SweepCoinAirdrop private Airdrop;\\n    bool private is_airdrop_init = false;\\n\\n\\n    constructor (uint256 totalSupply_, string memory name_, uint256 decimals_, string memory symbol_)  {\\n        _decimals = decimals_;\\n        _totalSupply = totalSupply_.mul(10 ** uint256(_decimals));\\n        _balances[msg.sender] = totalSupply_.mul(10 ** uint256(_decimals));\\n        _name = name_;\\n        _symbol = symbol_;\\n        _owner = msg.sender;\\n    }\\n\\n    /**\\n    * @return the name of the token.\\n    */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n    * @return the symbol of the token.\\n    */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n  * @return the number of decimals of the token.\\n  */\\n    function decimals() public view returns (uint256) {\\n        return _decimals;\\n    }\\n\\n\\n    mapping(address =\\u003e uint256) internal _balances;\\n\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) private _allowed;\\n\\n\\n    function balanceOf(address target_address) override public view returns (uint256) {\\n        return _balances[target_address];\\n    }\\n\\n    function canUseBalanceOf(address target_address)  public view returns (uint256) {\\n        return _balances[target_address].sub(airdropBalanceOf(target_address));\\n    }\\n\\n    function airdropBalanceOf(address target_address) public view returns (uint256) {\\n        uint256 airdrop_balance = 0;\\n        if (is_airdrop_init) airdrop_balance = Airdrop.airdropBalances(target_address);\\n        return airdrop_balance;\\n    }\\n\\n\\n    /**\\n    * @dev Total number of tokens in existence\\n    */\\n    function totalSupply() override public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function allowance(address owner, address spender) override public view returns (uint256) {\\n        return _allowed[owner][spender];\\n    }\\n\\n    function transfer(address to, uint256 value) override public returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    function burnToZero(address from, uint256 value) public returns (bool) {\\n\\n        require(value \\u003e 0, \\\"amount must be greater than 0\\\");\\n\\n        require(value \\u003c= _allowed[from][msg.sender]);\\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\\n\\n        address to = address(0);\\n        _burnValue = _burnValue.add(value);\\n        _burnValueMap[from] = _burnValueMap[from] .add(value);\\n\\n        uint256 airdrop_balance = airdropBalanceOf(from);\\n        require(value \\u003c= (_balances[from].sub(airdrop_balance)), \\u0027Insufficient account balance\\u0027);\\n        _balances[from] = _balances[from].sub(value);\\n        _balances[to] = _balances[to].add(value);\\n\\n        emit Transfer(from, to, value);\\n        return true;\\n    }\\n\\n\\n    function approve(address spender, uint256 value) override public returns (bool) {\\n        require(value \\u003e 0, \\\"amount must be greater than 0\\\");\\n        require(spender != address(0));\\n        _allowed[msg.sender][spender] = value;\\n        emit Approval(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    function transferFrom(address from, address to, uint256 value) override public returns (bool) {\\n        require(value \\u003e 0, \\\"amount must be greater than 0\\\");\\n        require(value \\u003c= _allowed[from][msg.sender]);\\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n        require(addedValue \\u003e 0, \\\"amount must be greater than 0\\\");\\n        require(spender != address(0));\\n        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));\\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n        require(subtractedValue \\u003e 0, \\\"amount must be greater than 0\\\");\\n        require(spender != address(0));\\n        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));\\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\\n        return true;\\n    }\\n\\n    function _transfer(address from, address to, uint256 value) internal {\\n        require(value \\u003e 0, \\\"amount must be greater than 0\\\");\\n        require(to != address(0));\\n        uint256 airdrop_balance = airdropBalanceOf(from);\\n        require(value \\u003c= (_balances[from].sub(airdrop_balance)), \\u0027Insufficient account balance\\u0027);\\n        _balances[from] = _balances[from].sub(value);\\n        _balances[to] = _balances[to].add(value);\\n        emit Transfer(from, to, value);\\n    }\\n\\n\\n    function setAirdopToken(address airdrop_address) public {\\n        require(address(msg.sender) == _owner, \\\"Insufficient permissions\\\");\\n        Airdrop = SweepCoinAirdrop(airdrop_address);\\n        is_airdrop_init = true;\\n    }\\n\\n    function isSetAirdopToken() public view returns (bool) {\\n        return is_airdrop_init;\\n    }\\n\\n\\n}\\n\\n\\n\"},\"SweepCoinAirdrop.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.1;\\n\\nimport \\\"./Address.sol\\\";\\nimport \\u0027./SafeMath.sol\\u0027;\\nimport \\\"./SweepCoin.sol\\\";\\nimport \\\"./SweepCoinEcologyPool.sol\\\";\\n\\n\\ncontract SweepCoinAirdrop {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    address private _owner;\\n    SweepCoin private _Token;\\n    SweepCoinEcologyPool private _EcologyPool;\\n\\n    struct AirdropItem {\\n        address _address;\\n        uint256 _starttime;\\n        uint256 _endtime;\\n        uint256 _value;\\n        uint8 _day;\\n    }\\n\\n    //Transfer of account airdrop balance is prohibited\\n    mapping(address =\\u003e AirdropItem)  private _airdrop_balances;\\n    uint256 public airdropTotal;\\n\\n    constructor (address tokenAddress, address ecologypoolAddress)  {\\n        _owner = msg.sender;\\n        _Token = SweepCoin(tokenAddress);\\n        _EcologyPool = SweepCoinEcologyPool(ecologypoolAddress);\\n    }\\n\\n\\n    function airdropBalances(address to) public view returns (uint256) {\\n        if (_airdrop_balances[to]._address == address(0)) return 0;\\n        if (_airdrop_balances[to]._endtime \\u003c= block.timestamp) return 0;\\n        return _airdrop_balances[to]._value;\\n    }\\n\\n\\n    function airdropInfo(address to) public view returns (AirdropItem memory) {\\n        return _airdrop_balances[to];\\n    }\\n\\n\\n    function unlockAirdrop(address target) public {\\n        require(address(msg.sender) == address(tx.origin), \\\"no contract\\\");\\n        require(address(msg.sender) == _owner, \\\"only owner  can transfer money \\\");\\n        require(address(msg.sender) != target, \\\"You can\\u0027t transfer money to yourself\\\");\\n        require(_airdrop_balances[target]._address != address(0), \\\"Lock record not found\\\");\\n        require(_airdrop_balances[target]._endtime \\u003e block.timestamp, \\\"Data unlocked, do not repeat\\\");\\n        _airdrop_balances[target]._endtime = 0;\\n    }\\n\\n\\n    function sendAirdrop(address to, uint8 lockDay, uint256 value_, address master) public returns (uint256){\\n        require(address(msg.sender) == address(tx.origin), \\\"no contract\\\");\\n        require(address(msg.sender) == _owner, \\\"only owner  can transfer money \\\");\\n        require(address(msg.sender) != to, \\\"You can\\u0027t transfer money to yourself\\\");\\n        require(to != master, \\\"Cannot bind from\\\");\\n        require(!to.isContract(), \\\"no contract !!\\\");\\n        require(_owner != to, \\\"Cannot transfer to administrator\\\");\\n        require(_Token.isSetAirdopToken() == true, \\u0027Token airdrop information not initialized\\u0027);\\n\\n        uint256 now_time = block.timestamp;\\n\\n        uint256 value = value_.mul(10 ** uint256(_Token.decimals()));\\n        uint256 endtime = now_time + 3600 * 24 * lockDay;\\n        require(value \\u003e 0, \\\"Amount must be greater than 0\\\");\\n        require(_airdrop_balances[to]._address == address(0), \\\"Airdrop record already exists\\\");\\n        require(_Token.canUseBalanceOf(address(this)) \\u003e= value_, \\u0027Insufficient contract address balance\\u0027);\\n\\n        _airdrop_balances[to] = AirdropItem(to, now_time, endtime, value, lockDay);\\n        _Token.transfer(to, value);\\n\\n        _EcologyPool.bindApprentice(master, to);\\n\\n\\n        airdropTotal = airdropTotal.add(value);\\n\\n        return value;\\n    }\\n\\n\\n    function sendAirdropBatch(address[] memory tos, uint8 lockDay, uint256 value_, address[] memory masters) public returns (uint256){\\n        require(address(msg.sender) == _owner, \\\"only owner can transfer money \\\");\\n        require(tos.length == masters.length, \\\"only owner can transfer money \\\");\\n        uint256 value = value_.mul(10 ** uint256(_Token.decimals()));\\n\\n        uint256 total_value = 0;\\n\\n        for (uint8 i = 0; i \\u003c tos.length; i++) {\\n            total_value = total_value.add(value);\\n        }\\n\\n        require(_Token.canUseBalanceOf(address(this)) \\u003e= total_value, \\u0027Insufficient contract address balance\\u0027);\\n\\n\\n        for (uint8 i = 0; i \\u003c tos.length; i++) {\\n            address to = tos[i];\\n            sendAirdrop(to, lockDay, value_, masters[i]);\\n        }\\n\\n        return total_value;\\n    }\\n\\n\\n}\\n\"},\"SweepCoinEcologyPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.1;\\n\\nimport \\u0027./SafeMath.sol\\u0027;\\nimport \\\"./SweepCoin.sol\\\";\\nimport \\\"./SweepNFT.sol\\\";\\n\\n\\ncontract SweepCoinEcologyPool {\\n    using SafeMath for uint256;\\n\\n    address  private _owner;\\n    SweepCoin private _Token;\\n    SweepNFT private _NFT;\\n    address public airdropAddress;\\n\\n    address public miningAddress;\\n\\n\\n    // User level direct and indirect 1000% specific revenue\\n    struct LevelInfo {\\n        uint8 lv;\\n        uint256 direct_active_rate;\\n        uint256 indirect_active_rate;\\n        uint256 direct_extract_rate;\\n        uint256 indirect_extract_rate;\\n    }\\n\\n    mapping(uint8 =\\u003e LevelInfo)  private levelList;\\n\\n    // apprentices =\\u003e master\\n    mapping(address =\\u003e address)  private masterRelationship;\\n    // Number of apprentices\\n    mapping(address =\\u003e address[])  private apprentices;\\n    //Level of address\\n    mapping(address =\\u003e LevelInfo)  private addressLvs;\\n\\n\\n    uint256 private totalWithdraw =0;\\n    // aready Withdrawn rewards\\n    mapping(address =\\u003e uint256)  private withdrawList;\\n\\n    uint256 private totalUnWithdraw =0;\\n    //Rewards to be withdrawn\\n    mapping(address =\\u003e uint256)  private unwithdrawList;\\n    //NFT activation record\\n    mapping(uint256 =\\u003e uint256)  private nftActiveList;\\n\\n\\n    constructor (address coinAddress, address nftAddress)  {\\n        _owner = msg.sender;\\n        _Token = SweepCoin(coinAddress);\\n        _NFT = SweepNFT(nftAddress);\\n\\n        for (uint8 i = 1; i \\u003c= 5; i++) {\\n            levelList[i] = LevelInfo(i, 0, 0, 0, 0);\\n        }\\n    }\\n\\n    // What needs to be done in the first step of releasing the contract\\n    function setAirdropAddress(address target) public {\\n        require(address(msg.sender) == _owner, \\\"Insufficient permissions\\\");\\n        airdropAddress = target;\\n    }\\n\\n\\n    function setMiningAddress(address target) public {\\n        require(address(msg.sender) == _owner, \\\"Insufficient permissions\\\");\\n        miningAddress = target;\\n    }\\n\\n\\n\\n    function updateLevelInfo(uint8 lv_,\\n        uint256 direct_active_rate_, uint256 indirect_active_rate_,\\n        uint256 direct_extract_rate_, uint256 indirect_extract_rate_\\n    ) public {\\n        require(address(msg.sender) == _owner, \\\"Insufficient permissions\\\");\\n        require(levelList[lv_].lv \\u003e 0, \\\"Illegal parameter\\\");\\n        levelList[lv_] = LevelInfo(lv_, direct_active_rate_, indirect_active_rate_, direct_extract_rate_, indirect_extract_rate_);\\n    }\\n\\n\\n    function levelInfo(uint8 lv_) public view returns (LevelInfo memory){\\n        return levelList[lv_];\\n    }\\n\\n\\n    function setAddressLv(address target, uint8 lv_) public {\\n        require(address(msg.sender) == _owner, \\\"Insufficient permissions\\\");\\n        require(levelList[lv_].lv \\u003e 0, \\\"Illegal parameter\\\");\\n        addressLvs[target] = levelList[lv_];\\n    }\\n\\n\\n    function getAddressLv(address target) public view returns (LevelInfo memory) {\\n        LevelInfo memory info = addressLvs[target];\\n\\n        if (info.lv == 0) return levelList[1];\\n\\n        return info;\\n    }\\n\\n\\n    function getMaster(address target) public view returns (address) {\\n        return masterRelationship[target];\\n    }\\n\\n    function apprenticeNum(address target) public view returns (uint256) {\\n        return apprentices[target].length;\\n    }\\n\\n\\n\\n    function nftActiveTime(uint256 tokenId) public view returns (uint256) {\\n        return nftActiveList[tokenId];\\n    }\\n\\n\\n    function bindApprentice(address master, address apprentice) public {\\n        require(msg.sender == airdropAddress, \\u0027No permission to call\\u0027);\\n        require(master != apprentice, \\u0027Cannot bind from\\u0027);\\n\\n        require(masterRelationship[apprentice] == address(0),\\u0027Relationship already bound\\u0027);\\n\\n        if (masterRelationship[apprentice] == master) return;\\n\\n\\n        masterRelationship[apprentice] = master;\\n        apprentices[master].push(apprentice);\\n    }\\n\\n\\n    function apprenticeAddressByIndex(address master,uint256 index_) public view returns(address) {\\n        require(index_ \\u003c apprentices[master].length,\\u0027global index out of bounds\\u0027);\\n        return  apprentices[master][index_];\\n    }\\n\\n\\n    // Award master\\n    function awardMaster(address target,uint256 amount) public{\\n\\n        require(miningAddress  == msg.sender,\\u0027Contract is required to call\\u0027);\\n        require(amount \\u003e 0,\\u0027Withdrawal amount must be greater than 0\\u0027);\\n\\n        address directMaster = masterRelationship[target];\\n\\n        if (directMaster != address(0)) {\\n\\n            LevelInfo memory directInfo = getAddressLv(directMaster);\\n\\n            uint256 directValue = directInfo.direct_active_rate.mul(amount).div(1000);\\n            unwithdrawList[directMaster] = unwithdrawList[directMaster].add(directValue);\\n\\n            totalUnWithdraw =  totalUnWithdraw.add(directValue) ;\\n\\n        }\\n\\n        //inDirect reward Master reward\\n        if (masterRelationship[directMaster] != address(0)) {\\n            address inDirectMaster = masterRelationship[directMaster];\\n            LevelInfo memory indirectInfo = getAddressLv(inDirectMaster);\\n\\n            uint256 indirectValue = indirectInfo.indirect_active_rate.mul(amount).div(1000);\\n            unwithdrawList[inDirectMaster] = unwithdrawList[inDirectMaster].add(indirectValue);\\n\\n            totalUnWithdraw =  totalUnWithdraw.add(indirectValue);\\n        }\\n\\n    }\\n\\n\\n\\n    //Activate NFT rewards\\n    function activateNFT(uint256 tokenId) public {\\n        if (msg.sender != address(_NFT)) return;\\n        address tokenOwner = _NFT.ownerOf(tokenId);\\n        if (tokenOwner == address(0)) return;\\n\\n        SweepNFT.NFTData memory nft = _NFT.getTokenData(tokenId);\\n        if (nft.tokenId != tokenId) return;\\n\\n        if (nftActiveList[tokenId] \\u003e 0) return;\\n\\n\\n        if (masterRelationship[tokenOwner] == address(0)) return;\\n\\n        nftActiveList[tokenId] = block.timestamp;\\n\\n        uint256 nft_coin = nft.coin;\\n        // Direct reward Master reward\\n        address directMaster = masterRelationship[tokenOwner];\\n\\n\\n        if (directMaster != address(0)) {\\n            LevelInfo memory directInfo = getAddressLv(directMaster);\\n\\n            uint256 directValue = directInfo.direct_active_rate.mul(nft_coin).div(1000);\\n            unwithdrawList[directMaster] = unwithdrawList[directMaster].add(directValue);\\n\\n            totalUnWithdraw =  totalUnWithdraw.add(directValue) ;\\n        }\\n\\n        //inDirect reward Master reward\\n        if (masterRelationship[directMaster] != address(0)) {\\n            address inDirectMaster = masterRelationship[directMaster];\\n            LevelInfo memory indirectInfo = getAddressLv(inDirectMaster);\\n\\n            uint256 indirectValue = indirectInfo.indirect_active_rate.mul(nft_coin).div(1000);\\n            unwithdrawList[inDirectMaster] = unwithdrawList[inDirectMaster].add(indirectValue);\\n\\n            totalUnWithdraw =  totalUnWithdraw.add(indirectValue);\\n        }\\n\\n    }\\n\\n\\n\\n    function withdrawCoin(address target) public view returns (uint256){\\n        uint256 value = withdrawList[target];\\n        return value;\\n    }\\n\\n\\n    function unWithdrawCoin(address target) public view returns (uint256){\\n        uint256 value = unwithdrawList[target];\\n        return value;\\n    }\\n\\n\\n    function withdraw() public {\\n        require(address(msg.sender) == address(tx.origin), \\\"no contract\\\");\\n        uint256 value = unwithdrawList[msg.sender];\\n        require(value \\u003e 0, \\u0027Withdrawal amount must be greater than 0\\u0027);\\n\\n        _Token.transfer(msg.sender, value);\\n        withdrawList[msg.sender] = withdrawList[msg.sender].add(value);\\n        unwithdrawList[msg.sender] =0;\\n        totalWithdraw = totalWithdraw.add(value);\\n        totalUnWithdraw = totalUnWithdraw.sub(value);\\n    }\\n\\n}\\n\"},\"SweepCoinMiningPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.1;\\n\\nimport \\u0027./SafeMath.sol\\u0027;\\nimport \\\"./SweepCoin.sol\\\";\\nimport \\\"./SweepNFT.sol\\\";\\nimport \\\"./SweepCoinEcologyPool.sol\\\";\\n\\n\\ncontract SweepCoinMiningPool {\\n    using SafeMath for uint256;\\n\\n    address public _owner;\\n    SweepCoin private _Token;\\n    SweepNFT private _NFT;\\n    SweepCoinEcologyPool private _EcologyPool;\\n    address public ecologyPoolAddress;\\n\\n\\n    bool private isStart = false;\\n    //Final force\\n    uint256 private lpSupply = 0;\\n\\n    // Number of coins produced per second\\n    uint256 public speed;\\n    //Update time of recording pledge or redemption\\n    uint256 public lastRewardTime;\\n    // Record the average number of outputs per second\\n    uint256 public accTokenPerShare;\\n\\n    uint256 private _totalToken;\\n    mapping(address =\\u003e uint256) private _ownerPow;\\n    mapping(address =\\u003e uint256) private _ownerToken;\\n\\n    struct MiningData {\\n        uint256 tokenId;\\n        uint256 coin;\\n        uint256 lp;\\n        uint256 rewardDebt;\\n        uint256 time;\\n        address owner;\\n    }\\n\\n\\n    //pledge record   tokenId =\\u003e  MiningData\\n    mapping(uint256 =\\u003e MiningData)  private miningList;\\n\\n\\n    // all pledge tokens\\n    uint256[] private allPledgeTokendIds;\\n    // all token  position\\n    mapping(uint256 =\\u003e uint256) private allTokenIdIndex;\\n    // address  -\\u003e [tokenId,tokenId]\\n    mapping(address =\\u003e uint256[]) private ownedTokens;\\n    mapping(uint256 =\\u003e uint256) private ownedTokenIndex;\\n\\n\\n\\n    constructor (address coinAddress, address nftAddress)  {\\n        _owner = msg.sender;\\n        _Token = SweepCoin(coinAddress);\\n        _NFT = SweepNFT(nftAddress);\\n    }\\n\\n    function startStatus() public view returns (bool) {\\n        return isStart;\\n    }\\n\\n\\n    function setStartStatus(bool isStart_) public {\\n        require(msg.sender == _owner, \\u0027Only owner  have permissions\\u0027);\\n        isStart = isStart_;\\n        if (isStart_ == false) {\\n            updateSpeed(0);\\n        }\\n    }\\n\\n    function updateSpeed(uint256 speed_) public {\\n        require(msg.sender == _owner, \\u0027Only owner  have permissions\\u0027);\\n        require(speed_ \\u003e= 0, \\u0027Illegal parameter\\u0027);\\n\\n        uint256 now_time = block.timestamp;\\n        if (lpSupply \\u003e 0 \\u0026\\u0026 lastRewardTime \\u003e 0) {\\n            uint256 total = now_time.sub(lastRewardTime).mul(speed).mul(1000);\\n            uint256 _accTokenPerShare = total.div(lpSupply);\\n            accTokenPerShare = accTokenPerShare.add(_accTokenPerShare);\\n            lastRewardTime = now_time;\\n        }\\n\\n        speed = speed_;\\n    }\\n\\n\\n    function setEcologyPool(address ecologyPoolAddress_) public {\\n        ecologyPoolAddress = ecologyPoolAddress_;\\n        _EcologyPool = SweepCoinEcologyPool(ecologyPoolAddress_);\\n    }\\n\\n\\n    function pledgeInfo(uint256 tokenId_) public view returns (MiningData memory){\\n        return miningList[tokenId_];\\n    }\\n\\n    function increasePledge(uint256 tokenId_, uint256 value) public {\\n        require(address(msg.sender) == address(tx.origin), \\\"no contract\\\");\\n        require(isStart == true, \\u0027The ore pool is not opened\\u0027);\\n        require(_Token.canUseBalanceOf(msg.sender) \\u003e= value, \\u0027Insufficient account balance\\u0027);\\n        SweepNFT.NFTData memory nft = _NFT.getTokenData(tokenId_);\\n        require(nft.tokenId == tokenId_, \\u0027Illegal parameter\\u0027);\\n\\n\\n        uint256 now_time = block.timestamp;\\n\\n\\n        //Increased computational power\\n        uint256 lp = 0;\\n        if (miningList[tokenId_].tokenId == 0) {\\n            require(msg.sender == _NFT.ownerOf(tokenId_), \\u0027NFT does not belong to you\\u0027);\\n            require(value == 0, \\u0027Illegal parameter\\u0027);\\n\\n            _addPledgeTokend(tokenId_);\\n\\n            lp = nft.coin.add(value);\\n            lp = lp.mul(nft.lucky).div(100).add(lp);\\n\\n            miningList[tokenId_] = MiningData(tokenId_, value, lp, 0, now_time, msg.sender);\\n            _NFT.transferFrom(msg.sender, address(this), tokenId_);\\n\\n        } else {\\n            MiningData storage mining = miningList[tokenId_];\\n            require(address(this) == _NFT.ownerOf(tokenId_), \\u0027NFT does not belong to you\\u0027);\\n            require(mining.owner == msg.sender, \\u0027Illegal parameter\\u0027);\\n\\n            require(value \\u003e 0, \\u0027Illegal parameter\\u0027);\\n\\n            mining.coin = mining.coin.add(value);\\n            uint256 nftLP = nft.coin.add(mining.coin);\\n            nftLP = nftLP.mul(nft.lucky).div(100).add(nftLP);\\n            lp = nftLP.sub(mining.lp);\\n            mining.lp = nftLP;\\n        }\\n\\n        _ownerPow[msg.sender] = _ownerPow[msg.sender].add(lp);\\n\\n        _totalToken = _totalToken.add(value);\\n        _ownerToken[msg.sender] = _ownerToken[msg.sender].add(value);\\n\\n\\n        if (lastRewardTime == 0) lastRewardTime = now_time;\\n        uint256 total = now_time.sub(lastRewardTime).mul(speed).mul(1000);\\n        uint256 _accTokenPerShare = 0;\\n        if (lpSupply == 0) {\\n            _accTokenPerShare = total.div(lp);\\n        } else {\\n            _accTokenPerShare = total.div(lpSupply);\\n        }\\n\\n        accTokenPerShare = accTokenPerShare.add(_accTokenPerShare);\\n        uint256 rewardDebt = lp.mul(accTokenPerShare).div(1000);\\n        miningList[tokenId_].rewardDebt = miningList[tokenId_].rewardDebt.add(rewardDebt);\\n\\n        lastRewardTime = now_time;\\n        lpSupply = lpSupply.add(lp);\\n\\n        if (value \\u003e 0) {\\n            _Token.transferFrom(msg.sender, address(this), value);\\n        }\\n\\n    }\\n\\n\\n    function reducePledge(uint256 tokenId_, uint256 value) public {\\n        require(address(msg.sender) == address(tx.origin), \\\"no contract\\\");\\n        MiningData storage mining = miningList[tokenId_];\\n\\n        uint256 now_time = block.timestamp;\\n\\n        require(msg.sender == mining.owner, \\u0027NFT does not belong to you\\u0027);\\n        require(address(this) == _NFT.ownerOf(mining.tokenId), \\u0027NFT does not belong to contract\\u0027);\\n\\n        require(value \\u003e 0, \\u0027Illegal data\\u0027);\\n\\n        require(mining.coin \\u003e= value, \\u0027Insufficient pledge amount\\u0027);\\n\\n        _totalToken = _totalToken.sub(value);\\n        _ownerToken[msg.sender] = _ownerToken[msg.sender].sub(value);\\n\\n        SweepNFT.NFTData memory nft = _NFT.getTokenData(tokenId_);\\n\\n\\n        // nft.coin + mining.coin + (nft.coin + mining.coin)*lucky\\n\\n        mining.coin = mining.coin.sub(value);\\n        uint256 nftLP = nft.coin.add(mining.coin);\\n        nftLP = nftLP.mul(nft.lucky).div(100).add(nftLP);\\n        uint256 reduce_lp = mining.lp.sub(nftLP);\\n\\n        _ownerPow[msg.sender] = _ownerPow[msg.sender].sub(reduce_lp);\\n\\n        mining.lp = nftLP;\\n\\n        uint256 total = now_time.sub(lastRewardTime).mul(speed).mul(1000);\\n        uint256 _accTokenPerShare = 0;\\n        if (lpSupply \\u003e 0) {\\n            _accTokenPerShare = total.div(lpSupply);\\n        }\\n        accTokenPerShare = accTokenPerShare.add(_accTokenPerShare);\\n\\n        uint256 rewardDebt = reduce_lp.mul(accTokenPerShare).div(1000);\\n        mining.rewardDebt = mining.rewardDebt.sub(rewardDebt);\\n\\n        lastRewardTime = now_time;\\n        lpSupply = lpSupply.sub(reduce_lp);\\n        //\u8f6c\u79fb\u4ee3\u5e01\\n        _Token.transfer(msg.sender, value);\\n\\n    }\\n\\n\\n    function cancelPledge(uint256 tokenId_) public {\\n        require(address(msg.sender) == address(tx.origin), \\\"no contract\\\");\\n        MiningData storage mining = miningList[tokenId_];\\n\\n        require(msg.sender == mining.owner, \\u0027NFT does not belong to you\\u0027);\\n        require(address(this) == _NFT.ownerOf(mining.tokenId), \\u0027NFT does not belong to contract\\u0027);\\n\\n        _totalToken = _totalToken.sub(mining.coin);\\n        _ownerToken[msg.sender] = _ownerToken[msg.sender].sub(mining.coin);\\n\\n        uint256 total = block.timestamp.sub(lastRewardTime).mul(speed).mul(1000);\\n        uint256 _accTokenPerShare = 0;\\n        if (lpSupply \\u003e 0) {\\n            _accTokenPerShare = total.div(lpSupply);\\n        }\\n        accTokenPerShare = accTokenPerShare.add(_accTokenPerShare);\\n\\n        uint256 rewardDebt = mining.lp.mul(accTokenPerShare).div(1000);\\n\\n        uint256 amount = mining.lp.mul(accTokenPerShare).div(1000).sub(rewardDebt);\\n\\n\\n        lastRewardTime = block.timestamp;\\n        lpSupply = lpSupply.sub(mining.lp);\\n\\n        _ownerPow[msg.sender] = _ownerPow[msg.sender].sub(mining.lp);\\n\\n\\n        if (lpSupply == 0) {\\n            accTokenPerShare = 0;\\n            lastRewardTime = 0;\\n        }\\n\\n\\n        //\u8f6c\u79fb\u4ee3\u5e01\\n        _NFT.transferFrom(address(this), msg.sender, tokenId_);\\n        if (mining.coin.add(amount) \\u003e 0) {\\n            _Token.transfer(msg.sender, mining.coin.add(amount));\\n        }\\n\\n\\n        if (ecologyPoolAddress != address(0)) {\\n            _EcologyPool.awardMaster(msg.sender, mining.coin.add(amount));\\n        }\\n\\n        delete miningList[tokenId_];\\n        _removePledgeTokend(tokenId_);\\n    }\\n\\n\\n    function canWithdrawalAmount(uint256 tokenId_) public view returns (uint256[2] memory) {\\n\\n        MiningData memory mining = miningList[tokenId_];\\n\\n        require(address(this) == _NFT.ownerOf(mining.tokenId), \\u0027NFT does not belong to contract\\u0027);\\n\\n        uint256 now_time = block.timestamp;\\n        uint256 total = now_time.sub(lastRewardTime).mul(speed).mul(1000);\\n        uint256 _accTokenPerShare = 0;\\n        if (lpSupply \\u003e 0) {\\n            _accTokenPerShare = total.div(lpSupply);\\n        }\\n        _accTokenPerShare = accTokenPerShare.add(_accTokenPerShare);\\n        uint256 amount = mining.lp.mul(_accTokenPerShare).div(1000).sub(mining.rewardDebt);\\n\\n        return [amount, now_time];\\n\\n    }\\n\\n\\n    function withdrawal(uint256 tokenId_) public {\\n        require(address(msg.sender) == address(tx.origin), \\\"no contract\\\");\\n        uint256 amount = canWithdrawalAmount(tokenId_)[0];\\n        require(amount \\u003e 0, \\u0027No withdrawable amount\\u0027);\\n\\n        MiningData storage mining = miningList[tokenId_];\\n        require(msg.sender == mining.owner, \\u0027NFT does not belong to you\\u0027);\\n\\n        mining.rewardDebt = mining.rewardDebt.add(amount);\\n        _Token.transfer(msg.sender, amount);\\n\\n        if (ecologyPoolAddress != address(0)) {\\n            _EcologyPool.awardMaster(msg.sender, amount);\\n        }\\n\\n    }\\n\\n\\n    function nftPower(uint256 tokenId_) public view returns (uint256){\\n        return miningList[tokenId_].lp;\\n    }\\n\\n    function totalPow() public view returns (uint256){\\n        return lpSupply;\\n    }\\n\\n\\n    function totalToken() public view returns (uint256){\\n        return _totalToken;\\n    }\\n\\n\\n    function ownerPower(address from) public view returns (uint256){\\n        return _ownerPow[from];\\n    }\\n\\n    function ownerToken(address from) public view returns (uint256){\\n        return _ownerToken[from];\\n    }\\n\\n    function blockTime() public view returns (uint256){\\n        return block.timestamp;\\n    }\\n\\n    function totalPledge() public view returns (uint256) {\\n        return allPledgeTokendIds.length;\\n    }\\n\\n    function pledgeTokenId(uint256 index_) public view returns (uint256) {\\n        require(index_ \\u003c allPledgeTokendIds.length, \\u0027global index out of bounds\\u0027);\\n        return allPledgeTokendIds[index_];\\n    }\\n\\n\\n    function ownerPledge(address from) public view returns (uint256) {\\n        return ownedTokens[from].length;\\n    }\\n\\n    function ownerPledgeTokenId(address from, uint256 index_) public view returns (uint256) {\\n        require(index_ \\u003c ownedTokens[from].length, \\u0027global index out of bounds\\u0027);\\n        return ownedTokens[from][index_];\\n    }\\n\\n\\n    function _removePledgeTokend(uint256 tokenId_) private {\\n\\n        uint256 cur_index = allTokenIdIndex[tokenId_];\\n\\n        uint256 last_index = allPledgeTokendIds.length - 1;\\n        uint256 lastTokenId = allPledgeTokendIds[last_index];\\n\\n\\n        allPledgeTokendIds[cur_index] = lastTokenId;\\n        allTokenIdIndex[lastTokenId] = cur_index;\\n\\n\\n        delete allTokenIdIndex[tokenId_];\\n        allPledgeTokendIds.pop();\\n\\n\\n        uint256 owned_cur_index = ownedTokenIndex[tokenId_];\\n\\n        uint256 owned_last_index = ownedTokens[msg.sender].length - 1;\\n        uint256 ownedlastTokenId = ownedTokens[msg.sender][owned_last_index];\\n\\n\\n        ownedTokens[msg.sender][owned_cur_index] = ownedlastTokenId;\\n        ownedTokenIndex[ownedlastTokenId] = owned_cur_index;\\n\\n        delete ownedTokenIndex[tokenId_];\\n        ownedTokens[msg.sender].pop();\\n\\n    }\\n\\n\\n    function _addPledgeTokend(uint256 tokenId_) private {\\n        allTokenIdIndex[tokenId_] = allPledgeTokendIds.length;\\n        allPledgeTokendIds.push(tokenId_);\\n\\n        uint256 len = ownedTokens[msg.sender].length;\\n        ownedTokenIndex[tokenId_] = len;\\n        ownedTokens[msg.sender].push(tokenId_);\\n\\n    }\\n\\n\\n}\\n\"},\"SweepNFT.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.1;\\n\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./ERC721Enumerable.sol\\\";\\nimport \\\"./SweepCoin.sol\\\";\\nimport \\u0027./SafeMath.sol\\u0027;\\nimport \\u0027./SweepCoinEcologyPool.sol\\u0027;\\nimport \\u0027./SweepCoinMiningPool.sol\\u0027;\\n\\ncontract SweepNFT is ERC721Enumerable, Ownable {\\n\\n    using SafeMath for uint256;\\n    using Strings for uint256;\\n\\n    SweepCoin private _Token;\\n\\n    SweepCoinEcologyPool private _EcologyPool;\\n    address public ecologyPoolAddress;\\n\\n\\n    struct NFTData {\\n        uint256 tokenId;\\n        uint256 time;\\n        uint256 coin;\\n        uint256 fee;\\n        uint256 width;\\n        uint256 height;\\n        uint256[] points;  //  [0,20,44,108,200,310]\\n        uint256 lucky; //Lucky value 0~5%\\n    }\\n\\n\\n\\n    // Optional mapping for token URIs\\n    mapping(uint256 =\\u003e string) private _tokenURIs;\\n\\n    // Base URI\\n    string private _baseURIextended;\\n\\n    // Minimum width\\n    uint256 private min_wh = 9;\\n    uint256 private max_wh = 30;\\n\\n    //  Proportion of Mines\\n    uint256 private min_mine = 10;  // Proportion of Mines 10%\\n    uint256 private max_mine = 30;   //  Proportion of Mines 30%\\n\\n    mapping(uint256 =\\u003e NFTData) private _tokenData;   // utokenId =\\u003e NFTData\\n    mapping(string =\\u003e uint256) private _tokenUnique;  //   width/height/0/20/44/108/200   unique string =\\u003e tokenId\\n\\n\\n\\n    constructor(string memory _name, string memory _symbol, address _coin_address)\\n    ERC721(_name, _symbol)\\n    {\\n        _Token = SweepCoin(_coin_address);\\n    }\\n\\n\\n    function setCoinEcologyPool(address pool_address) external onlyOwner() {\\n        _EcologyPool = SweepCoinEcologyPool(pool_address);\\n        ecologyPoolAddress = pool_address;\\n    }\\n\\n\\n    function setWH(uint256 min_wh_, uint256 max_wh_) external onlyOwner() {\\n        min_wh = min_wh_;\\n        max_wh = max_wh_;\\n    }\\n\\n    function getWH() public view returns (uint256[2] memory) {\\n        return [min_wh, max_wh];\\n    }\\n\\n\\n    function setMineRatio(uint256 min_mine_, uint256 max_mine_) external onlyOwner() {\\n        min_mine = min_mine_;\\n        max_mine = max_mine_;\\n    }\\n\\n    function getMineRatio() public view returns (uint256[2] memory) {\\n        return [min_mine, max_mine];\\n    }\\n\\n    function setBaseURI(string memory baseURI_) external onlyOwner() {\\n        _baseURIextended = baseURI_;\\n    }\\n\\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI set of nonexistent token\\\");\\n        _tokenURIs[tokenId] = _tokenURI;\\n    }\\n\\n    function _baseURI() internal view virtual override returns (string memory) {\\n        return _baseURIextended;\\n    }\\n\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory _tokenURI = _tokenURIs[tokenId];\\n        string memory base = _baseURI();\\n\\n        // If there is no base URI, return the token URI.\\n        if (bytes(base).length == 0) {\\n            return _tokenURI;\\n        }\\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\\n        if (bytes(_tokenURI).length \\u003e 0) {\\n            return string(abi.encodePacked(base, _tokenURI));\\n        }\\n        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\\n        return string(abi.encodePacked(base, tokenId.toString()));\\n    }\\n\\n\\n    function createNft(uint256 tokenId_, uint256 width_, uint256 height_, uint256[] memory points_,\\n\\n        address idea_address, uint256 fee_) public {\\n\\n\\n        require(address(msg.sender) == address(tx.origin), \\\"no contract\\\");\\n\\n        require(fee_ \\u003e= 0, \\u0027Illegal creation fee\\u0027);\\n        require(width_ \\u003e= min_wh, \\u0027Illegal width\\u0027);\\n        require(width_ \\u003c= max_wh, \\u0027Illegal : width\\u0027);\\n\\n        require(height_ \\u003e= min_wh, \\u0027Illegal height\\u0027);\\n        require(height_ \\u003c= max_wh, \\u0027Illegal : height\\u0027);\\n\\n        uint256 w_h = width_.mul(height_);\\n        uint256 coin = w_h.mul(10 ** uint256(_Token.decimals()));\\n\\n        fee_ = fee_.mul(10 ** uint256(_Token.decimals()));\\n\\n\\n        uint256 total_cost = coin;\\n        if (fee_ \\u003e 0 \\u0026\\u0026 msg.sender != idea_address) {\\n            total_cost = total_cost.add(fee_);\\n        }\\n\\n        require(_Token.canUseBalanceOf(msg.sender) \\u003e= total_cost, \\u0027Insufficient account available balance\\u0027);\\n\\n\\n        //Whether the calculation point is legal\\n        require(points_.length \\u003e= w_h.mul(min_mine).div(100), \\u0027Illegal points count\\u0027);\\n        require(points_.length \\u003c= w_h.mul(max_mine).div(100), \\u0027Illegal points count\\u0027);\\n        bool is_legal = true;\\n        for (uint8 i = 0; i \\u003c points_.length; i++) {\\n            if (points_[i] \\u003e= w_h || points_[i] \\u003c 0) {\\n                is_legal = false;\\n                break;\\n            }\\n        }\\n\\n        require(is_legal, \\u0027Illegal points\\u0027);\\n\\n\\n        string memory unique_str = string(abi.encodePacked(width_.toString(), \\u0027/\\u0027, height_.toString(), \\u0027/\\u0027));\\n\\n        for (uint8 i = 0; i \\u003c points_.length; i++) {\\n            unique_str = string(abi.encodePacked(unique_str, \\u0027/\\u0027, points_[i].toString()));\\n        }\\n\\n        require(_tokenUnique[unique_str] == 0, \\u0027Duplicate existence\\u0027);\\n        _tokenUnique[unique_str] = tokenId_;\\n\\n\\n        _mint(msg.sender, tokenId_);\\n\\n        uint256 lucky = rand(tokenId_) % 10;\\n        if (lucky == 0) lucky = 0;\\n        if (lucky \\u003e 5) lucky = 0;\\n        _tokenData[tokenId_] = NFTData(tokenId_, block.timestamp, coin, fee_, width_, height_, points_, lucky);\\n\\n\\n        // Buy someone else\\u0027s NFT\\n        if (fee_ \\u003e 0 \\u0026\\u0026 msg.sender != idea_address) {\\n            _Token.transferFrom(msg.sender, idea_address, fee_);\\n        }\\n        //Activate and  destroy token\\n        _Token.burnToZero(msg.sender, coin);\\n\\n        // \\\"233\\\",\\\"9\\\",\\\"9\\\",[0,\\\"4\\\",8,\\\"36\\\",40,\\\"44\\\",72,\\\"76\\\",80],\\\"0x2d658C3F95Aef74303d5a630C6373566C60516E0\\\",\\\"23\\\"\\n\\n        if (ecologyPoolAddress != address(0)) {\\n            //Payment of commission\\n            _EcologyPool.activateNFT(tokenId_);\\n        }\\n    }\\n\\n\\n    function getTokenData(uint256 tokenId) public view returns (NFTData memory){\\n        return _tokenData[tokenId];\\n    }\\n\\n    function rand(uint256 len) internal view returns (uint256) {\\n        uint256 random = uint256(keccak256(abi.encodePacked(block.difficulty, block.timestamp)));\\n        return random % (uint256(4123456).add(len));\\n    }\\n\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"totalSupply_\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimals_\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_burnValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_burnValueMap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target_address\",\"type\":\"address\"}],\"name\":\"airdropBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target_address\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burnToZero\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target_address\",\"type\":\"address\"}],\"name\":\"canUseBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isSetAirdopToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"airdrop_address\",\"type\":\"address\"}],\"name\":\"setAirdopToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SweepCoin", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000773594000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000115375706572204d696e65737765657065720000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002534d000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://dbd97d5ff2d5fd5a47c9e588331fd992a276e8aba211b2e683fc47f948f66bf0"}