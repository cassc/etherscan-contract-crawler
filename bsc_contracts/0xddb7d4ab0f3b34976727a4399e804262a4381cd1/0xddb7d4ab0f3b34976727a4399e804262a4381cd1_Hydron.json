{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Hydron.sol\": {\r\n      \"content\": \"//  /$$   /$$  /$$     /$$  /$$$$$$$   /$$$$$$$    /$$$$$$   /$$   /$$\\r\\n// | $$  | $$ |  $$   /$$/ | $$__  $$ | $$__  $$  /$$__  $$ | $$$ | $$ \\r\\n// | $$  | $$  \\\\  $$ /$$/  | $$  \\\\ $$ | $$  \\\\ $$ | $$  \\\\ $$ | $$$$| $$ \\r\\n// | $$$$$$$$   \\\\  $$$$/   | $$  | $$ | $$$$$$$/ | $$  | $$ | $$ $$ $$ \\r\\n// | $$__  $$    \\\\  $$/    | $$  | $$ | $$__  $$ | $$  | $$ | $$  $$$$ \\r\\n// | $$  | $$     | $$     | $$  | $$ | $$  \\\\ $$ | $$  | $$ | $$\\\\  $$$ \\r\\n// | $$  | $$     | $$     | $$$$$$$$ | $$  | $$ |  $$$$$$/ | $$ \\\\  $$ \\r\\n// |__/  |__/     |__/     |_______/  |__/  |__/  \\\\______/  |__/  \\\\__/ \\r\\n\\r\\n\\r\\n// First Dividend Token Mechanism - https://hydron.finance\\r\\n\\r\\npragma solidity 0.7.6;\\r\\n\\r\\nlibrary SafeMathInt {\\r\\n    int256 private constant MIN_INT256 = int256(1) << 255;\\r\\n    int256 private constant MAX_INT256 = ~(int256(1) << 255);\\r\\n\\r\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\r\\n        int256 c = a * b;\\r\\n\\r\\n        require(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));\\r\\n        require((b == 0) || (c / b == a));\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\r\\n        require(b != -1 || a != MIN_INT256);\\r\\n\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\r\\n        int256 c = a - b;\\r\\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\r\\n        int256 c = a + b;\\r\\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function abs(int256 a) internal pure returns (int256) {\\r\\n        require(a != MIN_INT256);\\r\\n        return a < 0 ? -a : a;\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address who) external view returns (uint256);\\r\\n\\r\\n    function allowance(address owner, address spender)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    function transfer(address to, uint256 value) external returns (bool);\\r\\n\\r\\n    function approve(address spender, uint256 value) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) external returns (bool);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n}\\r\\n\\r\\nlibrary SafeMath {\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    function sub(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    function div(\\r\\n        uint256 a,\\r\\n        uint256 b,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (uint256) {\\r\\n        require(b > 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b != 0);\\r\\n        return a % b;\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface InterfaceLP {\\r\\n    function sync() external;\\r\\n}\\r\\n\\r\\nlibrary Roles {\\r\\n    struct Role {\\r\\n        mapping (address => bool) bearer;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Give an account access to this role.\\r\\n     */\\r\\n    function add(Role storage role, address account) internal {\\r\\n        require(!has(role, account), \\\"Roles: account already has role\\\");\\r\\n        role.bearer[account] = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Remove an account's access to this role.\\r\\n     */\\r\\n    function remove(Role storage role, address account) internal {\\r\\n        require(has(role, account), \\\"Roles: account does not have role\\\");\\r\\n        role.bearer[account] = false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Check if an account has this role.\\r\\n     * @return bool\\r\\n     */\\r\\n    function has(Role storage role, address account) internal view returns (bool) {\\r\\n        require(account != address(0), \\\"Roles: account is the zero address\\\");\\r\\n        return role.bearer[account];\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract MinterRole {\\r\\n    using Roles for Roles.Role;\\r\\n\\r\\n    event MinterAdded(address indexed account);\\r\\n    event MinterRemoved(address indexed account);\\r\\n\\r\\n    Roles.Role private _minters;\\r\\n\\r\\n    constructor () {\\r\\n        _addMinter(msg.sender);\\r\\n    }\\r\\n\\r\\n    modifier onlyMinter() {\\r\\n        require(isMinter(msg.sender), \\\"MinterRole: caller does not have the Minter role\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function isMinter(address account) public view returns (bool) {\\r\\n        return _minters.has(account);\\r\\n    }\\r\\n\\r\\n    function renounceMinter() public {\\r\\n        _removeMinter(msg.sender);\\r\\n    }\\r\\n\\r\\n    function _addMinter(address account) internal {\\r\\n        _minters.add(account);\\r\\n        emit MinterAdded(account);\\r\\n    }\\r\\n\\r\\n    function _removeMinter(address account) internal {\\r\\n        _minters.remove(account);\\r\\n        emit MinterRemoved(account);\\r\\n    }\\r\\n}\\r\\n\\r\\nabstract contract ERC20Detailed is IERC20 {\\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n    uint8 private _decimals;\\r\\n\\r\\n    constructor(\\r\\n        string memory name,\\r\\n        string memory symbol,\\r\\n        uint8 decimals\\r\\n    ) {\\r\\n        _name = name;\\r\\n        _symbol = symbol;\\r\\n        _decimals = decimals;\\r\\n    }\\r\\n\\r\\n    function name() public view returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    function symbol() public view returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    function decimals() public view returns (uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IDEXRouter {\\r\\n    function factory() external pure returns (address);\\r\\n\\r\\n    function WETH() external pure returns (address);\\r\\n\\r\\n    function addLiquidity(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint256 amountADesired,\\r\\n        uint256 amountBDesired,\\r\\n        uint256 amountAMin,\\r\\n        uint256 amountBMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    )\\r\\n        external\\r\\n        returns (\\r\\n            uint256 amountA,\\r\\n            uint256 amountB,\\r\\n            uint256 liquidity\\r\\n        );\\r\\n\\r\\n    function addLiquidityETH(\\r\\n        address token,\\r\\n        uint256 amountTokenDesired,\\r\\n        uint256 amountTokenMin,\\r\\n        uint256 amountETHMin,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    )\\r\\n        external\\r\\n        payable\\r\\n        returns (\\r\\n            uint256 amountToken,\\r\\n            uint256 amountETH,\\r\\n            uint256 liquidity\\r\\n        );\\r\\n\\r\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external;\\r\\n\\r\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external payable;\\r\\n\\r\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n        uint256 amountIn,\\r\\n        uint256 amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to,\\r\\n        uint256 deadline\\r\\n    ) external;\\r\\n}\\r\\n\\r\\ninterface IDEXFactory {\\r\\n    function createPair(address tokenA, address tokenB)\\r\\n        external\\r\\n        returns (address pair);\\r\\n}\\r\\n\\r\\ncontract Ownable {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipRenounced(address indexed previousOwner);\\r\\n\\r\\n    event OwnershipTransferred(\\r\\n        address indexed previousOwner,\\r\\n        address indexed newOwner\\r\\n    );\\r\\n\\r\\n    constructor() {\\r\\n        _owner = msg.sender;\\r\\n    }\\r\\n\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(isOwner());\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function isOwner() public view returns (bool) {\\r\\n        return msg.sender == _owner;\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() public onlyOwner {\\r\\n        emit OwnershipRenounced(_owner);\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public onlyOwner {\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    function _transferOwnership(address newOwner) internal {\\r\\n        require(newOwner != address(0));\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract Hydron is ERC20Detailed, Ownable, MinterRole {\\r\\n    using SafeMath for uint256;\\r\\n    using SafeMathInt for int256;\\r\\n\\r\\n    event LogDividend(uint256 indexed epoch, uint256 totalSupply);\\r\\n\\r\\n    InterfaceLP public pairContract;\\r\\n\\r\\n    bool public initialDistributionFinished;\\r\\n\\r\\n    mapping(address => bool) allowTransfer;\\r\\n    mapping(address => bool) _isFeeExempt;\\r\\n\\r\\n    modifier initialDistributionLock() {\\r\\n        require(initialDistributionFinished || isOwner() || allowTransfer[msg.sender]);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier validRecipient(address to) {\\r\\n        require(to != address(0x0));\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    uint256 private constant DECIMALS = 18;\\r\\n    uint256 private constant MAX_UINT256 = ~uint256(0);\\r\\n    uint256 private constant INITIAL_FRAGMENTS_SUPPLY = 777 * 10**DECIMALS;\\r\\n    uint256 public treasuryFee = 1;\\r\\n    uint256 public sellFee = 6;\\r\\n    uint256 public dividendReductionRate = 3;\\r\\n    uint256 public denominator = 100;\\r\\n    uint256 public dividendAmount= 7777;\\r\\n    uint256 public dividendPayout = dividendAmount * 10**DECIMALS;\\r\\n    uint256 public dividendFrequency = 86400;\\r\\n    uint256 public dividendReductionFrequency = 30;\\r\\n    uint256 public dividendsUntilReduction = 30;\\r\\n    uint256 public manualDividendCallsLeft = 21;\\r\\n    uint256 public nextDividendEpoch = block.timestamp + dividendFrequency;\\r\\n    bool public autoDividend = true;\\r\\n    address public treasury;\\r\\n    address DEAD = 0x000000000000000000000000000000000000dEaD;\\r\\n    address ZERO = 0x0000000000000000000000000000000000000000;\\r\\n\\r\\n    IDEXRouter public router;\\r\\n    address public pair;\\r\\n\\r\\n    uint256 private constant TOTAL_GONS = MAX_UINT256 - (MAX_UINT256 % INITIAL_FRAGMENTS_SUPPLY);\\r\\n    uint256 private constant MAX_SUPPLY = ~uint256(0);\\r\\n\\r\\n    uint256 private _totalSupply;\\r\\n    uint256 private _gonsPerFragment;\\r\\n    mapping(address => uint256) private _gonBalances;\\r\\n\\r\\n    mapping(address => mapping(address => uint256)) private _allowedFragments;\\r\\n\\r\\n    constructor() ERC20Detailed(\\\"Hydron\\\", \\\"HYDRON\\\", uint8(DECIMALS)) {\\r\\n        router = IDEXRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\\r\\n\\r\\n        pair = IDEXFactory(router.factory()).createPair(\\r\\n            router.WETH(),\\r\\n            address(this)\\r\\n        );\\r\\n\\r\\n        treasury = 0x93dB3aEa2a6651ED47b1ba5D369236d3bf1DFFB9;\\r\\n\\r\\n        _allowedFragments[address(this)][address(router)] = uint256(-1);\\r\\n        pairContract = InterfaceLP(pair);\\r\\n\\r\\n        _totalSupply = INITIAL_FRAGMENTS_SUPPLY;\\r\\n        _gonBalances[treasury] = TOTAL_GONS;\\r\\n        _gonsPerFragment = TOTAL_GONS.div(_totalSupply);\\r\\n\\r\\n        initialDistributionFinished = false;\\r\\n        _isFeeExempt[treasury] = true;\\r\\n        _isFeeExempt[address(this)] = true;\\r\\n\\r\\n        _transferOwnership(treasury);\\r\\n        emit Transfer(address(0x0), treasury, _totalSupply);\\r\\n    }\\r\\n\\r\\n    function swipe(address _receiver) external onlyOwner {\\r\\n        uint256 balance = address(this).balance;\\r\\n        payable(_receiver).transfer(balance);\\r\\n    }\\r\\n\\r\\n    function payDividend(uint256 epoch, int256 supplyDelta) private returns (uint256) {\\r\\n        if (supplyDelta == 0) {\\r\\n            emit LogDividend(epoch, _totalSupply);\\r\\n            return _totalSupply;\\r\\n        }\\r\\n\\r\\n        if (supplyDelta < 0) {\\r\\n            _totalSupply = _totalSupply.sub(uint256(-supplyDelta));\\r\\n        } else {\\r\\n            _totalSupply = _totalSupply.add(uint256(supplyDelta));\\r\\n        }\\r\\n\\r\\n        if (_totalSupply > MAX_SUPPLY) {\\r\\n            _totalSupply = MAX_SUPPLY;\\r\\n        }\\r\\n\\r\\n        _gonsPerFragment = TOTAL_GONS.div(_totalSupply);\\r\\n        pairContract.sync();\\r\\n\\r\\n        emit LogDividend(epoch, _totalSupply);\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    function _payDividend() private {\\r\\n        uint256 epoch = block.timestamp;\\r\\n        dividendsUntilReduction = dividendsUntilReduction - 1;\\r\\n        if (dividendsUntilReduction == 0) {\\r\\n            dividendAmount = dividendAmount.sub(dividendAmount.mul(dividendReductionRate).div(denominator));\\r\\n            dividendsUntilReduction = dividendReductionFrequency;\\r\\n        }\\r\\n\\r\\n        int256 supplyDelta = int256(dividendPayout);\\r\\n        payDividend(epoch, supplyDelta);\\r\\n        nextDividendEpoch = epoch + dividendFrequency;\\r\\n    }\\r\\n\\r\\n    function manualDividend() external onlyOwner {\\r\\n        if(shouldPayDividend() && autoDividend) {\\r\\n            _payDividend();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function manualDividendCall() external onlyOwner {\\r\\n        require(manualDividendCallsLeft > 0);\\r\\n        manualDividendCallsLeft = manualDividendCallsLeft - 1;\\r\\n        _payDividend();\\r\\n    }\\r\\n\\r\\n    function totalSupply() external view override returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    function transfer(address to, uint256 value)\\r\\n        external\\r\\n        override\\r\\n        validRecipient(to)\\r\\n        initialDistributionLock\\r\\n        returns (bool)\\r\\n    {\\r\\n        _transferFrom(msg.sender, to, value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setLP(address _address) external onlyOwner {\\r\\n        pairContract = InterfaceLP(_address);\\r\\n        _isFeeExempt[_address];\\r\\n    }\\r\\n\\r\\n    function allowance(address owner_, address spender)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return _allowedFragments[owner_][spender];\\r\\n    }\\r\\n\\r\\n    function balanceOf(address who) external view override returns (uint256) {\\r\\n        return _gonBalances[who].div(_gonsPerFragment);\\r\\n    }\\r\\n\\r\\n    function _transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) internal returns (bool) {\\r\\n\\r\\n        uint256 gonAmount = amount.mul(_gonsPerFragment);\\r\\n\\r\\n        _gonBalances[sender] = _gonBalances[sender].sub(gonAmount);\\r\\n\\r\\n        uint256 gonAmountReceived = shouldTakeFee(sender, recipient)\\r\\n            ? takeFee(sender, recipient, gonAmount)\\r\\n            : gonAmount;\\r\\n        _gonBalances[recipient] = _gonBalances[recipient].add(\\r\\n            gonAmountReceived\\r\\n        );\\r\\n\\r\\n        emit Transfer(\\r\\n            sender,\\r\\n            recipient,\\r\\n            gonAmountReceived.div(_gonsPerFragment)\\r\\n        );\\r\\n\\r\\n        if(shouldPayDividend() && autoDividend) {\\r\\n            _payDividend();\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) external override validRecipient(to) returns (bool) {\\r\\n        if (_allowedFragments[from][msg.sender] != uint256(-1)) {\\r\\n            _allowedFragments[from][msg.sender] = _allowedFragments[from][\\r\\n                msg.sender\\r\\n            ].sub(value, \\\"Insufficient Allowance\\\");\\r\\n        }\\r\\n\\r\\n        _transferFrom(from, to, value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function takeFee(address sender, address recipient, uint256 gonAmount) internal returns (uint256) {\\r\\n        uint256 _totalFee = treasuryFee;\\r\\n        if(recipient == pair) _totalFee = _totalFee.add(sellFee);\\r\\n\\r\\n        uint256 feeAmount = gonAmount.mul(_totalFee).div(denominator);\\r\\n\\r\\n        _gonBalances[treasury] = _gonBalances[treasury].add(feeAmount);\\r\\n        emit Transfer(sender, treasury, feeAmount.div(_gonsPerFragment));\\r\\n\\r\\n        return gonAmount.sub(feeAmount);\\r\\n    }\\r\\n    \\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue)\\r\\n        external\\r\\n        initialDistributionLock\\r\\n        returns (bool)\\r\\n    {\\r\\n        uint256 oldValue = _allowedFragments[msg.sender][spender];\\r\\n        if (subtractedValue >= oldValue) {\\r\\n            _allowedFragments[msg.sender][spender] = 0;\\r\\n        } else {\\r\\n            _allowedFragments[msg.sender][spender] = oldValue.sub(\\r\\n                subtractedValue\\r\\n            );\\r\\n        }\\r\\n        emit Approval(\\r\\n            msg.sender,\\r\\n            spender,\\r\\n            _allowedFragments[msg.sender][spender]\\r\\n        );\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function increaseAllowance(address spender, uint256 addedValue)\\r\\n        external\\r\\n        initialDistributionLock\\r\\n        returns (bool)\\r\\n    {\\r\\n        _allowedFragments[msg.sender][spender] = _allowedFragments[msg.sender][\\r\\n            spender\\r\\n        ].add(addedValue);\\r\\n        emit Approval(\\r\\n            msg.sender,\\r\\n            spender,\\r\\n            _allowedFragments[msg.sender][spender]\\r\\n        );\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function approve(address spender, uint256 value)\\r\\n        external\\r\\n        override\\r\\n        initialDistributionLock\\r\\n        returns (bool)\\r\\n    {\\r\\n        _allowedFragments[msg.sender][spender] = value;\\r\\n        emit Approval(msg.sender, spender, value);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function checkFeeExempt(address _addr) external view returns (bool) {\\r\\n        return _isFeeExempt[_addr];\\r\\n    }\\r\\n\\r\\n    function setInitialDistributionFinished() external onlyOwner {\\r\\n        initialDistributionFinished = true;\\r\\n    }\\r\\n\\r\\n    function enableTransfer(address _addr) external onlyOwner {\\r\\n        allowTransfer[_addr] = true;\\r\\n    }\\r\\n\\r\\n    function setFeeExempt(address _addr) external onlyOwner {\\r\\n        _isFeeExempt[_addr] = true;\\r\\n    }\\r\\n\\r\\n    function setTreasury(address _treasury) external onlyOwner {\\r\\n        treasury = _treasury;\\r\\n    }\\r\\n\\r\\n    function shouldTakeFee(address from, address to) internal view returns (bool) {\\r\\n        return (pair == from || pair == to) && (!_isFeeExempt[from]);\\r\\n    }\\r\\n\\r\\n    function getCirculatingSupply() public view returns (uint256) {\\r\\n        return\\r\\n            (TOTAL_GONS.sub(_gonBalances[DEAD]).sub(_gonBalances[ZERO])).div(\\r\\n                _gonsPerFragment\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function manualSync() external {\\r\\n        InterfaceLP(pair).sync();\\r\\n    }\\r\\n\\r\\n    function transferToAddressETH(address payable recipient, uint256 amount) private {\\r\\n        recipient.transfer(amount);\\r\\n    }\\r\\n\\r\\n    function getManualDividendCallsLeft() public view returns (uint256) {\\r\\n        return manualDividendCallsLeft;\\r\\n    }\\r\\n\\r\\n    function getNextDividendEpoch() public view returns (uint256) {\\r\\n        return nextDividendEpoch;\\r\\n    }\\r\\n\\r\\n    function getDividendReductionFrequency() public view returns (uint256) {\\r\\n        return dividendReductionFrequency;\\r\\n    }\\r\\n\\r\\n    function getDividendsUntilReduction() public view returns (uint256) {\\r\\n        return dividendsUntilReduction;\\r\\n    }\\r\\n\\r\\n    function getDividendAmount() public view returns (uint256) {\\r\\n        return dividendAmount;\\r\\n    }\\r\\n\\r\\n    function getDenominator() public view returns (uint256) {\\r\\n        return denominator;\\r\\n    }\\r\\n\\r\\n    function getAutoDividend() public view returns (bool) {\\r\\n        return autoDividend;\\r\\n    }\\r\\n\\r\\n    function getDividendFrequency() public view returns (uint256) {\\r\\n        return dividendFrequency;\\r\\n    }\\r\\n\\r\\n    function shouldPayDividend() public view returns (bool) {\\r\\n        return nextDividendEpoch <= block.timestamp;\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"name\":\"LogDividend\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MinterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MinterRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoDividend\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"checkFeeExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"denominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendFrequency\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendPayout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendReductionFrequency\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendReductionRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendsUntilReduction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"enableTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAutoDividend\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDenominator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDividendAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDividendFrequency\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDividendReductionFrequency\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDividendsUntilReduction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getManualDividendCallsLeft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNextDividendEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialDistributionFinished\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isMinter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualDividend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualDividendCall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualDividendCallsLeft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualSync\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextDividendEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pairContract\",\"outputs\":[{\"internalType\":\"contract InterfaceLP\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setFeeExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setInitialDistributionFinished\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"}],\"name\":\"setTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shouldPayDividend\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"swipe\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Hydron", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}