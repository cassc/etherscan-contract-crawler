{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/OrderBook.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: None\\npragma solidity 0.8.16;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\ncontract OrderBook is Ownable {\\n\\n  address _baseCurrencyAddress;\\n  address _quoteCurrencyAddress;\\n\\n  uint maxBaseAsset;\\n  uint maxBaseValue;\\n  uint minBaseAsset;\\n  uint minBaseValue;\\n\\n  uint maxQuoteAsset;\\n  uint maxQuoteValue;\\n  uint minQuoteAsset;\\n  uint minQuoteValue;\\n\\n  uint minSellPrice;\\n  uint maxSellPrice;\\n  uint minBuyPrice;\\n  uint maxBuyPrice;\\n\\n  uint48 constant maxAmount = type(uint48).max;\\n\\n  uint _baseCurrencyUnit; // real amount = (amount in contract) * (base unit)\\n  uint _quoteCurrencyUnit;\\n  uint _priceDivisor; // real price = (price in contract) / (price divisor)\\n  uint _quoteDivisor;\\n  uint _baseDivisor;\\n\\n  function _getDecimals(address token) private view returns (uint) {\\n    return token == address(0) ? 18 : IERC20Metadata(token).decimals();\\n  }\\n\\n  function _getSymbol(address token) private view returns (string memory) {\\n    return token == address(0) ? \\\"BNB\\\" : IERC20Metadata(token).symbol();\\n  }\\n\\n  constructor(\\n    address baseCurrencyAddress,\\n    address quoteCurrencyAddress,\\n    uint baseCurrencyUnit,\\n    uint quoteCurrencyUnit,\\n    uint priceDivisor\\n  ) {\\n    _baseCurrencyAddress = baseCurrencyAddress;\\n    _quoteCurrencyAddress = quoteCurrencyAddress;\\n\\n    _baseCurrencyUnit = baseCurrencyUnit;\\n    _quoteCurrencyUnit = quoteCurrencyUnit;\\n\\n    _priceDivisor = priceDivisor;\\n    uint baseDecimals = _getDecimals(baseCurrencyAddress);\\n    uint quoteDecimals = _getDecimals(quoteCurrencyAddress);\\n    _baseDivisor  = 10**baseDecimals;\\n    _quoteDivisor = 10**quoteDecimals;\\n\\n    maxBaseAsset = exactBaseAmount(maxAmount);\\n    maxBaseValue = exactBaseAmount(maxAmount);\\n    minBaseAsset = exactBaseAmount(1);\\n    minBaseValue = exactBaseAmount(1);\\n\\n    maxQuoteAsset = exactQuoteAmount(maxAmount);\\n    maxQuoteValue = exactQuoteAmount(maxAmount);\\n    minQuoteAsset = exactQuoteAmount(1);\\n    minQuoteValue = exactQuoteAmount(1);\\n\\n    minSellPrice = 1;\\n    maxSellPrice = type(uint).max/(exactQuoteAmount(maxAmount))/(_baseDivisor);\\n    minBuyPrice = 1;\\n    maxBuyPrice = type(uint).max/(exactQuoteAmount(maxAmount))/(_baseDivisor);\\n\\n  }\\n\\n  function setLimitSellRanges(\\n    uint minAsset,\\n    uint maxAsset,\\n    uint minValue,\\n    uint maxValue,\\n    uint minPrice,\\n    uint maxPrice\\n  ) public onlyOwner {\\n    require(minAsset < maxAsset, \\\"minAsset >= maxAsset\\\");\\n    require(minValue < maxValue, \\\"minValue >= maxValue\\\");\\n    require(minPrice < maxPrice, \\\"minPrice >= maxPrice\\\");\\n    require(minAsset >= exactBaseAmount(1), \\\"minAsset too high\\\");\\n    require(maxAsset <= exactBaseAmount(maxAmount), \\\"maxAsset too high\\\");\\n    require(minValue >= exactQuoteAmount(1), \\\"minValue too high\\\");\\n    require(maxValue <= exactQuoteAmount(maxAmount), \\\"maxValue too high\\\");\\n    require(minPrice > 0, \\\"minPrice too low\\\");\\n    require(maxPrice <= type(uint).max/(exactQuoteAmount(maxAmount))/(_baseDivisor), \\\"maxPrice too high\\\");\\n    if(minAsset > 0 && minAsset != minBaseAsset) minBaseAsset = minAsset;\\n    if(maxAsset > 0 && maxAsset != maxBaseAsset) maxBaseAsset = maxAsset;\\n    if(minValue > 0 && minValue != minQuoteValue) minQuoteValue = minValue;\\n    if(maxValue > 0 && maxValue != maxQuoteValue) maxQuoteValue = maxValue;\\n    if(minPrice > 0 && minPrice != minSellPrice) minSellPrice = minPrice;\\n    if(maxPrice > 0 && maxPrice != maxSellPrice) maxSellPrice = maxPrice;\\n  }\\n\\n  function setLimitBuyRanges(\\n    uint minAsset,\\n    uint maxAsset,\\n    uint minValue,\\n    uint maxValue,\\n    uint minPrice,\\n    uint maxPrice\\n  ) public onlyOwner {\\n    require(minAsset < maxAsset, \\\"minAsset >= maxAsset\\\");\\n    require(minValue < maxValue, \\\"minValue >= maxValue\\\");\\n    require(minPrice < maxPrice, \\\"minPrice >= maxPrice\\\");\\n    require(minAsset >= exactQuoteAmount(1), \\\"minAsset too high\\\");\\n    require(maxAsset <= exactQuoteAmount(maxAmount), \\\"maxAsset too high\\\");\\n    require(minValue >= exactBaseAmount(1), \\\"minValue too high\\\");\\n    require(maxValue <= exactBaseAmount(maxAmount), \\\"maxValue too high\\\");\\n    require(minPrice > 0, \\\"minPrice too low\\\");\\n    require(maxPrice <= type(uint).max/(exactQuoteAmount(maxAmount))/(_baseDivisor), \\\"maxPrice too high\\\");\\n    if(minValue > 0 && minValue != minBaseValue) minBaseValue = minValue;\\n    if(maxValue > 0 && maxValue != maxBaseValue) maxBaseValue = maxValue;\\n    if(minAsset > 0 && minAsset != minQuoteAsset) minQuoteAsset = minAsset;\\n    if(maxAsset > 0 && maxAsset != maxQuoteAsset) maxQuoteAsset = maxAsset;\\n    if(minPrice > 0 && minPrice != minBuyPrice) minBuyPrice = minPrice;\\n    if(maxPrice > 0 && maxPrice != maxBuyPrice) maxBuyPrice = maxPrice;\\n  }\\n\\n  function numberSettings() public view returns (\\n    uint baseCurrencyUnit,\\n    uint quoteCurrencyUnit,\\n    uint priceDivisor,\\n    uint quoteDivisor,\\n    uint baseDivisor\\n  ){\\n    baseCurrencyUnit = _baseCurrencyUnit;\\n    quoteCurrencyUnit = _quoteCurrencyUnit;\\n    priceDivisor = _priceDivisor;\\n    quoteDivisor = _quoteDivisor;\\n    baseDivisor = _baseDivisor;\\n  }\\n\\n  function rangeSettings() public view returns (\\n    uint _maxBaseAsset,\\n    uint _maxBaseValue,\\n    uint _minBaseAsset,\\n    uint _minBaseValue,\\n    uint _maxQuoteAsset,\\n    uint _maxQuoteValue,\\n    uint _minQuoteAsset,\\n    uint _minQuoteValue,\\n    uint _minSellPrice,\\n    uint _maxSellPrice,\\n    uint _minBuyPrice,\\n    uint _maxBuyPrice\\n  ){\\n    _maxBaseAsset = maxBaseAsset;\\n    _maxBaseValue = maxBaseValue;\\n    _minBaseAsset = minBaseAsset;\\n    _minBaseValue = minBaseValue;\\n    _maxQuoteAsset = maxQuoteAsset;\\n    _maxQuoteValue = maxQuoteValue;\\n    _minQuoteAsset = minQuoteAsset;\\n    _minQuoteValue = minQuoteValue;\\n    _minSellPrice = minSellPrice;\\n    _maxSellPrice = maxSellPrice;\\n    _minBuyPrice = minBuyPrice;\\n    _maxBuyPrice = maxBuyPrice;\\n  }\\n\\n  function baseCurrencyIsBNB() internal view returns (bool) { return _baseCurrencyAddress == address(0); }\\n  function quoteCurrencyIsBNB() internal view returns (bool) { return _quoteCurrencyAddress == address(0); }\\n\\n  struct LimitOrder {\\n    uint48 asset; // \u0442\u043e, \u0447\u0442\u043e\\n    uint48 value;\\n    address trader;\\n  }\\n\\n  function internalBaseAmount(uint exactAmount) private view returns (uint48) {\\n    return uint48(exactAmount/(_baseCurrencyUnit));\\n  }\\n\\n  function internalQuoteAmount(uint exactAmount) private view returns (uint48) {\\n    return uint48(exactAmount/(_quoteCurrencyUnit));\\n  }\\n\\n  function exactBaseAmount(uint48 internalAmount) private view returns (uint) {\\n    return uint(internalAmount)*(_baseCurrencyUnit);\\n  }\\n\\n  function exactQuoteAmount(uint48 internalAmount) private view returns (uint) {\\n    return uint(internalAmount)*(_quoteCurrencyUnit);\\n  }\\n\\n  mapping(uint => LimitOrder) sell;\\n  mapping(uint => LimitOrder) buy;\\n\\n  uint public lastOrder;\\n\\n  event LimitSell(uint id, uint timestamp, address trader, uint asset, uint value);\\n\\n  function limitSell(uint asset, uint value) public payable {\\n    if(baseCurrencyIsBNB())\\n      asset = msg.value;\\n    else\\n      require(msg.value == 0, \\\"Cannot accept BNB\\\");\\n    require(asset%(_baseCurrencyUnit) == 0, \\\"Asset  is not a multiple of base unit\\\");\\n    require(value%(_quoteCurrencyUnit) == 0, \\\"Value is not a multiple of quote unit\\\");\\n    require(asset >= minBaseAsset, \\\"Asset too low\\\");\\n    require(asset <= maxBaseAsset, \\\"Asset too high\\\");\\n    require(value >= minQuoteValue, \\\"Value too low\\\");\\n    require(value <= maxQuoteValue, \\\"Value too high\\\");\\n\\n    // pair BASE/QUOTE\\n    // sell BASE asset, gain QUOTE value\\n    // price = QUOTE/BASE = value/asset\\n\\n    /* minSellPrice    value    _baseDivisor      maxSellPrice\\n      ------------- <= ----- * -------------- <= -------------\\n      _priceDivisor    asset   _quoteDivisor     _priceDivisor */\\n\\n    require((minSellPrice)*(asset * _quoteDivisor) <= (value * _baseDivisor)*(_priceDivisor), \\\"Price too low\\\");\\n    require((maxSellPrice)*(asset * _quoteDivisor) >= (value * _baseDivisor)*(_priceDivisor), \\\"Price too high\\\");\\n\\n    if(!baseCurrencyIsBNB())\\n      IERC20(_baseCurrencyAddress).transferFrom(msg.sender, address(this), asset);\\n\\n    lastOrder++;\\n    sell[lastOrder] = LimitOrder(internalBaseAmount(asset), internalQuoteAmount(value), msg.sender);\\n    emit LimitSell(lastOrder, block.timestamp, msg.sender, asset, value);\\n  }\\n\\n  event LimitBuy(uint id, uint timestamp, address trader, uint asset, uint value);\\n\\n  function limitBuy(uint asset, uint value) public payable {\\n    if(quoteCurrencyIsBNB())\\n      asset = msg.value;\\n    else\\n      require(msg.value == 0, \\\"Cannot accept BNB\\\");\\n    require(asset % (_quoteCurrencyUnit) == 0, \\\"Asset is not a multiple of quote unit\\\");\\n    require(value % (_baseCurrencyUnit) == 0, \\\"Value is not a multiple of base unit\\\");\\n    require(asset >= minQuoteAsset, \\\"Asset too low\\\");\\n    require(asset <= maxQuoteAsset, \\\"Asset too high\\\");\\n    require(value >= minBaseValue, \\\"Value too low\\\");\\n    require(value <= maxBaseValue, \\\"Value too high\\\");\\n\\n    // pair BASE/QUOTE\\n    // pay QUOTE asset, gain BASE value\\n    // price = QUOTE/BASE = asset/value\\n\\n    /* minBuyPrice     asset    _baseDivisor     maxBuyPrice\\n       ------------ <= ----- * -------------- <= ------------\\n      _priceDivisor    value   _quoteDivisor    _priceDivisor */\\n\\n    require((minBuyPrice)*(value * _quoteDivisor) <= (asset * _baseDivisor)*(_priceDivisor), \\\"Price too low\\\");\\n    require((maxBuyPrice)*(value * _quoteDivisor) >= (asset * _baseDivisor)*(_priceDivisor), \\\"Price too high\\\");\\n\\n    if(!quoteCurrencyIsBNB())\\n      IERC20(_quoteCurrencyAddress).transferFrom(msg.sender, address(this), asset);\\n\\n    lastOrder++;\\n    buy[lastOrder] = LimitOrder(internalQuoteAmount(asset), internalBaseAmount(value), msg.sender);\\n    emit LimitBuy(lastOrder, block.timestamp, msg.sender, asset, value);\\n  }\\n\\n  function sendBaseCurrency(address recipient, uint amount) private {\\n    if(baseCurrencyIsBNB()) {\\n      payable(recipient).transfer(amount);\\n    } else {\\n      IERC20(_baseCurrencyAddress).transfer(recipient, amount);\\n    }\\n  }\\n\\n  function sendQuoteCurrency(address recipient, uint amount) private {\\n    if(quoteCurrencyIsBNB()) {\\n      payable(recipient).transfer(amount);\\n    } else {\\n      IERC20(_quoteCurrencyAddress).transfer(recipient, amount);\\n    }\\n  }\\n\\n  event Cancel(uint id, uint timestamp);\\n\\n  function cancelBuyOrder(uint id) public {\\n    LimitOrder storage order = buy[id];\\n    require(order.trader != address(0), \\\"Order not found\\\");\\n    require(order.trader == msg.sender, \\\"Not your order\\\");\\n    sendQuoteCurrency(order.trader, exactQuoteAmount(order.asset));\\n    delete buy[id];\\n    lastOperation++;\\n    emit Cancel(id, block.timestamp);\\n  }\\n\\n  function cancelSellOrder(uint id) public {\\n    LimitOrder storage order = sell[id];\\n    require(order.trader != address(0), \\\"Order not found\\\");\\n    require(order.trader == msg.sender, \\\"Not your order\\\");\\n    sendBaseCurrency(order.trader, exactBaseAmount(order.asset));\\n    delete sell[id];\\n    lastOperation++;\\n    emit Cancel(id, block.timestamp);\\n  }\\n\\n  uint public lastOperation;\\n\\n  event Close(uint id, uint timestamp);\\n\\n  event MarketSell(uint timestamp, address seller, uint asset, uint value);\\n\\n  function marketSellSafe(uint asset, uint[] memory ids, uint lastSeenOperation) public payable {\\n    require(lastSeenOperation == lastOperation, \\\"Market has been changed\\\");\\n    marketSell(asset, ids);\\n  }\\n\\n  function marketSell(uint asset, uint[] memory ids) public payable {\\n    if(baseCurrencyIsBNB()) {\\n      asset = msg.value;\\n      require(asset >= _baseCurrencyUnit, \\\"Asset too low\\\");\\n    } else {\\n      require(msg.value == 0, \\\"Cannot accept BNB\\\");\\n      require(asset >= _baseCurrencyUnit, \\\"Asset too low\\\");\\n      IERC20(_baseCurrencyAddress).transferFrom(msg.sender, address(this), asset);\\n    }\\n    uint _asset = asset;\\n    uint gain = 0;\\n    for (uint256 i = 0; i < ids.length; i++) {\\n      LimitOrder storage order = buy[ids[i]];\\n      uint48 order_value = order.value;\\n      uint48 order_asset = order.asset;\\n      address buyer = order.trader;\\n      if(buyer == address(0) || order_value == 0 || order_asset == 0) continue;\\n      if(internalBaseAmount(_asset) >= order_value) {\\n        _asset -= exactBaseAmount(order_value);\\n        sendBaseCurrency(buyer, exactBaseAmount(order_value));\\n        gain += exactQuoteAmount(order_asset);\\n        delete buy[ids[i]];\\n        emit Close(ids[i], block.timestamp);\\n        if(_asset < _baseCurrencyUnit) break;\\n      } else {\\n        // new_order_value = order_value - asset\\n        // order_value / order_asset == new_order_value / new_order_asset\\n        // new_order_asset = new_order_value * order_asset / order_value\\n\\n        uint new_order_value = order_value - internalBaseAmount(_asset);\\n        uint new_order_asset = new_order_value * order_asset / order_value;\\n\\n        if(new_order_asset == 0) {\\n          sendBaseCurrency(buyer, exactBaseAmount(order_value));\\n          gain += exactQuoteAmount(order_asset);\\n          delete buy[ids[i]];\\n          emit Close(ids[i], block.timestamp);\\n        } else {\\n          sendBaseCurrency(buyer, exactBaseAmount(internalBaseAmount(_asset)));\\n          gain += exactQuoteAmount(order_asset - uint48(new_order_asset));\\n          order.asset = uint48(new_order_asset);\\n          order.value = uint48(new_order_value);\\n          emit LimitBuy(ids[i], block.timestamp, buyer, exactQuoteAmount(uint48(new_order_asset)), exactBaseAmount(uint48(new_order_value)));\\n        }\\n        _asset = 0;\\n        break;\\n      }\\n    }\\n    if(gain > 0) sendQuoteCurrency(msg.sender, gain);\\n    if(_asset > 0) sendBaseCurrency(msg.sender, _asset);\\n    if(gain > 0) emit MarketSell(block.timestamp, msg.sender, asset - _asset, gain);\\n    lastOperation++;\\n  }\\n\\n  event MarketBuy(uint timestamp, address buyer, uint asset, uint value);\\n\\n  function marketBuySafe(uint asset, uint[] memory ids, uint lastSeenOperation) public payable {\\n    require(lastSeenOperation == lastOperation, \\\"Market changed\\\");\\n    marketBuy(asset, ids);\\n  }\\n\\n  function marketBuy(uint asset, uint[] memory ids) public payable {\\n    if(quoteCurrencyIsBNB()) {\\n      asset = msg.value;\\n      require(asset >= _quoteCurrencyUnit, \\\"Asset too low\\\");\\n    } else {\\n      require(msg.value == 0, \\\"Cannot accept BNB\\\");\\n      require(asset >= _quoteCurrencyUnit, \\\"Asset too low\\\");\\n      IERC20(_quoteCurrencyAddress).transferFrom(msg.sender, address(this), asset);\\n    }\\n    uint _asset = asset;\\n    uint gain = 0;\\n    for (uint256 i = 0; i < ids.length; i++) {\\n      LimitOrder storage order = sell[ids[i]];\\n      uint48 order_value = order.value;\\n      uint48 order_asset = order.asset;\\n      address seller = order.trader;\\n      if(seller == address(0) || order_value == 0 || order_asset == 0) continue;\\n      if(internalQuoteAmount(_asset) >= order_value) {\\n        _asset -= exactQuoteAmount(order_value);\\n        sendQuoteCurrency(seller, exactQuoteAmount(order_value));\\n        gain += exactBaseAmount(order_asset);\\n        delete sell[ids[i]];\\n        emit Close(ids[i], block.timestamp);\\n        if(_asset < _quoteCurrencyUnit) break;\\n      } else {\\n        // new_order_value = order_value - asset\\n        // order_value / order_asset == new_order_value / new_order_asset\\n        // new_order_asset = new_order_value * order_asset / order_value\\n\\n        uint new_order_value = order_value - internalQuoteAmount(_asset);\\n        uint new_order_asset = new_order_value * order_asset / order_value;\\n\\n        if(new_order_asset == 0) {\\n          sendQuoteCurrency(seller, exactQuoteAmount(order_value));\\n          gain += exactBaseAmount(order_asset);\\n          delete sell[ids[i]];\\n          emit Close(ids[i], block.timestamp);\\n        } else {\\n          sendQuoteCurrency(seller, exactQuoteAmount(internalQuoteAmount(_asset)));\\n          gain += exactBaseAmount(order_asset - uint48(new_order_asset));\\n          order.asset = uint48(new_order_asset);\\n          order.value = uint48(new_order_value);\\n          emit LimitSell(ids[i], block.timestamp, seller, exactBaseAmount(uint48(new_order_asset)), exactQuoteAmount(uint48(new_order_value)));\\n        }\\n        _asset = 0;\\n        break;\\n      }\\n    }\\n    if(gain > 0) sendBaseCurrency(msg.sender, gain);\\n    if(_asset > 0) sendQuoteCurrency(msg.sender, _asset);\\n    if(gain > 0) emit MarketBuy(block.timestamp, msg.sender, asset - _asset, gain);\\n    lastOperation++;\\n  }\\n\\n  function checksum() public view returns (bytes32) {\\n    return keccak256(abi.encodePacked((lastOperation << 128) + lastOrder));\\n  }\\n\\n  function symbols() public view returns (string memory, string memory) {\\n    return (\\n      _getSymbol(_baseCurrencyAddress),\\n      _getSymbol(_quoteCurrencyAddress)\\n    );\\n  }\\n\\n  function symbol() public view returns (string memory) {\\n    return string.concat(\\n      _getSymbol(_baseCurrencyAddress),\\n      \\\"/\\\",\\n      _getSymbol(_quoteCurrencyAddress)\\n    );\\n  }\\n\\n  function baseCurrency() public view returns (address) {\\n    return _baseCurrencyAddress;\\n  }\\n\\n  function quoteCurrency() public view returns (address) {\\n    return _quoteCurrencyAddress;\\n  }\\n\\n  function _currencyInfo(address addr) private view returns (string memory name, string memory symbol, uint decimals, address tokenAddress ) {\\n    if(addr == address(0)) {\\n      name = \\\"Binance Coin\\\";\\n      symbol = \\\"BNB\\\";\\n      decimals = 18;\\n      tokenAddress = address(0);\\n    } else {\\n      IERC20Metadata token = IERC20Metadata(addr);\\n      name = token.name();\\n      symbol = token.symbol();\\n      decimals = token.decimals();\\n      tokenAddress = addr;\\n    }    \\n  }\\n\\n  function baseCurrencyInfo() public view returns (string memory name, string memory symbol, uint decimals, address tokenAddress ) { return _currencyInfo(_baseCurrencyAddress);}\\n  function quoteCurrencyInfo() public view returns (string memory name, string memory symbol, uint decimals, address tokenAddress ) { return _currencyInfo(_quoteCurrencyAddress);}\\n\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"baseCurrencyAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"quoteCurrencyAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"baseCurrencyUnit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quoteCurrencyUnit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceDivisor\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Cancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Close\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"asset\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LimitBuy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"asset\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LimitSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"asset\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"MarketBuy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"asset\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"MarketSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"baseCurrency\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseCurrencyInfo\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"cancelBuyOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"cancelSellOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checksum\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastOperation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastOrder\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"asset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"limitBuy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"asset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"limitSell\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"asset\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"marketBuy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"asset\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"lastSeenOperation\",\"type\":\"uint256\"}],\"name\":\"marketBuySafe\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"asset\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"marketSell\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"asset\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"lastSeenOperation\",\"type\":\"uint256\"}],\"name\":\"marketSellSafe\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numberSettings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"baseCurrencyUnit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quoteCurrencyUnit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceDivisor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quoteDivisor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseDivisor\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"quoteCurrency\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"quoteCurrencyInfo\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rangeSettings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxBaseAsset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxBaseValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minBaseAsset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minBaseValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxQuoteAsset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxQuoteValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minQuoteAsset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minQuoteValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minSellPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxSellPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minBuyPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxBuyPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minAsset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAsset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"name\":\"setLimitBuyRanges\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minAsset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAsset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"name\":\"setLimitSellRanges\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbols\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "OrderBook", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000005771b4391b59e868d1275340e14b8e39ee7938c1000000000000000000000000e9e7cea3dedca5984780bafc599bd69add087d56000000000000000000000000000000000000000000000000000000174876e800000000000000000000000000000000000000000000000000000000174876e80000000000000000000000000000000000000000000000000000000000000f4240", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}