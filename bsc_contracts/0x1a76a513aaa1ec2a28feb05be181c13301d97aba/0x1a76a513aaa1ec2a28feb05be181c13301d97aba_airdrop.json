{"SourceCode": "// File: @openzeppelin/contracts/utils/Strings.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n// File: erc721-metadata.sol\r\n\r\npragma solidity 0.8.7;\r\n\r\ninterface ERC721Metadata\r\n{\r\n\r\n  function name()\r\n    external\r\n    view\r\n    returns (string memory _name);\r\n\r\n  function symbol()\r\n    external\r\n    view\r\n    returns (string memory _symbol);\r\n\r\n  function tokenURI(uint256 _tokenId)\r\n    external\r\n    view\r\n    returns (string memory _uri);\r\n\r\n}\r\n// File: address-utils.sol\r\n\r\npragma solidity 0.8.7;\r\n\r\nlibrary AddressUtils\r\n{\r\n  function isContract(\r\n    address _addr\r\n  )\r\n    internal\r\n    view\r\n    returns (bool addressCheck)\r\n  {\r\n    bytes32 codehash;\r\n    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n    assembly { codehash := extcodehash(_addr) } // solhint-disable-line\r\n    addressCheck = (codehash != 0x0 && codehash != accountHash);\r\n  }\r\n\r\n}\r\n// File: erc165.sol\r\n\r\npragma solidity 0.8.7;\r\n\r\ninterface ERC165\r\n{\r\n  function supportsInterface(\r\n    bytes4 _interfaceID\r\n  )\r\n    external\r\n    view\r\n    returns (bool);\r\n    \r\n}\r\n// File: supports-interface.sol\r\n\r\npragma solidity 0.8.7;\r\n\r\n\r\ncontract SupportsInterface is\r\n  ERC165\r\n{\r\n  mapping(bytes4 => bool) internal supportedInterfaces;\r\n\r\n  constructor()\r\n  {\r\n    supportedInterfaces[0x01ffc9a7] = true; // ERC165\r\n  }\r\n\r\n  function supportsInterface(\r\n    bytes4 _interfaceID\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns (bool)\r\n  {\r\n    return supportedInterfaces[_interfaceID];\r\n  }\r\n\r\n}\r\n// File: erc721-token-receiver.sol\r\n\r\npragma solidity 0.8.7;\r\n\r\ninterface ERC721TokenReceiver\r\n{\r\n  function onERC721Received(\r\n    address _operator,\r\n    address _from,\r\n    uint256 _tokenId,\r\n    bytes calldata _data\r\n  )\r\n    external\r\n    returns(bytes4);\r\n\r\n}\r\n// File: erc721.sol\r\n\r\npragma solidity 0.8.7;\r\n\r\ninterface ERC721\r\n{\r\n  event Transfer(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint256 indexed _tokenId\r\n  );\r\n\r\n  event Approval(\r\n    address indexed _owner,\r\n    address indexed _approved,\r\n    uint256 indexed _tokenId\r\n  );\r\n\r\n  event ApprovalForAll(\r\n    address indexed _owner,\r\n    address indexed _operator,\r\n    bool _approved\r\n  );\r\n\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes calldata _data\r\n  )\r\n    external;\r\n\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n  function approve(\r\n    address _approved,\r\n    uint256 _tokenId\r\n  )\r\n    external;\r\n\r\n  function setApprovalForAll(\r\n    address _operator,\r\n    bool _approved\r\n  )\r\n    external;\r\n\r\n  function balanceOf(\r\n    address _owner\r\n  )\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  function ownerOf(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    view\r\n    returns (address);\r\n\r\n  function getApproved(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    view\r\n    returns (address);\r\n\r\n  function isApprovedForAll(\r\n    address _owner,\r\n    address _operator\r\n  )\r\n    external\r\n    view\r\n    returns (bool);\r\n\r\n}\r\n// File: token.sol\r\n\r\npragma solidity 0.8.7;\r\n\r\n\r\n\r\n\r\n\r\ncontract NFToken is\r\n  ERC721,\r\n  SupportsInterface\r\n{\r\n  using AddressUtils for address;\r\n  string constant ZERO_ADDRESS = \"003001\";\r\n  string constant NOT_VALID_NFT = \"003002\";\r\n  string constant NOT_OWNER_OR_OPERATOR = \"003003\";\r\n  string constant NOT_OWNER_APPROVED_OR_OPERATOR = \"003004\";\r\n  string constant NOT_ABLE_TO_RECEIVE_NFT = \"003005\";\r\n  string constant NFT_ALREADY_EXISTS = \"003006\";\r\n  string constant NOT_OWNER = \"003007\";\r\n  string constant IS_OWNER = \"003008\";\r\n  uint256 public constant price = 1 ether;\r\n  bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\r\n\r\n  mapping (uint256 => address) internal idToOwner;\r\n\r\n  mapping (uint256 => address) internal idToApproval;\r\n\r\n  mapping (address => uint256) private ownerToNFTokenCount;\r\n\r\n  mapping (address => mapping (address => bool)) internal ownerToOperators;\r\n\r\n  modifier canOperate(\r\n    uint256 _tokenId\r\n  )\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(\r\n      tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender],\r\n      NOT_OWNER_OR_OPERATOR\r\n    );\r\n    _;\r\n  }\r\n\r\n  modifier canTransfer(\r\n    uint256 _tokenId\r\n  )\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(\r\n      tokenOwner == msg.sender\r\n      || idToApproval[_tokenId] == msg.sender\r\n      || ownerToOperators[tokenOwner][msg.sender],\r\n      NOT_OWNER_APPROVED_OR_OPERATOR\r\n    );\r\n    _;\r\n  }\r\n\r\n  modifier validNFToken(\r\n    uint256 _tokenId\r\n  )\r\n  {\r\n    require(idToOwner[_tokenId] != address(0), NOT_VALID_NFT);\r\n    _;\r\n  }\r\n\r\n  constructor ()\r\n  {\r\n    supportedInterfaces[0x80ac58cd] = true; // ERC721\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes calldata _data\r\n  )\r\n    external\r\n    override\r\n  {\r\n    _safeTransferFrom(_from, _to, _tokenId, _data);\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n  {\r\n    _safeTransferFrom(_from, _to, _tokenId, \"\");\r\n  }\r\n\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n    canTransfer(_tokenId)\r\n    validNFToken(_tokenId)\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(tokenOwner == _from, NOT_OWNER);\r\n    require(_to != address(0), ZERO_ADDRESS);\r\n\r\n    _transfer(_to, _tokenId);\r\n  }\r\n\r\n  function approve(\r\n    address _approved,\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n    canOperate(_tokenId)\r\n    validNFToken(_tokenId)\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(_approved != tokenOwner, IS_OWNER);\r\n\r\n    idToApproval[_tokenId] = _approved;\r\n    emit Approval(tokenOwner, _approved, _tokenId);\r\n  }\r\n\r\n  function setApprovalForAll(\r\n    address _operator,\r\n    bool _approved\r\n  )\r\n    external\r\n    override\r\n  {\r\n    ownerToOperators[msg.sender][_operator] = _approved;\r\n    emit ApprovalForAll(msg.sender, _operator, _approved);\r\n  }\r\n\r\n  function balanceOf(\r\n    address _owner\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns (uint256)\r\n  {\r\n    require(_owner != address(0), ZERO_ADDRESS);\r\n    return _getOwnerNFTCount(_owner);\r\n  }\r\n\r\n  function ownerOf(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns (address _owner)\r\n  {\r\n    _owner = idToOwner[_tokenId];\r\n    require(_owner != address(0), NOT_VALID_NFT);\r\n  }\r\n\r\n  function getApproved(\r\n    uint256 _tokenId\r\n  )\r\n    external\r\n    override\r\n    view\r\n    validNFToken(_tokenId)\r\n    returns (address)\r\n  {\r\n    return idToApproval[_tokenId];\r\n  }\r\n\r\n  function isApprovedForAll(\r\n    address _owner,\r\n    address _operator\r\n  )\r\n    external\r\n    override\r\n    view\r\n    returns (bool)\r\n  {\r\n    return ownerToOperators[_owner][_operator];\r\n  }\r\n\r\n  function _transfer(\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n  {\r\n    address from = idToOwner[_tokenId];\r\n    _clearApproval(_tokenId);\r\n\r\n    _removeNFToken(from, _tokenId);\r\n    _addNFToken(_to, _tokenId);\r\n\r\n    emit Transfer(from, _to, _tokenId);\r\n  }\r\n  \r\n  function _mint(\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    virtual\r\n  {\r\n    require(_to != address(0), ZERO_ADDRESS);\r\n    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\r\n    _addNFToken(_to, _tokenId);\r\n\r\n    emit Transfer(address(0), _to, _tokenId);\r\n  }\r\n    \r\n  function getOwnerOf(\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    virtual\r\n    returns (address _owner)\r\n  {\r\n    _owner = idToOwner[_tokenId];\r\n    require(_owner != address(0), NOT_VALID_NFT);\r\n  }\r\n  \r\n  function _burn(\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    virtual\r\n    validNFToken(_tokenId)\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    _clearApproval(_tokenId);\r\n    _removeNFToken(tokenOwner, _tokenId);\r\n    emit Transfer(tokenOwner, address(0), _tokenId);\r\n  }\r\n\r\n\r\n  function _removeNFToken(\r\n    address _from,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    virtual\r\n  {\r\n    require(idToOwner[_tokenId] == _from, NOT_OWNER);\r\n    ownerToNFTokenCount[_from] -= 1;\r\n    delete idToOwner[_tokenId];\r\n  }\r\n\r\n  function _addNFToken(\r\n    address _to,\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    virtual\r\n  {\r\n    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\r\n\r\n    idToOwner[_tokenId] = _to;\r\n    ownerToNFTokenCount[_to] += 1;\r\n  }\r\n\r\n  function _getOwnerNFTCount(\r\n    address _owner\r\n  )\r\n    internal\r\n    virtual\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return ownerToNFTokenCount[_owner];\r\n  }\r\n\r\n  function _safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes memory _data\r\n  )\r\n    private\r\n    canTransfer(_tokenId)\r\n    validNFToken(_tokenId)\r\n  {\r\n    address tokenOwner = idToOwner[_tokenId];\r\n    require(tokenOwner == _from, NOT_OWNER);\r\n    require(_to != address(0), ZERO_ADDRESS);\r\n\r\n    _transfer(_to, _tokenId);\r\n\r\n    if (_to.isContract())\r\n    {\r\n      bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\r\n      require(retval == MAGIC_ON_ERC721_RECEIVED, NOT_ABLE_TO_RECEIVE_NFT);\r\n    }\r\n  }\r\n\r\n  function _clearApproval(\r\n    uint256 _tokenId\r\n  )\r\n    private\r\n  {\r\n    delete idToApproval[_tokenId];\r\n  }\r\n\r\n}\r\n// File: tokenMeta.sol\r\n\r\npragma solidity 0.8.7;\r\n\r\n\r\n\r\ncontract NFTokenMetadata is\r\n  NFToken,\r\n  ERC721Metadata\r\n{\r\n\r\n  string internal nftName;\r\n\r\n  string internal nftSymbol;\r\n\r\n  mapping (uint256 => string) internal idToUri;\r\n\r\n  constructor()\r\n  {\r\n    supportedInterfaces[0x5b5e139f] = true; // ERC721Metadata\r\n  }\r\n\r\n  function name()\r\n    external\r\n    override\r\n    view\r\n    returns (string memory _name)\r\n  {\r\n    _name = nftName;\r\n  }\r\n\r\n  function symbol()\r\n    external\r\n    override\r\n    view\r\n    returns (string memory _symbol)\r\n  {\r\n    _symbol = nftSymbol;\r\n  }\r\nfunction tokenURI(uint256 _tokenId)\r\n    public\r\n    virtual\r\n    override\r\n    view\r\n    validNFToken(_tokenId)\r\n    returns (string memory)\r\n  {\r\n    return idToUri[_tokenId];\r\n  }\r\n  function _burn(\r\n    uint256 _tokenId\r\n  )\r\n    internal\r\n    override\r\n    virtual\r\n  {\r\n    super._burn(_tokenId);\r\n\r\n    delete idToUri[_tokenId];\r\n  }\r\n\r\n  function _setTokenUri(\r\n    uint256 _tokenId,\r\n    string memory _uri\r\n  )\r\n    internal\r\n    validNFToken(_tokenId)\r\n  {\r\n    idToUri[_tokenId] = _uri;\r\n  }\r\n\r\n}\r\n// File: ownable.sol\r\n\r\npragma solidity 0.8.7;\r\n\r\ncontract Ownable \r\n{\r\n\r\n  string public constant NOT_CURRENT_OWNER = \"018001\";\r\n  string public constant CANNOT_TRANSFER_TO_ZERO_ADDRESS = \"018002\";\r\n\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  constructor()\r\n  {\r\n    owner = msg.sender;\r\n  }\r\n  \r\n  modifier onlyOwner()\r\n  {\r\n    require(msg.sender == owner, NOT_CURRENT_OWNER);\r\n    _;\r\n  }\r\n\r\n  function transferOwnership(\r\n    address _newOwner\r\n  )\r\n    public\r\n    onlyOwner\r\n  {\r\n    require(_newOwner != address(0), CANNOT_TRANSFER_TO_ZERO_ADDRESS);\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n\r\n}\r\n// File: airdrop.sol\r\n\r\npragma solidity 0.8.7;\r\n\r\n\r\n\r\n\r\n\r\ncontract airdrop is NFTokenMetadata, Ownable {\r\n\r\n    string theURI;\r\n\r\n    constructor() {\r\n        nftName = \"3D Ghospers\"; \r\n        nftSymbol = \"3DGHSP\";\r\n        theURI = \"https://rba.group/ghospers/\";\r\n    }\r\n\r\n    function _airdrop(address[] memory tokenOwnersArray, uint256[] memory token_IDs) public onlyOwner {\r\n        for(uint256 i=0; i<tokenOwnersArray.length; i++){\r\n            super._mint(tokenOwnersArray[i], token_IDs[i]);\r\n        }\r\n    }\r\n\r\n    function setURI(string memory _newURI) public onlyOwner {\r\n        theURI = _newURI;\r\n    }\r\n\r\n    function tokenURI(uint256 _id) override public view returns (string memory) {\r\n        return string(abi.encodePacked( theURI,\r\n            \"\",Strings.toString(_id)\r\n        ));\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CANNOT_TRANSFER_TO_ZERO_ADDRESS\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NOT_CURRENT_OWNER\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokenOwnersArray\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"token_IDs\",\"type\":\"uint256[]\"}],\"name\":\"_airdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_newURI\",\"type\":\"string\"}],\"name\":\"setURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "airdrop", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://491610a59f8ad6a6d023ce05f2bf65a89175d471945ba3a85c7d334abdacaa62"}