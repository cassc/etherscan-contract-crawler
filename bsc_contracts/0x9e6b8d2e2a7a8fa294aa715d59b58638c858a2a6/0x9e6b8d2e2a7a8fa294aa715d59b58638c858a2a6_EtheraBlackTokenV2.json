{"SourceCode": "/**\r\n * #EtheraBlack - Ethera Black Token ($ETB)\r\n *\r\n * #EtheraBlack features:\r\n * Total supply: 10,000,000,000,000,000.000000000\r\n * 12% fee will burned when selling;\r\n * The #EtheraBlack token will deflate it self in supply with every transaction by burning;\r\n * 25% supply is burned at start;\r\n * 25% more will be tokens will be burned on a schedule;\r\n * Totaling 50% of total burn;\r\n * 5% supply will go to a MarketingBlack wallet;\r\n * 1% supply will go to a Manager wallet;\r\n *\r\n * MarketingBlack wallet address : 0x3A171e5176Ed27a90ceB96E6992c79a554C6Bc61\r\n * EtheraBets wallet address     : 0xf0bd6baB705092fcd594eec296CAb8cc1B412240\r\n * Manager wallet address        : 0x65eBeE14F35405A91C97e2756C1c6fc20b52205B\r\n *\r\n * Official site    : http://etherablack.com/\r\n * Instagram profile: @ethera.cc\r\n * Telegram chat    : t.me/ethaETA \r\n */\r\n\r\npragma solidity ^0.8.7;\r\n// SPDX-License-Identifier: Unlicensed\r\n\r\n/**\r\n * @dev BEP20 Token interface\r\n */\r\ninterface IBEP20 {\r\n\tfunction getOwner() external view returns (address);\r\n\tfunction name() external view returns (string memory);\r\n\tfunction symbol() external view returns (string memory);\r\n\tfunction decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n * \r\n * from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\r\n */\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) { \r\n        uint256 size; \r\n\r\n        assembly { size := extcodesize(account) } \r\n\r\n        return size > 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) { return functionCall(target, data, \"Address: low-level call failed\"); }\r\n\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) { return functionCallWithValue(target, data, 0, errorMessage); }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) { return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\"); }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) { return functionStaticCall(target, data, \"Address: low-level static call failed\"); }\r\n\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) { return functionDelegateCall(target, data, \"Address: low-level delegate call failed\"); }\r\n\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) internal pure returns (bytes memory) {\r\n        if (success) { \r\n            return returndata; \r\n        } else { \r\n            if (returndata.length > 0) { \r\n                assembly { \r\n                    let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) \r\n                } \r\n            } else { \r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Wrappers around BEP20 operations that throw on failure (when the token\r\n * contract returns false).\r\n * \r\n * from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol\r\n */\r\nlibrary SafeBEP20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(IBEP20 token, address to, uint256 value) internal { _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value)); }\r\n\r\n    function safeTransferFrom(IBEP20 token, address from, address to, uint256 value) internal { _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value)); }\r\n\r\n    function safeApprove(IBEP20 token, address spender, uint256 value) internal {\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0), \"SafeBEP20: approve from non-zero to non-zero allowance\");\r\n\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IBEP20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance)); \r\n    }\r\n\r\n    function safeDecreaseAllowance(IBEP20 token, address spender, uint256 value) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n\r\n            require(oldAllowance >= value, \"SafeBEP20: decreased allowance below zero\");\r\n\r\n            uint256 newAllowance = oldAllowance - value;\r\n\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        }\r\n    }\r\n\r\n    function _callOptionalReturn(IBEP20 token, bytes memory data) private {\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeBEP20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { require(abi.decode(returndata, (bool)), \"SafeBEP20: BEP20 operation did not succeed\"); }\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations.\r\n * \r\n * from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol\r\n */\r\nlibrary SafeMath {\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) { \r\n        unchecked { \r\n            uint256 c = a + b; \r\n\r\n            if (c < a) return (false, 0);\r\n\r\n            return (true, c); \r\n        }\r\n    }\r\n\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) { \r\n        unchecked { \r\n            if (b > a) return (false, 0);\r\n\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) { \r\n        unchecked { \r\n            if (a == 0) return (true, 0); \r\n\r\n            uint256 c = a * b;\r\n\r\n            if (c / a != b) return (false, 0); \r\n\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) { \r\n        unchecked { \r\n            if (b == 0) return (false, 0); \r\n\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) { \r\n        unchecked { \r\n            if (b == 0) return (false, 0); \r\n\r\n            return (true, a % b); \r\n        }\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) { return a + b; }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) { return a - b; }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) { return a * b; }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) { return a / b; }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) { return a % b; }\r\n\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \r\n        unchecked { \r\n            require(b <= a, errorMessage);\r\n\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \r\n        unchecked { \r\n            require(b > 0, errorMessage); \r\n\r\n            return a / b; \r\n        }\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { \r\n        unchecked { \r\n            require(b > 0, errorMessage); \r\n\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Add Pancake Router and Pancake Pair interfaces\r\n * \r\n * from https://github.com/pancakeswap/pancake-swap-periphery/blob/master/contracts/interfaces/IPancakeRouter01.sol\r\n */\r\ninterface IPancakeRouter01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n    function addLiquidity(address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\n// from https://github.com/pancakeswap/pancake-swap-periphery/blob/master/contracts/interfaces/IPancakeRouter02.sol\r\ninterface IPancakeRouter02 is IPancakeRouter01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint amountETH);\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\r\n}\r\n\r\n// from https://github.com/pancakeswap/pancake-swap-core/blob/master/contracts/interfaces/IPancakeFactory.sol\r\ninterface IPancakeFactory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n    function setRewardFeeTo(address) external;\r\n    function setRewardFeeToSetter(address) external;\r\n}\r\n\r\n// from https://github.com/pancakeswap/pancake-swap-core/blob/master/contracts/interfaces/IPancakePair.sol\r\ninterface IPancakePair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(address indexed sender, uint amount0In, uint amount1In, uint amount0Out, uint amount1Out, address indexed to);\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n    function initialize(address, address) external;\r\n}\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol\r\n */\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    uint256 private _status;\r\n\r\n    constructor() { _status = _NOT_ENTERED; }\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        _status = _ENTERED;\r\n        _;\r\n\t\t_status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) { return payable(msg.sender); }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) { \r\n        this;  \r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    constructor() {\r\n        _owner = _msgSender();\r\n\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n\tfunction owner() public view returns (address) { return _owner; }\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n}\r\n\r\n/**\r\n * @dev Main Contract module\r\n */\r\ncontract EtheraBlackTokenV2 is IBEP20, ReentrancyGuard, Context, Ownable {\r\n\tusing Address for address;\r\n\tusing SafeBEP20 for IBEP20;\r\n\tusing SafeMath for uint256;\r\n\r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\tmapping(address => bool) private _isLockedWallet;\r\n    mapping(address => bool) private _isExcludedFromMax;\r\n\tmapping(address => bool) private _isExcludedFromFee;\r\n\tmapping(address => bool) private _isExcludedFromReward;\r\n\tmapping(address => uint256) private _sellLimits;\r\n\t\r\n\t/**\r\n\t * @dev For Pancakeswap Router V2, use:\r\n\t * 0x10ED43C718714eb63d5aA57B78B54704E256024E to Mainnet Binance Smart Chain;\r\n     * 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3 to Testnet Binance Smart Chain;\r\n\t *\r\n\t * For WBNB/BUSD Liquidity Pool Pair, use:\r\n\t * 0x58F876857a02D6762E0101bb5C46A8c1ED44Dc16 to Mainnet Binance Smart Chain;\r\n\t * 0xe0e92035077c39594793e61802a350347c320cf2 to Testnet Binance Smart Chain;\r\n\t *\r\n\t * For Ethera Black Token, use:\r\n\t * 0xAc60ABc93dcEFD821BE3D197918203563Fa1E338 to Mainnet Binance Smart Chain;\r\n\t * 0x33819A32931a7D9160cc5c17E48B0e65ccE99A29 to Testnet Binance Smart Chain;\r\n\t */\r\n\tIPancakeRouter02 private constant _pancakeRouterAddress = IPancakeRouter02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n\t//IPancakeRouter02 private constant _pancakeRouterAddress = IPancakeRouter02(0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3);\r\n\tIPancakePair private constant _bnbBusdPairAddress       = IPancakePair(0x58F876857a02D6762E0101bb5C46A8c1ED44Dc16);\r\n\t//IPancakePair private constant _bnbBusdPairAddress       = IPancakePair(0xe0e92035077c39594793e61802a350347c320cf2);\r\n\taddress private constant _etheraBlackTokenAddress       = 0xAc60ABc93dcEFD821BE3D197918203563Fa1E338;\r\n\t//address private constant _etheraBlackTokenAddress       = 0x33819A32931a7D9160cc5c17E48B0e65ccE99A29;\r\n\r\n\t// burn address\r\n\taddress private constant _burnAddress = 0x000000000000000000000000000000000000dEaD;\r\n\r\n\t// Dev's wallets\r\n\taddress payable public constant marketingBlack = payable(0x3A171e5176Ed27a90ceB96E6992c79a554C6Bc61);\r\n\taddress public constant etheraBetsWallet       = 0xf0bd6baB705092fcd594eec296CAb8cc1B412240;\r\n\taddress private constant _managerWallet        = 0x65eBeE14F35405A91C97e2756C1c6fc20b52205B;\r\n\r\n\tstring private constant _name         = \"Ethera Black\";\r\n    string private constant _symbol       = \"ETB\";\r\n\tuint8 private constant _decimals      = 9;\r\n\tuint256 private constant _totalSupply = 10 * 10**15 * 10**_decimals; // 10Q\r\n\r\n\t// custom variables system\r\n\tuint256 public buyMaxTxAmountLPPercent = 50;   // 50% of EtheraBlack Token on Liquidity Pool\r\n\tuint256 public sellMaxTxAmountPerDolar = 1000; // $1000 to sell of EtheraBlack Token balance of the owner\r\n\tuint256 public otherMaxTxAmountPercent = 100;  // 100% of EtheraBlack Token balance of the owner\r\n\r\n    uint256 public buyBurnFee   = 0;  // 0% Fee to burn on buy\r\n\tuint256 public sellBurnFee  = 12; // 12% Fee to burn on sell\r\n\tuint256 public otherBurnFee = 50; // 50% Fee to burn on other transaction\r\n\r\n\tuint256 public buyMarketingFee   = 0; // 0% Fee to Marketing wallet on buy\r\n\tuint256 public sellMarketingFee  = 0; // 0% Fee to Marketing wallet on sell\r\n\tuint256 public otherMarketingFee = 0; // 0% Fee to Marketing wallet on other transaction\r\n\r\n\tuint256 public buyEtheraBetsFee   = 0; // 0% Fee to Etherabets wallet on buy\r\n\tuint256 public sellEtheraBetsFee  = 0; // 0% Fee to Etherabets wallet on sell\r\n\tuint256 public otherEtheraBetsFee = 0; // 0% Fee to Etherabets wallet on other transaction\r\n\r\n\tuint256 public maxOfBnbToSwapPercent      = 10;  // 10% of BNBs on Liquidity Pool permited to swap\r\n\tuint256 public inittialBNBInLiquidityPool = 600; // 600 BNBs\r\n\r\n\tuint256 public etbTokenBalanceOverRage         = _totalSupply / 1000; // 10T\r\n\tuint256 public etbTokenMaxBalanceToSellPercent = 5;                   // 5%\r\n\r\n\tuint256 public numOfEtbTokensToSwap = _totalSupply / 2000; // number of tokens accumulated to exchange (0.05% of total supply)\r\n\tbool public isSwapTokensEnabled     = false;\r\n\r\n\tbool public isLockedSellEnabled = false;\r\n\tbool public isLockedSellPerTime = true;\r\n\tuint256 public sellBackMaxTime  = 1 days; // 24 hours to permit sells\r\n\r\n\tuint256 private _maxTxAmount;\r\n    uint256 private _burnFee;\r\n    uint256 private _previousBurnFee;\r\n\tuint256 private _marketingFee;\r\n    uint256 private _previousMarketingFee;\r\n    uint256 private _etheraBetsFee;\r\n    uint256 private _previousEtheraBetsFee;\r\n    uint256 private _tBurnTotal;\r\n    uint256 private _tFeeTotal;\r\n\tbool private _inSwapTokens;\r\n\r\n\t// struct to store time of sells\r\n\tstruct SellHistories {\r\n        address account;\r\n\t\tuint256 time;\r\n    }\r\n\r\n\t// LookBack into historical sale data\r\n    SellHistories[] private _sellHistories;\r\n\r\n\tIPancakeRouter02 public immutable pancakeRouter;\r\n    address public immutable pancakePair;\r\n\r\n\tconstructor() {\r\n\t\t// Create a pancake pair for this new token, setting ethera token address\r\n\t\tpancakePair   = IPancakeFactory(_pancakeRouterAddress.factory()).createPair(address(this), _pancakeRouterAddress.WETH());\r\n\t\tpancakeRouter = _pancakeRouterAddress;\r\n\r\n\t\t// exclude owner, this contract, burn address, marketing black wallet, etherabets wallet and manager wallet from limits of transaction\r\n\t\t_isExcludedFromMax[owner()]          = true;\r\n\t\t_isExcludedFromMax[address(this)]    = true;\r\n\t\t_isExcludedFromMax[_burnAddress]     = true;\r\n\t\t_isExcludedFromMax[marketingBlack]   = true;\r\n\t\t_isExcludedFromMax[etheraBetsWallet] = true;\r\n\t\t_isExcludedFromMax[_managerWallet]   = true;\r\n\r\n\t\t// exclude owner, this contract, burn address, marketing black wallet, etherabets wallet and manager wallet from fees\r\n\t\t_isExcludedFromFee[owner()]          = true;\r\n\t\t_isExcludedFromFee[address(this)]    = true;\r\n\t\t_isExcludedFromFee[_burnAddress]     = true;\r\n\t\t_isExcludedFromFee[marketingBlack]   = true;\r\n\t\t_isExcludedFromFee[etheraBetsWallet] = true;\r\n\t\t_isExcludedFromFee[_managerWallet]   = true;\r\n\r\n\t\t// set totalSupply variable\r\n\t\t_balances[_msgSender()] = _totalSupply;\r\n\r\n\t\temit Transfer(address(0), _msgSender(), _totalSupply);\r\n    }\r\n\r\n\tmodifier lockTheSwap {\r\n        _inSwapTokens = true;\r\n        _;\r\n        _inSwapTokens = false;\r\n    }\r\n\r\n\t// to receive BNBs\r\n    receive() external payable {\r\n\t\tif (msg.value != 0) { \r\n\t\t    marketingBlack.transfer(msg.value);\r\n\t\t}\r\n\t}\r\n\r\n    function getOwner() external view override returns (address) { return owner(); }\r\n\r\n    function name() external pure override returns (string memory) { return _name; }\r\n\r\n    function symbol() external pure override returns (string memory) { return _symbol; }\r\n\r\n    function decimals() external pure override returns (uint8) { return _decimals; }\r\n\r\n    function totalSupply() public view override returns (uint256) { return _totalSupply.sub(_tBurnTotal); }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) { return _balances[account]; }\r\n\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"BEP20: transfer amount exceeds allowance\"));\r\n\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) external override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) external view override returns (uint256) { return _allowances[owner][spender]; }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"BEP20: decreased allowance below zero\"));\r\n\r\n        return true;\r\n    }\r\n\r\n    function doLockWallet(address account) external onlyOwner {\r\n\t\trequire(!_isLockedWallet[account], \"Account is already locked\");\r\n\r\n        _isLockedWallet[account] = true;\r\n    }\r\n\r\n    function doUnlockWallet(address account) external onlyOwner {\r\n\t\trequire(_isLockedWallet[account], \"Account is not locked\");\r\n\r\n        _isLockedWallet[account] = false;\r\n    }\r\n\r\n    function isLockedWallet(address account) external view returns(bool) { return _isLockedWallet[account]; }\r\n\r\n\tfunction doExcludeFromMax(address account) external onlyOwner {\r\n\t\trequire(!_isExcludedFromMax[account], \"Account is already excluded from limits\");\r\n\r\n\t\t_isExcludedFromMax[account] = true; \r\n\t}\r\n\r\n    function doIncludeInMax(address account) external onlyOwner {\r\n\t\trequire(_isExcludedFromMax[account], \"Account is not excluded from limits\");\r\n\r\n\t\t_isExcludedFromMax[account] = false; \r\n\t}\r\n\r\n\tfunction isExcludedFromMax(address account) external view returns (bool) { return _isExcludedFromMax[account]; }\r\n\r\n    function doExcludeFromFee(address account) external onlyOwner {\r\n\t\trequire(!_isExcludedFromFee[account], \"Account is already excluded from fees\");\r\n\r\n        _isExcludedFromFee[account] = true;\r\n    }\r\n\r\n\tfunction doIncludeInFee(address account) external onlyOwner {\r\n\t\trequire(_isExcludedFromFee[account], \"Account is not excluded from fees\");\r\n\r\n\t\t_isExcludedFromFee[account] = false;\r\n    }\r\n\r\n    function isExcludedFromFee(address account) external view returns(bool) { return _isExcludedFromFee[account]; }\r\n\r\n\tfunction doIncludeInRewardOfEtheraBets(address account) external onlyOwner {\r\n\t\trequire(_isExcludedFromReward[account], \"Account is not excluded from reward\");\r\n\r\n\t\t_isExcludedFromReward[account] = false;\r\n    }\r\n\r\n\tfunction isExcludedFromRewardOfEtheraBets(address account) external view returns (bool) { return _isExcludedFromReward[account]; }\r\n\r\n\tfunction doIncludeAccountInSellLimitsInDolar(address account, uint256 value) external onlyOwner {\r\n\t\t(address busdTokenAddress, , , ) = _tokensInLiquidityPool(_bnbBusdPairAddress);\r\n\r\n\t\trequire(value >= 1 && value <= IBEP20(busdTokenAddress).totalSupply().div(10**18), \"Value out of range: values between 1 and total supply of BUSD\");\r\n\t\trequire(_sellLimits[account] == 0, \"Account is already included in sell limits\");\r\n\r\n\t\t_sellLimits[account] = _sellLimits[account].add(value); \r\n\t}\r\n\r\n\tfunction doExcludeAccountFromSellLimitsInDolar(address account) external onlyOwner {\r\n\t\trequire(_sellLimits[account] != 0, \"Account is not included in sell limits\");\r\n\r\n\t\t_sellLimits[account] = _sellLimits[account].sub(_sellLimits[account]); \r\n\t}\r\n\r\n\tfunction amountOfAccountInSellLimitsInDolar(address account) public view returns (uint256) { return _sellLimits[account]; }\r\n\r\n\tfunction setBuyMaxTxAmountLPPercent(uint256 value) external onlyOwner {\r\n\t\trequire(value >= 0 && value <= 100, \"Value out of range: values between 0 and 100\");\r\n\r\n        buyMaxTxAmountLPPercent = value;\r\n    }\r\n\r\n\tfunction setSellMaxTxAmountPerDolar(uint256 value) external onlyOwner {\r\n\t\t(address busdTokenAddress, , , ) = _tokensInLiquidityPool(_bnbBusdPairAddress);\r\n\r\n\t\trequire(value >= 1 && value <= IBEP20(busdTokenAddress).totalSupply().div(10**18), \"Value out of range: values between 1 and total supply of BUSD\");\r\n\r\n\t    sellMaxTxAmountPerDolar = value;\r\n\t}\r\n\r\n\tfunction setOtherMaxTxAmountPercent(uint256 value) external onlyOwner {\r\n\t\trequire(value >= 0 && value <= 100, \"Value out of range: values between 0 and 100\");\r\n\r\n\t    otherMaxTxAmountPercent = value;\r\n\t}\r\n\r\n    function setBuyBurnFeePercent(uint256 value) external onlyOwner {\r\n\t\trequire(value >= 0 && value <= 100, \"Value out of range: values between 0 and 100\");\r\n\r\n        buyBurnFee = value;\r\n    }\r\n\r\n    function setSellBurnFeePercent(uint256 value) external onlyOwner {\r\n\t\trequire(value >= 0 && value <= 100, \"Value out of range: values between 0 and 100\");\r\n\r\n        sellBurnFee = value;\r\n    }\r\n\r\n    function setOtherBurnFeePercent(uint256 value) external onlyOwner {\r\n\t\trequire(value >= 0 && value <= 100, \"Value out of range: values between 0 and 100\");\r\n\r\n        otherBurnFee = value;\r\n    }\r\n\r\n\tfunction setBuyMarketingFeePercent(uint256 value) external onlyOwner {\r\n\t\trequire(value >= 0 && value <= 100, \"Value out of range: values between 0 and 100\");\r\n\r\n        buyMarketingFee = value;\r\n    }\r\n\r\n    function setSellMarketingFeePercent(uint256 value) external onlyOwner {\r\n\t\trequire(value >= 0 && value <= 100, \"Value out of range: values between 0 and 100\");\r\n\r\n        sellMarketingFee = value;\r\n    }\r\n\r\n    function setOtherMarketingFeePercent(uint256 value) external onlyOwner {\r\n\t\trequire(value >= 0 && value <= 100, \"Value out of range: values between 0 and 100\");\r\n\r\n        otherMarketingFee = value;\r\n    }\r\n\r\n\tfunction setBuyEtheraBetsFeePercent(uint256 value) external onlyOwner {\r\n\t\trequire(value >= 0 && value <= 100, \"Value out of range: values between 0 and 100\");\r\n\r\n        buyEtheraBetsFee = value;\r\n    }\r\n\r\n    function setSellEtheraBetsFeePercent(uint256 value) external onlyOwner {\r\n\t\trequire(value >= 0 && value <= 100, \"Value out of range: values between 0 and 100\");\r\n\r\n        sellEtheraBetsFee = value;\r\n    }\r\n\r\n    function setOtherEtheraBetsFeePercent(uint256 value) external onlyOwner {\r\n\t\trequire(value >= 0 && value <= 100, \"Value out of range: values between 0 and 100\");\r\n\r\n        otherEtheraBetsFee = value;\r\n    }\r\n\r\n\tfunction setMaxOfBnbToSwapPercent(uint256 value) external onlyOwner {\r\n\t\trequire(value >= 0 && value <= 100, \"Value out of range: values between 0 and 100\");\r\n\r\n\t\tmaxOfBnbToSwapPercent = value;\r\n\t}\r\n\r\n\tfunction setInittialBNBInLiquidityPool(uint256 value) external onlyOwner {\r\n\t\trequire(value >= 1 && value <= IBEP20(pancakeRouter.WETH()).totalSupply().div(10**18), \"Value out of range: values between 1 and total supply of BNB\");\r\n\r\n\t\tinittialBNBInLiquidityPool = value;\r\n\t}\r\n\r\n\tfunction setEtbTokenBalanceOverRage(uint256 value) external onlyOwner {\r\n        require(value >= 1 && value <= totalSupply().div(10**_decimals), \"Value out of range: values between 1 and total supply of ETB\");\r\n\r\n\t\tetbTokenBalanceOverRage = value.mul(10**_decimals);\r\n    }\r\n\r\n\tfunction setEtbTokenMaxBalanceToSellPercent(uint256 value) external onlyOwner {\r\n\t\trequire(value >= 0 && value <= 100, \"Value out of range: values between 0 and 100\");\r\n\r\n\t\tetbTokenMaxBalanceToSellPercent = value;\r\n\t}\r\n\r\n\tfunction setNumOfEtbTokensToSwap(uint256 value) external onlyOwner {\r\n        (, uint256 maxValue, , ) = _tokensInLiquidityPool(IPancakePair(pancakePair));\r\n\r\n        require(maxValue != 0, \"Contract without liquidity!\");\r\n        require(value >= 0 && value <= maxValue.div(10**_decimals), \"Value out of range: values between 0 and max of ETB in liquidity Pool\");\r\n\r\n\t\tnumOfEtbTokensToSwap = value.mul(10**_decimals);\r\n    }\r\n\r\n\tfunction setSwapTokensEnabled(bool enabled) external onlyOwner {\r\n\t\tisSwapTokensEnabled = enabled;\r\n    }\r\n\r\n\tfunction setLockedSellEnabled(bool enabled) external onlyOwner {\r\n\t\tisLockedSellEnabled = enabled;\r\n\t}\r\n\r\n\tfunction setLockedSellPerTime(bool enabled) external onlyOwner {\r\n\t\tisLockedSellPerTime = enabled;\r\n\t}\r\n\r\n\tfunction setSellBackMaxTime(uint256 value) external onlyOwner {\r\n\t\trequire(isLockedSellPerTime, \"Time sale control is not activated\");\r\n\t\trequire(value >= 0 && value <= 1 weeks, \"Value out of range: values between 0 and 1 week in unix timestamp\");\r\n\r\n\t\tsellBackMaxTime = value;\r\n\t}\r\n\r\n\tfunction getLeftTimeToSell(address account) external view returns (uint256) { return _locateAccountSellHistories(account); }\r\n\r\n\tfunction inittialTotalSupply() external pure returns (uint256) { return _totalSupply; }\r\n\r\n\tfunction totalEtheraBlackBurnt() external view returns (uint256) { return _tBurnTotal; }\r\n\r\n    function totalFees() external view returns (uint256) { return _tFeeTotal; }\r\n\r\n\tfunction ClaimETBTokens() external returns (bool success) {\r\n\t\taddress sender     = _msgSender();\r\n\t\tIBEP20 etbV1Token  = IBEP20(_etheraBlackTokenAddress);\r\n\t\tuint256 etbBalance = etbV1Token.balanceOf(sender);\r\n\r\n\t\trequire(etbBalance != 0, \"You have no ETBv1 balance\");\r\n\t\trequire(balanceOf(sender) == 0, \"You already have ETBv2 in your wallet\");\r\n\t\trequire(etbV1Token.allowance(sender, address(this)) == etbBalance, \"it is necessary to approve this transaction\");\r\n\r\n\t\tetbV1Token.safeTransferFrom(sender, _burnAddress, etbBalance);\r\n\t\t_transfer(address(this), sender, etbBalance);\r\n\r\n\t\treturn true;\r\n    }\r\n\r\n\tfunction clearETBTokens(uint256 amountPercent) external onlyOwner {\r\n        require(amountPercent >= 0 && amountPercent <= 100, \"Value out of range: values between 0 and 100\");\r\n\t\t// gets the ETB tokens left over from contract\r\n\t\tuint256 etbAmount = balanceOf(address(this));\r\n\r\n\t\tif (etbAmount != 0) {\r\n\t\t\t_transfer(address(this), owner(), etbAmount.mul(amountPercent).div(10**2));\r\n\t\t}\r\n    }\r\n\r\n\tfunction _transfer(address from, address to, uint256 amount) private nonReentrant {\r\n        require(from != address(0), \"BEP20: transfer from the zero address\");\r\n        require(to != address(0), \"BEP20: transfer to the zero address\");\r\n        require(amount != 0, \"Transfer amount must be greater than zero\");\r\n\r\n        // prevents transfer of blocked wallets\r\n        require(!_isLockedWallet[from] || !_isLockedWallet[to], \"Locked addresses cannot call this function\");\r\n\r\n\t\t// lock sales\r\n        if (to == pancakePair) { // Sell\r\n            require(!isLockedSellEnabled, \"Unable to sell tokens at the moment\");\r\n        }\r\n\r\n        // sales (holder -> pair) control by time\r\n\t\tif (to == pancakePair && !_isExcludedFromMax[from] && isLockedSellPerTime) {\r\n\t\t\trequire(block.timestamp - _locateAccountSellHistories(from) > sellBackMaxTime, \"Sale allowed only after some hours\");\r\n\t\t}\r\n\r\n        // exclude from max\r\n        if (!_isExcludedFromMax[from] && !_isExcludedFromMax[to] && from != owner() && to != owner()) {\r\n            (, uint256 etbTokenAmount, , uint256 bnbAmount) = _tokensInLiquidityPool(IPancakePair(pancakePair));\r\n\t\t\t// set _maxTxAmount to buy, sell or other action\r\n            if (from == pancakePair) {\r\n\t\t\t\t_maxTxAmount = etbTokenAmount.mul(buyMaxTxAmountLPPercent).div(10**2);\r\n            } else if (to == pancakePair) {\r\n\t\t\t\t_maxTxAmount = _etbTokensMaxPermited(from, etbTokenAmount, bnbAmount);\r\n            } else {\r\n                _maxTxAmount = balanceOf(from).mul(otherMaxTxAmountPercent).div(10**2);\r\n            }\r\n\r\n            require(_maxTxAmount != 0, \"maxTxAmount must be greater than zero.\");\r\n            require(amount <= _maxTxAmount, \"Transfer amount exceeds the maxTxAmount.\");\r\n        }\r\n\r\n\t\t// is the token balance of this contract address over the min number of\r\n        // tokens that we need to initiate a swap + liquidity lock?\r\n\t\tuint256 contractTokenBalance = balanceOf(address(this));\r\n        bool overMinTokenBalance     = contractTokenBalance >= numOfEtbTokensToSwap;\r\n\r\n        if (overMinTokenBalance && !_inSwapTokens &&\r\n\t\t    from != pancakePair && isSwapTokensEnabled) {\r\n            contractTokenBalance = numOfEtbTokensToSwap;\r\n            // swap Tokens for BNB and transfer BNBs to Marketing Wallet \r\n            _swapAndtransferBnbToMarketingBlack(contractTokenBalance);\r\n        }\r\n\r\n        // indicates if fee should be deducted from transfer\r\n        bool takeFee = true;\r\n\r\n        // if any account belongs to _isExcludedFromFee account then remove the fee\r\n        if (_isExcludedFromFee[from] || _isExcludedFromFee[to]) {\r\n            takeFee = false;\r\n        } else {\r\n            // set _taxFee and _liquidityFee to buy or sell action\r\n            if (from == pancakePair) { // Buy\r\n                _burnFee       = buyBurnFee;\r\n\t\t\t\t_marketingFee  = buyMarketingFee;\r\n                _etheraBetsFee = buyEtheraBetsFee;\r\n            } else if (to == pancakePair) { // Sell\r\n                _burnFee       = sellBurnFee;\r\n                _marketingFee  = sellMarketingFee;\r\n\t\t\t\t_etheraBetsFee = sellEtheraBetsFee;\r\n            } else { // other\r\n                _burnFee       = otherBurnFee;\r\n                _marketingFee  = otherMarketingFee;\r\n\t\t\t\t_etheraBetsFee = otherEtheraBetsFee;\r\n            }\r\n        }\r\n\r\n        // transfer amount, it will take tax, burn fee\r\n        if (!takeFee) _removeAllFee();\r\n\r\n        (uint256 tTransferAmount, uint256 tBurnFee, uint256 tMarketingFee, uint256 tEtheraBetsFee) = _getTValues(amount);\r\n\r\n\t\t_balances[from] = _balances[from].sub(amount);\r\n        if (to == _burnAddress) {\r\n            _burnEtb(from, tTransferAmount);\r\n        } else {\r\n            _balances[to] = _balances[to].add(tTransferAmount);\r\n\r\n            emit Transfer(from, to, tTransferAmount);\r\n\r\n\t\t    _burnEtb(from, tBurnFee);\r\n\t\t    _transferFees(from, tMarketingFee, tEtheraBetsFee);\r\n            _tFeeTotal = _tFeeTotal.add(tBurnFee).add(tMarketingFee).add(tEtheraBetsFee);\r\n        }\r\n\r\n        if (!takeFee) _restoreAllFee();\r\n\r\n\t\t// buys (pair -> holder) and sales (holder -> pair) control by time\r\n        if (from == pancakePair && !_isExcludedFromMax[to] && isLockedSellPerTime) { // Buy\r\n\t\t\tuint256 timeCtrlToBuy = _locateAccountSellHistories(to);\r\n\r\n            /** \r\n             * sale time lock valid only for the first purchase, \r\n             * from the second purchase onwards it will not be included in the record,\r\n             * if time lock expires will be add the current time, \r\n             * the investor can sell their tokens at any time the sale lock expires.\r\n             */\r\n            if (timeCtrlToBuy == 0 || block.timestamp - timeCtrlToBuy > sellBackMaxTime) { \r\n\t\t\t\t_addAccountSellHistories(to);\r\n\t\t\t}\r\n\t\t} else if (to == pancakePair && !_isExcludedFromMax[from] && isLockedSellPerTime) { // Sell\r\n\t\t\t_addAccountSellHistories(from);\r\n\t\t\tif (!_isExcludedFromReward[from]) {\r\n\t\t\t    _isExcludedFromReward[from] = true;\r\n\t\t    }\r\n\t\t\t// clear list of the old holders\r\n\t\t\t_removeOldSellHistories();\r\n\t\t}\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) private {\r\n        require(owner != address(0), \"BEP20: approve from the zero address\");\r\n        require(spender != address(0), \"BEP20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n \r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _tokensInLiquidityPool(IPancakePair _tokenLiquidityPool) private view returns (address, uint256, address, uint256) {\r\n\t\taddress token0                         = _tokenLiquidityPool.token0();\r\n\t\taddress token1                         = _tokenLiquidityPool.token1();\r\n\t\t(uint256 reserve0, uint256 reserve1, ) = _tokenLiquidityPool.getReserves();\r\n\t\taddress etbToken;\r\n\t\tuint256 etbAmount;\r\n\t\taddress bnbToken;\r\n\t\tuint256 bnbAmount;\r\n\r\n\t\tif (token0 == pancakeRouter.WETH()) {\r\n\t\t\tbnbToken  = token0;\r\n\t\t\tbnbAmount = reserve0;\r\n\t\t\tetbToken  = token1;\r\n\t\t\tetbAmount = reserve1;\r\n\t\t} else if (token1 == pancakeRouter.WETH()) {\r\n\t\t\tbnbToken  = token1;\r\n\t\t\tbnbAmount = reserve1;\r\n\t\t\tetbToken  = token0;\r\n\t\t\tetbAmount = reserve0;\r\n\t\t}\r\n\r\n\t\treturn (etbToken, etbAmount, bnbToken, bnbAmount);\r\n    }\r\n\r\n    function _locateAccountSellHistories(address account) private view returns (uint256) {\r\n        uint256 time = 0;\r\n\r\n\t\tfor (uint256 i = 0; i < _sellHistories.length; i++) {\r\n            if (_sellHistories[i].account == account) {\r\n\t\t\t\ttime = _sellHistories[i].time;\r\n                break;\r\n            }\r\n        }\r\n\r\n\t\treturn time;\r\n    }\r\n\r\n\tfunction _etbTokensMaxPermited(address from, uint256 _etbInLiquidityPool, uint256 _bnbInLiquidityPool) private view returns (uint256) {\r\n\t\t// pre fixed values\r\n\t\tuint256 tokensPermited         = 0;\r\n\t\tuint256 etbTokenPermitedToSell = 0;\r\n\t\tuint256 bnbPermitedToSell      = 0;\r\n\t\t// calcule balance of sender\r\n\t\tuint256 etbTokenBalance\t = balanceOf(from);\r\n\t\t// calcule reserve of BNB at Liquidity Pool\r\n\t\tuint256 bnbReservedInLP\t = _calculateBNBReservedInLiquidityPool();\r\n\t\t// calcule max of BNBs per Dolar\r\n\t\tuint256 maxOfBnbPerDolar = _calculateMaxOfBNBPerDolar(from);\r\n\t\t// calcule max of Ethera Black tokens per BNB\r\n\t\t(uint256 etbTokenPerBnb, uint256 maxOfEtbTokenPerDolar) = _calculateETBTokensMaxPermited(maxOfBnbPerDolar, _etbInLiquidityPool, _bnbInLiquidityPool);\r\n\r\n\t\tif (etbTokenBalance > etbTokenBalanceOverRage) {\r\n\t\t\tetbTokenPermitedToSell = etbTokenBalance.mul(etbTokenMaxBalanceToSellPercent).div(10**2);\r\n\t\t}\r\n\t\tif (_bnbInLiquidityPool > bnbReservedInLP) {\r\n\t\t\tbnbPermitedToSell = _bnbInLiquidityPool.sub(bnbReservedInLP);\r\n\t\t\ttokensPermited    = etbTokenPerBnb.mul(bnbPermitedToSell).div(10**18);\r\n\t\t\tif (etbTokenPermitedToSell != 0 && tokensPermited > etbTokenPermitedToSell) {\r\n\t\t\t\ttokensPermited = etbTokenPermitedToSell;\r\n\t\t\t}\r\n\t\t\tif (tokensPermited > maxOfEtbTokenPerDolar) {\r\n\t\t\t\ttokensPermited = maxOfEtbTokenPerDolar;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn tokensPermited;\r\n    }\r\n\r\n\tfunction _swapAndtransferBnbToMarketingBlack(uint256 tokenAmount) private lockTheSwap {\r\n        // generate the pancake pair path of etb -> wbnb\r\n        address[] memory path = new address[](2);\r\n\r\n        path[0] = address(this);\r\n        path[1] = pancakeRouter.WETH();\r\n\r\n        _approve(address(this), address(pancakeRouter), tokenAmount);\r\n\r\n        // make the swap\r\n        pancakeRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0, // accept any amount of BNB\r\n            path,\r\n            marketingBlack,\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n\tfunction _removeAllFee() private {\r\n        if (_burnFee == 0 && _marketingFee == 0 && _etheraBetsFee == 0) return;\r\n\r\n        _previousBurnFee       = _burnFee;\r\n        _previousMarketingFee  = _marketingFee;\r\n        _previousEtheraBetsFee = _etheraBetsFee;\r\n\r\n\t\t_burnFee       = 0;\r\n\t\t_marketingFee  = 0;\r\n\t\t_etheraBetsFee = 0;\r\n    }\r\n\r\n    function _getTValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256) {\r\n        uint256 burnFee        = _calculateBurnFee(tAmount);\r\n        uint256 marketingFee   = _calculateMarketingFee(tAmount);\r\n        uint256 etheraBetsFee  = _calculateEtheraBetsFee(tAmount);\r\n\t\tuint256 transferAmount = tAmount.sub(burnFee).sub(marketingFee).sub(etheraBetsFee);\r\n\r\n        return (transferAmount, burnFee, marketingFee, etheraBetsFee);\r\n    }\r\n\r\n    function _burnEtb(address sender, uint256 burnAmount) private {\r\n\t    if (burnAmount != 0) {\r\n\t\t\temit Transfer(sender, _burnAddress, burnAmount);\r\n\r\n            _tBurnTotal = _tBurnTotal.add(burnAmount);\r\n\t    }\r\n    }\r\n\r\n\tfunction _transferFees(address sender, uint256 marketingAmount, uint256 etheraBetsAmount) private {\r\n        if (marketingAmount != 0) {\r\n            _balances[address(this)] = _balances[address(this)].add(marketingAmount);\r\n\r\n            emit Transfer(sender, address(this), marketingAmount);\r\n        }\r\n\t\tif (etheraBetsAmount != 0) {\r\n            _balances[etheraBetsWallet] = _balances[etheraBetsWallet].add(etheraBetsAmount);\r\n\r\n            emit Transfer(sender, etheraBetsWallet, etheraBetsAmount);\r\n        }\r\n    }\r\n\r\n\tfunction _restoreAllFee() private {\r\n\t    _burnFee       = _previousBurnFee;\r\n        _marketingFee  = _previousMarketingFee;\r\n\t\t_etheraBetsFee = _previousEtheraBetsFee;\r\n    }\r\n\r\n    function _addAccountSellHistories(address account) private {\r\n\t\tSellHistories memory sellHistory;\r\n\r\n        sellHistory.account = account;\r\n\t\tsellHistory.time    = block.timestamp;\r\n        _sellHistories.push(sellHistory);\r\n\t}\r\n\r\n    function _removeOldSellHistories() private {\r\n        uint256 i                        = 0;\r\n        uint256 maxStartTimeForHistories = block.timestamp - sellBackMaxTime;\r\n\r\n        for (uint256 j = 0; j < _sellHistories.length; j++) {\r\n            if (_sellHistories[j].time >= maxStartTimeForHistories) {\r\n                if (_sellHistories[j].time != _sellHistories[i].time) {\r\n                    _sellHistories[i].account = _sellHistories[j].account;\r\n\t\t\t\t    _sellHistories[i].time    = _sellHistories[j].time;\r\n                }\r\n                i++;\r\n            }\r\n        }\r\n\r\n        uint256 removedCnt = _sellHistories.length - i;\r\n\r\n        for (uint256 j = 0; j < removedCnt; j++) {\r\n\t\t\t_sellHistories.pop();\r\n        }\r\n    }\r\n\r\n\tfunction _calculateBNBReservedInLiquidityPool() private view returns (uint256) {\r\n\t\tuint256 bnbOfPercent     = inittialBNBInLiquidityPool.mul(maxOfBnbToSwapPercent).div(10**2);\r\n\t\tuint256 bnbReservedInLP\t = inittialBNBInLiquidityPool.sub(bnbOfPercent);\r\n\r\n\t\tbnbReservedInLP\t= bnbReservedInLP.mul(10**18);\r\n\r\n\t\treturn bnbReservedInLP;\r\n\t}\r\n\r\n\tfunction _calculateMaxOfBNBPerDolar(address account) private view returns (uint256) {\r\n\t\t// check account limited to sell\r\n\t\tuint256 limitPerAccountInDolar                   = amountOfAccountInSellLimitsInDolar(account);\r\n\t\t(, uint256 busdTokenAmount, , uint256 bnbAmount) = _tokensInLiquidityPool(_bnbBusdPairAddress);\r\n\t\tuint256 bnbPerDolar                              = bnbAmount.mul(10**18).div(busdTokenAmount);\r\n\t\tuint256 maxOfBnbPerDolar                         = bnbPerDolar.mul(sellMaxTxAmountPerDolar);\r\n\r\n\t\tif (limitPerAccountInDolar !=0 ) {\r\n\t\t\tmaxOfBnbPerDolar = bnbPerDolar.mul(limitPerAccountInDolar);\r\n\t\t}\r\n\r\n\t\treturn maxOfBnbPerDolar;\r\n\t}\r\n\r\n\tfunction _calculateETBTokensMaxPermited(uint256 bnbPerDolar, uint256 _etbTokenInLP, uint256 _bnbInLP) private pure returns (uint256, uint256) {\r\n\t\tuint256 etbTokenPerBnb        = _etbTokenInLP.mul(10**18).div(_bnbInLP);\r\n\t\tuint256 maxOfEtbTokenPerDolar = etbTokenPerBnb.mul(bnbPerDolar).div(10**18);\r\n\r\n\t\treturn (etbTokenPerBnb, maxOfEtbTokenPerDolar);\r\n\t}\r\n\r\n    function _calculateBurnFee(uint256 _amount) private view returns (uint256) { return _amount.mul(_burnFee).div(10**2); }\r\n\r\n    function _calculateMarketingFee(uint256 _amount) private view returns (uint256) { return _amount.mul(_marketingFee).div(10**2); }\r\n\r\n\tfunction _calculateEtheraBetsFee(uint256 _amount) private view returns (uint256) { return _amount.mul(_etheraBetsFee).div(10**2); }\r\n}\r\n/**\r\n * End contract\r\n * \r\n * Developed by @tadryanom Ethera.cc\r\n */", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ClaimETBTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"amountOfAccountInSellLimitsInDolar\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyBurnFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyEtheraBetsFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyMarketingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyMaxTxAmountLPPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountPercent\",\"type\":\"uint256\"}],\"name\":\"clearETBTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"doExcludeAccountFromSellLimitsInDolar\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"doExcludeFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"doExcludeFromMax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"doIncludeAccountInSellLimitsInDolar\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"doIncludeInFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"doIncludeInMax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"doIncludeInRewardOfEtheraBets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"doLockWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"doUnlockWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"etbTokenBalanceOverRage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"etbTokenMaxBalanceToSellPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"etheraBetsWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getLeftTimeToSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inittialBNBInLiquidityPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inittialTotalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromRewardOfEtheraBets\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isLockedSellEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isLockedSellPerTime\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isLockedWallet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isSwapTokensEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingBlack\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxOfBnbToSwapPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numOfEtbTokensToSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"otherBurnFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"otherEtheraBetsFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"otherMarketingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"otherMaxTxAmountPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pancakePair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pancakeRouter\",\"outputs\":[{\"internalType\":\"contract IPancakeRouter02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellBackMaxTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellBurnFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellEtheraBetsFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellMarketingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellMaxTxAmountPerDolar\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setBuyBurnFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setBuyEtheraBetsFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setBuyMarketingFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setBuyMaxTxAmountLPPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setEtbTokenBalanceOverRage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setEtbTokenMaxBalanceToSellPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setInittialBNBInLiquidityPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setLockedSellEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setLockedSellPerTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setMaxOfBnbToSwapPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setNumOfEtbTokensToSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setOtherBurnFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setOtherEtheraBetsFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setOtherMarketingFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setOtherMaxTxAmountPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setSellBackMaxTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setSellBurnFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setSellEtheraBetsFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setSellMarketingFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setSellMaxTxAmountPerDolar\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setSwapTokensEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalEtheraBlackBurnt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "EtheraBlackTokenV2", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d0c10cc86f75875bc0260e2abc08fadecc076e7078ab1954dc570ec2e06e3a64"}