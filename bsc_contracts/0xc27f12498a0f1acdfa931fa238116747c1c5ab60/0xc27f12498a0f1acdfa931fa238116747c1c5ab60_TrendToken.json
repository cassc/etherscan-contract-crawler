{"SourceCode": "{\"Address.sol\":{\"content\":\"pragma solidity ^0.5.5;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following \\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != accountHash \\u0026\\u0026 codehash != 0x0);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` into `address payable`. Note that this is\\n     * simply a type cast: the actual underlying value is not changed.\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function toPayable(address account) internal pure returns (address payable) {\\n        return address(uint160(account));\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     *\\n     * _Available since v2.4.0._\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-call-value\\n        (bool success, ) = recipient.call.value(amount)(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n}\"},\"AggregatorV2V3Interface.sol\":{\"content\":\"pragma solidity \\u003e=0.5.0;\\n\\n/**\\n * @title The V2 \\u0026 V3 Aggregator Interface\\n * @notice Solidity V0.5 does not allow interfaces to inherit from other\\n * interfaces so this contract is a combination of v0.5 AggregatorInterface.sol\\n * and v0.5 AggregatorV3Interface.sol.\\n */\\ninterface AggregatorV2V3Interface {\\n  //\\n  // V2 Interface:\\n  //\\n  function latestAnswer() external view returns (int256);\\n  function latestTimestamp() external view returns (uint256);\\n  function latestRound() external view returns (uint256);\\n  function getAnswer(uint256 roundId) external view returns (int256);\\n  function getTimestamp(uint256 roundId) external view returns (uint256);\\n\\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp);\\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\\n\\n  //\\n  // V3 Interface:\\n  //\\n  function decimals() external view returns (uint8);\\n  function description() external view returns (string memory);\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n}\"},\"CompStorageTT.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.5.16;\\n\\nimport \\\"./ITrendToken.sol\\\";\\nimport \\\"./IChainlinkOracle.sol\\\";\\n\\n\\n\\ncontract UnitrollerAdminStorage {\\n    /**\\n    * @notice Administrator for this contract\\n    */\\n    address public admin;\\n\\n    /**\\n    * @notice Pending administrator for this contract\\n    */\\n    address public pendingAdmin;\\n\\n    /**\\n    * @notice Active brains of Unitroller\\n    */\\n    address public comptrollerImplementation;\\n\\n    /**\\n    * @notice Pending brains of Unitroller\\n    */\\n    address public pendingComptrollerImplementation;\\n}\\n\\n\\n\\ncontract ComptrollerStorage is UnitrollerAdminStorage {\\n\\n    /**\\n     * @notice Oracle which gives the price of any given asset\\n     */\\n    IOracle public oracle;\\n\\n\\n    /**\\n     * @notice Per-account mapping of \\\"assets you are in\\\", capped by maxAssets\\n     */\\n    mapping(address =\\u003e ITrendToken[]) public accountAssets;\\n\\n\\n    struct TrendToken {\\n\\n        // @notice Whether or not this Trend Token is listed \\n        bool isListed;\\n\\n        // @notice Whether or not this Trend Token is active\\n        // @dev Admin may set Trend Token to inactive to prevent any activity\\n        bool isActive;\\n\\n        // @notice Whether or not this Trend Token is tradeable\\n        // @dev Admin may set Trend Token to isTrade to prevent any trade activity\\n        bool isTrade;\\n\\n        // @notice Whether or not this Trend Token can interact with Dual Pools\\n        bool allowedDualPools;\\n\\n        // @notice The maximum trade fee this Trend Token can have\\n        uint maxTradeFee;\\n\\n        // @notice The maximum performance fee this Trend Token can have\\n        uint maxPerformanceFee;\\n\\n        // @notice Maximum value (contract and collateral) to disable token from portfolio\\n        uint maxDisableValue;\\n\\n    }\\n\\n\\n    /**\\n     * @notice Official mapping of vTokens -\\u003e Market metadata\\n     * @dev Used e.g. to determine if a market is supported\\n     */\\n    mapping(address =\\u003e TrendToken) public trendTokens;\\n\\n\\n    /**\\n     * @notice The Pause Guardian can pause certain actions as a safety mechanism.\\n     *  Actions which allow users to remove their own assets cannot be paused.\\n     *  Liquidation / seizing / transfer can only be paused globally, not by market.\\n     */\\n    address public pauseGuardian;\\n\\n\\n    /**\\n     * @notice Pause/Unpause whole protocol actions\\n     */\\n    bool public protocolPaused;\\n\\n\\n    /**\\n     * @notice Sets a specific Trend Token to paused\\n     * @dev Does not allow for deposit or redeems\\n     */\\n    mapping(address =\\u003e bool) public mintGuardianPaused;\\n\\n\\n    /**\\n     * @notice A list of all Trend Tokens\\n     */\\n    ITrendToken[] public allTrendTokens;\\n\\n    /**\\n     * @notice a list of all supported underlying tokens\\n     * @dev May be added to Trend Token portfolios\\n     */\\n    address[] public supportedTokens;\\n\\n    /**\\n     * @notice Mapping of underlying:dTokens\\n     */\\n    mapping(address =\\u003e address) public tokenToDToken;\\n\\n\\n    /**\\n     * @notice Wallet that is able to change the state of locked\\n     */\\n    address lockedWallet;\\n\\n    /**\\n     * @notice Restrictions actions of admin if locked\\n     * @dev Adds an extra layer of security\\n     */\\n    bool locked = true;\\n\\n\\n}\\n\\n\"},\"CompTT.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.5.16;\\n\\n\\nimport \\\"./ICompTT.sol\\\";\\nimport \\\"./IChainlinkOracle.sol\\\";\\nimport \\\"./CompStorageTT.sol\\\";\\nimport \\\"./UniTT.sol\\\";\\n\\n\\n\\n\\ncontract CompTT is ComptrollerStorage {//}, ComptrollerErrorReporter, ExponentialNoError {\\n    /// @notice Emitted when an admin supports a market\\n    event TrendTokenListed(ITrendToken trendToken);\\n\\n    /// @notice Emitted when price oracle is changed\\n    event NewPriceOracle(IOracle oldPriceOracle, IOracle newPriceOracle);\\n\\n    /// @notice Emitted when pause guardian is changed\\n    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\\n\\n    /// @notice Emitted when an action is paused globally\\n    event ActionPaused(string action, bool pauseState);\\n\\n    /// @notice Emitted when protocol state is changed by admin\\n    event ActionProtocolPaused(bool state);\\n\\n    /// @notice Emitted when protocol state is changed by admin\\n    event ActionMintPaused(address trendToken, bool state);\\n\\n    /// @notice Emitted when token is supported by admin\\n    event SupportToken(address underlying, address iToken);\\n\\n    /// @notice Emitted when locked state changes\\n    event Locked(bool oldState, bool newState);\\n\\n    /// @notice Emitted when lockedWallet address is updated\\n    event UpdateLockedWallet(address oldWallet, address lockedWallet);\\n\\n\\n    constructor() public {\\n        admin = msg.sender;\\n        lockedWallet = msg.sender;\\n    }\\n\\n    // -------- MODIFIERS AND CHECKS ------------ // \\n\\n\\n    modifier onlyProtocolAllowed {\\n        require(!protocolPaused, \\\"protocol is paused\\\");\\n        _;\\n    }\\n\\n\\n    function ensureAdmin() private view {\\n        require(msg.sender == admin, \\\"!admin\\\");\\n    }\\n\\n\\n    function ensureNonzeroAddress(address someone) private pure {\\n        require(someone != address(0), \\\"can\\u0027t be zero address\\\");\\n    }\\n\\n\\n    modifier onlySupportedTrendTokens(address trendToken) {\\n        require(trendTokenSupported(ITrendToken(trendToken)), \\\"Trend Token is not supported\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Must return True for protcol to be puased\\n     */\\n    modifier validPauseState(bool state) {\\n        require(msg.sender == pauseGuardian || msg.sender == admin, \\\"only pause guardian and admin can\\\");\\n        require(msg.sender == admin || state, \\\"only admin can unpause\\\");\\n        _;\\n    }\\n\\n\\n    /**\\n     * @notice Prevents Manager from executing highly secure operations\\n     */\\n    modifier requireUnlocked() {\\n        require(!locked,\\\"!locked\\\");\\n        _;\\n    }\\n\\n\\n    /** CHANGE: SUPPLY ALLOWED\\n     * @notice Checks if the account should be allowed to mint tokens in the given market\\n     * @param trendToken The market to verify the mint against\\n     * param minter The account which would get the minted tokens\\n     * param mintAmount The amount of underlying being supplied to the market in exchange for tokens\\n     * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\\n     */\\n    function depositOrRedeemAllowed(address trendToken, uint amount) external view onlyProtocolAllowed returns (bool) {\\n        // Pausing is a very serious situation - we revert to sound the alarms\\n        require(amount\\u003e0,\\\"amount must be greater than 0\\\");\\n        require(!mintGuardianPaused[trendToken], \\\"mint is paused\\\");\\n        require(trendTokens[trendToken].isListed, \\\"trend token not listed\\\");\\n        require(trendTokens[trendToken].isActive, \\\"trend token not active\\\");\\n        return true; \\n    }\\n\\n\\n    /** \\n     * @notice Checks if the account should be allowed to mint tokens in the given market\\n     * @param trendToken The market to verify the mint against\\n     * param minter The account which would get the minted tokens\\n     * param mintAmount The amount of underlying being supplied to the market in exchange for tokens\\n     * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\\n     */\\n    function tradeAllowed(address trendToken, uint amount) external view onlyProtocolAllowed returns (bool) {\\n        // Pausing is a very serious situation - we revert to sound the alarms\\n        require(amount\\u003e0,\\\"amount must be greater than 0\\\");\\n        require(!mintGuardianPaused[trendToken], \\\"mint is paused\\\");\\n        require(trendTokens[trendToken].isListed, \\\"trend token not listed\\\");\\n        require(trendTokens[trendToken].isActive, \\\"trend token not active\\\");\\n        require(trendTokens[trendToken].isTrade, \\\"trend token not tradeable\\\");\\n        return true; \\n    }\\n\\n\\n    // ---------- EXTERNAL VIEW FUNCTIONS ----------- // \\n    /** Used for Frontend Lens **/\\n    \\n\\n    /**\\n     * @notice Returns current block number\\n     */\\n    function getBlockNumber() external view returns (uint) {\\n        return block.number;\\n    }\\n\\n\\n    /**\\n     * @notice Return the address of the XVS token\\n     * @return The address of XVS\\n     * shh not used?\\n     */\\n    function getXVSAddress() external pure returns (address) {\\n        return 0xf79c28eB5bd0cC10B58F04DfF7c34d0c8D39BdE6; //0xcF6BB5389c92Bdda8a3747Ddb454cB7a64626C63;\\n    }\\n\\n\\n    /**\\n     * @notice Allows a Trend Token to enable a token (add to portfolio)\\n     * @return Returns zero address if \\n     */\\n    function returnDToken(address underlying) external view onlyProtocolAllowed returns(address) {\\n        return tokenToDToken[underlying];\\n    }\\n\\n\\n    /**\\n     * @notice Returns Trend Token list status\\n     */\\n    function trendTokenIsListed(address trendToken) external view returns(bool) {\\n        return trendTokens[address(trendToken)].isListed;\\n    }\\n\\n\\n    /**\\n     * @notice Returns Trend Token active status\\n     */\\n    function trendTokenIsActive(address trendToken) external view returns(bool) {\\n        return trendTokens[address(trendToken)].isActive;\\n    }\\n\\n\\n    /**\\n     * @notice Returns Trend Token active status\\n     */\\n    function trendTokenIsTrade(address trendToken) external view returns(bool) {\\n        return trendTokens[address(trendToken)].isTrade;\\n    }\\n\\n\\n\\n    /**\\n     * @notice Returns whether or not the Trend Token is allowed to supply on Dual Pools\\n     */\\n    function trendTokenAllowedDualPools(address trendToken) external view returns(bool) {\\n        return trendTokens[address(trendToken)].allowedDualPools;\\n    }\\n\\n\\n    /**\\n     * @notice Returns the maximum trade fee for the Trend Token\\n     */\\n    function trendTokenMaxTradeFee(address trendToken) external view returns(uint) {\\n        return trendTokens[address(trendToken)].maxTradeFee;\\n    }\\n\\n\\n    /**\\n     * @notice Returns the maximum performance fee for the Trend Token\\n     */\\n    function trendTokenMaxPerformanceFee(address trendToken) external view returns(uint) {\\n        return trendTokens[address(trendToken)].maxPerformanceFee;\\n    }\\n\\n\\n    /**\\n     * @notice Returns the maximum vlaue in a token for it to be disabled\\n     */\\n    function trendTokenMaxDisableValue(address trendToken) external view returns(uint) {\\n        return trendTokens[address(trendToken)].maxDisableValue;\\n    }\\n\\n\\n    // ------------- PROTOCOL WIDE (all trend tokens) FUNCTIONS --------------- // \\n\\n\\n    /**\\n     * @notice Sets this contract to become Unicontroller\\n     */\\n    function _become(Unitroller unitroller) external requireUnlocked {\\n        require(msg.sender == unitroller.admin(), \\\"only unitroller admin can\\\");\\n        require(unitroller._acceptImplementation() == 0, \\\"not authorized\\\");\\n    }\\n\\n\\n    /**\\n     * @notice Set whole protocol pause/unpause state\\n     */\\n    function _setProtocolPaused(bool state) external validPauseState(state) returns(bool) {\\n        protocolPaused = state;\\n        emit ActionProtocolPaused(state);\\n        return state;\\n    }\\n\\n\\n    /**\\n     * @notice Allows trading bot to change state of locked\\n     * @dev if locked is true, manager actions are limited (higher security) \\n     *      as a result, some actions require permission of both\\n     */\\n    function _updateLockedState(bool _state) external {\\n        require(msg.sender == lockedWallet,\\\"not lockedWallet\\\");\\n        bool oldState = locked;\\n        locked = _state;\\n        emit Locked(oldState, locked);\\n    }\\n\\n\\n    /**\\n     * @notice Allows LockedWallet to change address\\n     */\\n    function _updateLockedWallet(address _newWallet) external {\\n        require(msg.sender == lockedWallet, \\\"not lockedWallet\\\");\\n        require(_newWallet != address(0),\\\"locked wallet cannot be zero address\\\");\\n        address oldWallet = lockedWallet;\\n        lockedWallet = _newWallet;\\n        emit UpdateLockedWallet(oldWallet, lockedWallet);\\n\\n    }\\n\\n\\n    /**\\n     * @notice Set depsoit, redeem, and trade to paused\\n     */\\n    function _setMintPaused(address _trendToken, bool state) external validPauseState(state) returns(bool) {\\n        mintGuardianPaused[_trendToken] = state;\\n        emit ActionMintPaused(_trendToken, state);\\n        return state;\\n    }\\n\\n\\n    /**\\n      * @notice Sets a new price oracle for the comptroller\\n      * @dev Admin function to set a new price oracle\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _setPriceOracle(IOracle newOracle) external requireUnlocked returns (bool) {\\n        // Check caller is admin\\n        ensureAdmin();\\n\\n        ensureNonzeroAddress(address(newOracle));\\n\\n        // Track the old oracle for the comptroller\\n        IOracle oldOracle = oracle;\\n\\n        // Set comptroller\\u0027s oracle to newOracle\\n        oracle = newOracle;\\n\\n        // Emit NewPriceOracle(oldOracle, newOracle)\\n        emit NewPriceOracle(oldOracle, newOracle);\\n\\n        return true;\\n    }\\n\\n\\n    /**\\n     * @notice Admin function to change the Pause Guardian\\n     * @param newPauseGuardian The address of the new Pause Guardian\\n     * @return uint 0=success, otherwise a failure. (See enum Error for details)\\n     */\\n    function _setPauseGuardian(address newPauseGuardian) external requireUnlocked returns (bool) {\\n        ensureAdmin();\\n        require(newPauseGuardian != address(0),\\\"newPauseGuardian cannot be zero address\\\");\\n\\n        ensureNonzeroAddress(newPauseGuardian);\\n\\n        // Save current value for inclusion in log\\n        address oldPauseGuardian = pauseGuardian;\\n\\n        // Store pauseGuardian with value newPauseGuardian\\n        pauseGuardian = newPauseGuardian;\\n\\n        // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\\n        emit NewPauseGuardian(oldPauseGuardian, newPauseGuardian);\\n\\n        return true;\\n    }\\n\\n\\n    /**\\n     * @notice Internal function to support token (for example, BTCB)\\n     * @param underlying The address of underlying asset (BTCB)\\n     * @param dToken The dToken address of underlying asset (dBTCB)\\n     */\\n    function supportTokenFresh(address underlying, address dToken) internal returns(uint) {\\n        ensureAdmin();\\n        require(dToken != address(0) \\u0026\\u0026 underlying != address(0),\\\"dToken or underlying cannot be zero address\\\");\\n        require(tokenToDToken[underlying] == address(0),\\\"underlying already added\\\");\\n        require(oracle.getUnderlyingPrice(dToken) != 0,\\\"no price in Oracle\\\");\\n        tokenToDToken[underlying] = dToken;\\n        supportedTokens.push(underlying);\\n    }\\n\\n\\n    /**\\n     * Allows admin to support tokens so Trend Tokens can use them\\n     * This requires a price from the Chainlink Oracle\\n     * underlying and iToken are added to the mappings\\n     */\\n    function _supportToken(address underlying, address dToken) external requireUnlocked returns(uint) {\\n        supportTokenFresh(underlying, dToken);\\n        emit SupportToken(underlying, dToken);\\n    }\\n\\n\\n    // --------- SUPPORT TREND TOKEN AND UPDATE PARAMETERS -------------- //\\n\\n    /**\\n     * @notice Returns true if Trend Token is already supported\\n     * @dev Is supported if added to allTrendTokens from _supportTrendToken()\\n     */\\n    function trendTokenSupported(ITrendToken trendToken) internal view returns(bool) {\\n        for (uint i = 0; i \\u003c allTrendTokens.length; i ++) {\\n            if (allTrendTokens[i] == trendToken) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    } \\n\\n\\n    /**\\n     * @notice Internal function to check Trend Token isnt already added and verify it is a trend token\\n     * @param trendToken The trend token desired to be supported by Comptroller Trend Token \\n     */\\n    function _supportTrendTokenFresh(ITrendToken trendToken) internal {\\n        require(!trendTokenSupported(trendToken),\\\"Trend Token already supported.\\\");\\n        require(trendToken.isTrendToken(),\\\"not a trend token\\\"); // sanity check\\n        allTrendTokens.push(trendToken);\\n    }\\n\\n\\n    /**\\n      * @notice Add the Trend Token to the Trend Token mapping and set initial conditions\\n      * @dev Admin function to set isListed and add support for the market\\n      * @param trendToken The address of the Trend Token to list\\n      * @return uint 0=success, otherwise a failure. (See enum Error for details)\\n      */\\n    function _supportTrendToken(ITrendToken trendToken) external requireUnlocked returns (bool) {\\n        ensureAdmin();\\n        require(!trendTokens[address(trendToken)].isListed,\\\"trend token already listed\\\");\\n\\n        // Note that isVenus is not in active use anymore\\n        trendTokens[address(trendToken)] = TrendToken({isListed: true, isActive: true, isTrade: true, allowedDualPools: true, \\n                                                       maxTradeFee: 0.05e18, maxPerformanceFee: 0.50e18, maxDisableValue: 10000e18 });\\n\\n        _supportTrendTokenFresh(trendToken);\\n\\n        emit TrendTokenListed(trendToken);\\n\\n        return true;\\n    }\\n\\n\\n    /**\\n     * @notice Allows admin to change Trend Token active state\\n     * @dev False sets Trend Token to paused (cannot deposit, redeem, or public rebalance)\\n     */\\n    function _newIsActive(address trendToken, bool _isActive) external requireUnlocked onlySupportedTrendTokens(trendToken) {\\n        ensureAdmin();\\n        trendTokens[trendToken].isActive = _isActive;\\n    } \\n\\n    /**\\n     * @notice Allows admin to change Trend Token trade state\\n     * @dev False halts trading activity of underlying \\u003c--\\u003e underlying\\n     */\\n    function _newIsTrade(address trendToken, bool _isTrade) external requireUnlocked onlySupportedTrendTokens(trendToken) {\\n        ensureAdmin();\\n        trendTokens[trendToken].isTrade = _isTrade;\\n    } \\n\\n\\n    /**\\n     * @notice Allows admin to change allowedDualPools status\\n     * @dev Allows Trend Token supply assets to Dual Pools\\n     */\\n    function _newAllowedDualPools(address trendToken, bool _allowedDualPools) external requireUnlocked onlySupportedTrendTokens(trendToken) {\\n        ensureAdmin();\\n        trendTokens[trendToken].allowedDualPools = _allowedDualPools;\\n    } \\n\\n\\n    /**\\n     * @notice Allows admin to change maxTradeFee\\n     * @dev Trade Fee is charged when users deposit or redeem trend tokens\\n     */\\n    function _newMaxTradeFee(address trendToken, uint _maxTradeFee) external requireUnlocked onlySupportedTrendTokens(trendToken) {\\n        ensureAdmin();\\n        require(_maxTradeFee \\u003c= 0.25e18,\\\"max trade fee exceeded upper limit\\\");\\n        trendTokens[trendToken].maxTradeFee = _maxTradeFee;\\n    } \\n\\n\\n    /**\\n     * @notice Allows admin to change maxTradeFee\\n     * @dev Trade Fee is charged when users deposit or redeem trend tokens\\n     */\\n    function _newMaxPerformanceFee(address trendToken, uint _maxPerformanceFee) external requireUnlocked onlySupportedTrendTokens(trendToken) {\\n        ensureAdmin();\\n        require(_maxPerformanceFee \\u003c= 1e18,\\\"max performance fee exceeded upper limit\\\");\\n        trendTokens[trendToken].maxPerformanceFee = _maxPerformanceFee;\\n    } \\n\\n\\n    /**\\n     * @notice Allows admin to change maxTradeFee\\n     * @dev Trade Fee is charged when users deposit or redeem trend tokens\\n     */\\n    function _newMaxDisableValue(address trendToken, uint _maxDisableValue) external requireUnlocked onlySupportedTrendTokens(trendToken) {\\n        ensureAdmin();\\n        require(_maxDisableValue \\u003c= 1e18,\\\"max performance fee exceeded upper limit\\\");\\n        trendTokens[trendToken].maxDisableValue = _maxDisableValue;\\n    } \\n\\n\\n}\\n\"},\"DualPool.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.5.16;\\n\\nimport \\\"./ITrendTokenTkn.sol\\\";\\nimport \\\"./IVBNB.sol\\\";\\nimport \\\"./IVBep20.sol\\\";\\nimport \\\"./ICompDP.sol\\\";\\nimport \\\"./ICompTT.sol\\\";\\nimport \\\"./IChainlinkOracle.sol\\\";\\nimport \\\"./DualPoolStorage.sol\\\";\\nimport \\\"./Lib.sol\\\";\\n\\n// Mar 19: 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd,0x20e0827B4249588236E31ECE4Fe99A29a0Ec40bA,0x022d21035c00594bdFBdAf77bEF76BBCe597d876\\n\\n\\ncontract DualPoolIntegration is DualPoolStorage {//is DualPoolTokens { // 6,800 bytes --\\u003e 5500 --\\u003e 4100\\n\\n    using SafeMath for uint;\\n\\n\\n    // CONSTRUCTOR\\n    constructor(address _wbnb, address _compTT, address _compDP) public {\\n        compTT = ICompTT(_compTT);\\n        compDP = ICompDP(_compDP); \\n        wbnb = IERC20(_wbnb);\\n        dBNB = IVBep20(compTT.returnDToken(_wbnb));\\n        priceOracle = IOracle(address(ICompTT(_compTT).oracle()));\\n        require(address(dBNB) != address(0), \\\"dBNB cannot be zero address.\\\");\\n    }\\n\\n    // ------------- FOR TESTING PURPOSES ---------------- //\\n\\n\\n    /**\\n     * @notice Allows for the deposit of BNB to this contract\\n     */\\n    function () external payable {\\n    }\\n\\n\\n   // ----- CONTRACT ACCOUNT DATA ------ // \\n\\n\\n    /**\\n     * @notice Returns stored balances (vToken, borrow) and stored exchange rates between bep20\\u003c--\\u003evToken\\n     *         vTokenBal: vToken balance, (to get collateral amount, multiply by rate/1e18)\\n     *         borrowBal: underlying borrow balance\\n     *         rate: \\u0027collateral = vToken * rate / 1e18\\u0027 is multiplied by 1e18\\n     * @param _dToken The dToken to get screenshot data on\\n     */\\n    function screenshot(IVBep20 _dToken) internal view returns(uint,uint,uint)  {\\n        (uint error,uint vTokenBal, uint borrowBal, uint rate)  = _dToken.getAccountSnapshot(address(this));\\n        require(error == 0, \\\"!screenshot error\\\");\\n        return (vTokenBal, borrowBal, rate);\\n    }\\n\\n\\n    /**\\n     *  @notice Returns list of dTokens that have been entered in Dual Pools\\n     */\\n    function getMarkets() internal view returns(address[] memory) {\\n        return compDP.getAssetsIn(address(this));\\n    }\\n\\n\\n    /**\\n     * @notice Fetch prices of tokens from Chainlink price oracle\\n     * @param _dToken The underlying assets dToken to get price of\\n     */\\n    function priceBEP20(IVBep20 _dToken) internal view returns(uint256) { //have it exact BUSD\\n        uint price = priceOracle.getUnderlyingPrice(address(_dToken));\\n        require(price != 0, \\\"price cannot be 0\\\");\\n        return price;\\n    }\\n\\n\\n    /**\\n     * @notice The exchange rate between underlying and dToken\\n     * @dev formula \\u0027dTokenAmt = exchangeRate * underlyingAmt\\u0027\\n     * @param _dToken The underyling token to get exchange rate of\\n     */\\n    function exchangeVBEP20(IVBep20 _dToken) internal view returns(uint) {\\n        uint rate =  _dToken.exchangeRateStored();\\n        return rate;\\n    }\\n\\n\\n    // ---------- VENUS MARKETS ---------- // \\n\\n    /**\\n     * @notice Trend Token enables portfolio of underlying assets to Dual Pools\\n     * @dev Allows Trend Token to borrow assets from Dual Pool\\n     * @param _dTokens List of bep20 tokens to be enabled\\n     */\\n    function enableCol(address[] memory _dTokens) internal {\\n        compDP.enterMarkets(_dTokens);\\n    }\\n\\n\\n    /**\\n     * @notice Trend Token disables token from Dual Pools\\n     * @dev Removes token from collateral calculations\\n     * @param _dToken the dToken to disable collateral \\n     */\\n    function disableCol(IVBep20 _dToken) internal { // Allowing collateral and borrow of entered markets\\n        compDP.exitMarket(address(_dToken));\\n    }\\n\\n\\n    /**\\n     * @notice Returns true if _dToken entered into market\\n     * @dev Required to post collateral (loose funds, wont get vTokens) or borrow\\n     *      Still able to repay borrow and redeem collateral though\\n     * @param _dToken The dToken to check if this Trend Tokens is entered into\\n     */ \\n    function tokenEntered(IVBep20 _dToken) internal view returns(bool) {\\n        return compDP.checkMembership(address(this), address(_dToken));\\n    }\\n\\n\\n    /**\\n     * @notice Supplies collateral to Dual Pools\\n     * @dev The Underlying token must entered into by this Trend Token\\n     * @param _bep20 The underlying asset \\n     * @param _dToken The dToken for underlying to be supplied to\\n     * @param amountBEP20 The underlying amount to be supplied\\n     */\\n    function collateralSupply(IERC20 _bep20, IVBep20 _dToken, uint amountBEP20) internal {  //supply BNB as collateral \\n        if (_dToken == dBNB) {\\n            IVBNB vbnb = IVBNB(address(dBNB));\\n            vbnb.mint.value(amountBEP20)();\\n        } else {\\n            _bep20.approve(address(_dToken), amountBEP20); // approve the transfer\\n            assert(_dToken.mint(amountBEP20) == 0);// mint the vTokens and assert there is no error\\n        }\\n    }\\n\\n\\n    /**\\n     * @notice Redeems collateral from Dual Pools\\n     * @param _bep20 The underlying asset to be redeemed\\n     * @param amountBEP20 The underlying amount to be redeemed\\n     */\\n    function collateralRedeem(IERC20 _bep20, IVBep20 _dToken, uint amountBEP20) internal returns(uint redeemedAmount) { // withdrawal BNB collateral \\n        uint balanceBeforeRedeem = _bep20.balanceOf(address(this)); \\n        require(_dToken.redeemUnderlying(amountBEP20) == 0, \\\"Try smaller amount.\\\");\\n        uint balanceAfterRedeem = _bep20.balanceOf(address(this)); \\n        redeemedAmount = balanceAfterRedeem.sub(balanceBeforeRedeem);\\n    }\\n\\n\\n\\n}\\n\\n\\n\"},\"DualPoolStorage.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.5.16;\\n\\nimport \\\"./ITrendTokenTkn.sol\\\";\\nimport \\\"./IVBep20.sol\\\";\\nimport \\\"./ICompTT.sol\\\";\\nimport \\\"./ICompDP.sol\\\";\\n\\n\\ncontract DualPoolStorage {\\n\\n\\n    /**\\n     * @notice The Dual Pool comptroller contract that governs all Trend Tokens and some permissions\\n    */\\n    ICompDP public compDP;\\n\\n\\n    /**\\n     * @notice The Trend Token comptroller contract that governs all Trend Tokens and some permissions\\n    */\\n    ICompTT public compTT;\\n\\n\\n    /**\\n     * @notice The dToken for BNB\\n    */\\n    IVBep20 public dBNB;\\n\\n    /**\\n     * @notice The wrapped BNB contract address\\n     * @dev Used as a placeholder to represent BNB\\n     */\\n    IERC20 public wbnb;\\n\\n\\n    /**\\n     * @notice The Price Oracle for Dual Pool pricing\\n    */\\n    IOracle public priceOracle;\\n\\n\\n}\\n\"},\"ERC20.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the `IERC20` interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using `_mint`.\\n * For a generic mechanism see `ERC20Mintable`.\\n *\\n * *For a detailed writeup see our guide [How to implement supply\\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn\\u0027t required by the specification.\\n *\\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See `IERC20.approve`.\\n */\\ncontract ERC20 is IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address =\\u003e uint256) private _balances;\\n\\n    mapping (address =\\u003e mapping (address =\\u003e uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    /**\\n     * @dev See `IERC20.totalSupply`.\\n     */\\n    function totalSupply() public view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See `IERC20.balanceOf`.\\n     */\\n    function balanceOf(address account) public view returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See `IERC20.transfer`.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public returns (bool) {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See `IERC20.allowance`.\\n     */\\n    function allowance(address owner, address spender) public view returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See `IERC20.approve`.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 value) public returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See `IERC20.transferFrom`.\\n     *\\n     * Emits an `Approval` event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of `ERC20`;\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `value`.\\n     * - the caller must have allowance for `sender`\\u0027s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to `approve` that can be used as a mitigation for\\n     * problems described in `IERC20.approve`.\\n     *\\n     * Emits an `Approval` event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to `approve` that can be used as a mitigation for\\n     * problems described in `IERC20.approve`.\\n     *\\n     * Emits an `Approval` event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to `transfer`, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a `Transfer` event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _balances[sender] = _balances[sender].sub(amount);\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a `Transfer` event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n     /**\\n     * @dev Destoys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a `Transfer` event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 value) internal {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _totalSupply = _totalSupply.sub(value);\\n        _balances[account] = _balances[account].sub(value);\\n        emit Transfer(account, address(0), value);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\n     *\\n     * This is internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an `Approval` event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 value) internal {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    /**\\n     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\\n     * from the caller\\u0027s allowance.\\n     *\\n     * See `_burn` and `_approve`.\\n     */\\n    function _burnFrom(address account, uint256 amount) internal {\\n        _burn(account, amount);\\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\\n    }\\n}\\n\"},\"ERC20Detailed.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * @dev Optional functions from the ERC20 standard.\\n */\\ncontract ERC20Detailed is IERC20 {\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\\n     * these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = decimals;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei.\\n     *\\n     * \\u003e Note that this information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * `IERC20.balanceOf` and `IERC20.transfer`.\\n     */\\n    function decimals() public view returns (uint8) {\\n        return _decimals;\\n    }\\n}\\n\"},\"IChainlinkOracle.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.5.16;\\n\\nimport \\\"./AggregatorV2V3Interface.sol\\\";\\n\\ninterface IOracle {\\n    function getUnderlyingPrice(address vtoken) external view returns(uint256);\\n\\n    function getFeed(string calldata symbol) external view returns (AggregatorV2V3Interface);\\n    function getChainlinkPrice(AggregatorV2V3Interface feed) external view returns (uint);\\n\\n}\\n\\n\"},\"ICompDP.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.5.16;\\n\\ninterface ICompDP {\\n\\n    function enterMarkets(address[] calldata _markets) external returns(uint[] memory);\\n    function claimXDP(address _recipient) external;\\n    function venusAccrued(address holder) external view returns(uint256);\\n    function getAssetsIn(address account) external view returns (address[] memory);\\n    \\n    function markets(address vTokenAddress) external view returns (bool, uint, bool); // (isListed, collateralFactorMantissa, isXvsed)\\n    \\n    function getAccountLiquidity(address account) external view returns (uint, uint, uint); //  (error, liquidity, shortfall)\\n    function closeFactorMantissa() external view returns (uint); // multiply by token borrow balance to see how much can be repaid\\n    function exitMarket(address vToken) external returns (uint);\\n    function getHypotheticalAccountLiquidity(address account,address vTokenModify,uint redeemTokens,uint borrowAmount) external view returns (uint, uint, uint);\\n    \\n    function checkMembership(address account, address vToken) external view returns (bool);\\n\\n    \\n    //** ----------- Trade Functionlaity ----------- **//\\n    function iUSDaddress() external pure returns(address); // in contract, delared public (so might not work as external\\n\\n\\n\\n\\n}\\n\"},\"ICompTT.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.5.16;\\n\\nimport \\\"./IChainlinkOracle.sol\\\";\\nimport \\\"./ITrendToken.sol\\\";\\nimport \\\"./CompTT.sol\\\";\\n\\n\\ncontract ICompTT {\\n\\n    function oracle() external view returns (IOracle);\\n    function protocolPaused() external view returns(bool);\\n    function depositOrRedeemAllowed(address trendToken, uint amount) external view returns(bool);\\n    function tradeAllowed(address trendToken, uint amount) external view returns (bool);\\n    function returnDToken(address underlying) external view returns(address);\\n\\n    function trendTokenIsListed(address trendToken) external view returns(bool);\\n    function trendTokenIsActive(address trendToken) external view returns(bool);\\n    function trendTokenIsTrade(address trendToken) external view returns(bool);\\n    function trendTokenAllowedDualPools(address trendToken) external view returns(bool);\\n    function trendTokenMaxTradeFee(address trendToken) external view returns(uint);\\n    function trendTokenMaxPerformanceFee(address trendToken) external view returns(uint);\\n    function trendTokenMaxDisableValue(address trendToken) external view returns(uint);\\n\\n}\"},\"IERC20.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see `ERC20Detailed`.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\\n     * zero by default.\\n     *\\n     * This value changes when `approve` or `transferFrom` are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * \\u003e Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an `Approval` event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to `approve`. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"IIncentiveModelSimple.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.5.16;\\n//pragma experimental ABIEncoderV2;\\n\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n\\ninterface IIncentiveModelSimple {\\n\\n    /**\\n     * @notice For Lens\\n     */\\n    function protocolFeeTrade() external view returns(uint);\\n\\n    function protocolFeeDeposit() external view returns(uint);\\n\\n    function protocolFeeRedeem() external view returns(uint);\\n\\n    function isIncentiveModel() external view returns(bool);\\n    function totalDepositFee(IERC20 _depositBEP20, uint _valueDeposit, int priorDelta, int postDelta, uint price, uint balanceXTT)  external view returns(int totalFee, uint protocolFeePerc, uint reward, uint fee);\\n    function totalRedeemFee(IERC20 _redeemBep20, uint _valueRedeem, int priorDelta, int postDelta, uint price, uint balanceXTT) external view returns(int totalFee, uint protocolFeePerc, uint reward, uint fee);\\n    function valueOutAfterSell(IERC20 _tokenIn, uint _valueIn, int priorDeltaIn, int postDeltaIn, uint balanceXTT) external view returns(uint redeemValue);\\n    function valueOutAfterBuy(IERC20 _tokenOut, uint _valueAfterSell, int priorDeltaOut, int postDeltaOut) external view returns(uint buyValue);\\n\\n}\"},\"IncentiveModelSimple.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.5.16;\\n//pragma experimental ABIEncoderV2;\\n\\nimport \\\"./IIncentiveModelSimple.sol\\\";\\nimport \\\"./Lib.sol\\\";\\nimport \\\"./SignedSafeMath.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\n\\n// Add to Github Repo\\n// 1) Create updatable feePerToken() underlying:fee pairs, similar to CompTT (make sure cant duplicate underlying)\\n//      - add array of underlying\\n// 2) Upgradeable protocolFeeDeposit, protocolFeeRedeem, protocolFeeTrade\\n//      - keep discount and threshold fixed \\n\\ncontract IncentiveModelSimple is IIncentiveModelSimple {\\n\\n    using SignedSafeMath for int;\\n    using SafeMath for uint;\\n\\n    // ---------- PUBLIC VARIABLES ------------- // \\n\\n    /**\\n     * @notice Used as a sanity check when adding incentive model to Trend Token\\n     */\\n    bool public constant isIncentiveModel = true;\\n\\n    /**\\n     * @notice Has permission to make changes\\n     */\\n    address public admin;\\n\\n    /**\\n     *@notice Base fee charged when depositing for Trend Tokens\\n     */\\n    uint public protocolFeeDeposit = 0.0015e18;\\n\\n    /**\\n     *@notice Base fee charged when redeeming Trend Tokens for underlying\\n     */\\n    uint public protocolFeeRedeem = 0.0025e18;\\n\\n    /**\\n     *@notice Base fee charged when trading underlying for underlying\\n     */\\n    uint public protocolFeeTrade = 0.0015e18;\\n    \\n\\n    /**\\n     * @notice Discounts when meeting low, med, and high XTT Thresholds\\n     */\\n    uint public lowDiscount = 0.20e18;\\n    uint public medDiscount = 0.40e18;\\n    uint public highDiscount = 0.80e18;\\n\\n    /**\\n     * @notice Amount of XTT required to be held to receive low, med, and high discounts\\n     */\\n    uint public lowThreshold = 100e18;\\n    uint public medThreshold = 10000e18;\\n    uint public highThreshold = 100000e18;\\n\\n\\n    /**\\n     * @notice Maps ERC20 token to its base reward/fee when depositing or redeeming\\n     * @dev If BNB: 0.50%, then 0.50% reward when depositing BNB if protocol desires more\\n     *                          0.50% fee when redeeming BNB if protocol desires less\\n     */\\n    mapping(address =\\u003e uint) public feePerToken;\\n\\n\\n    /**\\n     * @notice Maintains a list of all underlying assets that are included in the feePerToken mapping\\n     *         This allows this underlying to be deposited, redeemed, or traded\\n     */\\n    IERC20[] public allUnderlying;\\n\\n\\n    /**\\n     * @notice Emitted when updated associated values\\n     */\\n    event UpdateFeeDiscount(uint oldLow, uint oldMed, uint oldHigh, uint newLow, uint newMed, uint newHigh);\\n    event UpdateDepositFee(uint oldFee, uint newFee);\\n    event UpdateRedeemFee(uint oldFee, uint newFee);\\n    event UpdateProtocolFee(uint oldFee, uint newFee);\\n\\n\\n\\n    constructor() public {\\n        admin = msg.sender;\\n    }\\n\\n    \\n    /**\\n     *  Changes the XTT holding threshold for 20%, 40%, and 60% trading fees on buying/selling Trend Tokens\\n     */\\n    function _updateTradeFeeDiscounts(uint _lowThres, uint _medThres, uint _highThres) external {\\n        require(msg.sender == admin,\\\"!admin\\\");\\n        require(_lowThres \\u003c _medThres \\u0026\\u0026 _medThres \\u003c _highThres \\u0026\\u0026 _highThres \\u003c= 1e18,\\\"!threshold\\\");\\n        uint oldLow = lowThreshold;\\n        uint oldMed = medThreshold;\\n        uint oldHigh = highThreshold;\\n        lowThreshold = _lowThres;\\n        medThreshold = _medThres;\\n        highThreshold = _highThres;\\n        emit UpdateFeeDiscount(oldLow, oldMed, oldHigh, lowThreshold, medThreshold, highThreshold);\\n    }\\n\\n\\n    /**\\n     * @notice Updates deposit fee when buying Trend Tokens\\n     */\\n    function _updateDepositFee(uint _newDepositFee) external {\\n        require(msg.sender == admin,\\\"!admin\\\");\\n        require(_newDepositFee \\u003c= 0.05e18,\\\"max 5%\\\");\\n        uint oldFee = protocolFeeDeposit;\\n        protocolFeeDeposit = _newDepositFee;\\n        emit UpdateDepositFee(oldFee, protocolFeeDeposit);\\n    }\\n\\n\\n    /**\\n     * @notice Updates redeem fee when selling Trend Tokens\\n     */\\n    function _updateRedeemFee(uint _newRedeemFee) external {\\n        require(msg.sender == admin,\\\"!admin\\\");\\n        require(_newRedeemFee \\u003c= 0.10e18,\\\"max 10%\\\");\\n        uint oldFee = protocolFeeRedeem;\\n        protocolFeeRedeem = _newRedeemFee;\\n        emit UpdateRedeemFee(oldFee, protocolFeeRedeem);\\n    }\\n\\n\\n    /**\\n     * @notice Updates redeem fee when trading underlying for underlying\\n     */\\n    function _updateProtocolFeeTrade(uint _newProtocolFee) external {\\n        require(msg.sender == admin,\\\"!admin\\\");\\n        require(_newProtocolFee \\u003c= 0.050e18,\\\"max 5%\\\");\\n        uint oldFee = protocolFeeTrade;\\n        protocolFeeTrade = _newProtocolFee;\\n        emit UpdateProtocolFee(oldFee, protocolFeeTrade);\\n    }\\n\\n\\n    /**\\n     * @notice Returns the trade fee discount for holding XDP tokens\\n     * @param _traderBalance The traders balance of XDP tokens\\n     */\\n    function feeDiscount(uint _traderBalance) public view returns(uint discount) {\\n        if (_traderBalance \\u003e= highThreshold) {\\n            discount = highDiscount;\\n        } else if (_traderBalance \\u003e= medThreshold) {\\n            discount = medDiscount;\\n        } else if (_traderBalance \\u003e= lowThreshold) {\\n            discount = lowDiscount;\\n        } else {\\n            discount = 0;\\n        }\\n    }\\n\\n\\n    /**\\n     * @notice Allows admin to change the fee/reward for deposit, redeem, and trade for each token\\n     * @ testnet\\n     * BNB: 0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd ==\\u003e 2000000000000000\\n     * BUSD: 0x8301F2213c0eeD49a7E28Ae4c3e91722919B8B47 ==\\u003e 2500000000000000\\n     * BTC: 0xA808e341e8e723DC6BA0Bb5204Bafc2330d7B8e4 ==\\u003e 3000000000000000\\n     */\\n    function _updateFeePerToken(IERC20 underlying, uint feeOrReward) external {\\n        require(msg.sender == admin,\\\"!admin\\\");\\n        require(feeOrReward \\u003e 0 \\u0026\\u0026 feeOrReward \\u003c= 0.05e18,\\\"max 5%, min\\u003e0\\\");\\n        if (feePerToken[address(underlying)] == 0) {\\n            allUnderlying.push(underlying);\\n        }\\n        feePerToken[address(underlying)] = feeOrReward;\\n    }\\n\\n\\n    /**\\n     * @notice Returns the fee/reward for specified underlying token\\n     * @dev If fee/reward is zero, then it wasnt updated, and default fee 5%\\n     */\\n    function returnFeePerToken(IERC20 underlying) internal view returns(uint) {\\n        uint fee = feePerToken[address(underlying)];\\n        require(fee\\u003e0,\\\"feePerToken not updated.\\\");\\n        return fee;\\n    }\\n\\n    function returnFeePerTokenExt(IERC20 underlying) external view returns(uint) {\\n        return returnFeePerToken(underlying);\\n    }\\n\\n    // ------------- CALCULATING DEPOSIT/REDEEM FEE OR REWARD ---------------- //\\n\\n\\n    /**\\n     * @notice calculates the reward (or fee) when user deposits a token\\n     * @param _bep20 The underlying asset to be deposited\\n     * @param _valueIn The value of deposited _bep20 (un-used for now)\\n     * @param _priorDelta Desired allocations minus actual allocations before _bep20 deposit (positive if desired more asset) \\n     * @param _postDelta Desired allocations minus estimated allocations after _bep20 deposit\\n     */\\n    function depositRewardOrFee(IERC20 _bep20, uint _valueIn, int _priorDelta, int _postDelta) internal view returns(uint reward, uint fee) {\\n\\n        _valueIn; // may be used in the future to vary deposit reward (or fee)\\n\\n        if (_priorDelta \\u003e= 0) { // require more of the token (net reward unless far excess) \\n\\n            uint priorDelta = uint(_priorDelta);\\n            reward = returnFeePerToken(_bep20);\\n\\n            if (_postDelta \\u003c 0) { // all deposit goes towards desired\\n\\n                uint excess = uint(-_postDelta);\\n\\n                if (priorDelta \\u003e= excess) { // most of the deposit goes towards desired (net reward) \\n\\n                    uint rewardFactor = Lib.getAssetAmt(uint(priorDelta.sub(excess)),priorDelta);\\n                    reward = Lib.getValue(reward, rewardFactor);\\n\\n                } else {\\n\\n                    uint feeFactor = Lib.getAssetAmt(uint(excess.sub(priorDelta)),excess);\\n                    fee = Lib.getValue(feeFactor,reward);\\n                    reward = 0;\\n\\n                }\\n\\n            }\\n\\n        } else { // desires less of the token (full fee)\\n\\n            fee = returnFeePerToken(_bep20);\\n\\n        }\\n\\n\\n    }\\n\\n\\n    function redeemRewardOrFee(IERC20 _bep20, uint _valueIn, int _priorDelta, int _postDelta) internal view returns(uint reward, uint fee) {\\n\\n        _valueIn; // may be used in the future to vary deposit reward (or fee)\\n        \\n        if (_priorDelta \\u003c= 0) { // require less of the token (net reward unless far excess) \\n\\n            reward = returnFeePerToken(_bep20);\\n\\n            if (_postDelta \\u003e 0) { // all deposit goes towards desired\\n\\n                uint priorDelta = uint(-_priorDelta);\\n                uint excess = uint(_postDelta);\\n\\n                if (priorDelta \\u003e= excess) { // most of the deposit goes towards desired (net reward) \\n\\n                    uint rewardFactor = Lib.getAssetAmt(uint(priorDelta.sub(excess)),priorDelta);\\n                    reward = Lib.getValue(reward, rewardFactor);\\n\\n                } else {\\n\\n                    uint feeFactor = Lib.getAssetAmt(uint(excess.sub(priorDelta)),excess);\\n                    fee = Lib.getValue(feeFactor,reward);\\n                    reward = 0;\\n\\n                }\\n\\n            }\\n\\n        } else { // desires less of the token (full fee)\\n\\n            fee = returnFeePerToken(_bep20);\\n\\n        }\\n\\n\\n    }\\n\\n\\n\\n    /** \\n     * @notice Caculates the trade fee (reward) perfect for specified trade\\n     * @dev Only considers the amount needed to be traded to get within threshold\\n     * param _valueIn The USD value being deposited by user\\n     * param _tokenEquity The contract plus collateral values of token being deposited\\n     * param _poolEquity The total equity in the pool\\n     * param _allocationDelta Desired allocation (percent) minus current allocation (percent)\\n     *                         Positive if Trend Token wants more of the asset\\n     * @return reward if deposit/withdrawal rebalances productively, fee if counterproductively\\n     * re-arrange this to have valueFor and valueAgainst\\n     */\\n\\n\\n    /** \\n     * @notice Returns the total Trend Token deposit fee \\n     * @dev May be negative if reward exceeds the protocolBaseFee (especially if high XDP discount)\\n     * @param reward The incentive reward if any\\n     * @param fee The incentive fee if any\\n     */\\n    function totalDepositFee(IERC20 _depositBEP20, uint _valueDeposit, int priorDelta, int postDelta, uint price, uint balanceXTT)  \\n             external view returns(int totalFee, uint protocolFeePerc, uint reward, uint fee) {\\n        price; // may be used in the future\\n        (reward, fee) = depositRewardOrFee(_depositBEP20,_valueDeposit, priorDelta, postDelta);\\n        uint feeFactorFromDiscountXTT = uint(1e18).sub(feeDiscount(balanceXTT));\\n        protocolFeePerc = protocolFeeDeposit.mul(feeFactorFromDiscountXTT).div(1e18);\\n        totalFee = int(protocolFeePerc).add(int(fee)).sub(int(reward));\\n        return (totalFee, protocolFeePerc, reward, fee);\\n\\n    }\\n\\n\\n    /** \\n     * @notice Returns the total Trend Token redeem fee \\n     * @dev May be negative if reward exceeds the protocolBaseFee (especially if high XDP discount)\\n     * @param reward The incentive reward if any\\n     * @param fee The incentive fee if any\\n     */\\n    function totalRedeemFee(IERC20 _redeemBep20, uint _valueRedeem, int priorDelta, int postDelta, uint price, uint balanceXTT) \\n             external view returns(int totalFee, uint protocolFeePerc, uint reward, uint fee) {\\n        price; // may be used in the future\\n        (reward, fee) = redeemRewardOrFee(_redeemBep20,_valueRedeem, priorDelta, postDelta);\\n        uint feeFactorFromDiscountXTT = uint(1e18).sub(feeDiscount(balanceXTT));\\n        protocolFeePerc = protocolFeeRedeem.mul(feeFactorFromDiscountXTT).div(1e18);\\n        totalFee = int(protocolFeePerc).add(int(fee)).sub(int(reward));\\n        return (totalFee, protocolFeePerc, reward, fee);\\n\\n    }\\n\\n    // ------------- TRADE FUNCTIONS ----------------- // \\n\\n\\n    /**\\n     * @notice Returns the value out after _tokenIn is sold\\n     */\\n    function valueOutAfterSell(IERC20 _tokenIn, uint _valueIn, int priorDeltaIn, int postDeltaIn, uint balanceXTT) external view returns(uint redeemValue) {\\n        (uint rewardIn, uint feeIn) = depositRewardOrFee(_tokenIn,_valueIn, priorDeltaIn, postDeltaIn);\\n        uint feeFactorFromDiscountXTT = uint(1e18).sub(feeDiscount(balanceXTT));\\n        uint protocolFeePerc = protocolFeeTrade.mul(feeFactorFromDiscountXTT).div(1e18);\\n        int totalFeeIn = int(protocolFeePerc).add(int(feeIn)).sub(int(rewardIn));\\n        uint muliple = uint(int(1e18).sub(totalFeeIn));\\n        redeemValue = _valueIn.mul(muliple).div(1e18);\\n    }\\n\\n\\n    function valueOutAfterBuy(IERC20 _tokenOut, uint _valueAfterSell, int priorDeltaOut, int postDeltaOut) external view returns(uint buyValue)  {\\n        // calculates value out\\n        (uint rewardOut, uint feeOut) = redeemRewardOrFee(_tokenOut,_valueAfterSell, priorDeltaOut, postDeltaOut);\\n        uint multiple = uint(int(1e18).sub(int(feeOut).sub(int(rewardOut))));\\n        buyValue = _valueAfterSell.mul(multiple).div(1e18);\\n\\n    }\\n\\n\\n}\\n\"},\"ITrendToken.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.5.16; \\n\\nimport \\\"./IVBep20.sol\\\";\\nimport \\\"./ITrendTokenTkn.sol\\\";\\nimport \\\"./IIncentiveModelSimple.sol\\\";\\n\\ninterface ITrendToken {\\n\\n    /**\\n     * @notice For lens\\n     */\\n    function incentiveModel() external view returns(IIncentiveModelSimple);\\n    function storedEquity() external view returns(address[] memory,uint[] memory,uint[] memory,uint[] memory,uint[] memory,uint);\\n    function trendToken() external view returns(ITrendTokenTkn);\\n    function performanceFee() external view returns(uint);\\n\\n    function desiredAllocations() external view returns(uint[] memory);\\n\\n\\n\\n    function lastRebalance() external view returns(uint);\\n    function isTrendToken() external view returns(bool);\\n\\n    function compDP() external view returns (address);\\n    function dBNB() external view returns(IVBep20);\\n    function priceExt(IVBep20 _dToken) external view returns(uint);\\n    function trendTokenToUSDext() external view returns(uint, uint);\\n    function trendTokenOutExternal(IERC20 _depositBep20, IVBep20 _dToken, uint _sellAmtBEP20) external view returns(uint, uint, uint, uint, uint, int); \\n    function trendTokenInExternal(IERC20 _redeemBep20, IVBep20 _dToken, uint _redeemAmt) external view returns(uint, uint, uint, uint, uint, int);\\n    function tradeInfoExt(IERC20[] calldata tokenInOut, IVBep20[] calldata dTokensInOut, uint valueIn) external view returns(uint);\\n\\n}\\n\\n\"},\"ITrendTokenTkn.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.5.16;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see `ERC20Detailed`.\\n */\\ninterface ITrendTokenTkn {\\n  \\n    function mint(address _recipient, uint256 _amount) external;\\n\\n    function name() external view returns(string memory);\\n\\n    function burn(uint256 _amount) external;\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\\n     * zero by default.\\n     *\\n     * This value changes when `approve` or `transferFrom` are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * \\u003e Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an `Approval` event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     */\\n    //function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    function transfersFrom(address sender, address recipient, uint256 amount) external returns(bool); // requires allowance (instead of subtraction overflow message)\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to `approve`. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"IVBep20.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.5.16;\\n\\ninterface IVBep20 {\\n\\n    function balanceOf(address _user) external view returns(uint256);\\n    function balanceOfUnderlying(address account) external returns (uint);\\n\\n    function mint(uint mintAmount) external returns (uint); // Different for IVBNB\\n    function repayBorrow(uint256 _amount) external returns(uint256); // Different for IVBNB\\n\\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\\n    function exchangeRateStored() external view returns(uint256);\\n    function borrowBalanceCurrent(address _owner) external returns(uint256);\\n    function borrow(uint256 _amount) external returns(uint256);\\n\\n    function getCash() external view returns (uint);\\n\\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\\n    function borrowBalanceStored(address account) external view returns (uint);\\n    function totalBorrowsCurrent() external returns (uint);\\n\\n    function accrueInterest() external returns (uint);\\n\\n    /*** Trading Functionality ***/\\n    \\n    function amountsOut(address _dTokenIn, address _dTokenOut, uint _amountIn, address _trader, address _referrer) external view returns(uint amountOut, uint reserveFeeUnderly, uint totalFeeAndSlip);\\n    function swapExactTokensForTokens(uint256 _amountTokenIn, uint256 _minOut, address[] calldata dTokenOut_referrer, address payable _sendTo, uint256 _deadline) external;\\n\\n\\n    function underlying() external view returns(address);\\n\\n}\"},\"IVBNB.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.5.16;\\n\\n\\ninterface IVBNB {\\n    function balanceOf(address _owner) external view returns(uint256);\\n    function balanceOfUnderlying(address _owner) external returns(uint256);\\n    function mint() external payable; // different for IVBep20\\n    function repayBorrow() external payable;\\n    function redeemUnderlying(uint256 _amount) external returns(uint256);\\n    function exchangeRateStored() external view returns(uint256);\\n    function borrowBalanceCurrent(address account) external returns (uint);\\n    function borrow(uint256 _amount) external returns(uint256);\\n    function getAccountSnapshot(address account) external view returns (uint, uint, uint, uint);\\n    function borrowBalanceStored(address account) external view returns (uint);\\n    function totalBorrowsCurrent() external returns (uint);\\n\\n    /*** Trading Functionality ***/\\n    //function swapExactTokenForBNB(address _iTokenIn, uint _amountTokenIn, uint _minOut, uint _deadline) external;\\n    function swapExactETHForTokens(uint _minOut, address[] calldata dTokenOut_referrer, address payable _sendTo, uint _deadline) external payable;\\n}\\n\\n\\n\"},\"IXTT.sol\":{\"content\":\"// SPDX-License-Identifier: ISC\\npragma solidity ^0.5.16;\\n\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\\n * the optional functions; to access them see `ERC20Detailed`.\\n */\\ninterface IXTT {\\n  \\n\\n    function burn(uint256 _amount) external;\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\\n     * zero by default.\\n     *\\n     * This value changes when `approve` or `transferFrom` are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * \\u003e Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an `Approval` event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a `Transfer` event.\\n     */\\n    //function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    function transfersFrom(address sender, address recipient, uint256 amount) external returns(bool); // requires allowance (instead of subtraction overflow message)\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to `approve`. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"Lib.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.5.16;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./SignedSafeMath.sol\\\";\\n\\n\\nlibrary Lib { // deployed at: 0x92EB22eb4f4dFE719a988F328cE88ce36DD5279A\\n\\n    using SafeMath for uint;\\n    using SignedSafeMath for int;\\n\\n    // Contastants \\n    uint public constant PRICE_DEN = 1e18;\\n\\n    // -----   PancakeSwap ----------- //\\n\\n    \\n    function pathGenerator2(address coinIn, address coinOut) internal pure returns(address[] memory) {\\n        address[] memory path = new address[](2);\\n        path[0] = address(coinIn);\\n        path[1] = address(coinOut);\\n        return path;\\n    }\\n\\n\\n    function getValue(uint256 _amount, uint256 _price) internal pure returns(uint256) {\\n        return _amount.mul(_price).div(PRICE_DEN);\\n    }\\n\\n\\n    function getAssetAmt(uint256 _usdAmount, uint256 _price) internal pure returns(uint256) {\\n        return _usdAmount.mul(PRICE_DEN).div(_price);\\n    }\\n\\n\\n}\"},\"SafeERC20.sol\":{\"content\":\"pragma solidity ^0.5.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // \\u0027safeIncreaseAllowance\\u0027 and \\u0027safeDecreaseAllowance\\u0027\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity\\u0027s return data size checking mechanism, since\\n        // we\\u0027re implementing it ourselves.\\n\\n        // A Solidity high level call has three parts:\\n        //  1. The target address is checked to verify it contains contract code\\n        //  2. The call itself is made, and success asserted\\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\\n        // solhint-disable-next-line max-line-length\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\n\\n        if (returndata.length \\u003e 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.5.16;\\n\\n// Copyright 2020 Venus Labs, Inc.\\n\\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\\n\\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\\n// 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\\n\\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A \\n// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, \\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, \\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\\n\\n/**\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it\\u0027s recommended to use it always.\\n */\\nlibrary SafeMath {\\n  /**\\n   * @dev Returns the addition of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity\\u0027s `+` operator.\\n   *\\n   * Requirements:\\n   * - Addition cannot overflow.\\n   */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return add(a, b, \\\"SafeMath: addition overflow\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n   * overflow (when the result is negative).\\n   *\\n   * Counterpart to Solidity\\u0027s `-` operator.\\n   *\\n   * Requirements:\\n   * - Subtraction cannot overflow.\\n   */\\n  function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c \\u003e= a, errorMessage);\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, reverting on\\n   * overflow (when the result is negative).\\n   *\\n   * Counterpart to Solidity\\u0027s `-` operator.\\n   *\\n   * Requirements:\\n   * - Subtraction cannot overflow.\\n   */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n  }\\n\\n  //function Asub(uint256 a, uint256 b) public pure returns (uint256) {\\n  //  return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n  //}\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n   * overflow (when the result is negative).\\n   *\\n   * Counterpart to Solidity\\u0027s `-` operator.\\n   *\\n   * Requirements:\\n   * - Subtraction cannot overflow.\\n   */\\n  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n    require(b \\u003c= a, errorMessage);\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the multiplication of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity\\u0027s `*` operator.\\n   *\\n   * Requirements:\\n   * - Multiplication cannot overflow.\\n   */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n    // benefit is lost if \\u0027b\\u0027 is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the integer division of two unsigned integers. Reverts on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return div(a, b, \\\"SafeMath: division by zero\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n    // Solidity only automatically asserts when dividing by 0\\n    require(b \\u003e 0, errorMessage);\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n   * Reverts when dividing by zero.\\n   *\\n   * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\n   * invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n   * Reverts with custom message when dividing by zero.\\n   *\\n   * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\n   * invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n    require(b != 0, errorMessage);\\n    return a % b;\\n  }\\n}\"},\"SignedSafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.5.16;\\n\\n\\n/**\\n * @title SignedSafeMath\\n * @dev Signed math operations with safety checks that revert on error.\\n */\\nlibrary SignedSafeMath {\\n    int256 constant private _INT256_MIN = -2**255;\\n\\n    /**\\n     * @dev Multiplies two signed integers, reverts on overflow.\\n     */\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        require(!(a == -1 \\u0026\\u0026 b == _INT256_MIN), \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        int256 c = a * b;\\n        require(c / a == b, \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\\n     */\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        require(b != 0, \\\"SignedSafeMath: division by zero\\\");\\n        require(!(b == -1 \\u0026\\u0026 a == _INT256_MIN), \\\"SignedSafeMath: division overflow\\\");\\n\\n        int256 c = a / b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Subtracts two signed integers, reverts on overflow.\\n     */\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a - b;\\n        require((b \\u003e= 0 \\u0026\\u0026 c \\u003c= a) || (b \\u003c 0 \\u0026\\u0026 c \\u003e a), \\\"SignedSafeMath: subtraction overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Adds two signed integers, reverts on overflow.\\n     */\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a + b;\\n        require((b \\u003e= 0 \\u0026\\u0026 c \\u003e= a) || (b \\u003c 0 \\u0026\\u0026 c \\u003c a), \\\"SignedSafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n}\"},\"TrendToken.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.5.16;\\n\\nimport \\\"./TrendTokenTkn.sol\\\";\\nimport \\\"./DualPool.sol\\\";\\nimport \\\"./CompTT.sol\\\";\\nimport \\\"./ICompTT.sol\\\";\\nimport \\\"./TrendTokenStorage.sol\\\";\\nimport \\\"./IncentiveModelSimple.sol\\\";\\nimport \\\"./SignedSafeMath.sol\\\";\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./SafeERC20.sol\\\";\\n\\n\\n\\ncontract TrendToken is DualPoolIntegration, TrendTokenStorage { \\n\\n    using SignedSafeMath for int;\\n    using SafeERC20 for IERC20;\\n\\n\\n    constructor(address _wbnb, address _compTT, address _compDP) \\n                DualPoolIntegration(_wbnb,_compTT,_compDP) public {\\n        compTT = ICompTT(_compTT);\\n        manager = msg.sender;\\n        tradingBot = msg.sender;\\n        feeRecipient = msg.sender;\\n        TrendTokenTkn _trendToken = new TrendTokenTkn(\\\"TrendToken Top5\\\",\\\"TREND5\\\");\\n        trendToken = ITrendTokenTkn(address(_trendToken));\\n        wbnb = IERC20(_wbnb);\\n        _notEntered = true;\\n        \\n    }\\n\\n\\n    /**\\n     * @notice Allows for the deposit of BNB to this contract\\n     */\\n    function () external payable {\\n        //emit RecievedBNB(msg.value);\\n    }\\n\\n\\n    /**\\n     * @notice Used for contract byte size savings\\n     */\\n    function onlyModifiers(address _owner, string memory message) view internal {\\n        require(msg.sender == _owner, message);\\n    }\\n\\n\\n    /**\\n     * @notice Restricts actions to manager\\n     */\\n    modifier onlyManager() {\\n        onlyModifiers(manager,\\\"!manager\\\");\\n        _;\\n    } \\n\\n\\n    /**\\n     * @notice Restricts actions to tradingBot\\n     */\\n    modifier onlyTradingBot() {\\n        onlyModifiers(tradingBot,\\\"!tradingBot\\\");\\n        _;\\n    } \\n\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     */\\n    modifier nonReentrant() {\\n        require(_notEntered, \\\"re-entered\\\");\\n        _notEntered = false;\\n        _;\\n        _notEntered = true; // get a gas-refund post-Istanbul\\n    }\\n\\n\\n    /**\\n     * @notice Prevents mint, redeem, and borrow rebalance if Trend Tokens are paused\\n     */\\n    modifier pausedTrendToken() {\\n        require(!trendTokenPaused, \\\"!paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Prevents Manager from executing highly secure operations\\n     * @dev Including _updateCompAndModels, _updateManagerRecipientAndBot, _maxDisableValue, _adjustCollateral \\n     */\\n    modifier requireUnlocked() {\\n        require(!locked,\\\"!locked\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Ensures deadline is not exceeded upon deposit, redeem, or swap\\n     */\\n    modifier ensureDeadline(uint _deadline) {\\n        require(_deadline \\u003e= block.timestamp, \\\"!timestamp\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Checks wheter or not value is equal to or less than max, else gives message\\n     * @dev Saves byte size over repreating similar require statements\\n     */\\n    function requireUnderAmount(uint value, uint max, string memory message) internal pure {\\n        require(value\\u003c=max, message);\\n    }\\n\\n\\n    // ---------------   ADMIN FUNCTIONS \\u0026 VARIABLES ----------------- //\\n\\n    \\n    // -------  MANAGER: UPDATE ADDRESSES ------- // \\n\\n\\n    /**\\n     * @notice Sets new Trend Token comptroller, Dual Pool comptroller, and incentive model\\n     * @dev If want unchanged, set parameter to zero address\\n     * @param _compTT The Trend Token comptroller that governs all Trend Tokens\\n     * @param _compDP The Dual Pool comptroller that governs all dTokens for lend/redeem actions\\n     * @param _incentiveModel View functions that dictate the deposit and redeem rewarrds \\n     */\\n    function _updateCompAndModels(address _compTT, address _compDP, IIncentiveModelSimple _incentiveModel) onlyManager requireUnlocked external {\\n        \\n        if (_compTT != address(0)) {\\n            address oldCompTT = address(compTT);\\n            require(ICompTT(_compTT).trendTokenIsActive(address(this)),\\\"Inactive TT.\\\" );\\n            compTT = ICompTT(_compTT);\\n            emit NewCompTT(oldCompTT, address(compTT));\\n        }\\n\\n        if (_compDP != address(0)) {\\n            address oldCompDP = address(compDP);\\n            compDP = ICompDP(_compDP);\\n            emit NewCompDP(oldCompDP, address(compDP));\\n        }\\n\\n        if (address(_incentiveModel) != address(0)) {\\n            address oldIncentive = address(incentiveModel);\\n            incentiveModel = _incentiveModel;\\n            emit NewIncentiveModel(oldIncentive, address(incentiveModel));\\n        }\\n \\n    }\\n\\n\\n    /**\\n     * @notice Allows manager to change manager, fee recipient, and trading bot\\n     * @dev If want unchanged, set parameter to zero address\\n     * @param _manager Ability to set fees, factors, etc\\n     * @param _feeRecipient Address where deposit, redeem, performance, and XDP earnings go\\n     * @param _tradingBot Ability to set portfolios, allocations, and some Dual Pool actions\\n     */\\n    function _updateManagerRecipientAndBot(address _manager, address payable _feeRecipient, address _tradingBot) onlyManager requireUnlocked external {\\n\\n        if (_manager != address(0)) {\\n            address oldManager = address(manager);\\n            manager = _manager;\\n            emit NewManager(oldManager, address(manager));\\n        }\\n\\n        if (_feeRecipient != address(0)) {\\n            address oldFeeRecipient = address(feeRecipient);\\n            feeRecipient = _feeRecipient;\\n            emit NewFeeRecipient(oldFeeRecipient, address(feeRecipient));\\n        }\\n\\n        if (_tradingBot != address(0)) {\\n            address oldTradingBot = address(tradingBot);\\n            tradingBot = _tradingBot;\\n            emit NewTradingBot(oldTradingBot, address(tradingBot));\\n        }\\n\\n    }\\n    \\n\\n    // -------  MANAGER: UPDATE FEES/REWARDS ------- // \\n\\n    \\n    /** \\n     * @notice Updates performance fee \\n     * @dev Must send performance fee first \\n     * param _performanceFee Percentage of new trend token ATH gains that goes to reserves\\n     */\\n    function _newPerformanceFee(uint _performanceFee) onlyManager requireUnlocked external {\\n        requireUnderAmount(_performanceFee, compTT.trendTokenMaxPerformanceFee(address(this)), \\\"!performanceFee\\\");\\n        (uint trendTokenPrice, uint mintMBNB) = trendTokenToUSD(); \\n        sendPerformanceFee(mintMBNB, trendTokenPrice);\\n        uint oldFee = performanceFee;\\n        performanceFee = _performanceFee;\\n        emit NewPerformanceFee(oldFee, performanceFee);\\n    }\\n    \\n\\n    /**\\n     * @notice Updates the fee distribution to Fee Receipient\\n     * @param _trendTokenRedeemBurn Percentage of redeem trend token fees that get burned (instead of going to reserves)\\n     *                               which increases the value of Trend Tokens\\n     */\\n    function _updateTrendTokenBurn(uint  _trendTokenRedeemBurn) external onlyManager {\\n        requireUnderAmount(_trendTokenRedeemBurn, 1e18, \\\"exceeded 100%.\\\");\\n        uint oldTrendToken = trendTokenRedeemBurn;\\n        trendTokenRedeemBurn = _trendTokenRedeemBurn;\\n        emit UpdateTrendTokenBurn(oldTrendToken, trendTokenRedeemBurn);\\n    }\\n\\n\\n    /**\\n     * @notice Allows manager to set the referralReward\\n     */\\n    function _setReferralReward(uint _referralReward) onlyManager external {\\n        requireUnderAmount(_referralReward, 0.50e18, \\\"!_setReferralReward\\\");\\n        uint oldReward = referralReward;\\n        referralReward = _referralReward;\\n        emit SetReferralReward(oldReward, referralReward);\\n    }\\n\\n\\n    // -------   MANAGER: UPDATE VALUES ------- // \\n\\n\\n    /**\\n     * @notice Sets the minimum value of a token before it can be removed from the portfolio\\n     */\\n    function _maxDisableValue(uint _maxDisableTokenValue) onlyManager requireUnlocked external {\\n        requireUnderAmount(_maxDisableTokenValue, compTT.trendTokenMaxDisableValue(address(this)), \\\"!maxDisableValue\\\");\\n        uint oldValue = maxDisableTokenValue;\\n        maxDisableTokenValue = _maxDisableTokenValue;\\n        emit MaxDisableValue(oldValue, maxDisableTokenValue);\\n    }\\n\\n\\n    /**\\n     * @notice Allows manager to set the maximum Trend Token supply\\n     * @param _maxSupply The new Trend Token max supply \\n     */\\n    function _setMaxSupply(uint _maxSupply) onlyManager external {\\n        uint oldSupply = maxSupply;\\n        maxSupply = _maxSupply;\\n        emit SetMaxSupply(oldSupply, maxSupply);\\n    }\\n\\n\\n    /**\\n     * @notice Allows manager to set amount of equity to be held in contract (remainder held in Dual Pools)\\n     */\\n    function setContractFactor(uint _contractFactor) internal {\\n        requireUnderAmount(_contractFactor, 1e18, \\\"!max\\\");\\n        uint oldFactor = contractFactor;\\n        contractFactor = _contractFactor;\\n        emit SetContractFactor(oldFactor, contractFactor);\\n    }\\n\\n\\n    /**\\n     * @notice Allows manager to set amount of equity to be held in contract (remainder held in Dual Pools)\\n     */\\n    function _setContractFactor(uint _contractFactor) onlyManager external {\\n        setContractFactor(_contractFactor);\\n    }\\n\\n\\n    // -------- MANAGER: DUAL POOL INTERACTIONS --------------- // \\n\\n    /**\\n     * @notice Allows admin to supply or redeem collateral from contract holdings\\n     */\\n    function _adjustCollateral(IERC20 _bep20, uint _supplyAmt, uint _redeemAmt) onlyManager requireUnlocked external {\\n        IVBep20 dToken = dTokenSupportedRequire(_bep20);\\n        if (_supplyAmt \\u003e 0) {\\n            collateralSupply(_bep20,dToken, _supplyAmt);\\n        } else if (_redeemAmt \\u003e 0) {\\n            collateralRedeem(_bep20,dToken,_redeemAmt);\\n        }\\n    }\\n\\n\\n    // ------- TRADING BOT: UPDATE BOOL --------- //\\n\\n\\n    /**\\n     * @notice Allows trading bot to change state of locked\\n     * @dev if locked is true, manager actions are limited (higher security) \\n     *      as a result, some actions require permission of both\\n     */\\n    function _updateLocked(bool _state) onlyTradingBot external {\\n        bool oldState = locked;\\n        locked = _state;\\n        emit Locked(oldState, locked);\\n    }\\n\\n\\n    /**\\n     * @notice Allows trading bot to pause deposits of underlying\\n     * @dev Used when wanting to disable a token\\n     */\\n    function _depositsDisabled(address underlying, bool _state) onlyTradingBot external {\\n        bool oldState = depositsDisabled[underlying];\\n        depositsDisabled[underlying] = _state;\\n        emit DepositsDisabled(underlying, oldState, depositsDisabled[underlying] );\\n    }\\n\\n\\n    /**\\n     * @notice Allows manager to pause Trend Token\\n     * @dev Pauses mint/redeem/borrowRebalance of this Trend Token\\n     * @param _pause True if this Trend Token is to be paused\\n     */\\n    function _pauseTrendToken(bool _pause) onlyTradingBot external {\\n        bool oldState = trendTokenPaused;\\n        trendTokenPaused = _pause;\\n        emit PauseTrendToken(oldState, trendTokenPaused);\\n    }\\n\\n\\n\\n    // ------- TRADING BOT: UPDATE PORTFOLIO --------- //\\n\\n\\n    /**\\n     * @notice Requires dToken for _bep20 to exist\\n     */\\n    function dTokenSupportedRequire(IERC20 _bep20) internal view returns(IVBep20) {\\n        IVBep20 dToken = IVBep20(compTT.returnDToken(address(_bep20))); \\n        require(address(dToken) != address(0), \\\"!dToken\\\");\\n        return dToken;\\n    }\\n\\n\\n    /**\\n     * @notice Changes deposit weights of portfolio\\n     * @dev Weights must equal 1e18 and be same length as entered portfolio on Dual Pools\\n     * @param _allocations The desired supply and contract equity positions (\\u003e100% when leverage long)\\n     */\\n    function _setDesiredAllocationsFresh(uint[] memory _allocations) internal {\\n        uint allocationTotal = 0;\\n        for (uint i=0; i\\u003c_allocations.length; i++) {\\n            allocationTotal = allocationTotal.add(_allocations[i]);\\n        }\\n        require(allocationTotal == 1e18 \\u0026\\u0026 _allocations.length == getMarkets().length, \\\"allocation!=100% or !length\\\");\\n        uint[] memory oldAllocations = desiredAllocations;\\n        desiredAllocations = _allocations;\\n        emit SetDesiredAllocationsFresh(getMarkets(), oldAllocations, desiredAllocations);\\n    }\\n\\n\\n    /**\\n     * @notice Allows manager to change deposit weights without changing portfolio\\n     * @param _allocations The desired supply and contract equity positions (\\u003e100% when leverage long)\\n     * param _borrows The desired borrow borrow positions (\\u003e0% USD when long, \\u003e0% other when short)\\n     */\\n    function _setDesiredAllocations(uint[] calldata _allocations) onlyTradingBot external {\\n        _setDesiredAllocationsFresh(_allocations);\\n    }\\n\\n\\n    /** \\n    *   Enables tokens market (borrow or collateral)\\n    *   Requires tokens is listed in venusTokens \\n    *   requires slippage on pancake is below threshold (commented out for isolated test)\\n    */\\n    function _enableTokens(address[] calldata _tokens, uint[] calldata _allocations) onlyTradingBot external {\\n        address[] memory dTokens = new address[](_tokens.length);\\n        for (uint i=0; i\\u003c_tokens.length; i++) {\\n            address token = _tokens[i];\\n            address dToken = address(dTokenSupportedRequire(IERC20(token)));\\n            dTokens[i] = dToken; \\n        }\\n        enableCol(dTokens);\\n        _setDesiredAllocationsFresh(_allocations);\\n    }\\n\\n\\n    /**\\n    * @notice Requires the dToken has been enabled on Dual Pools\\n    * @dev All enabled tokens are also listed and active on CompTT\\n    */\\n    function checkActiveToken(IVBep20 _dToken) internal view {\\n        require(address(_dToken) != address(0) \\u0026\\u0026 tokenEntered(_dToken),\\\"!enabled\\\");\\n    }\\n\\n\\n    /** \\n    *   Disables token market (cant borrow or collateral)\\n    *   Requires token is currently enabled\\n    *   Requires total value (contract, collateral, borrow) is below minTradeVal\\n    *       otherwise Equity will drop and therefore price of Trend Token\\n    */\\n    function _disableToken(IERC20 _bep20, uint[] calldata _allocations) onlyTradingBot external {\\n        IVBep20 dToken = dTokenSupportedRequire(_bep20);\\n        require(_bep20 != wbnb \\u0026\\u0026 tokenEquityVal(dToken) \\u003c maxDisableTokenValue,\\\"!BNB or !maxVal\\\");\\n        checkActiveToken(dToken);\\n        compDP.claimXDP(address(this));\\n        disableCol(dToken);\\n        _setDesiredAllocationsFresh(_allocations);\\n    }\\n\\n\\n    // -------------------- MANAGER: REDEEM \\u0026 REDUCE TREND TOKENS ------------------- // \\n    /**\\n     * @notice Allows manager to redeem Trend Tokens to fee recipient OR redeem for BNB --\\u003e XTT --\\u003e burn\\n     */\\n\\n\\n    /**\\n     * @notice Sends performance fee (in Trend Tokens) to this Trend Token contract\\n     */\\n    function _redeemPerformanceFee() onlyManager external {\\n        (uint trendTokenPrice, uint mintMBNB) = trendTokenToUSD(); \\n        sendPerformanceFee(mintMBNB, trendTokenPrice);\\n    }\\n\\n\\n    /** \\n     * @notice Allows manager to redeem Trend Tokens to fee recipient wallet\\n     */\\n    function _reduceTrendTokenReservesToRecipient(uint redeemAmtTrendToken) onlyManager external  {\\n        uint currentBalance = trendToken.balanceOf(address(this));\\n        requireUnderAmount(redeemAmtTrendToken, currentBalance, \\\"!balanceTT\\\");\\n        IERC20(address(trendToken)).safeTransfer(feeRecipient,redeemAmtTrendToken);\\n    }\\n\\n\\n    // ------- TRADING BOT: REDEEM \\u0026 DISTRIBUTE XDP --------- //\\n\\n    /** \\n     * @notice Claims XDP from Dual Pools and sends _redeemAmountXDP to Fee Recipoient\\n     * @dev The remainder of XDP stays in the pool \\n     */\\n    function _redeemXDPtoRecipient(bool claim, uint _redeemAmountXDP) onlyManager external  {\\n        if (claim) {\\n            compDP.claimXDP(address(this));\\n        }\\n        requireUnderAmount(_redeemAmountXDP, balanceXDP(),\\\"!balXDP\\\");\\n        xdp.safeTransfer(feeRecipient,_redeemAmountXDP);\\n    }\\n\\n\\n    // ------ EXTERNAL VIEW FUNCTIONS ------------- //\\n\\n\\n    /**\\n     * @notice Returns the underlying price of dToken externally\\n     */\\n    function priceExt(IVBep20 _dToken) external view returns(uint) {\\n        return priceBEP20(_dToken) ;\\n    }\\n\\n\\n    /**\\n     * @notice Returns the price of trend token (in USD) externally\\n     */\\n    function trendTokenToUSDext() external view returns(uint, uint) {\\n        return trendTokenToUSD();\\n    }\\n\\n\\n    /** \\n     * @param trendTokenIn True if trendTokenInCalculations else trendTokenOutCalculations\\n     * @return (uint price, uint trendTokenPrice, uint mintMBNB, uint trendTokenAmt, uint protocolFeePerc, int feeOrReward)\\n     */\\n    function trendTokenExternal(IERC20 _bep20, IVBep20 _dToken, uint _amount, bool trendTokenIn) \\n        external view returns(uint, uint, uint, uint, uint, int)  {\\n            if (trendTokenIn) {\\n                return trendTokenInCalculations(_bep20, _dToken, _amount);\\n            } else {\\n                return trendTokenOutCalculations(_bep20, _dToken, _amount);\\n            }\\n    }\\n\\n\\n    /**\\n     * @notice External function for stored equity\\n     */\\n    function storedEquityExternal() external view returns(address[] memory,uint[] memory,uint[] memory,uint[] memory,uint) {\\n        return storedEquity();\\n    }\\n\\n\\n    /**\\n     * @notice External function for token information\\n     */\\n    function tokenInfoExternal(IVBep20 _dToken, uint depositAmt, uint redeemAmt) external view returns(int, int, uint, uint) {\\n        return tokenInfo(_dToken, depositAmt, redeemAmt);\\n    }\\n\\n\\n    /**\\n     * @notice Calculates the value out after selling tokenInOut[0] for tokenInOut[1]\\n     */\\n    function tradeInfoExt(IERC20[] calldata tokenInOut, IVBep20[] calldata dTokensInOut, uint valueIn) external view returns(uint) {\\n        return tradeInfo(tokenInOut, dTokensInOut, valueIn);\\n    }\\n\\n\\n\\n    // ----- PROTOCOL DEPOSITS AND WITHDRAWALS   ------ //\\n\\n    // --------- PERFORMANCE FEE ---------- // \\n\\n\\n    /**\\n     * @notice Calculates outstanding performance fee\\n     * @param trendTokenPrice The current price of a Trend Token\\n     * @param trendTokenSupply The current Trend Token supply\\n     * @return The amount of Trend Tokens desired to be minted and sent to fee recipient\\n     */\\n    function calculatePerformanceFee(uint trendTokenPrice, uint trendTokenSupply) internal view returns(uint) {\\n        uint gainATH = trendTokenPrice.sub(trendTokenATH); // (3e18 - 1.5e18) = 1.5e18\\n        uint feeAmt = Lib.getValue(gainATH,performanceFee); // 1.5e18 * 20% = = 0.30e18\\n        uint targetPrice = trendTokenPrice.sub(feeAmt); // 3e18 - 0.30e18 = 2.7e18 (price after fee)\\n        uint mintPercent = Lib.getAssetAmt(trendTokenPrice,targetPrice) - 1e18;// (3.0e18*1e18/2.7e18) - 1e18 = 0.1111e18\\n        uint mintTrendTokenAmt = Lib.getValue(trendTokenSupply,mintPercent); // 100e18 * 0.1111e18 / 1e18 = 11.111...e18 mBNB \\n        return mintTrendTokenAmt;\\n    }\\n\\n\\n    /**\\n     * @notice Mints and sends trend token performance fees to reserves\\n     * @param _mintTrendTokenAmt The number of Trend Tokens desired to be minted\\n     * @param _trendTokenPrice The current Trend Token price in USD\\n     */\\n    function sendPerformanceFee(uint _mintTrendTokenAmt, uint _trendTokenPrice) internal {\\n        if (_mintTrendTokenAmt\\u003e0) {\\n            trendToken.mint(address(this), _mintTrendTokenAmt); // mint and send 10.52e18 margin tokens to owner (decreasing value 1.041%)\\n            uint oldTrendTokenATH = trendTokenATH;\\n            trendTokenATH = _trendTokenPrice; // update \\n            emit PerformanceFee(_trendTokenPrice,oldTrendTokenATH,trendTokenATH, _mintTrendTokenAmt);\\n        }\\n    }\\n\\n\\n    // --------- BALANCES, EQUITY, TREND TOKEN PRICE ---------- // \\n    /**\\n     * @notice Key internal view functions to supply and redeem Trend Tokens\\n     */\\n\\n\\n    /**\\n     * @notice Fetches the balance of XDP of this Trend Token\\n     */\\n    function balanceXDP() internal view returns(uint balance) {\\n        balance = xdp.balanceOf(address(this));\\n    }\\n\\n\\n    /**\\n     * @notice Fetches this Trend Tokens balance of an underlying token\\n     * @param _dToken The dToken to get balance of \\n     * @return The balance of _token\\n     */\\n    function contractBal(IVBep20 _dToken) internal view returns(uint) {\\n        if (_dToken == dBNB) { \\n            return address(this).balance;\\n        } else { \\n            return IERC20(_dToken.underlying()).balanceOf(address(this));\\n        }\\n    }\\n\\n\\n    /**\\n     * @notice Fetchs the current balance of Trend Token and calculates total equity\\n     * @dev Total Equity is the value of call contract and collateral positons\\n    */\\n    function storedEquity() internal view returns(address[] memory,uint[] memory,uint[] memory,uint[] memory,uint) {  // returns current balances (uint)\\n\\n        address[] memory dTokens = getMarkets();\\n        uint[] memory prices = new uint[](dTokens.length);\\n        uint[] memory conVals = new uint[](dTokens.length);\\n        uint[] memory colVals = new uint[](dTokens.length);\\n        uint assetValSum = 0; \\n\\n        for (uint i = 0; i \\u003c dTokens.length; i++) {\\n\\n            // fetch token and price\\n            IVBep20 dToken = IVBep20(dTokens[i]);\\n            uint tokenToUSD = priceBEP20(dToken);\\n            prices[i] = tokenToUSD;\\n            (uint tokenBal,, uint rate) = screenshot(dToken);\\n\\n            // contract balances\\n            uint contractVal = Lib.getValue(contractBal(dToken),tokenToUSD);\\n            conVals[i] = contractVal;\\n\\n            // collateral values\\n            uint collateralAmt = Lib.getValue(tokenBal,rate);\\n            uint collateralVal = Lib.getValue(collateralAmt,tokenToUSD);\\n            colVals[i] = collateralVal;\\n            \\n            assetValSum = assetValSum.add(contractVal.add(collateralVal));\\n\\n        }\\n\\n        uint netEquity = assetValSum;\\n        return (dTokens,prices,conVals,colVals,netEquity);\\n\\n    }\\n\\n\\n    /**\\n     * @notice Publicly returns this Trend Tokens price in USD\\n     */\\n    function trendTokenToUSD() internal view returns(uint,uint) {\\n        (,,,,uint equity) = storedEquity();\\n        return trendTokenToUSD(equity);\\n    }\\n\\n\\n    /**\\n    * @notice Calculate the Trend Token Price in USD\\n    * @dev Deducts any outstanding performance fees and adds value of XDP if the price exists   \\n    * @param _equityInUSD The current equity value of portfolio\\n    * @return Price of Trend Token, number of outstand performance fee Trend Tokens\\n    */\\n    function trendTokenToUSD(uint _equityInUSD) internal view returns(uint,uint) {  \\n\\n        uint price = 1e18; // starting condition\\n        uint supplyTrendToken = trendToken.totalSupply();\\n        uint mintTrendToken = 0; \\n\\n        if (supplyTrendToken \\u003e 0) {\\n\\n            price = Lib.getAssetAmt(_equityInUSD,supplyTrendToken);\\n\\n            if (price \\u003e trendTokenATH) { // account for outstading performance fee\\n                mintTrendToken = calculatePerformanceFee(price, supplyTrendToken);\\n            }\\n\\n            price = Lib.getAssetAmt(_equityInUSD,supplyTrendToken.add(mintTrendToken));\\n        }\\n\\n        return (price,mintTrendToken);\\n\\n    }\\n\\n\\n    /**\\n     * @notice Fetches data required for deposit/redeem incentives for a specific token\\n     * @param _dToken The spefific token to get information on\\n     * @return allocationDelata Difference between desired and current percent allocations\\n     *         price The price of _token, \\n     *         equity The total Trend Token equity in contract and Dual Pools\\n     *         Positive allocation delta if desire more of the asset\\n     */\\n    function tokenInfo(IVBep20 _dToken, uint depositAmt, uint redeemAmt) internal view returns(int priorDelta, int postDelta, uint price, uint equity) {\\n        \\n        (address[] memory dTokens, // 0x00 in placeholder for all tokens except _dToken\\n        uint[] memory prices,\\n        uint[] memory conVals,\\n        uint[] memory colVals,\\n        uint netEquity) = storedEquity(); // !!!!!!!!!!!!!!!!!!! change to a array of single token (or tokenInfo input paramet\\n\\n        for (uint i=0; i \\u003c dTokens.length; i++) {\\n\\n            if (IVBep20(dTokens[i]) == _dToken) {\\n\\n                price = prices[i];\\n                equity = netEquity;\\n                uint depositVal = Lib.getValue(depositAmt,price);\\n                uint redeemVal = Lib.getValue(redeemAmt,price);\\n\\n                if (netEquity\\u003e0) {\\n\\n                    uint tokenEquity = conVals[i].add(colVals[i]);\\n                    uint priorAllocation = Lib.getAssetAmt(tokenEquity,netEquity);\\n                    priorDelta = int(desiredAllocations[i]).sub(int(priorAllocation));\\n\\n                    require(tokenEquity \\u003e= redeemVal \\u0026\\u0026 netEquity \\u003e= redeemVal,\\\"not enough to redeem\\\");\\n\\n                    uint postAllocation = Lib.getAssetAmt(tokenEquity.add(depositVal).sub(redeemVal),netEquity.add(depositVal).sub(redeemVal));\\n                    postDelta = int(desiredAllocations[i]).sub(int(postAllocation));\\n\\n                } else {\\n\\n                    require(redeemVal==0,\\\"redeem=0.\\\");\\n                    priorDelta = int(desiredAllocations[i]);\\n                    postDelta = int(1e18);\\n                     \\n                }\\n                \\n            }\\n        \\n        }\\n\\n    }\\n\\n\\n    /**\\n     * @notice Calculates the equity (in USD) of underlying associated with _dToken\\n    */\\n    function tokenEquityVal(IVBep20 _dToken) internal view returns(uint) {\\n        \\n        address[] memory _dTokens = getMarkets();\\n\\n        for (uint i=0; i \\u003c _dTokens.length; i++) {\\n\\n            if (IVBep20(_dTokens[i]) == _dToken) {\\n\\n                // get info\\n                uint tokenPrice = priceBEP20(IVBep20(_dTokens[i]));\\n                (uint tokenBal,, uint rate) = screenshot(IVBep20(_dTokens[i]));\\n\\n                // get contract value\\n                uint contractVal = Lib.getValue(contractBal(IVBep20(_dTokens[i])),tokenPrice);\\n\\n                // get collateral value\\n                uint collateralVal = Lib.getValue(Lib.getValue(tokenBal,rate),tokenPrice);\\n\\n                return contractVal.add(collateralVal);\\n\\n            }\\n        \\n        }\\n\\n    }\\n\\n\\n    // ------------ DEPOSIT FUNCTION -------------- //\\n    /**\\n     * @notice Allows users to supply any asset in the portfolio for Trend Tokens\\n     * @dev Rewards for supplying assets the Trend Token desires, fees for supplying other assets\\n     */\\n\\n\\n    /**\\n     * @notice Sends referralReward% of protocolFeePerc to referral and referralReward% to referrer\\n     */\\n    function distributeReferralReward(IERC20 _token, uint _sellAmtBEP20, uint _protocolFeePerc, address payable referrer) internal {\\n        \\n        uint totalProtocolFeeAmt = Lib.getValue(_sellAmtBEP20,_protocolFeePerc);\\n        uint distributeAmount = Lib.getValue(totalProtocolFeeAmt,referralReward);\\n\\n        if (_token == wbnb) {\\n\\n            msg.sender.transfer(distributeAmount); \\n            referrer.transfer(distributeAmount); \\n\\n        } else {\\n\\n            _token.safeTransfer(msg.sender, distributeAmount); \\n            _token.safeTransfer(referrer, distributeAmount); \\n\\n\\n        }\\n\\n    }\\n\\n\\n    /**\\n     * @notice Calculates the fees and trend token amounts out upon deposit\\n     * @dev Calls the Incentive Model contract to fetch base protocol fee and fee/reward incentive\\n     */\\n    function trendTokenOutCalculations(IERC20 _depositBep20, IVBep20 _dToken, uint _sellAmtBEP20) \\n        internal view returns(uint price, uint trendTokenPrice, uint mintMBNB, uint trendTokenAmt, uint protocolFeePerc, int feeOrReward)  {\\n\\n        (int priorDelta, int postDelta, uint priceToken, uint equity) = tokenInfo(_dToken,_sellAmtBEP20,0);\\n        uint inValue = Lib.getValue(_sellAmtBEP20,priceToken);\\n        equity = equity.sub(inValue); // equityprior\\n\\n        (feeOrReward, protocolFeePerc,,) = incentiveModel.totalDepositFee(_depositBep20, inValue, priorDelta, postDelta, priceToken, xtt.balanceOf(msg.sender)); \\n        uint inValueMinusFees = Lib.getValue(inValue, uint(int(1e18).sub(feeOrReward)));\\n\\n        (trendTokenPrice, mintMBNB) = trendTokenToUSD(equity); \\n        trendTokenAmt = Lib.getAssetAmt(inValueMinusFees,trendTokenPrice);\\n        price = priceToken;\\n\\n    }\\n\\n\\n    /**\\n     * @notice Allows the deposit of BNB/BEP20 for Trend Tokens\\n     * @dev Keeps protocolFeePerc in Pool (no longer sent to admin)\\n     */\\n    function depositFresh(IERC20 _depositBep20, uint _sellAmtBEP20, uint _minTrendTokenOut, address payable _referrer) internal pausedTrendToken returns(uint)  {\\n        \\n        // Requirements\\n        compTT.depositOrRedeemAllowed(address(this),_sellAmtBEP20); // above zero, unpaused, trend token active\\n        IVBep20 dToken = IVBep20(compTT.returnDToken(address(_depositBep20)));\\n        require(!depositsDisabled[address(_depositBep20)], \\\"deposits disabled\\\");  // checks deposits arent disabled\\n        checkActiveToken(dToken); // checks this Trend Token is an enabled dToken\\n\\n        // Calculate prices, fees, and amounts\\n        (uint priceToken,\\n        uint trendTokenPrice,, \\n        uint trendTokenAmt, \\n        uint protocolFeePerc, \\n        int feeOrReward) = trendTokenOutCalculations(_depositBep20, dToken, _sellAmtBEP20);\\n\\n        // Send fees and Trend Token to user\\n        //sendPerformanceFee(mintTrendTokenAmt,trendTokenPrice); // MAYBE REMOVE FOR TAX REASONS? \\n        require(trendTokenAmt \\u003e= _minTrendTokenOut,\\\"!minOut\\\");\\n        trendToken.mint(msg.sender, trendTokenAmt);// mint and send Margin Token to Trader (after fees)\\n\\n        // Require max supply isnt exceeded\\n        uint supplyTrendToken = trendToken.totalSupply();\\n        require(supplyTrendToken \\u003c= maxSupply,\\\"!maxSupply.\\\");\\n\\n        // Sends 40/40 of protocolFeePerc to referrer/referral instead of going to Pool\\n        if (_referrer != address(0)) {\\n            distributeReferralReward(_depositBep20, _sellAmtBEP20, protocolFeePerc, _referrer);\\n        }\\n\\n        emit Deposit(priceToken, trendTokenPrice, supplyTrendToken, protocolFeePerc, feeOrReward);\\n\\n        return trendTokenAmt;\\n\\n    }\\n\\n\\n    /**\\n    *   Payable function for buying Trend Tokens with BNB\\n    */\\n    function depositBNB(uint _minTrendTokenOut, uint _deadline, address payable _referrer) external nonReentrant ensureDeadline(_deadline) payable {\\n        depositFresh(wbnb, msg.value, _minTrendTokenOut,_referrer);\\n    }\\n\\n\\n    /**\\n    *   Payable function for buying Trend Tokens with BNB\\n    */\\n    function deposit(IERC20 _depositBep20, uint _sellAmtBEP20, uint _minTrendTokenOut, address payable _referrer, uint _deadline) external nonReentrant ensureDeadline(_deadline) {\\n        uint balanceBefore = _depositBep20.balanceOf(address(this));\\n        _depositBep20.safeTransferFrom(msg.sender, address(this), _sellAmtBEP20);\\n        uint balanceAfter = _depositBep20.balanceOf(address(this));\\n        uint actualTransferredAmount = balanceAfter.sub(balanceBefore);\\n        depositFresh(_depositBep20, actualTransferredAmount,_minTrendTokenOut,_referrer);\\n    }\\n\\n\\n    // --- REDEEM FUNCTIONS  --- //\\n    /**\\n     * @notice Allows users to redeem Trend Tokens for any underlying asset, if it has a sufficient balance\\n     * @dev Rewards for redeeming assets the Trend Token does not want, fees for redeeming other assets\\n     */\\n\\n\\n    /**\\n     * @notice Sends underlying to user after depositing Trend Tokens\\n     * @dev Redeems from Dual Pools if contract balance isnt great enough\\n     *      Amount is updated as exact amount redeemed may vary from _amount\\n     */\\n    function sendUnderlyingOut(IERC20 _underlying, IVBep20 _dToken, uint _amount) internal {\\n        //require(_amount \\u003c= contractBal(_dToken),\\\"insufficent bal\\\");\\n        requireUnderAmount(_amount,contractBal(_dToken),\\\"insufficent bal\\\");\\n\\n        if (_underlying == wbnb) {\\n\\n            msg.sender.transfer(_amount); \\n\\n        } else {\\n\\n            _underlying.safeTransfer(msg.sender, _amount); \\n\\n        }\\n    }\\n\\n\\n    /**\\n     * @notice Calculates the amount of underlying to send to manager after deposit of Trend Tokens\\n     * @dev Takes into account the redeem fee calculation from incentive model\\n     */\\n    function trendTokenInCalculations(IERC20 _redeemBep20, IVBep20 _dToken, uint _redeemAmt) \\n        internal view returns(uint price, uint trendTokenPrice, uint mintMBNB, uint trendTokenInAmt, uint protocolFeePerc, int feeOrReward)  {\\n\\n        (int priorDelta, int postDelta, uint priceToken, uint equity) = tokenInfo(_dToken,0,_redeemAmt);\\n        uint outValueEst = Lib.getValue(_redeemAmt,priceToken); // 1 * $1 = $1\\n\\n        (feeOrReward, protocolFeePerc,,) = incentiveModel.totalRedeemFee(_redeemBep20, outValueEst, priorDelta, postDelta, priceToken, xtt.balanceOf(msg.sender));\\n        uint outValueAddFees = Lib.getValue(outValueEst, uint(int(1e18).add(feeOrReward))); // $1 * 1-0.0035 = 0.9965\\n\\n        (trendTokenPrice, mintMBNB) = trendTokenToUSD(equity);  // 1.002\\n        trendTokenInAmt = Lib.getAssetAmt(outValueAddFees,trendTokenPrice); // $10, assume Trend price is $2\\n        price = priceToken;\\n\\n    }\\n\\n\\n    /**\\n     * @notice Allows for the deposit of Trend Tokens to redeem an underlying asset of redeemers choice\\n     * @param _redeemBep20 The token the redeemer wishes to redeem\\n     * @param _redeemAmt The amount of underlying to be redeemed\\n     * @return The amount of underlying sent to redeemer\\n     */\\n    function redeemFresh(IERC20 _redeemBep20, uint _redeemAmt, uint _maxTrendTokenIn) internal pausedTrendToken returns(uint) { // change back to external\\n        \\n        // Requirements\\n        compTT.depositOrRedeemAllowed(address(this), _redeemAmt); // above zero, unpaused, trend token listed\\n        IVBep20 dToken = IVBep20(compTT.returnDToken(address(_redeemBep20))); \\n        checkActiveToken(dToken); // checks this Trend Token enabled dToken (must be listed)\\n\\n        (uint price, \\n        uint trendTokenPrice,, \\n        uint trendTokenInAmt, \\n        uint protocolFeePerc, \\n        int feeOrReward) = trendTokenInCalculations(_redeemBep20, dToken, _redeemAmt);\\n\\n        // Receive Trend Tokens and send Performance Fee\\n        //require(trendTokenInAmt \\u003c= _maxTrendTokenIn, \\\"!maxIn\\\");\\n        requireUnderAmount(trendTokenInAmt,_maxTrendTokenIn,\\\"!maxIn\\\");\\n        trendToken.transfersFrom(msg.sender, address(this), trendTokenInAmt); \\n\\n        // Add Trend Tokens to rerve and burn the rest\\n        uint trendTokenFee = Lib.getValue(trendTokenInAmt,protocolFeePerc);\\n        uint trendTokenToReservesPerc = Lib.getValue(trendTokenFee,uint(1e18).sub(trendTokenRedeemBurn));\\n        trendToken.burn(trendTokenInAmt.sub(trendTokenToReservesPerc));\\n\\n        // Redeem and send underlying\\n        sendUnderlyingOut(_redeemBep20, dToken, _redeemAmt);\\n\\n        // Events\\n        emit Redeem(price, trendTokenPrice, trendToken.totalSupply(), protocolFeePerc, feeOrReward,trendTokenFee);\\n\\n        return trendTokenInAmt;\\n\\n    }\\n\\n\\n    /**\\n     * @notice External function redeemer interacts with to redeem Trend Tokens\\n     * @dev Disabled if Trend Token is paused\\n     */\\n    function redeem(IERC20 _redeemBep20, uint _redeemAmt, uint _maxTrendTokenIn, uint _deadline) external nonReentrant  ensureDeadline(_deadline) {\\n        redeemFresh(_redeemBep20, _redeemAmt, _maxTrendTokenIn);\\n    }\\n\\n\\n    // --------------- TRADE FUNCTIONALITY ----------------- // \\n\\n    /**\\n     * @notice Calculates the value of underlying to send back to the user\\n     */\\n    function tradeInfo(IERC20[] memory tokenInOut, IVBep20[] memory dTokensInOut, uint valueIn) internal view returns(uint valOutAfterBuy)  {\\n\\n        (address[] memory dTokens,, // dToken (not underlying)\\n        uint[] memory conVals,\\n        uint[] memory colVals,\\n        uint netEquity) = storedEquity();\\n\\n        require(netEquity\\u003e0 \\u0026\\u0026 address(dTokensInOut[0]) != address(0) \\u0026\\u0026 address(dTokensInOut[1]) != address(0) \\u0026\\u0026\\n               dTokensInOut[0] != dTokensInOut[1] \\u0026\\u0026  tokenInOut.length == 2, \\\"equity !\\u003e 0\\\");\\n\\n        int[] memory priorPostDeltaIn = new int[](2);\\n        int[] memory priorPostDeltaOut = new int[](2);\\n        uint[] memory tokenEquityInOut = new uint[](2);\\n        uint[] memory desiredAllos = new uint[](2);\\n\\n        for (uint i=0; i \\u003c dTokens.length; i++) {\\n\\n            if (IVBep20(dTokens[i]) == dTokensInOut[0]) { // dTokenIn: sell\\n\\n                tokenEquityInOut[0] = conVals[i].add(colVals[i]);\\n                desiredAllos[0] = desiredAllocations[i];\\n\\n            } else if (IVBep20(dTokens[i]) == dTokensInOut[1]) { // dTokenOut: buy\\n\\n                tokenEquityInOut[1] = conVals[i].add(colVals[i]);\\n                desiredAllos[1] = desiredAllocations[i];\\n                \\n            }\\n        \\n        }\\n\\n        uint equityAfterSell = netEquity.add(valueIn); // 30 + 1 = 31\\n        priorPostDeltaIn[0] = int(desiredAllos[0]).sub(int(Lib.getAssetAmt(tokenEquityInOut[0],netEquity))); // 1 - 13/30 = 56%\\n        priorPostDeltaIn[1] = int(desiredAllos[0]).sub(int(Lib.getAssetAmt(tokenEquityInOut[0].add(valueIn),equityAfterSell))); // 1 - (13+1)/ 31 = 54%\\n\\n                                                            // BNB, 1000000000000000000, 560000000000000000, 530000000000000000, 10000000000000000000000000\\n                                                            // output ==\\u003e 1000000000000000000\\n        uint valAfterSell = incentiveModel.valueOutAfterSell(tokenInOut[0], valueIn, priorPostDeltaIn[0], priorPostDeltaIn[1], xtt.balanceOf(msg.sender));\\n\\n        priorPostDeltaOut[0] = int(desiredAllos[1]).sub(int(Lib.getAssetAmt(tokenEquityInOut[1],equityAfterSell))); // 0 - 17/31 = -55%\\n        priorPostDeltaOut[1] = int(desiredAllos[1]).sub(int(Lib.getAssetAmt(tokenEquityInOut[1].sub(valAfterSell),equityAfterSell.sub(valAfterSell)))); // 0 - (17-1)/(31-1) = -47%\\n        \\n                                                            // BUSD, 1000000000000000000, -550000000000000000, -470000000000000000\\n        valOutAfterBuy = incentiveModel.valueOutAfterBuy(tokenInOut[1], valAfterSell, priorPostDeltaOut[0], priorPostDeltaOut[1]);\\n\\n    }\\n\\n    \\n    /**\\n     * @notice Executes desired trade\\n     * @param tokenInOut List of [tokenSell, tokenBuy]\\n     * @param sellAmt The amount of tokenSell to sell\\n     */\\n    function executeTrade(IERC20[] memory tokenInOut, uint sellAmt, uint _minOut, uint _deadline) internal pausedTrendToken  ensureDeadline(_deadline) {\\n        compTT.tradeAllowed(address(this), sellAmt); \\n        \\n        IVBep20[] memory dTokensInOut = new IVBep20[](2);\\n        dTokensInOut[0] = IVBep20(compTT.returnDToken(address(tokenInOut[0]))); \\n        dTokensInOut[1] = IVBep20(compTT.returnDToken(address(tokenInOut[1]))); \\n\\n        uint valueIn = Lib.getValue(sellAmt,priceBEP20(dTokensInOut[0]));\\n        uint valOutAfterBuy = tradeInfo(tokenInOut,dTokensInOut,valueIn);\\n        uint outUnderlying = Lib.getAssetAmt(valOutAfterBuy,priceBEP20(dTokensInOut[1]));\\n        require(outUnderlying \\u003e= _minOut,\\\"!minOut\\\");\\n        \\n        sendUnderlyingOut(tokenInOut[1], dTokensInOut[1], outUnderlying);\\n\\n        emit ExecuteTrade(sellAmt, valueIn, valOutAfterBuy, outUnderlying);\\n    }\\n\\n    /**\\n     * @notice Allows user to swap one underlying (BUSD) for another (BTCB)\\n     */\\n    function swapExactTokensForTokens(uint sellAmt, uint minOut, IERC20[] calldata tokenInOut, uint _deadline) external nonReentrant {\\n        tokenInOut[0].safeTransferFrom(msg.sender, address(this), sellAmt);\\n        executeTrade(tokenInOut,sellAmt,minOut,_deadline);\\n    }\\n\\n\\n    /**\\n     * @notice Allows user to swap BNB for an underlying (BUSD)\\n     */\\n    function swapExactETHForTokens(uint minOut, IERC20[] calldata tokenInOut, uint _deadline) external nonReentrant payable {\\n        require(tokenInOut[0] == wbnb, \\\"input must be BNB\\\");\\n        executeTrade(tokenInOut,msg.value,minOut,_deadline);\\n    }\\n\\n\\n    // ----------------- SUPPLY REBLANCE ------------------- //\\n    /**\\n     * @notice Allows the public to supply or redeem portfolio tokens according to contractFactor\\n     */\\n\\n\\n    /**\\n     * @notice Returns the underlying token for inputted dToken\\n     * @dev If dToken is dBNB then wbnb will be returned\\n     */\\n    function returnUnderlying(IVBep20 dToken) internal view returns(IERC20 addr) {\\n        addr = wbnb;\\n        if (dToken != dBNB) {\\n            addr = IERC20(dToken.underlying());\\n        }\\n    }\\n\\n\\n    /**\\n     * @notice Supplies or redeems dToken according to contractFactor\\n     * @dev If dToken is not in dTokens, it will be skipped\\n     * @param dToken The dToken to be supplied/redeemed\\n     * @param _contractFactor The percentage of token equity desired to be in contract (not supplied)\\n     */\\n    function singleSupplyAndRedeemRebalance(IVBep20 dToken, uint _contractFactor) internal {\\n\\n        (address[] memory dTokens,\\n        uint[] memory prices,\\n        uint[] memory conVals,\\n        uint[] memory colVals,) = storedEquity();\\n\\n        for (uint i=0; i \\u003c dTokens.length; i++) {\\n\\n            if (address(dToken) == dTokens[i]) {\\n\\n                uint tokenEquity = conVals[i].add(colVals[i]);\\n\\n                if (tokenEquity \\u003e 0) {\\n\\n                    IERC20 underlying = returnUnderlying(dToken);\\n                    uint currentContractFactor = Lib.getAssetAmt(conVals[i], tokenEquity);\\n\\n                    // requires supplying (too much contract balance) \\n                    if (currentContractFactor \\u003e _contractFactor) {\\n\\n                        uint supplyDelta = currentContractFactor.sub(_contractFactor);\\n                        uint supplyValue = Lib.getValue(supplyDelta, tokenEquity);\\n                        uint supplyAmt = Lib.getAssetAmt(supplyValue,prices[i]);\\n                        collateralSupply(underlying, dToken, supplyAmt); \\n\\n\\n                    } \\n\\n                    // requires redeeming (not enough contract balance)\\n                    else if (currentContractFactor \\u003c _contractFactor) {\\n\\n                        uint redeemDelta = _contractFactor.sub(currentContractFactor);\\n                        uint redeemValue = Lib.getValue(redeemDelta,tokenEquity);\\n                        uint redeemAmt = Lib.getAssetAmt(redeemValue,prices[i]);\\n                        collateralRedeem(underlying, dToken, redeemAmt); \\n\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n\\n\\n    /** \\n     * @notice Allows the public to rebalance borrows\\n     * @dev Repays or borrows assets as needed, may redeem if required\\n     * input _tokens List of underlying tokens to rebalance\\n     */\\n    function publicSupplyAndRedeemRebalance(address[] calldata _tokens) external pausedTrendToken {\\n\\n        bool allowedDualPools = compTT.trendTokenAllowedDualPools(address(this));\\n\\n        if (!allowedDualPools) {\\n            setContractFactor(1e18);\\n        }\\n\\n        for (uint i=0; i \\u003c _tokens.length; i++) {\\n            IVBep20 dToken = IVBep20(compTT.returnDToken(address(_tokens[i])));\\n            require(tokenEntered(dToken), \\\"!entered\\\");\\n            singleSupplyAndRedeemRebalance(dToken, contractFactor);\\n        }\\n    }\\n    \\n\\n\\n}\\n\\n\"},\"TrendTokenStorage.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.5.16;\\n\\nimport \\\"./ITrendTokenTkn.sol\\\";\\nimport \\\"./XTTgov.sol\\\";\\nimport \\\"./ICompTT.sol\\\";\\nimport \\\"./IIncentiveModelSimple.sol\\\";\\n\\n\\ncontract TrendTokenStorage {\\n\\n\\n    // --------------- EVENTS ----------- // \\n    \\n\\n    /**\\n     * @notice Emitted when Trend Token redeemed for underlying\\n     */\\n    event Redeem(uint tokenPrice, uint trendTokenPrice, uint supplyTrendToken, uint protocolFeePerc, int feeOrReward, uint addTrendTokenAmt);\\n\\n\\n    /**\\n     * @notice Emitted when Trend Token deposited for underlying\\n     */\\n    event Deposit(uint tokenPrice, uint trendTokenPrice, uint supplyTrendToken, uint protocolFeePerc, int feeOrReward);\\n\\n\\n    /**\\n     * @notice Emitted when Trend Token price makes new all time high and performance fee charged\\n     */\\n    event PerformanceFee(uint trendTokenStart, uint oldTrendTokenATH, uint newTrendTokenATH, uint addTrendTokenAmt);\\n\\n\\n    /**\\n     * @notice Emitted when contract addresses changed\\n     */\\n    event NewIncentiveModel(address oldIncentiveModel, address newIncentiveModel);\\n    event NewCompTT(address oldCompTT, address newCompTT);\\n    event NewCompDP(address oldCompDP, address newCompDP);\\n\\n    /**\\n     * @notice Emitted when wallet addresses changed\\n     */\\n    event NewManager(address oldManager, address newManager);\\n    event NewFeeRecipient(address oldFeeRecipient, address newFeeRecipient);\\n    event NewTradingBot(address oldTradingBot, address newTradingBot);\\n\\n    /**\\n     * @notice Emitted when performance fee changed\\n     */\\n    event NewPerformanceFee(uint oldFee, uint newFee);\\n\\n    /**\\n     * @notice Emitted when fee distribution changed\\n     */\\n    event UpdateTrendTokenBurn(uint oldTrendToken,uint newTrendToken);\\n\\n\\n    /**\\n     * @notice Emitted when max disable value changed\\n     */\\n    event MaxDisableValue(uint oldValue, uint newValue);\\n\\n\\n    /**\\n     * @notice Emitted when max supply changed\\n     */\\n    event SetMaxSupply(uint oldSupply, uint newSupply);\\n\\n\\n    /**\\n     * @notice Emitted when contract factor changed\\n     */\\n    event SetContractFactor(uint oldFactor, uint newFactor); \\n\\n    /**\\n     * @notice Emitted deposits are disable\\n     */\\n    event DepositsDisabled(address underlying, bool oldState, bool newState);\\n\\n    /**\\n     * @notice Emitted when Trend Token is paused\\n     */\\n    event PauseTrendToken(bool oldState, bool newState);   \\n\\n    /**\\n     * @notice Emitted when allocations changed, as well as when enabling or disabling tokens\\n     */\\n    event SetDesiredAllocationsFresh(address[] portfolio, uint[] oldAllocations, uint[] newAllocations);\\n\\n    /**\\n     * @notice Emitted when a trade is executed\\n     */\\n    event ExecuteTrade(uint amountIn, uint valueIn, uint valueOut, uint amountOut);\\n\\n    /**\\n     * @notice Emitted when locked state changes\\n     */\\n    event Locked(bool oldState, bool newState);\\n\\n    /**\\n     * @notice Emited when setting new referral reward\\n     */\\n    event SetReferralReward(uint oldReward, uint newReward);\\n\\n    // --------------- ADMIN ADJUSTABLE VARIABLES ----------- // \\n\\n    /**\\n     * @dev Guard variable for re-entrancy checks\\n     */\\n    bool internal _notEntered; \\n\\n\\n    /**\\n     * @notice Will redeem assets from Dual Pools if percentage of token equity in contract falls below this value\\n     * @dev This keeps a float of assets in the contract for low gas cost Trend Token deposits and redeems\\n     */\\n    uint public contractFactor = 1e18; // default none held as collateral\\n\\n\\n    /**\\n     * @notice Sets the desired allocations of the portfolio \\n     * @dev Allocations are in percents relative to equity\\n     */\\n    uint[] public desiredAllocations;\\n\\n\\n    /**\\n     * @notice Prevents users from minting Trend Tokens beyond this limit\\n     * @dev Manager is able to adjust this value\\n     */\\n    uint public maxSupply = 10000e18;\\n\\n\\n    /**\\n     * @notice The managers wallet who has special access of Trend Token\\n     * @dev Access includes fees, factors, change managers, etc\\n     */\\n    address public manager; \\n\\n    /**\\n     * @notice The trading bot wallet who has special access of Trend Token\\n     * @dev Access includes portfolios, allocations, and dual pool actions (except trading)\\n     */\\n    address public tradingBot; \\n\\n\\n    /**\\n     * @notice Wallet that can receive deposit fees, reserves, and XTT\\n     */\\n    address payable public feeRecipient;\\n\\n\\n    /**\\n     * @notice The deposit and redeem incentive model\\n     */\\n    IIncentiveModelSimple public incentiveModel;\\n\\n\\n    /**\\n     * @notice Allows manager to pause Trend Token\\n     * @dev Prevents deposits, withdrawals, and borrow rebalances\\n     */\\n    bool public trendTokenPaused = false;\\n\\n\\n    /**\\n     * @notice Reward for referrer and referrer upon purchase of Trend Token\\n     */\\n    uint public referralReward = 0.40e18;\\n\\n\\n    /**\\n     * @notice Percentage of Trend Token price all tiem high gains that goes to fee recipient\\n     */\\n    uint public performanceFee = 0.10e18;\\n\\n\\n    /**\\n     * @notice Percentage of trend tokens fees from redeems that are burned (increase price\\n     * @dev Increases the price of Trend Tokens\\n     */\\n    uint public trendTokenRedeemBurn = 0.50e18;\\n\\n\\n    /**\\n     * @notice Minimum position value allowed to disable token\\n     * @dev Disabling a token with a large balance would result in trend token price drop\\n     */\\n    uint public maxDisableTokenValue = 1e18;\\n\\n\\n    /**\\n     * @notice Allows trading bot to lock some actions from the Manager\\n     * @dev An extra layer of security\\n     */\\n\\n    bool locked = true;\\n    \\n\\n    // --------------- TOKEN VARIABLES ----------- // \\n\\n    /**\\n     * @notice CompTT ensures this variable is true before supporting a Trend Token\\n     */\\n    bool public constant isTrendToken = true;\\n\\n\\n    /**\\n     * @notice The Trend Token contract address\\n     */\\n    ITrendTokenTkn public trendToken;\\n\\n\\n    /**\\n     * @notice Address for Trend Tokens XTT Utility Token\\n     * @dev Distributed when users hold Trend Tokens in Vaults\\n     *      PancakeSwap XTT-BNB pair created\\n     */\\n    IXTT public xtt = IXTT(0x6e568e89Dc8c68ca3f6d918f30c75A081a14C06E); \\n    \\n    \\n    /** note: \\n     * @notice Address for Dual Pools XDP Utility token\\n     * @dev Earned by Trend Tokens when they borrow/supply to Dual Pools\\n     *      PancakeSwap XDP-BNB pair created\\n     */\\n    IERC20 public xdp = IERC20(0xD49a93d991ACE4bEf0A7f9F665E38e902110f4C1);//IERC20(0xf79c28eB5bd0cC10B58F04DfF7c34d0c8D39BdE6);\\n\\n\\n    // ----------------- FEES AND RESERVES -------------------- // \\n\\n\\n    /**\\n     * @notice Value keeps track of the Trend Token price all time high\\n     * @dev Any gains above this are subject to performance fee\\n     */\\n    uint public trendTokenATH = 1e18; \\n\\n\\n    /**\\n     * @notice Prevents deposits of this token\\n     */\\n    mapping(address =\\u003e bool) public depositsDisabled;\\n\\n\\n\\n}\\n\\n\\n\"},\"TrendTokenTkn.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.5.16;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./ERC20Detailed.sol\\\";\\nimport \\\"./ITrendTokenTkn.sol\\\";\\n\\n/**\\n * @title SimpleToken\\n * @dev Very simple ERC20 Token example, where all tokens are pre-assigned to the creator.\\n * Note they can later distribute these tokens as they wish using `transfer` and other\\n * `ERC20` functions.\\n */\\ncontract TrendTokenTkn is ERC20, ERC20Detailed {\\n    \\n    uint8 public constant DECIMALS = 18;\\n    address public minter;\\n\\n\\n    constructor (string memory _tokenName, string memory _symbol) public ERC20Detailed(_tokenName, _symbol, DECIMALS) {\\n        minter = msg.sender;\\n    }\\n\\n    modifier requireMinter() {\\n        require(msg.sender == minter, \\\"!minter\\\");\\n        _;\\n    } \\n\\n    // ------- remove on mainnet -------- // \\n\\n    function mint(address _recipient, uint256 _amount) external requireMinter {\\n        _mint(_recipient, _amount);\\n    }\\n\\n    function burn(uint256 _amount) external {\\n        _burn(msg.sender, _amount);\\n    }\\n\\n    function transfersFrom(address sender, address recipient, uint256 amount) external returns(bool) {\\n        require(allowance(sender, recipient) \\u003e= amount, \\\"insufficent Trend Token allowance\\\");\\n        require(balanceOf(sender) \\u003e= amount,\\\"insufficent Trend Token balance\\\");\\n        return transferFrom(sender, recipient, amount);\\n    }\\n}\\n\\n\"},\"UniTT.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.5.16;\\n\\nimport \\\"./CompStorageTT.sol\\\";\\n\\n\\n/**\\n * @title ComptrollerCore\\n * @dev Storage for the comptroller is at this address, while execution is delegated to the `comptrollerImplementation`.\\n * VTokens should reference this contract as their comptroller.\\n */\\ncontract Unitroller is UnitrollerAdminStorage {\\n\\n    /**\\n      * @notice Emitted when pendingComptrollerImplementation is changed\\n      */\\n    event NewPendingImplementation(address oldPendingImplementation, address newPendingImplementation);\\n\\n    /**\\n      * @notice Emitted when pendingComptrollerImplementation is accepted, which means comptroller implementation is updated\\n      */\\n    event NewImplementation(address oldImplementation, address newImplementation);\\n\\n    /**\\n      * @notice Emitted when pendingAdmin is changed\\n      */\\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\\n\\n    /**\\n      * @notice Emitted when pendingAdmin is accepted, which means admin is updated\\n      */\\n    event NewAdmin(address oldAdmin, address newAdmin);\\n\\n    constructor() public {\\n        // Set admin to caller\\n        admin = msg.sender;\\n    }\\n\\n    /*** Admin Functions ***/\\n    function _setPendingImplementation(address newPendingImplementation) public  {\\n\\n        require(msg.sender == admin, \\\"must be admin\\\");\\n\\n        address oldPendingImplementation = pendingComptrollerImplementation;\\n\\n        pendingComptrollerImplementation = newPendingImplementation;\\n\\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\\n\\n    }\\n\\n    /**\\n    * @notice Accepts new implementation of comptroller. msg.sender must be pendingImplementation\\n    * @dev Admin function for new implementation to accept it\\u0027s role as implementation\\n    * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n    */\\n    function _acceptImplementation() public returns (uint) {\\n        // Check caller is pendingImplementation and pendingImplementation \u2260 address(0)\\n        require(msg.sender == pendingComptrollerImplementation \\u0026\\u0026 pendingComptrollerImplementation != address(0),\\n                \\\"!_acceptImplementation\\\");\\n\\n        // Save current values for inclusion in log\\n        address oldImplementation = comptrollerImplementation;\\n        address oldPendingImplementation = pendingComptrollerImplementation;\\n\\n        comptrollerImplementation = pendingComptrollerImplementation;\\n\\n        pendingComptrollerImplementation = address(0);\\n\\n        emit NewImplementation(oldImplementation, comptrollerImplementation);\\n        emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\\n\\n\\n    }\\n\\n\\n    /**\\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\\n      * @param newPendingAdmin New pending admin.\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _setPendingAdmin(address newPendingAdmin) public  {\\n        // Check caller = admin\\n        require(msg.sender == admin,\\\"!setPendingAdmin\\\");\\n\\n        // Save current value, if any, for inclusion in log\\n        address oldPendingAdmin = pendingAdmin;\\n\\n        // Store pendingAdmin with value newPendingAdmin\\n        pendingAdmin = newPendingAdmin;\\n\\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\\n\\n    }\\n\\n    /**\\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\\n      * @dev Admin function for pending admin to accept role and update admin\\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\\n      */\\n    function _acceptAdmin() public {\\n        // Check caller is pendingAdmin\\n        require(msg.sender == pendingAdmin,\\\"!acceptAdmin\\\");\\n\\n        // Save current values for inclusion in log\\n        address oldAdmin = admin;\\n        address oldPendingAdmin = pendingAdmin;\\n\\n        // Store admin with value pendingAdmin\\n        admin = pendingAdmin;\\n\\n        // Clear the pending value\\n        pendingAdmin = address(0);\\n\\n        emit NewAdmin(oldAdmin, admin);\\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\\n\\n    }\\n\\n    /**\\n     * @dev Delegates execution to an implementation contract.\\n     * It returns to the external caller whatever the implementation returns\\n     * or forwards reverts.\\n     */\\n    function () external payable {\\n        // delegate all other functions to current implementation\\n        (bool success, ) = comptrollerImplementation.delegatecall(msg.data);\\n\\n        assembly {\\n              let free_mem_ptr := mload(0x40)\\n              returndatacopy(free_mem_ptr, 0, returndatasize)\\n\\n              switch success\\n              case 0 { revert(free_mem_ptr, returndatasize) }\\n              default { return(free_mem_ptr, returndatasize) }\\n        }\\n    }\\n}\"},\"XTTgov.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.5.16;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./IXTT.sol\\\";\\n\\n\\n// Copyright 2020 Venus Labs, Inc.\\n\\n// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\\n\\n// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\\n// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\\n// 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\\n\\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A \\n// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, \\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, \\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\\n\\n/**\\n * changes: added burn function\\n */\\ncontract Owned {\\n\\n    using SafeMath for uint;\\n\\n    address public owner;\\n\\n    event OwnershipTransferred(address indexed _from, address indexed _to);\\n\\n    constructor() public {\\n        owner = msg.sender;\\n    }\\n\\n    modifier onlyOwner {\\n        require(msg.sender == owner, \\\"Should be owner\\\");\\n        _;\\n    }\\n\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        owner = newOwner;\\n        emit OwnershipTransferred(owner, newOwner);\\n    }\\n}\\n\\ncontract Tokenlock is Owned {\\n    /// @notice Indicates if token is locked\\n    uint8 isLocked = 0;\\n\\n    event Freezed();\\n    event UnFreezed();\\n\\n    modifier validLock {\\n        require(isLocked == 0, \\\"Token is locked\\\");\\n        _;\\n    }\\n\\n    function freeze() public onlyOwner {\\n        isLocked = 1;\\n\\n        emit Freezed();\\n    }\\n\\n    function unfreeze() public onlyOwner {\\n        isLocked = 0;\\n\\n        emit UnFreezed();\\n    }\\n}\\n\\ncontract XTT is Tokenlock {\\n    /// @notice BEP-20 token name for this token\\n    string public constant name = \\\"TrendToken Utility\\\";\\n\\n    /// @notice BEP-20 token symbol for this token\\n    string public constant symbol = \\\"XTT\\\";\\n\\n    /// @notice BEP-20 token decimals for this token\\n    uint8 public constant decimals = 18;\\n\\n    /// @notice Total number of tokens in circulation\\n    uint public totalSupply = 10000000e18; // 30 million XVS\\n\\n    /// @notice Allowance amounts on behalf of others\\n    mapping (address =\\u003e mapping (address =\\u003e uint96)) internal allowances;\\n\\n    /// @notice Official record of token balances for each account\\n    mapping (address =\\u003e uint96) internal balances;\\n\\n    /// @notice A record of each accounts delegate\\n    mapping (address =\\u003e address) public delegates;\\n\\n    /// @notice A checkpoint for marking number of votes from a given block\\n    struct Checkpoint {\\n        uint32 fromBlock;\\n        uint96 votes;\\n    }\\n\\n    /// @notice A record of votes checkpoints for each account, by index\\n    mapping (address =\\u003e mapping (uint32 =\\u003e Checkpoint)) public checkpoints;\\n\\n    /// @notice The number of checkpoints for each account\\n    mapping (address =\\u003e uint32) public numCheckpoints;\\n\\n    /// @notice The EIP-712 typehash for the contract\\u0027s domain\\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\");\\n\\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\\\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\\\");\\n\\n    /// @notice A record of states for signing / validating signatures\\n    mapping (address =\\u003e uint) public nonces;\\n\\n    /// @notice An event thats emitted when an account changes its delegate\\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\\n\\n    /// @notice An event thats emitted when a delegate account\\u0027s vote balance changes\\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\\n\\n    /// @notice The standard BEP-20 transfer event\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    /// @notice The standard BEP-20 approval event\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /**\\n     * @notice Construct a new XVS token\\n     * @param account The initial account to grant all the tokens\\n     */\\n    constructor(address account) public {\\n        balances[account] = uint96(totalSupply);\\n        emit Transfer(address(0), account, totalSupply);\\n    }\\n\\n     /**\\n     * @dev Destoys `amount` tokens from `msg.sender`, reducing the total supply.\\n     *\\n     * Emits a `Transfer` event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function burn(uint256 rawAmount) external {\\n        require(msg.sender != address(0), \\\"ERC20: burn from the zero address\\\");\\n        uint96 amount96 = safe96(rawAmount, \\\"XTT::burn: amount exceeds 96 bits\\\");\\n        totalSupply = sub256(totalSupply,rawAmount,\\\"XTT::burn: unable to decrease supply\\\");\\n        balances[msg.sender] = sub96(balances[msg.sender],amount96,\\\"XTT::burn: unable to decrease senders balance\\\");\\n        emit Transfer(msg.sender, address(0), amount96);\\n    }\\n\\n    /**\\n     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\\n     * @param account The address of the account holding the funds\\n     * @param spender The address of the account spending the funds\\n     * @return The number of tokens approved\\n     */\\n    function allowance(address account, address spender) external view returns (uint) {\\n        return allowances[account][spender];\\n    }\\n\\n    /**\\n     * @notice Approve `spender` to transfer up to `amount` from `src`\\n     * @dev This will overwrite the approval amount for `spender`\\n     * @param spender The address of the account which may transfer tokens\\n     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\\n     * @return Whether or not the approval succeeded\\n     */\\n    function approve(address spender, uint rawAmount) external validLock returns (bool) {\\n        uint96 amount;\\n        if (rawAmount == uint(-1)) {\\n            amount = uint96(-1);\\n        } else {\\n            amount = safe96(rawAmount, \\\"XDP::approve: amount exceeds 96 bits\\\");\\n        }\\n\\n        allowances[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Get the number of tokens held by the `account`\\n     * @param account The address of the account to get the balance of\\n     * @return The number of tokens held\\n     */\\n    function balanceOf(address account) external view returns (uint) {\\n        return balances[account];\\n    }\\n\\n    /**\\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\n     * @param dst The address of the destination account\\n     * @param rawAmount The number of tokens to transfer\\n     * @return Whether or not the transfer succeeded\\n     */\\n    function transfer(address dst, uint rawAmount) external validLock returns (bool) {\\n        uint96 amount = safe96(rawAmount, \\\"XDP::transfer: amount exceeds 96 bits\\\");\\n        _transferTokens(msg.sender, dst, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Transfer `amount` tokens from `src` to `dst`\\n     * @param src The address of the source account\\n     * @param dst The address of the destination account\\n     * @param rawAmount The number of tokens to transfer\\n     * @return Whether or not the transfer succeeded\\n     */\\n    function transferFrom(address src, address dst, uint rawAmount) external validLock returns (bool) {\\n        address spender = msg.sender;\\n        uint96 spenderAllowance = allowances[src][spender];\\n        uint96 amount = safe96(rawAmount, \\\"XDP::approve: amount exceeds 96 bits\\\");\\n\\n        if (spender != src \\u0026\\u0026 spenderAllowance != uint96(-1)) {\\n            uint96 newAllowance = sub96(spenderAllowance, amount, \\\"XDP::transferFrom: transfer amount exceeds spender allowance\\\");\\n            allowances[src][spender] = newAllowance;\\n\\n            emit Approval(src, spender, newAllowance);\\n        }\\n\\n        _transferTokens(src, dst, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Delegate votes from `msg.sender` to `delegatee`\\n     * @param delegatee The address to delegate votes to\\n     */\\n    function delegate(address delegatee) public validLock {\\n        return _delegate(msg.sender, delegatee);\\n    }\\n\\n    /**\\n     * @notice Delegates votes from signatory to `delegatee`\\n     * @param delegatee The address to delegate votes to\\n     * @param nonce The contract state required to match the signature\\n     * @param expiry The time at which to expire the signature\\n     * @param v The recovery byte of the signature\\n     * @param r Half of the ECDSA signature pair\\n     * @param s Half of the ECDSA signature pair\\n     */\\n    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) public validLock {\\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\\n        bytes32 digest = keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n        address signatory = ecrecover(digest, v, r, s);\\n        require(signatory != address(0), \\\"XDP::delegateBySig: invalid signature\\\");\\n        require(nonce == nonces[signatory]++, \\\"XDP::delegateBySig: invalid nonce\\\");\\n        require(now \\u003c= expiry, \\\"XDP::delegateBySig: signature expired\\\");\\n        return _delegate(signatory, delegatee);\\n    }\\n\\n    /**\\n     * @notice Gets the current votes balance for `account`\\n     * @param account The address to get votes balance\\n     * @return The number of current votes for `account`\\n     */\\n    function getCurrentVotes(address account) external view returns (uint96) {\\n        uint32 nCheckpoints = numCheckpoints[account];\\n        return nCheckpoints \\u003e 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\\n    }\\n\\n    /**\\n     * @notice Determine the prior number of votes for an account as of a block number\\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\\n     * @param account The address of the account to check\\n     * @param blockNumber The block number to get the vote balance at\\n     * @return The number of votes the account had as of the given block\\n     */\\n    function getPriorVotes(address account, uint blockNumber) public view returns (uint96) {\\n        require(blockNumber \\u003c block.number, \\\"XDP::getPriorVotes: not yet determined\\\");\\n\\n        uint32 nCheckpoints = numCheckpoints[account];\\n        if (nCheckpoints == 0) {\\n            return 0;\\n        }\\n\\n        // First check most recent balance\\n        if (checkpoints[account][nCheckpoints - 1].fromBlock \\u003c= blockNumber) {\\n            return checkpoints[account][nCheckpoints - 1].votes;\\n        }\\n\\n        // Next check implicit zero balance\\n        if (checkpoints[account][0].fromBlock \\u003e blockNumber) {\\n            return 0;\\n        }\\n\\n        uint32 lower = 0;\\n        uint32 upper = nCheckpoints - 1;\\n        while (upper \\u003e lower) {\\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\\n            Checkpoint memory cp = checkpoints[account][center];\\n            if (cp.fromBlock == blockNumber) {\\n                return cp.votes;\\n            } else if (cp.fromBlock \\u003c blockNumber) {\\n                lower = center;\\n            } else {\\n                upper = center - 1;\\n            }\\n        }\\n        return checkpoints[account][lower].votes;\\n    }\\n\\n    function _delegate(address delegator, address delegatee) internal {\\n        address currentDelegate = delegates[delegator];\\n        uint96 delegatorBalance = balances[delegator];\\n        delegates[delegator] = delegatee;\\n\\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\\n\\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\\n    }\\n\\n    function _transferTokens(address src, address dst, uint96 amount) internal {\\n        require(src != address(0), \\\"XDP::_transferTokens: cannot transfer from the zero address\\\");\\n        require(dst != address(0), \\\"XDP::_transferTokens: cannot transfer to the zero address\\\");\\n\\n        balances[src] = sub96(balances[src], amount, \\\"XDP::_transferTokens: transfer amount exceeds balance\\\");\\n        balances[dst] = add96(balances[dst], amount, \\\"XDP::_transferTokens: transfer amount overflows\\\");\\n        emit Transfer(src, dst, amount);\\n\\n        _moveDelegates(delegates[src], delegates[dst], amount);\\n    }\\n\\n    function _moveDelegates(address srcRep, address dstRep, uint96 amount) internal {\\n        if (srcRep != dstRep \\u0026\\u0026 amount \\u003e 0) {\\n            if (srcRep != address(0)) {\\n                uint32 srcRepNum = numCheckpoints[srcRep];\\n                uint96 srcRepOld = srcRepNum \\u003e 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\\n                uint96 srcRepNew = sub96(srcRepOld, amount, \\\"XDP::_moveVotes: vote amount underflows\\\");\\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\\n            }\\n\\n            if (dstRep != address(0)) {\\n                uint32 dstRepNum = numCheckpoints[dstRep];\\n                uint96 dstRepOld = dstRepNum \\u003e 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\\n                uint96 dstRepNew = add96(dstRepOld, amount, \\\"XDP::_moveVotes: vote amount overflows\\\");\\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\\n            }\\n        }\\n    }\\n\\n    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal {\\n      uint32 blockNumber = safe32(block.number, \\\"XDP::_writeCheckpoint: block number exceeds 32 bits\\\");\\n\\n      if (nCheckpoints \\u003e 0 \\u0026\\u0026 checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\\n          checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\\n      } else {\\n          checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\\n          numCheckpoints[delegatee] = nCheckpoints + 1;\\n      }\\n\\n      emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\\n    }\\n\\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\\n        require(n \\u003c 2**32, errorMessage);\\n        return uint32(n);\\n    }\\n\\n    function safe96(uint n, string memory errorMessage) internal pure returns (uint96) {\\n        require(n \\u003c 2**96, errorMessage);\\n        return uint96(n);\\n    }\\n\\n    function add96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\\n        uint96 c = a + b;\\n        require(c \\u003e= a, errorMessage);\\n        return c;\\n    }\\n\\n    function sub96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\\n        require(b \\u003c= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    function sub256(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b \\u003c= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    function getChainId() internal pure returns (uint) {\\n        uint256 chainId;\\n        assembly { chainId := chainid() }\\n        return chainId;\\n    }\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wbnb\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_compTT\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_compDP\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"trendTokenPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"supplyTrendToken\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"protocolFeePerc\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"feeOrReward\",\"type\":\"int256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"oldState\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"newState\",\"type\":\"bool\"}],\"name\":\"DepositsDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"valueIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"valueOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"name\":\"ExecuteTrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"oldState\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"newState\",\"type\":\"bool\"}],\"name\":\"Locked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"MaxDisableValue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldCompDP\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newCompDP\",\"type\":\"address\"}],\"name\":\"NewCompDP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldCompTT\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newCompTT\",\"type\":\"address\"}],\"name\":\"NewCompTT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldFeeRecipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newFeeRecipient\",\"type\":\"address\"}],\"name\":\"NewFeeRecipient\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldIncentiveModel\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newIncentiveModel\",\"type\":\"address\"}],\"name\":\"NewIncentiveModel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldManager\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"NewManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"NewPerformanceFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldTradingBot\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newTradingBot\",\"type\":\"address\"}],\"name\":\"NewTradingBot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"oldState\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"newState\",\"type\":\"bool\"}],\"name\":\"PauseTrendToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"trendTokenStart\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldTrendTokenATH\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTrendTokenATH\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"addTrendTokenAmt\",\"type\":\"uint256\"}],\"name\":\"PerformanceFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"trendTokenPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"supplyTrendToken\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"protocolFeePerc\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"feeOrReward\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"addTrendTokenAmt\",\"type\":\"uint256\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldFactor\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFactor\",\"type\":\"uint256\"}],\"name\":\"SetContractFactor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"portfolio\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"oldAllocations\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"newAllocations\",\"type\":\"uint256[]\"}],\"name\":\"SetDesiredAllocationsFresh\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSupply\",\"type\":\"uint256\"}],\"name\":\"SetMaxSupply\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldReward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newReward\",\"type\":\"uint256\"}],\"name\":\"SetReferralReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldTrendToken\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTrendToken\",\"type\":\"uint256\"}],\"name\":\"UpdateTrendTokenBurn\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_bep20\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_supplyAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_redeemAmt\",\"type\":\"uint256\"}],\"name\":\"_adjustCollateral\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_state\",\"type\":\"bool\"}],\"name\":\"_depositsDisabled\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_bep20\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_allocations\",\"type\":\"uint256[]\"}],\"name\":\"_disableToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_allocations\",\"type\":\"uint256[]\"}],\"name\":\"_enableTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxDisableTokenValue\",\"type\":\"uint256\"}],\"name\":\"_maxDisableValue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_performanceFee\",\"type\":\"uint256\"}],\"name\":\"_newPerformanceFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_pause\",\"type\":\"bool\"}],\"name\":\"_pauseTrendToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"_redeemPerformanceFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"claim\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_redeemAmountXDP\",\"type\":\"uint256\"}],\"name\":\"_redeemXDPtoRecipient\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"redeemAmtTrendToken\",\"type\":\"uint256\"}],\"name\":\"_reduceTrendTokenReservesToRecipient\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_contractFactor\",\"type\":\"uint256\"}],\"name\":\"_setContractFactor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_allocations\",\"type\":\"uint256[]\"}],\"name\":\"_setDesiredAllocations\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxSupply\",\"type\":\"uint256\"}],\"name\":\"_setMaxSupply\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_referralReward\",\"type\":\"uint256\"}],\"name\":\"_setReferralReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_compTT\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_compDP\",\"type\":\"address\"},{\"internalType\":\"contract IIncentiveModelSimple\",\"name\":\"_incentiveModel\",\"type\":\"address\"}],\"name\":\"_updateCompAndModels\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_state\",\"type\":\"bool\"}],\"name\":\"_updateLocked\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_feeRecipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tradingBot\",\"type\":\"address\"}],\"name\":\"_updateManagerRecipientAndBot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_trendTokenRedeemBurn\",\"type\":\"uint256\"}],\"name\":\"_updateTrendTokenBurn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"compDP\",\"outputs\":[{\"internalType\":\"contract ICompDP\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"compTT\",\"outputs\":[{\"internalType\":\"contract ICompTT\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dBNB\",\"outputs\":[{\"internalType\":\"contract IVBep20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_depositBep20\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_sellAmtBEP20\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minTrendTokenOut\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minTrendTokenOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"depositBNB\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"depositsDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"desiredAllocations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeRecipient\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"incentiveModel\",\"outputs\":[{\"internalType\":\"contract IIncentiveModelSimple\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isTrendToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxDisableTokenValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"performanceFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract IVBep20\",\"name\":\"_dToken\",\"type\":\"address\"}],\"name\":\"priceExt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceOracle\",\"outputs\":[{\"internalType\":\"contract IOracle\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"}],\"name\":\"publicSupplyAndRedeemRebalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_redeemBep20\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_redeemAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxTrendTokenIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"referralReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"storedEquityExternal\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minOut\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC20[]\",\"name\":\"tokenInOut\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactETHForTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sellAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minOut\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC20[]\",\"name\":\"tokenInOut\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract IVBep20\",\"name\":\"_dToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"depositAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"redeemAmt\",\"type\":\"uint256\"}],\"name\":\"tokenInfoExternal\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"tokenInOut\",\"type\":\"address[]\"},{\"internalType\":\"contract IVBep20[]\",\"name\":\"dTokensInOut\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"valueIn\",\"type\":\"uint256\"}],\"name\":\"tradeInfoExt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tradingBot\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"trendToken\",\"outputs\":[{\"internalType\":\"contract ITrendTokenTkn\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"trendTokenATH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_bep20\",\"type\":\"address\"},{\"internalType\":\"contract IVBep20\",\"name\":\"_dToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"trendTokenIn\",\"type\":\"bool\"}],\"name\":\"trendTokenExternal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"trendTokenPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"trendTokenRedeemBurn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"trendTokenToUSDext\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wbnb\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"xdp\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"xtt\",\"outputs\":[{\"internalType\":\"contract IXTT\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "TrendToken", "CompilerVersion": "v0.5.16+commit.9c3226ce", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c0000000000000000000000009b32d0649a30d61c7cea6c5b2404553f716c397c0000000000000000000000005e5e28029ef37fc97ffb763c4ac1f532bbd4c7a2", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://d9ace0a1f3b6f315abf9fb6213a5cc111f57e4d645432f3adc1accdc271df1d3"}