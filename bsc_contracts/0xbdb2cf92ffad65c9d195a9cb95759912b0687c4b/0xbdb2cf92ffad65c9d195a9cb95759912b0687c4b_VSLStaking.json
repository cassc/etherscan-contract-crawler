{"SourceCode": "// SPDX-License-Identifier: Unlicensed\r\n\r\npragma solidity 0.8.14;\r\n\r\ninterface IERC20\r\n{\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\nabstract contract Context\r\n{\r\n    function _msgSender() internal view virtual returns (address payable)\r\n    {\r\n        return payable(msg.sender);\r\n    }\r\n}\r\n\r\ncontract Ownable is Context\r\n{\r\n    address private _owner;\r\n    address private _newOwner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor()\r\n    {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        _newOwner = address(0);\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address)\r\n    {\r\n        return _owner;\r\n    }\r\n\r\n    function isOwner(address who) public view returns (bool)\r\n    {\r\n        return _owner == who;\r\n    }\r\n\r\n    modifier onlyOwner()\r\n    {\r\n        require(isOwner(_msgSender()), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner\r\n    {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        require(newOwner != _owner, \"Ownable: new owner is already the owner\");\r\n        _newOwner = newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public\r\n    {\r\n        require(_msgSender() == _newOwner);\r\n        emit OwnershipTransferred(_owner, _newOwner);\r\n        _owner = _newOwner;\r\n        _newOwner = address(0);\r\n    }\r\n\r\n    function getTime() public view returns (uint256)\r\n    {\r\n        return block.timestamp;\r\n    }\r\n\r\n    function convertToTime(uint256 _numDays, uint256 _numHours, uint256 _numMinutes, uint256 _numSeconds) public pure returns(uint256)\r\n    {\r\n        return (_numDays * 1 days) + (_numHours * 1 hours) + (_numMinutes * 1 minutes) + (_numSeconds * 1 seconds);\r\n    }\r\n}\r\n\r\ncontract Allowable is Ownable\r\n{\r\n    uint256 private allowedCount;\r\n    mapping(address => bool) private allowedContract;\r\n    mapping(uint256 => address) private allowedByID;\r\n    mapping(address => uint256) private allowedindex;\r\n\r\n    constructor() payable {}\r\n\r\n    // Use this to prevent those not on the list from accessing controlled functions on the token contract\r\n    modifier onlyAllowedContract()\r\n    {\r\n        require(isOwner(_msgSender()) || allowedContract[_msgSender()], \"caller is not an allowed contract or the owner\");\r\n        _;\r\n    }\r\n\r\n    // SECTION: Allowed Caller List (Setup for DAO or contract to control later)\r\n\r\n    function GetAllowedID(address _wallet) view external returns(uint256 allowedID)\r\n    {\r\n        return allowedindex[_wallet];\r\n    }\r\n\r\n    event AllowedContractChange(address _contractAddress, bool _allowOrNot);\r\n    function SetupAllowedContract(address _contractAddress, bool _allowOrNot) external onlyAllowedContract\r\n    {\r\n        allowedContract[_contractAddress] = _allowOrNot;\r\n        emit AllowedContractChange(_contractAddress, _allowOrNot);\r\n\r\n        // Only add the address in if it is new...\r\n        for(uint256 i = 1; i <= allowedCount; i++)\r\n        {\r\n            if(allowedByID[i] == _contractAddress) return;\r\n        }\r\n\r\n        // Would have exited by now if it was used in the past...\r\n        allowedCount++;\r\n        allowedByID[allowedCount] = _contractAddress;\r\n    }\r\n\r\n    function IsAddressInList(address _wallet) view external returns(bool addressInList)\r\n    {\r\n        addressInList = (allowedindex[_wallet] != 0) ? true : false;\r\n    }\r\n\r\n    function IsAllowed(address _wallet) view public returns(bool addressAllowed)\r\n    {\r\n        if(isOwner(_wallet)) return true;\r\n        if(allowedContract[_wallet]) return true;\r\n        return false;\r\n    }\r\n\r\n    struct Allowed\r\n    {\r\n        address account;\r\n        bool stillAllowed;\r\n    }\r\n\r\n    function GetAllAllowedAddresses() view external onlyAllowedContract returns (Allowed [] memory allowanceDetails)\r\n    {\r\n        allowanceDetails = new Allowed[](allowedCount);\r\n        uint256 elem = 0;\r\n        uint256 entries = allowedCount;\r\n        for(uint256 i = 1; i <= entries; i++)\r\n        {\r\n            allowanceDetails[elem].account = allowedByID[i];\r\n            allowanceDetails[elem].stillAllowed = allowedContract[allowedByID[i]];\r\n            elem++;\r\n        }\r\n        return allowanceDetails;\r\n    }\r\n\r\n    // SECTION: BNB Transfers...\r\n\r\n    // Used to get BNB from the contract...\r\n    // Note: Pass in 0 to get all of it\r\n    function TransferBNBToAddress(address payable recipient, uint256 _maxAmount) external onlyAllowedContract\r\n    {\r\n        uint256 amountToTransfer = address(this).balance;\r\n        if(_maxAmount != 0 && (amountToTransfer > _maxAmount)) amountToTransfer = _maxAmount;\r\n        if(amountToTransfer != 0) recipient.transfer(amountToTransfer);\r\n    }\r\n}\r\n\r\ncontract VetterToken\r\n{\r\n    function _getWalletTier(address who) view public returns(uint256) {}\r\n}\r\n\r\n// VSL Staking Contract Use - Setup Order:\r\n//  1) Create Contract\r\n//  2) Set VSL Token Contract\r\n//  3) Set Vetter Token Contract\r\n//  4) Make This Contract Tax Free on VSL and Set as Staking Contract\r\n//  5) Setup allowed contract addresses as needed\r\n//      0xd6b36ce79b498ceE55d090165B89A3928FA84603\r\n//      0xb930630828d01258Ce9Dc222531e2d107A75a680 - production to give access to update packages\r\n//      Event Listener should be added as well\r\ncontract VSLStaking is Allowable\r\n{\r\n    address private constant DEAD_ADDRESS = 0x000000000000000000000000000000000000dEaD;\r\n    address private _vslContract;\r\n    VetterToken private _vetterToken;\r\n    address private _vetterContract;\r\n\r\n    // Needed to remove the 9 decimals on the base token and get to the right number of shares\r\n    // Note: 1 tps per 1 token, but we show it to the user as 1 Token = 0.00001 shares\r\n    // Dividing by 100K gives us actual shares since it should be 1 per 100K and we just don't want decimals\r\n    uint256 private constant tokensPerShare = 1000000000;       // Tokens Needed Per Share (need to include 9 decimal digits)\r\n\r\n    // Decided not to make these adjustable due to re-basing issues...just use smaller packages if the price gets too high\r\n    mapping(uint256 => uint256) private multiplierList;         // This list of multipliers per tier...\r\n    //      Tier ID     Multiplier (Factor) --> 5 = 5X multiplier\r\n\r\n    // These are adjustable over time...\r\n    uint256 private earlyUnstakeTime = 3 days;                  // Configurable time before unstake has a penalty\r\n    uint256 private earlyUnstakePenalty = 20;                   // Percent lost/burned on early unstake\r\n    uint256 private oldAfterTime = 30 days;                     // Configurable time before a distribution ages out and can't be collected (tokens burned)\r\n    uint256 private stakingTransferFee = 0.1 ether;             // Configurable cost of transferring wallets (to keep staking lockups)\r\n    uint256 private claimRewardAmount = 100000000000;           // Configurable token amount for rewards (starts at 100 VSL tokens)\r\n\r\n    uint256 private totalTokensDistributed;                     // Tokens EVER Distributed (summary kept up to date for easy reference)\r\n    uint256 private totalTokensUncollected;                     // Tokens Currently Uncollected - In Distributions (summary kept up to date for easy reference)\r\n    uint256 private totalTokensPenalized;                       // Summary kept up to date for easy reference...\r\n    uint256 private totalTokensStaked;                          // Summary kept up to date for easy reference...\r\n    uint256 private totalSharesInStaking;                       // Summary kept up to date for easy reference...\r\n    uint256 private currentStakerCount;                         // Running total of the wallets in staking currently\r\n\r\n    struct Distribution\r\n    {\r\n        uint256 timeDistributed;        // Used to compare collections...the collection had to exist prior to the distribution\r\n        uint256 originalDistribution;   // Initial Amount of tokens in this distribution...needed?\r\n        uint256 amountRemaining;        // Every successful collection lowers the remaining amount\r\n        uint256 tokensPerShare;         // Used when collecting the distribution...uses totalSharesAtTime\r\n    }\r\n    mapping(uint256 => Distribution) private distributionList;  // The various distributions for as long as they exist\r\n    uint256 private numDistributions;                           // Starts at 0, first distribution is 1\r\n    uint256 private startingDistribution = 1;                   // Starts at first possible distribution (then moves as they are used up)\r\n\r\n    struct Staker\r\n    {\r\n        address wallet;                 // Wallet = User ID for this staking pool\r\n        uint256 firstChange;            // Points to the beginning of the list of changes to their account\r\n        uint256 lastChange;             // Points to the end of the list of changes to their account\r\n        uint256 lockupCount;            // Number of locks they have active at this time (acts as ID of lockup list as well)\r\n        uint256 penaltyCount;           // Number of penalties they have active at this time (acts as ID of penalty list as well)\r\n        uint256 bonusShares;            // Current bonus shares (before tier multiplication)\r\n        uint256 currentTier;            // Used to multiply the final shares\r\n        uint256 tokensCollected;        // Amount ever collected to date\r\n        uint256 tokensLocked;           // Tokens currently locked up\r\n        uint256 tokensStaked;           // Tokens in staking contract in general\r\n        uint256 lastDistributionID;     // Track the last collected distribution\r\n        uint256 lastCollectedOn;        // date of the last collect process run\r\n    }\r\n\r\n    mapping(uint256 => Staker) private stakerList;                  // ID to Staker Data\r\n    mapping(address => uint256) private walletList;                     // Address to Wallet\r\n    uint256 private numStakers;                                         // Starts at 0, first staker/wallet is 1\r\n\r\n    struct Change\r\n    {\r\n        uint256 timeofChange;           // Needed to determine whether it was before a distribution or not\r\n        uint256 totalShares;            // Number of tokens that were staked at this time\r\n    }\r\n\r\n    mapping(uint256 => mapping(uint256 => Change)) private listOfChanges; // The list of changes per wallet/staker\r\n    //      stakerID           changeID    actual change record\r\n\r\n    struct Penalty\r\n    {\r\n        uint256 tokenAmount;            // Number of tokens waiting before unstake penalty\r\n        uint256 noPenaltyAfter;         // Block/Time this penalty period expires\r\n    }\r\n\r\n    mapping(uint256 => mapping(uint256 => Penalty)) private listOfPenalties; // The list of penalties per wallet/staker\r\n    //      stakerID           penaltyID    actual penalty record\r\n\r\n    struct Lockup\r\n    {\r\n        uint256 packageID;              // The package used to lock up their stake\r\n        uint256 unlockTime;             // Block/Time this lock can be unlocked\r\n    }\r\n\r\n    mapping(uint256 => mapping(uint256 => Lockup)) private listOfLockups; // The list of lockups per wallet/staker\r\n    //      stakerID           lockupID    actual lockup record\r\n\r\n    bool private allowAllUnlock;                // Used to flag that anyone can unlock all locks (needed for migration)\r\n    bool private allowNewStakers = true;        // Used to prevent new wallets from utilizing this staking contract in the future\r\n\r\n    struct Package\r\n    {\r\n        uint256 startAfter;             // Block/Time this package becomes available (0 = start immediately)\r\n        uint256 endAfter;               // Block/Time this package can no longer be selected (0 = does not end)\r\n        uint256 amountToLock;           // Number of Tokens the package will lock up\r\n        uint256 lockPeriod;             // Number of days the lock will be active for when used\r\n        uint16 minTier;                 // Must be a certain tier to participate in this bonus package (0 = available to all)\r\n        uint32 minPackages;             // Must own a certain number of packages (0 = available to all)\r\n        uint64 maxLocks;                // Maximum times this package can be used in a lock (0 = unlimited)\r\n        uint128 lockCount;              // If it has been used in a Lock this tracks by how many users...we can't change anything other than dates if != 0\r\n        uint256 bonusShares;            // Number of bonus shares granted for locking in this package (can be multiplied)\r\n        uint256 dbID;                   // Needed to handshake to the DB\r\n    }\r\n\r\n    mapping(uint256 => Package) private packageList;\r\n    uint256 private packageCount;                       // Starts at 0, first package is ID = 1\r\n\r\n    event Staked(address indexed wallet, uint256 tokens, uint256 shares);\r\n    event Locked(address indexed wallet, uint256 packageID, uint256 shares);\r\n    event UnLocked(address indexed wallet, uint256 packageID, uint256 shares);\r\n    event Unstaked(address indexed wallet, uint256 tokens, uint256 shares);\r\n    event Collected(uint256 indexed dbID, uint256 limitOnDistributions);\r\n    event CollectedByWallet(address indexed wallet, uint256 limitOnDistributions);\r\n    event Distributed(uint256 indexed distributionID, uint256 tokensDistributed, uint256 tokensPerShare, uint256 totalShares);\r\n    event PackageUpdated(uint256 indexed packageID, uint256 indexed dbID);\r\n    event ChangeReceived(address indexed wallet, uint256 shares);\r\n    event StakingTransferred(address indexed from, address indexed to, uint256 shares);\r\n    event ConsolidateAndBurn(uint256 tokens, uint256 totalShares);\r\n\r\n    error InvalidParameter(uint8 parameter);\r\n    error UnknownPackage();\r\n    error MissingTokenContract();\r\n    error NoShareHolders();\r\n    error NoPackagesAvailable();\r\n    error NoTokensAvailable();\r\n    error BalanceLow();\r\n    error InvalidStaker();\r\n    error AlreadyHasPackage();\r\n    error MissingPackage();\r\n    error PackageCriteriaMissing(uint8 which);\r\n    error UnlockingTooEarly();\r\n    error NoNewStakers();\r\n\r\n    constructor() payable\r\n    {\r\n        // Set up the initial multipliers for owners of Vetter...\r\n        multiplierList[0] = 1;\r\n        multiplierList[1] = 2;\r\n        multiplierList[2] = 3;\r\n        multiplierList[3] = 4;\r\n        multiplierList[4] = 5;\r\n        multiplierList[5] = 10;\r\n        multiplierList[6] = 15;\r\n        multiplierList[7] = 20;\r\n    }\r\n\r\n    // To receive ETH from uniswapV2Router when swapping\r\n    receive() external payable {}\r\n\r\n    // SECTION: Control Code for handling changes to everything\r\n\r\n    // Called to set up a distribution for Collection\r\n    // Emits event Distributed(uint256 totalTokens, uint256 tokensPerShare, uint256 totalShares);\r\n    function DistributeStakingRewards(uint256 maxToProcess) external onlyAllowedContract\r\n    {\r\n        // Will need this to check the token balance to be distributed...\r\n        if(_vslContract == address(0x0)) revert MissingTokenContract();\r\n\r\n        // Can't distribute with no stakers...\r\n        if(totalSharesInStaking == 0) revert NoShareHolders();\r\n\r\n        // Calculate the number of tokens available to distribute [Cap at Up To: (Contract Balance - Staked - Uncollected - Penalized)]\r\n        // Use the contract address to check for the current total tokens on the contract\r\n        uint256 toDistribute = GetTokensToDistribute();\r\n        if(maxToProcess != 0 && toDistribute > maxToProcess) toDistribute = maxToProcess;\r\n\r\n        // Make sure there were tokens (and the variable passed was not 0)\r\n        if(toDistribute == 0) revert NoTokensAvailable();\r\n\r\n        // Calculate the tokens per share value (and remember for later)\r\n        uint256 tps = toDistribute / totalSharesInStaking;\r\n\r\n        // Deal with rounding errors by limiting to the correct number here...\r\n        toDistribute = tps * totalSharesInStaking;\r\n\r\n        // Create a Distribution\r\n        _newDistribution(toDistribute, tps);\r\n    }\r\n\r\n    // Function used to burn any uncollected tokens that have been distributed...\r\n    // startAt can be 0 to process from the start or a higher ID to process a batch\r\n    // maxToProcess can be any ID lower than the end of the distribution list\r\n    // Note: The distribution list will shrink as this processes\r\n    function ConsolidateAndBurnDistributions(uint256 startAt, uint256 maxToProcess) external onlyAllowedContract\r\n    {\r\n        // Will need this to check the token balance to be distributed...\r\n        if(_vslContract == address(0x0)) revert MissingTokenContract();\r\n\r\n        // If 0 was passed in or an ID lower than the beginning of the list, then we start at the beginning of the list\r\n        // Otherwise we try to start at the desired ID\r\n        uint256 current = (startAt == 0 || startAt < startingDistribution) ? startingDistribution : startAt;\r\n        uint256 endAt = (maxToProcess > numDistributions) ? numDistributions : maxToProcess;\r\n\r\n        // Prep a variable for what time before which a timeDistributed has to be to be considered old\r\n        uint256 pastTime = getTime() - oldAfterTime;\r\n\r\n        uint256 tokensToBurn;\r\n        while(current <= endAt)\r\n        {\r\n            // Check whether the Distribution is past the cut off period and there are tokens left\r\n            if(distributionList[current].amountRemaining != 0 && distributionList[current].timeDistributed < pastTime)\r\n            {\r\n                // Add to burn total and adjust all other variables as needed\r\n                tokensToBurn += distributionList[current].amountRemaining;\r\n                distributionList[current].amountRemaining = 0;\r\n            }\r\n            current++;\r\n        }\r\n        if(tokensToBurn != 0)\r\n        {\r\n            totalTokensUncollected -= tokensToBurn;\r\n            // Burn them, but make sure we don't try to burn more than we have some how...\r\n            uint256 amount = IERC20(_vslContract).balanceOf(address(this));\r\n            if(tokensToBurn > amount) tokensToBurn = amount;\r\n            if(tokensToBurn != 0)\r\n            {\r\n                IERC20(_vslContract).transfer(DEAD_ADDRESS, tokensToBurn);\r\n                emit ConsolidateAndBurn(tokensToBurn, totalSharesInStaking);\r\n            }\r\n        }\r\n\r\n        // Move the pointer past any cleaned out distributions\r\n        // Note: We can't do this above since the burn may be in the middle of the list for some reason...\r\n        _bumpStartingDistribution();\r\n    }\r\n\r\n    function GetNumberOfBurnableDistributions() external view onlyAllowedContract returns(uint256 numberToBurn, uint256 tokensToBurn)\r\n    {\r\n        // Start at the beginning...\r\n        uint256 current = startingDistribution;\r\n\r\n        // Prep a variable for what time before which a timeDistributed has to be to be considered old\r\n        uint256 pastTime = getTime() - oldAfterTime;\r\n        while(current <= numDistributions)\r\n        {\r\n            // Check whether the Distribution is past the cut off period and there are tokens left\r\n            if(distributionList[current].amountRemaining != 0 && distributionList[current].timeDistributed < pastTime)\r\n            {\r\n                // Add to burn total\r\n                numberToBurn++;\r\n                tokensToBurn += distributionList[current].amountRemaining;\r\n            }\r\n            current++;\r\n        }\r\n    }\r\n\r\n    // Called to add tokens into the staking contract for a wallet\r\n    // Note: They need to already Approve this contract from the UI side before this is called...\r\n    //      - Approve THIS contract address to stake the number of tokens they are transferring\r\n    function StakeTokens(uint256 _numTokens) external\r\n    {\r\n        // Will need this to check the token balance to be staked...\r\n        if(_vslContract == address(0x0)) revert MissingTokenContract();\r\n        // Will need this to check the tier of Vetter for the wallet\r\n        if(_vetterContract == address(0x0)) revert MissingTokenContract();\r\n\r\n        // Make sure they have that many tokens in their wallet to move to the contract\r\n        address _wallet = _msgSender();\r\n        if(IERC20(_vslContract).balanceOf(_wallet) < _numTokens) revert BalanceLow();\r\n\r\n        // Determine the number of tokens we are holding before this transfer...\r\n        // Note: People may have sent right to us...we do not want to include those and give the tokens away\r\n        uint256 contractStart = IERC20(_vslContract).balanceOf(address(this));\r\n\r\n        // We need to transfer the tokens to this contract to stake...\r\n        // They need to already Approve this from the UI side before this is called...\r\n        //      - Approve THIS contract address to stake the number of tokens they are transferring\r\n        IERC20(_vslContract).transferFrom(_wallet, address(this), _numTokens);\r\n\r\n        // Now getting the balance after the transfer tells us how many tokens to stake (what is left after any tax, etc.)\r\n        // This takes a bit of extra gas, but better to verify the tokens were received and it was the correct amount\r\n        uint256 contractEnd = IERC20(_vslContract).balanceOf(address(this));\r\n        uint256 numTokens = contractEnd - contractStart;\r\n        if(numTokens == 0) revert NoTokensAvailable();\r\n\r\n        // See if the wallet is already a staker or not (If not - Make a Staker entry to track them)\r\n        // The wallet tier is needed for a new staker as well as later calculations\r\n        uint256 _currentTier = _vetterToken._getWalletTier(_wallet);\r\n        uint256 stakerID = _addOrFindStaker(_wallet, _currentTier);\r\n\r\n        // Update main currentStakerCount once they actually complete the stake...\r\n        // IF this is a new user or if they ever unstake all, then we add them now to the count\r\n        if(stakerList[stakerID].tokensStaked == 0) currentStakerCount++;\r\n\r\n        // Compute the beginning totals we need to compute the differences later...\r\n        uint256 stakerTotalSharesBefore = (stakerList[stakerID].lastChange != 0) ? listOfChanges[stakerID][stakerList[stakerID].lastChange].totalShares : 0;\r\n\r\n        // Update [Staked Tokens, Tier] on Staker\r\n        stakerList[stakerID].tokensStaked += numTokens;\r\n        stakerList[stakerID].currentTier = _currentTier;\r\n\r\n        // Now Compute the difference in totals we need to update the contract...\r\n        uint256 stakerTotalSharesAfter =\r\n            (\r\n                (stakerList[stakerID].tokensStaked / tokensPerShare)\r\n                + stakerList[stakerID].bonusShares\r\n            )\r\n            * multiplierList[_currentTier];\r\n\r\n        // Update [Total Tokens Staked, Total Shares] on main contract\r\n        // Also...create the Unstake Penalty and Tier Change for the staker if needed\r\n        totalTokensStaked += numTokens;\r\n        _cleanPenalties(stakerID);\r\n        _addPenalty(stakerID, numTokens);\r\n\r\n        // Main: Shares\r\n        if(stakerTotalSharesAfter > stakerTotalSharesBefore)\r\n        {\r\n            totalSharesInStaking += (stakerTotalSharesAfter - stakerTotalSharesBefore);\r\n            _addChange(stakerID, stakerTotalSharesAfter);\r\n        }\r\n        else if(stakerTotalSharesAfter < stakerTotalSharesBefore)\r\n        {\r\n            totalSharesInStaking -= (stakerTotalSharesBefore - stakerTotalSharesAfter);\r\n            _addChange(stakerID, stakerTotalSharesAfter);\r\n        }\r\n\r\n        // Let's auto stake any collectible tokens as well\r\n        if(_collectByWallet(stakerID,_currentTier,0) != 0) emit CollectedByWallet(_wallet, 0);\r\n\r\n        // Let the listener(s) know it happened...\r\n        emit Staked(_wallet, _numTokens, stakerTotalSharesAfter);\r\n    }\r\n\r\n    // Called to add staked tokens into a package to lock them up\r\n    function LockTokens(uint256 _packageID) external\r\n    {\r\n        // Will need this to check the tier of Vetter for the wallet\r\n        if(_vetterContract == address(0x0)) revert MissingTokenContract();\r\n\r\n        // We have to have packages to begin with...\r\n        if(packageCount == 0) revert NoPackagesAvailable();\r\n\r\n        // And we have to be sure the package exists...\r\n        if(_packageID < 1 || _packageID > packageCount) revert InvalidParameter(1);\r\n\r\n        // Make sure we have a staker calling the function...\r\n        address _wallet = _msgSender();\r\n        uint256 ID = walletList[_wallet];\r\n        if(ID == 0) revert InvalidStaker();\r\n\r\n        // Make sure they do not already have this package...\r\n        if(HasPackage(_wallet, _packageID)) revert AlreadyHasPackage();\r\n\r\n        // Validate this package is accessible to this user and has not been used yet by them\r\n        uint256 curTime = getTime();\r\n        if(packageList[_packageID].startAfter != 0 && curTime < packageList[_packageID].startAfter) revert PackageCriteriaMissing(1);\r\n        if(packageList[_packageID].endAfter != 0 && curTime > packageList[_packageID].endAfter) revert PackageCriteriaMissing(2);\r\n        if(stakerList[ID].currentTier < packageList[_packageID].minTier) revert PackageCriteriaMissing(3);\r\n        if(stakerList[ID].lockupCount < packageList[_packageID].minPackages) revert PackageCriteriaMissing(4);\r\n        if(packageList[_packageID].maxLocks != 0 && packageList[_packageID].lockCount >= packageList[_packageID].maxLocks) revert PackageCriteriaMissing(5);\r\n\r\n        // Get any collectible tokens first...\r\n        uint256 _currentTier = _vetterToken._getWalletTier(_wallet);\r\n        if(_collectByWallet(ID,_currentTier,0) != 0) emit CollectedByWallet(_wallet, 0);\r\n\r\n        // Make sure they can stake the number of tokens requested for that package\r\n        // If Available < Needed then we have an issue\r\n        if((stakerList[ID].tokensStaked - stakerList[ID].tokensLocked) < packageList[_packageID].amountToLock)\r\n            revert PackageCriteriaMissing(6);\r\n\r\n        // Everything seems to check out...so now we can proceed with setting it up...\r\n\r\n        // Compute the beginning totals we need to compute the differences later...\r\n        uint256 stakerTotalSharesBefore = listOfChanges[ID][stakerList[ID].lastChange].totalShares;\r\n\r\n        // Perform the actual creation of the lock for this user\r\n        _addLockup(ID, _packageID);\r\n        packageList[_packageID].lockCount++; // Mark the package reference counter (lockCount) so we know it is in use\r\n\r\n        // Update state variables as needed...\r\n        // Staker: Shares, Locked Tokens\r\n        stakerList[ID].tokensLocked += packageList[_packageID].amountToLock;\r\n        stakerList[ID].bonusShares += packageList[_packageID].bonusShares;\r\n        stakerList[ID].currentTier = _currentTier;\r\n\r\n        // Now Compute the difference in totals we need to update the contract...\r\n        uint256 stakerTotalSharesAfter =\r\n            (\r\n                (stakerList[ID].tokensStaked / tokensPerShare)\r\n                + stakerList[ID].bonusShares\r\n            )\r\n            * multiplierList[_currentTier];\r\n\r\n        // Main: Shares\r\n        if(stakerTotalSharesAfter > stakerTotalSharesBefore)\r\n        {\r\n            totalSharesInStaking += (stakerTotalSharesAfter - stakerTotalSharesBefore);\r\n            _addChange(ID, stakerTotalSharesAfter);\r\n        }\r\n        else if(stakerTotalSharesAfter < stakerTotalSharesBefore)\r\n        {\r\n            totalSharesInStaking -= (stakerTotalSharesBefore - stakerTotalSharesAfter);\r\n            _addChange(ID, stakerTotalSharesAfter);\r\n        }\r\n        _cleanPenalties(ID);\r\n\r\n        // Let the listener(s) know it happened...\r\n        emit Locked(_wallet, _packageID, stakerTotalSharesAfter);\r\n    }\r\n\r\n    // Called to unlock tokens from a package and back into staking\r\n    // Emits event UnLocked(address indexed wallet, uint256 packageID);\r\n    function UnlockTokens(uint256 _packageID) external\r\n    {\r\n        // Will need this to check the tier of Vetter for the wallet\r\n        if(_vetterContract == address(0x0)) revert MissingTokenContract();\r\n\r\n        // We have to be sure the package exists...\r\n        if(_packageID < 1 || _packageID > packageCount) revert InvalidParameter(1);\r\n\r\n        // Make sure this user actually has the package selected\r\n        address _wallet = _msgSender();\r\n        uint256 ID = walletList[_wallet];\r\n        if(ID == 0) revert InvalidStaker();\r\n        uint256 curLock = _getLockup(ID, _packageID);\r\n        if(curLock == 0) revert MissingPackage();\r\n\r\n        // Make sure the locking period is over and they are able to unlock\r\n        if(!allowAllUnlock && (listOfLockups[ID][curLock].unlockTime > getTime())) revert UnlockingTooEarly();\r\n\r\n        // Everything seems to check out...so now we can proceed with setting it up...\r\n\r\n        // See if they have a collection first though...\r\n        uint256 _currentTier = _vetterToken._getWalletTier(_wallet);\r\n        if(_collectByWallet(ID,_currentTier, 0) != 0) emit CollectedByWallet(_wallet, 0);\r\n\r\n        // Compute the beginning totals we need to compute the differences later...\r\n        uint256 stakerTotalSharesBefore = listOfChanges[ID][stakerList[ID].lastChange].totalShares;\r\n\r\n        // Perform the actual removal of the lock for this user\r\n        _removeLockup(ID, curLock);\r\n\r\n        packageList[_packageID].lockCount--; // Remove one from the reference counter to signal this user is done with this package\r\n\r\n        // Update state variables as needed...\r\n        // Staker: Shares, Locked Tokens, Tier\r\n        stakerList[ID].tokensLocked -= packageList[_packageID].amountToLock;\r\n        stakerList[ID].bonusShares -= packageList[_packageID].bonusShares;\r\n        stakerList[ID].currentTier = _currentTier;\r\n\r\n        // Now Compute the difference in totals we need to update the contract...\r\n        uint256 stakerTotalSharesAfter =\r\n            (\r\n                (stakerList[ID].tokensStaked / tokensPerShare)\r\n                + stakerList[ID].bonusShares\r\n            )\r\n            * multiplierList[_currentTier];\r\n\r\n        // Main: Shares\r\n        if(stakerTotalSharesAfter > stakerTotalSharesBefore)\r\n        {\r\n            totalSharesInStaking += (stakerTotalSharesAfter - stakerTotalSharesBefore);\r\n            _addChange(ID, stakerTotalSharesAfter);\r\n        }\r\n        else if(stakerTotalSharesAfter < stakerTotalSharesBefore)\r\n        {\r\n            totalSharesInStaking -= (stakerTotalSharesBefore - stakerTotalSharesAfter);\r\n            _addChange(ID, stakerTotalSharesAfter);\r\n        }\r\n        _cleanPenalties(ID);\r\n\r\n        // Let the listener(s) know it happened...\r\n        emit UnLocked(_wallet, _packageID, stakerTotalSharesAfter);\r\n    }\r\n\r\n    // Called to unstake tokens from the staking contract\r\n    function UnstakeTokens(uint256 _numTokens, bool _okToTakePenalty) external\r\n    {\r\n        // Fail early if this is missing...costs less gas\r\n        if(_vslContract == address(0x0)) revert MissingTokenContract();\r\n        // Will need this to check the tier of Vetter for the wallet\r\n        if(_vetterContract == address(0x0)) revert MissingTokenContract();\r\n\r\n        address _wallet = _msgSender();\r\n        uint256 ID = walletList[_wallet];\r\n        if(ID == 0) revert InvalidStaker(); // Means they are not actually a staker so nothing to do...\r\n\r\n        // Collect first to know what is available...\r\n        uint256 _currentTier = _vetterToken._getWalletTier(_wallet);\r\n        if(_collectByWallet(ID,_currentTier,0) != 0) emit CollectedByWallet(_wallet, 0);\r\n\r\n        // Compute the beginning totals we need to compute the differences later...\r\n        uint256 stakerTotalSharesBefore = listOfChanges[ID][stakerList[ID].lastChange].totalShares;\r\n\r\n        // This is the total they can technically unstake...\r\n        uint256 available = stakerList[ID].tokensStaked - stakerList[ID].tokensLocked;\r\n\r\n        // This amount OF it would be at a penalty however\r\n        uint256 penaltyCount = GetPenaltyTokens(_wallet);\r\n        if (penaltyCount > stakerList[ID].tokensLocked) penaltyCount -= stakerList[ID].tokensLocked;\r\n        else penaltyCount = 0;\r\n\r\n        // Verify they can unstake as many as requested...based upon how many are in penalty or not\r\n        uint256 numToDraw = (_numTokens > available) ? available : _numTokens;\r\n        // We have to penalize their token draw...\r\n        uint256 numPenalty;\r\n        if(!_okToTakePenalty)\r\n        {\r\n            // Handle if there are none available\r\n            if(penaltyCount > available) numToDraw = 0;\r\n            // Hanlde reducing the amount we are pulling down to just what is available (if any)\r\n            else if(numToDraw > (available - penaltyCount)) numToDraw = available - penaltyCount;\r\n        }\r\n        else\r\n        {\r\n            // otherwise we will handle drawing down penalized tokens later\r\n            if(penaltyCount > available) numPenalty = available;\r\n            else if(numToDraw > (available - penaltyCount)) numPenalty = numToDraw - (available - penaltyCount);\r\n        }\r\n\r\n        if(numToDraw != 0)\r\n        {\r\n            // Remove the tokens from the staker\r\n            stakerList[ID].tokensStaked -= numToDraw;\r\n            stakerList[ID].currentTier = _currentTier;\r\n\r\n            // Update main currentStakerCount once they actually complete the unstake...\r\n            // IF they unstaked all, then we remove them now from the count\r\n            if(stakerList[ID].tokensStaked == 0) currentStakerCount--;\r\n\r\n            // Let the listener(s) know it happened...\r\n            uint256 numDrawn = numToDraw;\r\n\r\n            // Are they taking more than what was vested already...\r\n            if(numPenalty != 0)\r\n            {\r\n                uint256 penaltyTokens = CalcEarlyUnstakePenalty(numPenalty);\r\n                totalTokensPenalized += penaltyTokens;\r\n                totalTokensStaked -= penaltyTokens;\r\n                numToDraw -= penaltyTokens;\r\n\r\n                // Kill the penalty objects as needed to resolve the first in first out...\r\n                uint256 oldestID = _oldestPenalty(ID);\r\n                while(oldestID != 0 && numPenalty != 0)\r\n                {\r\n                    if(listOfPenalties[ID][oldestID].tokenAmount >= numPenalty)\r\n                    {\r\n                        listOfPenalties[ID][oldestID].tokenAmount -= numPenalty;\r\n                        numPenalty = 0;\r\n                    }\r\n                    else\r\n                    {\r\n                        numPenalty -= listOfPenalties[ID][oldestID].tokenAmount;\r\n                        listOfPenalties[ID][oldestID].tokenAmount = 0;\r\n                        oldestID = _oldestPenalty(ID);\r\n                    }\r\n                }\r\n                _cleanPenalties(ID);\r\n            }\r\n\r\n            // Now Compute the difference in totals we need to update the contract...\r\n            uint256 stakerTotalSharesAfter =\r\n                (\r\n                    (stakerList[ID].tokensStaked / tokensPerShare)\r\n                    + stakerList[ID].bonusShares\r\n                )\r\n                * multiplierList[_currentTier];\r\n\r\n            // Main: Shares\r\n            if(stakerTotalSharesAfter > stakerTotalSharesBefore)\r\n            {\r\n                totalSharesInStaking += (stakerTotalSharesAfter - stakerTotalSharesBefore);\r\n                _addChange(ID, stakerTotalSharesAfter);\r\n            }\r\n            else if(stakerTotalSharesAfter < stakerTotalSharesBefore)\r\n            {\r\n                totalSharesInStaking -= (stakerTotalSharesBefore - stakerTotalSharesAfter);\r\n                _addChange(ID, stakerTotalSharesAfter);\r\n            }\r\n\r\n            // Now send their non-penalized tokens to their wallet...\r\n            if(numToDraw != 0)\r\n            {\r\n                IERC20(_vslContract).transfer(_wallet, numToDraw);\r\n                totalTokensStaked -= numToDraw;\r\n            }\r\n\r\n            emit Unstaked(_wallet, numDrawn, stakerTotalSharesAfter);\r\n        }\r\n        else revert NoTokensAvailable();\r\n    }\r\n\r\n    // Called to collect tokens for a range of wallets\r\n    // Note:    isRandom = true, we deal with payout\r\n    //          isRandom = false, we do not deal with payout\r\n    // DB will come and walk the wallet list to update to new collected tokens amount (newTotal - oldTotal = collectedAmount)\r\n    // Note: _limitDistributions can be 0 to pull them all...or a number to lower the amount of dist per wallet to process\r\n    function CollectTokens(uint256 dbID, address[] memory wallets, bool isRandom, uint256 _limitDistributions) external\r\n    {\r\n        // Will need this to check the tier of Vetter for the wallet\r\n        if(_vetterContract == address(0x0)) revert MissingTokenContract();\r\n\r\n        // Step through the list of wallets to process each one\r\n        uint256 processed;\r\n        uint256 stakerID;\r\n        uint256 numWallets = wallets.length;\r\n        for(uint256 i = 0; i < numWallets; i++)\r\n        {\r\n            stakerID = walletList[wallets[i]];\r\n            uint256 _currentTier = _vetterToken._getWalletTier(wallets[i]);\r\n            if(stakerID != 0 && _collectByWallet(stakerID, _currentTier, _limitDistributions) != 0)\r\n            {\r\n                processed++;\r\n                _cleanPenalties(stakerID);\r\n            }\r\n        }\r\n\r\n        // Process the payout to the caller (if needed)\r\n        if(isRandom && processed != 0 && totalTokensPenalized > claimRewardAmount)\r\n        {\r\n            uint256 factor = 100;\r\n            uint256 rand = uint256(keccak256(abi.encodePacked(block.difficulty, block.timestamp, factor)));\r\n            if((rand % factor) > 30) // 70 % chance of payout...\r\n            {\r\n                // Will need this to check the token balance to pay out...\r\n                if(_vslContract == address(0x0)) revert MissingTokenContract();\r\n                address _wallet = _msgSender();\r\n                IERC20(_vslContract).transfer(_wallet, claimRewardAmount);\r\n                totalTokensPenalized -= claimRewardAmount;\r\n            }\r\n        }\r\n        emit Collected(dbID, _limitDistributions);\r\n    }\r\n\r\n    // Called to collect tokens for a specific wallet\r\n    // Note: _limitDistributions can be 0 to pull them all...or a number to lower the amount of dist per wallet to process\r\n    function CollectByWallet(uint256 _limitDistributions) external\r\n    {\r\n        // Will need this to check the tier of Vetter for the wallet\r\n        if(_vetterContract == address(0x0)) revert MissingTokenContract();\r\n\r\n        address _wallet = _msgSender();\r\n        uint256 stakerID = walletList[_wallet];\r\n        if(stakerID != 0)\r\n        {\r\n            // Simply call for the current user only...and let the listener(s) know it happened...\r\n            uint256 _currentTier = _vetterToken._getWalletTier(_wallet);\r\n            if(_collectByWallet(stakerID, _currentTier, _limitDistributions) != 0) emit CollectedByWallet(_wallet, _limitDistributions);\r\n            _cleanPenalties(stakerID);\r\n        }\r\n    }\r\n\r\n    // This is called externally by a tier change checker on the event listener\r\n    // It should only be called when the tier actually changes, but we will verify in case it is called again for some reason\r\n    // This WILL do nothing if they are not already a staker as we do not want to just add everyone to the staking contract who isn't in it\r\n    // forceIt = use to make sure we get a change event (sel-healing = change multiplier or something)\r\n    function CheckTierChange(address _wallet, bool forceIt) external onlyAllowedContract\r\n    {\r\n        // Will need this to check the tier of Vetter for the wallet\r\n        if(_vetterContract == address(0x0)) revert MissingTokenContract();\r\n\r\n        // Verify they are actually a staker before we continue (or fail silently)\r\n        uint256 stakerID = walletList[_wallet];\r\n        if(stakerID == 0) return;\r\n\r\n        // Verify the tier is actually different (or fail silently)\r\n        uint256 _currentTier = _vetterToken._getWalletTier(_wallet);\r\n        if(!forceIt && stakerList[stakerID].currentTier == _currentTier)\r\n        {\r\n            emit ChangeReceived(_wallet, listOfChanges[stakerID][stakerList[stakerID].lastChange].totalShares);\r\n            return;\r\n        }\r\n\r\n        // Compute the beginning totals we need to compute the differences later...\r\n        uint256 stakerTotalSharesBefore = listOfChanges[stakerID][stakerList[stakerID].lastChange].totalShares;\r\n\r\n        // Update Tier on Staker\r\n        stakerList[stakerID].currentTier = _currentTier;\r\n\r\n        // Now Compute the difference in totals we need to update the contract...\r\n        uint256 stakerTotalSharesAfter =\r\n            (\r\n                (stakerList[stakerID].tokensStaked / tokensPerShare)\r\n                + stakerList[stakerID].bonusShares\r\n            )\r\n            * multiplierList[_currentTier];\r\n\r\n        // Main: Shares\r\n        if(stakerTotalSharesAfter > stakerTotalSharesBefore)\r\n        {\r\n            totalSharesInStaking += (stakerTotalSharesAfter - stakerTotalSharesBefore);\r\n        }\r\n        else if(stakerTotalSharesAfter < stakerTotalSharesBefore)\r\n        {\r\n            totalSharesInStaking -= (stakerTotalSharesBefore - stakerTotalSharesAfter);\r\n        }\r\n\r\n        // We made a change...so update or add a change as of this point in time\r\n        _addChange(stakerID, stakerTotalSharesAfter);\r\n\r\n        emit ChangeReceived(_wallet, stakerTotalSharesAfter);\r\n    }\r\n\r\n    // SECTION: Transfer Functionality\r\n\r\n    // Can be called for anyone after a fee for admin, etc. has been collected...\r\n    function InternalTransfer(address _from, address _to) external onlyAllowedContract\r\n    {\r\n        _performTransfer(_from, _to);\r\n    }\r\n\r\n    // Can be called externally by anyone for a fee...\r\n    function TransferStaking(address _to) external payable\r\n    {\r\n        if(msg.value < stakingTransferFee) revert BalanceLow(); // make sure they sent the money in to do this\r\n        address _wallet = _msgSender();\r\n        _performTransfer(_wallet, _to);\r\n    }\r\n\r\n    // Replace the address variables where _from shows up with _to address and correct the links/pointers\r\n    function _performTransfer(address _from, address _to) internal\r\n    {\r\n        // Will need this to check the tier of Vetter for the wallet\r\n        if(_vetterContract == address(0x0)) revert MissingTokenContract();\r\n\r\n        if(_to == _from) revert InvalidParameter(1); // The addresses must be different\r\n        if(_to == address(0x0)) revert InvalidParameter(2); // We can't burn a stake, they have to unstake and do that manually\r\n        uint256 fromID = walletList[_from];\r\n        if(fromID == 0) revert InvalidParameter(1); // The address from must exist already...\r\n        uint256 toID = walletList[_to];\r\n        if(toID != 0) revert InvalidParameter(2); // The address to can not already have staking...\r\n\r\n        // Compute the beginning totals we need to compute the differences later...\r\n        uint256 stakerTotalSharesBefore = listOfChanges[fromID][stakerList[fromID].lastChange].totalShares;\r\n\r\n        stakerList[fromID].wallet = _to;\r\n        walletList[_from] = 0;\r\n        walletList[_to] = fromID;\r\n\r\n        // Update Tier on Staker\r\n        uint256 _currentTier = _vetterToken._getWalletTier(_to);\r\n        stakerList[fromID].currentTier = _currentTier;\r\n\r\n        // Now Compute the difference in totals we need to update the contract...\r\n        uint256 stakerTotalSharesAfter =\r\n            (\r\n                (stakerList[fromID].tokensStaked / tokensPerShare)\r\n                + stakerList[fromID].bonusShares\r\n            )\r\n            * multiplierList[_currentTier];\r\n\r\n        // Main: Shares\r\n        if(stakerTotalSharesAfter > stakerTotalSharesBefore)\r\n        {\r\n            totalSharesInStaking += (stakerTotalSharesAfter - stakerTotalSharesBefore);\r\n        }\r\n        else if(stakerTotalSharesAfter < stakerTotalSharesBefore)\r\n        {\r\n            totalSharesInStaking -= (stakerTotalSharesBefore - stakerTotalSharesAfter);\r\n        }\r\n\r\n        // We made a change...so update or add a change as of this point in time\r\n        _addChange(fromID, stakerTotalSharesAfter);\r\n        emit StakingTransferred(_from, _to, stakerTotalSharesAfter);\r\n    }\r\n\r\n    // SECTION: Distribution Functionality\r\n\r\n    // Add a distribution to the list\r\n    function _newDistribution(uint256 _originalDistribution, uint256 _tokensPerShare) internal\r\n    {\r\n        // Add it to the Distribution List\r\n        numDistributions += 1;\r\n        distributionList[numDistributions].timeDistributed = getTime();\r\n        distributionList[numDistributions].originalDistribution = _originalDistribution;\r\n        distributionList[numDistributions].amountRemaining = _originalDistribution;\r\n        distributionList[numDistributions].tokensPerShare = _tokensPerShare;\r\n\r\n        // Update Tokens Distributed and Uncollected Tokens...\r\n        // Make sure main contract stays up to date as a distribution is made\r\n        totalTokensDistributed += _originalDistribution;\r\n        totalTokensUncollected += _originalDistribution;\r\n\r\n        emit Distributed(numDistributions, _originalDistribution, _tokensPerShare, totalSharesInStaking);\r\n    }\r\n\r\n    // Used to bump the starting pointer up if needed as distributions are collected or cleaned/burned\r\n    // We are not actually deleting the distributions...so this will stop working once max uint256 is reached\r\n    function _bumpStartingDistribution() internal\r\n    {\r\n        while(startingDistribution <= numDistributions)\r\n        {\r\n            if(distributionList[startingDistribution].amountRemaining != 0) break;\r\n            startingDistribution++;\r\n        }\r\n    }\r\n\r\n    // The ending point of the list of distributions\r\n    // Also: The total number of distributions ever made\r\n    function GetLastDistribution() view external returns(uint256)\r\n    {\r\n        return numDistributions;\r\n    }\r\n\r\n    // The starting point into the list of distributions\r\n    function GetFirstDistribution() view external returns(uint256)\r\n    {\r\n        return startingDistribution;\r\n    }\r\n\r\n    // How many uncollected distributions remain\r\n    function GetRemainingDistributions() view external returns(uint256)\r\n    {\r\n        if(startingDistribution > numDistributions) return 0;\r\n        return (numDistributions - startingDistribution) + 1;\r\n    }\r\n\r\n    // Look at a specific distribution's details\r\n    function GetDistribution(uint256 _distributionID) view external returns(Distribution memory)\r\n    {\r\n        return distributionList[_distributionID];\r\n    }\r\n\r\n    // Get Last Time a Distribution was Created\r\n    function GetLastDistributionTime() view external returns(uint256 last)\r\n    {\r\n        last = distributionList[numDistributions].timeDistributed;\r\n    }\r\n\r\n    // SECTION: Staker Functionality\r\n\r\n    // The total number of stakers ever staked\r\n    function GetStakerCount() view external returns(uint256)\r\n    {\r\n        return numStakers;\r\n    }\r\n\r\n    // The ID for the wallet who has staked...\r\n    function GetStakerID(address wallet) view external returns(uint256)\r\n    {\r\n        return walletList[wallet];\r\n    }\r\n\r\n    // The wallet for the ID who has staked...\r\n    function GetStakerWallet(uint256 _stakerID) view external returns(address wallet)\r\n    {\r\n        return stakerList[_stakerID].wallet;\r\n    }\r\n\r\n    // The full Staker record for the wallet who has staked...\r\n    function GetStakerByWallet(address wallet) view external returns(Staker memory)\r\n    {\r\n        return stakerList[walletList[wallet]];\r\n    }\r\n\r\n    // The full Staker record for the ID who has staked...\r\n    function GetStakerByID(uint256 _stakerID) view external returns(Staker memory)\r\n    {\r\n        return stakerList[_stakerID];\r\n    }\r\n\r\n    // Called internally to create or find an existing staker record\r\n    // If the wallet has a staker record already created, it will return it's ID\r\n    // If not, then a blank staker record is set up for this wallet to use\r\n    function _addOrFindStaker(address _wallet, uint256 _tier) internal returns(uint256)\r\n    {\r\n        // Find existing staker record if it exists...\r\n        if(walletList[_wallet] != 0) return walletList[_wallet];\r\n\r\n        if(!allowNewStakers) revert NoNewStakers();\r\n\r\n        // Otherwise we add a new one into the lists\r\n        numStakers++;\r\n        walletList[_wallet] = numStakers; // Needed to find this wallet later without running the list\r\n        stakerList[numStakers] = Staker(_wallet,0,0,0,0,0,_tier,0,0,0,0,0); // Actual Staker List by ID\r\n\r\n        // Note: We do not update main currentStakerCount until they actually complete the stake...\r\n        return numStakers;\r\n    }\r\n\r\n    // Determine the Shares Details for a given wallet\r\n    // total = final shares with bonuses and Vetter multiplier figured in\r\n    // base = number of shares computed from the base staked token count and Per Share figures\r\n    // bonus = sum of bonuses earned by lockups of this wallet's tokens\r\n    // For reference, multiplier = the current tier of the wallet's multiple applied\r\n    function GetShares(address _wallet) view external returns(uint256 total, uint256 base, uint256 bonus, uint256 multiplier)\r\n    {\r\n        uint256 ID = walletList[_wallet];\r\n        if(ID != 0)\r\n        {\r\n            base = stakerList[ID].tokensStaked / tokensPerShare;\r\n            bonus = stakerList[ID].bonusShares;\r\n            multiplier = multiplierList[stakerList[ID].currentTier];\r\n            total = (base + bonus) * multiplier;\r\n        }\r\n    }\r\n\r\n    // Determine how many tokens are available for this wallet to collect\r\n    // numTokens = number of tokens to return\r\n    function GetCollectableTokens(address _wallet) view external returns(uint256 numTokens)\r\n    {\r\n        uint256 ID = walletList[_wallet];\r\n        if(ID != 0)\r\n        {\r\n            uint256 dist = stakerList[ID].lastDistributionID + 1;\r\n            if(dist < startingDistribution) dist = startingDistribution;\r\n\r\n            // Step through the changes and see if there are future distributions we can collect from...\r\n            // Note: This will not actually change the starting pointer to the changes like the collection function would\r\n            uint256 earnedTokens;\r\n            uint256 curChange = stakerList[ID].firstChange;\r\n            uint256 nextChange = stakerList[ID].firstChange + 1;\r\n            while(curChange <= stakerList[ID].lastChange && dist <= numDistributions)\r\n            {\r\n                // See if we have an older change and can move on to the next one...\r\n                if(nextChange <= stakerList[ID].lastChange && listOfChanges[ID][nextChange].timeofChange < distributionList[dist].timeDistributed)\r\n                {\r\n                    curChange++;\r\n                    nextChange++;\r\n                }\r\n                // See if the current change is before the next distribution...\r\n                else if(listOfChanges[ID][curChange].timeofChange < distributionList[dist].timeDistributed)\r\n                {\r\n                    // See how many tokens they earned...\r\n                    earnedTokens = distributionList[dist].tokensPerShare * listOfChanges[ID][curChange].totalShares;\r\n                    if(earnedTokens > distributionList[numDistributions].amountRemaining) earnedTokens = distributionList[numDistributions].amountRemaining;\r\n                    numTokens += earnedTokens;\r\n\r\n                    dist++;\r\n                }\r\n                // Otherwise the distribution is before the current change so we can skip it...\r\n                else dist++;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Get the date/time of the last time this wallet has actually collected tokens\r\n    // lastCollected = time of last collection\r\n    function GetLastCollectedTime(address _wallet) view external returns(uint256 lastCollected)\r\n    {\r\n        uint256 ID = walletList[_wallet];\r\n        if(ID != 0) lastCollected = stakerList[ID].lastCollectedOn;\r\n    }\r\n\r\n    // SECTION: Change Functionality\r\n\r\n    // Called internally to perform the change creation\r\n    // This will create a staker if one does not exist...so do not expect it to fail...ever\r\n    function _addChange(uint256 _stakerID, uint256 _shares) internal returns(uint256 changeID)\r\n    {\r\n        // See if there are any changes at all first...\r\n        if(stakerList[_stakerID].firstChange == 0)\r\n        {\r\n            // We start a new change in this case\r\n            stakerList[_stakerID].lastChange = 1;\r\n            stakerList[_stakerID].firstChange = 1;\r\n            changeID = 1;\r\n        }\r\n        // See if the last change was after the last distribution\r\n        else if(numDistributions == 0 || (numDistributions != 0 && (distributionList[numDistributions].timeDistributed < listOfChanges[_stakerID][stakerList[_stakerID].lastChange].timeofChange)))\r\n        {\r\n            // Just update the last one rather that adding a new one\r\n            changeID = stakerList[_stakerID].lastChange;\r\n        }\r\n        else\r\n        {\r\n            // In this case...there has been another distribution since the last change, so we need to create a new change now\r\n            stakerList[_stakerID].lastChange += 1;\r\n            changeID = stakerList[_stakerID].lastChange;\r\n        }\r\n        listOfChanges[_stakerID][changeID].timeofChange = getTime();\r\n        listOfChanges[_stakerID][changeID].totalShares = _shares;\r\n    }\r\n\r\n    // Called internally to perform the collect tokens action for a specific wallet\r\n    // Will try to get ALL collections performed in one go...use CollectNextOnlyForWallet to\r\n    //  get caught up if too much gas is needed for this\r\n    function _collectByWallet(uint256 _stakerID, uint256 _currentTier, uint256 _limitDistributions) internal returns(uint256 numTokens)\r\n    {\r\n        // Will need this to check the tier of Vetter for the wallet\r\n        if(_vetterContract == address(0x0)) revert MissingTokenContract();\r\n\r\n        uint256 dist = stakerList[_stakerID].lastDistributionID + 1;\r\n        if(dist < startingDistribution) dist = startingDistribution;\r\n\r\n        // Compute the beginning totals we need to compute the differences later...\r\n        uint256 stakerTotalSharesBefore = listOfChanges[_stakerID][stakerList[_stakerID].lastChange].totalShares;\r\n\r\n        // Step through the changes and see if there are future distributions we can collect from...\r\n        // Note: This will actually change the starting pointer to the changes (clean the list) as we go, until one is left\r\n        uint256 earnedTokens;\r\n        uint256 nextChange = stakerList[_stakerID].firstChange + 1;\r\n        uint256 numFound;\r\n        while(stakerList[_stakerID].firstChange <= stakerList[_stakerID].lastChange && dist <= numDistributions)\r\n        {\r\n            // See if we have an older change and can move on to the next one...\r\n            if(nextChange <= stakerList[_stakerID].lastChange && listOfChanges[_stakerID][nextChange].timeofChange < distributionList[dist].timeDistributed)\r\n            {\r\n                stakerList[_stakerID].firstChange++;\r\n                nextChange++;\r\n            }\r\n            // See if the current change is before the next distribution...\r\n            else if(listOfChanges[_stakerID][stakerList[_stakerID].firstChange].timeofChange < distributionList[dist].timeDistributed)\r\n            {\r\n                // We collect this distribution...\r\n                // See how many tokens they earned...\r\n                earnedTokens = distributionList[dist].tokensPerShare * listOfChanges[_stakerID][stakerList[_stakerID].firstChange].totalShares;\r\n                if(earnedTokens > distributionList[dist].amountRemaining) earnedTokens = distributionList[dist].amountRemaining;\r\n\r\n                if(earnedTokens != 0)\r\n                {\r\n                    // Update the main contract figures as needed and track this earned amount\r\n                    numTokens += earnedTokens;\r\n                    distributionList[dist].amountRemaining -= earnedTokens;\r\n                    numFound++;\r\n                    if(_limitDistributions != 0 && numFound >= _limitDistributions) break;\r\n                }\r\n\r\n                dist++;\r\n            }\r\n            // Otherwise the distribution is before the first change so we can skip it...\r\n            else\r\n            {\r\n                dist++;\r\n            }\r\n        }\r\n\r\n        if(numTokens != 0)\r\n        {\r\n            // Actually move the tokens to the staker's balance...\r\n            stakerList[_stakerID].tokensCollected += numTokens;\r\n            stakerList[_stakerID].tokensStaked += numTokens;\r\n\r\n            // Update Tier on Staker\r\n            stakerList[_stakerID].currentTier = _currentTier;\r\n\r\n            // Now Compute the difference in totals we need to update the contract...\r\n            uint256 stakerTotalSharesAfter =\r\n                (\r\n                    (stakerList[_stakerID].tokensStaked / tokensPerShare)\r\n                    + stakerList[_stakerID].bonusShares\r\n                )\r\n                * multiplierList[_currentTier];\r\n\r\n            // Update [Total Tokens Staked, Total Shares] on main contract\r\n            totalTokensStaked += numTokens;\r\n            totalTokensUncollected -= numTokens;\r\n\r\n            if(stakerTotalSharesAfter > stakerTotalSharesBefore)\r\n            {\r\n                totalSharesInStaking += (stakerTotalSharesAfter - stakerTotalSharesBefore);\r\n                _addChange(_stakerID, stakerTotalSharesAfter);\r\n            }\r\n            else if(stakerTotalSharesAfter < stakerTotalSharesBefore)\r\n            {\r\n                totalSharesInStaking -= (stakerTotalSharesBefore - stakerTotalSharesAfter);\r\n                _addChange(_stakerID, stakerTotalSharesAfter);\r\n            }\r\n        }\r\n\r\n        // Update general collection details...\r\n        stakerList[_stakerID].lastCollectedOn = getTime();\r\n        stakerList[_stakerID].lastDistributionID = (dist <= numDistributions) ? dist : numDistributions;\r\n\r\n        // Move the pointer past any cleaned out distributions\r\n        _bumpStartingDistribution();\r\n    }\r\n\r\n    // SECTION: Lock Functionality\r\n\r\n    // Check if a wallet already has a particular package locked...\r\n    function HasPackage(address _wallet, uint256 _packageID) public view returns(bool)\r\n    {\r\n        uint256 ID = walletList[_wallet];\r\n        if(ID != 0 && _getLockup(ID, _packageID) != 0) return true;\r\n        return false;\r\n    }\r\n\r\n    // Get a particular package locked for a staker...\r\n    function _getLockup(uint256 _stakerID, uint256 _packageID) internal view returns(uint256)\r\n    {\r\n        uint256 curLock = stakerList[_stakerID].lockupCount;\r\n        while(curLock != 0)\r\n        {\r\n            // Return the ID of the specified lockup on this staker\r\n            if(listOfLockups[_stakerID][curLock].packageID == _packageID) return curLock;\r\n            curLock -= 1;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    // Called internally to perform the lockup creation\r\n    // We are adding a new lock to the system for the specified staker (if they exist)\r\n    function _addLockup(uint256 _stakerID, uint256 _packageID) internal\r\n    {\r\n        // This is an internal function and must already been established...\r\n        //if(_stakerID == 0 || _stakerID > numStakers) revert InvalidStaker();\r\n\r\n        stakerList[_stakerID].lockupCount += 1;\r\n        uint256 lockID = stakerList[_stakerID].lockupCount;\r\n        listOfLockups[_stakerID][lockID].packageID = _packageID;\r\n        listOfLockups[_stakerID][lockID].unlockTime = getTime() + packageList[_packageID].lockPeriod;\r\n    }\r\n\r\n    // Get a particular package locked for a staker...\r\n    function _removeLockup(uint256 _stakerID, uint256 _lockupID) internal\r\n    {\r\n        // This is an internal function and must already been established...\r\n        //if(_stakerID == 0 || _stakerID > numStakers) revert InvalidStaker();\r\n        //if(_lockupID == 0 || _lockupID > stakerList[_stakerID].lockupCount) revert InvalidStaker();\r\n\r\n        if(_lockupID < stakerList[_stakerID].lockupCount)\r\n        {\r\n            // Move the last index to this spot\r\n            // Do not need to if we are on the last one...we can just move the pointer only\r\n            listOfLockups[_stakerID][_lockupID] = listOfLockups[_stakerID][stakerList[_stakerID].lockupCount];\r\n        }\r\n        stakerList[_stakerID].lockupCount -= 1;\r\n    }\r\n\r\n    // Get the count of lockups a staker has...\r\n    function GetStakerLockupCount(address _wallet) external view returns(uint256 numLockups)\r\n    {\r\n        return stakerList[walletList[_wallet]].lockupCount;\r\n    }\r\n\r\n    // Get the details of a speific lockup a staker has...\r\n    function GetStakerLockup(address _wallet, uint256 _lockupID) external view returns(Lockup memory)\r\n    {\r\n        return listOfLockups[walletList[_wallet]][_lockupID];\r\n    }\r\n\r\n    // SECTION: Penalty Functionality\r\n\r\n    // Get Penalty Token count for a wallet...\r\n    // We assume first in first out when we destroy penalties as people take those tokens out of the contract\r\n    function GetPenaltyTokens(address _wallet) public view returns(uint256 numTokens)\r\n    {\r\n        uint256 ID = walletList[_wallet];\r\n        if(ID != 0)\r\n        {\r\n            uint256 curPenalty = stakerList[ID].penaltyCount;\r\n            uint256 curTime = getTime();\r\n            while(curPenalty != 0)\r\n            {\r\n                // See if current time is still within the no Penalty After time...\r\n                if(curTime <= listOfPenalties[ID][curPenalty].noPenaltyAfter)\r\n                {\r\n                    // We have to count this one...\r\n                    numTokens += listOfPenalties[ID][curPenalty].tokenAmount;\r\n                }\r\n                curPenalty -= 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Called internally to perform the penalty creation\r\n    function _addPenalty(uint256 _stakerID, uint256 _numTokens) internal returns(uint256 penaltyID)\r\n    {\r\n        // This is an internal function and must already been established...\r\n        //if(_stakerID == 0 || _stakerID > numStakers) revert InvalidStaker();\r\n\r\n        // We are adding a new lock to the system\r\n        stakerList[_stakerID].penaltyCount += 1;\r\n        penaltyID = stakerList[_stakerID].penaltyCount;\r\n        listOfPenalties[_stakerID][penaltyID].tokenAmount = _numTokens;\r\n        listOfPenalties[_stakerID][penaltyID].noPenaltyAfter = getTime() + earlyUnstakeTime;\r\n    }\r\n\r\n    // Called internally to perform the penalty cleanup\r\n    function _cleanPenalties(uint256 _stakerID) internal\r\n    {\r\n        // This is an internal function and must already been established...\r\n        //if(_stakerID == 0 || _stakerID > numStakers) revert InvalidStaker();\r\n\r\n        uint256 curPenalty = stakerList[_stakerID].penaltyCount;\r\n        uint256 curTime = getTime();\r\n        while(curPenalty != 0)\r\n        {\r\n            // See if current time is past the no Penalty After time...\r\n            // Or the number of tokens has been reduced to zero from an unstake\r\n            if(curTime > listOfPenalties[_stakerID][curPenalty].noPenaltyAfter || (listOfPenalties[_stakerID][curPenalty].tokenAmount == 0))\r\n            {\r\n                // We can get rid of this one...\r\n                if(curPenalty < stakerList[_stakerID].penaltyCount)\r\n                {\r\n                    // Move the last index to this spot\r\n                    // Do not need to if we are on the last one...we can just move the pointer only\r\n                    listOfPenalties[_stakerID][curPenalty] = listOfPenalties[_stakerID][stakerList[_stakerID].penaltyCount];\r\n                }\r\n                stakerList[_stakerID].penaltyCount -= 1;\r\n            }\r\n            curPenalty -= 1;\r\n        }\r\n    }\r\n\r\n    // Called internally to perform the penalty cleanup\r\n    function _oldestPenalty(uint256 _stakerID) internal view returns(uint256 oldestID)\r\n    {\r\n        uint256 curPenalty = stakerList[_stakerID].penaltyCount;\r\n        if(curPenalty == 0) return 0;\r\n\r\n        uint256 curTime = getTime();\r\n        uint256 oldestTime = 0;\r\n        while(curPenalty != 0)\r\n        {\r\n            // See if current time is before the no Penalty After time...\r\n            // And the number of tokens has been reduced to zero from an unstake\r\n            if(curTime < listOfPenalties[_stakerID][curPenalty].noPenaltyAfter && (listOfPenalties[_stakerID][curPenalty].tokenAmount != 0))\r\n            {\r\n                // Found the first one...\r\n                if(oldestTime == 0)\r\n                {\r\n                    oldestTime = listOfPenalties[_stakerID][curPenalty].noPenaltyAfter;\r\n                    oldestID = curPenalty;\r\n                }\r\n                // See if this one is going to go away sooner...\r\n                else if(listOfPenalties[_stakerID][curPenalty].noPenaltyAfter < oldestTime)\r\n                {\r\n                    oldestTime = listOfPenalties[_stakerID][curPenalty].noPenaltyAfter;\r\n                    oldestID = curPenalty;\r\n                }\r\n            }\r\n            curPenalty -= 1;\r\n        }\r\n        // At this point, oldestID is a pointer to the soonest to expire...\r\n    }\r\n\r\n    // Get the count of penalties a staker has...\r\n    function GetStakerPenaltyCount(address _wallet) external view returns(uint256)\r\n    {\r\n        return stakerList[walletList[_wallet]].penaltyCount;\r\n    }\r\n\r\n    // Get the details of a speific penalty a staker has...\r\n    function GetStakerPenalty(address _wallet, uint256 _penaltyID) external view returns(Penalty memory)\r\n    {\r\n        return listOfPenalties[walletList[_wallet]][_penaltyID];\r\n    }\r\n\r\n    // SECTION: Package Functionality\r\n\r\n    // Add or Adjust a package in the list\r\n    // Note: Pass ID of 0 to add a new package\r\n    // Note: if adjusting and lockCount != 0...then all parameters other than dates will be ignored\r\n    function AddOrAdjustPackage(\r\n        uint256 _packageID,              // Which package to adjust\r\n        uint256 _startAfter,             // Block/Time this package becomes available (0 = start immediately)\r\n        uint256 _endAfter,               // Block/Time this package can no longer be selected (0 = does not end)\r\n        uint256 _amountToLock,           // Number of Tokens the package will lock up\r\n        uint256 _lockPeriod,             // Number of days the lock will be active for when used\r\n        uint16 _minTier,                 // Must be a certain tier to participate in this bonus package (0 = available to all)\r\n        uint32 _minPackages,             // Must own a certain number of packages (0 = available to all)\r\n        uint64 _maxLocks,                // Maximum times this package can be used in a lock (0 = unlimited)\r\n        uint256 _bonusShares,            // Number of bonus shares granted for locking in this package (can be multiplied)\r\n        uint256 _dbID                    // To handshake later\r\n    ) external onlyAllowedContract\r\n    {\r\n        if(_packageID > packageCount) revert UnknownPackage();\r\n\r\n        if(_packageID == 0)\r\n        {\r\n            packageCount += 1;\r\n            _packageID = packageCount;\r\n        }\r\n        packageList[_packageID].startAfter = _startAfter;\r\n        packageList[_packageID].endAfter = _endAfter;\r\n\r\n        if(packageList[_packageID].lockCount == 0)\r\n        {\r\n            if(_amountToLock == 0) revert InvalidParameter(4);\r\n            if(_lockPeriod == 0) revert InvalidParameter(5);\r\n            packageList[_packageID].amountToLock = _amountToLock;\r\n            packageList[_packageID].lockPeriod = _lockPeriod;\r\n            packageList[_packageID].minTier = _minTier;\r\n            packageList[_packageID].minPackages = _minPackages;\r\n            packageList[_packageID].bonusShares = _bonusShares;\r\n            packageList[_packageID].maxLocks = _maxLocks;\r\n            packageList[_packageID].dbID = _dbID;\r\n        }\r\n        emit PackageUpdated(_packageID, _dbID);\r\n    }\r\n\r\n    function GetPackageCount() view external returns(uint256)\r\n    {\r\n        return packageCount;\r\n    }\r\n\r\n    function GetPackage(uint256 _packageID) view external returns(Package memory)\r\n    {\r\n        return packageList[_packageID];\r\n    }\r\n\r\n    // SECTION: Contract Setup\r\n\r\n    // Set up the pointer to the current token contract to use the reward function\r\n    event VSLContractChange(address _contractAddress);\r\n    function SetVSLContract(address _contractAddress) external onlyAllowedContract\r\n    {\r\n        _vslContract = _contractAddress;\r\n        emit VSLContractChange(_contractAddress);\r\n    }\r\n\r\n    // Get the pointer to the current token contract to use the reward function\r\n    function GetVSLContract() view external onlyAllowedContract returns(address _contractAddress)\r\n    {\r\n        _contractAddress = _vslContract;\r\n    }\r\n\r\n    // Set up the pointer to the current token contract to use the only Architect modifier\r\n    event VetterContractChange(address _contractAddress);\r\n    function SetVetterContract(address _contractAddress) external onlyAllowedContract\r\n    {\r\n        _vetterContract = _contractAddress;\r\n        _vetterToken = VetterToken(_contractAddress);\r\n        emit VetterContractChange(_contractAddress);\r\n    }\r\n\r\n    // Get the pointer to the current token contract to use the only Architect modifier\r\n    function GetVetterContract() view external onlyAllowedContract returns(address _contractAddress)\r\n    {\r\n        _contractAddress = _vetterContract;\r\n    }\r\n\r\n    // SECTION: Multiplier Setup...\r\n\r\n    // Get current multiplier for the specified tier\r\n    function GetTierMultiplier(uint256 _tier) external view returns (uint256 multiplyBy)\r\n    {\r\n        multiplyBy = multiplierList[_tier];\r\n    }\r\n\r\n    // Set current multiplier for the specified tier\r\n    event TierMultiplierSet(uint256 _tier, uint256 _multiplyBy);\r\n    function SetTierMultiplier(uint256 _tier, uint256 _multiplyBy) external onlyAllowedContract\r\n    {\r\n        multiplierList[_tier] = _multiplyBy;\r\n        emit TierMultiplierSet(_tier, _multiplyBy);\r\n    }\r\n\r\n    // SECTION: General Getters and Setters...\r\n\r\n    // Getter for the Staking Transfer Fee\r\n    function GetStakingTransferFee() external view returns (uint256)\r\n    {\r\n        return stakingTransferFee;\r\n    }\r\n\r\n    // Needed to adjust the fee...be sure to pass in the WEI amount (not 0.2 ether but the equivalent in ether/BNB)\r\n    event StakingTransferFeeSet(uint256 _newTransferFee);\r\n    function SetStakingTransferFee(uint256 _newTransferFee) external onlyAllowedContract\r\n    {\r\n        stakingTransferFee = _newTransferFee;\r\n        emit StakingTransferFeeSet(_newTransferFee);\r\n    }\r\n\r\n    // Getter for the Penalty Reward Amount\r\n    function GetClaimRewardAmount() external view returns (uint256)\r\n    {\r\n        return claimRewardAmount;\r\n    }\r\n\r\n    // Needed to adjust the reward amount...be sure to pass in the token amount (with the 9 digits)\r\n    event ClaimRewardSet(uint256 _claimRewardAmount);\r\n    function SetClaimRewardAmount(uint256 _claimRewardAmount) external onlyAllowedContract\r\n    {\r\n        claimRewardAmount = _claimRewardAmount;\r\n        emit ClaimRewardSet(_claimRewardAmount);\r\n    }\r\n\r\n    // Needed to allow unlocking for migration purposes...\r\n    function GetUnlockAllState() external view returns(bool allUnlocked)\r\n    {\r\n        allUnlocked = allowAllUnlock;\r\n    }\r\n\r\n    // Needed to allow unlocking for migration purposes...\r\n    event UnlockAllSet(bool _allowUnlock);\r\n    function SetUnlockAllState(bool _allowUnlock) external onlyAllowedContract\r\n    {\r\n        allowAllUnlock = _allowUnlock;\r\n        emit UnlockAllSet(_allowUnlock);\r\n    }\r\n\r\n    // Needed to check turning on and off new stakers flag...\r\n    function GetAllowNewStakersState() external view returns(bool newStakersAllowed)\r\n    {\r\n        newStakersAllowed = allowNewStakers;\r\n    }\r\n\r\n    // Needed to allow turning on and off new stakers...\r\n    event AllowNewStakersSet(bool _allowNewStakers);\r\n    function SetAllowNewStakersState(bool _allowNewStakers) external onlyAllowedContract\r\n    {\r\n        allowNewStakers = _allowNewStakers;\r\n        emit AllowNewStakersSet(_allowNewStakers);\r\n    }\r\n\r\n    // Uses the totalTokensUncollected and totalTokensStaked vs. contract balance\r\n    // to determine the number of tokens available for the next distribution...\r\n    function GetTokensToDistribute() public view returns (uint256)\r\n    {\r\n        if(_vslContract == address(0x0)) revert MissingTokenContract();\r\n        return IERC20(_vslContract).balanceOf(address(this)) - totalTokensStaked - totalTokensUncollected - totalTokensPenalized;\r\n    }\r\n\r\n    // Getter for all of the main contract stats...\r\n    // uint256 private totalTokensDistributed;                     // Tokens EVER Distributed (summary kept up to date for easy reference)\r\n    // uint256 private totalTokensUncollected;                     // Tokens Currently Uncollected - In Distributions (summary kept up to date for easy reference)\r\n    // uint256 private totalTokensPenalized;                       // Summary kept up to date for easy reference...\r\n    // uint256 private totalTokensStaked;                          // Summary kept up to date for easy reference...\r\n    // uint256 private totalSharesInStaking;                       // Summary kept up to date for easy reference...\r\n    // uint256 private currentStakerCount;                         // Running total of the wallets in staking currently\r\n    function GetContractDetails() external view returns(\r\n        uint256 _totalTokensDistributed, uint256 _totalTokensUncollected, uint256 _totalTokensPenalized,\r\n        uint256 _totalTokensStaked, uint256 _totalSharesInStaking, uint256 _currentStakerCount\r\n    )\r\n    {\r\n        _totalTokensDistributed = totalTokensDistributed;\r\n        _totalTokensUncollected = totalTokensUncollected;\r\n        _totalTokensPenalized = totalTokensPenalized;\r\n        _totalTokensStaked = totalTokensStaked;\r\n        _totalSharesInStaking = totalSharesInStaking;\r\n        _currentStakerCount = currentStakerCount;\r\n    }\r\n\r\n    // Getter for all of the adjustable contract stats...\r\n    // uint256 private earlyUnstakeTime = 3 days;                  // Configurable time before unstake has a penalty\r\n    // uint256 private earlyUnstakePenalty = 20;                   // Percent lost/burned on early unstake\r\n    // uint256 private oldAfterTime = 30 days;                     // Configurable time before a distribution ages out and can't be collected (tokens burned)\r\n    // uint256 private stakingTransferFee = 0.1 ether;             // Configurable cost of transferring wallets (to keep staking lockups)\r\n    // uint256 private claimRewardAmount = 100000000000;         // Configurable token amount for rewards (starts at 100 VSL tokens)\r\n    function GetAdjustableDetails() external view returns(\r\n        uint256 _earlyUnstakeTime, uint256 _earlyUnstakePenalty, uint256 _oldAfterTime, uint256 _stakingTransferFee, uint256 _claimRewardAmount\r\n    )\r\n    {\r\n        _earlyUnstakeTime = earlyUnstakeTime;\r\n        _earlyUnstakePenalty = earlyUnstakePenalty;\r\n        _oldAfterTime = oldAfterTime;\r\n        _stakingTransferFee = stakingTransferFee;\r\n        _claimRewardAmount = claimRewardAmount;\r\n    }\r\n\r\n    // Tokens EVER Distributed (summary kept up to date for easy reference)\r\n    function GetTotalTokensEverDistributed() external view returns (uint256)\r\n    {\r\n        return totalTokensDistributed;\r\n    }\r\n\r\n    // Tokens Currently Uncollected - Still In Distributions\r\n    function GetTotalTokensUncollected() external view returns (uint256)\r\n    {\r\n        return totalTokensUncollected;\r\n    }\r\n\r\n    // Tokens on the contract in the Currently Panalized pool\r\n    function GetTotalTokensPenalized() external view returns (uint256)\r\n    {\r\n        return totalTokensPenalized;\r\n    }\r\n\r\n    // Number of Stakers with stakes still on the contract\r\n    function GetCurrentStakerCount() external view returns (uint256)\r\n    {\r\n        return currentStakerCount;\r\n    }\r\n\r\n    // Used to see the total number of tokens in the staking pool currently\r\n    function GetTotalTokensStaked() external view returns (uint256)\r\n    {\r\n        return totalTokensStaked;\r\n    }\r\n\r\n    // Used to see the total number of shares in the staking pool at any time...\r\n    function GetTotalSharesInStaking() external view returns (uint256)\r\n    {\r\n        return totalSharesInStaking;\r\n    }\r\n\r\n    // Configurable time before unstake has a penalty (defaults to 3 days)\r\n    function GetEarlyUnstakeTime() external view returns (uint256)\r\n    {\r\n        return earlyUnstakeTime;\r\n    }\r\n\r\n    // Used to set the number of days before a unstake can be pulled without triggering a penalty\r\n    event EarlyUnstakeTimeSet(uint256 _unstakeTime);\r\n    function SetEarlyUnstakeTime(uint256 _unstakeTime) external onlyAllowedContract\r\n    {\r\n        earlyUnstakeTime = _unstakeTime; // Should be the time equivalent of the number of days\r\n        emit EarlyUnstakeTimeSet(_unstakeTime);\r\n    }\r\n\r\n    // See what the Percent lost/burned on early unstake is\r\n    function GetEarlyUnstakePenalty() external view returns (uint256)\r\n    {\r\n        return earlyUnstakePenalty;\r\n    }\r\n\r\n    // Get the percentage of tokens to remove for early unstake (whether burned or used elsewhere)\r\n    function CalcEarlyUnstakePenalty(uint256 numberOfTokens) public view returns (uint256)\r\n    {\r\n        return (earlyUnstakePenalty * numberOfTokens) / 100;\r\n    }\r\n\r\n    // Change the percentage lost on an early unstake\r\n    event EarlyUnstakePenaltySet(uint256 _newPercentage);\r\n    function SetEarlyUnstakePenalty(uint256 _newPercentage) external onlyAllowedContract\r\n    {\r\n        earlyUnstakePenalty = _newPercentage;\r\n        emit EarlyUnstakePenaltySet(_newPercentage);\r\n    }\r\n\r\n    // Configurable time before a distribution ages out and can't be collected (tokens may be burned)\r\n    function GetOldAfterTime() external view returns (uint256)\r\n    {\r\n        return oldAfterTime;\r\n    }\r\n\r\n    // Change the time for distributions to age to the point of being allowed to burn\r\n    // default is 30 days...be sure the time passed in represents the correct number of days as time\r\n    event OldAfterSet(uint256 _newTime);\r\n    function SetOldAfterTime(uint256 _newTime) external onlyAllowedContract\r\n    {\r\n        oldAfterTime = _newTime;\r\n        emit OldAfterSet(_newTime);\r\n    }\r\n\r\n    // SECTION: Token and BNB Transfers...\r\n\r\n    function TransferForeignTokens(address _token, address _to, uint256 _maxAmount) external onlyAllowedContract returns (bool _sent)\r\n    {\r\n        // No back door to remove other people's VSL Tokens...they must collect, unlock and unstake their own\r\n        if(_token == _vslContract) return false;\r\n\r\n        // See what we have available...\r\n        uint256 amountToTransfer = IERC20(_token).balanceOf(address(this));\r\n\r\n        // Cap it at the max requested...\r\n        if(_maxAmount != 0 && (amountToTransfer > _maxAmount)) amountToTransfer = _maxAmount;\r\n\r\n        // Perform the send...\r\n        if(amountToTransfer != 0) _sent = IERC20(_token).transfer(_to, amountToTransfer);\r\n        else _sent = false;\r\n    }\r\n\r\n    function TransferInternalAmount(address _to, uint256 _maxAmount) external onlyAllowedContract returns (bool _sent)\r\n    {\r\n        if(_vslContract == address(0x0)) revert MissingTokenContract();\r\n\r\n        // See what we have available...\r\n        uint256 amount = GetTokensToDistribute() + totalTokensPenalized;\r\n\r\n        // Cap it at the max requested...\r\n        if(amount > _maxAmount)\r\n        {\r\n            if((amount - totalTokensPenalized) > _maxAmount) totalTokensPenalized -= _maxAmount - (amount - totalTokensPenalized);\r\n            amount = _maxAmount;\r\n        }\r\n        else totalTokensPenalized = 0;\r\n\r\n        // Perform the send...\r\n        if(amount != 0) _sent = IERC20(_vslContract).transfer(_to, amount);\r\n        else _sent = false;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyHasPackage\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BalanceLow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"parameter\",\"type\":\"uint8\"}],\"name\":\"InvalidParameter\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidStaker\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MissingPackage\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MissingTokenContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoNewStakers\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoPackagesAvailable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoShareHolders\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoTokensAvailable\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"which\",\"type\":\"uint8\"}],\"name\":\"PackageCriteriaMissing\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnknownPackage\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnlockingTooEarly\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_allowNewStakers\",\"type\":\"bool\"}],\"name\":\"AllowNewStakersSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_allowOrNot\",\"type\":\"bool\"}],\"name\":\"AllowedContractChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"ChangeReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_claimRewardAmount\",\"type\":\"uint256\"}],\"name\":\"ClaimRewardSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"dbID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"limitOnDistributions\",\"type\":\"uint256\"}],\"name\":\"Collected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"limitOnDistributions\",\"type\":\"uint256\"}],\"name\":\"CollectedByWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"}],\"name\":\"ConsolidateAndBurn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"distributionID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensDistributed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensPerShare\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"}],\"name\":\"Distributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newPercentage\",\"type\":\"uint256\"}],\"name\":\"EarlyUnstakePenaltySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_unstakeTime\",\"type\":\"uint256\"}],\"name\":\"EarlyUnstakeTimeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"packageID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"Locked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newTime\",\"type\":\"uint256\"}],\"name\":\"OldAfterSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"packageID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"dbID\",\"type\":\"uint256\"}],\"name\":\"PackageUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newTransferFee\",\"type\":\"uint256\"}],\"name\":\"StakingTransferFeeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"StakingTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tier\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_multiplyBy\",\"type\":\"uint256\"}],\"name\":\"TierMultiplierSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"packageID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"UnLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_allowUnlock\",\"type\":\"bool\"}],\"name\":\"UnlockAllSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"}],\"name\":\"VSLContractChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"}],\"name\":\"VetterContractChange\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_packageID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startAfter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endAfter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountToLock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lockPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_minTier\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"_minPackages\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"_maxLocks\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"_bonusShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_dbID\",\"type\":\"uint256\"}],\"name\":\"AddOrAdjustPackage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numberOfTokens\",\"type\":\"uint256\"}],\"name\":\"CalcEarlyUnstakePenalty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"forceIt\",\"type\":\"bool\"}],\"name\":\"CheckTierChange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_limitDistributions\",\"type\":\"uint256\"}],\"name\":\"CollectByWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbID\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"wallets\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"isRandom\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_limitDistributions\",\"type\":\"uint256\"}],\"name\":\"CollectTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxToProcess\",\"type\":\"uint256\"}],\"name\":\"ConsolidateAndBurnDistributions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxToProcess\",\"type\":\"uint256\"}],\"name\":\"DistributeStakingRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetAdjustableDetails\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_earlyUnstakeTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_earlyUnstakePenalty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_oldAfterTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stakingTransferFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_claimRewardAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetAllAllowedAddresses\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"stillAllowed\",\"type\":\"bool\"}],\"internalType\":\"struct Allowable.Allowed[]\",\"name\":\"allowanceDetails\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetAllowNewStakersState\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"newStakersAllowed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"GetAllowedID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"allowedID\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetClaimRewardAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"GetCollectableTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetContractDetails\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalTokensDistributed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalTokensUncollected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalTokensPenalized\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalTokensStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalSharesInStaking\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_currentStakerCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetCurrentStakerCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_distributionID\",\"type\":\"uint256\"}],\"name\":\"GetDistribution\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timeDistributed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"originalDistribution\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountRemaining\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokensPerShare\",\"type\":\"uint256\"}],\"internalType\":\"struct VSLStaking.Distribution\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetEarlyUnstakePenalty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetEarlyUnstakeTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetFirstDistribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"GetLastCollectedTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lastCollected\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetLastDistribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetLastDistributionTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"last\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetNumberOfBurnableDistributions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"numberToBurn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokensToBurn\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetOldAfterTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_packageID\",\"type\":\"uint256\"}],\"name\":\"GetPackage\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"startAfter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAfter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountToLock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"minTier\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"minPackages\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"maxLocks\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"lockCount\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"bonusShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbID\",\"type\":\"uint256\"}],\"internalType\":\"struct VSLStaking.Package\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetPackageCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"GetPenaltyTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetRemainingDistributions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"GetShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"base\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"multiplier\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakerID\",\"type\":\"uint256\"}],\"name\":\"GetStakerByID\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"firstChange\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastChange\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockupCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"penaltyCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentTier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokensCollected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokensLocked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokensStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastDistributionID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastCollectedOn\",\"type\":\"uint256\"}],\"internalType\":\"struct VSLStaking.Staker\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"GetStakerByWallet\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"firstChange\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastChange\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockupCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"penaltyCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonusShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentTier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokensCollected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokensLocked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokensStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastDistributionID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastCollectedOn\",\"type\":\"uint256\"}],\"internalType\":\"struct VSLStaking.Staker\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetStakerCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"GetStakerID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_lockupID\",\"type\":\"uint256\"}],\"name\":\"GetStakerLockup\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"packageID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"}],\"internalType\":\"struct VSLStaking.Lockup\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"GetStakerLockupCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"numLockups\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_penaltyID\",\"type\":\"uint256\"}],\"name\":\"GetStakerPenalty\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"noPenaltyAfter\",\"type\":\"uint256\"}],\"internalType\":\"struct VSLStaking.Penalty\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"GetStakerPenaltyCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakerID\",\"type\":\"uint256\"}],\"name\":\"GetStakerWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetStakingTransferFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tier\",\"type\":\"uint256\"}],\"name\":\"GetTierMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"multiplyBy\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetTokensToDistribute\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetTotalSharesInStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetTotalTokensEverDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetTotalTokensPenalized\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetTotalTokensStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetTotalTokensUncollected\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetUnlockAllState\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"allUnlocked\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetVSLContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetVetterContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_packageID\",\"type\":\"uint256\"}],\"name\":\"HasPackage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"InternalTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"IsAddressInList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"addressInList\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"IsAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"addressAllowed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_packageID\",\"type\":\"uint256\"}],\"name\":\"LockTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_allowNewStakers\",\"type\":\"bool\"}],\"name\":\"SetAllowNewStakersState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_claimRewardAmount\",\"type\":\"uint256\"}],\"name\":\"SetClaimRewardAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newPercentage\",\"type\":\"uint256\"}],\"name\":\"SetEarlyUnstakePenalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_unstakeTime\",\"type\":\"uint256\"}],\"name\":\"SetEarlyUnstakeTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newTime\",\"type\":\"uint256\"}],\"name\":\"SetOldAfterTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newTransferFee\",\"type\":\"uint256\"}],\"name\":\"SetStakingTransferFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_multiplyBy\",\"type\":\"uint256\"}],\"name\":\"SetTierMultiplier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_allowUnlock\",\"type\":\"bool\"}],\"name\":\"SetUnlockAllState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"}],\"name\":\"SetVSLContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"}],\"name\":\"SetVetterContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_allowOrNot\",\"type\":\"bool\"}],\"name\":\"SetupAllowedContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_numTokens\",\"type\":\"uint256\"}],\"name\":\"StakeTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxAmount\",\"type\":\"uint256\"}],\"name\":\"TransferBNBToAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxAmount\",\"type\":\"uint256\"}],\"name\":\"TransferForeignTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_sent\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_maxAmount\",\"type\":\"uint256\"}],\"name\":\"TransferInternalAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_sent\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"TransferStaking\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_packageID\",\"type\":\"uint256\"}],\"name\":\"UnlockTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_numTokens\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_okToTakePenalty\",\"type\":\"bool\"}],\"name\":\"UnstakeTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_numDays\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_numHours\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_numMinutes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_numSeconds\",\"type\":\"uint256\"}],\"name\":\"convertToTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "VSLStaking", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://79dccef059cbda607faecd69ee684624189dc158036057bc9e7152a216882260"}