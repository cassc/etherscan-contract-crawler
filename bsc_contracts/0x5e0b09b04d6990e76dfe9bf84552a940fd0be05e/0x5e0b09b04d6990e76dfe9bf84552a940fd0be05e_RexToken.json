{"SourceCode": "// SPDX-License-Identifier: --\ud83e\udd34--\r\n\r\npragma solidity ^0.7.4;\r\n\r\n/*\r\n ______      _______   ____    ____\r\n|   __  \\   |    ___|  \\   \\  /   /\r\n|  |__|  |  |   |___    \\   \\/   /\r\n|       /   |   |___    /   /\\   \\\r\n|__|\\ ___\\  |_______|  /___/  \\___\\\r\n\r\nLatin: king, ruler, monarch\r\n\r\nName      :: REX\r\nTicker    :: REX\r\nDecimals  :: 18\r\n\r\nWebsite   :: https://www.rex-token.com\r\nTelegram  :: https://t.me/eth_rex\r\nTwitter   :: https://twitter.com/rex_token\r\nDiscord   :: https://discord.gg/YYy4K3pTye\r\n\r\nConcept   :: HYBRID-INTEREST TIME DEPOSITS\r\nSpecial   :: RANDOM PERSONAL Big Pay Days\r\nCategory  :: Passive Income\r\n\r\n\r\nREX\r\nCryptocurrency & Certificate of Deposit\r\nThe world's most flexible token.\r\n\r\nREX is a cryptocurrency token for storing and transfering value.\r\nIn addition, REX has built-in functions to deposit REX tokens in\r\norder to gain interest. In this manner, REX may be regarded as a\r\nCertificate of Deposit (CD).\r\n\r\nREX is the world's only CD token that lets you create time deposits,\r\nname them, scrape off interest before maturity, split them and even\r\ntransfer them to other addresses. This makes REX a most flexible and\r\npowerful ecosystem for decentralized value transfers.\r\n\r\n\u2713  REX is an immutable smart contract.\r\n\u2713  REX provides its own BEP-20 / ERC-20 token, called $REX.\r\n\u2713  REX has no owner, no admin and cannot be switched off.\r\n\u2713  REX provides daily auctions for transforming $BNB to $REX.\r\n\u2713  REX provides brand new functions for time deposits of $REX.\r\n\u2713  REX provides new hybrid-interest time deposits.\r\n\u2713  REX time deposits (\"staking\") gain more $REX.\r\n\u2713  REX auction participants may get $REX and $BNB.\r\n\u2713  REX has no fixed BigPayDays to avoid price dumps.\r\n\u2713  REX introduces \u201crandom personal BigPayDays\u201d.\r\n\u2713  REX allows scraping off interest from immature deposits.\r\n\u2713  REX allows moving deposits to other addresses.\r\n\u2713  REX allows splitting deposits into two.\r\n\u2713  REX lets referrers claim 10% $REX rewards.\r\n\u2713  REX lets referrers claim 4%-6% $BNB rewards in addition.\r\n\u2713  REX tokens are free for the first 8,000 holders.\r\n\r\nUse rex-token.com for interacting with this contract.\r\nFind the ::REXpaper:: for more information.\r\n\r\n*/\r\n\r\ninterface IBEP20 {\r\n  /**\r\n   * @dev Returns the amount of tokens in existence.\r\n   */\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the token decimals.\r\n   */\r\n  function decimals() external view returns (uint8);\r\n\r\n  /**\r\n   * @dev Returns the token symbol.\r\n   */\r\n  function symbol() external view returns (string memory);\r\n\r\n  /**\r\n  * @dev Returns the token name.\r\n  */\r\n  function name() external view returns (string memory);\r\n\r\n  /**\r\n   * @dev Returns the amount of tokens owned by `account`.\r\n   */\r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Returns the remaining number of tokens that `spender` will be\r\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n   * zero by default.\r\n   *\r\n   * This value changes when {approve} or {transferFrom} are called.\r\n   */\r\n  function allowance(address _owner, address spender) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n   * that someone may use both the old and the new allowance by unfortunate\r\n   * transaction ordering. One possible solution to mitigate this race\r\n   * condition is to first reduce the spender's allowance to 0 and set the\r\n   * desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   *\r\n   * Emits an {Approval} event.\r\n   */\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n   * allowance mechanism. `amount` is then deducted from the caller's\r\n   * allowance.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n   * another (`to`).\r\n   *\r\n   * Note that `value` may be zero.\r\n   */\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  /**\r\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n   * a call to {approve}. `value` is the new allowance.\r\n   */\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n  function _msgSender() internal view returns (address payable) {\r\n    return msg.sender;\r\n  }\r\n\r\n  function _msgData() internal view returns (bytes memory) {\r\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n    return msg.data;\r\n  }\r\n}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n  /**\r\n   * @dev Returns the addition of two unsigned integers, reverting on\r\n   * overflow.\r\n   *\r\n   * Counterpart to Solidity's `+` operator.\r\n   *\r\n   * Requirements:\r\n   * - Addition cannot overflow.\r\n   */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the subtraction of two unsigned integers, reverting on\r\n   * overflow (when the result is negative).\r\n   *\r\n   * Counterpart to Solidity's `-` operator.\r\n   *\r\n   * Requirements:\r\n   * - Subtraction cannot overflow.\r\n   */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return sub(a, b, \"SafeMath: subtraction overflow\");\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n   * overflow (when the result is negative).\r\n   *\r\n   * Counterpart to Solidity's `-` operator.\r\n   *\r\n   * Requirements:\r\n   * - Subtraction cannot overflow.\r\n   */\r\n  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    require(b <= a, errorMessage);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the multiplication of two unsigned integers, reverting on\r\n   * overflow.\r\n   *\r\n   * Counterpart to Solidity's `*` operator.\r\n   *\r\n   * Requirements:\r\n   * - Multiplication cannot overflow.\r\n   */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the integer division of two unsigned integers. Reverts on\r\n   * division by zero. The result is rounded towards zero.\r\n   *\r\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n   * uses an invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return div(a, b, \"SafeMath: division by zero\");\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n   * division by zero. The result is rounded towards zero.\r\n   *\r\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n   * uses an invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    // Solidity only automatically asserts when dividing by 0\r\n    require(b > 0, errorMessage);\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n   * Reverts when dividing by zero.\r\n   *\r\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n   * invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return mod(a, b, \"SafeMath: modulo by zero\");\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n   * Reverts with custom message when dividing by zero.\r\n   *\r\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n   * invalid opcode to revert (consuming all remaining gas).\r\n   *\r\n   * Requirements:\r\n   * - The divisor cannot be zero.\r\n   */\r\n  function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    require(b != 0, errorMessage);\r\n    return a % b;\r\n  }\r\n}\r\n\r\nlibrary SafeMath32 {\r\n\r\n    function add(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        uint32 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function sub(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        require(b <= a);\r\n        uint32 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint32 a, uint32 b) internal pure returns (uint32) {\r\n\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint32 c = a * b;\r\n        require(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        require(b > 0);\r\n        uint32 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function mod(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract BEP20Token is Context {\r\n  using SafeMath for uint256;\r\n\r\n  mapping (address => uint256) private _balances;\r\n  mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n  uint256 private _totalSupply = 0;\r\n  uint8 private _decimals = 18;\r\n  string private _symbol;\r\n  string private _name;\r\n\r\n  event Transfer(\r\n      address indexed from,\r\n      address indexed to,\r\n      uint256 value\r\n  );\r\n\r\n  event Approval(\r\n      address indexed owner,\r\n      address indexed spender,\r\n      uint256 value\r\n  );\r\n\r\n  constructor (string memory tokenName, string memory tokenSymbol) {\r\n    _name = tokenName;\r\n    _symbol = tokenSymbol;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the token decimals.\r\n   */\r\n  function decimals() external view returns (uint8) {\r\n    return _decimals;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the token symbol.\r\n   */\r\n  function symbol() external view returns (string memory) {\r\n    return _symbol;\r\n  }\r\n\r\n  /**\r\n  * @dev Returns the token name.\r\n  */\r\n  function name() external view returns (string memory) {\r\n    return _name;\r\n  }\r\n\r\n  /**\r\n   * @dev See {BEP20-totalSupply}.\r\n   */\r\n  function totalSupply() public view returns (uint256) {\r\n    return _totalSupply;\r\n  }\r\n\r\n  /**\r\n   * @dev See {BEP20-balanceOf}.\r\n   */\r\n  function balanceOf(address account) external view returns (uint256) {\r\n    return _balances[account];\r\n  }\r\n\r\n  /**\r\n   * @dev See {BEP20-transfer}.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `recipient` cannot be the zero address.\r\n   * - the caller must have a balance of at least `amount`.\r\n   */\r\n  function transfer(address recipient, uint256 amount) external returns (bool) {\r\n    _transfer(_msgSender(), recipient, amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev See {BEP20-allowance}.\r\n   */\r\n  function allowance(address owner, address spender) external view returns (uint256) {\r\n    return _allowances[owner][spender];\r\n  }\r\n\r\n  /**\r\n   * @dev See {BEP20-approve}.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `spender` cannot be the zero address.\r\n   */\r\n  function approve(address spender, uint256 amount) external returns (bool) {\r\n    _approve(_msgSender(), spender, amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev See {BEP20-transferFrom}.\r\n   *\r\n   * Emits an {Approval} event indicating the updated allowance. This is not\r\n   * required by the EIP. See the note at the beginning of {BEP20};\r\n   *\r\n   * Requirements:\r\n   * - `sender` and `recipient` cannot be the zero address.\r\n   * - `sender` must have a balance of at least `amount`.\r\n   * - the caller must have allowance for `sender`'s tokens of at least\r\n   * `amount`.\r\n   */\r\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) {\r\n    _transfer(sender, recipient, amount);\r\n    _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"BEP20: transfer amount exceeds allowance\"));\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n   *\r\n   * This is an alternative to {approve} that can be used as a mitigation for\r\n   * problems described in {BEP20-approve}.\r\n   *\r\n   * Emits an {Approval} event indicating the updated allowance.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `spender` cannot be the zero address.\r\n   */\r\n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n   *\r\n   * This is an alternative to {approve} that can be used as a mitigation for\r\n   * problems described in {BEP20-approve}.\r\n   *\r\n   * Emits an {Approval} event indicating the updated allowance.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `spender` cannot be the zero address.\r\n   * - `spender` must have allowance for the caller of at least\r\n   * `subtractedValue`.\r\n   */\r\n  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"BEP20: decreased allowance below zero\"));\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n   *\r\n   * This is internal function is equivalent to {transfer}, and can be used to\r\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `sender` cannot be the zero address.\r\n   * - `recipient` cannot be the zero address.\r\n   * - `sender` must have a balance of at least `amount`.\r\n   */\r\n  function _transfer(address sender, address recipient, uint256 amount) internal {\r\n    require(sender != address(0), \"BEP20: transfer from the zero address\");\r\n    require(recipient != address(0), \"BEP20: transfer to the zero address\");\r\n\r\n    _balances[sender] = _balances[sender].sub(amount, \"BEP20: transfer amount exceeds balance\");\r\n    _balances[recipient] = _balances[recipient].add(amount);\r\n    emit Transfer(sender, recipient, amount);\r\n  }\r\n\r\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n   * the total supply.\r\n   *\r\n   * Emits a {Transfer} event with `from` set to the zero address.\r\n   *\r\n   * Requirements\r\n   *\r\n   * - `to` cannot be the zero address.\r\n   */\r\n  function _mint(address account, uint256 amount) internal {\r\n    require(account != address(0), \"BEP20: mint to the zero address\");\r\n\r\n    _totalSupply = _totalSupply.add(amount);\r\n    _balances[account] = _balances[account].add(amount);\r\n    emit Transfer(address(0), account, amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Destroys `amount` tokens from `account`, reducing the\r\n   * total supply.\r\n   *\r\n   * Emits a {Transfer} event with `to` set to the zero address.\r\n   *\r\n   * Requirements\r\n   *\r\n   * - `account` cannot be the zero address.\r\n   * - `account` must have at least `amount` tokens.\r\n   */\r\n  function _burn(address account, uint256 amount) internal {\r\n    require(account != address(0), \"BEP20: burn from the zero address\");\r\n\r\n    _balances[account] = _balances[account].sub(amount, \"BEP20: burn amount exceeds balance\");\r\n    _totalSupply = _totalSupply.sub(amount);\r\n    emit Transfer(account, address(0), amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n   *\r\n   * This is internal function is equivalent to `approve`, and can be used to\r\n   * e.g. set automatic allowances for certain subsystems, etc.\r\n   *\r\n   * Emits an {Approval} event.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `owner` cannot be the zero address.\r\n   * - `spender` cannot be the zero address.\r\n   */\r\n  function _approve(address owner, address spender, uint256 amount) internal {\r\n    require(owner != address(0), \"BEP20: approve from the zero address\");\r\n    require(spender != address(0), \"BEP20: approve to the zero address\");\r\n\r\n    _allowances[owner][spender] = amount;\r\n    emit Approval(owner, spender, amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\r\n   * from the caller's allowance.\r\n   *\r\n   * See {_burn} and {_approve}.\r\n   */\r\n  function _burnFrom(address account, uint256 amount) internal {\r\n    _burn(account, amount);\r\n    _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"BEP20: burn amount exceeds allowance\"));\r\n  }\r\n}\r\n\r\ncontract Events {\r\n\r\n    event StakeStarted(\r\n        bytes16 indexed stakeID,\r\n        address indexed stakerAddress,\r\n        uint256 stakedAmount,\r\n        uint256 stakesShares,\r\n        uint32 startDay,\r\n        uint32 stakingDays\r\n    );\r\n\r\n    event StakeEnded(\r\n        bytes16 indexed stakeID,\r\n        address indexed stakerAddress,\r\n        uint256 stakedAmount,\r\n        uint256 stakesShares,\r\n        uint256 rewardAmount,\r\n        uint32 closeDay,\r\n        uint256 penaltyAmount\r\n    );\r\n\r\n    event InterestScraped(\r\n        bytes16 indexed stakeID,\r\n        address indexed stakerAddress,\r\n        uint256 scrapeAmount,\r\n        uint32 scrapeDay,\r\n        uint256 stakersPenalty,\r\n        uint32 currentRexDay\r\n    );\r\n\r\n    event TokensClaimed(\r\n        address indexed claimer,\r\n        uint256 claimAmount,\r\n        uint32 day\r\n    );\r\n\r\n    event NewGlobals(\r\n        uint256 totalShares,\r\n        uint256 totalStaked,\r\n        uint256 totalClaimed,\r\n        uint256 shareRate,\r\n        uint32 indexed currentRexDay\r\n    );\r\n\r\n    event NewSharePrice(\r\n        uint256 newSharePrice,\r\n        uint256 oldSharePrice,\r\n        uint32 currentRexDay\r\n    );\r\n\r\n}\r\n\r\nabstract contract Global is BEP20Token, Events {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    struct Globals {\r\n        uint256 totalStaked;\r\n        uint256 totalShares;\r\n        uint256 totalClaimed;\r\n        uint256 sharePrice;\r\n        uint32 currentRexDay;\r\n    }\r\n\r\n    Globals public globals;\r\n\r\n    constructor() {\r\n        globals.sharePrice = 1E17;   // = 0.1 BNB\r\n    }\r\n\r\n    function _increaseClaimedAmount(uint256 _claimedTokens) internal {\r\n        globals.totalClaimed = globals.totalClaimed.add(_claimedTokens);\r\n    }\r\n\r\n    function _increaseGlobals(\r\n        uint256 _staked,\r\n        uint256 _shares\r\n    )\r\n        internal\r\n    {\r\n        globals.totalStaked = globals.totalStaked.add(_staked);\r\n        globals.totalShares = globals.totalShares.add(_shares);\r\n        _logGlobals();\r\n    }\r\n\r\n    function _decreaseGlobals(\r\n        uint256 _staked,\r\n        uint256 _shares\r\n    )\r\n        internal\r\n    {\r\n        globals.totalStaked =\r\n        globals.totalStaked > _staked ?\r\n        globals.totalStaked - _staked : 0;\r\n\r\n        globals.totalShares =\r\n        globals.totalShares > _shares ?\r\n        globals.totalShares - _shares : 0;\r\n\r\n        _logGlobals();\r\n    }\r\n\r\n    function _logGlobals()\r\n        private\r\n    {\r\n        emit NewGlobals(\r\n            globals.totalShares,\r\n            globals.totalStaked,\r\n            globals.totalClaimed,\r\n            globals.sharePrice,\r\n            globals.currentRexDay\r\n        );\r\n    }\r\n}\r\n\r\nabstract contract Declaration is Global {\r\n\r\n    uint256 public LAUNCH_TIME;\r\n    uint256 constant SECONDS_IN_DAY = 86400 seconds;\r\n    uint256 constant CLUB_STAKE_TRESHOLD = 1E5;\r\n    uint256 constant BONUS_PRECISION = 1E8;\r\n    uint256 constant SHARES_PRECISION = 1E10;\r\n    uint256 constant TENTH_OF_BNB = 1E17;\r\n    uint256 constant REWARD_PRECISION = 1E20;\r\n    uint256 constant PRINCES_PER_REX = 1E18;\r\n    uint256 constant PRECISION_RATE = 1E18;\r\n    uint256 constant INITIAL_SHARE_PRICE = TENTH_OF_BNB;\r\n    uint32 constant INFLATION_RATE = 105000; // 5.000%\r\n    uint32 constant INFLATION_DIVISOR = 10000; // 5.000%\r\n\r\n      // REX POOL distributed daily to stakers (REX-BigPayDay)\r\n      // gets filled daily by unclaimed REX and added to penalties on dailyShapshot\r\n    uint256 public unclaimedRexPOOL; // unclaimed REX from FREE CLAIMS get summed up, max. 1M/day are given to stakers\r\n    uint256 DAILY_TRANSFER_CAP = 100000 * PRINCES_PER_REX; // if noone claims, unclaimed will be distributed later\r\n\r\n    uint32 constant MIN_STAKING_DAYS = 1;\r\n    uint32 constant MAX_STAKING_DAYS = 5555;\r\n    uint32 constant MIN_STAKE_AMOUNT = 1000000; // equals 0.000000000001 REX\r\n\r\n    uint32 constant CLAIM_PHASE_START_DAY = 1;  // not before the 1st day, checked by _currentRexDay\r\n    uint32 constant CLAIM_PHASE_END_DAY = 365;\r\n    uint32 constant CLAIMABLE_ETH_ADDRESSES = uint32(8000);\r\n    uint256 constant PRINCES_PER_CLAIM_DAY = 100 * PRINCES_PER_REX;\r\n    uint32 public claimCount;\r\n\r\n    address public RDA_CONTRACT;            // defined later via init after deployment\r\n    IBEP20 public TREX_CONTRACT;            // defined later via init after deployment\r\n    IBEP20 public MREX_CONTRACT;            // defined later via init after deployment\r\n\r\n    constructor() {\r\n        LAUNCH_TIME = 1624096800;        //  Sat Jun 19 2021 10:00:00 GMT+0000\r\n    }\r\n\r\n    struct Stake {\r\n        uint256 stakesShares;\r\n        uint256 stakedAmount;\r\n        uint256 rewardAmount;\r\n        uint256 penaltyAmount;\r\n        uint32 startDay;\r\n        uint32 stakingDays;\r\n        uint32 finalDay;\r\n        uint32 closeDay;\r\n        uint32 scrapeDay;\r\n        bool isActive;\r\n        bool isSplit;\r\n        string description;\r\n    }\r\n\r\n    mapping(address => bool) public addressHasClaimed;\r\n    mapping(address => uint256) public stakeCount;\r\n    mapping(address => uint256) public totalREXinActiveStakes;\r\n    mapping(address => bool) public ultraRexican;\r\n    mapping(address => bool) public clubFive;\r\n    mapping(address => mapping(bytes16 => Stake)) public stakes;\r\n    mapping(address => mapping(bytes16 => uint256)) public scrapes;\r\n\r\n    mapping(uint32 => uint256) public scheduledToEnd;\r\n    mapping(uint32 => uint256) public totalPenalties;\r\n}\r\n\r\nabstract contract Timing is Declaration {\r\n\r\n    function currentRexDay() public view returns (uint32) {\r\n        return _getNow() >= LAUNCH_TIME ? _currentRexDay() : 0;\r\n    }\r\n\r\n    function _currentRexDay() internal view returns (uint32) {\r\n        return _rexDayFromStamp(_getNow());\r\n    }\r\n\r\n    function _nextRexDay() internal view returns (uint32) {\r\n        return _currentRexDay() + 1;\r\n    }\r\n\r\n    function _previousRexDay() internal view returns (uint32) {\r\n        return _currentRexDay() - 1;\r\n    }\r\n\r\n    function _rexDayFromStamp(uint256 _timestamp) internal view returns (uint32) {\r\n        return uint32((_timestamp - LAUNCH_TIME) / SECONDS_IN_DAY);\r\n    }\r\n\r\n    function _getNow() internal view returns (uint256) {\r\n        return block.timestamp;\r\n    }\r\n}\r\n\r\nabstract contract Helper is Timing {\r\n\r\n    using SafeMath for uint256;\r\n    using SafeMath32 for uint32;\r\n\r\n    function _notContract(address _addr) internal view returns (bool) {\r\n        uint32 size;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return (size == 0);\r\n    }\r\n\r\n    function _toBytes16(uint256 x) internal pure returns (bytes16 b) {\r\n       return bytes16(bytes32(x));\r\n    }\r\n\r\n    function generateID(address x, uint256 y, bytes1 z) public pure returns (bytes16 b) {\r\n        b = _toBytes16(\r\n            uint256(\r\n                keccak256(\r\n                    abi.encodePacked(x, y, z)\r\n                )\r\n            )\r\n        );\r\n    }\r\n\r\n    function _generateStakeID(address _staker) internal view returns (bytes16 stakeID) {\r\n        return generateID(_staker, stakeCount[_staker], 0x01);\r\n    }\r\n\r\n    function stakesPagination(\r\n        address _staker,\r\n        uint256 _offset,\r\n        uint256 _length\r\n    )\r\n        external\r\n        view\r\n        returns (bytes16[] memory _stakes)\r\n    {\r\n        uint256 start = _offset > 0 &&\r\n            stakeCount[_staker] > _offset ?\r\n            stakeCount[_staker] - _offset : stakeCount[_staker];\r\n\r\n        uint256 finish = _length > 0 &&\r\n            start > _length ?\r\n            start - _length : 0;\r\n\r\n        uint256 i;\r\n\r\n        _stakes = new bytes16[](start - finish);\r\n\r\n        for (uint256 _stakeIndex = start; _stakeIndex > finish; _stakeIndex--) {\r\n            bytes16 _stakeID = generateID(_staker, _stakeIndex - 1, 0x01);\r\n            if (stakes[_staker][_stakeID].stakedAmount > 0) {\r\n                _stakes[i] = _stakeID; i++;\r\n            }\r\n        }\r\n    }\r\n\r\n    function unclaimedAddresses() public view returns (uint32) {\r\n        return CLAIMABLE_ETH_ADDRESSES - claimCount;\r\n    }\r\n\r\n    function isUltraRexican(address addr) public view returns (bool) {\r\n        return ultraRexican[addr];\r\n    }\r\n\r\n    function latestStakeID(address _staker) external view returns (bytes16) {\r\n        return stakeCount[_staker] == 0 ? bytes16(0) : generateID(_staker, stakeCount[_staker].sub(1), 0x01);\r\n    }\r\n\r\n    function _increaseStakeCount(address _staker) internal {\r\n        stakeCount[_staker] = stakeCount[_staker] + 1;\r\n    }\r\n\r\n    function _isMatureStake(Stake memory _stake) internal view returns (bool) {\r\n        return _stake.closeDay > 0\r\n            ? _stake.finalDay <= _stake.closeDay\r\n            : _stake.finalDay <= _currentRexDay();\r\n    }\r\n\r\n    function _stakeNotStarted(Stake memory _stake) internal view returns (bool) {\r\n        return _stake.closeDay > 0\r\n            ? _stake.startDay > _stake.closeDay\r\n            : _stake.startDay > _currentRexDay();\r\n    }\r\n\r\n    function _stakeEnded(Stake memory _stake) internal view returns (bool) {\r\n        return _stake.isActive == false || _isMatureStake(_stake);\r\n    }\r\n\r\n    function _daysDiff(uint32 _startDate, uint32 _endDate) internal pure returns (uint32) {\r\n        return _startDate > _endDate ? 0 : _endDate.sub(_startDate);\r\n    }\r\n\r\n    function _daysLeft(Stake memory _stake) internal view returns (uint32) {\r\n        return _stake.isActive == false\r\n            ? _daysDiff(_stake.closeDay, _stake.finalDay)\r\n            : _daysDiff(_currentRexDay(), _stake.finalDay);\r\n    }\r\n\r\n    function _calculationDay(Stake memory _stake) internal view returns (uint32) {\r\n        return _stake.finalDay > globals.currentRexDay ? globals.currentRexDay : _stake.finalDay;\r\n    }\r\n\r\n    function _startingDay(Stake memory _stake) internal pure returns (uint32) {\r\n        return _stake.scrapeDay == 0 ? _stake.startDay : _stake.scrapeDay;\r\n    }\r\n\r\n    function _notPast(uint32 _day) internal view returns (bool) {\r\n        return _day >= _currentRexDay();\r\n    }\r\n\r\n    function _notFuture(uint32 _day) internal view returns (bool) {\r\n        return _day <= _currentRexDay();\r\n    }\r\n\r\n    function _nonZeroAddress(address _address) internal pure returns (bool) {\r\n        return _address != address(0x0);\r\n    }\r\n\r\n    function _getStakingDays(Stake memory _stake) internal pure returns (uint32) {\r\n        return\r\n            _stake.stakingDays > 1 ?\r\n            _stake.stakingDays - 1 : 1;\r\n    }\r\n\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    )\r\n        internal\r\n    {\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(\r\n                0xa9059cbb,\r\n                to,\r\n                value\r\n            )\r\n        );\r\n\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool)))\r\n            // 'REX: transfer failed'\r\n        );\r\n    }\r\n}\r\n\r\nabstract contract Snapshot is Helper {\r\n\r\n    using SafeMath for uint256;\r\n    using SafeMath32 for uint32;\r\n\r\n    // normal shares\r\n    struct SnapShot {\r\n        uint256 totalShares;\r\n        uint256 inflationAmount;\r\n        uint256 scheduledToEnd;\r\n    }\r\n\r\n    mapping(uint32 => SnapShot) public snapshots;\r\n\r\n    modifier snapshotTrigger() {\r\n        _dailySnapshotPoint(_currentRexDay());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice allows volunteer to offload snapshots\r\n     * to save on gas during next start/end stake\r\n     */\r\n    function manualDailySnapshot()\r\n        external\r\n    {\r\n        _dailySnapshotPoint(_currentRexDay());\r\n    }\r\n\r\n    /**\r\n     * @notice allows to offload snapshots\r\n     */\r\n    function manualDailySnapshotPoint(\r\n        uint32 _updateDay\r\n    )\r\n        external\r\n    {\r\n        require(\r\n            _updateDay > 0 &&\r\n            _updateDay < _currentRexDay(),\r\n            'REX: Day does not exist yet.'\r\n        );\r\n\r\n        require(\r\n            _updateDay > globals.currentRexDay,\r\n            'REX: snapshot already taken for that day'\r\n        );\r\n\r\n        _dailySnapshotPoint(_updateDay);\r\n    }\r\n\r\n    /**\r\n     * @notice internal function that offloads global values to daily snapshots\r\n     * updates globals.currentRexDay\r\n     */\r\n    function _dailySnapshotPoint(\r\n        uint32 _updateDay\r\n    )\r\n        private\r\n    {\r\n        uint256 totalStakedToday = globals.totalStaked;\r\n        uint256 scheduledToEndToday;\r\n\r\n        for (uint32 _day = globals.currentRexDay; _day < _updateDay; _day++) {\r\n\r\n            scheduledToEndToday = scheduledToEnd[_day] + snapshots[_day - 1].scheduledToEnd;\r\n            SnapShot memory snapshot = snapshots[_day];\r\n            snapshot.scheduledToEnd = scheduledToEndToday;\r\n\r\n            snapshot.totalShares =\r\n                globals.totalShares > scheduledToEndToday ?\r\n                globals.totalShares - scheduledToEndToday : 0;\r\n\r\n            _transferUnclaimedRexToStakers(_day);   // add unclaimed REX to \"totalPenalties\" (increases interest for stakers)\r\n\r\n            snapshot.inflationAmount =  snapshot.totalShares\r\n                .mul(PRECISION_RATE)\r\n                .div(\r\n                    _inflationAmount(\r\n                        totalStakedToday,\r\n                        totalSupply(),\r\n                        totalPenalties[_day]\r\n                    )\r\n                );\r\n\r\n            snapshots[_day] = snapshot;\r\n\r\n            globals.currentRexDay++;\r\n\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice internal function that transfers daily unclaimed REX to penalties (therefore to stakers)\r\n     */\r\n    function _transferUnclaimedRexToStakers(uint32 _day) private {\r\n        if (_day <= CLAIM_PHASE_END_DAY)  // collect unclaimed REX in claim phase and add to pool\r\n        {\r\n            uint256 _unclaimedAddresses = uint256(CLAIMABLE_ETH_ADDRESSES - claimCount); // get number of unclaimed REX addresses\r\n            unclaimedRexPOOL = unclaimedRexPOOL.add(_unclaimedAddresses.mul(PRINCES_PER_CLAIM_DAY)); // add REX to POOL\r\n        }\r\n        if (unclaimedRexPOOL > 0) // transfer capped amount to penalties, subtract from POOL\r\n        {\r\n            uint256 unclaimedGoToStakers = unclaimedRexPOOL > DAILY_TRANSFER_CAP\r\n                ? DAILY_TRANSFER_CAP\r\n                : unclaimedRexPOOL;\r\n            totalPenalties[_day] = totalPenalties[_day].add(unclaimedGoToStakers);\r\n            unclaimedRexPOOL = unclaimedRexPOOL.sub(unclaimedGoToStakers);\r\n        }\r\n    }\r\n\r\n    function _inflationAmount(uint256 _totalStaked, uint256 _totalSupply, uint256 _totalPenalties) private pure returns (uint256) {\r\n        return (_totalStaked + _totalSupply) * INFLATION_DIVISOR / INFLATION_RATE + _totalPenalties;\r\n    }\r\n}\r\n\r\nabstract contract StakingToken is Snapshot {\r\n\r\n    using SafeMath for uint256;\r\n    using SafeMath32 for uint32;\r\n\r\n    /**\r\n     * @notice A function for a staker to create a stake\r\n     * @param _stakedAmount amount of REX staked\r\n     * @param _stakingDays amount of days it is locked\r\n     */\r\n    function createStake(\r\n        uint256 _stakedAmount,\r\n        uint32 _stakingDays,\r\n        string calldata _description\r\n    )\r\n        snapshotTrigger\r\n        public\r\n        returns (bytes16, uint32)\r\n    {\r\n        require(_stakingDays >= MIN_STAKING_DAYS && _stakingDays <= MAX_STAKING_DAYS, 'REX: Stake duration not in range.');\r\n        require(_stakedAmount >= MIN_STAKE_AMOUNT, 'REX: Stake too small.');\r\n\r\n        (\r\n            Stake memory newStake,\r\n            bytes16 stakeID,\r\n            uint32 _startDay\r\n        ) =\r\n\r\n        _createStake(msg.sender, _stakedAmount, _stakingDays, _description);\r\n\r\n        stakes[msg.sender][stakeID] = newStake;\r\n        _increaseStakeCount(msg.sender);\r\n        _increaseGlobals(newStake.stakedAmount, newStake.stakesShares);\r\n        _addScheduledShares(newStake.finalDay, newStake.stakesShares);\r\n        if (_stakingDays == 5555 && newStake.stakedAmount >= CLUB_STAKE_TRESHOLD) { clubFive[msg.sender] = true; }\r\n\r\n        emit StakeStarted(\r\n            stakeID,\r\n            msg.sender,\r\n            newStake.stakedAmount,\r\n            newStake.stakesShares,\r\n            newStake.startDay,\r\n            newStake.stakingDays\r\n        );\r\n\r\n        return (stakeID, _startDay);\r\n    }\r\n\r\n    /**\r\n    * @notice Internal function to create a stake\r\n    */\r\n    function _createStake(\r\n        address _staker,\r\n        uint256 _stakedAmount,\r\n        uint32 _stakingDays,\r\n        string memory _description\r\n    )\r\n        private\r\n        returns (\r\n            Stake memory _newStake,\r\n            bytes16 _stakeID,\r\n            uint32 _startDay\r\n        )\r\n    {\r\n        _burn(_staker, _stakedAmount);\r\n        totalREXinActiveStakes[_staker] = totalREXinActiveStakes[_staker].add(_stakedAmount);\r\n\r\n        _startDay = _nextRexDay();\r\n        _stakeID = _generateStakeID(_staker);\r\n        _newStake.stakingDays = _stakingDays;\r\n        _newStake.startDay = _startDay;\r\n        _newStake.finalDay = _startDay + _stakingDays;\r\n        _newStake.description = _description;\r\n        _newStake.isActive = true;\r\n        _newStake.stakedAmount = _stakedAmount;\r\n\r\n        _newStake.stakesShares = (TREX_CONTRACT.balanceOf(msg.sender) > 0)\r\n            ? _stakesShares(_stakedAmount, _stakingDays, INITIAL_SHARE_PRICE)\r\n            : _stakesShares(_stakedAmount, _stakingDays, globals.sharePrice);\r\n    }\r\n\r\n    /**\r\n    * @notice Internal function to create an \"auto-stake\" for addresses that have free claimed REX\r\n    * Auto-stakes don't count for the randomEBNB calculation, so \"totalREXinActiveStakes\" are not added\r\n    */\r\n    function _createAutoStake(\r\n        address _staker,\r\n        uint256 _stakedAmount,\r\n        uint32 _stakingDays\r\n    )\r\n        internal\r\n    {\r\n        uint32 _startDay = _nextRexDay();\r\n        bytes16 _stakeID = _generateStakeID(_staker);\r\n\r\n        Stake memory _newStake;\r\n        _newStake.stakingDays = _stakingDays;\r\n        _newStake.startDay = _startDay;\r\n        _newStake.finalDay = _startDay + _stakingDays;\r\n        _newStake.description = unicode'\ud83e\udd34 free-claim auto-stake';\r\n        _newStake.isActive = true;\r\n        _newStake.stakedAmount = _stakedAmount;\r\n\r\n        _newStake.stakesShares = (TREX_CONTRACT.balanceOf(msg.sender) > 0)\r\n            ? _stakesShares(_stakedAmount, _stakingDays, INITIAL_SHARE_PRICE)\r\n            : _stakesShares(_stakedAmount, _stakingDays, globals.sharePrice);\r\n\r\n        stakes[_staker][_stakeID] = _newStake;\r\n        _increaseStakeCount(_staker);\r\n        _increaseGlobals(_newStake.stakedAmount, _newStake.stakesShares);\r\n        _addScheduledShares(_newStake.finalDay, _newStake.stakesShares);\r\n\r\n        emit StakeStarted(\r\n            _stakeID,\r\n            _staker,\r\n            _newStake.stakedAmount,\r\n            _newStake.stakesShares,\r\n            _newStake.startDay,\r\n            _newStake.stakingDays\r\n        );\r\n\r\n    }\r\n\r\n    /**\r\n    * @notice A function for a staker to end a stake\r\n    * belonging to their address by providing the stake ID.\r\n    * @param _stakeID unique bytes sequence reference to the stake\r\n    */\r\n    function endStake(\r\n        bytes16 _stakeID\r\n    )\r\n        snapshotTrigger\r\n        external\r\n        returns (uint256)\r\n    {\r\n        (Stake memory endedStake, uint256 penaltyAmount) = _endStake(msg.sender, _stakeID);\r\n        _decreaseGlobals(endedStake.stakedAmount, endedStake.stakesShares);\r\n        _removeScheduledShares(endedStake.finalDay, endedStake.stakesShares);\r\n        if (penaltyAmount > 0) {\r\n            totalPenalties[endedStake.closeDay] = totalPenalties[endedStake.closeDay].add(penaltyAmount);\r\n        }\r\n        _sharePriceUpdate(\r\n            endedStake.stakedAmount > penaltyAmount ?\r\n            endedStake.stakedAmount - penaltyAmount : 0,\r\n            endedStake.rewardAmount + scrapes[msg.sender][_stakeID],\r\n            endedStake.stakingDays,\r\n            endedStake.stakesShares\r\n        );\r\n\r\n        emit StakeEnded(\r\n            _stakeID,\r\n            msg.sender,\r\n            endedStake.stakedAmount,\r\n            endedStake.stakesShares,\r\n            endedStake.rewardAmount,\r\n            endedStake.closeDay,\r\n            penaltyAmount\r\n        );\r\n\r\n        return endedStake.rewardAmount;\r\n    }\r\n\r\n    function _endStake(\r\n        address _staker,\r\n        bytes16 _stakeID\r\n    )\r\n        private\r\n        returns (\r\n            Stake storage _stake,\r\n            uint256 _penalty\r\n        )\r\n    {\r\n        require(stakes[_staker][_stakeID].isActive, 'REX: not an active stake');        // only active stakes can be ended\r\n        string memory _desc = unicode'\ud83e\udd34 free-claim auto-stake';                        // declare string for auto-stake\r\n        bool _autostake = compareStrings(stakes[_staker][_stakeID].description, _desc); // check if stake is auto-stake\r\n        if (_autostake)                                                                 // auto-stake can not be ended before maturity\r\n        {\r\n            require(stakes[_staker][_stakeID].finalDay <= _currentRexDay(), 'REX: Auto-stake not mature.');\r\n        }\r\n\r\n        _stake = stakes[_staker][_stakeID];                       // get stake\r\n        _stake.closeDay = _currentRexDay();                       // set closeDay\r\n        _stake.rewardAmount = _calculateRewardAmount(_stake);     // loop calculates rewards/day (=INTEREST), reduced if early or late claim\r\n        _penalty = _calculatePenaltyAmount(_stake);               // penalty reduces the payout from principal (stakedAmount), if ended before half of maturity\r\n        _stake.penaltyAmount = _penalty;\r\n        _stake.isActive = false;\r\n\r\n          // big long stakes make the staker be in Club5555, ending a big immature stake revokes the status\r\n        if (_stake.stakingDays == 5555 && _stake.stakedAmount >= CLUB_STAKE_TRESHOLD && _isMatureStake(_stake) == false) { clubFive[_staker] = false; }\r\n\r\n          // keep track of the user's REX in active stakes, for calculating BigPayDays in RexDailyAuction contract\r\n        totalREXinActiveStakes[_staker] =\r\n            totalREXinActiveStakes[_staker] >= (_stake.stakedAmount) ?\r\n            totalREXinActiveStakes[_staker].sub(_stake.stakedAmount) : 0;\r\n\r\n          // mint back the principal minus penalties\r\n        _mint(\r\n            _staker,\r\n            _stake.stakedAmount > _penalty ?\r\n            _stake.stakedAmount - _penalty : 0\r\n        );\r\n\r\n          // mint the rewards\r\n        _mint(\r\n            _staker,\r\n            _stake.rewardAmount\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @notice A function for a staker to move an active stake\r\n    * belonging to his address by providing the stake ID, to another address.\r\n    * Not possible if interest has been scraped before.\r\n    * @param _stakeID unique bytes sequence reference to the stake\r\n    * @param _toAddress Receiver of the stake\r\n    */\r\n    function moveStake(\r\n        bytes16 _stakeID,\r\n        address _toAddress\r\n    )\r\n        snapshotTrigger\r\n        external\r\n    {\r\n        require(MREX_CONTRACT.balanceOf(msg.sender) > 0, 'REX: Hodl MREX to be allowed!');\r\n        require(stakes[msg.sender][_stakeID].isActive, 'REX: Not an active stake.');\r\n        require(stakes[msg.sender][_stakeID].scrapeDay == 0, 'REX: No. Already scraped interest.');\r\n        require(_notContract(_toAddress), 'REX: Receiver not an address');\r\n        require(_toAddress != msg.sender, 'REX: Sender equals receiver');\r\n\r\n        Stake memory _temp = stakes[msg.sender][_stakeID];\r\n        Stake memory _newStake;\r\n\r\n        _newStake.stakesShares = _temp.stakesShares;\r\n        _newStake.stakedAmount = _temp.stakedAmount;\r\n        _newStake.startDay = _temp.startDay;\r\n        _newStake.stakingDays = _temp.stakingDays;\r\n        _newStake.finalDay = _temp.finalDay;\r\n        _newStake.closeDay = _temp.closeDay;\r\n        _newStake.scrapeDay = _temp.scrapeDay;\r\n        _newStake.isActive = _temp.isActive;\r\n        _newStake.isSplit = _temp.isSplit;\r\n        _newStake.description = _temp.description;\r\n\r\n        Stake storage _stake = stakes[msg.sender][_stakeID];\r\n        _stake.closeDay = _currentRexDay();\r\n        _stake.description = unicode'MOVED AWAY';\r\n        _stake.isActive = false;\r\n\r\n          // transfer staked amount to the new staker (sub and add)\r\n        totalREXinActiveStakes[msg.sender] = totalREXinActiveStakes[msg.sender] > _temp.stakedAmount ?\r\n            totalREXinActiveStakes[msg.sender].sub(_temp.stakedAmount) : 0;\r\n        totalREXinActiveStakes[_toAddress] = totalREXinActiveStakes[_toAddress].add(_temp.stakedAmount);\r\n\r\n          // big long stakes make the staker be in Club5555, moving a big immature stake revokes the status\r\n        if (_newStake.stakingDays == 5555 && _newStake.stakedAmount >= CLUB_STAKE_TRESHOLD) { clubFive[msg.sender] = false; }\r\n\r\n          // save the new stake for the new staker (toAddress)\r\n        bytes16 _newReceiverStakeID = _generateStakeID(_toAddress);\r\n        stakes[_toAddress][_newReceiverStakeID] = _newStake;\r\n        _increaseStakeCount(_toAddress);\r\n    }\r\n\r\n    /**\r\n    * @notice A function for a staker to rename a stake\r\n    * belonging to his address by providing the stake ID\r\n    * @param _stakeID unique bytes sequence reference to the stake\r\n    * @param _description New description\r\n    */\r\n    function renameStake(\r\n        bytes16 _stakeID,\r\n        string calldata _description\r\n    )\r\n        snapshotTrigger\r\n        external\r\n    {\r\n        require(stakes[msg.sender][_stakeID].isActive, 'REX: Not an active stake');\r\n        require(MREX_CONTRACT.balanceOf(msg.sender) > 0, 'REX: Hodl MREX to be allowed!');\r\n        Stake storage _stake = stakes[msg.sender][_stakeID];                              // get the stake\r\n        string memory _desc = unicode'\ud83e\udd34 free-claim auto-stake';                          // define autostake string\r\n        bool _autostake = compareStrings(_stake.description, _desc); // compare strings   // compare to description, create bool\r\n        require(!_autostake, 'REX: Cannot rename auto-stake.');                           // require not autostake\r\n        _stake.description = _description;                                                // change description\r\n    }\r\n\r\n    function splitStake(\r\n        bytes16 _stakeID\r\n    )\r\n        snapshotTrigger\r\n        external\r\n    {\r\n        require(MREX_CONTRACT.balanceOf(msg.sender) > 0, 'REX: Hodl MREX to be allowed!');\r\n        require(stakes[msg.sender][_stakeID].isActive, 'REX: Not an active stake.');\r\n        require(stakes[msg.sender][_stakeID].isSplit == false, 'REX: Already split.');\r\n        require(stakes[msg.sender][_stakeID].scrapeDay == 0, 'REX: No. Already scraped interest.');\r\n        require(stakes[msg.sender][_stakeID].stakedAmount >= 2*MIN_STAKE_AMOUNT, 'REX: Too small to split.');\r\n\r\n        Stake memory _temp = stakes[msg.sender][_stakeID];\r\n        Stake memory _newStake;\r\n\r\n        _newStake.stakesShares = _temp.stakesShares / 2;\r\n        _newStake.stakedAmount = _temp.stakedAmount / 2;\r\n        _newStake.startDay = _temp.startDay;\r\n        _newStake.stakingDays = _temp.stakingDays;\r\n        _newStake.finalDay = _temp.finalDay;\r\n        _newStake.closeDay = _temp.closeDay;\r\n        _newStake.isActive = true;\r\n        _newStake.isSplit = true;\r\n        _newStake.description = _temp.description;\r\n\r\n        Stake storage _stake = stakes[msg.sender][_stakeID];\r\n        _stake.isSplit = true;\r\n        _stake.stakesShares = _stake.stakesShares - _newStake.stakesShares;\r\n        _stake.stakedAmount = _stake.stakedAmount - _newStake.stakedAmount;\r\n\r\n          // save the new stake\r\n        bytes16 _newStakeID = _generateStakeID(msg.sender);\r\n        stakes[msg.sender][_newStakeID] = _newStake;\r\n        _increaseStakeCount(msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @notice allows to scrape interest from active stake\r\n    * @param _stakeID unique bytes sequence reference to the stake\r\n    * @param _scrapeDays amount of days to process, all = 0\r\n    */\r\n    function scrapeInterest(\r\n        bytes16 _stakeID,\r\n        uint32 _scrapeDays\r\n    )\r\n        external\r\n        snapshotTrigger\r\n        returns (\r\n            uint32 scrapeDay,\r\n            uint256 scrapeAmount,\r\n            uint32 remainingDays,\r\n            uint256 stakersPenalty\r\n        )\r\n    {\r\n        require(stakes[msg.sender][_stakeID].isActive, 'REX: Not an active stake');\r\n        require(stakes[msg.sender][_stakeID].finalDay > _currentRexDay(), 'REX: Stake mature. Close it!');\r\n        require(stakes[msg.sender][_stakeID].stakingDays > 2, 'REX: Stake too short to scrape interest.');\r\n        require(MREX_CONTRACT.balanceOf(msg.sender) > 0, 'REX: Hodl MREX to be allowed.');\r\n\r\n        Stake memory stake = stakes[msg.sender][_stakeID];      // get stake\r\n\r\n        scrapeDay = _scrapeDays > 0                             // startingDay returns stake.startDay OR stake.scrapeDay (if scraped already)\r\n            ? _startingDay(stake).add(_scrapeDays)              // if not all days are wished to scrape, add desired days to startingDay, see comment above\r\n            : _calculationDay(stake);                           // calculationDay returns endDay OR currentDay, if currentDay is later than endDay\r\n\r\n        scrapeDay = scrapeDay > _currentRexDay()                // if scrape day exceeds currrentDay, limit to currentDay\r\n            ? _calculationDay(stake)\r\n            : scrapeDay;\r\n\r\n        scrapeAmount = _loopRewardAmount(                       // startingDay returns stake.startDay OR stake.scrapeDay (if scraped before)\r\n            stake.stakesShares,\r\n            _startingDay(stake),\r\n            scrapeDay\r\n        );\r\n\r\n        remainingDays = _daysLeft(stake);\r\n\r\n          // the penalty is the amount, that a new stake till the end would cost, cheaper if holds TREX\r\n        stakersPenalty = _stakesShares(\r\n            scrapeAmount,\r\n            remainingDays,\r\n            TREX_CONTRACT.balanceOf(msg.sender) > 0 ? INITIAL_SHARE_PRICE : globals.sharePrice\r\n        );\r\n\r\n        uint256 _sharesTemp = stake.stakesShares;\r\n\r\n          // deduct penalty from SHARES\r\n        stake.stakesShares =\r\n        stake.stakesShares > stakersPenalty ?\r\n        stake.stakesShares.sub(stakersPenalty) : 0;\r\n\r\n            // keep track of the scheduled shares: deduct from final day\r\n        _removeScheduledShares(\r\n            stake.finalDay,\r\n            _sharesTemp > stakersPenalty ? stakersPenalty : _sharesTemp\r\n        );\r\n\r\n          // log globals\r\n        _decreaseGlobals(0, _sharesTemp > stakersPenalty ? stakersPenalty : _sharesTemp);\r\n\r\n        _sharePriceUpdate(\r\n            stake.stakedAmount,\r\n            scrapeAmount,\r\n            stake.stakingDays,\r\n            stake.stakesShares\r\n        );\r\n\r\n          // keep track of scrapes for sharePriceUpdate when calling _endStake\r\n        scrapes[msg.sender][_stakeID] = scrapes[msg.sender][_stakeID].add(scrapeAmount);\r\n\r\n        stake.scrapeDay = scrapeDay;\r\n        stakes[msg.sender][_stakeID] = stake;\r\n\r\n        _mint(msg.sender, scrapeAmount);\r\n\r\n        emit InterestScraped(\r\n            _stakeID,\r\n            msg.sender,\r\n            scrapeAmount,\r\n            scrapeDay,\r\n            stakersPenalty,\r\n            _currentRexDay()\r\n        );\r\n    }\r\n\r\n    function _addScheduledShares(\r\n        uint32 _finalDay,\r\n        uint256 _shares\r\n    )\r\n        internal\r\n    {\r\n        scheduledToEnd[_finalDay] =\r\n        scheduledToEnd[_finalDay].add(_shares);\r\n    }\r\n\r\n    function _removeScheduledShares(\r\n        uint32 _finalDay,\r\n        uint256 _shares\r\n    )\r\n        internal\r\n    {\r\n        if (_notPast(_finalDay)) {\r\n\r\n            scheduledToEnd[_finalDay] =\r\n            scheduledToEnd[_finalDay] > _shares ?\r\n            scheduledToEnd[_finalDay] - _shares : 0;\r\n\r\n        } else {\r\n\r\n            uint32 _day = _previousRexDay();\r\n            snapshots[_day].scheduledToEnd =\r\n            snapshots[_day].scheduledToEnd > _shares ?\r\n            snapshots[_day].scheduledToEnd - _shares : 0;\r\n        }\r\n    }\r\n\r\n    function _sharePriceUpdate(\r\n        uint256 _stakedAmount,\r\n        uint256 _rewardAmount,\r\n        uint32 _stakingDays,\r\n        uint256 _stakeShares\r\n    )\r\n        private\r\n    {\r\n        if (_stakeShares > 0 && _currentRexDay() > 1) {\r\n\r\n            uint256 newSharePrice = _getNewSharePrice(\r\n                _stakedAmount,\r\n                _rewardAmount,\r\n                _stakeShares,\r\n                _stakingDays\r\n            );\r\n\r\n            if (newSharePrice > globals.sharePrice) {\r\n\r\n                newSharePrice =\r\n                    newSharePrice < globals.sharePrice.mul(110).div(100) ?\r\n                    newSharePrice : globals.sharePrice.mul(110).div(100);\r\n\r\n                emit NewSharePrice(\r\n                    newSharePrice,\r\n                    globals.sharePrice,\r\n                    _currentRexDay()\r\n                );\r\n\r\n                globals.sharePrice = newSharePrice;\r\n            }\r\n\r\n            return;\r\n        }\r\n    }\r\n\r\n    function _getNewSharePrice(\r\n        uint256 _stakedAmount,\r\n        uint256 _rewardAmount,\r\n        uint256 _stakeShares,\r\n        uint32 _stakingDays\r\n    )\r\n        private\r\n        pure\r\n        returns (uint256)\r\n    {\r\n\r\n        uint256 _bonusAmount = _getBonus(_stakingDays);\r\n        return\r\n            _stakedAmount\r\n                .add(_rewardAmount)\r\n                .mul(_bonusAmount)\r\n                .mul(BONUS_PRECISION)\r\n                .div(_stakeShares);\r\n    }\r\n\r\n    function _stakesShares(\r\n        uint256 _stakedAmount,\r\n        uint32 _stakingDays,\r\n        uint256 _sharePrice\r\n    )\r\n        private\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return _sharesAmount(_stakedAmount, _stakingDays, _sharePrice);\r\n    }\r\n\r\n    function _sharesAmount(\r\n        uint256 _stakedAmount,\r\n        uint32 _stakingDays,\r\n        uint256 _sharePrice\r\n    )\r\n        private\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return _baseAmount(_stakedAmount, _sharePrice)\r\n            .mul(SHARES_PRECISION + _getBonus(_stakingDays))\r\n            .div(SHARES_PRECISION);\r\n    }\r\n\r\n    function _getBonus(\r\n        uint32 _stakingDays\r\n    )\r\n        private\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return _calcBonusDays(_stakingDays).mul(SHARES_PRECISION).div(7300);\r\n    }\r\n\r\n    function _calcBonusDays(\r\n        uint32 _stakingDays\r\n    )\r\n        private\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return\r\n            _stakingDays.div(365) == 0\r\n            ? _stakingDays\r\n            : getHigherDays(_stakingDays);\r\n    }\r\n\r\n    function getHigherDays(\r\n        uint32 _stakingDays\r\n    )\r\n        private\r\n        pure\r\n        returns (uint256 _days)\r\n    {\r\n        for (uint32 i = 0; i < _stakingDays.div(365); i++) {\r\n            _days += _stakingDays-(i*365);\r\n        }\r\n        _days += _stakingDays - (_stakingDays.div(365) * 365);\r\n        return uint256(_days);\r\n    }\r\n\r\n    function _baseAmount(\r\n        uint256 _stakedAmount,\r\n        uint256 _sharePrice\r\n    )\r\n        private\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return\r\n            _stakedAmount\r\n                .mul(PRECISION_RATE)\r\n                .div(_sharePrice);\r\n    }\r\n\r\n\r\n    function _checkRewardAmountbyID(address _staker, bytes16 _stakeID) public view returns (uint256 rewardAmount) {\r\n        Stake memory stake = stakes[_staker][_stakeID];\r\n        return stake.isActive ? _detectReward(stake) : stake.rewardAmount;\r\n    }\r\n\r\n    function _checkPenaltyAmountbyID(address _staker, bytes16 _stakeID) public view returns (uint256 penaltyAmount) {\r\n        Stake memory stake = stakes[_staker][_stakeID];\r\n        return stake.isActive ? _calculatePenaltyAmount(stake) : stake.penaltyAmount;\r\n    }\r\n\r\n    function _detectReward(Stake memory _stake) private view returns (uint256) {\r\n        return _stakeNotStarted(_stake) ? 0 : _calculateRewardAmount(_stake);\r\n    }\r\n\r\n    function _calculatePenaltyAmount(\r\n        Stake memory _stake\r\n    )\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _stakeNotStarted(_stake) || _isMatureStake(_stake) ? 0 : _getPenalty(_stake);\r\n    }\r\n\r\n    /**\r\n    * @notice If stake is served 50%: no penalty, otherwise linear from 100% (day 1) to 0% (day x/2 of x)\r\n    */\r\n    function _getPenalty(Stake memory _stake)\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return ((_stake.stakingDays - _daysLeft(_stake)) >= (_stake.stakingDays / 2))\r\n          ? 0\r\n          : ( _stake.stakedAmount - ( ( _stake.stakedAmount * (_stake.stakingDays - _daysLeft(_stake)) ) / (_stake.stakingDays / 2) ) );\r\n    }\r\n\r\n    function _calculateRewardAmount(\r\n        Stake memory _stake\r\n    )\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _loopRewardAmount(\r\n            _stake.stakesShares,\r\n            _startingDay(_stake),\r\n            _calculationDay(_stake)\r\n        );\r\n    }\r\n\r\n    function _loopRewardAmount(\r\n        uint256 _stakeShares,\r\n        uint32 _startDay,\r\n        uint32 _finalDay\r\n    )\r\n        private\r\n        view\r\n        returns (uint256 _rewardAmount)\r\n    {\r\n          // calculate rewards / day\r\n        for (uint32 _day = _startDay; _day < _finalDay; _day++) {\r\n            _rewardAmount += _stakeShares * PRECISION_RATE / snapshots[_day].inflationAmount;\r\n        }\r\n\r\n          // deduct penalty if late claim, more than 14 days after finalDay, 1%/week\r\n        if (_currentRexDay() > (_finalDay + uint32(14)) && _rewardAmount > 0) {\r\n            uint256 _reductionPercent = ((uint256(_currentRexDay()) - uint256(_finalDay) - uint256(14)) / uint256(7)) + uint256(1);\r\n            if (_reductionPercent > 100) { _reductionPercent = 100; }\r\n            _rewardAmount = _rewardAmount\r\n                .mul(uint256(100).sub(_reductionPercent))\r\n                .div(100);\r\n        }\r\n\r\n          // deduct penalty if early claim, 100-0% from statingDay till finalDay\r\n        if (_currentRexDay() < _finalDay && _rewardAmount > 0) {\r\n            if (_finalDay != _startDay) {\r\n                _rewardAmount = _rewardAmount * REWARD_PRECISION * (uint256(_currentRexDay()) - uint256(_startDay) ) / ( uint256(_finalDay) - uint256(_startDay) ) / REWARD_PRECISION;\r\n            }\r\n        }\r\n    }\r\n\r\n    function compareStrings(\r\n        string memory a,\r\n        string memory b\r\n    )\r\n        private pure returns (bool)\r\n    {\r\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\r\n    }\r\n}\r\n\r\nabstract contract ClaimableToken is StakingToken {\r\n\r\n    using SafeMath for uint256;\r\n    using SafeMath32 for uint32;\r\n\r\n    /**\r\n     * @notice A function to claim REX and auto-stake them\r\n     * //  param _stakeDays MIN_AUTOSTAKE_DAYS at minimum, MAX_AUTOSTAKE_DAYS at maximum\r\n     */\r\n    function claimRexAndStake(\r\n    )\r\n        snapshotTrigger\r\n        external\r\n    {\r\n        require(!addressHasClaimed[msg.sender], 'REX: Address has claimed already.');\r\n        require(msg.sender.balance > TENTH_OF_BNB, 'REX: BNB Balance must be >0.1');\r\n        require(_currentRexDay() != 0, 'REX: Too early. Wait till day 1.');\r\n        require(_currentRexDay() <= CLAIM_PHASE_END_DAY, 'REX: Claiming has ended already.');\r\n        require(claimCount <= CLAIMABLE_ETH_ADDRESSES, 'REX: Too many claims.');             // sanity check\r\n\r\n        addressHasClaimed[msg.sender] = true;                                                // re-entry protection\r\n        claimCount++;\r\n\r\n        uint32 _validClaimDays = CLAIM_PHASE_END_DAY.add(1).sub(_currentRexDay());           // => (1 <= # <= 365 days)\r\n        uint256 _claimTokens = uint256(_validClaimDays).mul(PRINCES_PER_CLAIM_DAY);          // => (100 REX <= # <= 36,500 REX)\r\n\r\n          // first 50 addresses get 525 staking_days, then decreasing by 1 every 50 claims, down to 365 days\r\n        uint32 _stakingDays = uint32( uint256(525).sub( claimCount.div(50) ) );\r\n\r\n        _createAutoStake(msg.sender, _claimTokens, _stakingDays);\r\n        _increaseClaimedAmount(_claimTokens);\r\n\r\n        emit TokensClaimed(msg.sender, _claimTokens, _currentRexDay());\r\n    }\r\n\r\n    function claimableRex() external view returns (uint256) {\r\n        if (addressHasClaimed[msg.sender]) { return 0; }\r\n        if (_currentRexDay() == 0) { return 0; }\r\n        if (_currentRexDay() > CLAIM_PHASE_END_DAY) { return 0; }\r\n        if (claimCount > CLAIMABLE_ETH_ADDRESSES) { return 0; }\r\n        return (uint256(CLAIM_PHASE_END_DAY).add(1).sub(uint256(_currentRexDay())).mul(PRINCES_PER_CLAIM_DAY));\r\n    }\r\n}\r\n\r\ncontract RexToken is ClaimableToken {\r\n\r\n    address public TOKEN_DEFINER;\r\n\r\n    modifier onlyTokenDefiner() {\r\n        require(\r\n            msg.sender == TOKEN_DEFINER,\r\n            'REX: Wrong sender.'\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor() BEP20Token(\"REX\", \"REX\") {\r\n        TOKEN_DEFINER = msg.sender;\r\n    }\r\n\r\n    receive() external payable { revert(); }\r\n    fallback() external payable { revert(); }\r\n\r\n    /**\r\n     * @notice Set up the contract's REX interface\r\n     * @dev revoke TOKEN_DEFINER access afterwards\r\n     * @param _RDA Contract address of Daily Auctions\r\n     * @param _TREX Contract address of TREX token\r\n     * @param _MREX Contract address of MREX token\r\n     */\r\n    function __initRexContracts(address _RDA, address _TREX, address _MREX) external onlyTokenDefiner {\r\n        RDA_CONTRACT = _RDA;\r\n        TREX_CONTRACT = IBEP20(_TREX);\r\n        MREX_CONTRACT = IBEP20(_MREX);\r\n    }\r\n\r\n    function __revokeAccess() external onlyTokenDefiner\r\n    {\r\n        TOKEN_DEFINER = address(0x0);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows RexDailyAuction Contract to mint REX tokens\r\n     * @dev executed from RDA_CONTRACT when claiming REX after donations and referrals\r\n     * @param _donatorAddress to mint REX for\r\n     * @param _amount of tokens to mint for _donatorAddress\r\n     */\r\n    function mintSupply(\r\n        address _donatorAddress,\r\n        uint256 _amount\r\n    )\r\n        external\r\n    {\r\n        require(msg.sender == RDA_CONTRACT, 'REX: No rights to mint.');\r\n        _mint(_donatorAddress, _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev totalSupply() is the circulating supply, doesn't include STAKED REX. allocatedSupply() includes both.\r\n     * @return Allocated Supply in REX\r\n     */\r\n    function allocatedSupply() external view returns (uint256)\r\n    {\r\n        return totalSupply() + globals.totalStaked;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows externals (RDA) and others to check staked amounts\r\n     * @dev executed from RexDailyAuction, ONLY counts normal stakes, NOT from free claims\r\n     * @param _staker Address to check\r\n     * @return Number of staked REX\r\n     */\r\n     function getTokensStaked(\r\n         address _staker\r\n     )\r\n        external\r\n        view\r\n        returns (uint256)\r\n     {\r\n        return totalREXinActiveStakes[_staker];\r\n     }\r\n\r\n    /**\r\n     * @notice Makes a referrer an ULTRA_REXICAN\r\n     * @dev called from RexDailyAuction\r\n     * @param _referrer Address that becomes an ULTRA_REXICAN\r\n     */\r\n    function setUltraRexican(\r\n        address _referrer\r\n    )\r\n        external\r\n    {\r\n        require(msg.sender == RDA_CONTRACT, 'REX: Can only be called by RDA contract.');\r\n            ultraRexican[_referrer] = true;\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes16\",\"name\":\"stakeID\",\"type\":\"bytes16\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"scrapeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"scrapeDay\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakersPenalty\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"currentRexDay\",\"type\":\"uint32\"}],\"name\":\"InterestScraped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalStaked\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalClaimed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shareRate\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"currentRexDay\",\"type\":\"uint32\"}],\"name\":\"NewGlobals\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSharePrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldSharePrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"currentRexDay\",\"type\":\"uint32\"}],\"name\":\"NewSharePrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes16\",\"name\":\"stakeID\",\"type\":\"bytes16\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakesShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"closeDay\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"penaltyAmount\",\"type\":\"uint256\"}],\"name\":\"StakeEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes16\",\"name\":\"stakeID\",\"type\":\"bytes16\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"stakerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakesShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"startDay\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"stakingDays\",\"type\":\"uint32\"}],\"name\":\"StakeStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"day\",\"type\":\"uint32\"}],\"name\":\"TokensClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"LAUNCH_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MREX_CONTRACT\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RDA_CONTRACT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN_DEFINER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TREX_CONTRACT\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_RDA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_TREX\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_MREX\",\"type\":\"address\"}],\"name\":\"__initRexContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"__revokeAccess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"_stakeID\",\"type\":\"bytes16\"}],\"name\":\"_checkPenaltyAmountbyID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"penaltyAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"_stakeID\",\"type\":\"bytes16\"}],\"name\":\"_checkRewardAmountbyID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressHasClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allocatedSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimCount\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimRexAndStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimableRex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"clubFive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_stakingDays\",\"type\":\"uint32\"},{\"internalType\":\"string\",\"name\":\"_description\",\"type\":\"string\"}],\"name\":\"createStake\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentRexDay\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"_stakeID\",\"type\":\"bytes16\"}],\"name\":\"endStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"x\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"},{\"internalType\":\"bytes1\",\"name\":\"z\",\"type\":\"bytes1\"}],\"name\":\"generateID\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"b\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"getTokensStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalClaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sharePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"currentRexDay\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isUltraRexican\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"latestStakeID\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualDailySnapshot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_updateDay\",\"type\":\"uint32\"}],\"name\":\"manualDailySnapshotPoint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_donatorAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mintSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"_stakeID\",\"type\":\"bytes16\"},{\"internalType\":\"address\",\"name\":\"_toAddress\",\"type\":\"address\"}],\"name\":\"moveStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"_stakeID\",\"type\":\"bytes16\"},{\"internalType\":\"string\",\"name\":\"_description\",\"type\":\"string\"}],\"name\":\"renameStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"scheduledToEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"_stakeID\",\"type\":\"bytes16\"},{\"internalType\":\"uint32\",\"name\":\"_scrapeDays\",\"type\":\"uint32\"}],\"name\":\"scrapeInterest\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"scrapeDay\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"scrapeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"remainingDays\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"stakersPenalty\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"scrapes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"setUltraRexican\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"snapshots\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"inflationAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"scheduledToEnd\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"_stakeID\",\"type\":\"bytes16\"}],\"name\":\"splitStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakeCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakesShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"penaltyAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"startDay\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"stakingDays\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"finalDay\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"closeDay\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"scrapeDay\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isSplit\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_length\",\"type\":\"uint256\"}],\"name\":\"stakesPagination\",\"outputs\":[{\"internalType\":\"bytes16[]\",\"name\":\"_stakes\",\"type\":\"bytes16[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"totalPenalties\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalREXinActiveStakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ultraRexican\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unclaimedAddresses\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unclaimedRexPOOL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "RexToken", "CompilerVersion": "v0.7.4+commit.3f05b770", "OptimizationUsed": "1", "Runs": "1", "ConstructorArguments": "", "EVMVersion": "istanbul", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ab68a2240801121ed30c75f74667f9a9e43a0ef9586e320ec15f437e5bd0a2a3"}