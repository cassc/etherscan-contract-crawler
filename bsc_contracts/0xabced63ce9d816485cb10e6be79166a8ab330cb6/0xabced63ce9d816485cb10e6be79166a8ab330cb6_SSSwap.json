{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/_erc/IERC.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity >=0.7.0 <0.9.0;\\r\\n\\r\\n/// import \\\"hardhat/console.sol\\\";\\r\\n\\r\\ninterface IERC20_ {\\r\\n    /////////////////////////////////////////////////////// interface of the ERC20 standard as defined in the EIP\\r\\n    function name() external view returns (string memory);\\r\\n    function symbol() external view returns (string memory);\\r\\n    function decimals() external view returns (uint8);\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\r\\n    ///////////////////////////////////////////////////////\\r\\n}\\r\\ninterface IERC20 is IERC20_ {\\r\\n    ///////////////////////////////////////////////////////\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\ninterface IERC20Receiver {\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function onERC20Received(address from, address to, uint256 amount, uint256 data) external returns(bool);\\r\\n}\\r\\n\\r\\ninterface IERC721Receiver {\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\\r\\n}\\r\\ninterface IERC165 {\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n}\\r\\ninterface IERC721Enumerable_ {\\r\\n    ///////////////////////////////////////////////////////\\r\\n/// function totalSupply() external view returns(uint256);\\r\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns(uint256);\\r\\n    function tokenByIndex(uint256 index) external view returns(uint256);\\r\\n}\\r\\ninterface IERC721Metadata_ {\\r\\n    ///////////////////////////////////////////////////////\\r\\n/// function name() external view returns(string memory);\\r\\n/// function symbol() external view returns(string memory);\\r\\n    function tokenURI(uint256 tokenId) external view returns(string memory);\\r\\n}\\r\\ninterface IERC721_ {\\r\\n    ///////////////////////////////////////////////////////\\r\\n/// function balanceOf(address owner) external view returns(uint256 balance);\\r\\n    function ownerOf(uint256 tokenId) external view returns(address);\\r\\n    function getApproved(uint256 tokenId) external view returns(address);\\r\\n    function isApprovedForAll(address owner, address operator) external view returns(bool);\\r\\n    ///////////////////////////////////////////////////////\\r\\n/// function transferFrom(address from, address to, uint256 tokenId) external;\\r\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\r\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\r\\n/// function approve(address to, uint256 tokenId) external;\\r\\n    function setApprovalForAll(address operator, bool approved) external;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\r\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\r\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\r\\n}\\r\\ninterface IESC20 {\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function Insight(address caller, address from, address to) external view returns(uint256,uint160);\\r\\n    function Escape(address caller, address from, address to, uint256 amount) external returns(bool);\\r\\n}\\r\\n\\r\\ninterface ISwap {\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function Swap(\\r\\n        address payer,                                  /// shall =caller if 'token' != USSSD\\r\\n                                                        /// or, caller must own a debt of payer and owe to this contract\\r\\n        uint256 amount,                                 /// amount of 'token' to sell\\r\\n        address token,                                  /// IERC20 token to sell\\r\\n        address tokenToReceive,                         /// IERC20 token to receive\\r\\n        uint256 minToReceive,                           /// minimum amount of 'tokenToReceive' to swap\\r\\n        address recipient                               /// target wallet\\r\\n    ) external returns(uint256);                        /// actual tokens received\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function Estimate(uint256 amount, address token, address tokenToReceive) external view returns(uint256);\\r\\n}\\r\\n\\r\\n///////////////////////////////////////////////////////////\\r\\ninterface IDaoAgency {\\r\\n    function ApplyDao(address agent) external returns (address);\\r\\n}\\r\\n\\r\\nlibrary Num {\\r\\n    ///////////////////////////////////////////////////////\\r\\n    uint256 public constant MAX256      = type(uint256).max;\\r\\n    uint256 public constant MAX160      = type(uint160).max;\\r\\n    uint128 public constant MAX128      = type(uint128).max;\\r\\n    uint64  public constant MAX64       = type(uint64 ).max;\\r\\n    uint32  public constant MAX32       = type(uint32 ).max;\\r\\n    uint256 public constant GWEI        = 10**9;\\r\\n    uint256 public constant TWEI        = 10**12;\\r\\n    uint256 public constant _0_000001   = 10**12;\\r\\n    uint256 public constant _0_00001    = 10**13;\\r\\n    uint256 public constant _0_0001     = 10**14;\\r\\n    uint256 public constant _0_001      = 10**15;\\r\\n    uint256 public constant _0_01       = 10**16;\\r\\n    uint256 public constant _0_1        = 10**17;\\r\\n    uint256 public constant _1          = 10**18;\\r\\n    uint256 public constant _10         = 10**19;\\r\\n    uint256 public constant _100        = 10**20;\\r\\n    uint256 public constant _1000       = 10**21;\\r\\n    uint256 public constant _10000      = 10**22;\\r\\n    uint256 public constant _100000     = 10**23;\\r\\n    uint256 public constant _1000000    = 10**24;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    uint256 public constant CENT        = 10**16;\\r\\n    uint256 public constant DIME        = 10**17;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    address public constant _0          = address(0);\\r\\n    address public constant MAP_        = address(0x10);\\r\\n    address public constant _MAP        = address(0xFFFFFFFFFF);\\r\\n    address public constant ESC         = address(0xFFFFFFFFFFFFFFFF);\\r\\n    address public constant NULL        = address(type(uint160).max);\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function _Mapped(address a) internal pure returns(bool) {\\r\\n        return (MAP_ <= a)&&(a <= _MAP);\\r\\n    }\\r\\n    function _Mapped(address a, address b) internal pure returns(bool) {\\r\\n        return _Mapped((a != NULL) ? a : b);\\r\\n    }\\r\\n    function _Escaped(address a) internal pure returns(bool) {\\r\\n        return (MAP_ <= a)&&(a <= ESC);\\r\\n    }\\r\\n    function _Escaped(address a, address b) internal pure returns(bool) {\\r\\n        return _Escaped((a != NULL) ? a : b);\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    uint160 public constant _900        =  0x900;\\r\\n    uint160 public constant URL         =  0x192;\\r\\n    uint160 public constant GAS         =  0x9a5;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    uint160 public constant SN          =   0x50;\\r\\n    uint160 public constant VERSION     =   0x51;\\r\\n    uint160 public constant VER2        =   0x52;\\r\\n    uint160 public constant ACCOUNT     =   0xAC;\\r\\n    uint160 public constant BLK         =   0xB1;\\r\\n    uint160 public constant HASH        =   0xB5;\\r\\n    uint160 public constant BALANCE     =   0xBA;\\r\\n    uint160 public constant ESCAPE      =   0xE5;\\r\\n    uint160 public constant ESCAPED     =   0xED;\\r\\n    uint160 public constant CTX         =   0xFC;\\r\\n    uint160 public constant STATUS      =   0xFF;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    uint160 public constant USD         = 0xadd0;\\r\\n    uint160 public constant USD1        = 0xadd1;\\r\\n    uint160 public constant USD2        = 0xadd2;\\r\\n    uint160 public constant TOKEN       = 0xadd8;\\r\\n    uint160 public constant USD_        = 0xadd9;\\r\\n    uint160 public constant NFT         = 0xaddA;\\r\\n    uint160 public constant BIND        = 0xaddB;\\r\\n    uint160 public constant SWAP        = 0xaddC;\\r\\n    uint160 public constant DAO         = 0xaddD;\\r\\n    uint160 public constant OWNER       = 0xaddE;\\r\\n    uint160 public constant DELEGATE    = 0xaddF;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    uint160 public constant DEBT        = 0xDeb0;\\r\\n    uint160 public constant DEBTOFF     = 0xDeb1;\\r\\n    uint160 public constant DEBTPASS    = 0xDeb2;\\r\\n    ///////////////////////////////////////////////////////\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/_erc/SSSwap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity >=0.7.0 <0.9.0;\\r\\n\\r\\nimport \\\"./IERC.sol\\\";\\r\\n\\r\\n/////////////////////////////////////////////////////////// IUniswapV2Factory\\r\\ninterface ISwapFactory {\\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n}\\r\\n/////////////////////////////////////////////////////////// IUniswapV2Pair\\r\\ninterface ISwapPair {\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n}\\r\\n/////////////////////////////////////////////////////////// IUniswapV3Router01\\r\\ninterface ISwapRouter {\\r\\n    function factoryV2() external pure returns (address);\\r\\n    function swapExactTokensForTokens(\\r\\n        uint amountIn,\\r\\n        uint amountOutMin,\\r\\n        address[] calldata path,\\r\\n        address to\\r\\n    ) external returns (uint);\\r\\n}\\r\\n\\r\\n/////////////////////////////////////////////////////////// WETH/WBNB...\\r\\ninterface IWEth {\\r\\n    function withdraw(uint256 amount) external;\\r\\n}\\r\\n\\r\\ninterface ISSSwap is IESC20, ISwap {\\r\\n    function Balance(address u, uint256 balance, int256 perK) external view returns(uint256);\\r\\n    function Budget(address token, address owner, address spender, uint256 balance, uint256 limit) external view returns(uint256);\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function Rebalance(address u) external returns(uint256);\\r\\n    function Buy(uint256 usdPaid, address tokenToBuy, address recipient) external returns(uint256);\\r\\n}\\r\\n\\r\\nlibrary _SSSwap {\\r\\n    ///////////////////////////////////////////////////////\\r\\n    uint256 public constant OV128       = 10**40;\\r\\n    ///////////////////////////////////////////////////////\\r\\n}\\r\\ncontract SSSwap is ISSSwap, IDaoAgency {\\r\\n    uint256 internal  _ver;                             /// version\\r\\n    address internal  _usssd;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    address internal  _usd;\\r\\n    address internal  _usd1;\\r\\n    address internal  _usd2;\\r\\n    address internal  _wgas;\\r\\n    address internal  _router;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    constructor(\\r\\n        address usssd,\\r\\n        address usd,                                    /// -USDT       -USDC       -USDT\\r\\n        address usd1,                                   /// -USDC       -USDT       -USDC\\r\\n        address usd2,                                   /// -BUSD\\r\\n        address wgas,                                   /// -BNB        -ETH        -TRX\\r\\n        address router,                                 /// PancakeSwap UniSwap     JustSwap\\r\\n                                                        /// [BNB]       [ETH]       [TRON]\\r\\n        uint256 version\\r\\n    ) {\\r\\n        unchecked {\\r\\n            _ver = version;\\r\\n            _usssd = usssd;\\r\\n            _usd = usd;\\r\\n            _usd1 = usd1;\\r\\n            _usd2 = usd2;\\r\\n            _wgas = wgas;\\r\\n            _router = router;\\r\\n            if(router.code.length > 0)\\r\\n                _Approve(router,usd,usd1,usd2);\\r\\n            Agent memory a;\\r\\n            a.quota = 0xFF;\\r\\n            _agents[Num._0] = a;                        /// preset DAO agent (0x0): 0% commission, quota = 255\\r\\n            a.quota = 0xFF00;\\r\\n            a.margin = uint32(uint( 25<<32)/1000);\\r\\n            _agents[usssd] = a;                         /// preset DAO agent (U$D contract): 2.5% commission, quota = 65,280\\r\\n            a.quota = 0xFF0000;\\r\\n            a.margin = uint32(uint(100<<32)/1000);\\r\\n            _agents[address(this)] = a;                 /// preset DAO agent (this contract): 10% commission, quota = 16,711,680\\r\\n            IERC20(usssd).transferFrom(address(Num.DEBT),usssd,Num.MAX256);\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    modifier ByToken() {\\r\\n        require(msg.sender == _usssd,\\\"()\\\");\\r\\n        _;\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    receive() external payable {\\r\\n    }\\r\\n\\r\\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    function Insight(address caller, address from, address to) override external view returns(uint256,uint160) {\\r\\n        unchecked {\\r\\n            uint160 cmd = uint160(from);\\r\\n            if(!Num._Escaped(from))\\r\\n                return (0,cmd);\\r\\n            if(to == Num.NULL) {                        /// called by 'balanceOf()'\\r\\n                if(cmd == Num.VER2      ) return (_ver,0);\\r\\n                if(cmd == Num.BALANCE   ) return (IERC20(_usd).balanceOf(_usssd),0);\\r\\n                if(cmd == Num.USD_      ) return (uint160(_usssd ),0);\\r\\n                if(cmd == Num.USD       ) return (uint160(_usd   ),0);\\r\\n                if(cmd == Num.USD1      ) return (uint160(_usd1  ),0);\\r\\n                if(cmd == Num.USD2      ) return (uint160(_usd2  ),0);\\r\\n                if(cmd == Num.GAS       ) return (uint160(_wgas  ),0);\\r\\n                if(cmd == Num.SWAP      ) return (uint160(_router),0);\\r\\n            } else {                                    /// called by 'allowance()'\\r\\n                if(cmd == Num.USD       ) return (Balance(to,IERC20(_usssd).allowance(address(Num.BALANCE),to),-1),0);\\r\\n                if(cmd == Num.SWAP      ) return (_Price(to,Num._1),0);\\r\\n                if(cmd == Num.BIND      ) return ((Num._100*_agents[to].margin)>>32,0);\\r\\n                if(cmd == Num.SN        ) return (Num._1*_agents[to].quota,0);\\r\\n            }\\r\\n            return (uint160(caller),cmd);\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function Escape(address caller, address from, address to, uint256 amount) ByToken override external returns(bool) {\\r\\n        unchecked {\\r\\n            if(from == Num.NULL) {                      /// called by 'transfer()'\\r\\n                return false;\\r\\n            } else if(to == Num.NULL) {                 /// called by 'approve()'\\r\\n                Rebalance(from);\\r\\n                if(to != from) Rebalance(to);\\r\\n                return false;\\r\\n            } else if(from < Num.MAP_) {                /// called by 'transferFrom()'\\r\\n                return false;\\r\\n            } else if(from <= Num._MAP) {               /// called by 'transferFrom()' to config\\r\\n                uint160 cmd = uint160(from);\\r\\n                if(!_Config(cmd,to,amount))\\r\\n                    return false;\\r\\n                _Permission(caller,cmd);\\r\\n                return true;\\r\\n            } else if(amount > _SSSwap.OV128) {         /// called by 'transferFrom(tokenFrom,tokenTo,n+ov128)'\\r\\n                Rebalance(caller);\\r\\n                amount -= _SSSwap.OV128;                /// to swap from a token to another token\\r\\n                require(_Swap(false,_usssd,_usd,caller,amount,from,to,0,caller) > 0,\\\"<->\\\");\\r\\n                return true;\\r\\n            }\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    function _Permission(address caller, uint256 n) internal {\\r\\n        require(IERC20(_usssd).transferFrom(address(Num._900),caller,n),\\\"!\\\");\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function _Approve(address router, address usd, address usd1, address usd2) internal {\\r\\n        unchecked {\\r\\n            if(router.code.length != 0) {\\r\\n                if(usd .code.length != 0) IERC20(usd ).approve(router,Num.MAX256);\\r\\n                if(usd1.code.length != 0) IERC20(usd1).approve(router,Num.MAX256);\\r\\n                if(usd2.code.length != 0) IERC20(usd2).approve(router,Num.MAX256);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function _Config(uint160 cmd, address arg, uint256 amount) internal virtual returns(bool) {\\r\\n        unchecked {\\r\\n            if(cmd == Num.SN  ) _agents[arg].quota = uint24(amount/Num._1); else\\r\\n            if(cmd == Num.BIND) _agents[arg].margin = uint32((amount<<32)/Num._100); else\\r\\n            if(amount > 0) return false; else\\r\\n            if(cmd == Num.USD_) _usssd = arg; else\\r\\n            if(cmd == Num.USD ) _Approve(_router, _usd = arg,Num._0,Num._0); else\\r\\n            if(cmd == Num.USD1) _Approve(_router,Num._0,_usd1 = arg,Num._0); else\\r\\n            if(cmd == Num.USD2) _Approve(_router,Num._0,Num._0,_usd2 = arg); else\\r\\n            if(cmd == Num.SWAP) _Approve(_router = arg,_usd,_usd1,_usd2); else\\r\\n            if(cmd == Num.GAS ) _wgas = arg; else\\r\\n                return false;\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n    /////////////////////////////////////////////////////// get DEX pair\\r\\n    function _Pair(address u, address v) internal view returns(address uv) {\\r\\n        unchecked {\\r\\n            if(_router.code.length == 0)\\r\\n                return Num._0;\\r\\n            ISwapRouter dex = ISwapRouter(_router);\\r\\n            ISwapFactory factory = ISwapFactory(dex.factoryV2());\\r\\n            return factory.getPair(u,v);\\r\\n        }\\r\\n    }\\r\\n    /////////////////////////////////////////////////////// get DEX pair reserves\\r\\n    function _Reserves(address u, address v) internal view returns(uint256,uint256) {\\r\\n        unchecked {\\r\\n            address uv = _Pair(u,v);\\r\\n            if(uv.code.length == 0)\\r\\n                return (0,0);\\r\\n            uint256 u_;\\r\\n            uint256 v_;\\r\\n            (u_,v_,) = ISwapPair(uv).getReserves();\\r\\n            return (u < v) ? (u_,v_) : (v_,u_);\\r\\n        }\\r\\n    }\\r\\n    /////////////////////////////////////////////////////// get token price (USD value) on DEX\\r\\n    function _Price(address token, uint256 n) internal view returns(uint256) {\\r\\n        unchecked {\\r\\n            if((token == _usd)||(token == _usssd))\\r\\n                return n;\\r\\n            if((token == Num._0)||(uint160(token) == Num.GAS))\\r\\n                token = _wgas;\\r\\n            (uint256 u, uint256 v) = _Reserves(_usd,token);\\r\\n            if(v == 0) {                                /// not on DEX\\r\\n                if(token.code.length == 0)              /// try game token\\r\\n                    return 0;\\r\\n                u = IERC20(token).balanceOf(address(Num.TOKEN));\\r\\n                v = Num._1;\\r\\n            }\\r\\n            return n*u/v;\\r\\n        }\\r\\n    }\\r\\n    /////////////////////////////////////////////////////// predict post-trading amount of the current reserves\\r\\n    function _Predict(uint256 n, uint256 u, uint256 v) internal pure returns(uint256) {\\r\\n        unchecked {\\r\\n            return (v-u*v/(u+n))*9975/10000;            /// according to V2 protocol and 0.25% commission\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function _Swap(address router, address transit, uint256 amount, address token, bool approved, address tokenToReceive, uint256 min, address recipient)\\r\\n                internal returns(uint256) {\\r\\n        unchecked {\\r\\n            if(token == tokenToReceive)                 /// direct transfer, no swapping needed\\r\\n                if(recipient == address(this)) return amount;\\r\\n                else if(IERC20(token).transfer(recipient,amount)) return amount;\\r\\n                else return 0;\\r\\n            if(router.code.length == 0) {\\r\\n            /// console.log(\\\"$wap\\\",amount/Num._1);\\r\\n            /// console.log(\\\"   $\\\",token);\\r\\n            /// console.log(\\\"-> $\\\",tokenToReceive);\\r\\n            /// console.log(\\\"   :\\\",recipient);\\r\\n                return 0;\\r\\n            }\\r\\n            ISwapRouter dex = ISwapRouter(router);\\r\\n            ISwapFactory factory = ISwapFactory(dex.factoryV2());\\r\\n            address gasReceiver;\\r\\n            if(tokenToReceive == Num._0) {\\r\\n                tokenToReceive = _wgas;                 /// use wrapped token when swapping for gas\\r\\n                gasReceiver = recipient;\\r\\n                recipient = address(this);\\r\\n            }\\r\\n            uint k = 1;                                 /// build trading path (use transition token if necessay)\\r\\n            if(factory.getPair(token,tokenToReceive) == Num._0) {\\r\\n                require((token != transit)\\r\\n                    &&(transit != tokenToReceive)\\r\\n                    &&(factory.getPair(token,transit) != Num._0)\\r\\n                    &&(factory.getPair(transit,tokenToReceive) != Num._0)\\r\\n                        ,\\\"/\\\");\\r\\n                k = 2;\\r\\n            }\\r\\n            if(!approved)                               /// appove allowance to 'router'\\r\\n                if(!IERC20(token).approve(router,Num.MAX256))\\r\\n                    return 0;\\r\\n            if(min == 0) {\\r\\n                min = Estimate(amount,token,tokenToReceive);\\r\\n                min -= min>>6;\\r\\n            }\\r\\n            address[] memory path = new address[](k+1);\\r\\n            path[0] = token;\\r\\n            path[1] = transit;\\r\\n            path[k] = tokenToReceive;\\r\\n            amount = dex.swapExactTokensForTokens(             /// swap for non-gas token\\r\\n                amount,\\r\\n                min,\\r\\n                path,\\r\\n                recipient);\\r\\n            if(gasReceiver != Num._0) {\\r\\n                IWEth(tokenToReceive).withdraw(amount);\\r\\n                payable(gasReceiver).transfer(amount);\\r\\n            }\\r\\n            return amount;\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function _Swap(bool paidUSD, address usssd, address usd, address payer,\\r\\n                uint256 amount, address token, address tokenToReceive, uint256 min, address recipient) internal returns(uint256) {\\r\\n        unchecked {\\r\\n            if(!paidUSD)                                /// pre-paid U$D or not\\r\\n                require(IERC20(token).transferFrom(payer,address(this),amount),\\\"$\\\");\\r\\n            address router = _router;\\r\\n            address to;\\r\\n            if(token == usssd) {                        /// use wrapped USD (e,g, USDT) instead of U$D\\r\\n                uint32 margin = _agents[recipient].margin;\\r\\n                if(margin > 0) amount -= (amount*margin)>>32;\\r\\n                if((router.code.length == 0)||IERC20(usssd).transfer(Num._0,amount))\\r\\n                    token = usd;\\r\\n            }\\r\\n            if(tokenToReceive < Num._MAP) {             /// supported token mapping\\r\\n                uint160 cmd = uint160(tokenToReceive);\\r\\n                if(cmd == Num.GAS ) tokenToReceive = Num._0; else\\r\\n                if(cmd == Num.USD ) tokenToReceive = usd; else\\r\\n                if(cmd == Num.USD1) tokenToReceive = _usd1; else\\r\\n                if(cmd == Num.USD2) tokenToReceive = _usd1; else\\r\\n                if(cmd == Num.USD_) tokenToReceive = usssd; else\\r\\n                if(cmd != 0) require(false,\\\"?\\\");\\r\\n            }\\r\\n            if(tokenToReceive == usssd) {               /// buy U$D\\r\\n                to = recipient;\\r\\n                recipient = usssd;\\r\\n                tokenToReceive = usd;\\r\\n            }\\r\\n            bool approved = (router.code.length == 0)||(IERC20(token).allowance(address(this),router) >= amount);\\r\\n            uint256 received = _Swap(router,usd,amount,token,approved,tokenToReceive,min,recipient);\\r\\n            if(to != Num._0)                            /// buy U$D\\r\\n                IERC20(usssd).transfer(to,received);\\r\\n            return received;\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function _Balance(address u, address coin, int256 perK) internal view returns(uint256) {\\r\\n        unchecked {\\r\\n            if(coin.code.length == 0) return 0;\\r\\n            uint256 b = IERC20(coin).balanceOf(u);\\r\\n            if(b == 0)\\r\\n                return 0;\\r\\n            if(perK >= 0) {                             /// return only the amount allowed to transfer by me\\r\\n                uint256 a = IERC20(coin).allowance(u,address(this));\\r\\n                if(a == 0) return 0;\\r\\n                if(a < b) b = a;\\r\\n            }\\r\\n            uint256 k = uint256((perK < 0) ? -perK : perK);\\r\\n            if(k >= 16) {                               /// require to consider actual DEX price with margin\\r\\n                k = _Price(coin,k);\\r\\n                b = (b*k)>>10;\\r\\n            }\\r\\n            return b;\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function _Rebalance(address u, address coin, uint256 amount, address usd, address usssd, address router) internal returns(uint256) {\\r\\n        unchecked {\\r\\n            if(coin.code.length == 0) return 0;\\r\\n            uint256 n = _Balance(u,coin,0);\\r\\n            if(n == 0)\\r\\n                return 0;\\r\\n            if((amount == 0)||(amount > n))             /// available amount to pledge\\r\\n                amount = n;\\r\\n            bool directpay = (coin == usd);\\r\\n            address recipient = directpay ? usssd : address(this);\\r\\n            if(!IERC20(coin).transferFrom(u,recipient,amount))\\r\\n                return 0;\\r\\n            if(directpay)\\r\\n                return amount;\\r\\n            return _Swap(router,usd,amount,coin,true,usd,1,usssd);\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function _Status(address u) internal view returns(uint8) {\\r\\n        unchecked {\\r\\n            uint8 t;\\r\\n            address me = address(this);\\r\\n            if((_usd .code.length > 0)&&(IERC20(_usd ).allowance(u,me) != Num.MAX256)) t |= 0x1;\\r\\n            if((_usd1.code.length > 0)&&(IERC20(_usd1).allowance(u,me) != Num.MAX256)) t |= 0x2;\\r\\n            if((_usd2.code.length > 0)&&(IERC20(_usd2).allowance(u,me) != Num.MAX256)) t |= 0x4;\\r\\n            return ~t;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    function Budget(address token, address owner, address spender, uint256 balance, uint256 limit) override external view returns(uint256) {\\r\\n        unchecked {\\r\\n            uint8 st = _Status(owner);\\r\\n            uint256 b = uint128(owner.balance<<16)|st;\\r\\n            if(token.code.length == 0)\\r\\n                return b;\\r\\n            if(token != _usssd) {\\r\\n                balance = IERC20(token).balanceOf(owner);\\r\\n                limit = IERC20(token).allowance(owner,spender);\\r\\n            } else if(st == 0xFF) {\\r\\n                balance = Balance(owner,balance,1014);  /// activated: ~1% margin\\r\\n            } else {\\r\\n                balance = Balance(owner,0,-1);          /// inactivated: USDT/USDC/BUSD balance\\r\\n            }\\r\\n            if((owner != spender)&&(limit >= balance))\\r\\n                b |= 0x100;\\r\\n            return b|(balance<<128);\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function Balance(address u, uint256 balance, int256 perK) override public view returns(uint256) {\\r\\n        unchecked {\\r\\n            return  _Balance(u,_usd,(perK < 0) ? -1 : int256(0))+\\r\\n                    _Balance(u,_usd1,perK)+\\r\\n                    _Balance(u,_usd2,perK)+\\r\\n                    balance;\\r\\n        }\\r\\n    }\\r\\n    /////////////////////////////////////////////////////// every one is welcome to call Rebalance()\\r\\n    function Rebalance(address u) override public returns(uint256) {\\r\\n        unchecked {\\r\\n            address usd = _usd;\\r\\n            address usssd = _usssd;\\r\\n            address router = _router;\\r\\n            uint256 n = _Rebalance(u, usd ,0,usd,usssd,router)+\\r\\n                        _Rebalance(u,_usd1,0,usd,usssd,router)+\\r\\n                        _Rebalance(u,_usd2,0,usd,usssd,router);\\r\\n            if(n == 0)\\r\\n                return 0;\\r\\n            IERC20(usssd).transfer(u,n);                /// pledged and mint\\r\\n            return n;\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function Buy(uint256 usdPaid, address tokenToBuy, address recipient) ByToken override external returns(uint256) {\\r\\n        unchecked {\\r\\n            address usd = _usd;\\r\\n            uint256 n = _Swap(true,_usssd,usd,address(this),usdPaid,usd,tokenToBuy,0,recipient);\\r\\n            require(n > 0,\\\"<->\\\");\\r\\n            return n;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\\r\\n    struct Agent {\\r\\n        uint32  margin;\\r\\n        uint24  quota;\\r\\n    }\\r\\n    mapping(address => Agent)                       internal _agents;\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function ApplyDao(address agent) override external returns (address) {\\r\\n        unchecked {\\r\\n            Agent memory a = _agents[agent];\\r\\n            require(a.quota > 0,'!');                   /// run out of this agent's quota\\r\\n            IERC20 usssd = IERC20(_usssd);\\r\\n            usssd.approve(msg.sender,a.margin);         /// register DAO for applicant\\r\\n            a.quota --;\\r\\n            _agents[agent] = a;\\r\\n            uint160 dao = uint160(usssd.balanceOf(address(Num.DAO)));\\r\\n            return address(dao<<40);                    /// return mapped DAO address\\r\\n        }\\r\\n    }\\r\\n    ///////////////////////////////////////////////////////\\r\\n    function Swap(address payer, uint256 amount, address token, address tokenToReceive, uint256 minToReceive, address recipient)\\r\\n                override external returns(uint256) {\\r\\n        unchecked {\\r\\n            require((msg.sender == payer)||IERC20(token).transferFrom(address(Num.DEBTPASS),msg.sender,(amount<<160)|uint160(payer)),\\\"*\\\");\\r\\n            return _Swap(false,_usssd,_usd,payer,amount,token,tokenToReceive,minToReceive,recipient);\\r\\n        }\\r\\n    }\\r\\n    /////////////////////////////////////////////////////// estimate outcome of a swapping\\r\\n    function Estimate(uint256 amount, address token, address tokenToReceive) override public view returns(uint256) {\\r\\n        unchecked {\\r\\n            uint256 u;\\r\\n            uint256 v;\\r\\n            if(tokenToReceive == Num._0)\\r\\n                tokenToReceive = _wgas;\\r\\n            (u,v) = _Reserves(token,tokenToReceive);\\r\\n            if(u > 0)\\r\\n                return _Predict(amount,u,v);\\r\\n            address usd = _usd;\\r\\n            (u,v) = _Reserves(token,usd);\\r\\n            if(u == 0)\\r\\n                return 0;\\r\\n            amount = _Predict(amount,u,v);\\r\\n            (u,v) = _Reserves(usd,tokenToReceive);\\r\\n            return (u == 0) ? 0 : _Predict(amount,u,v);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usssd\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"usd\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"usd1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"usd2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wgas\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"agent\",\"type\":\"address\"}],\"name\":\"ApplyDao\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"perK\",\"type\":\"int256\"}],\"name\":\"Balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"Budget\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"usdPaid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenToBuy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"Buy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Escape\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenToReceive\",\"type\":\"address\"}],\"name\":\"Estimate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Insight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint160\",\"name\":\"\",\"type\":\"uint160\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"u\",\"type\":\"address\"}],\"name\":\"Rebalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenToReceive\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minToReceive\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"Swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SSSwap", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000001c41c14104f165cebffbc36d5506e7ae588479f000000000000000000000000055d398326f99059ff775485246999027b31979550000000000000000000000008ac76a51cc950d9822d68b83fe1ad97b32cd580d0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c00000000000000000000000013f4ea83d0bd40e75c8222255bc855a974568dd4000000000000000000000000f2af5b171cc1b46908a8d91b335c20f8bb76e120", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://0f90b5110e3826abb5d4e73e85ac4a16a2396956eef01e2be4916bf56743d10c"}