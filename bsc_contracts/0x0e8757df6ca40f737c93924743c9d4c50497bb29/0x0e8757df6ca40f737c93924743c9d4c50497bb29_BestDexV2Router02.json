{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/BestDexV2Router02.sol\": {\r\n      \"content\": \"pragma solidity =0.6.6;\\n\\nimport \\\"./v2-core/contracts/interfaces/IBestDexV2Factory.sol\\\";\\nimport \\\"./libraries/TransferHelper.sol\\\";\\n\\nimport \\\"./interfaces/IBestDexV2Router02.sol\\\";\\nimport \\\"./libraries/BestDexV2Library.sol\\\";\\nimport \\\"./libraries/SafeMath.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IWETH.sol\\\";\\n\\ncontract BestDexV2Router02 is IBestDexV2Router02 {\\n  using SafeMath for uint256;\\n\\n  address public immutable override factory;\\n  address public immutable override WETH;\\n\\n  modifier ensure(uint256 deadline) {\\n    require(deadline >= block.timestamp, \\\"BestDexV2Router: EXPIRED\\\");\\n    _;\\n  }\\n\\n  event SwapTokens(\\n    address indexed from,\\n    uint256[] amounts,\\n    address[] tokens,\\n    address to,\\n    uint256 indexed index,\\n    uint256 timestamp\\n  );\\n\\n  constructor(address _factory, address _WETH) public {\\n    factory = _factory;\\n    WETH = _WETH;\\n  }\\n\\n  receive() external payable {\\n    assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\\n  }\\n\\n  // **** ADD LIQUIDITY ****\\n  function _addLiquidity(\\n    address tokenA,\\n    address tokenB,\\n    uint256 amountADesired,\\n    uint256 amountBDesired,\\n    uint256 amountAMin,\\n    uint256 amountBMin\\n  ) internal virtual returns (uint256 amountA, uint256 amountB) {\\n    // create the pair if it doesn't exist yet\\n    if (IBestDexV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {\\n      IBestDexV2Factory(factory).createPair(tokenA, tokenB);\\n    }\\n    (uint256 reserveA, uint256 reserveB) = BestDexV2Library.getReserves(\\n      factory,\\n      tokenA,\\n      tokenB\\n    );\\n    if (reserveA == 0 && reserveB == 0) {\\n      (amountA, amountB) = (amountADesired, amountBDesired);\\n    } else {\\n      uint256 amountBOptimal = BestDexV2Library.quote(\\n        amountADesired,\\n        reserveA,\\n        reserveB\\n      );\\n      if (amountBOptimal <= amountBDesired) {\\n        require(\\n          amountBOptimal >= amountBMin,\\n          \\\"BestDexV2Router: INSUFFICIENT_B_AMOUNT\\\"\\n        );\\n        (amountA, amountB) = (amountADesired, amountBOptimal);\\n      } else {\\n        uint256 amountAOptimal = BestDexV2Library.quote(\\n          amountBDesired,\\n          reserveB,\\n          reserveA\\n        );\\n        assert(amountAOptimal <= amountADesired);\\n        require(\\n          amountAOptimal >= amountAMin,\\n          \\\"BestDexV2Router: INSUFFICIENT_A_AMOUNT\\\"\\n        );\\n        (amountA, amountB) = (amountAOptimal, amountBDesired);\\n      }\\n    }\\n  }\\n\\n  function addLiquidity(\\n    address tokenA,\\n    address tokenB,\\n    uint256 amountADesired,\\n    uint256 amountBDesired,\\n    uint256 amountAMin,\\n    uint256 amountBMin,\\n    address to,\\n    uint256 deadline\\n  )\\n    external\\n    virtual\\n    override\\n    ensure(deadline)\\n    returns (uint256 amountA, uint256 amountB, uint256 liquidity)\\n  {\\n    (amountA, amountB) = _addLiquidity(\\n      tokenA,\\n      tokenB,\\n      amountADesired,\\n      amountBDesired,\\n      amountAMin,\\n      amountBMin\\n    );\\n    address pair = BestDexV2Library.pairFor(factory, tokenA, tokenB);\\n    TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\\n    TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\\n    liquidity = IBestDexV2Pair(pair).mint(to);\\n  }\\n\\n  function addLiquidityETH(\\n    address token,\\n    uint256 amountTokenDesired,\\n    uint256 amountTokenMin,\\n    uint256 amountETHMin,\\n    address to,\\n    uint256 deadline\\n  )\\n    external\\n    payable\\n    virtual\\n    override\\n    ensure(deadline)\\n    returns (uint256 amountToken, uint256 amountETH, uint256 liquidity)\\n  {\\n    (amountToken, amountETH) = _addLiquidity(\\n      token,\\n      WETH,\\n      amountTokenDesired,\\n      msg.value,\\n      amountTokenMin,\\n      amountETHMin\\n    );\\n    address pair = BestDexV2Library.pairFor(factory, token, WETH);\\n    TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\\n    IWETH(WETH).deposit{ value: amountETH }();\\n    assert(IWETH(WETH).transfer(pair, amountETH));\\n    liquidity = IBestDexV2Pair(pair).mint(to);\\n    // refund dust eth, if any\\n    if (msg.value > amountETH)\\n      TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\\n  }\\n\\n  // **** REMOVE LIQUIDITY ****\\n  function removeLiquidity(\\n    address tokenA,\\n    address tokenB,\\n    uint256 liquidity,\\n    uint256 amountAMin,\\n    uint256 amountBMin,\\n    address to,\\n    uint256 deadline\\n  )\\n    public\\n    virtual\\n    override\\n    ensure(deadline)\\n    returns (uint256 amountA, uint256 amountB)\\n  {\\n    address pair = BestDexV2Library.pairFor(factory, tokenA, tokenB);\\n    IBestDexV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\\n    (uint256 amount0, uint256 amount1) = IBestDexV2Pair(pair).burn(to);\\n    (address token0, ) = BestDexV2Library.sortTokens(tokenA, tokenB);\\n    (amountA, amountB) = tokenA == token0\\n      ? (amount0, amount1)\\n      : (amount1, amount0);\\n    require(amountA >= amountAMin, \\\"BestDexV2Router: INSUFFICIENT_A_AMOUNT\\\");\\n    require(amountB >= amountBMin, \\\"BestDexV2Router: INSUFFICIENT_B_AMOUNT\\\");\\n  }\\n\\n  function removeLiquidityETH(\\n    address token,\\n    uint256 liquidity,\\n    uint256 amountTokenMin,\\n    uint256 amountETHMin,\\n    address to,\\n    uint256 deadline\\n  )\\n    public\\n    virtual\\n    override\\n    ensure(deadline)\\n    returns (uint256 amountToken, uint256 amountETH)\\n  {\\n    (amountToken, amountETH) = removeLiquidity(\\n      token,\\n      WETH,\\n      liquidity,\\n      amountTokenMin,\\n      amountETHMin,\\n      address(this),\\n      deadline\\n    );\\n    TransferHelper.safeTransfer(token, to, amountToken);\\n    IWETH(WETH).withdraw(amountETH);\\n    TransferHelper.safeTransferETH(to, amountETH);\\n  }\\n\\n  function removeLiquidityWithPermit(\\n    address tokenA,\\n    address tokenB,\\n    uint256 liquidity,\\n    uint256 amountAMin,\\n    uint256 amountBMin,\\n    address to,\\n    uint256 deadline,\\n    bool approveMax,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external virtual override returns (uint256 amountA, uint256 amountB) {\\n    address pair = BestDexV2Library.pairFor(factory, tokenA, tokenB);\\n    uint256 value = approveMax ? uint256(-1) : liquidity;\\n    IBestDexV2Pair(pair).permit(\\n      msg.sender,\\n      address(this),\\n      value,\\n      deadline,\\n      v,\\n      r,\\n      s\\n    );\\n    (amountA, amountB) = removeLiquidity(\\n      tokenA,\\n      tokenB,\\n      liquidity,\\n      amountAMin,\\n      amountBMin,\\n      to,\\n      deadline\\n    );\\n  }\\n\\n  function removeLiquidityETHWithPermit(\\n    address token,\\n    uint256 liquidity,\\n    uint256 amountTokenMin,\\n    uint256 amountETHMin,\\n    address to,\\n    uint256 deadline,\\n    bool approveMax,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external virtual override returns (uint256 amountToken, uint256 amountETH) {\\n    address pair = BestDexV2Library.pairFor(factory, token, WETH);\\n    uint256 value = approveMax ? uint256(-1) : liquidity;\\n    IBestDexV2Pair(pair).permit(\\n      msg.sender,\\n      address(this),\\n      value,\\n      deadline,\\n      v,\\n      r,\\n      s\\n    );\\n    (amountToken, amountETH) = removeLiquidityETH(\\n      token,\\n      liquidity,\\n      amountTokenMin,\\n      amountETHMin,\\n      to,\\n      deadline\\n    );\\n  }\\n\\n  // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\\n    address token,\\n    uint256 liquidity,\\n    uint256 amountTokenMin,\\n    uint256 amountETHMin,\\n    address to,\\n    uint256 deadline\\n  ) public virtual override ensure(deadline) returns (uint256 amountETH) {\\n    (, amountETH) = removeLiquidity(\\n      token,\\n      WETH,\\n      liquidity,\\n      amountTokenMin,\\n      amountETHMin,\\n      address(this),\\n      deadline\\n    );\\n    TransferHelper.safeTransfer(\\n      token,\\n      to,\\n      IERC20(token).balanceOf(address(this))\\n    );\\n    IWETH(WETH).withdraw(amountETH);\\n    TransferHelper.safeTransferETH(to, amountETH);\\n  }\\n\\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n    address token,\\n    uint256 liquidity,\\n    uint256 amountTokenMin,\\n    uint256 amountETHMin,\\n    address to,\\n    uint256 deadline,\\n    bool approveMax,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external virtual override returns (uint256 amountETH) {\\n    address pair = BestDexV2Library.pairFor(factory, token, WETH);\\n    uint256 value = approveMax ? uint256(-1) : liquidity;\\n    IBestDexV2Pair(pair).permit(\\n      msg.sender,\\n      address(this),\\n      value,\\n      deadline,\\n      v,\\n      r,\\n      s\\n    );\\n    amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(\\n      token,\\n      liquidity,\\n      amountTokenMin,\\n      amountETHMin,\\n      to,\\n      deadline\\n    );\\n  }\\n\\n  // **** SWAP ****\\n  // requires the initial amount to have already been sent to the first pair\\n  function _swap(\\n    uint256[] memory amounts,\\n    address[] memory path,\\n    address _to\\n  ) internal virtual {\\n    for (uint256 i; i < path.length - 1; i++) {\\n      (address input, address output) = (path[i], path[i + 1]);\\n      (address token0, ) = BestDexV2Library.sortTokens(input, output);\\n      uint256 amountOut = amounts[i + 1];\\n      (uint256 amount0Out, uint256 amount1Out) = input == token0\\n        ? (uint256(0), amountOut)\\n        : (amountOut, uint256(0));\\n      address to = i < path.length - 2\\n        ? BestDexV2Library.pairFor(factory, output, path[i + 2])\\n        : _to;\\n      IBestDexV2Pair(BestDexV2Library.pairFor(factory, input, output)).swap(\\n        amount0Out,\\n        amount1Out,\\n        to,\\n        new bytes(0)\\n      );\\n    }\\n  }\\n\\n  function swapExactTokensForTokens(\\n    uint256 amountIn,\\n    uint256 amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint256 deadline\\n  )\\n    external\\n    virtual\\n    override\\n    ensure(deadline)\\n    returns (uint256[] memory amounts)\\n  {\\n    amounts = BestDexV2Library.getAmountsOut(factory, amountIn, path);\\n    require(\\n      amounts[amounts.length - 1] >= amountOutMin,\\n      \\\"BestDexV2Router: INSUFFICIENT_OUTPUT_AMOUNT\\\"\\n    );\\n    TransferHelper.safeTransferFrom(\\n      path[0],\\n      msg.sender,\\n      BestDexV2Library.pairFor(factory, path[0], path[1]),\\n      amounts[0]\\n    );\\n    _swap(amounts, path, to);\\n\\n    // emit SwapExactInput(address(this), amountIn, amounts, to);\\n    emit SwapTokens(msg.sender, amounts, path, to, 0, block.timestamp);\\n  }\\n\\n  function swapTokensForExactTokens(\\n    uint256 amountOut,\\n    uint256 amountInMax,\\n    address[] calldata path,\\n    address to,\\n    uint256 deadline\\n  )\\n    external\\n    virtual\\n    override\\n    ensure(deadline)\\n    returns (uint256[] memory amounts)\\n  {\\n    amounts = BestDexV2Library.getAmountsIn(factory, amountOut, path);\\n    require(\\n      amounts[0] <= amountInMax,\\n      \\\"BestDexV2Router: EXCESSIVE_INPUT_AMOUNT\\\"\\n    );\\n    TransferHelper.safeTransferFrom(\\n      path[0],\\n      msg.sender,\\n      BestDexV2Library.pairFor(factory, path[0], path[1]),\\n      amounts[0]\\n    );\\n    _swap(amounts, path, to);\\n\\n    // emit SwapExactOutput(address(this), amounts, amountOut, to);\\n    emit SwapTokens(msg.sender, amounts, path, to, 1, block.timestamp);\\n  }\\n\\n  function swapExactETHForTokens(\\n    uint256 amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint256 deadline\\n  )\\n    external\\n    payable\\n    virtual\\n    override\\n    ensure(deadline)\\n    returns (uint256[] memory amounts)\\n  {\\n    require(path[0] == WETH, \\\"BestDexV2Router: INVALID_PATH\\\");\\n    amounts = BestDexV2Library.getAmountsOut(factory, msg.value, path);\\n    require(\\n      amounts[amounts.length - 1] >= amountOutMin,\\n      \\\"BestDexV2Router: INSUFFICIENT_OUTPUT_AMOUNT\\\"\\n    );\\n    IWETH(WETH).deposit{ value: amounts[0] }();\\n    assert(\\n      IWETH(WETH).transfer(\\n        BestDexV2Library.pairFor(factory, path[0], path[1]),\\n        amounts[0]\\n      )\\n    );\\n    _swap(amounts, path, to);\\n\\n    // emit SwapExactInput(address(this), msg.value, amounts, to);\\n    emit SwapTokens(msg.sender, amounts, path, to, 2, block.timestamp);\\n  }\\n\\n  function swapTokensForExactETH(\\n    uint256 amountOut,\\n    uint256 amountInMax,\\n    address[] calldata path,\\n    address to,\\n    uint256 deadline\\n  )\\n    external\\n    virtual\\n    override\\n    ensure(deadline)\\n    returns (uint256[] memory amounts)\\n  {\\n    require(path[path.length - 1] == WETH, \\\"BestDexV2Router: INVALID_PATH\\\");\\n    amounts = BestDexV2Library.getAmountsIn(factory, amountOut, path);\\n    require(\\n      amounts[0] <= amountInMax,\\n      \\\"BestDexV2Router: EXCESSIVE_INPUT_AMOUNT\\\"\\n    );\\n    TransferHelper.safeTransferFrom(\\n      path[0],\\n      msg.sender,\\n      BestDexV2Library.pairFor(factory, path[0], path[1]),\\n      amounts[0]\\n    );\\n    _swap(amounts, path, address(this));\\n    IWETH(WETH).withdraw(amounts[amounts.length - 1]);\\n    TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\\n\\n    // emit SwapExactOutput(msg.sender, amounts, amountOut, to);\\n    emit SwapTokens(msg.sender, amounts, path, to, 3, block.timestamp);\\n  }\\n\\n  function swapExactTokensForETH(\\n    uint256 amountIn,\\n    uint256 amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint256 deadline\\n  )\\n    external\\n    virtual\\n    override\\n    ensure(deadline)\\n    returns (uint256[] memory amounts)\\n  {\\n    require(path[path.length - 1] == WETH, \\\"BestDexV2Router: INVALID_PATH\\\");\\n    amounts = BestDexV2Library.getAmountsOut(factory, amountIn, path);\\n    require(\\n      amounts[amounts.length - 1] >= amountOutMin,\\n      \\\"BestDexV2Router: INSUFFICIENT_OUTPUT_AMOUNT\\\"\\n    );\\n    TransferHelper.safeTransferFrom(\\n      path[0],\\n      msg.sender,\\n      BestDexV2Library.pairFor(factory, path[0], path[1]),\\n      amounts[0]\\n    );\\n    _swap(amounts, path, address(this));\\n    IWETH(WETH).withdraw(amounts[amounts.length - 1]);\\n    TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\\n\\n    // emit SwapExactInput(address(this), amountIn, amounts, to);\\n    emit SwapTokens(msg.sender, amounts, path, to, 4, block.timestamp);\\n  }\\n\\n  function swapETHForExactTokens(\\n    uint256 amountOut,\\n    address[] calldata path,\\n    address to,\\n    uint256 deadline\\n  )\\n    external\\n    payable\\n    virtual\\n    override\\n    ensure(deadline)\\n    returns (uint256[] memory amounts)\\n  {\\n    require(path[0] == WETH, \\\"BestDexV2Router: INVALID_PATH\\\");\\n    amounts = BestDexV2Library.getAmountsIn(factory, amountOut, path);\\n    require(amounts[0] <= msg.value, \\\"BestDexV2Router: EXCESSIVE_INPUT_AMOUNT\\\");\\n    IWETH(WETH).deposit{ value: amounts[0] }();\\n    assert(\\n      IWETH(WETH).transfer(\\n        BestDexV2Library.pairFor(factory, path[0], path[1]),\\n        amounts[0]\\n      )\\n    );\\n    _swap(amounts, path, to);\\n    // refund dust eth, if any\\n    if (msg.value > amounts[0])\\n      TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\\n\\n    // emit SwapExactOutput(address(this), amounts, amountOut, to);\\n    emit SwapTokens(msg.sender, amounts, path, to, 5, block.timestamp);\\n  }\\n\\n  // **** SWAP (supporting fee-on-transfer tokens) ****\\n  // requires the initial amount to have already been sent to the first pair\\n  function _swapSupportingFeeOnTransferTokens(\\n    address[] memory path,\\n    address _to\\n  ) internal virtual returns (uint256[] memory amounts) {\\n    amounts = new uint256[](path.length);\\n    for (uint256 i; i < path.length - 1; i++) {\\n      (address input, address output) = (path[i], path[i + 1]);\\n      (address token0, ) = BestDexV2Library.sortTokens(input, output);\\n      IBestDexV2Pair pair = IBestDexV2Pair(\\n        BestDexV2Library.pairFor(factory, input, output)\\n      );\\n      uint256 amountInput;\\n      uint256 amountOutput;\\n      {\\n        // scope to avoid stack too deep errors\\n        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\\n        (uint256 reserveInput, uint256 reserveOutput) = input == token0\\n          ? (reserve0, reserve1)\\n          : (reserve1, reserve0);\\n        amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);\\n        amountOutput = BestDexV2Library.getAmountOut(\\n          amountInput,\\n          reserveInput,\\n          reserveOutput\\n        );\\n        amounts[i] = amountInput;\\n      }\\n      (uint256 amount0Out, uint256 amount1Out) = input == token0\\n        ? (uint256(0), amountOutput)\\n        : (amountOutput, uint256(0));\\n      address to = i < path.length - 2\\n        ? BestDexV2Library.pairFor(factory, output, path[i + 2])\\n        : _to;\\n      pair.swap(amount0Out, amount1Out, to, new bytes(0));\\n    }\\n    return amounts;\\n  }\\n\\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n    uint256 amountIn,\\n    uint256 amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint256 deadline\\n  ) external virtual override ensure(deadline) {\\n    TransferHelper.safeTransferFrom(\\n      path[0],\\n      msg.sender,\\n      BestDexV2Library.pairFor(factory, path[0], path[1]),\\n      amountIn\\n    );\\n    uint256 balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\\n    uint256[] memory amounts = _swapSupportingFeeOnTransferTokens(path, to);\\n    require(\\n      IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >=\\n        amountOutMin,\\n      \\\"BestDexV2Router: INSUFFICIENT_OUTPUT_AMOUNT\\\"\\n    );\\n    amounts[amounts.length - 1] = IERC20(path[path.length - 1])\\n      .balanceOf(to)\\n      .sub(balanceBefore);\\n\\n    emit SwapTokens(msg.sender, amounts, path, to, 6, block.timestamp);\\n  }\\n\\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n    uint256 amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint256 deadline\\n  ) external payable virtual override ensure(deadline) {\\n    require(path[0] == WETH, \\\"BestDexV2Router: INVALID_PATH\\\");\\n    uint256 amountIn = msg.value;\\n    IWETH(WETH).deposit{ value: amountIn }();\\n    assert(\\n      IWETH(WETH).transfer(\\n        BestDexV2Library.pairFor(factory, path[0], path[1]),\\n        amountIn\\n      )\\n    );\\n    uint256 balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\\n    uint256[] memory amounts = _swapSupportingFeeOnTransferTokens(path, to);\\n    require(\\n      IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >=\\n        amountOutMin,\\n      \\\"BestDexV2Router: INSUFFICIENT_OUTPUT_AMOUNT\\\"\\n    );\\n    amounts[amounts.length - 1] = IERC20(path[path.length - 1])\\n      .balanceOf(to)\\n      .sub(balanceBefore);\\n\\n    emit SwapTokens(msg.sender, amounts, path, to, 7, block.timestamp);\\n  }\\n\\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n    uint256 amountIn,\\n    uint256 amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint256 deadline\\n  ) external virtual override ensure(deadline) {\\n    require(path[path.length - 1] == WETH, \\\"BestDexV2Router: INVALID_PATH\\\");\\n    TransferHelper.safeTransferFrom(\\n      path[0],\\n      msg.sender,\\n      BestDexV2Library.pairFor(factory, path[0], path[1]),\\n      amountIn\\n    );\\n    uint256[] memory amounts = _swapSupportingFeeOnTransferTokens(\\n      path,\\n      address(this)\\n    );\\n    uint256 amountOut = IERC20(WETH).balanceOf(address(this));\\n    require(\\n      amountOut >= amountOutMin,\\n      \\\"BestDexV2Router: INSUFFICIENT_OUTPUT_AMOUNT\\\"\\n    );\\n    IWETH(WETH).withdraw(amountOut);\\n    TransferHelper.safeTransferETH(to, amountOut);\\n    amounts[amounts.length - 1] = amountOut;\\n\\n    emit SwapTokens(msg.sender, amounts, path, to, 8, block.timestamp);\\n  }\\n\\n  // **** LIBRARY FUNCTIONS ****\\n  function quote(\\n    uint256 amountA,\\n    uint256 reserveA,\\n    uint256 reserveB\\n  ) public pure virtual override returns (uint256 amountB) {\\n    return BestDexV2Library.quote(amountA, reserveA, reserveB);\\n  }\\n\\n  function getAmountOut(\\n    uint256 amountIn,\\n    uint256 reserveIn,\\n    uint256 reserveOut\\n  ) public pure virtual override returns (uint256 amountOut) {\\n    return BestDexV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\\n  }\\n\\n  function getAmountIn(\\n    uint256 amountOut,\\n    uint256 reserveIn,\\n    uint256 reserveOut\\n  ) public pure virtual override returns (uint256 amountIn) {\\n    return BestDexV2Library.getAmountIn(amountOut, reserveIn, reserveOut);\\n  }\\n\\n  function getAmountsOut(\\n    uint256 amountIn,\\n    address[] memory path\\n  ) public view virtual override returns (uint256[] memory amounts) {\\n    return BestDexV2Library.getAmountsOut(factory, amountIn, path);\\n  }\\n\\n  function getAmountsIn(\\n    uint256 amountOut,\\n    address[] memory path\\n  ) public view virtual override returns (uint256[] memory amounts) {\\n    return BestDexV2Library.getAmountsIn(factory, amountOut, path);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBestDexV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IBestDexV2Router01 {\\n  function factory() external pure returns (address);\\n\\n  function WETH() external pure returns (address);\\n\\n  function addLiquidity(\\n    address tokenA,\\n    address tokenB,\\n    uint amountADesired,\\n    uint amountBDesired,\\n    uint amountAMin,\\n    uint amountBMin,\\n    address to,\\n    uint deadline\\n  ) external returns (uint amountA, uint amountB, uint liquidity);\\n\\n  function addLiquidityETH(\\n    address token,\\n    uint amountTokenDesired,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline\\n  ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n\\n  function removeLiquidity(\\n    address tokenA,\\n    address tokenB,\\n    uint liquidity,\\n    uint amountAMin,\\n    uint amountBMin,\\n    address to,\\n    uint deadline\\n  ) external returns (uint amountA, uint amountB);\\n\\n  function removeLiquidityETH(\\n    address token,\\n    uint liquidity,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline\\n  ) external returns (uint amountToken, uint amountETH);\\n\\n  function removeLiquidityWithPermit(\\n    address tokenA,\\n    address tokenB,\\n    uint liquidity,\\n    uint amountAMin,\\n    uint amountBMin,\\n    address to,\\n    uint deadline,\\n    bool approveMax,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external returns (uint amountA, uint amountB);\\n\\n  function removeLiquidityETHWithPermit(\\n    address token,\\n    uint liquidity,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline,\\n    bool approveMax,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external returns (uint amountToken, uint amountETH);\\n\\n  function swapExactTokensForTokens(\\n    uint amountIn,\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external returns (uint[] memory amounts);\\n\\n  function swapTokensForExactTokens(\\n    uint amountOut,\\n    uint amountInMax,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external returns (uint[] memory amounts);\\n\\n  function swapExactETHForTokens(\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external payable returns (uint[] memory amounts);\\n\\n  function swapTokensForExactETH(\\n    uint amountOut,\\n    uint amountInMax,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external returns (uint[] memory amounts);\\n\\n  function swapExactTokensForETH(\\n    uint amountIn,\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external returns (uint[] memory amounts);\\n\\n  function swapETHForExactTokens(\\n    uint amountOut,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external payable returns (uint[] memory amounts);\\n\\n  function quote(\\n    uint amountA,\\n    uint reserveA,\\n    uint reserveB\\n  ) external pure returns (uint amountB);\\n\\n  function getAmountOut(\\n    uint amountIn,\\n    uint reserveIn,\\n    uint reserveOut\\n  ) external pure returns (uint amountOut);\\n\\n  function getAmountIn(\\n    uint amountOut,\\n    uint reserveIn,\\n    uint reserveOut\\n  ) external pure returns (uint amountIn);\\n\\n  function getAmountsOut(\\n    uint amountIn,\\n    address[] calldata path\\n  ) external view returns (uint[] memory amounts);\\n\\n  function getAmountsIn(\\n    uint amountOut,\\n    address[] calldata path\\n  ) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBestDexV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\nimport \\\"./IBestDexV2Router01.sol\\\";\\n\\ninterface IBestDexV2Router02 is IBestDexV2Router01 {\\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\\n    address token,\\n    uint liquidity,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline\\n  ) external returns (uint amountETH);\\n\\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n    address token,\\n    uint liquidity,\\n    uint amountTokenMin,\\n    uint amountETHMin,\\n    address to,\\n    uint deadline,\\n    bool approveMax,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external returns (uint amountETH);\\n\\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n    uint amountIn,\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external;\\n\\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external payable;\\n\\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n    uint amountIn,\\n    uint amountOutMin,\\n    address[] calldata path,\\n    address to,\\n    uint deadline\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n    function transfer(address to, uint value) external returns (bool);\\n    function withdraw(uint) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/BestDexV2Library.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\nimport \\\"../v2-core/contracts/interfaces/IBestDexV2Pair.sol\\\";\\n\\nimport \\\"./SafeMath.sol\\\";\\n\\nlibrary BestDexV2Library {\\n  using SafeMath for uint;\\n\\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\\n  function sortTokens(\\n    address tokenA,\\n    address tokenB\\n  ) internal pure returns (address token0, address token1) {\\n    require(tokenA != tokenB, \\\"BestDexV2Library: IDENTICAL_ADDRESSES\\\");\\n    (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n    require(token0 != address(0), \\\"BestDexV2Library: ZERO_ADDRESS\\\");\\n  }\\n\\n  // calculates the CREATE2 address for a pair without making any external calls\\n  function pairFor(\\n    address factory,\\n    address tokenA,\\n    address tokenB\\n  ) internal pure returns (address pair) {\\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\\n    pair = address(\\n      uint(\\n        keccak256(\\n          abi.encodePacked(\\n            hex\\\"ff\\\",\\n            factory,\\n            keccak256(abi.encodePacked(token0, token1)),\\n            hex\\\"bc471bbbb2273e96c6d2092b38790f3213a407a6cb2cabcbd0f640b9f59da74e\\\" // init code hash\\n          )\\n        )\\n      )\\n    );\\n  }\\n  // fetches and sorts the reserves for a pair\\n  function getReserves(\\n    address factory,\\n    address tokenA,\\n    address tokenB\\n  ) internal view returns (uint reserveA, uint reserveB) {\\n    (address token0, ) = sortTokens(tokenA, tokenB);\\n    (uint reserve0, uint reserve1, ) = IBestDexV2Pair(\\n      pairFor(factory, tokenA, tokenB)\\n    ).getReserves();\\n    (reserveA, reserveB) = tokenA == token0\\n      ? (reserve0, reserve1)\\n      : (reserve1, reserve0);\\n  }\\n\\n  // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\\n  function quote(\\n    uint amountA,\\n    uint reserveA,\\n    uint reserveB\\n  ) internal pure returns (uint amountB) {\\n    require(amountA > 0, \\\"BestDexV2Library: INSUFFICIENT_AMOUNT\\\");\\n    require(\\n      reserveA > 0 && reserveB > 0,\\n      \\\"BestDexV2Library: INSUFFICIENT_LIQUIDITY\\\"\\n    );\\n    amountB = amountA.mul(reserveB) / reserveA;\\n  }\\n\\n  // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\\n  function getAmountOut(\\n    uint amountIn,\\n    uint reserveIn,\\n    uint reserveOut\\n  ) internal pure returns (uint amountOut) {\\n    require(amountIn > 0, \\\"BestDexV2Library: INSUFFICIENT_INPUT_AMOUNT\\\");\\n    require(\\n      reserveIn > 0 && reserveOut > 0,\\n      \\\"BestDexV2Library: INSUFFICIENT_LIQUIDITY\\\"\\n    );\\n    uint amountInWithFee = amountIn.mul(997);\\n    uint numerator = amountInWithFee.mul(reserveOut);\\n    uint denominator = reserveIn.mul(1000).add(amountInWithFee);\\n    amountOut = numerator / denominator;\\n  }\\n\\n  // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\\n  function getAmountIn(\\n    uint amountOut,\\n    uint reserveIn,\\n    uint reserveOut\\n  ) internal pure returns (uint amountIn) {\\n    require(amountOut > 0, \\\"BestDexV2Library: INSUFFICIENT_OUTPUT_AMOUNT\\\");\\n    require(\\n      reserveIn > 0 && reserveOut > 0,\\n      \\\"BestDexV2Library: INSUFFICIENT_LIQUIDITY\\\"\\n    );\\n    uint numerator = reserveIn.mul(amountOut).mul(1000);\\n    uint denominator = reserveOut.sub(amountOut).mul(997);\\n    amountIn = (numerator / denominator).add(1);\\n  }\\n\\n  // performs chained getAmountOut calculations on any number of pairs\\n  function getAmountsOut(\\n    address factory,\\n    uint amountIn,\\n    address[] memory path\\n  ) internal view returns (uint[] memory amounts) {\\n    require(path.length >= 2, \\\"BestDexV2Library: INVALID_PATH\\\");\\n    amounts = new uint[](path.length);\\n    amounts[0] = amountIn;\\n    for (uint i; i < path.length - 1; i++) {\\n      (uint reserveIn, uint reserveOut) = getReserves(\\n        factory,\\n        path[i],\\n        path[i + 1]\\n      );\\n      amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\\n    }\\n  }\\n\\n  // performs chained getAmountIn calculations on any number of pairs\\n  function getAmountsIn(\\n    address factory,\\n    uint amountOut,\\n    address[] memory path\\n  ) internal view returns (uint[] memory amounts) {\\n    require(path.length >= 2, \\\"BestDexV2Library: INVALID_PATH\\\");\\n    amounts = new uint[](path.length);\\n    amounts[amounts.length - 1] = amountOut;\\n    for (uint i = path.length - 1; i > 0; i--) {\\n      (uint reserveIn, uint reserveOut) = getReserves(\\n        factory,\\n        path[i - 1],\\n        path[i]\\n      );\\n      amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity =0.6.6;\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary SafeMath {\\n    function add(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x + y) >= x, 'ds-math-add-overflow');\\n    }\\n\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\\n    }\\n\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.6.0;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            'TransferHelper::safeApprove: approve failed'\\n        );\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            'TransferHelper::safeTransfer: transfer failed'\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            'TransferHelper::transferFrom: transferFrom failed'\\n        );\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/v2-core/contracts/interfaces/IBestDexV2Factory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IBestDexV2Factory {\\n  event PairCreated(\\n    address indexed token0,\\n    address indexed token1,\\n    address pair,\\n    uint\\n  );\\n\\n  function feeTo() external view returns (address);\\n\\n  function feeToSetter() external view returns (address);\\n\\n  function getPair(\\n    address tokenA,\\n    address tokenB\\n  ) external view returns (address pair);\\n\\n  function allPairs(uint) external view returns (address pair);\\n\\n  function allPairsLength() external view returns (uint);\\n\\n  function createPair(\\n    address tokenA,\\n    address tokenB\\n  ) external returns (address pair);\\n\\n  function setFeeTo(address) external;\\n\\n  function setFeeToSetter(address) external;\\n}\\n\"\r\n    },\r\n    \"contracts/v2-core/contracts/interfaces/IBestDexV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IBestDexV2Pair {\\n  event Approval(address indexed owner, address indexed spender, uint value);\\n  event Transfer(address indexed from, address indexed to, uint value);\\n\\n  function name() external pure returns (string memory);\\n\\n  function symbol() external pure returns (string memory);\\n\\n  function decimals() external pure returns (uint8);\\n\\n  function totalSupply() external view returns (uint);\\n\\n  function balanceOf(address owner) external view returns (uint);\\n\\n  function allowance(\\n    address owner,\\n    address spender\\n  ) external view returns (uint);\\n\\n  function approve(address spender, uint value) external returns (bool);\\n\\n  function transfer(address to, uint value) external returns (bool);\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint value\\n  ) external returns (bool);\\n\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n  function nonces(address owner) external view returns (uint);\\n\\n  function permit(\\n    address owner,\\n    address spender,\\n    uint value,\\n    uint deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external;\\n\\n  event Mint(address indexed sender, uint amount0, uint amount1);\\n  event Burn(\\n    address indexed sender,\\n    uint amount0,\\n    uint amount1,\\n    address indexed to\\n  );\\n  event Swap(\\n    address indexed sender,\\n    uint amount0In,\\n    uint amount1In,\\n    uint amount0Out,\\n    uint amount1Out,\\n    address indexed to\\n  );\\n  event Sync(uint112 reserve0, uint112 reserve1);\\n\\n  function MINIMUM_LIQUIDITY() external pure returns (uint);\\n\\n  function factory() external view returns (address);\\n\\n  function token0() external view returns (address);\\n\\n  function token1() external view returns (address);\\n\\n  function getReserves()\\n    external\\n    view\\n    returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n\\n  function price0CumulativeLast() external view returns (uint);\\n\\n  function price1CumulativeLast() external view returns (uint);\\n\\n  function kLast() external view returns (uint);\\n\\n  function mint(address to) external returns (uint liquidity);\\n\\n  function burn(address to) external returns (uint amount0, uint amount1);\\n\\n  function swap(\\n    uint amount0Out,\\n    uint amount1Out,\\n    address to,\\n    bytes calldata data\\n  ) external;\\n\\n  function skim(address to) external;\\n\\n  function sync() external;\\n\\n  function initialize(address, address) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 400\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_WETH\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"SwapTokens\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountADesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBDesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenDesired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"addLiquidityETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveOut\",\"type\":\"uint256\"}],\"name\":\"getAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveOut\",\"type\":\"uint256\"}],\"name\":\"getAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"getAmountsIn\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"getAmountsOut\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveB\",\"type\":\"uint256\"}],\"name\":\"quote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"removeLiquidityETHSupportingFeeOnTransferTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"approveMax\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"removeLiquidityETHWithPermit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"approveMax\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"removeLiquidityETHWithPermitSupportingFeeOnTransferTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountAMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountBMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"approveMax\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"removeLiquidityWithPermit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapETHForExactTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactETHForTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactETHForTokensSupportingFeeOnTransferTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForETH\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForETHSupportingFeeOnTransferTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForTokensSupportingFeeOnTransferTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMax\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapTokensForExactETH\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMax\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapTokensForExactTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "BestDexV2Router02", "CompilerVersion": "v0.6.6+commit.6c089d02", "OptimizationUsed": "1", "Runs": "400", "ConstructorArguments": "000000000000000000000000e859a7685c906dd7a53919da5891cae0cb531f6e000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}