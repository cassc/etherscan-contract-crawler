{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/GammaStrategy.sol\": {\r\n      \"content\": \"pragma solidity 0.8.15;\\n\\n// SPDX-License-Identifier: MIT\\n\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return payable(msg.sender);\\n    }\\n}\\n\\ninterface IERC20 {\\n   \\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n}\\n\\nlibrary Address {\\n   \\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + (value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    // not been called from anywhere\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance =\\n            token.allowance(address(this), spender) - (value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor() {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\\nabstract contract ReentrancyGuard {\\n   \\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n        _;\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\\ninterface IWBNB is IERC20 {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256 wad) external;\\n}\\n\\ninterface IToken {\\n    function totalSupply() external view returns(uint);\\n}\\n\\ninterface GammaTroller {\\n    function claimGamma(address[] memory holders,address[] memory gTokens,bool borrowers,bool suppliers) external ;\\n}\\n\\ninterface Gtoken {\\n    function mint(uint mintAmount) external returns (uint);\\n    function redeem(uint redeemTokens) external returns (uint); \\n}\\n\\nabstract contract StratX2 is Ownable, ReentrancyGuard {\\n\\n    using SafeERC20 for IERC20;\\n\\n    address public wantAddress;\\n    address public rewardsAddress;\\n    address public feeRewardsUpdater;\\n\\n    address public wbnbAddress;\\n    address public gammaFarmAddress;\\n    address public GAMMAAddress;\\n    address public iGammaAddress;\\n    address public gammaTrollerAddress;\\n\\n    uint256 public feeRewardsAccruedPerWeek;\\n    uint256 public feeRewardsAccrued;\\n    \\n    uint256 public wantLockedTotal;\\n    uint256 public constant initialExchangeRate = 1e8;\\n   \\n    uint256 public entranceFeeFactor; \\n    uint256 public constant entranceFeeFactorMax = 50; // 0.5% is the max entrance fee settable. LL = lowerlimit\\n\\n    uint256 public withdrawFeeFactor = 100;\\n    uint256 public constant withdrawFeeFactorMax = 200; // 2% is the max entrance fee settable. LL = lowerlimit\\n\\n    uint256 public performanceFee = 1000; //10%\\n    uint256 public constant performanceFeeMax = 2500; //25%\\n\\n    uint256 public instantWithdrawFeeFactor = 500; // 5%;\\n    uint256 public constant instantWithdrawFeeFactorMax = 1000; //10%\\n\\n    event SetSettings(\\n        uint256 _entranceFeeFactor, \\n        uint256 _withdrawFeeFactor,\\n        uint256 _instantWithdrawFeeFactor,\\n        uint256 _performanceFee\\n    );\\n\\n    event SetRewardsAddress(address _rewardsAddress);\\n    error Unauthorized(address caller);\\n\\n    function checkForFarmAddressCall() private view  {\\n        if(msg.sender != gammaFarmAddress) \\n        {\\n            revert Unauthorized(msg.sender);\\n        }\\n    }\\n\\n    /**\\n    * @notice Calculates the exchange rate from the gToken to the iToken\\n    * @return (calculated exchange rate scaled by 1e18)\\n    */\\n    function iTokenExchangeRate() public view returns (uint) {\\n        uint256 _totalSupply = IToken(iGammaAddress).totalSupply();\\n        if (_totalSupply == 0) {\\n           /**\\n            * If there are no iTokens minted:\\n            *  exchangeRate = initialExchangeRate\\n            */\\n            return (initialExchangeRate); //1e8\\n        } else { \\n            return ((wantLockedTotal * 1e18) / _totalSupply);\\n        }\\n    }\\n\\n    function getUserGtokenBal(address _user) external view returns (uint256 gGAMMABalance){\\n        gGAMMABalance = (IERC20(iGammaAddress).balanceOf(_user) * iTokenExchangeRate())/1e18;\\n    }\\n\\n    // Executes deposit based on whether or not to charge fee\\n    function deposit(uint256 _wantAmt, bool _chargeFee) external virtual nonReentrant returns (uint256) {\\n        checkForFarmAddressCall();\\n        uint256 balBefore = IERC20(wantAddress).balanceOf(address(this));\\n        IERC20(GAMMAAddress).safeIncreaseAllowance(wantAddress, _wantAmt);\\n        Gtoken(wantAddress).mint(_wantAmt);\\n        uint256 depositAmount = IERC20(wantAddress).balanceOf(address(this)) - balBefore;\\n\\n        uint256 depositFee;\\n        if(_chargeFee) {\\n            depositFee = (depositAmount* entranceFeeFactor)/ 10000;\\n        }\\n        \\n        if(depositFee != 0){\\n            depositAmount = depositAmount - depositFee;\\n            IERC20(wantAddress).safeTransfer(rewardsAddress, depositFee);\\n        }\\n\\n        uint256 current_exchange_rate = iTokenExchangeRate();\\n        uint256 mintAmount = (depositAmount * 1e18) / current_exchange_rate;\\n\\n        wantLockedTotal = wantLockedTotal + depositAmount;\\n        \\n        return (mintAmount);\\n    }\\n\\n    function unstake(uint256 _wantAmt, bool instantly) public virtual nonReentrant returns (uint256, uint256) {\\n        checkForFarmAddressCall();\\n\\n        if (wantLockedTotal < _wantAmt) {\\n            _wantAmt = wantLockedTotal;\\n        }\\n\\n        uint256 balanceOfStrat = IERC20(wantAddress).balanceOf(address(this));\\n        if (_wantAmt > balanceOfStrat) {\\n            _wantAmt = balanceOfStrat;\\n        }\\n        \\n        uint256 stratWantTokensRemoved = _wantAmt;\\n        uint256 withdrawFee;\\n        uint256 withdrawAmount;\\n        uint256 feeFactor = withdrawFeeFactor;\\n\\n        if(instantly) {\\n            feeFactor = instantWithdrawFeeFactor;\\n        }\\n        \\n        if (_wantAmt != 0) {\\n            withdrawFee = (_wantAmt * feeFactor)/10000;\\n            _wantAmt = _wantAmt - withdrawFee;\\n            withdrawFee = withdrawFee/2;\\n            wantLockedTotal = wantLockedTotal - _wantAmt - withdrawFee;\\n            IERC20(wantAddress).safeTransfer(rewardsAddress, withdrawFee);\\n\\n            feeRewardsAccrued += withdrawFee;\\n\\n            uint256 balBefore = IERC20(GAMMAAddress).balanceOf(address(this));\\n            Gtoken(wantAddress).redeem(_wantAmt);\\n            withdrawAmount = IERC20(GAMMAAddress).balanceOf(address(this)) - balBefore;\\n            \\n            IERC20(GAMMAAddress).safeTransfer(gammaFarmAddress, withdrawAmount);\\n        }\\n        return (withdrawAmount, stratWantTokensRemoved);\\n    }\\n\\n    function getShares() external virtual view returns (uint256, uint256) {\\n        return (wantLockedTotal, IToken(iGammaAddress).totalSupply());\\n    }\\n\\n     function sharesTotal() external virtual view returns (uint256) {\\n        return IToken(iGammaAddress).totalSupply();\\n    }\\n\\n    function setSettings(\\n        uint256 _entranceFeeFactor, \\n        uint256 _withdrawFeeFactor,\\n        uint256 _instantWithdrawFeeFactor,\\n        uint256 _performanceFee\\n    ) external virtual onlyOwner {\\n    \\n        require(_entranceFeeFactor <= entranceFeeFactorMax, \\\"_entranceFeeFactor too high\\\");\\n        entranceFeeFactor = _entranceFeeFactor;\\n\\n        require(_withdrawFeeFactor <= withdrawFeeFactorMax, \\\"_withdrawFeeFactor too high\\\");\\n        withdrawFeeFactor = _withdrawFeeFactor;\\n\\n        require(_instantWithdrawFeeFactor <= instantWithdrawFeeFactorMax, \\\"_instantWithdrawFeeFactor too high\\\");\\n        instantWithdrawFeeFactor = _instantWithdrawFeeFactor;\\n\\n        require(_performanceFee <= performanceFeeMax, \\\"_performanceFee too high\\\");\\n        performanceFee = _performanceFee;\\n\\n        emit SetSettings(_entranceFeeFactor, _withdrawFeeFactor,_instantWithdrawFeeFactor, _performanceFee);\\n    }\\n\\n    function setRewardsAddress(address _rewardsAddress) external virtual onlyOwner {\\n        rewardsAddress = _rewardsAddress;\\n        emit SetRewardsAddress(_rewardsAddress);\\n    }\\n\\n    /**\\n    * @notice this will change fee rewards updater address\\n    *         in the contract it is called by owner address only\\n    */\\n    function changeFeeRewardsUpdater(address _newFeeRewardsUpdater) external onlyOwner {\\n        feeRewardsUpdater = _newFeeRewardsUpdater;\\n    }\\n\\n    /**\\n    * @notice this will update feeRewardsAccruedPerWeek value\\n    *         in the contract it is called by feeRewardsUpdater address only\\n    */\\n\\n    function updateFeeRewards() external {\\n        require(_msgSender()  == feeRewardsUpdater,\\\"Caller is not fee rewards updater\\\");\\n        if(feeRewardsAccrued > 0){\\n            feeRewardsAccruedPerWeek = feeRewardsAccrued;\\n            feeRewardsAccrued = 0;\\n        }\\n    }\\n\\n    function inCaseTokensGetStuck(address _token) external onlyOwner {\\n        require(_token != address(wantAddress), \\\"Token cannot be same as deposit token\\\");\\n        require(_token != GAMMAAddress, \\\"Token cannot be same as gamma token\\\");\\n        uint256 amount = IERC20(_token).balanceOf(address(this));\\n        IERC20(_token).safeTransfer(_msgSender(), amount);\\n    }\\n\\n    function _wrapBNB() internal virtual {\\n        // BNB -> WBNB\\n        uint256 bnbBal = address(this).balance;\\n        if (bnbBal != 0) {\\n            IWBNB(wbnbAddress).deposit{value: bnbBal}(); // BNB -> WBNB\\n        }\\n    }\\n\\n    function wrapBNB() external virtual onlyOwner {\\n        _wrapBNB();\\n    }\\n\\n    function claimPendingGamma() internal {\\n        \\n        address[] memory holders = new address[](1);\\n        holders[0] = address(this);\\n\\n        address[] memory gTokens = new address[](1);\\n        gTokens[0] = address(wantAddress);\\n\\n        GammaTroller(gammaTrollerAddress).claimGamma(holders,gTokens, false, true);        \\n\\n    }\\n\\n    function earnGammaProfits() external returns (uint256){\\n        checkForFarmAddressCall();\\n        claimPendingGamma();\\n        //invest GAMMA into gTOKEN\\n        IERC20 gToken = IERC20(wantAddress);\\n        uint256 bal = IERC20(GAMMAAddress).balanceOf(address(this));\\n        if (bal != 0) {\\n            uint256 gTokenBalBefore = gToken.balanceOf(address(this));\\n            IERC20(GAMMAAddress).safeIncreaseAllowance(wantAddress, bal);\\n            Gtoken(wantAddress).mint(bal);\\n            uint256 gTokenBal = gToken.balanceOf(address(this)) - gTokenBalBefore;\\n            uint256 fee = (gTokenBal * performanceFee) / 10000;\\n            gTokenBal = gTokenBal - fee;\\n            gToken.safeTransfer(rewardsAddress,fee);\\n            wantLockedTotal = wantLockedTotal + gTokenBal;\\n        }\\n\\treturn bal;\\n    }\\n}\\n\\ncontract GammaStrategy_GAMMA is StratX2 {\\n    \\n    constructor(\\n        address[] memory _addresses,\\n        uint256 _entranceFeeFactor,\\n        uint256 _withdrawFeeFactor,\\n        uint256 _instantWithdrawFeeFactor\\n\\n    ) {\\n        wbnbAddress = _addresses[0];\\n        gammaFarmAddress = _addresses[1];\\n        GAMMAAddress = _addresses[2];\\n        wantAddress = _addresses[3];\\n        iGammaAddress = _addresses[4];\\n        gammaTrollerAddress = _addresses[5];\\n        rewardsAddress = _addresses[6];\\n\\tfeeRewardsUpdater = _addresses[7];\\n\\n        entranceFeeFactor = _entranceFeeFactor;\\n        withdrawFeeFactor = _withdrawFeeFactor;\\n        instantWithdrawFeeFactor =_instantWithdrawFeeFactor;\\n        //transferOwnership(gammaFarmAddress);\\n    }\\n\\n    function changeGammaTrollerAddress(address _gammatrollerAddress) public onlyOwner {\\n        gammaTrollerAddress = _gammatrollerAddress;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 20000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_entranceFeeFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawFeeFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_instantWithdrawFeeFactor\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_rewardsAddress\",\"type\":\"address\"}],\"name\":\"SetRewardsAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_entranceFeeFactor\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_withdrawFeeFactor\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_instantWithdrawFeeFactor\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_performanceFee\",\"type\":\"uint256\"}],\"name\":\"SetSettings\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"GAMMAAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newFeeRewardsUpdater\",\"type\":\"address\"}],\"name\":\"changeFeeRewardsUpdater\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gammatrollerAddress\",\"type\":\"address\"}],\"name\":\"changeGammaTrollerAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_wantAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_chargeFee\",\"type\":\"bool\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"earnGammaProfits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"entranceFeeFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"entranceFeeFactorMax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeRewardsAccrued\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeRewardsAccruedPerWeek\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeRewardsUpdater\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gammaFarmAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gammaTrollerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserGtokenBal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"gGAMMABalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"iGammaAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"iTokenExchangeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"inCaseTokensGetStuck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialExchangeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"instantWithdrawFeeFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"instantWithdrawFeeFactorMax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"performanceFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"performanceFeeMax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardsAddress\",\"type\":\"address\"}],\"name\":\"setRewardsAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_entranceFeeFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawFeeFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_instantWithdrawFeeFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_performanceFee\",\"type\":\"uint256\"}],\"name\":\"setSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sharesTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_wantAmt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"instantly\",\"type\":\"bool\"}],\"name\":\"unstake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateFeeRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wantAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wantLockedTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wbnbAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFeeFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFeeFactorMax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wrapBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "GammaStrategy_GAMMA", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "20000", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000001f40000000000000000000000000000000000000000000000000000000000000008000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c0000000000000000000000008722686d62ab8c6bc21b1a806bd825a04d6dcb6d000000000000000000000000b3cb6d2f8f2fde203a022201c81a96c167607f15000000000000000000000000cd221e1504442671671d3330cb8e916a5edc3fc7000000000000000000000000db287dc49634f0443c4a8f229d7b2241c2011c0c0000000000000000000000001e0c9d09f9995b95ec4175aaa18b49f49f6165a3000000000000000000000000ac88bd12c992b1adbb43183a0aa5e3fa5ae3e5ee000000000000000000000000fbb8d3ace23f822a412ac6f150e75ec8d29e51f8", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}