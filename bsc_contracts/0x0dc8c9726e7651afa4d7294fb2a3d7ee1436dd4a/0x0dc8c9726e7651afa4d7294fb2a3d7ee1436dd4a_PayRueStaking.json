{"SourceCode": "{\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"},\"PayRueStaking.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n/**\\n* The PayRue Staking Contract\\n*\\n* Features and assumptions:\\n* - Users stake PROPEL and also receive PROPEL (though it also supports other tokens with 1:1 reward ratio)\\n* - APY is always 100% - you stake 10 000 PROPEL, you get 10 000 PROPEL as rewards during the next year\\n* - Each stake is guaranteed the 100% reward in 365 days, after which they can still get new rewards if\\n*   there is reward money left in the contract. If the reward cannot be guaranteed, the stake will not be accepted.\\n* - Each stake is locked for 365 days, after which it can be unstaked or left in the contract\\n*/\\npragma solidity ^0.8.0;\\n\\nimport \\\"Ownable.sol\\\";\\nimport \\\"ReentrancyGuard.sol\\\";\\nimport \\\"IERC20.sol\\\";\\n\\ncontract PayRueStaking is ReentrancyGuard, Ownable {\\n    event Staked(\\n        address indexed user,\\n        uint256 amount\\n    );\\n\\n    event Unstaked(\\n        address indexed user,\\n        uint256 amount\\n    );\\n\\n    event RewardPaid(\\n        address indexed user,\\n        uint256 amount\\n    );\\n\\n    event EmergencyWithdrawalInitiated();\\n\\n    struct Stake {\\n        uint256 amount;\\n        uint256 timestamp;\\n    }\\n\\n    struct UserStakingData {\\n        uint256 amountStaked;\\n        uint256 guaranteedReward;\\n        uint256 storedReward;\\n        uint256 storedRewardUpdatedOn;\\n        uint256 firstActiveStakeIndex; // for gas optimization if many stakes\\n        Stake[] stakes;\\n    }\\n\\n    uint256 public constant lockedPeriod = 365 days;\\n    uint256 public constant yieldPeriod = 365 days;\\n\\n    IERC20 public stakingToken;\\n    IERC20 public rewardToken;\\n    bool internal _stakingTokenIsRewardToken;\\n\\n    uint256 public minStakeAmount = 10_000 ether; // should be at least 1\\n    bool public emergencyWithdrawalInProgress = false;\\n    bool public paused = false;\\n\\n    mapping(address =\\u003e UserStakingData) stakingDataByUser;\\n\\n    uint256 public totalAmountStaked = 0;\\n    uint256 public totalGuaranteedReward = 0;\\n    uint256 public totalStoredReward = 0;\\n\\n    constructor(\\n        address _stakingToken,\\n        address _rewardToken\\n    )\\n    Ownable()\\n    {\\n        stakingToken = IERC20(_stakingToken);\\n        rewardToken = IERC20(_rewardToken);\\n        _stakingTokenIsRewardToken = _stakingToken == _rewardToken;\\n    }\\n\\n    // PUBLIC USER API\\n    // ===============\\n\\n    function stake(\\n        uint256 amount\\n    )\\n    public\\n    virtual\\n    nonReentrant\\n    {\\n        require(!paused, \\\"Staking is temporarily paused, no new stakes accepted\\\");\\n        require(!emergencyWithdrawalInProgress, \\\"Emergency withdrawal in progress, no new stakes accepted\\\");\\n        require(amount \\u003e= minStakeAmount, \\\"Minimum stake amount not met\\\");\\n        // This needs to be checked before accepting the stake, in case stakedToken and rewardToken are the same\\n        require(\\n            availableToStakeOrReward() \\u003e= amount,\\n            \\\"Not enough rewards left to accept new stakes for given amount\\\"\\n        );\\n        require(\\n            stakingToken.transferFrom(msg.sender, address(this), amount),\\n            \\\"Cannot transfer balance\\\"\\n        );\\n\\n        UserStakingData storage userData = stakingDataByUser[msg.sender];\\n\\n        // Update stored reward, in case the user has already staked\\n        _updateStoredReward(userData);\\n\\n        userData.stakes.push(Stake({\\n            amount: amount,\\n            timestamp: block.timestamp\\n        }));\\n        userData.amountStaked += amount;\\n        totalAmountStaked += amount;\\n        userData.guaranteedReward += amount;\\n        totalGuaranteedReward += amount;\\n        userData.storedRewardUpdatedOn = block.timestamp;  // may waste some gas, but would rather be safe than sorry\\n\\n        emit Staked(\\n            msg.sender,\\n            amount\\n        );\\n    }\\n\\n    function claimReward()\\n    public\\n    virtual\\n    nonReentrant\\n    {\\n        _rewardUser(msg.sender);\\n    }\\n\\n    function unstake(\\n        uint256 amount\\n    )\\n    public\\n    virtual\\n    nonReentrant\\n    {\\n        _unstakeUser(msg.sender, amount);\\n    }\\n\\n    function exit()\\n    public\\n    virtual\\n    nonReentrant\\n    {\\n        UserStakingData storage userData = stakingDataByUser[msg.sender];\\n        if (userData.amountStaked \\u003e 0) {\\n            _unstakeUser(msg.sender, userData.amountStaked);\\n        }\\n        _rewardUser(msg.sender);\\n        delete stakingDataByUser[msg.sender];\\n    }\\n\\n    // PUBLIC VIEWS AND UTILITIES\\n    // ==========================\\n\\n    function availableToStakeOrReward()\\n    public\\n    view\\n    returns (uint256 stakeable)\\n    {\\n        stakeable = rewardToken.balanceOf(address(this)) - totalLockedReward();\\n        if (_stakingTokenIsRewardToken) {\\n            stakeable -= totalAmountStaked;\\n        }\\n    }\\n\\n    function totalLockedReward()\\n    public\\n    view\\n    returns (uint256 locked)\\n    {\\n        locked = totalStoredReward + totalGuaranteedReward;\\n    }\\n\\n    function rewardClaimable(\\n        address user\\n    )\\n    public\\n    view\\n    returns (uint256 reward)\\n    {\\n        UserStakingData storage userData = stakingDataByUser[user];\\n        reward = userData.storedReward;\\n        reward += _calculateStoredRewardToAdd(userData);\\n    }\\n\\n    function staked(\\n        address user\\n    )\\n    public\\n    view\\n    returns (uint256 amount)\\n    {\\n        UserStakingData storage userData = stakingDataByUser[user];\\n        return userData.amountStaked;\\n    }\\n\\n    // OWNER API\\n    // =========\\n\\n    function payRewardToUser(\\n        address user\\n    )\\n    public\\n    virtual\\n    onlyOwner\\n    nonReentrant\\n    {\\n        _rewardUser(user);\\n    }\\n\\n    function withdrawTokens(\\n        address token,\\n        uint256 amount\\n    )\\n    public\\n    virtual\\n    onlyOwner\\n    nonReentrant\\n    {\\n        if (token == address(rewardToken)) {\\n            require(amount \\u003c= availableToStakeOrReward(), \\\"Can only withdraw up to balance minus locked amount\\\");\\n        } else if (token == address(stakingToken)) {\\n            uint256 maxAmount = stakingToken.balanceOf(address(this)) - totalAmountStaked;\\n            require(amount \\u003c= maxAmount, \\\"Cannot withdraw staked tokens\\\");\\n        }\\n        IERC20(token).transfer(msg.sender, amount);\\n    }\\n\\n    function setMinStakeAmount(\\n        uint256 newMinStakeAmount\\n    )\\n    public\\n    virtual\\n    onlyOwner\\n    nonReentrant\\n    {\\n        require(newMinStakeAmount \\u003e 1, \\\"Minimum stake amount must be at least 1\\\");\\n        minStakeAmount = newMinStakeAmount;\\n    }\\n\\n    function setPaused(\\n        bool newPaused\\n    )\\n    public\\n    virtual\\n    onlyOwner\\n    nonReentrant\\n    {\\n        paused = newPaused;\\n    }\\n\\n    function initiateEmergencyWithdrawal()\\n    public\\n    virtual\\n    onlyOwner\\n    nonReentrant\\n    {\\n        require(!emergencyWithdrawalInProgress, \\\"Emergency withdrawal already in progress\\\");\\n        emergencyWithdrawalInProgress = true;\\n        emit EmergencyWithdrawalInitiated();\\n    }\\n\\n    function forceExitUser(\\n        address user\\n    )\\n    public\\n    virtual\\n    onlyOwner\\n    nonReentrant\\n    {\\n        // NOTE: this pays all of guaranteed reward to the user, even ahead of schedule with humongous APY!\\n        require(emergencyWithdrawalInProgress, \\\"Emergency withdrawal not in progress\\\");\\n        UserStakingData storage userData = stakingDataByUser[user];\\n        if (userData.amountStaked \\u003e 0) {\\n            totalAmountStaked -= userData.amountStaked;\\n            stakingToken.transfer(user, userData.amountStaked);\\n            emit Unstaked(\\n                user,\\n                userData.amountStaked\\n            );\\n            //userData.amountStaked = 0;\\n        }\\n        uint256 userReward = userData.storedReward + userData.guaranteedReward;\\n        if (userReward \\u003e 0) {\\n            rewardToken.transfer(user, userReward);\\n            totalStoredReward -= userData.storedReward;\\n            totalGuaranteedReward -= userData.guaranteedReward;\\n            emit RewardPaid(\\n                user,\\n                userReward\\n            );\\n            //userData.storedReward = 0;\\n            //userData.guaranteedReward = 0;\\n        }\\n        // delete the whole thing to set everything as 0 and to save on gas\\n        delete stakingDataByUser[user];\\n    }\\n\\n    // INTERNAL API\\n    // ============\\n\\n    function _rewardUser(\\n        address user\\n    )\\n    internal\\n    {\\n        UserStakingData storage userData = stakingDataByUser[user];\\n        _updateStoredReward(userData);\\n\\n        uint256 reward = userData.storedReward;\\n        if (reward == 0) {\\n            return;\\n        }\\n\\n        userData.storedReward = 0;\\n        totalStoredReward -= reward;\\n\\n        require(\\n            rewardToken.transfer(user, reward),\\n            \\\"Sending reward failed\\\"\\n        );\\n\\n        emit RewardPaid(\\n            user,\\n            reward\\n        );\\n    }\\n\\n    function _unstakeUser(\\n        address user,\\n        uint256 amount\\n    )\\n    private\\n    {\\n        require(amount \\u003e 0, \\\"Cannot unstake zero amount\\\");\\n\\n        UserStakingData storage userData = stakingDataByUser[user];\\n        _updateStoredReward(userData);\\n\\n        uint256 amountLeft = amount;\\n\\n        uint256 i = userData.firstActiveStakeIndex;\\n        for (; i \\u003c userData.stakes.length; i++) {\\n            if (userData.stakes[i].amount == 0) {\\n                continue;\\n            }\\n\\n            require(\\n                userData.stakes[i].timestamp \\u003c= block.timestamp - lockedPeriod,\\n                \\\"Unstaking is only allowed after the locked period has expired\\\"\\n            );\\n            if (userData.stakes[i].amount \\u003e amountLeft) {\\n                userData.stakes[i].amount -= amountLeft;\\n                amountLeft = 0;\\n                break;\\n            } else {\\n                // stake amount equal to or smaller than amountLeft\\n                amountLeft -= userData.stakes[i].amount;\\n                userData.stakes[i].amount = 0;\\n                delete userData.stakes[i];  // this should be safe and saves a little bit of gas, but also leaves a gap in the array\\n            }\\n        }\\n\\n        require(\\n            amountLeft == 0,\\n            \\\"Not enough staked balance left to unstake all of wanted amount\\\"\\n        );\\n\\n        userData.firstActiveStakeIndex = i;\\n        userData.amountStaked -= amount;\\n        totalAmountStaked -= amount;\\n\\n        // We need to make sure the user is left with no guaranteed reward if they have unstaked everything\\n        // -- in that case, just add to stored reward.\\n        if (userData.guaranteedReward \\u003e 0 \\u0026\\u0026 i == userData.stakes.length) {\\n            userData.storedReward += userData.guaranteedReward;\\n            totalStoredReward += userData.guaranteedReward;\\n\\n            totalGuaranteedReward -= userData.guaranteedReward;\\n            userData.guaranteedReward = 0;\\n\\n            userData.storedRewardUpdatedOn = block.timestamp;\\n        }\\n\\n        require(\\n            stakingToken.transfer(msg.sender, amount),\\n            \\\"Transferring staked token back to sender failed\\\"\\n        );\\n\\n        emit Unstaked(\\n            msg.sender,\\n            amount\\n        );\\n    }\\n\\n    function _updateStoredReward(\\n        UserStakingData storage userData\\n    )\\n    internal\\n    {\\n        uint256 addedStoredReward = _calculateStoredRewardToAdd(userData);\\n        if (addedStoredReward != 0) {\\n            userData.storedReward += addedStoredReward;\\n            totalStoredReward += addedStoredReward;\\n            if (addedStoredReward \\u003e userData.guaranteedReward) {\\n                totalGuaranteedReward -= userData.guaranteedReward;\\n                userData.guaranteedReward = 0;\\n            } else {\\n                userData.guaranteedReward -= addedStoredReward;\\n                totalGuaranteedReward -= addedStoredReward;\\n            }\\n            userData.storedRewardUpdatedOn = block.timestamp;\\n        }\\n    }\\n\\n    function _calculateStoredRewardToAdd(\\n        UserStakingData storage userData\\n    )\\n    internal\\n    view\\n    returns (uint256 storedRewardToAdd) {\\n        if (userData.storedRewardUpdatedOn == 0 || userData.storedRewardUpdatedOn == block.timestamp) {\\n            // safety check -- don\\u0027t want to accidentally multiply everything by the unix epoch instead of time passed\\n            return 0;\\n        }\\n        uint256 timePassedFromLastUpdate = block.timestamp - userData.storedRewardUpdatedOn;\\n        storedRewardToAdd = (userData.amountStaked * timePassedFromLastUpdate) / yieldPeriod;\\n\\n        // We can pay out more than guaranteed, but only if we have enough non-locked funds for it\\n        if (storedRewardToAdd \\u003e userData.guaranteedReward) {\\n            uint256 excess = storedRewardToAdd - userData.guaranteedReward;\\n            uint256 available = availableToStakeOrReward();\\n            if (excess \\u003e available) {\\n                storedRewardToAdd = storedRewardToAdd - excess + available;\\n            }\\n        }\\n    }\\n}\\n\"},\"ReentrancyGuard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot\\u0027s contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler\\u0027s defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction\\u0027s gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakingToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"EmergencyWithdrawalInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"availableToStakeOrReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeable\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdrawalInProgress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"forceExitUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initiateEmergencyWithdrawal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockedPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minStakeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"payRewardToUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"rewardClaimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMinStakeAmount\",\"type\":\"uint256\"}],\"name\":\"setMinStakeAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"newPaused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"staked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAmountStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalGuaranteedReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLockedReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"locked\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStoredReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yieldPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "PayRueStaking", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "0000000000000000000000009b44df3318972be845d83f961735609137c4c23c0000000000000000000000009b44df3318972be845d83f961735609137c4c23c", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://14c3a7e8ffbbb32f2d1c8d80e2dcf6466862d678846f9689006b160fd6078c1f"}