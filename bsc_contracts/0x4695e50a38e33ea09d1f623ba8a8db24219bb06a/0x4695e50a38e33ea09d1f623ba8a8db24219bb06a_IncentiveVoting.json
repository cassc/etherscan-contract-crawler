{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"IncentiveVoting.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n\\nimport \\\"Ownable.sol\\\";\\nimport \\\"IERC20.sol\\\";\\n\\n\\ninterface ITokenLocker {\\n\\n    function userWeight(address _user) external view returns (uint256);\\n    function weeklyTotalWeight(uint256 _week) external view returns (uint256);\\n    function weeklyWeightOf(address _user, uint256 _week)\\n        external\\n        view\\n        returns (uint256);\\n    function startTime() external view returns (uint256);\\n}\\n\\ninterface ILpStaking {\\n    function poolInfo(address _pool) external view returns (uint256, uint256, uint256, uint256);\\n    function addPool(address _token) external returns (bool);\\n}\\n\\ninterface IStableSwap {\\n    function withdraw_admin_fees() external;\\n}\\n\\ninterface IERC20Mintable {\\n    function minter() external view returns (address);\\n}\\n\\n\\ncontract IncentiveVoting is Ownable {\\n\\n    struct TokenApprovalVote {\\n        address token;\\n        uint40 startTime;\\n        uint16 week;\\n        uint256 requiredVotes;\\n        uint256 givenVotes;\\n    }\\n    struct Vote {\\n        address token;\\n        uint256 votes;\\n    }\\n\\n    // token -> week -> votes received\\n    mapping(address => uint256[65535]) public tokenVotes;\\n\\n    // user -> week -> votes used\\n    mapping(address => uint256[65535]) public userVotes;\\n\\n    // user -> token -> week -> votes for pool\\n    mapping(address => mapping(address => uint256[65535])) public userTokenVotes;\\n\\n    // week -> total votes used\\n    uint256[65535] public totalVotes;\\n\\n    // data about token approval votes\\n    TokenApprovalVote[] public tokenApprovalVotes;\\n\\n    // voteId -> user -> supporting votes for token approval\\n    mapping(uint256 => mapping(address => uint256)) public userTokenApprovalVotes;\\n\\n    // minimum support required in an approval vote, as a % out of 100\\n    uint256 public tokenApprovalQuorumPct;\\n    uint256 public pendingTokenApprovalQuorumPct;\\n    uint256 public pendingTokenApprovalQuorumTime;\\n\\n    // user -> timestamp of last created token approval vote\\n    mapping(address => uint256) public lastVote;\\n\\n    uint256 constant WEEK = 86400 * 7;\\n    uint256 public startTime;\\n\\n    ITokenLocker public tokenLocker;\\n    ILpStaking public lpStaking;\\n\\n    mapping(address => bool) public isApproved;\\n    address[] public approvedTokens;\\n\\n    // The amount of EPX tokens minted each second in a given period.\\n    // Each item represents a 4 week epoch. New values are pushed onto\\n    // the array over time as users call `vote`.\\n    uint256[] public rewardsPerSecond;\\n\\n    // Minimum weight to create a new token approval vote\\n    uint256 public immutable NEW_TOKEN_APPROVAL_VOTE_MIN_WEIGHT;\\n\\n    event TokenApprovalVoteCreated(\\n        address indexed creator,\\n        address indexed token,\\n        uint256 startTime,\\n        uint256 week,\\n        uint256 requiredVotes,\\n        uint256 voteIndex\\n    );\\n\\n    event VotedForTokenApproval(\\n        address indexed voter,\\n        uint256 indexed voteIndex,\\n        uint256 newVotes,\\n        uint256 totalVotes,\\n        uint256 requiredVotes,\\n        bool isApproved\\n    );\\n\\n    event VotedForIncentives(\\n        address indexed voter,\\n        address[] tokens,\\n        uint256[] votes,\\n        uint256 userVotesUsed,\\n        uint256 totalUserVotes\\n    );\\n\\n    event PendingApprovalQuorumSet(\\n        address caller,\\n        uint256 quorumPct,\\n        uint256 pendingQuorumPct\\n    );\\n\\n    event ApprovalQuorumSet(\\n        address caller,\\n        uint256 previousQuorumPct,\\n        uint256 quorumPct\\n    );\\n\\n    constructor(\\n        ITokenLocker _tokenLocker,\\n        uint256 _initialRewardsPerSecond,\\n        uint256 _quorumPct,\\n        uint256 _tokenApprovalMinWeight\\n    ) {\\n        require(_tokenApprovalMinWeight > 1e18, \\\"Incorrect precision!\\\");\\n\\n        tokenApprovalQuorumPct = _quorumPct;\\n        NEW_TOKEN_APPROVAL_VOTE_MIN_WEIGHT = _tokenApprovalMinWeight;\\n        tokenLocker = _tokenLocker;\\n        startTime = _tokenLocker.startTime();\\n\\n        rewardsPerSecond.push(_initialRewardsPerSecond);\\n    }\\n\\n    function setLpStaking(ILpStaking _lpStaking, address[] memory _initialApprovedTokens) external {\\n        require(address(lpStaking) == address(0));\\n        lpStaking = _lpStaking;\\n        for (uint i = 0; i < _initialApprovedTokens.length; i++) {\\n            address token = _initialApprovedTokens[i];\\n            isApproved[token] = true;\\n            approvedTokens.push(token);\\n            _lpStaking.addPool(token);\\n        }\\n    }\\n\\n    function tokenApprovalVotesLength() external view returns (uint256) {\\n        return tokenApprovalVotes.length;\\n    }\\n\\n    function approvedTokensLength() external view returns (uint256) {\\n        return approvedTokens.length;\\n    }\\n\\n    function getWeek() public view returns (uint256) {\\n        if (startTime >= block.timestamp) return 0;\\n        return (block.timestamp - startTime) / 604800;\\n    }\\n\\n    /**\\n        @notice Get data on the current votes made in the active week\\n        @return _totalVotes Total number of votes this week for all pools\\n        @return _voteData Dynamic array of (token address, votes for token)\\n     */\\n    function getVotes(uint256 _week) external view returns (uint256 _totalVotes, Vote[] memory _voteData) {\\n        _voteData = new Vote[](approvedTokens.length);\\n        for (uint i = 0; i < _voteData.length; i++) {\\n            address token = approvedTokens[i];\\n            _voteData[i] = Vote({token: token, votes: tokenVotes[token][_week]});\\n        }\\n        return (totalVotes[_week], _voteData);\\n    }\\n\\n\\n    /**\\n        @notice Get data on current votes `_user` has made in the active week\\n        @return _totalVotes Total number of votes from `_user` this week for all pools\\n        @return _voteData Dynamic array of (token address, votes for token)\\n     */\\n    function getUserVotes(address _user, uint256 _week)\\n        external\\n        view\\n        returns (uint256 _totalVotes, Vote[] memory _voteData)\\n    {\\n        _voteData = new Vote[](approvedTokens.length);\\n        for (uint i = 0; i < _voteData.length; i++) {\\n            address token = approvedTokens[i];\\n            _voteData[i] = Vote({token: token, votes: userTokenVotes[_user][token][_week]});\\n        }\\n        return (userVotes[_user][_week], _voteData);\\n    }\\n\\n    /**\\n        @notice Get the amount of unused votes for for the current week being voted on\\n        @param _user Address to query\\n        @return uint Amount of unused votes\\n     */\\n    function availableVotes(address _user) external view returns (uint256) {\\n        uint256 week = getWeek();\\n        uint256 usedVotes = userVotes[_user][week];\\n        uint256 totalVotes = tokenLocker.userWeight(_user) / 1e18;\\n        return totalVotes - usedVotes;\\n    }\\n\\n    /**\\n        @notice Allocate votes toward LP tokens to receive emissions in the following week\\n        @dev A user may vote as many times as they like within a week, so long as their total\\n             available votes are not exceeded. If they receive additional votes by locking more\\n             tokens within `tokenLocker`, they can vote immediately.\\n\\n             Votes can only be added - not modified or removed. Votes only apply to the\\n             following week - they do not carry over. A user must resubmit their vote each\\n             week.\\n        @param _tokens List of addresses of LP tokens to vote for\\n        @param _votes Votes to allocate to `_tokens`. Values are additive, they do\\n                        not include previous votes. For example, if you have already\\n                        allocated 100 votes and wish to allocate a total of 300,\\n                        the vote amount should be given as 200.\\n     */\\n    function vote(address[] calldata _tokens, uint256[] calldata _votes) external {\\n        require(_tokens.length == _votes.length, \\\"Input length mismatch\\\");\\n\\n        // update rewards per second, if required\\n        uint256 week = getWeek();\\n        uint256 length = rewardsPerSecond.length;\\n        if (length <= week / 4) {\\n            uint256 perSecond = rewardsPerSecond[length-1];\\n            while (length <= week / 4) {\\n                perSecond = perSecond * 99 / 100;\\n                length += 1;\\n                rewardsPerSecond.push(perSecond);\\n            }\\n        }\\n\\n        // update accounting for this week's votes\\n        uint256 usedVotes = userVotes[msg.sender][week];\\n        for (uint i = 0; i < _tokens.length; i++) {\\n            address token = _tokens[i];\\n            uint256 amount = _votes[i];\\n            require(isApproved[token], \\\"Not approved for incentives\\\");\\n            tokenVotes[token][week] += amount;\\n            totalVotes[week] += amount;\\n            userTokenVotes[msg.sender][token][week] += amount;\\n            usedVotes += amount;\\n        }\\n\\n        // make sure user has not exceeded available votes\\n        uint256 totalVotes = tokenLocker.userWeight(msg.sender) / 1e18;\\n        require(usedVotes <= totalVotes, \\\"Available votes exceeded\\\");\\n        userVotes[msg.sender][week] = usedVotes;\\n\\n        emit VotedForIncentives(\\n            msg.sender,\\n            _tokens,\\n            _votes,\\n            usedVotes,\\n            totalVotes\\n        );\\n    }\\n\\n    /**\\n        @notice Create a new vote to enable protocol emissions on a given token\\n        @dev Emissions are only available to approved LP tokens. This prevents\\n             incentives being given to pools with malicious assets. We trust\\n             lockers to vote in the best longterm interests of the protocol :)\\n        @param _token Token address to create a vote for\\n        @return _voteIndex uint Index value used to reference the vote\\n     */\\n    function createTokenApprovalVote(address _token)\\n        external\\n        returns (uint256 _voteIndex)\\n    {\\n        require(!isApproved[_token], \\\"Already approved\\\");\\n        // wait 2 weeks to allow approval votes, to ensure sufficient locked balances\\n        uint256 week = getWeek();\\n        require(week > 1, \\\"Cannot make vote in first two weeks\\\");\\n\\n        // verify that claiming admin fees works for the pool associated with\\n        // this LP token. we verify this behaviour now to avoid later isssues\\n        // in `EllipsisLpStaking.claim` if the token does not belong to a pool\\n        // or contains an incompatible asset.\\n        address pool = IERC20Mintable(_token).minter();\\n        IStableSwap(pool).withdraw_admin_fees();\\n\\n        week -= 1;\\n        uint256 weight = tokenLocker.weeklyWeightOf(msg.sender, week);\\n        // minimum weight and max one vote per week to prevent spamming votes\\n        require(weight >= NEW_TOKEN_APPROVAL_VOTE_MIN_WEIGHT, \\\"Not enough weight\\\");\\n        require(lastVote[msg.sender] + WEEK <= block.timestamp, \\\"One new vote per week\\\");\\n        lastVote[msg.sender] = block.timestamp;\\n\\n        uint256 required = tokenLocker.weeklyTotalWeight(week) * tokenApprovalQuorumPct / 100 / 1e18;\\n        tokenApprovalVotes.push(\\n            TokenApprovalVote({\\n                token: _token,\\n                startTime: uint40(block.timestamp),\\n                week: uint16(week),\\n                requiredVotes: required,\\n                givenVotes: 0\\n            })\\n        );\\n\\n        uint256 voteIdx = tokenApprovalVotes.length - 1;\\n        emit TokenApprovalVoteCreated(\\n            msg.sender,\\n            _token,\\n            block.timestamp,\\n            week,\\n            required,\\n            voteIdx\\n        );\\n        return voteIdx;\\n    }\\n\\n    function availableTokenApprovalVotes(address _user, uint256 _voteIndex)\\n        external\\n        view\\n        returns (uint256 _remainingVotes)\\n    {\\n        TokenApprovalVote storage vote = tokenApprovalVotes[_voteIndex];\\n        if (vote.startTime <= block.timestamp - WEEK) return 0;\\n        uint256 totalVotes = tokenLocker.weeklyWeightOf(_user, vote.week) / 1e18;\\n        return totalVotes - userTokenApprovalVotes[_voteIndex][_user];\\n    }\\n\\n    /**\\n        @notice Vote in favor of approving a new token for protocol emissions\\n        @dev Votes last for one week. Weight for voting is based on the last\\n             completed week at the time the vote was created. A vote passes\\n             once the percent of weight given exceeds `tokenApprovalQuorumPct`.\\n             It is not possible to vote against a proposed token, users who\\n             wish to do so should instead abstain from voting.\\n        @param _voteIndex Array index referencing the vote\\n        @param _yesVotes Number of votes to cast in favor. End users can set as\\n                         2**256-1 to vote with all available weight. Integragors\\n                         may wish to vote with only a portion of their available\\n                         weight, in order to more accurately reflect a sub-vote\\n                         within their userbase.\\n     */\\n    function voteForTokenApproval(uint256 _voteIndex, uint256 _yesVotes) external {\\n        TokenApprovalVote storage vote = tokenApprovalVotes[_voteIndex];\\n        require(vote.startTime > block.timestamp - WEEK, \\\"Vote has ended\\\");\\n        require(!isApproved[vote.token], \\\"Already approved\\\");\\n\\n        uint256 totalVotes = tokenLocker.weeklyWeightOf(msg.sender, vote.week) / 1e18;\\n        uint256 usedVotes = userTokenApprovalVotes[_voteIndex][msg.sender];\\n        if (_yesVotes == type(uint256).max) {\\n            _yesVotes = totalVotes - usedVotes;\\n        }\\n        usedVotes += _yesVotes;\\n        require(usedVotes <= totalVotes, \\\"Exceeds available votes\\\");\\n\\n        userTokenApprovalVotes[_voteIndex][msg.sender] = usedVotes;\\n        vote.givenVotes += _yesVotes;\\n\\n        if (vote.givenVotes >= vote.requiredVotes) {\\n            isApproved[vote.token] = true;\\n            approvedTokens.push(vote.token);\\n            lpStaking.addPool(vote.token);\\n        }\\n\\n        emit VotedForTokenApproval(\\n            msg.sender,\\n            _voteIndex,\\n            _yesVotes,\\n            vote.givenVotes,\\n            vote.requiredVotes,\\n            isApproved[vote.token]\\n        );\\n    }\\n\\n    /**\\n        @dev Calculate and return the rewards per second for a given LP token.\\n             Called by `EllipsisLpStaker` when determining the emissions that each\\n             pool is entitled to.\\n     */\\n    function getRewardsPerSecond(address _token, uint256 _week) external view returns (uint256) {\\n        if (_week == 0) return 0;\\n        // weekly rewards are calculated based on the previous week's votes\\n        _week -= 1;\\n\\n        uint256 votes = tokenVotes[_token][_week];\\n        if (votes == 0) return 0;\\n\\n        return rewardsPerSecond[_week / 4] * votes / totalVotes[_week];\\n    }\\n\\n    /**\\n        @notice Commit a change to the required quorum for token approval votes.\\n        @dev Quorum can only be modified within a defined range of 10-50%. A three day\\n             delay is required between commiting and applying the change, in order to\\n             discourge malicious actions from the contract owner.\\n     */\\n    function commitTokenApprovalQuorum(uint256 _quorumPct) external onlyOwner {\\n        require(_quorumPct >= 10 && _quorumPct <= 50, \\\"Invalid parameter\\\");\\n        pendingTokenApprovalQuorumPct = _quorumPct;\\n        pendingTokenApprovalQuorumTime = block.timestamp + 86400 * 3;\\n        emit PendingApprovalQuorumSet(msg.sender, tokenApprovalQuorumPct, _quorumPct);\\n    }\\n\\n    /**\\n        @notice Apply a change to the required quorum for token approval votes\\n     */\\n    function applyTokenApprovalQuorum() external {\\n        uint256 quorum = pendingTokenApprovalQuorumPct;\\n        require(quorum > 0, \\\"No pending value set\\\");\\n        require(pendingTokenApprovalQuorumTime < block.timestamp, \\\"Delay has not passed\\\");\\n        pendingTokenApprovalQuorumPct = 0;\\n        pendingTokenApprovalQuorumTime = 0;\\n\\n        emit ApprovalQuorumSet(msg.sender, tokenApprovalQuorumPct, quorum);\\n        tokenApprovalQuorumPct = quorum;\\n    }\\n\\n    /**\\n        @notice Modify the approval for a token to receive incentives.\\n        @dev This can only be called on tokens that were already voted in, it cannot\\n        be used to bypass the voting process. It is intended to block emissions in\\n        case of an exploit or act of maliciousness from a token within an approved pool.\\n     */\\n    function setTokenApproval(address _token, bool _isApproved) external onlyOwner {\\n        if (!isApproved[_token]) {\\n            (,,uint256 lastRewardTime,) = lpStaking.poolInfo(_token);\\n            require(lastRewardTime != 0, \\\"Token must be voted in\\\");\\n        }\\n        isApproved[_token] = _isApproved;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {\r\n      \"IncentiveVoting.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract ITokenLocker\",\"name\":\"_tokenLocker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_initialRewardsPerSecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_quorumPct\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenApprovalMinWeight\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousQuorumPct\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quorumPct\",\"type\":\"uint256\"}],\"name\":\"ApprovalQuorumSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quorumPct\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pendingQuorumPct\",\"type\":\"uint256\"}],\"name\":\"PendingApprovalQuorumSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"week\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requiredVotes\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"voteIndex\",\"type\":\"uint256\"}],\"name\":\"TokenApprovalVoteCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"votes\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userVotesUsed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalUserVotes\",\"type\":\"uint256\"}],\"name\":\"VotedForIncentives\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"voteIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newVotes\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalVotes\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requiredVotes\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isApproved\",\"type\":\"bool\"}],\"name\":\"VotedForTokenApproval\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"NEW_TOKEN_APPROVAL_VOTE_MIN_WEIGHT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"applyTokenApprovalQuorum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"approvedTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"approvedTokensLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_voteIndex\",\"type\":\"uint256\"}],\"name\":\"availableTokenApprovalVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_remainingVotes\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"availableVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_quorumPct\",\"type\":\"uint256\"}],\"name\":\"commitTokenApprovalQuorum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"createTokenApprovalVote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_voteIndex\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_week\",\"type\":\"uint256\"}],\"name\":\"getRewardsPerSecond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_week\",\"type\":\"uint256\"}],\"name\":\"getUserVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalVotes\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"votes\",\"type\":\"uint256\"}],\"internalType\":\"struct IncentiveVoting.Vote[]\",\"name\":\"_voteData\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_week\",\"type\":\"uint256\"}],\"name\":\"getVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalVotes\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"votes\",\"type\":\"uint256\"}],\"internalType\":\"struct IncentiveVoting.Vote[]\",\"name\":\"_voteData\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWeek\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApproved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastVote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpStaking\",\"outputs\":[{\"internalType\":\"contract ILpStaking\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingTokenApprovalQuorumPct\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingTokenApprovalQuorumTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardsPerSecond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ILpStaking\",\"name\":\"_lpStaking\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_initialApprovedTokens\",\"type\":\"address[]\"}],\"name\":\"setLpStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isApproved\",\"type\":\"bool\"}],\"name\":\"setTokenApproval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenApprovalQuorumPct\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenApprovalVotes\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint40\",\"name\":\"startTime\",\"type\":\"uint40\"},{\"internalType\":\"uint16\",\"name\":\"week\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"requiredVotes\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"givenVotes\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenApprovalVotesLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenLocker\",\"outputs\":[{\"internalType\":\"contract ITokenLocker\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userTokenApprovalVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userTokenVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_votes\",\"type\":\"uint256[]\"}],\"name\":\"vote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_voteIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_yesVotes\",\"type\":\"uint256\"}],\"name\":\"voteForTokenApproval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "IncentiveVoting", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000022a93f53a0a3e6847d05dd504283e8e296a49aae00000000000000000000000000000000000000000000000dcdb22b10035a8490000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000cecb8f27f4200f3a000000", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}