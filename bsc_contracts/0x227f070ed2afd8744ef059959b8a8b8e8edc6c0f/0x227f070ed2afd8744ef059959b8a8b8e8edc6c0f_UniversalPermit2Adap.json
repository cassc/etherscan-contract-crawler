{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/UniversalPermit2Adapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\n\\nimport { SimulationAdapter } from \\\"@call-simulation/SimulationAdapter.sol\\\";\\n// solhint-disable no-unused-import\\nimport { BasePermit2Adapter, IPermit2, Token } from \\\"./base/BasePermit2Adapter.sol\\\";\\nimport {\\n  IArbitraryExecutionPermit2Adapter,\\n  ArbitraryExecutionPermit2Adapter\\n} from \\\"./base/ArbitraryExecutionPermit2Adapter.sol\\\";\\nimport { ISwapPermit2Adapter, SwapPermit2Adapter } from \\\"./base/SwapPermit2Adapter.sol\\\";\\n// solhint-enable no-unused-import\\n\\n/**\\n * @title Universal Permit2 Adapter\\n * @author Sam Bugs\\n * @notice This contracts adds Permit2 capabilities to existing contracts by acting as a proxy\\n * @dev It's important to note that this contract should never hold any funds outside of the scope of a transaction,\\n *      nor should it be granted \\\"regular\\\" ERC20 token approvals. This contract is meant to be used as a proxy, so\\n *      the only tokens approved/transferred through Permit2 should be entirely spent in the same transaction.\\n *      Any unspent allowance or remaining tokens on the contract can be transferred by anyone, so please be careful!\\n */\\ncontract UniversalPermit2Adapter is SimulationAdapter, SwapPermit2Adapter, ArbitraryExecutionPermit2Adapter {\\n  constructor(IPermit2 _permit2) BasePermit2Adapter(_permit2) { }\\n}\\n\"\r\n    },\r\n    \"lib/call-simulation/src/SimulationAdapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\n\\nimport { IERC165 } from \\\"./interfaces/external/IERC165.sol\\\";\\nimport { ISimulationAdapter } from \\\"./interfaces/ISimulationAdapter.sol\\\";\\n\\n/**\\n * @title Simulation Adapter\\n * @author Sam Bugs\\n * @notice This contracts adds off-chain simulation capabilities to existing contracts. It works similarly to a\\n *         multicall, but the state is not modified in each subcall.\\n */\\nabstract contract SimulationAdapter is IERC165, ISimulationAdapter {\\n  /// @notice An error that contains a simulation's result\\n  error SimulatedCall(SimulationResult result);\\n\\n  /// @inheritdoc IERC165\\n  function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {\\n    return _interfaceId == type(ISimulationAdapter).interfaceId || _interfaceId == type(IERC165).interfaceId;\\n  }\\n\\n  /// @inheritdoc ISimulationAdapter\\n  function simulate(bytes[] calldata _calls) external payable returns (SimulationResult[] memory _results) {\\n    _results = new SimulationResult[](_calls.length);\\n    for (uint256 i = 0; i < _calls.length; i++) {\\n      _results[i] = _simulate(_calls[i]);\\n    }\\n    return _results;\\n  }\\n\\n  /**\\n   * @notice Executes a simulation and returns the result\\n   * @param _call The call to simulate\\n   * @return _simulationResult The simulation's result\\n   */\\n  function _simulate(bytes calldata _call) internal returns (SimulationResult memory _simulationResult) {\\n    (bool _success, bytes memory _result) =\\n    // solhint-disable-next-line avoid-low-level-calls\\n     address(this).delegatecall(abi.encodeWithSelector(this.simulateAndRevert.selector, _call));\\n    require(!_success, \\\"WTF? Should have failed!\\\");\\n    // Move pointer to ignore selector\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      _result := add(_result, 0x04)\\n    }\\n    (_simulationResult) = abi.decode(_result, (SimulationResult));\\n  }\\n\\n  /**\\n   * @notice Executes a call agains this contract and reverts with the result\\n   * @dev This is meant to be used internally, do not call!\\n   * @param _call The call to simulate\\n   */\\n  function simulateAndRevert(bytes calldata _call) external payable {\\n    uint256 _gasAtStart = gasleft();\\n    // solhint-disable-next-line avoid-low-level-calls\\n    (bool _success, bytes memory _result) = address(this).delegatecall(_call);\\n    uint256 _gasSpent = _gasAtStart - gasleft();\\n    revert SimulatedCall(SimulationResult({ success: _success, result: _result, gasSpent: _gasSpent }));\\n  }\\n}\\n\"\r\n    },\r\n    \"src/base/BasePermit2Adapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\n\\nimport { IBasePermit2Adapter, IPermit2 } from \\\"../interfaces/IBasePermit2Adapter.sol\\\";\\nimport { Token } from \\\"../libraries/Token.sol\\\";\\n\\n/**\\n * @title Base Permit2 Adapter\\n * @author Sam Bugs\\n * @notice The base contract for Permit2 adapters\\n */\\nabstract contract BasePermit2Adapter is IBasePermit2Adapter {\\n  /// @inheritdoc IBasePermit2Adapter\\n  address public constant NATIVE_TOKEN = Token.NATIVE_TOKEN;\\n  /// @inheritdoc IBasePermit2Adapter\\n  // solhint-disable-next-line var-name-mixedcase\\n  IPermit2 public immutable PERMIT2;\\n\\n  constructor(IPermit2 _permit2) {\\n    PERMIT2 = _permit2;\\n  }\\n\\n  // solhint-disable-next-line no-empty-blocks\\n  receive() external payable { }\\n\\n  modifier checkDeadline(uint256 _deadline) {\\n    if (block.timestamp > _deadline) revert TransactionDeadlinePassed(block.timestamp, _deadline);\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/base/ArbitraryExecutionPermit2Adapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\n\\nimport { Address } from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n// solhint-disable-next-line no-unused-import\\nimport { Permit2Transfers, IPermit2 } from \\\"../libraries/Permit2Transfers.sol\\\";\\nimport { Token, IERC20 } from \\\"../libraries/Token.sol\\\";\\nimport { IArbitraryExecutionPermit2Adapter } from \\\"../interfaces/IArbitraryExecutionPermit2Adapter.sol\\\";\\nimport { BasePermit2Adapter } from \\\"./BasePermit2Adapter.sol\\\";\\n\\n/**\\n * @title Arbitrary Execution Permit2 Adapter\\n * @author Sam Bugs\\n * @notice This contracts adds Permit2 capabilities to existing contracts by acting as a proxy\\n * @dev It's important to note that this contract should never hold any funds outside of the scope of a transaction,\\n *      nor should it be granted \\\"regular\\\" ERC20 token approvals. This contract is meant to be used as a proxy, so\\n *      the only tokens approved/transferred through Permit2 should be entirely spent in the same transaction.\\n *      Any unspent allowance or remaining tokens on the contract can be transferred by anyone, so please be careful!\\n */\\nabstract contract ArbitraryExecutionPermit2Adapter is BasePermit2Adapter, IArbitraryExecutionPermit2Adapter {\\n  using Permit2Transfers for IPermit2;\\n  using Token for address;\\n  using Token for IERC20;\\n  using Address for address;\\n\\n  /// @inheritdoc IArbitraryExecutionPermit2Adapter\\n  function executeWithPermit(\\n    SinglePermit calldata _permit,\\n    AllowanceTarget[] calldata _allowanceTargets,\\n    ContractCall[] calldata _contractCalls,\\n    TransferOut[] calldata _transferOut,\\n    uint256 _deadline\\n  )\\n    external\\n    payable\\n    checkDeadline(_deadline)\\n    returns (bytes[] memory _executionResults, uint256[] memory _tokenBalances)\\n  {\\n    PERMIT2.takeFromCaller(_permit.token, _permit.amount, _permit.nonce, _deadline, _permit.signature);\\n    return _approveExecuteAndTransfer(_allowanceTargets, _contractCalls, _transferOut);\\n  }\\n\\n  /// @inheritdoc IArbitraryExecutionPermit2Adapter\\n  function executeWithBatchPermit(\\n    BatchPermit calldata _batchPermit,\\n    AllowanceTarget[] calldata _allowanceTargets,\\n    ContractCall[] calldata _contractCalls,\\n    TransferOut[] calldata _transferOut,\\n    uint256 _deadline\\n  )\\n    external\\n    payable\\n    checkDeadline(_deadline)\\n    returns (bytes[] memory _executionResults, uint256[] memory _tokenBalances)\\n  {\\n    PERMIT2.batchTakeFromCaller(_batchPermit.tokens, _batchPermit.nonce, _deadline, _batchPermit.signature);\\n    return _approveExecuteAndTransfer(_allowanceTargets, _contractCalls, _transferOut);\\n  }\\n\\n  function _approveExecuteAndTransfer(\\n    AllowanceTarget[] calldata _allowanceTargets,\\n    ContractCall[] calldata _contractCalls,\\n    TransferOut[] calldata _transferOut\\n  )\\n    internal\\n    returns (bytes[] memory _executionResults, uint256[] memory _tokenBalances)\\n  {\\n    // Approve targets\\n    for (uint256 i; i < _allowanceTargets.length;) {\\n      IERC20(_allowanceTargets[i].token).maxApprove(_allowanceTargets[i].allowanceTarget);\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n\\n    // Call contracts\\n    _executionResults = new bytes[](_contractCalls.length);\\n    for (uint256 i; i < _contractCalls.length;) {\\n      _executionResults[i] =\\n        _contractCalls[i].target.functionCallWithValue(_contractCalls[i].data, _contractCalls[i].value);\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n\\n    // Reset allowance to prevent attacks. Also, we are setting it to 1 instead of 0 for gas optimization\\n    for (uint256 i; i < _allowanceTargets.length;) {\\n      IERC20(_allowanceTargets[i].token).setAllowance(_allowanceTargets[i].allowanceTarget, 1);\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n\\n    // Distribute tokens\\n    _tokenBalances = new uint256[](_transferOut.length);\\n    for (uint256 i; i < _transferOut.length;) {\\n      _tokenBalances[i] = _transferOut[i].token.distributeTo(_transferOut[i].distribution);\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"src/base/SwapPermit2Adapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\n\\nimport { Address } from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n// solhint-disable-next-line no-unused-import\\nimport { Permit2Transfers, IPermit2 } from \\\"../libraries/Permit2Transfers.sol\\\";\\nimport { Token } from \\\"../libraries/Token.sol\\\";\\nimport { ISwapPermit2Adapter } from \\\"../interfaces/ISwapPermit2Adapter.sol\\\";\\nimport { BasePermit2Adapter } from \\\"./BasePermit2Adapter.sol\\\";\\n\\n/**\\n * @title Swap Permit2 Adapter\\n * @author Sam Bugs\\n * @notice This contracts adds Permit2 capabilities to existing token swap contracts by acting as a proxy. It performs\\n *         some extra checks to guarantee that the minimum amounts are respected\\n * @dev It's important to note that this contract should never hold any funds outside of the scope of a transaction,\\n *      nor should it be granted \\\"regular\\\" ERC20 token approvals. This contract is meant to be used as a proxy, so\\n *      the only tokens approved/transferred through Permit2 should be entirely spent in the same transaction.\\n *      Any unspent allowance or remaining tokens on the contract can be transferred by anyone, so please be careful!\\n */\\nabstract contract SwapPermit2Adapter is BasePermit2Adapter, ISwapPermit2Adapter {\\n  using Permit2Transfers for IPermit2;\\n  using Token for address;\\n  using Address for address;\\n\\n  /// @inheritdoc ISwapPermit2Adapter\\n  function sellOrderSwap(SellOrderSwapParams calldata _params)\\n    public\\n    payable\\n    checkDeadline(_params.deadline)\\n    returns (uint256 _amountIn, uint256 _amountOut)\\n  {\\n    // Take from caller\\n    PERMIT2.takeFromCaller(_params.tokenIn, _params.amountIn, _params.nonce, _params.deadline, _params.signature);\\n\\n    // Max approve token in\\n    _params.tokenIn.maxApproveIfNecessary(_params.allowanceTarget);\\n\\n    // Execute swap\\n    uint256 _value = _params.tokenIn == Token.NATIVE_TOKEN ? _params.amountIn : 0;\\n    _params.swapper.functionCallWithValue(_params.swapData, _value);\\n\\n    // Distribute token out\\n    _amountOut = _params.tokenOut.distributeTo(_params.transferOut);\\n\\n    // Check min amount\\n    if (_amountOut < _params.minAmountOut) revert ReceivedTooLittleTokenOut(_amountOut, _params.minAmountOut);\\n\\n    // Reset allowance\\n    _params.tokenIn.setAllowanceIfNecessary(_params.allowanceTarget, 1);\\n\\n    // Set amount in\\n    _amountIn = _params.amountIn;\\n  }\\n\\n  /// @inheritdoc ISwapPermit2Adapter\\n  function buyOrderSwap(BuyOrderSwapParams calldata _params)\\n    public\\n    payable\\n    checkDeadline(_params.deadline)\\n    returns (uint256 _amountIn, uint256 _amountOut)\\n  {\\n    // Take from caller\\n    PERMIT2.takeFromCaller(_params.tokenIn, _params.maxAmountIn, _params.nonce, _params.deadline, _params.signature);\\n\\n    // Max approve token in\\n    _params.tokenIn.maxApproveIfNecessary(_params.allowanceTarget);\\n\\n    // Execute swap\\n    uint256 _value = _params.tokenIn == Token.NATIVE_TOKEN ? _params.maxAmountIn : 0;\\n    _params.swapper.functionCallWithValue(_params.swapData, _value);\\n\\n    // Check balance for unspent tokens\\n    uint256 _unspentTokenIn = _params.tokenIn.balanceOnContract();\\n\\n    // Distribute token out\\n    _amountOut = _params.tokenOut.distributeTo(_params.transferOut);\\n\\n    // Check min amount\\n    if (_amountOut < _params.amountOut) revert ReceivedTooLittleTokenOut(_amountOut, _params.amountOut);\\n\\n    // Send unspent to the set recipient\\n    _params.tokenIn.sendAmountTo(_unspentTokenIn, _params.unspentTokenInRecipient);\\n\\n    // Reset allowance\\n    _params.tokenIn.setAllowanceIfNecessary(_params.allowanceTarget, 1);\\n\\n    // Set amount in\\n    _amountIn = _params.maxAmountIn - _unspentTokenIn;\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/call-simulation/src/interfaces/external/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\n\\ninterface IERC165 {\\n  /**\\n   * @dev Returns true if this contract implements the interface defined by\\n   * `interfaceId`. See the corresponding\\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n   * to learn more about how these ids are created.\\n   *\\n   * This function call must use less than 30 000 gas.\\n   */\\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/call-simulation/src/interfaces/ISimulationAdapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\n\\ninterface ISimulationAdapter {\\n  /// @notice A simulation's result\\n  struct SimulationResult {\\n    bool success;\\n    bytes result;\\n    uint256 gasSpent;\\n  }\\n\\n  /**\\n   * @notice Executes individual simulations against this contract but doesn't modify the state when doing so\\n   * @dev This function is meant to be used for off-chain simulation and should not be called on-chain\\n   * @param calls The calls to simulate\\n   * @return results Each simulation result\\n   */\\n  function simulate(bytes[] calldata calls) external payable returns (SimulationResult[] memory results);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IBasePermit2Adapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\n\\nimport { IPermit2 } from \\\"./external/IPermit2.sol\\\";\\n\\n/// @notice The interface all Permit2 adapters should implement\\ninterface IBasePermit2Adapter {\\n  /**\\n   * @notice Thrown when a transaction deadline has passed\\n   * @param current The current time\\n   * @param deadline The set deadline\\n   */\\n  error TransactionDeadlinePassed(uint256 current, uint256 deadline);\\n\\n  /**\\n   * @notice Returns the address that represents the native token\\n   * @dev This value is constant and cannot change\\n   * @return The address that represents the native token\\n   */\\n  function NATIVE_TOKEN() external view returns (address);\\n\\n  /**\\n   * @notice Returns the address of the Permit2 contract\\n   * @dev This value is constant and cannot change\\n   * @return The address of the Permit2 contract\\n   */\\n  function PERMIT2() external view returns (IPermit2);\\n}\\n\"\r\n    },\r\n    \"src/libraries/Token.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\n\\nimport { SafeERC20, IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport { Address } from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\n/**\\n * @title Token Library\\n * @author Sam Bugs\\n * @notice A small library that contains helpers for tokens (both ERC20 and native)\\n */\\nlibrary Token {\\n  using SafeERC20 for IERC20;\\n  using Address for address payable;\\n  using Address for address;\\n\\n  /// @notice A specific target to distribute tokens to\\n  struct DistributionTarget {\\n    address recipient;\\n    uint256 shareBps;\\n  }\\n\\n  address public constant NATIVE_TOKEN = address(0);\\n\\n  /**\\n   * @notice Calculates the amount of token balance held by the contract\\n   * @param _token The token to check\\n   * @return _balance The current balance held by the contract\\n   */\\n  function balanceOnContract(address _token) internal view returns (uint256 _balance) {\\n    return _token == NATIVE_TOKEN ? address(this).balance : IERC20(_token).balanceOf(address(this));\\n  }\\n\\n  /**\\n   * @notice Performs a max approval to the allowance target, for the given token\\n   * @param _token The token to approve\\n   * @param _allowanceTarget The spender that will be approved\\n   */\\n  function maxApprove(IERC20 _token, address _allowanceTarget) internal {\\n    setAllowance(_token, _allowanceTarget, type(uint256).max);\\n  }\\n\\n  /**\\n   * @notice Performs an approval to the allowance target, for the given token and amount\\n   * @param _token The token to approve\\n   * @param _allowanceTarget The spender that will be approved\\n   * @param _amount The allowance to set\\n   */\\n  function setAllowance(IERC20 _token, address _allowanceTarget, uint256 _amount) internal {\\n    // This helper should handle cases like USDT. Thanks OZ!\\n    _token.forceApprove(_allowanceTarget, _amount);\\n  }\\n\\n  /**\\n   * @notice Performs a max approval to the allowance target for the given token, as long as the token is not\\n   *         the native token, and the allowance target is not the zero address\\n   * @param _token The token to approve\\n   * @param _allowanceTarget The spender that will be approved\\n   */\\n  function maxApproveIfNecessary(address _token, address _allowanceTarget) internal {\\n    setAllowanceIfNecessary(_token, _allowanceTarget, type(uint256).max);\\n  }\\n\\n  /**\\n   * @notice Performs an approval to the allowance target for the given token and amount, as long as the token is not\\n   *         the native token, and the allowance target is not the zero address\\n   * @param _token The token to approve\\n   * @param _allowanceTarget The spender that will be approved\\n   * @param _amount The allowance to set\\n   */\\n  function setAllowanceIfNecessary(address _token, address _allowanceTarget, uint256 _amount) internal {\\n    if (_token != NATIVE_TOKEN && _allowanceTarget != address(0)) {\\n      setAllowance(IERC20(_token), _allowanceTarget, _amount);\\n    }\\n  }\\n\\n  /**\\n   * @notice Distributes the available amount of the given token according to the set distribution. All tokens\\n   *         will be distributed according to the configured shares. The last target will get sent all unassigned\\n   *         tokens\\n   * @param _token The token to distribute\\n   * @param _distribution How to distribute the available amount of the token. Must have at least one target\\n   */\\n  function distributeTo(\\n    address _token,\\n    DistributionTarget[] calldata _distribution\\n  )\\n    internal\\n    returns (uint256 _available)\\n  {\\n    _available = balanceOnContract(_token);\\n    uint256 _amountLeft = _available;\\n\\n    // Distribute amounts\\n    for (uint256 i; i < _distribution.length - 1;) {\\n      uint256 _toSend = _available * _distribution[i].shareBps / 10_000;\\n      sendAmountTo(_token, _toSend, _distribution[i].recipient);\\n      _amountLeft -= _toSend;\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n\\n    // Send amount left to the last recipient\\n    sendAmountTo(_token, _amountLeft, _distribution[_distribution.length - 1].recipient);\\n  }\\n\\n  /**\\n   * @notice Checks if the contract has any balance of the given token, and if it does,\\n   *         it sends it to the given recipient\\n   * @param _token The token to check\\n   * @param _recipient The recipient of the token balance\\n   * @return _balance The current balance held by the contract\\n   */\\n  function sendBalanceOnContractTo(address _token, address _recipient) internal returns (uint256 _balance) {\\n    _balance = balanceOnContract(_token);\\n    sendAmountTo(_token, _balance, _recipient);\\n  }\\n\\n  /**\\n   * @notice Transfers the given amount of tokens from the contract to the recipient\\n   * @param _token The token to check\\n   * @param _amount The amount to send\\n   * @param _recipient The recipient\\n   */\\n  function sendAmountTo(address _token, uint256 _amount, address _recipient) internal {\\n    if (_amount > 0) {\\n      if (_recipient == address(0)) _recipient = msg.sender;\\n      if (_token == NATIVE_TOKEN) {\\n        payable(_recipient).sendValue(_amount);\\n      } else {\\n        IERC20(_token).safeTransfer(_recipient, _amount);\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.19;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev The ETH balance of the account is not enough to perform the operation.\\n     */\\n    error AddressInsufficientBalance(address account);\\n\\n    /**\\n     * @dev There's no code at `target` (it is not a contract).\\n     */\\n    error AddressEmptyCode(address target);\\n\\n    /**\\n     * @dev A call to an address target failed. The target may have reverted.\\n     */\\n    error FailedInnerCall();\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        if (address(this).balance < amount) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        if (!success) {\\n            revert FailedInnerCall();\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, defaultRevert);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with a\\n     * `customRevert` function as a fallback when `target` reverts.\\n     *\\n     * Requirements:\\n     *\\n     * - `customRevert` must be a reverting function.\\n     *\\n     * _Available since v5.0._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        function() internal view customRevert\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, customRevert);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, defaultRevert);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with a `customRevert` function as a fallback revert reason when `target` reverts.\\n     *\\n     * Requirements:\\n     *\\n     * - `customRevert` must be a reverting function.\\n     *\\n     * _Available since v5.0._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        function() internal view customRevert\\n    ) internal returns (bytes memory) {\\n        if (address(this).balance < value) {\\n            revert AddressInsufficientBalance(address(this));\\n        }\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, customRevert);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, defaultRevert);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        function() internal view customRevert\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, customRevert);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, defaultRevert);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        function() internal view customRevert\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, customRevert);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided `customRevert`) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v5.0._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        function() internal view customRevert\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check if target is a contract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                if (target.code.length == 0) {\\n                    revert AddressEmptyCode(target);\\n                }\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, customRevert);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or with a default revert error.\\n     *\\n     * _Available since v5.0._\\n     */\\n    function verifyCallResult(bool success, bytes memory returndata) internal view returns (bytes memory) {\\n        return verifyCallResult(success, returndata, defaultRevert);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-verifyCallResult-bool-bytes-}[`verifyCallResult`], but with a\\n     * `customRevert` function as a fallback when `success` is `false`.\\n     *\\n     * Requirements:\\n     *\\n     * - `customRevert` must be a reverting function.\\n     *\\n     * _Available since v5.0._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        function() internal view customRevert\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, customRevert);\\n        }\\n    }\\n\\n    /**\\n     * @dev Default reverting function when no `customRevert` is provided in a function call.\\n     */\\n    function defaultRevert() internal pure {\\n        revert FailedInnerCall();\\n    }\\n\\n    function _revert(bytes memory returndata, function() internal view customRevert) private view {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            customRevert();\\n            revert FailedInnerCall();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/Permit2Transfers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\n\\nimport { IPermit2 } from \\\"../interfaces/external/IPermit2.sol\\\";\\nimport { Token } from \\\"./Token.sol\\\";\\n\\n/**\\n * @title Permit2 Transfers Library\\n * @author Sam Bugs\\n * @notice A small library to call Permit2's transfer from methods\\n */\\nlibrary Permit2Transfers {\\n  /**\\n   * @notice Executes a transfer from using Permit2\\n   * @param _permit2 The Permit2 contract\\n   * @param _token The token to transfer\\n   * @param _amount The amount to transfer\\n   * @param _nonce The owner's nonce\\n   * @param _deadline The signature's expiration deadline\\n   * @param _signature The signature that allows the transfer\\n   */\\n  function takeFromCaller(\\n    IPermit2 _permit2,\\n    address _token,\\n    uint256 _amount,\\n    uint256 _nonce,\\n    uint256 _deadline,\\n    bytes calldata _signature\\n  )\\n    internal\\n  {\\n    if (address(_token) != Token.NATIVE_TOKEN) {\\n      _permit2.permitTransferFrom(\\n        // The permit message.\\n        IPermit2.PermitTransferFrom({\\n          permitted: IPermit2.TokenPermissions({ token: _token, amount: _amount }),\\n          nonce: _nonce,\\n          deadline: _deadline\\n        }),\\n        // The transfer recipient and amount.\\n        IPermit2.SignatureTransferDetails({ to: address(this), requestedAmount: _amount }),\\n        // The owner of the tokens, which must also be\\n        // the signer of the message, otherwise this call\\n        // will fail.\\n        msg.sender,\\n        // The packed signature that was the result of signing\\n        // the EIP712 hash of `permit`.\\n        _signature\\n      );\\n    }\\n  }\\n\\n  /**\\n   * @notice Executes a batch transfer from using Permit2\\n   * @param _permit2 The Permit2 contract\\n   * @param _tokens The amount of tokens to transfer\\n   * @param _nonce The owner's nonce\\n   * @param _deadline The signature's expiration deadline\\n   * @param _signature The signature that allows the transfer\\n   */\\n  function batchTakeFromCaller(\\n    IPermit2 _permit2,\\n    IPermit2.TokenPermissions[] calldata _tokens,\\n    uint256 _nonce,\\n    uint256 _deadline,\\n    bytes calldata _signature\\n  )\\n    internal\\n  {\\n    if (_tokens.length > 0) {\\n      _permit2.permitTransferFrom(\\n        // The permit message.\\n        IPermit2.PermitBatchTransferFrom({ permitted: _tokens, nonce: _nonce, deadline: _deadline }),\\n        // The transfer recipients and amounts.\\n        _buildTransferDetails(_tokens),\\n        // The owner of the tokens, which must also be\\n        // the signer of the message, otherwise this call\\n        // will fail.\\n        msg.sender,\\n        // The packed signature that was the result of signing\\n        // the EIP712 hash of `permit`.\\n        _signature\\n      );\\n    }\\n  }\\n\\n  function _buildTransferDetails(IPermit2.TokenPermissions[] calldata _tokens)\\n    private\\n    view\\n    returns (IPermit2.SignatureTransferDetails[] memory _details)\\n  {\\n    _details = new IPermit2.SignatureTransferDetails[](_tokens.length);\\n    for (uint256 i; i < _details.length;) {\\n      _details[i] = IPermit2.SignatureTransferDetails({ to: address(this), requestedAmount: _tokens[i].amount });\\n      unchecked {\\n        ++i;\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IArbitraryExecutionPermit2Adapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\n\\nimport { Token } from \\\"../libraries/Token.sol\\\";\\nimport { IBasePermit2Adapter, IPermit2 } from \\\"./IBasePermit2Adapter.sol\\\";\\n\\ninterface IArbitraryExecutionPermit2Adapter is IBasePermit2Adapter {\\n  /// @notice Data necessary to execute a single permit transfer\\n  struct SinglePermit {\\n    address token;\\n    uint256 amount;\\n    uint256 nonce;\\n    bytes signature;\\n  }\\n\\n  /// @notice Data necessary to execute a batch permit transfer\\n  struct BatchPermit {\\n    IPermit2.TokenPermissions[] tokens;\\n    uint256 nonce;\\n    bytes signature;\\n  }\\n\\n  /// @notice Allowance target for a specific token\\n  struct AllowanceTarget {\\n    address token;\\n    address allowanceTarget;\\n  }\\n\\n  /// @notice A specific contract call\\n  struct ContractCall {\\n    address target;\\n    bytes data;\\n    uint256 value;\\n  }\\n\\n  /// @notice A token and how to distribute it\\n  struct TransferOut {\\n    address token;\\n    Token.DistributionTarget[] distribution;\\n  }\\n\\n  /**\\n   * @notice Executes arbitrary calls by proxing to another contracts, but using Permit2 to transfer tokens from the\\n   *         caller\\n   * @param permit The permit data to use to transfer tokens from the user\\n   * @param allowanceTargets The contracts to approve before executing calls\\n   * @param contractCalls The calls to execute\\n   * @param transferOut The tokens to transfer out of our contract after all calls have been executed. Note that each\\n   *                    element of the array should handle different tokens\\n   * @param deadline The max time where this call can be executed\\n   * @return executionResults The results of each contract call\\n   * @return tokenBalances The balances held by the contract after contract calls were executed\\n   */\\n  function executeWithPermit(\\n    SinglePermit calldata permit,\\n    AllowanceTarget[] calldata allowanceTargets,\\n    ContractCall[] calldata contractCalls,\\n    TransferOut[] calldata transferOut,\\n    uint256 deadline\\n  )\\n    external\\n    payable\\n    returns (bytes[] memory executionResults, uint256[] memory tokenBalances);\\n\\n  /**\\n   * @notice Executes arbitrary calls by proxing to another contracts, but using Permit2 to transfer tokens from the\\n   *         caller\\n   * @param batchPermit The permit data to use to batch transfer tokens from the user\\n   * @param allowanceTargets The contracts to approve before executing calls\\n   * @param contractCalls The calls to execute\\n   * @param transferOut The tokens to transfer out of our contract after all calls have been executed\\n   * @param deadline The max time where this call can be executed\\n   * @return executionResults The results of each contract call\\n   * @return tokenBalances The balances held by the contract after contract calls were executed\\n   */\\n  function executeWithBatchPermit(\\n    BatchPermit calldata batchPermit,\\n    AllowanceTarget[] calldata allowanceTargets,\\n    ContractCall[] calldata contractCalls,\\n    TransferOut[] calldata transferOut,\\n    uint256 deadline\\n  )\\n    external\\n    payable\\n    returns (bytes[] memory executionResults, uint256[] memory tokenBalances);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISwapPermit2Adapter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\n\\nimport { Token } from \\\"../libraries/Token.sol\\\";\\nimport { IBasePermit2Adapter } from \\\"./IBasePermit2Adapter.sol\\\";\\n\\ninterface ISwapPermit2Adapter is IBasePermit2Adapter {\\n  /**\\n   * @notice Thrown when the swap produced less token out than expected\\n   * @param received The amount of token out received\\n   * @param expected The amount of token out expected\\n   */\\n  error ReceivedTooLittleTokenOut(uint256 received, uint256 expected);\\n\\n  /// @notice Swap params for a sell order\\n  struct SellOrderSwapParams {\\n    // Deadline\\n    uint256 deadline;\\n    // Take from caller\\n    address tokenIn;\\n    uint256 amountIn;\\n    uint256 nonce;\\n    bytes signature;\\n    // Swap approval\\n    address allowanceTarget;\\n    // Swap execution\\n    address swapper;\\n    bytes swapData;\\n    // Swap validation\\n    address tokenOut;\\n    uint256 minAmountOut;\\n    // Transfer token out\\n    Token.DistributionTarget[] transferOut;\\n  }\\n\\n  // @notice Swap params for a buy order\\n  struct BuyOrderSwapParams {\\n    // Deadline\\n    uint256 deadline;\\n    // Take from caller\\n    address tokenIn;\\n    uint256 maxAmountIn;\\n    uint256 nonce;\\n    bytes signature;\\n    // Swap approval\\n    address allowanceTarget;\\n    // Swap execution\\n    address swapper;\\n    bytes swapData;\\n    // Swap validation\\n    address tokenOut;\\n    uint256 amountOut;\\n    // Transfer token out\\n    Token.DistributionTarget[] transferOut;\\n    // Transfer token in\\n    address unspentTokenInRecipient;\\n  }\\n\\n  /**\\n   * @notice Executes a sell order swap by proxing to another contract, but using Permit2 to transfer tokens from the\\n   * caller\\n   * @param params The swap's data, such as tokens, amounts, recipient, etc\\n   * @return amountIn The amount ot `token in` spent on the swap\\n   * @return amountOut The amount of `token out` produced by the proxied swap\\n   */\\n  function sellOrderSwap(SellOrderSwapParams calldata params)\\n    external\\n    payable\\n    returns (uint256 amountIn, uint256 amountOut);\\n\\n  /**\\n   * @notice Executes a buy order swap by proxing to another contract, but using Permit2 to transfer tokens from the\\n   * caller\\n   * @param params The swap's data, such as tokens, amounts, recipient, etc\\n   * @return amountIn The amount ot `token in` spent on the swap\\n   * @return amountOut The amount of `token out` produced by the proxied swap\\n   */\\n  function buyOrderSwap(BuyOrderSwapParams calldata params)\\n    external\\n    payable\\n    returns (uint256 amountIn, uint256 amountOut);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/external/IPermit2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\n\\n// Minimal Permit2 interface, derived from\\n// https://github.com/Uniswap/permit2/blob/main/src/interfaces/ISignatureTransfer.sol\\ninterface IPermit2 {\\n  struct TokenPermissions {\\n    address token;\\n    uint256 amount;\\n  }\\n\\n  struct PermitTransferFrom {\\n    TokenPermissions permitted;\\n    uint256 nonce;\\n    uint256 deadline;\\n  }\\n\\n  struct PermitBatchTransferFrom {\\n    TokenPermissions[] permitted;\\n    uint256 nonce;\\n    uint256 deadline;\\n  }\\n\\n  struct SignatureTransferDetails {\\n    address to;\\n    uint256 requestedAmount;\\n  }\\n\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n  function permitTransferFrom(\\n    PermitTransferFrom calldata permit,\\n    SignatureTransferDetails calldata transferDetails,\\n    address owner,\\n    bytes calldata signature\\n  )\\n    external;\\n\\n  function permitTransferFrom(\\n    PermitBatchTransferFrom memory permit,\\n    SignatureTransferDetails[] calldata transferDetails,\\n    address owner,\\n    bytes calldata signature\\n  )\\n    external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.19;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev An operation with an ERC20 token failed.\\n     */\\n    error SafeERC20FailedOperation(address token);\\n\\n    /**\\n     * @dev Indicates a failed `decreaseAllowance` request.\\n     */\\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        forceApprove(token, spender, oldAllowance + value);\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\\n        unchecked {\\n            uint256 currentAllowance = token.allowance(address(this), spender);\\n            if (currentAllowance < requestedDecrease) {\\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\\n            }\\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to\\n     * 0 before setting it to a non-zero value.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        if (nonceAfter != nonceBefore + 1) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data);\\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.19;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.19;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@call-simulation/=lib/call-simulation/src/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"@prb/test/=lib/prb-test/src/\",\r\n      \"call-simulation/=lib/call-simulation/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"prb-test/=lib/prb-test/src/\",\r\n      \"src/=src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"appendCBOR\": false\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IPermit2\",\"name\":\"_permit2\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"AddressEmptyCode\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddressInsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"received\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"}],\"name\":\"ReceivedTooLittleTokenOut\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"SafeERC20FailedOperation\",\"type\":\"error\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"result\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"gasSpent\",\"type\":\"uint256\"}],\"internalType\":\"struct ISimulationAdapter.SimulationResult\",\"name\":\"result\",\"type\":\"tuple\"}],\"name\":\"SimulatedCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"current\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"TransactionDeadlinePassed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NATIVE_TOKEN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT2\",\"outputs\":[{\"internalType\":\"contract IPermit2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"allowanceTarget\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"swapper\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"swapData\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"shareBps\",\"type\":\"uint256\"}],\"internalType\":\"struct Token.DistributionTarget[]\",\"name\":\"transferOut\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"unspentTokenInRecipient\",\"type\":\"address\"}],\"internalType\":\"struct ISwapPermit2Adapter.BuyOrderSwapParams\",\"name\":\"_params\",\"type\":\"tuple\"}],\"name\":\"buyOrderSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct IPermit2.TokenPermissions[]\",\"name\":\"tokens\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct IArbitraryExecutionPermit2Adapter.BatchPermit\",\"name\":\"_batchPermit\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"allowanceTarget\",\"type\":\"address\"}],\"internalType\":\"struct IArbitraryExecutionPermit2Adapter.AllowanceTarget[]\",\"name\":\"_allowanceTargets\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct IArbitraryExecutionPermit2Adapter.ContractCall[]\",\"name\":\"_contractCalls\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"shareBps\",\"type\":\"uint256\"}],\"internalType\":\"struct Token.DistributionTarget[]\",\"name\":\"distribution\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IArbitraryExecutionPermit2Adapter.TransferOut[]\",\"name\":\"_transferOut\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"executeWithBatchPermit\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"_executionResults\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenBalances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct IArbitraryExecutionPermit2Adapter.SinglePermit\",\"name\":\"_permit\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"allowanceTarget\",\"type\":\"address\"}],\"internalType\":\"struct IArbitraryExecutionPermit2Adapter.AllowanceTarget[]\",\"name\":\"_allowanceTargets\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct IArbitraryExecutionPermit2Adapter.ContractCall[]\",\"name\":\"_contractCalls\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"shareBps\",\"type\":\"uint256\"}],\"internalType\":\"struct Token.DistributionTarget[]\",\"name\":\"distribution\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IArbitraryExecutionPermit2Adapter.TransferOut[]\",\"name\":\"_transferOut\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"}],\"name\":\"executeWithPermit\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"_executionResults\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenBalances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"allowanceTarget\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"swapper\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"swapData\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"shareBps\",\"type\":\"uint256\"}],\"internalType\":\"struct Token.DistributionTarget[]\",\"name\":\"transferOut\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ISwapPermit2Adapter.SellOrderSwapParams\",\"name\":\"_params\",\"type\":\"tuple\"}],\"name\":\"sellOrderSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"_calls\",\"type\":\"bytes[]\"}],\"name\":\"simulate\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"result\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"gasSpent\",\"type\":\"uint256\"}],\"internalType\":\"struct ISimulationAdapter.SimulationResult[]\",\"name\":\"_results\",\"type\":\"tuple[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_call\",\"type\":\"bytes\"}],\"name\":\"simulateAndRevert\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "UniversalPermit2Adapter", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "000000000000000000000000000000000022d473030f116ddee9f6b43ac78ba3", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}