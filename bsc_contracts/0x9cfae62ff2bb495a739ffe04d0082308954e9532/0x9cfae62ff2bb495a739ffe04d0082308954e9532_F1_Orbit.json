{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.0; \r\n\r\ncontract owned\r\n{\r\n    address internal owner;\r\n    address internal newOwner;\r\n    address public signer;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n        signer = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\r\n    modifier onlySigner {\r\n        require(msg.sender == signer, 'caller must be signer');\r\n        _;\r\n    }\r\n\r\n\r\n    function changeSigner(address _signer) public onlyOwner {\r\n        signer = _signer;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    //the reason for this flow is to protect owners from sending ownership to unintended address due to human error\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\n\r\n interface force1Interface\r\n {\r\n    function coreAddressByID(uint id) external view returns(address);\r\n }\r\n\r\n interface tokenInterface\r\n {\r\n    function transfer(address _to, uint256 _amount) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _amount) external returns (bool);\r\n    function balanceOf(address _user) external view returns(uint);\r\n    function increaseLiquidity(uint _liquidity, address _caller) external returns(bool);\r\n }\r\n\r\n\r\ncontract F1_Orbit is owned {\r\n\r\n    // Replace below address with main token token\r\n    address public tokenAddress;\r\n    address public coreAddress;\r\n    address public liquidityTokenAddress;\r\n\r\n    uint public totalGlobalCount;\r\n    mapping(address => uint) public userGlobalCount;\r\n\r\n    uint maxDownLimit = 2;\r\n    uint public startTime = block.timestamp;\r\n\r\n    uint public lastIDCount = 0;\r\n    uint public defaultRefID = 1;   //this ref ID will be used if user joins without any ref ID\r\n    bool public ignoreForce1;\r\n\r\n    struct userInfo {\r\n        bool joined;\r\n        uint id;\r\n        uint parentID;\r\n        uint referrerID;\r\n        uint levelBought;\r\n        address[] parent;\r\n        address[] referral;\r\n    }\r\n\r\n\r\n    \r\n    mapping(uint => uint) public priceOfLevel;\r\n    mapping(uint => uint) public directRefIncome;\r\n    mapping(uint => uint) public distForCore;\r\n    mapping(uint => uint) public liquidity;\r\n\r\n\r\n    mapping(uint => uint) public _4XGlobalCount; // for distribution\r\n\r\n    struct autoPool\r\n    {\r\n        uint userID;\r\n        uint autoPoolParent;\r\n        bool right;\r\n    }\r\n\r\n\r\n    mapping(uint => autoPool[]) public _4XPoolLevel;  // users lavel records under auto pool scheme\r\n    mapping(address => mapping(uint => uint[])) public _4XPoolIndex; //to find index of user inside auto pool\r\n    uint[10] public _4XFillIndex;  // which auto pool index is in top of queue to fill in \r\n    uint[10] public _4XFillBox;   // 3 downline to each, so which downline need to fill in\r\n\r\n    mapping (address => userInfo) public userInfos;\r\n    mapping (uint => address payable) public userAddressByID;\r\n\r\n\r\n    event regLevelEv(address indexed _userWallet, uint indexed _userID, uint indexed _parentID, uint _time, address _refererWallet, uint _referrerID);\r\n    event levelBuyEv(address indexed _user, uint _level, uint _amount, uint _time);\r\n    event paidForLevelEv(address indexed _user, address indexed _referral, uint _level, uint _amount, uint _time);\r\n\r\n    event _4XPoolPayEv(uint timeNow,address paidTo,uint paidForLevel, uint paidAmount, address paidAgainst);\r\n    event update_4XPoolEv(uint timeNow,uint userIndexInAutoPool, address user);\r\n    event directPayEv(address from, address to, uint level, uint amount);\r\n\r\n    function initialize(address payable ownerAddress, address payable ID1address) public onlyOwner {\r\n        owner = ownerAddress;\r\n\r\n        emit OwnershipTransferred(address(0), owner);\r\n        address payable ownerWallet = ID1address;\r\n\r\n        uint pow = 10 ** 18;\r\n\r\n        priceOfLevel[1] = 12 * pow;\r\n        priceOfLevel[2] = 18 * pow;\r\n        priceOfLevel[3] = 30 * pow;\r\n        priceOfLevel[4] = 40 * pow;\r\n        priceOfLevel[5] = 70 * pow;\r\n        priceOfLevel[6] = 130 * pow;\r\n        priceOfLevel[7] = 200 * pow;\r\n        priceOfLevel[8] = 300 * pow;\r\n        priceOfLevel[9] = 500 * pow;\r\n        priceOfLevel[10]= 700 * pow;\r\n\r\n        directRefIncome[1] = 3 * pow;\r\n        directRefIncome[2] = 4 * pow;\r\n        directRefIncome[3] = 6 * pow;\r\n        directRefIncome[4] = 8 * pow;\r\n        directRefIncome[5] = 15 * pow;\r\n        directRefIncome[6] = 30 * pow;\r\n        directRefIncome[7] = 50 * pow;\r\n        directRefIncome[8] = 70 * pow;\r\n        directRefIncome[9] = 114 * pow;\r\n        directRefIncome[10]= 200 * pow;\r\n\r\n        _4XGlobalCount[1] = 1;\r\n        _4XGlobalCount[2] = 1;\r\n        _4XGlobalCount[3] = 1;\r\n        _4XGlobalCount[4] = 1;\r\n        _4XGlobalCount[5] = 3;\r\n        _4XGlobalCount[6] = 3;\r\n        _4XGlobalCount[7] = 4;\r\n        _4XGlobalCount[8] = 4;\r\n        _4XGlobalCount[9] = 5;\r\n        _4XGlobalCount[10]= 6;\r\n\r\n        distForCore[1] = 0 * pow;\r\n        distForCore[2] = 3 * pow;\r\n        distForCore[3] = 6 * pow;\r\n        distForCore[4] = 8 * pow;\r\n        distForCore[5] = 15 * pow;\r\n        distForCore[6] = 30 * pow;\r\n        distForCore[7] = 50 * pow;\r\n        distForCore[8] = 80 * pow;\r\n        distForCore[9] = 142 * pow;\r\n        distForCore[10]= 166 * pow;\r\n\r\n\r\n        liquidity[1] = 4 * pow;\r\n        liquidity[2] = 6 * pow;\r\n        liquidity[3] = 13 * pow;\r\n        liquidity[4] = 19 * pow;\r\n        liquidity[5] = 25 * pow;\r\n        liquidity[6] = 55 * pow;\r\n        liquidity[7] = 80 * pow;\r\n        liquidity[8] = 125 * pow;\r\n        liquidity[9] = 219 * pow;\r\n        liquidity[10]= 304 * pow;\r\n\r\n        userInfo memory UserInfo;\r\n        lastIDCount++;\r\n\r\n        UserInfo = userInfo({\r\n            joined: true,\r\n            id: lastIDCount,\r\n            parentID: 1,\r\n            referrerID: 1,\r\n            levelBought: 10,  \r\n            referral: new address[](0),\r\n            parent: new address[](0)\r\n        });\r\n        userInfos[ownerWallet] = UserInfo;\r\n        userAddressByID[lastIDCount] = ownerWallet;\r\n\r\n        autoPool memory temp2;\r\n        for (uint a = 0 ; a < 10; a++)\r\n        {\r\n           temp2.userID = lastIDCount;  \r\n           _4XPoolLevel[a].push(temp2);\r\n         \r\n           _4XPoolIndex[ownerWallet][a].push(0);\r\n        }\r\n\r\n        emit regLevelEv(ownerWallet, 1, 0, block.timestamp, address(this), 0);\r\n\r\n    }\r\n\r\n    function toggleIgnoreForce1() public onlyOwner returns(bool)\r\n    {\r\n        ignoreForce1 = !ignoreForce1;\r\n        return true;\r\n    }\r\n\r\n    function subOrbitOwn(uint _oldID, address _referrer, address _user) public onlyOwner returns(bool) \r\n    {\r\n        _subOrbit(_oldID,_referrer, _user);\r\n        return true;\r\n    }\r\n\r\n\r\n    function subOrbit(uint _oldID, address _referrer) public returns(bool) \r\n    {\r\n        _subOrbit(_oldID,_referrer, msg.sender);\r\n        return true;\r\n    }\r\n\r\n\r\n    function _subOrbit(uint _oldID, address _referrer, address msgSender) internal returns(bool) \r\n    {\r\n        if (!ignoreForce1) require(force1Interface(coreAddress).coreAddressByID(_oldID) == msgSender, \"Invalid oldID\");\r\n        uint _referrerID = userInfos[_referrer].id;\r\n        if (_referrerID == 0) _referrerID = 1;\r\n\r\n        uint pID;\r\n\r\n        address origRef = userAddressByID[_referrerID];\r\n\r\n\r\n        //checking all conditions\r\n        require(!userInfos[msgSender].joined, 'User exist');\r\n\r\n        uint _lastIDCount = lastIDCount; // from here _lastIDCount is lastIDCount\r\n\r\n        if(userInfos[_referrer].parent.length >= maxDownLimit ) pID = userInfos[findFreeReferrer(_referrer)].id;\r\n\r\n\r\n        uint prc = priceOfLevel[1];\r\n        //transferring tokens from smart user to smart contract for level 1\r\n        tokenInterface(tokenAddress).transferFrom(msg.sender, address(this), prc);\r\n\r\n        uint di = directRefIncome[1] ;\r\n        //direct payment\r\n        if( userInfos[origRef].levelBought >= 1) \r\n        {\r\n            tokenInterface(tokenAddress).transfer(origRef, di);\r\n            emit directPayEv(msgSender,origRef,1,di);\r\n        }\r\n        else\r\n        {\r\n            tokenInterface(tokenAddress).transfer(owner, directRefIncome[1] );\r\n            emit directPayEv(msgSender,owner,1,di);\r\n        }\r\n        //update variables\r\n        userInfo memory UserInfo;\r\n        _lastIDCount++;\r\n\r\n        UserInfo = userInfo({\r\n            joined: true,\r\n            id: _lastIDCount,\r\n            parentID: pID,\r\n            referrerID: _referrerID,\r\n            levelBought: 1,             \r\n            referral: new address[](0),\r\n            parent: new address[](0)\r\n        });\r\n\r\n        userInfos[msgSender] = UserInfo;\r\n        userAddressByID[_lastIDCount] = payable(msgSender);\r\n\r\n\r\n\r\n        userInfos[userAddressByID[pID]].parent.push(msgSender);\r\n        \r\n        userInfos[origRef].referral.push(msgSender);\r\n\r\n\r\n        lastIDCount = _lastIDCount;\r\n        require(spkitPart(msgSender,_lastIDCount,pID,_referrerID,prc),\"split part failed\");\r\n        return true;\r\n    }\r\n\r\n    function spkitPart(address msgSender, uint lID, uint pID, uint _referrerID, uint prc) internal returns(bool)\r\n    {\r\n        //require(payForLevel(1, msgSender),\"pay for level fail\");\r\n        emit regLevelEv(msgSender, lID, pID, block.timestamp,userAddressByID[pID], _referrerID );\r\n        emit levelBuyEv(msgSender, 1, prc, block.timestamp);\r\n\r\n        require(updateNPay_4XPool(msgSender),\"_4X pool update fail\"); \r\n        uint liq = liquidity[1];\r\n        tokenInterface(tokenAddress).transfer(liquidityTokenAddress, liq);\r\n        tokenInterface(liquidityTokenAddress).increaseLiquidity(liq,msgSender);\r\n        flushRemaining();      \r\n        return true;\r\n    }\r\n\r\n    function buyOrbitOwn(uint _level, address _user) public onlyOwner returns(bool)\r\n    {\r\n        _buyOrbit(_level, _user);\r\n        return true;\r\n    }\r\n\r\n\r\n    function buyOrbit(uint _level) public returns(bool)\r\n    {\r\n        _buyOrbit(_level, msg.sender);\r\n        return true;\r\n    }\r\n\r\n\r\n    function _buyOrbit(uint _level, address msgSender) internal returns(bool)\r\n    {\r\n        \r\n        require(_level > 1 && _level <= 10, 'Incorrect level');\r\n        require(userInfos[msgSender].levelBought + 1 == _level, \"buy previous level first\");  \r\n        userInfos[msgSender].levelBought = _level;\r\n        \r\n      \r\n        //transfer tokens\r\n        uint prc = priceOfLevel[_level];\r\n        tokenInterface(tokenAddress).transferFrom(msg.sender, address(this), prc);\r\n\r\n\r\n        address origRef = userAddressByID[userInfos[msgSender].referrerID];\r\n        //direct payment\r\n        \r\n       // if( userInfos[origRef].levelBought >= _level) \r\n       // {\r\n       //     tokenInterface(tokenAddress).transfer(origRef, directRefIncome[_level] );\r\n       // }\r\n       // else\r\n       // {\r\n       //     tokenInterface(tokenAddress).transfer(owner, directRefIncome[_level] );\r\n       // }\r\n\r\n\r\n       // referer = userAddressByID[userInfos[_user].referrerID];\r\n        for(uint j=0; j < 5; j++)\r\n        {\r\n            if( userInfos[origRef].levelBought >= _level )\r\n            {\r\n                tokenInterface(tokenAddress).transfer(origRef, directRefIncome[_level]);\r\n                emit directPayEv(msgSender,origRef,_level,directRefIncome[_level]);\r\n                j=11;\r\n            }\r\n            else\r\n            {\r\n                origRef = userAddressByID[userInfos[origRef].referrerID];\r\n                if(j==4)\r\n                {\r\n                    tokenInterface(tokenAddress).transfer(owner, directRefIncome[_level]);\r\n                    emit directPayEv(msgSender,owner,_level,directRefIncome[_level]);\r\n                    j=11;\r\n                }                \r\n            }            \r\n        }\r\n\r\n\r\n        require(payForLevel(_level, msgSender),\"pay for level fail\");\r\n        emit levelBuyEv(msgSender, _level, prc , block.timestamp);\r\n\r\n            uint i=_4XGlobalCount[_level];\r\n            \r\n            for (uint j=0;j<i;j++)\r\n            {\r\n                updateNPay_4XPool(msgSender);\r\n            }\r\n\r\n        uint liq = liquidity[_level];\r\n        tokenInterface(tokenAddress).transfer(liquidityTokenAddress, liq);\r\n        tokenInterface(liquidityTokenAddress).increaseLiquidity(liq,msgSender);\r\n\r\n        flushRemaining();\r\n        return true;\r\n    }\r\n    \r\n\r\n\r\n    function payForLevel(uint _level, address _user) internal returns (bool){\r\n        address referer;\r\n        uint amt = distForCore[_level]/10;\r\n\r\n        referer = userAddressByID[userInfos[_user].referrerID];\r\n        for(uint i=0; i < 10; i++)\r\n        {\r\n            if( userInfos[referer].levelBought >= _level )\r\n            {\r\n                tokenInterface(tokenAddress).transfer(referer, amt);\r\n            }\r\n            else\r\n            {\r\n                tokenInterface(tokenAddress).transfer(owner, amt);\r\n            }\r\n            referer = userAddressByID[userInfos[referer].referrerID];\r\n        }\r\n        return true;\r\n\r\n    }\r\n\r\n    function flushRemaining() internal returns(bool)\r\n    {\r\n        uint bal = tokenInterface(tokenAddress).balanceOf(address(this));\r\n        if (bal > 0) tokenInterface(tokenAddress).transfer(owner, bal);\r\n        return true;\r\n    }\r\n\r\n    function findFreeReferrer(address _user) public view returns(address) {\r\n        uint _limit = maxDownLimit;\r\n        if(userInfos[_user].parent.length < _limit ) return _user;\r\n\r\n        address[] memory referrals = new address[](126);\r\n\r\n        uint j;\r\n        for(j=0;j<_limit;j++)\r\n        {\r\n            referrals[j] = userInfos[_user].parent[j];\r\n        }\r\n\r\n        address freeReferrer;\r\n        bool noFreeReferrer = true;\r\n\r\n        for(uint i = 0; i < 126; i++) {\r\n\r\n\r\n            if(userInfos[referrals[i]].parent.length == _limit) {\r\n\r\n                if(j < 62) {\r\n                    \r\n                    for(uint k=0;k< _limit;k++)\r\n                    {\r\n                        referrals[j] = userInfos[referrals[i]].parent[k];\r\n                        j++;\r\n                    }\r\n\r\n                }\r\n            }\r\n            else {\r\n                noFreeReferrer = false;\r\n                freeReferrer = referrals[i];\r\n                break;\r\n            }\r\n        }\r\n\r\n        require(!noFreeReferrer, 'No Free Referrer');\r\n\r\n        return freeReferrer;\r\n    }\r\n\r\n\r\n    function updateNPay_4XPool(address _user) internal returns (bool)\r\n    {\r\n        address recycleUser;\r\n        uint a;\r\n        uint len = _4XPoolLevel[a].length;\r\n        autoPool memory temp;\r\n        temp.userID = userInfos[_user].id;\r\n        uint idx = _4XFillIndex[a];\r\n        temp.autoPoolParent = idx;       \r\n        _4XPoolLevel[a].push(temp);  \r\n        userGlobalCount[_user]++;\r\n        totalGlobalCount++;      \r\n\r\n        uint ix = _4XPoolLevel[a][idx].autoPoolParent;\r\n        recycleUser = userAddressByID[_4XPoolLevel[a][ix].userID];       \r\n\r\n        bool recycle = false;\r\n        if(_4XFillBox[a] == 0)\r\n        {\r\n            _4XFillBox[a] = 1;\r\n        }   \r\n        else\r\n        {\r\n            _4XPoolLevel[a][len].right = true;\r\n            _4XFillIndex[a]++;\r\n            _4XFillBox[a] = 0;\r\n\r\n            if (_4XPoolLevel[a][idx].right == true) \r\n            {\r\n                recycle = true;\r\n            } \r\n            \r\n        }\r\n\r\n\r\n        if(recycle == false)\r\n        {\r\n            if(recycleUser == address(0)) recycleUser = userAddressByID[defaultRefID];\r\n            uint amt = 5 * (10**18);\r\n\r\n            tokenInterface(tokenAddress).transfer(recycleUser, amt);\r\n            emit _4XPoolPayEv(block.timestamp, recycleUser,a+1, amt, _user);\r\n        }\r\n\r\n        _4XPoolIndex[_user][a].push(len);\r\n        emit update_4XPoolEv(block.timestamp,len, _user);\r\n        if(recycle == true) updateNPay_4XPool(recycleUser);\r\n        return true;\r\n    }\r\n\r\n    function viewUserReferral(address _user) public view returns(address[] memory) {\r\n        return userInfos[_user].referral;\r\n    }\r\n\r\n\r\n\r\n    function viewUsersOfParent(address _user) public view returns(address[] memory) {\r\n        return userInfos[_user].parent;\r\n    }\r\n\r\n\r\n    \r\n    function indexLength(uint _level) public view returns(uint)\r\n    {\r\n        if(!(_level > 0  || _level < 11)) return 0;\r\n        return _4XPoolLevel[_level - 1].length;\r\n    }  \r\n\r\n    \r\n    function changeLiquidityTokenaddress(address newLiquidityTokenaddress) onlyOwner public returns(string memory){\r\n        liquidityTokenAddress = newLiquidityTokenaddress;\r\n        return(\"token address updated successfully\");\r\n    }\r\n\r\n    function Assign_Reward_Address(address newtokenaddress) onlyOwner public returns(string memory){\r\n        tokenAddress = newtokenaddress;\r\n        return(\"token address updated successfully\");\r\n    }\r\n\r\n    function force1CoreContract(address _fContract) onlyOwner public returns(bool)\r\n    {\r\n        coreAddress = _fContract;\r\n        return true;\r\n    }\r\n\r\n    function changeMyAddress(address _newAddress, address _oldAddress) public onlyOwner returns(bool)\r\n    {\r\n        require(!userInfos[_newAddress].joined && userInfos[_oldAddress].joined, \"wrong caller or new address\");\r\n        userInfos[_newAddress] = userInfos[_oldAddress];\r\n        userInfos[_oldAddress] = userInfos[address(0)];\r\n        uint id = userInfos[_oldAddress].id;\r\n\r\n        userAddressByID[id] = payable(_newAddress);\r\n\r\n        return true;\r\n    }\r\n\r\n    function levelBought_(address _user) public view returns(uint)\r\n    {\r\n        return userInfos[_user].levelBought;\r\n    }\r\n\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeNow\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"paidTo\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"paidForLevel\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"paidAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"paidAgainst\",\"type\":\"address\"}],\"name\":\"_4XPoolPayEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"directPayEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"levelBuyEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_referral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"paidForLevelEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_userWallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_userID\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_parentID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_refererWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_referrerID\",\"type\":\"uint256\"}],\"name\":\"regLevelEv\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeNow\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userIndexInAutoPool\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"update_4XPoolEv\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newtokenaddress\",\"type\":\"address\"}],\"name\":\"Assign_Reward_Address\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_4XFillBox\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_4XFillIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_4XGlobalCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_4XPoolIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_4XPoolLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"userID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"autoPoolParent\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"right\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"buyOrbit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"buyOrbitOwn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newLiquidityTokenaddress\",\"type\":\"address\"}],\"name\":\"changeLiquidityTokenaddress\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oldAddress\",\"type\":\"address\"}],\"name\":\"changeMyAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"}],\"name\":\"changeSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coreAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultRefID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"directRefIncome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"distForCore\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"findFreeReferrer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fContract\",\"type\":\"address\"}],\"name\":\"force1CoreContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ignoreForce1\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"indexLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"ownerAddress\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"ID1address\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastIDCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"levelBought_\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"liquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"priceOfLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"signer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_oldID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"subOrbit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_oldID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"subOrbitOwn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleIgnoreForce1\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalGlobalCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userAddressByID\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userGlobalCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfos\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"joined\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"parentID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referrerID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"levelBought\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"viewUserReferral\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"viewUsersOfParent\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "F1_Orbit", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d4555adc83e26e70bc794d559197796a7130b0f07996124c3542b8457e04524b"}