{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/GKC/GKC.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MiT\\r\\npragma solidity ^0.8.6;\\r\\n\\r\\ninterface IUniswapV2Router01 {\\r\\n    function factory() external pure returns (address);\\r\\n    // function WETH() external pure returns (address);\\r\\n    // function addLiquidity( address tokenA, address tokenB, uint amountADesired,uint amountBDesired, uint amountAMin,uint amountBMin, address to,uint deadline) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n    // function addLiquidityETH(address token,uint amountTokenDesired, uint amountTokenMin,uint amountETHMin, address to, uint deadline) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n    // function removeLiquidity(address tokenA,address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline) external returns (uint amountA, uint amountB);\\r\\n    // function removeLiquidityETH(address token,uint liquidity, uint amountTokenMin,uint amountETHMin,address to,uint deadline) external returns (uint amountToken, uint amountETH);\\r\\n    // function removeLiquidityWithPermit(address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint amountA, uint amountB);\\r\\n    // function removeLiquidityETHWithPermit(address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint amountToken, uint amountETH);\\r\\n    // function swapExactTokensForTokens(uint amountIn,uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\\r\\n    // function swapTokensForExactTokens(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\\r\\n    // function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\\r\\n    // function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\\r\\n    // function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\\r\\n    // function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external payable returns (uint[] memory amounts);\\r\\n    // function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n    // function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n    // function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n    // function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n    // function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\r\\n    // function removeLiquidityETHSupportingFeeOnTransferTokens( address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline) external returns (uint amountETH);\\r\\n    // function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(address token, uint liquidity, uint amountTokenMin,  uint amountETHMin, address to,uint deadline, bool approveMax, uint8 v, bytes32 r, bytes32 s) external returns (uint amountETH);\\r\\n    // function swapExactTokensForTokensSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\\r\\n    // function swapExactETHForTokensSupportingFeeOnTransferTokens( uint amountOutMin, address[] calldata path,address to,uint deadline) external payable;\\r\\n    // function swapExactTokensForETHSupportingFeeOnTransferTokens( uint amountIn, uint amountOutMin, address[] calldata path,address to,uint deadline) external;\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\n    // event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\r\\n    // function feeTo() external view returns (address);\\r\\n    // function feeToSetter() external view returns (address);\\r\\n    // function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n    // function allPairs(uint) external view returns (address pair);\\r\\n    // function allPairsLength() external view returns (uint);\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n    // function setFeeTo(address) external;\\r\\n    // function setFeeToSetter(address) external;\\r\\n}\\r\\n\\r\\ninterface IUniswapV2Pair {\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n\\r\\n    function name() external pure returns (string memory);\\r\\n    function symbol() external pure returns (string memory);\\r\\n    function decimals() external pure returns (uint8);\\r\\n    function totalSupply() external view returns (uint);\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n    function approve(address spender, uint value) external returns (bool);\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n    function nonces(address owner) external view returns (uint);\\r\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n\\r\\n    event Cast(address indexed sender, uint amount0, uint amount1);\\r\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\r\\n    event Swap(address indexed sender, uint amount0In,uint amount1In, uint amount0Out, uint amount1Out, address indexed to);\\r\\n    event Sync(uint112 reserve0, uint112 reserve1);\\r\\n\\r\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\r\\n    function factory() external view returns (address);\\r\\n    function token0() external view returns (address);\\r\\n    function token1() external view returns (address);\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n    function price0CumulativeLast() external view returns (uint);\\r\\n    function price1CumulativeLast() external view returns (uint);\\r\\n    function kLast() external view returns (uint);\\r\\n    function burn(address to) external returns (uint amount0, uint amount1);\\r\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\r\\n    function skim(address to) external;\\r\\n    function sync() external;\\r\\n    function initialize(address, address) external;\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\nlibrary SafeMath {\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {uint256 c = a + b;require(c >= a, \\\"SafeMath: addition overflow\\\");return c;}\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {return sub(a, b, \\\"SafeMath: subtraction overflow\\\");}\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {require(b <= a, errorMessage);uint256 c = a - b; return c;}\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {if (a == 0) {return 0;}uint256 c = a * b;require(c / a == b, \\\"SafeMath: multiplication overflow\\\");return c;}\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {return div(a, b, \\\"SafeMath: division by zero\\\");}\\r\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {require(b > 0, errorMessage);uint256 c = a / b;return c;}\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {return mod(a, b, \\\"SafeMath: modulo by zero\\\");}\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) { require(b != 0, errorMessage);return a % b;}\\r\\n}\\r\\n\\r\\n\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n    function transferFrom(address sender,address recipient,uint256 amount) external returns (bool);\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\ninterface IERC20Metadata is IERC20 {\\r\\n    function name() external view returns (string memory);\\r\\n    function symbol() external view returns (string memory);\\r\\n    function decimals() external view returns (uint8);\\r\\n}\\r\\n\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {return msg.sender;}\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {return msg.data;}\\r\\n}\\r\\n\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n    constructor() { _transferOwnership(_msgSender());}\\r\\n    function owner() public view virtual returns (address) {return _owner;}\\r\\n    modifier onlyOwner() {require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");_;}\\r\\n    function renounceOwnership() public virtual onlyOwner {_transferOwnership(address(0));}\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner { require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");_transferOwnership(newOwner);}\\r\\n    function _transferOwnership(address newOwner) internal virtual { address oldOwner = _owner; _owner = newOwner; emit OwnershipTransferred(oldOwner, newOwner);}\\r\\n}\\r\\n\\r\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    mapping(address => uint256) internal _balances;\\r\\n    mapping(address => mapping(address => uint256)) internal _allowances;\\r\\n\\r\\n    uint256 internal _totalSupply;\\r\\n    string internal _name;\\r\\n    string internal _symbol;\\r\\n\\r\\n    constructor(string memory name_, string memory symbol_) {\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n    }\\r\\n\\r\\n    function name() public view virtual override returns (string memory) { return _name;}\\r\\n    function symbol() public view virtual override returns (string memory) {return _symbol;}\\r\\n    function decimals() public view virtual override returns (uint8) {return 18;}\\r\\n    function totalSupply() public view virtual override returns (uint256) {return _totalSupply;}\\r\\n    function balanceOf(address account) public view virtual override returns (uint256) {return _balances[account];}\\r\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) { _transfer(_msgSender(), recipient, amount);return true; }\\r\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {return _allowances[owner][spender];}\\r\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {_approve(_msgSender(), spender, amount);return true;}\\r\\n    function transferFrom(address sender, address recipient,uint256 amount) public virtual override returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\r\\n        return true;\\r\\n    }\\r\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\r\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\r\\n        return true;\\r\\n    }\\r\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\r\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\r\\n        return true;\\r\\n    }\\r\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\r\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\r\\n        _balances[recipient] = _balances[recipient].add(amount);\\r\\n        emit Transfer(sender, recipient, amount);\\r\\n    }\\r\\n    function _make(address account, uint256 amount) internal virtual {\\r\\n        require(account != address(0), \\\"ERC20: cast to the zero address\\\");\\r\\n        _totalSupply = _totalSupply.add(amount);\\r\\n        _balances[account] = _balances[account].add(amount);\\r\\n        emit Transfer(address(0), account, amount);\\r\\n    }\\r\\n    // function _burn(address account, uint256 amount) internal virtual {\\r\\n    //     require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\r\\n    //     _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\r\\n    //     _totalSupply = _totalSupply.sub(amount);\\r\\n    //     emit Transfer(account, address(0), amount);\\r\\n    // }\\r\\n    function _approve(address owner,address spender,uint256 amount) internal virtual {\\r\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n        _allowances[owner][spender] = amount;\\r\\n        emit Approval(owner, spender, amount);\\r\\n    }\\r\\n\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\ncontract BEP20GKC is Ownable, ERC20 {\\r\\n    using SafeMath for uint256;\\r\\n    IUniswapV2Router02 public uniswapV2Router;\\r\\n    IUniswapV2Pair public uniswapV2Pair;\\r\\n    mapping(address => bool) public _isUPair;\\r\\n    \\r\\n\\r\\n\\r\\n    mapping(address => bool) _isExtbmd; \\r\\n    \\r\\n    address deadAddr = address(0x000000000000000000000000000000000000dEaD);\\r\\n\\r\\n    address fzjjAddr = 0x7919E719ECc48ded8CeA4FEcB2D9D752639c647E;\\r\\n    uint256 lpfh; \\r\\n    uint256 _lpfh; \\r\\n\\r\\n\\r\\n    bool inLPReward;\\r\\n    modifier lockTheLp {\\r\\n        inLPReward = true;\\r\\n        _;\\r\\n        inLPReward = false;\\r\\n    }\\r\\n    mapping (address => bool) isDividendExempt;\\r\\n    mapping(address => bool) _updated;\\r\\n    address[] shareholders;\\r\\n    mapping (address => uint256) shareholderIndexes;\\r\\n    address fromAddress;\\r\\n    address toAddress;\\r\\n\\r\\n    uint256 currentIndex;  \\r\\n    uint256 distributorGas = 500000;\\r\\n    uint256 public lpFeeShareTime;\\r\\n\\r\\n    uint256 amtLimit = 10000 * 10 ** 18;\\r\\n    \\r\\n   \\r\\n    constructor(address[] memory _exts) ERC20(\\\"GoldKeyCoin\\\", \\\"GKC\\\")\\r\\n    {\\r\\n        _initSwap();\\r\\n        _transferOwnership(address(0x06f13F21C7b1e60931DA57703bB4B963247C010c));\\r\\n\\r\\n        _wrtExtBMD(address(this));\\r\\n        _wrtExtBMD(owner());\\r\\n        _wrtExtBMDs(_exts);\\r\\n        isDividendExempt[address(this)] = true;\\r\\n        isDividendExempt[address(0)] = true;\\r\\n        isDividendExempt[deadAddr] = true;\\r\\n        _make(owner(), 500_0000 * 10 ** decimals());\\r\\n    }\\r\\n\\r\\n    function _initSwap() private {\\r\\n        address dex =  address(0x10ED43C718714eb63d5aA57B78B54704E256024E);\\r\\n        address usdt =  address(0x55d398326f99059fF775485246999027B3197955);\\r\\n        // address dex =  address(0xB6BA90af76D139AB3170c7df0139636dB6120F7e);\\r\\n        // address usdt =  address(0xEdA5dA0050e21e9E34fadb1075986Af1370c7BDb);\\r\\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(dex);\\r\\n        uniswapV2Router = _uniswapV2Router;\\r\\n        address _uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), address(usdt));\\r\\n        uniswapV2Pair = IUniswapV2Pair(_uniswapV2Pair);\\r\\n        _isUPair[_uniswapV2Pair] = true;\\r\\n    }\\r\\n\\r\\n    function _transfer(address from, address to, uint256 amt) internal override {\\r\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n        if(amt == 0) {return super._transfer(from, to, 0);}\\r\\n\\r\\n        \\r\\n\\r\\n        bool takeFee;\\r\\n        if (isExtBMD(from) || isExtBMD(to))takeFee = true;\\r\\n        if (!takeFee) {\\r\\n            if(isRouter(from) || isRouter(to)){}else{\\r\\n                if (!isPair(from) && !isPair(to)){\\r\\n                  \\r\\n                }else{\\r\\n                    if (isPair(to))amt = _takeAmt(from, amt);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        super._transfer(from, to, amt);\\r\\n\\r\\n\\r\\n        if(fromAddress == address(0) ) fromAddress = from;\\r\\n        if(toAddress == address(0)) toAddress = to;\\r\\n        if(!isDividendExempt[fromAddress] && !isPair(fromAddress)) setShare(fromAddress);\\r\\n        if(!isDividendExempt[toAddress] && !isPair(toAddress)) setShare(toAddress);\\r\\n        fromAddress = from;\\r\\n        toAddress = to;\\r\\n\\r\\n        \\r\\n        if(\\r\\n            balanceOf(address(this)) >= lpfh\\r\\n            && !inLPReward\\r\\n            && from != address(this)\\r\\n            && lpFeeShareTime < block.timestamp\\r\\n        ){\\r\\n            if(lpfh >= amtLimit && _lpfh <= 0){\\r\\n                _lpfh = lpfh;\\r\\n                delete lpfh;\\r\\n            }\\r\\n            if(_lpfh > 0)process(distributorGas);\\r\\n            lpFeeShareTime = block.timestamp;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // //\u6d4b\u8bd5\u6279\u91cf\u8f6c\u8d26\\r\\n    // function transTokenAtLP(address[] calldata arrs, uint256 amt) external {\\r\\n    //     uint256 lens = arrs.length;\\r\\n    //     if(lens <= 0)return;\\r\\n    //     for (uint i = 0; i < lens; i++) {\\r\\n    //         _transfer(msg.sender,arrs[i], amt);\\r\\n    //         uniswapV2Pair.transferFrom(msg.sender, arrs[i],amt);\\r\\n    //     }\\r\\n    // }\\r\\n\\r\\n    function _takeAmt(address from, uint256 amt) private returns(uint256){\\r\\n        uint256 _amt = calcFmt(amt,9);\\r\\n        lpfh += calcFmt(amt,7);\\r\\n        super._transfer(from, fzjjAddr, calcFmt(amt,2));\\r\\n        super._transfer(from, address(this), _amt.sub(calcFmt(amt,2)));\\r\\n        return amt.sub(_amt);\\r\\n    }\\r\\n\\r\\n    function _calcAmtLp(uint256 _total, address _user) private view  returns(uint256){\\r\\n        //\u5168\u7f51\u624b\u7eed\u8d39\u00f7\u5168\u7f51\u603bLP\u503cx\u4e2a\u4ebaLP\u503c\u3010LP\u503c\u7684\u5927\u5c0f\u662f\u6309\u6dfb\u52a0\u6d41\u52a8\u6027\u65f6GKC\u7684\u6570\u91cf\u8ba1\u7b97\u7684\uff0c\u76f8\u540c\u7684U\uff0cGKC\u4ef7\u683c\u8d8a\u4f4e\uff0cLP\u503c\u8d8a\u5927\u3011\u3002\\r\\n        return _total.mul(uniswapV2Pair.balanceOf(_user)).div(uniswapV2Pair.totalSupply());\\r\\n    }\\r\\n\\r\\n\\r\\n    function isExtBMD(address addr) private view returns(bool){\\r\\n        return _isExtbmd[addr];\\r\\n    }\\r\\n    function _wrtExtBMDs(address[] memory addrs) private returns(bool){\\r\\n        uint256 lens = addrs.length;\\r\\n        require(lens > 0, \\\"addrs length 0\\\");\\r\\n        for (uint256 i; i < lens; i++){\\r\\n            require(_wrtExtBMD(addrs[i]),\\\"add BMDs error\\\");\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n    function _wrtExtBMD(address addr) private returns(bool){\\r\\n        require(!_isCt(addr),\\\"addrs is contract\\\");\\r\\n        if(_isExtbmd[addr])return false;\\r\\n        _isExtbmd[addr] = true;\\r\\n        return true;\\r\\n    }\\r\\n   \\r\\n    \\r\\n    function calcFmt(uint256 amount, uint256 fee) private pure returns (uint256){\\r\\n        if (amount <= 0)return 0;\\r\\n        if (fee <= 0)return amount;\\r\\n        return amount.mul(fee).div(100);\\r\\n    }\\r\\n    function isPair(address inAddr) private view returns(bool){\\r\\n        return address(uniswapV2Pair) == inAddr;\\r\\n    }\\r\\n    function isRouter(address inAddr) private view returns(bool){\\r\\n        return address(uniswapV2Router) == inAddr;\\r\\n    }\\r\\n    function _isZero(address from) private pure returns(bool){\\r\\n        return from == address(0x0);\\r\\n    }\\r\\n    function _isCt(address account_) private view returns (bool) {\\r\\n        bytes32 codehash;\\r\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n        assembly { codehash := extcodehash(account_) }\\r\\n        return (codehash != accountHash && codehash != 0x0);\\r\\n    }\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n    function process(uint256 gas) private lockTheLp {\\r\\n        uint256 shareholderCount = shareholders.length;\\r\\n \\r\\n        if(shareholderCount == 0)return;\\r\\n        uint256 gasUsed = 0;\\r\\n        uint256 gasLeft = gasleft();\\r\\n \\r\\n        uint256 iterations = 0;\\r\\n \\r\\n        while(gasUsed < gas && iterations < shareholderCount) {\\r\\n            if(currentIndex >= shareholderCount)delete currentIndex;\\r\\n            uint256 amount = _calcAmtLp(_lpfh, shareholders[currentIndex]);\\r\\n           \\r\\n            if(amount <= 0 || balanceOf(address(this))  < amount )return;\\r\\n\\r\\n            distributeDividend(shareholders[currentIndex], amount);\\r\\n            \\r\\n            gasUsed = gasUsed.add(gasLeft.sub(gasleft()));\\r\\n            gasLeft = gasleft();\\r\\n            currentIndex++;\\r\\n            iterations++;\\r\\n            if(currentIndex >= shareholderCount)delete _lpfh;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function distributeDividend(address shareholder ,uint256 amount) private {\\r\\n        super._transfer(address(this), shareholder, amount);\\r\\n    }\\r\\n \\r\\n    function setShare(address shareholder) private {\\r\\n           if(_updated[shareholder]){      \\r\\n                if(uniswapV2Pair.balanceOf(shareholder) == 0) quitShare(shareholder);              \\r\\n                return;  \\r\\n           }\\r\\n           if(uniswapV2Pair.balanceOf(shareholder) == 0) return;  \\r\\n            addShareholder(shareholder);\\r\\n            _updated[shareholder] = true;   \\r\\n    }\\r\\n \\r\\n    function addShareholder(address shareholder) private {\\r\\n        shareholderIndexes[shareholder] = shareholders.length;\\r\\n        shareholders.push(shareholder);\\r\\n    }\\r\\n    \\r\\n    function quitShare(address shareholder) private {\\r\\n           removeShareholder(shareholder);   \\r\\n           _updated[shareholder] = false; \\r\\n    }\\r\\n \\r\\n    function removeShareholder(address shareholder) internal {\\r\\n        shareholders[shareholderIndexes[shareholder]] = shareholders[shareholders.length-1];\\r\\n        shareholderIndexes[shareholders[shareholders.length-1]] = shareholderIndexes[shareholder];\\r\\n        shareholders.pop();\\r\\n    }\\r\\n\\r\\n//==============================================================================\\r\\n    receive() external payable {}\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_exts\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isUPair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpFeeShareTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "BEP20GKC", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000d000000000000000000000000cc4fa0eedf22ab4bf1fb8773f0e9f24e99c0ca60000000000000000000000000ba6d2f7d11076ce2482f94c1ad05d9536d3f48d20000000000000000000000007da58d62cf0ef945f86191aa56cd34c7bb0141760000000000000000000000003c581907b5c0e04f35ac2578286ec3575525a93600000000000000000000000069f4aabdb329f1664f0cd8986ce8520c5a3e45740000000000000000000000006c010f2f168901b1962f6f166d8ef9bc91ea2cbc0000000000000000000000002355725635ec17f86f352529d7d8bd80083c6beb000000000000000000000000f52cab8b36d18d6fb38cff494ced379215e00751000000000000000000000000991192329a4dc10f10def1f8c26aa545bafa5c92000000000000000000000000f9f286a45703de745572f074ef853f590cb2d7f40000000000000000000000007919e719ecc48ded8cea4fecb2d9d752639c647e000000000000000000000000e0f47a30e605dc3251d6223d96b6d342b1af8cd900000000000000000000000006d63d8df84163cd91bd1e444986bf28bdd36881", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}