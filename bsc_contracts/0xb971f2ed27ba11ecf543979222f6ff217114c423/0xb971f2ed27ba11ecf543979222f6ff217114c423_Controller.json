{"SourceCode": "// File @openzeppelin/contracts/access/IAccessControl.sol@v4.9.0\r\n\r\n// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev External interface of AccessControl declared to support ERC165 detection.\r\n */\r\ninterface IAccessControl {\r\n    /**\r\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\r\n     *\r\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\r\n     * {RoleAdminChanged} not being emitted signaling this.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    event RoleAdminChanged(\r\n        bytes32 indexed role,\r\n        bytes32 indexed previousAdminRole,\r\n        bytes32 indexed newAdminRole\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when `account` is granted `role`.\r\n     *\r\n     * `sender` is the account that originated the contract call, an admin role\r\n     * bearer except when using {AccessControl-_setupRole}.\r\n     */\r\n    event RoleGranted(\r\n        bytes32 indexed role,\r\n        address indexed account,\r\n        address indexed sender\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when `account` is revoked `role`.\r\n     *\r\n     * `sender` is the account that originated the contract call:\r\n     *   - if using `revokeRole`, it is the admin role bearer\r\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\r\n     */\r\n    event RoleRevoked(\r\n        bytes32 indexed role,\r\n        address indexed account,\r\n        address indexed sender\r\n    );\r\n\r\n    /**\r\n     * @dev Returns `true` if `account` has been granted `role`.\r\n     */\r\n    function hasRole(\r\n        bytes32 role,\r\n        address account\r\n    ) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\r\n     * {revokeRole}.\r\n     *\r\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\r\n     */\r\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\r\n\r\n    /**\r\n     * @dev Grants `role` to `account`.\r\n     *\r\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     */\r\n    function grantRole(bytes32 role, address account) external;\r\n\r\n    /**\r\n     * @dev Revokes `role` from `account`.\r\n     *\r\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     */\r\n    function revokeRole(bytes32 role, address account) external;\r\n\r\n    /**\r\n     * @dev Revokes `role` from the calling account.\r\n     *\r\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\r\n     * purpose is to provide a mechanism for accounts to lose their privileges\r\n     * if they are compromised (such as when a trusted device is misplaced).\r\n     *\r\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be `account`.\r\n     */\r\n    function renounceRole(bytes32 role, address account) external;\r\n}\r\n\r\n// File @openzeppelin/contracts/utils/Context.sol@v4.9.0\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File @openzeppelin/contracts/utils/introspection/IERC165.sol@v4.9.0\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File @openzeppelin/contracts/utils/introspection/ERC165.sol@v4.9.0\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(\r\n        bytes4 interfaceId\r\n    ) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n// File @openzeppelin/contracts/utils/math/Math.sol@v4.9.0\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    enum Rounding {\r\n        Down, // Toward negative infinity\r\n        Up, // Toward infinity\r\n        Zero // Toward zero\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow.\r\n        return (a & b) + (a ^ b) / 2;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the ceiling of the division of two numbers.\r\n     *\r\n     * This differs from standard division with `/` in that it rounds up instead\r\n     * of rounding down.\r\n     */\r\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b - 1) / b can overflow on addition, so we distribute.\r\n        return a == 0 ? 0 : (a - 1) / b + 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\r\n     * with further edits by Uniswap Labs also under MIT license.\r\n     */\r\n    function mulDiv(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\r\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\r\n            // variables such that product = prod1 * 2^256 + prod0.\r\n            uint256 prod0; // Least significant 256 bits of the product\r\n            uint256 prod1; // Most significant 256 bits of the product\r\n            assembly {\r\n                let mm := mulmod(x, y, not(0))\r\n                prod0 := mul(x, y)\r\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n            }\r\n\r\n            // Handle non-overflow cases, 256 by 256 division.\r\n            if (prod1 == 0) {\r\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\r\n                // The surrounding unchecked block does not change this fact.\r\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\r\n                return prod0 / denominator;\r\n            }\r\n\r\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\r\n            require(denominator > prod1, \"Math: mulDiv overflow\");\r\n\r\n            ///////////////////////////////////////////////\r\n            // 512 by 256 division.\r\n            ///////////////////////////////////////////////\r\n\r\n            // Make division exact by subtracting the remainder from [prod1 prod0].\r\n            uint256 remainder;\r\n            assembly {\r\n                // Compute remainder using mulmod.\r\n                remainder := mulmod(x, y, denominator)\r\n\r\n                // Subtract 256 bit number from 512 bit number.\r\n                prod1 := sub(prod1, gt(remainder, prod0))\r\n                prod0 := sub(prod0, remainder)\r\n            }\r\n\r\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\r\n            // See https://cs.stackexchange.com/q/138556/92363.\r\n\r\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\r\n            uint256 twos = denominator & (~denominator + 1);\r\n            assembly {\r\n                // Divide denominator by twos.\r\n                denominator := div(denominator, twos)\r\n\r\n                // Divide [prod1 prod0] by twos.\r\n                prod0 := div(prod0, twos)\r\n\r\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\r\n                twos := add(div(sub(0, twos), twos), 1)\r\n            }\r\n\r\n            // Shift in bits from prod1 into prod0.\r\n            prod0 |= prod1 * twos;\r\n\r\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\r\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\r\n            // four bits. That is, denominator * inv = 1 mod 2^4.\r\n            uint256 inverse = (3 * denominator) ^ 2;\r\n\r\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\r\n            // in modular arithmetic, doubling the correct bits in each step.\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\r\n\r\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\r\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\r\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\r\n            // is no longer required.\r\n            result = prod0 * inverse;\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\r\n     */\r\n    function mulDiv(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 denominator,\r\n        Rounding rounding\r\n    ) internal pure returns (uint256) {\r\n        uint256 result = mulDiv(x, y, denominator);\r\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\r\n            result += 1;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\r\n     *\r\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\r\n     */\r\n    function sqrt(uint256 a) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\r\n        //\r\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\r\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\r\n        //\r\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\r\n        // ??`sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\r\n        // ??`2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\r\n        //\r\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\r\n        uint256 result = 1 << (log2(a) >> 1);\r\n\r\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\r\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\r\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\r\n        // into the expected uint128 result.\r\n        unchecked {\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            return min(result, a / result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates sqrt(a), following the selected rounding direction.\r\n     */\r\n    function sqrt(\r\n        uint256 a,\r\n        Rounding rounding\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = sqrt(a);\r\n            return\r\n                result +\r\n                (rounding == Rounding.Up && result * result < a ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 128;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 64;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 32;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 16;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                value >>= 8;\r\n                result += 8;\r\n            }\r\n            if (value >> 4 > 0) {\r\n                value >>= 4;\r\n                result += 4;\r\n            }\r\n            if (value >> 2 > 0) {\r\n                value >>= 2;\r\n                result += 2;\r\n            }\r\n            if (value >> 1 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(\r\n        uint256 value,\r\n        Rounding rounding\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log2(value);\r\n            return\r\n                result +\r\n                (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >= 10 ** 64) {\r\n                value /= 10 ** 64;\r\n                result += 64;\r\n            }\r\n            if (value >= 10 ** 32) {\r\n                value /= 10 ** 32;\r\n                result += 32;\r\n            }\r\n            if (value >= 10 ** 16) {\r\n                value /= 10 ** 16;\r\n                result += 16;\r\n            }\r\n            if (value >= 10 ** 8) {\r\n                value /= 10 ** 8;\r\n                result += 8;\r\n            }\r\n            if (value >= 10 ** 4) {\r\n                value /= 10 ** 4;\r\n                result += 4;\r\n            }\r\n            if (value >= 10 ** 2) {\r\n                value /= 10 ** 2;\r\n                result += 2;\r\n            }\r\n            if (value >= 10 ** 1) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(\r\n        uint256 value,\r\n        Rounding rounding\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log10(value);\r\n            return\r\n                result +\r\n                (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     *\r\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\r\n     */\r\n    function log256(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 16;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 8;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 4;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 2;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log256(\r\n        uint256 value,\r\n        Rounding rounding\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log256(value);\r\n            return\r\n                result +\r\n                (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\r\n        }\r\n    }\r\n}\r\n\r\n// File @openzeppelin/contracts/utils/math/SignedMath.sol@v4.9.0\r\n\r\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\r\n\r\n/**\r\n * @dev Standard signed math utilities missing in the Solidity language.\r\n */\r\nlibrary SignedMath {\r\n    /**\r\n     * @dev Returns the largest of two signed numbers.\r\n     */\r\n    function max(int256 a, int256 b) internal pure returns (int256) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two signed numbers.\r\n     */\r\n    function min(int256 a, int256 b) internal pure returns (int256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two signed numbers without overflow.\r\n     * The result is rounded towards zero.\r\n     */\r\n    function average(int256 a, int256 b) internal pure returns (int256) {\r\n        // Formula from the book \"Hacker's Delight\"\r\n        int256 x = (a & b) + ((a ^ b) >> 1);\r\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the absolute unsigned value of a signed value.\r\n     */\r\n    function abs(int256 n) internal pure returns (uint256) {\r\n        unchecked {\r\n            // must be unchecked in order to support `n = type(int256).min`\r\n            return uint256(n >= 0 ? n : -n);\r\n        }\r\n    }\r\n}\r\n\r\n// File @openzeppelin/contracts/utils/Strings.sol@v4.9.0\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\r\n    uint8 private constant _ADDRESS_LENGTH = 20;\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        unchecked {\r\n            uint256 length = Math.log10(value) + 1;\r\n            string memory buffer = new string(length);\r\n            uint256 ptr;\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                ptr := add(buffer, add(32, length))\r\n            }\r\n            while (true) {\r\n                ptr--;\r\n                /// @solidity memory-safe-assembly\r\n                assembly {\r\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\r\n                }\r\n                value /= 10;\r\n                if (value == 0) break;\r\n            }\r\n            return buffer;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(int256 value) internal pure returns (string memory) {\r\n        return\r\n            string(\r\n                abi.encodePacked(\r\n                    value < 0 ? \"-\" : \"\",\r\n                    toString(SignedMath.abs(value))\r\n                )\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        unchecked {\r\n            return toHexString(value, Math.log256(value) + 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(\r\n        uint256 value,\r\n        uint256 length\r\n    ) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(address addr) internal pure returns (string memory) {\r\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the two strings are equal.\r\n     */\r\n    function equal(\r\n        string memory a,\r\n        string memory b\r\n    ) internal pure returns (bool) {\r\n        return keccak256(bytes(a)) == keccak256(bytes(b));\r\n    }\r\n}\r\n\r\n// File @openzeppelin/contracts/access/AccessControl.sol@v4.9.0\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\r\n\r\n/**\r\n * @dev Contract module that allows children to implement role-based access\r\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\r\n * members except through off-chain means by accessing the contract event logs. Some\r\n * applications may benefit from on-chain enumerability, for those cases see\r\n * {AccessControlEnumerable}.\r\n *\r\n * Roles are referred to by their `bytes32` identifier. These should be exposed\r\n * in the external API and be unique. The best way to achieve this is by\r\n * using `public constant` hash digests:\r\n *\r\n * ```solidity\r\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\r\n * ```\r\n *\r\n * Roles can be used to represent a set of permissions. To restrict access to a\r\n * function call, use {hasRole}:\r\n *\r\n * ```solidity\r\n * function foo() public {\r\n *     require(hasRole(MY_ROLE, msg.sender));\r\n *     ...\r\n * }\r\n * ```\r\n *\r\n * Roles can be granted and revoked dynamically via the {grantRole} and\r\n * {revokeRole} functions. Each role has an associated admin role, and only\r\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\r\n *\r\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\r\n * that only accounts with this role will be able to grant or revoke other\r\n * roles. More complex role relationships can be created by using\r\n * {_setRoleAdmin}.\r\n *\r\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\r\n * grant and revoke this role. Extra precautions should be taken to secure\r\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\r\n * to enforce additional security measures for this role.\r\n */\r\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\r\n    struct RoleData {\r\n        mapping(address => bool) members;\r\n        bytes32 adminRole;\r\n    }\r\n\r\n    mapping(bytes32 => RoleData) private _roles;\r\n\r\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\r\n\r\n    /**\r\n     * @dev Modifier that checks that an account has a specific role. Reverts\r\n     * with a standardized message including the required role.\r\n     *\r\n     * The format of the revert reason is given by the following regular expression:\r\n     *\r\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\r\n     *\r\n     * _Available since v4.1._\r\n     */\r\n    modifier onlyRole(bytes32 role) {\r\n        _checkRole(role);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(\r\n        bytes4 interfaceId\r\n    ) public view virtual override returns (bool) {\r\n        return\r\n            interfaceId == type(IAccessControl).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns `true` if `account` has been granted `role`.\r\n     */\r\n    function hasRole(\r\n        bytes32 role,\r\n        address account\r\n    ) public view virtual override returns (bool) {\r\n        return _roles[role].members[account];\r\n    }\r\n\r\n    /**\r\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\r\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\r\n     *\r\n     * Format of the revert message is described in {_checkRole}.\r\n     *\r\n     * _Available since v4.6._\r\n     */\r\n    function _checkRole(bytes32 role) internal view virtual {\r\n        _checkRole(role, _msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Revert with a standard message if `account` is missing `role`.\r\n     *\r\n     * The format of the revert reason is given by the following regular expression:\r\n     *\r\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\r\n     */\r\n    function _checkRole(bytes32 role, address account) internal view virtual {\r\n        if (!hasRole(role, account)) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        \"AccessControl: account \",\r\n                        Strings.toHexString(account),\r\n                        \" is missing role \",\r\n                        Strings.toHexString(uint256(role), 32)\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\r\n     * {revokeRole}.\r\n     *\r\n     * To change a role's admin, use {_setRoleAdmin}.\r\n     */\r\n    function getRoleAdmin(\r\n        bytes32 role\r\n    ) public view virtual override returns (bytes32) {\r\n        return _roles[role].adminRole;\r\n    }\r\n\r\n    /**\r\n     * @dev Grants `role` to `account`.\r\n     *\r\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     *\r\n     * May emit a {RoleGranted} event.\r\n     */\r\n    function grantRole(\r\n        bytes32 role,\r\n        address account\r\n    ) public virtual override onlyRole(getRoleAdmin(role)) {\r\n        _grantRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Revokes `role` from `account`.\r\n     *\r\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     *\r\n     * May emit a {RoleRevoked} event.\r\n     */\r\n    function revokeRole(\r\n        bytes32 role,\r\n        address account\r\n    ) public virtual override onlyRole(getRoleAdmin(role)) {\r\n        _revokeRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Revokes `role` from the calling account.\r\n     *\r\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\r\n     * purpose is to provide a mechanism for accounts to lose their privileges\r\n     * if they are compromised (such as when a trusted device is misplaced).\r\n     *\r\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be `account`.\r\n     *\r\n     * May emit a {RoleRevoked} event.\r\n     */\r\n    function renounceRole(\r\n        bytes32 role,\r\n        address account\r\n    ) public virtual override {\r\n        require(\r\n            account == _msgSender(),\r\n            \"AccessControl: can only renounce roles for self\"\r\n        );\r\n\r\n        _revokeRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Grants `role` to `account`.\r\n     *\r\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n     * event. Note that unlike {grantRole}, this function doesn't perform any\r\n     * checks on the calling account.\r\n     *\r\n     * May emit a {RoleGranted} event.\r\n     *\r\n     * [WARNING]\r\n     * ====\r\n     * This function should only be called from the constructor when setting\r\n     * up the initial roles for the system.\r\n     *\r\n     * Using this function in any other way is effectively circumventing the admin\r\n     * system imposed by {AccessControl}.\r\n     * ====\r\n     *\r\n     * NOTE: This function is deprecated in favor of {_grantRole}.\r\n     */\r\n    function _setupRole(bytes32 role, address account) internal virtual {\r\n        _grantRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `adminRole` as ``role``'s admin role.\r\n     *\r\n     * Emits a {RoleAdminChanged} event.\r\n     */\r\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\r\n        bytes32 previousAdminRole = getRoleAdmin(role);\r\n        _roles[role].adminRole = adminRole;\r\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\r\n    }\r\n\r\n    /**\r\n     * @dev Grants `role` to `account`.\r\n     *\r\n     * Internal function without access restriction.\r\n     *\r\n     * May emit a {RoleGranted} event.\r\n     */\r\n    function _grantRole(bytes32 role, address account) internal virtual {\r\n        if (!hasRole(role, account)) {\r\n            _roles[role].members[account] = true;\r\n            emit RoleGranted(role, account, _msgSender());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Revokes `role` from `account`.\r\n     *\r\n     * Internal function without access restriction.\r\n     *\r\n     * May emit a {RoleRevoked} event.\r\n     */\r\n    function _revokeRole(bytes32 role, address account) internal virtual {\r\n        if (hasRole(role, account)) {\r\n            _roles[role].members[account] = false;\r\n            emit RoleRevoked(role, account, _msgSender());\r\n        }\r\n    }\r\n}\r\n\r\n// File @openzeppelin/contracts/utils/math/SafeMath.sol@v4.9.0\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\r\n\r\n// CAUTION\r\n// This version of SafeMath should only be used with Solidity 0.8 or later,\r\n// because it relies on the compiler's built in overflow checks.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(\r\n        uint256 a,\r\n        uint256 b\r\n    ) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(\r\n        uint256 a,\r\n        uint256 b\r\n    ) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(\r\n        uint256 a,\r\n        uint256 b\r\n    ) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(\r\n        uint256 a,\r\n        uint256 b\r\n    ) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(\r\n        uint256 a,\r\n        uint256 b\r\n    ) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\n// File contracts/interfaces/IControllerEvent.sol\r\n\r\ninterface IControllerEvent {\r\n    event SetTransactionDeadlineDuration(\r\n        address indexed strategyContract,\r\n        address indexed executorAddress,\r\n        uint256 transactionDeadlineDuration\r\n    );\r\n\r\n    event SetTickSpreadUpper(\r\n        address indexed strategyContract,\r\n        address indexed executorAddress,\r\n        int24 tickSpreadUpper\r\n    );\r\n\r\n    event SetTickSpreadLower(\r\n        address indexed strategyContract,\r\n        address indexed executorAddress,\r\n        int24 tickSpreadLower\r\n    );\r\n\r\n    event SetBuyBackToken(\r\n        address indexed strategyContract,\r\n        address indexed executorAddress,\r\n        address buyBackToken\r\n    );\r\n\r\n    event SetBuyBackNumerator(\r\n        address indexed strategyContract,\r\n        address indexed executorAddress,\r\n        uint24 buyBackNumerator\r\n    );\r\n\r\n    event SetFundManagerVaultByIndex(\r\n        address indexed strategyContract,\r\n        address indexed executorAddress,\r\n        uint256 index,\r\n        address fundManagerVaultAddress,\r\n        uint24 fundManagerProfitVaultNumerator\r\n    );\r\n\r\n    event SetFundManagerByIndex(\r\n        address indexed fundManagerVaultAddress,\r\n        address indexed executorAddress,\r\n        uint256 index,\r\n        address fundManagerAddress,\r\n        uint24 fundManagerProfitNumerator\r\n    );\r\n\r\n    event SetEarnLoopSegmentSize(\r\n        address indexed strategyContract,\r\n        address indexed executorAddress,\r\n        uint256 earnLoopSegmentSize\r\n    );\r\n\r\n    event SetStakeNext(\r\n        address indexed strategyContract,\r\n        address indexed executorAddress,\r\n        bool stakeNext\r\n    );\r\n\r\n    event CollectRewards(\r\n        address indexed strategyContract,\r\n        address indexed executorAddress,\r\n        uint256 indexed liquidityNftId,\r\n        uint256 rewardToken0Amount,\r\n        uint256 rewardToken1Amount,\r\n        uint256 rewardCakeAmount,\r\n        uint256 rewardUsdtAmount\r\n    );\r\n\r\n    event EarnPreparation(\r\n        address indexed strategyContract,\r\n        address indexed executorAddress,\r\n        uint256 indexed liquidityNftId,\r\n        uint256 rewardUsdtAmount,\r\n        uint256 remainingEarnCountDown\r\n    );\r\n\r\n    event Earn(\r\n        address indexed strategyContract,\r\n        address indexed executorAddress,\r\n        uint256 indexed liquidityNftId,\r\n        uint256 remainingEarnCountDown\r\n    );\r\n\r\n    event Allocate(\r\n        address indexed fundManagerVaultAddress,\r\n        address indexed executorAddress,\r\n        uint256 allocatedUsdtAmount,\r\n        uint256 remainingUsdtAmount\r\n    );\r\n\r\n    event Rescale(\r\n        address indexed strategyContract,\r\n        address indexed executorAddress,\r\n        uint256 dustToken0Amount,\r\n        uint256 dustToken1Amount\r\n    );\r\n\r\n    event DepositDustToken(\r\n        address indexed strategyContract,\r\n        address indexed executorAddress,\r\n        uint256 indexed liquidityNftId,\r\n        bool depositDustToken0,\r\n        uint256 increasedToken0Amount,\r\n        uint256 increasedToken1Amount,\r\n        uint256 dustToken0Amount,\r\n        uint256 dustToken1Amount\r\n    );\r\n}\r\n\r\n// File contracts/interfaces/IFundManagerVault.sol\r\n\r\ninterface IFundManagerVault {\r\n    struct FundManager {\r\n        address fundManagerAddress;\r\n        uint256 fundManagerProfitNumerator;\r\n    }\r\n\r\n    function getUsdtBalance() external view returns (uint256);\r\n\r\n    function getAllFundManagers() external view returns (FundManager[4] memory);\r\n\r\n    function setFundManagerByIndex(\r\n        uint256 index,\r\n        address fundManagerAddress,\r\n        uint24 fundManagerProfitNumerator\r\n    ) external;\r\n\r\n    function allocate() external;\r\n}\r\n\r\n// File contracts/interfaces/IStrategy.sol\r\n\r\ninterface IStrategy {\r\n    function depositLiquidity(\r\n        bool isBNB,\r\n        address userAddress,\r\n        address inputToken,\r\n        uint256 inputAmount,\r\n        uint256 swapInAmount,\r\n        uint256 minimumSwapOutAmount\r\n    )\r\n        external\r\n        payable\r\n        returns (\r\n            uint256 increasedToken0Amount,\r\n            uint256 increasedToken1Amount,\r\n            uint256 sendBackToken0Amount,\r\n            uint256 sendBackToken1Amount\r\n        );\r\n\r\n    function withdrawLiquidity(\r\n        address userAddress,\r\n        uint256 withdrawShares\r\n    )\r\n        external\r\n        returns (\r\n            uint256 userReceivedToken0Amount,\r\n            uint256 userReceivedToken1Amount\r\n        );\r\n\r\n    function collectRewards() external;\r\n\r\n    function earnPreparation(\r\n        uint256 minimumToken0SwapOutAmount,\r\n        uint256 minimumToken1SwapOutAmount,\r\n        uint256 minimumCakeSwapOutAmount,\r\n        uint256 minimumBuybackSwapOutAmount\r\n    ) external;\r\n\r\n    function earn() external;\r\n\r\n    function claimReward(address userAddress) external;\r\n\r\n    function rescale() external;\r\n\r\n    function depositDustToken(\r\n        bool depositDustToken0\r\n    )\r\n        external\r\n        returns (uint256 increasedToken0Amount, uint256 increasedToken1Amount);\r\n}\r\n\r\n// File contracts/interfaces/IStrategyInfo.sol\r\n\r\ninterface IStrategyInfo {\r\n    /// @dev Pancakeswap-Transaction-related Variable\r\n    function transactionDeadlineDuration() external view returns (uint256);\r\n\r\n    /// @dev get Liquidity-NFT-related Variable\r\n    function liquidityNftId() external view returns (uint256);\r\n\r\n    function tickSpreadUpper() external view returns (int24);\r\n\r\n    function tickSpreadLower() external view returns (int24);\r\n\r\n    function tickSpacing() external view returns (int24);\r\n\r\n    /// @dev get Pool-related Variable\r\n    function poolAddress() external view returns (address);\r\n\r\n    function poolFee() external view returns (uint24);\r\n\r\n    function token0Address() external view returns (address);\r\n\r\n    function token1Address() external view returns (address);\r\n\r\n    /// @dev get Tracker-Token-related Variable\r\n    function trackerTokenAddress() external view returns (address);\r\n\r\n    /// @dev get User-Management-related Variable\r\n    function isInUserList(address userAddress) external view returns (bool);\r\n\r\n    function userIndex(address userAddress) external view returns (uint256);\r\n\r\n    function getAllUsersInUserList() external view returns (address[] memory);\r\n\r\n    /// @dev get User-Share-Management-related Variable\r\n    function userShare(address userAddress) external view returns (uint256);\r\n\r\n    function totalUserShare() external view returns (uint256);\r\n\r\n    /// @dev get Reward-Management-related Variable\r\n    function rewardToken0Amount() external view returns (uint256);\r\n\r\n    function rewardToken1Amount() external view returns (uint256);\r\n\r\n    function rewardCakeAmount() external view returns (uint256);\r\n\r\n    function rewardUsdtAmount() external view returns (uint256);\r\n\r\n    /// @dev get User-Reward-Management-related Variable\r\n    function userUsdtReward(\r\n        address userAddress\r\n    ) external view returns (uint256);\r\n\r\n    function totalUserUsdtReward() external view returns (uint256);\r\n\r\n    /// @dev get Buyback-related Variable\r\n    function buyBackToken() external view returns (address);\r\n\r\n    function buyBackNumerator() external view returns (uint24);\r\n\r\n    function getUsdtToBuyBackTokenPath()\r\n        external\r\n        view\r\n        returns (address[] memory);\r\n\r\n    /// @dev get Fund-Manager-related Variable\r\n    struct FundManagerVault {\r\n        address fundManagerVaultAddress;\r\n        uint256 fundManagerProfitVaultNumerator;\r\n    }\r\n\r\n    function getAllFundManagerVaults()\r\n        external\r\n        view\r\n        returns (FundManagerVault[3] memory);\r\n\r\n    /// @dev get Earn-Loop-Control-related Variable\r\n    function earnLoopSegmentSize() external view returns (uint256);\r\n\r\n    function earnLoopDistributedAmount() external view returns (uint256);\r\n\r\n    function earnLoopStartIndex() external view returns (uint256);\r\n\r\n    function isEarning() external view returns (bool);\r\n\r\n    /// @dev get Rescale-related Variable\r\n    function dustToken0Amount() external view returns (uint256);\r\n\r\n    function dustToken1Amount() external view returns (uint256);\r\n\r\n    /// @dev get Stake-Control-related Variable\r\n    function stakeNext() external view returns (bool);\r\n\r\n    function isStaking() external view returns (bool);\r\n\r\n    /// @dev get Constant Variable\r\n    function getBuyBackDenominator() external pure returns (uint24);\r\n\r\n    function getFundManagerProfitVaultDenominator()\r\n        external\r\n        pure\r\n        returns (uint24);\r\n\r\n    function getFarmAddress() external pure returns (address);\r\n\r\n    function getControllerAddress() external pure returns (address);\r\n\r\n    function getSwapAmountCalculatorAddress() external pure returns (address);\r\n\r\n    function getZapAddress() external pure returns (address);\r\n}\r\n\r\n// File contracts/interfaces/IStrategySetter.sol\r\n\r\ninterface IStrategySetter {\r\n    function setTransactionDeadlineDuration(\r\n        uint256 _transactionDeadlineDuration\r\n    ) external;\r\n\r\n    function setTickSpreadUpper(int24 _tickSpreadUpper) external;\r\n\r\n    function setTickSpreadLower(int24 _tickSpreadLower) external;\r\n\r\n    function setBuyBackToken(address _buyBackToken) external;\r\n\r\n    function setBuyBackNumerator(uint24 _buyBackNumerator) external;\r\n\r\n    function setFundManagerVaultByIndex(\r\n        uint256 index,\r\n        address _fundManagerVaultAddress,\r\n        uint24 _fundManagerProfitVaultNumerator\r\n    ) external;\r\n\r\n    function setEarnLoopSegmentSize(uint256 _earnLoopSegmentSize) external;\r\n\r\n    function setStakeNext(bool _stakeNext) external;\r\n}\r\n\r\n// File contracts/libraries/constants/Constants.sol\r\n\r\nlibrary Constants {\r\n    /// @dev mainnet pancakeswap V3\r\n    address public constant PANCAKE_V3_FACTORY_ADDRESS =\r\n        address(0x0BFbCF9fa4f9C56B0F40a671Ad40E0805A091865);\r\n    address public constant MASTER_CHEF_V3_ADDRESS =\r\n        address(0x556B9306565093C855AEA9AE92A594704c2Cd59e);\r\n    address public constant NONFUNGIBLE_POSITION_MANAGER_ADDRESS =\r\n        address(0x46A15B0b27311cedF172AB29E4f4766fbE7F4364);\r\n    address public constant SMART_ROUTER_ADDRESS =\r\n        address(0x13f4EA83D0bd40E75C8222255bc855a974568Dd4);\r\n\r\n    /// @dev testnet pancakeswap V3\r\n    address public constant TESTNET_PANCAKE_V3_FACTORY_ADDRESS =\r\n        address(0x0BFbCF9fa4f9C56B0F40a671Ad40E0805A091865);\r\n    address public constant TESTNET_MASTER_CHEF_V3_ADDRESS =\r\n        address(0x4c650FB471fe4e0f476fD3437C3411B1122c4e3B);\r\n    address public constant TESTNET_NONFUNGIBLE_POSITION_MANAGER_ADDRESS =\r\n        address(0x427bF5b37357632377eCbEC9de3626C71A5396c1);\r\n    address public constant TESTNET_SMART_ROUTER_ADDRESS =\r\n        address(0x9a489505a00cE272eAa5e07Dba6491314CaE3796);\r\n\r\n    /// @dev mainnet token address\r\n    address public constant WBNB_ADDRESS =\r\n        address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\r\n    address public constant USDT_ADDRESS =\r\n        address(0x55d398326f99059fF775485246999027B3197955);\r\n    address public constant USDC_ADDRESS =\r\n        address(0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d);\r\n    address public constant BTCB_ADDRESS =\r\n        address(0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c);\r\n    address public constant BUSD_ADDRESS =\r\n        address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\r\n    address public constant CAKE_ADDRESS =\r\n        address(0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82);\r\n    address public constant ETH_ADDRESS =\r\n        address(0x2170Ed0880ac9A755fd29B2688956BD959F933F8);\r\n    address public constant XRP_ADDRESS =\r\n        address(0x1D2F0da169ceB9fC7B3144628dB156f3F6c60dBE);\r\n    address public constant ADA_ADDRESS =\r\n        address(0x3EE2200Efb3400fAbB9AacF31297cBdD1d435D47);\r\n    address public constant DOT_ADDRESS =\r\n        address(0x7083609fCE4d1d8Dc0C979AAb8c869Ea2C873402);\r\n    address public constant RXD_ADDRESS =\r\n        address(0x92cb26ca653a51bBf916E6c3d58599CDB12e3a9F);\r\n\r\n    /// @dev testnet token address\r\n    address public constant TESTNET_WBNB_ADDRESS =\r\n        address(0xae13d989daC2f0dEbFf460aC112a837C89BAa7cd);\r\n    address public constant TESTNET_USDT_ADDRESS =\r\n        address(0x0fB5D7c73FA349A90392f873a4FA1eCf6a3d0a96);\r\n    address public constant TESTNET_BUSD_ADDRESS =\r\n        address(0xaB1a4d4f1D656d2450692D237fdD6C7f9146e814);\r\n    address public constant TESTNET_CAKE_ADDRESS =\r\n        address(0x8d008B313C1d6C7fE2982F62d32Da7507cF43551);\r\n    address public constant TESTNET_RXD_ADDRESS =\r\n        address(0x3f83fCC8eFC9EBB56362222dD7844226870a12Ea);\r\n\r\n    /// @dev black hole address\r\n    address public constant BLACK_HOLE_ADDRESS =\r\n        address(0x000000000000000000000000000000000000dEaD);\r\n}\r\n\r\n// File contracts/interfaces/pancakeswapV3/INonfungiblePositionManager.sol\r\n\r\npragma abicoder v2;\r\n\r\ninterface INonfungiblePositionManager {\r\n    /// @notice Returns the position information associated with a given token ID.\r\n    /// @dev Throws if the token ID is not valid.\r\n    /// @param tokenId The ID of the token that represents the position\r\n    /// @return nonce The nonce for permits\r\n    /// @return operator The address that is approved for spending\r\n    /// @return token0 The address of the token0 for a specific pool\r\n    /// @return token1 The address of the token1 for a specific pool\r\n    /// @return fee The fee associated with the pool\r\n    /// @return tickLower The lower end of the tick range for the position\r\n    /// @return tickUpper The higher end of the tick range for the position\r\n    /// @return liquidity The liquidity of the position\r\n    /// @return feeGrowthInside0LastX128 The fee growth of token0 as of the last action on the individual position\r\n    /// @return feeGrowthInside1LastX128 The fee growth of token1 as of the last action on the individual position\r\n    /// @return tokensOwed0 The uncollected amount of token0 owed to the position as of the last computation\r\n    /// @return tokensOwed1 The uncollected amount of token1 owed to the position as of the last computation\r\n    function positions(\r\n        uint256 tokenId\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint96 nonce,\r\n            address operator,\r\n            address token0,\r\n            address token1,\r\n            uint24 fee,\r\n            int24 tickLower,\r\n            int24 tickUpper,\r\n            uint128 liquidity,\r\n            uint256 feeGrowthInside0LastX128,\r\n            uint256 feeGrowthInside1LastX128,\r\n            uint128 tokensOwed0,\r\n            uint128 tokensOwed1\r\n        );\r\n\r\n    struct MintParams {\r\n        address token0;\r\n        address token1;\r\n        uint24 fee;\r\n        int24 tickLower;\r\n        int24 tickUpper;\r\n        uint256 amount0Desired;\r\n        uint256 amount1Desired;\r\n        uint256 amount0Min;\r\n        uint256 amount1Min;\r\n        address recipient;\r\n        uint256 deadline;\r\n    }\r\n\r\n    /// @notice Creates a new position wrapped in a NFT\r\n    /// @dev Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized\r\n    /// a method does not exist, i.e. the pool is assumed to be initialized.\r\n    /// @param params The params necessary to mint a position, encoded as `MintParams` in calldata\r\n    /// @return tokenId The ID of the token that represents the minted position\r\n    /// @return liquidity The amount of liquidity for this position\r\n    /// @return amount0 The amount of token0\r\n    /// @return amount1 The amount of token1\r\n    function mint(\r\n        MintParams calldata params\r\n    )\r\n        external\r\n        payable\r\n        returns (\r\n            uint256 tokenId,\r\n            uint128 liquidity,\r\n            uint256 amount0,\r\n            uint256 amount1\r\n        );\r\n\r\n    struct IncreaseLiquidityParams {\r\n        uint256 tokenId;\r\n        uint256 amount0Desired;\r\n        uint256 amount1Desired;\r\n        uint256 amount0Min;\r\n        uint256 amount1Min;\r\n        uint256 deadline;\r\n    }\r\n\r\n    /// @notice Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`\r\n    /// @param params tokenId The ID of the token for which liquidity is being increased,\r\n    /// amount0Desired The desired amount of token0 to be spent,\r\n    /// amount1Desired The desired amount of token1 to be spent,\r\n    /// amount0Min The minimum amount of token0 to spend, which serves as a slippage check,\r\n    /// amount1Min The minimum amount of token1 to spend, which serves as a slippage check,\r\n    /// deadline The time by which the transaction must be included to effect the change\r\n    /// @return liquidity The new liquidity amount as a result of the increase\r\n    /// @return amount0 The amount of token0 to acheive resulting liquidity\r\n    /// @return amount1 The amount of token1 to acheive resulting liquidity\r\n    function increaseLiquidity(\r\n        IncreaseLiquidityParams calldata params\r\n    )\r\n        external\r\n        payable\r\n        returns (uint128 liquidity, uint256 amount0, uint256 amount1);\r\n\r\n    struct DecreaseLiquidityParams {\r\n        uint256 tokenId;\r\n        uint128 liquidity;\r\n        uint256 amount0Min;\r\n        uint256 amount1Min;\r\n        uint256 deadline;\r\n    }\r\n\r\n    /// @notice Decreases the amount of liquidity in a position and accounts it to the position\r\n    /// @param params tokenId The ID of the token for which liquidity is being decreased,\r\n    /// amount The amount by which liquidity will be decreased,\r\n    /// amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,\r\n    /// amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,\r\n    /// deadline The time by which the transaction must be included to effect the change\r\n    /// @return amount0 The amount of token0 accounted to the position's tokens owed\r\n    /// @return amount1 The amount of token1 accounted to the position's tokens owed\r\n    function decreaseLiquidity(\r\n        DecreaseLiquidityParams calldata params\r\n    ) external payable returns (uint256 amount0, uint256 amount1);\r\n\r\n    struct CollectParams {\r\n        uint256 tokenId;\r\n        address recipient;\r\n        uint128 amount0Max;\r\n        uint128 amount1Max;\r\n    }\r\n\r\n    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient\r\n    /// @param params tokenId The ID of the NFT for which tokens are being collected,\r\n    /// recipient The account that should receive the tokens,\r\n    /// amount0Max The maximum amount of token0 to collect,\r\n    /// amount1Max The maximum amount of token1 to collect\r\n    /// @return amount0 The amount of fees collected in token0\r\n    /// @return amount1 The amount of fees collected in token1\r\n    function collect(\r\n        CollectParams calldata params\r\n    ) external payable returns (uint256 amount0, uint256 amount1);\r\n\r\n    /// @notice Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens\r\n    /// must be collected first.\r\n    /// @param tokenId The ID of the token that is being burned\r\n    function burn(uint256 tokenId) external payable;\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /// @notice Refunds any ETH balance held by this contract to the `msg.sender`\r\n    /// @dev Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps\r\n    /// that use ether for the input amount. And in PancakeSwap Router, this would be called\r\n    /// at the very end of swap\r\n    function refundETH() external payable;\r\n}\r\n\r\n// File contracts/libraries/pancakeswapV3/TickMath.sol\r\n\r\n/// @title Math library for computing sqrt prices from ticks and vice versa\r\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\r\n/// prices between 2**-128 and 2**128\r\nlibrary TickMath {\r\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\r\n    int24 internal constant MIN_TICK = -887272;\r\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\r\n    int24 internal constant MAX_TICK = -MIN_TICK;\r\n\r\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\r\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\r\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\r\n    uint160 internal constant MAX_SQRT_RATIO =\r\n        1461446703485210103287273052203988822378723970342;\r\n\r\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\r\n    /// @dev Throws if |tick| > max tick\r\n    /// @param tick The input tick for the above formula\r\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\r\n    /// at the given tick\r\n    function getSqrtRatioAtTick(\r\n        int24 tick\r\n    ) internal pure returns (uint160 sqrtPriceX96) {\r\n        uint256 absTick = tick < 0\r\n            ? uint256(-int256(tick))\r\n            : uint256(int256(tick));\r\n        require(absTick <= uint256(int256(MAX_TICK)), \"T\");\r\n\r\n        uint256 ratio = absTick & 0x1 != 0\r\n            ? 0xfffcb933bd6fad37aa2d162d1a594001\r\n            : 0x100000000000000000000000000000000;\r\n        if (absTick & 0x2 != 0)\r\n            ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\r\n        if (absTick & 0x4 != 0)\r\n            ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\r\n        if (absTick & 0x8 != 0)\r\n            ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\r\n        if (absTick & 0x10 != 0)\r\n            ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\r\n        if (absTick & 0x20 != 0)\r\n            ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\r\n        if (absTick & 0x40 != 0)\r\n            ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\r\n        if (absTick & 0x80 != 0)\r\n            ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\r\n        if (absTick & 0x100 != 0)\r\n            ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\r\n        if (absTick & 0x200 != 0)\r\n            ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\r\n        if (absTick & 0x400 != 0)\r\n            ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\r\n        if (absTick & 0x800 != 0)\r\n            ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\r\n        if (absTick & 0x1000 != 0)\r\n            ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\r\n        if (absTick & 0x2000 != 0)\r\n            ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\r\n        if (absTick & 0x4000 != 0)\r\n            ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\r\n        if (absTick & 0x8000 != 0)\r\n            ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\r\n        if (absTick & 0x10000 != 0)\r\n            ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\r\n        if (absTick & 0x20000 != 0)\r\n            ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\r\n        if (absTick & 0x40000 != 0)\r\n            ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\r\n        if (absTick & 0x80000 != 0)\r\n            ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\r\n\r\n        if (tick > 0) ratio = type(uint256).max / ratio;\r\n\r\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\r\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\r\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\r\n        sqrtPriceX96 = uint160(\r\n            (ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1)\r\n        );\r\n    }\r\n}\r\n\r\n// File contracts/interfaces/external/IERC20Querier.sol\r\n\r\ninterface IERC20Querier {\r\n    function decimals() external view returns (uint256);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n}\r\n\r\n// File contracts/interfaces/pancakeswapV3/IPancakeV3Factory.sol\r\n\r\n/// @title The interface for the PancakeSwap V3 Factory\r\n/// @notice The PancakeSwap V3 Factory facilitates creation of PancakeSwap V3 pools and control over the protocol fees\r\ninterface IPancakeV3Factory {\r\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\r\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\r\n    /// @param tokenA The contract address of either token0 or token1\r\n    /// @param tokenB The contract address of the other token\r\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\r\n    /// @return pool The pool address\r\n    function getPool(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint24 fee\r\n    ) external view returns (address pool);\r\n}\r\n\r\n// File contracts/interfaces/pancakeswapV3/IPancakeV3Pool.sol\r\n\r\n/// @title The interface for a PancakeSwap V3 Pool\r\n/// @notice A PancakeSwap pool facilitates swapping and automated market making between any two assets that strictly conform\r\n/// to the ERC20 specification\r\n/// @dev The pool interface is broken up into many smaller pieces\r\ninterface IPancakeV3Pool {\r\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\r\n    /// when accessed externally.\r\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\r\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\r\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\r\n    /// boundary.\r\n    /// observationIndex The index of the last oracle observation that was written,\r\n    /// observationCardinality The current maximum number of observations stored in the pool,\r\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\r\n    /// feeProtocol The protocol fee for both tokens of the pool.\r\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\r\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\r\n    /// unlocked Whether the pool is currently locked to reentrancy\r\n    function slot0()\r\n        external\r\n        view\r\n        returns (\r\n            uint160 sqrtPriceX96,\r\n            int24 tick,\r\n            uint16 observationIndex,\r\n            uint16 observationCardinality,\r\n            uint16 observationCardinalityNext,\r\n            uint32 feeProtocol,\r\n            bool unlocked\r\n        );\r\n\r\n    /// @notice The first of the two tokens of the pool, sorted by address\r\n    /// @return The token contract address\r\n    function token0() external view returns (address);\r\n\r\n    /// @notice The second of the two tokens of the pool, sorted by address\r\n    /// @return The token contract address\r\n    function token1() external view returns (address);\r\n\r\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\r\n    /// @return The fee\r\n    function fee() external view returns (uint24);\r\n\r\n    /// @notice The pool tick spacing\r\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\r\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\r\n    /// This value is an int24 to avoid casting even though it is always positive.\r\n    /// @return The tick spacing\r\n    function tickSpacing() external view returns (int24);\r\n}\r\n\r\n// File contracts/libraries/PoolHelper.sol\r\n\r\nlibrary PoolHelper {\r\n    using SafeMath for uint256;\r\n\r\n    function getPoolAddress(\r\n        address pancakeswapV3FactoryAddress,\r\n        address tokenA,\r\n        address tokenB,\r\n        uint24 poolFee\r\n    ) internal view returns (address poolAddress) {\r\n        return\r\n            IPancakeV3Factory(pancakeswapV3FactoryAddress).getPool(\r\n                tokenA,\r\n                tokenB,\r\n                poolFee\r\n            );\r\n    }\r\n\r\n    function getPoolInfo(\r\n        address poolAddress\r\n    )\r\n        internal\r\n        view\r\n        returns (\r\n            address token0,\r\n            address token1,\r\n            uint24 poolFee,\r\n            int24 tick,\r\n            uint160 sqrtPriceX96,\r\n            uint256 decimal0,\r\n            uint256 decimal1\r\n        )\r\n    {\r\n        (sqrtPriceX96, tick, , , , , ) = IPancakeV3Pool(poolAddress).slot0();\r\n        token0 = IPancakeV3Pool(poolAddress).token0();\r\n        token1 = IPancakeV3Pool(poolAddress).token1();\r\n        poolFee = IPancakeV3Pool(poolAddress).fee();\r\n        decimal0 = IERC20Querier(token0).decimals();\r\n        decimal1 = IERC20Querier(token1).decimals();\r\n    }\r\n\r\n    /// @dev formula explanation\r\n    /*\r\n    [Original formula (without decimal precision)]\r\n    (token1 * (10^decimal1)) / (token0 * (10^decimal0)) = (sqrtPriceX96 / (2^96))^2   \r\n    tokenPrice = token1/token0 = (sqrtPriceX96 / (2^96))^2 * (10^decimal0) / (10^decimal1)\r\n\r\n    [Formula with decimal precision & decimal adjustment]\r\n    tokenPriceWithDecimalAdj = tokenPrice * (10^decimalPrecision)\r\n        = (sqrtPriceX96 * (10^decimalPrecision) / (2^96))^2 \r\n            / 10^(decimalPrecision + decimal1 - decimal0)\r\n    */\r\n    function getTokenPriceWithDecimalsByPool(\r\n        address poolAddress,\r\n        uint256 decimalPrecision\r\n    ) internal view returns (uint256 tokenPriceWithDecimals) {\r\n        (\r\n            ,\r\n            ,\r\n            ,\r\n            ,\r\n            uint160 sqrtPriceX96,\r\n            uint256 decimal0,\r\n            uint256 decimal1\r\n        ) = getPoolInfo(poolAddress);\r\n\r\n        // when decimalPrecision is 18,\r\n        // calculation restriction: 79228162514264337594 <= sqrtPriceX96 <= type(uint160).max\r\n        uint256 scaledPriceX96 = uint256(sqrtPriceX96)\r\n            .mul(10 ** decimalPrecision)\r\n            .div(2 ** 96);\r\n        uint256 tokenPriceWithoutDecimalAdj = scaledPriceX96.mul(\r\n            scaledPriceX96\r\n        );\r\n        uint256 decimalAdj = decimalPrecision.add(decimal1).sub(decimal0);\r\n        uint256 result = tokenPriceWithoutDecimalAdj.div(10 ** decimalAdj);\r\n        require(result > 0, \"token price too small\");\r\n        tokenPriceWithDecimals = result;\r\n    }\r\n\r\n    function getTokenDecimalAdjustment(\r\n        address token\r\n    ) internal view returns (uint256 decimalAdjustment) {\r\n        uint256 tokenDecimalStandard = 18;\r\n        uint256 decimal = IERC20Querier(token).decimals();\r\n        return tokenDecimalStandard.sub(decimal);\r\n    }\r\n}\r\n\r\n// File contracts/libraries/LiquidityNftHelper.sol\r\n\r\nlibrary LiquidityNftHelper {\r\n    using SafeMath for uint256;\r\n\r\n    function getLiquidityAmountByNftId(\r\n        uint256 liquidityNftId,\r\n        address nonfungiblePositionManagerAddress\r\n    ) internal view returns (uint128 liquidity) {\r\n        (, , , , , , , liquidity, , , , ) = INonfungiblePositionManager(\r\n            nonfungiblePositionManagerAddress\r\n        ).positions(liquidityNftId);\r\n    }\r\n\r\n    function getPoolInfoByLiquidityNft(\r\n        uint256 liquidityNftId,\r\n        address pancakeswapV3FactoryAddress,\r\n        address nonfungiblePositionManagerAddress\r\n    )\r\n        internal\r\n        view\r\n        returns (\r\n            address poolAddress,\r\n            int24 tick,\r\n            uint160 sqrtPriceX96,\r\n            uint256 decimal0,\r\n            uint256 decimal1\r\n        )\r\n    {\r\n        (\r\n            address token0,\r\n            address token1,\r\n            uint24 poolFee,\r\n            ,\r\n            ,\r\n            ,\r\n\r\n        ) = getLiquidityNftPositionsInfo(\r\n                liquidityNftId,\r\n                nonfungiblePositionManagerAddress\r\n            );\r\n        poolAddress = PoolHelper.getPoolAddress(\r\n            pancakeswapV3FactoryAddress,\r\n            token0,\r\n            token1,\r\n            poolFee\r\n        );\r\n        (, , , tick, sqrtPriceX96, decimal0, decimal1) = PoolHelper.getPoolInfo(\r\n            poolAddress\r\n        );\r\n    }\r\n\r\n    function getLiquidityNftPositionsInfo(\r\n        uint256 liquidityNftId,\r\n        address nonfungiblePositionManagerAddress\r\n    )\r\n        internal\r\n        view\r\n        returns (\r\n            address token0,\r\n            address token1,\r\n            uint24 poolFee,\r\n            int24 tickLower,\r\n            int24 tickUpper,\r\n            uint160 sqrtRatioAX96,\r\n            uint160 sqrtRatioBX96\r\n        )\r\n    {\r\n        (\r\n            ,\r\n            ,\r\n            token0,\r\n            token1,\r\n            poolFee,\r\n            tickLower,\r\n            tickUpper,\r\n            ,\r\n            ,\r\n            ,\r\n            ,\r\n\r\n        ) = INonfungiblePositionManager(nonfungiblePositionManagerAddress)\r\n            .positions(liquidityNftId);\r\n        sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(tickLower);\r\n        sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(tickUpper);\r\n    }\r\n\r\n    /// @dev formula explanation\r\n    /*\r\n    [Original formula (without decimal precision)]\r\n    tickUpper -> sqrtRatioBX96\r\n    tickLower -> sqrtRatioAX96\r\n    tick      -> sqrtPriceX96\r\n    (token1 * (10^decimal1)) / (token0 * (10^decimal0)) = \r\n        (sqrtPriceX96 * sqrtRatioBX96 * (sqrtPriceX96 - sqrtRatioAX96))\r\n            / ((2^192) * (sqrtRatioBX96 - sqrtPriceX96))\r\n    \r\n    [Formula with decimal precision & decimal adjustment]\r\n    liquidityRatioWithDecimalAdj = liquidityRatio * (10^decimalPrecision)\r\n        = (sqrtPriceX96 * (10^decimalPrecision) / (2^96))\r\n            * (sqrtPriceBX96 * (10^decimalPrecision) / (2^96))\r\n            * (sqrtPriceX96 - sqrtRatioAX96)\r\n            / ((sqrtRatioBX96 - sqrtPriceX96) * (10^(decimalPrecision + decimal1 - decimal0)))\r\n    */\r\n    function getInRangeLiquidityRatioWithDecimals(\r\n        uint256 liquidityNftId,\r\n        uint256 decimalPrecision,\r\n        address pancakeswapV3FactoryAddress,\r\n        address nonfungiblePositionManagerAddress\r\n    ) internal view returns (uint256 liquidityRatioWithDecimals) {\r\n        // get sqrtPrice of tickUpper, tick, tickLower\r\n        (\r\n            ,\r\n            ,\r\n            ,\r\n            ,\r\n            ,\r\n            uint160 sqrtRatioAX96,\r\n            uint160 sqrtRatioBX96\r\n        ) = getLiquidityNftPositionsInfo(\r\n                liquidityNftId,\r\n                nonfungiblePositionManagerAddress\r\n            );\r\n        (\r\n            ,\r\n            ,\r\n            uint160 sqrtPriceX96,\r\n            uint256 decimal0,\r\n            uint256 decimal1\r\n        ) = getPoolInfoByLiquidityNft(\r\n                liquidityNftId,\r\n                pancakeswapV3FactoryAddress,\r\n                nonfungiblePositionManagerAddress\r\n            );\r\n\r\n        // when decimalPrecision is 18,\r\n        // calculation restriction: 79228162514264337594 <= sqrtPriceX96 <= type(uint160).max\r\n        uint256 scaledPriceX96 = uint256(sqrtPriceX96)\r\n            .mul(10 ** decimalPrecision)\r\n            .div(2 ** 96);\r\n        uint256 scaledPriceBX96 = uint256(sqrtRatioBX96)\r\n            .mul(10 ** decimalPrecision)\r\n            .div(2 ** 96);\r\n\r\n        uint256 decimalAdj = decimalPrecision.add(decimal1).sub(decimal0);\r\n        uint256 preLiquidityRatioWithDecimals = scaledPriceX96\r\n            .mul(scaledPriceBX96)\r\n            .div(10 ** decimalAdj);\r\n\r\n        liquidityRatioWithDecimals = preLiquidityRatioWithDecimals\r\n            .mul(uint256(sqrtPriceX96).sub(sqrtRatioAX96))\r\n            .div(uint256(sqrtRatioBX96).sub(sqrtPriceX96));\r\n    }\r\n\r\n    function verifyInputTokenIsLiquidityNftTokenPair(\r\n        uint256 liquidityNftId,\r\n        address inputToken,\r\n        address nonfungiblePositionManagerAddress\r\n    ) internal view {\r\n        (\r\n            address token0,\r\n            address token1,\r\n            ,\r\n            ,\r\n            ,\r\n            ,\r\n\r\n        ) = getLiquidityNftPositionsInfo(\r\n                liquidityNftId,\r\n                nonfungiblePositionManagerAddress\r\n            );\r\n        require(\r\n            inputToken == token0 || inputToken == token1,\r\n            \"inputToken not in token pair\"\r\n        );\r\n    }\r\n\r\n    function verifyCurrentPriceInLiquidityNftRange(\r\n        uint256 liquidityNftId,\r\n        address pancakeswapV3FactoryAddress,\r\n        address nonfungiblePositionManagerAddress\r\n    ) internal view returns (bool isInRange, address liquidity0Token) {\r\n        (, int24 tick, , , ) = getPoolInfoByLiquidityNft(\r\n            liquidityNftId,\r\n            pancakeswapV3FactoryAddress,\r\n            nonfungiblePositionManagerAddress\r\n        );\r\n        (\r\n            address token0,\r\n            address token1,\r\n            ,\r\n            int24 tickLower,\r\n            int24 tickUpper,\r\n            ,\r\n\r\n        ) = getLiquidityNftPositionsInfo(\r\n                liquidityNftId,\r\n                nonfungiblePositionManagerAddress\r\n            );\r\n\r\n        // tick out of range, tick <= tickLower left token0\r\n        if (tick <= tickLower) {\r\n            return (false, token0);\r\n\r\n            // tick in range, tickLower < tick < tickUpper\r\n        } else if (tick < tickUpper) {\r\n            return (true, address(0));\r\n\r\n            // tick out of range, tick >= tickUpper left token1\r\n        } else {\r\n            return (false, token1);\r\n        }\r\n    }\r\n\r\n    function verifyCurrentPriceInLiquidityNftValidGapRange(\r\n        int24 tickSpacing,\r\n        uint256 liquidityNftId,\r\n        address pancakeswapV3FactoryAddress,\r\n        address nonfungiblePositionManagerAddress\r\n    ) internal view returns (bool isInValidGapRange) {\r\n        (int24 tick, int24 tickLower, int24 tickUpper) = getTickInfo(\r\n            liquidityNftId,\r\n            pancakeswapV3FactoryAddress,\r\n            nonfungiblePositionManagerAddress\r\n        );\r\n\r\n        // Current tick is within one tick spacing away from the current tick boundary\r\n        if (\r\n            tick <= (tickLower - tickSpacing) ||\r\n            tick >= (tickUpper + tickSpacing)\r\n        ) {\r\n            return false;\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function getTickInfo(\r\n        uint256 liquidityNftId,\r\n        address pancakeswapV3FactoryAddress,\r\n        address nonfungiblePositionManagerAddress\r\n    ) internal view returns (int24 tick, int24 tickLower, int24 tickUpper) {\r\n        (, tick, , , ) = getPoolInfoByLiquidityNft(\r\n            liquidityNftId,\r\n            pancakeswapV3FactoryAddress,\r\n            nonfungiblePositionManagerAddress\r\n        );\r\n        (, , , tickLower, tickUpper, , ) = getLiquidityNftPositionsInfo(\r\n            liquidityNftId,\r\n            nonfungiblePositionManagerAddress\r\n        );\r\n    }\r\n\r\n    function verifyNoDuplicateTickAndTickLower(\r\n        uint256 liquidityNftId,\r\n        address pancakeswapV3FactoryAddress,\r\n        address nonfungiblePositionManagerAddress\r\n    ) internal view {\r\n        (int24 tick, int24 tickLower, ) = getTickInfo(\r\n            liquidityNftId,\r\n            pancakeswapV3FactoryAddress,\r\n            nonfungiblePositionManagerAddress\r\n        );\r\n\r\n        require(tickLower != tick, \"tickLower == tick\");\r\n    }\r\n\r\n    function verifyNoDuplicateTickAndNewTickLower(\r\n        uint256 liquidityNftId,\r\n        int24 tickSpacing,\r\n        address pancakeswapV3FactoryAddress,\r\n        address nonfungiblePositionManagerAddress\r\n    ) internal view {\r\n        (int24 tick, int24 tickLower, ) = getTickInfo(\r\n            liquidityNftId,\r\n            pancakeswapV3FactoryAddress,\r\n            nonfungiblePositionManagerAddress\r\n        );\r\n\r\n        require(\r\n            !(tickLower > tick && tick % tickSpacing == 0),\r\n            \"new tickLower == tick\"\r\n        );\r\n    }\r\n\r\n    function calculateTickBoundary(\r\n        address poolAddress,\r\n        int24 tickSpread,\r\n        int24 tickSpacing\r\n    ) internal view returns (int24 tickLower, int24 tickUpper) {\r\n        // Get current tick\r\n        (, , , int24 currentTick, , , ) = PoolHelper.getPoolInfo(poolAddress);\r\n\r\n        // Calculate the floor tick value\r\n        int24 tickFloor = floorTick(currentTick, tickSpacing);\r\n\r\n        // Calculate the tickLower & tickToTickLower value\r\n        tickLower = tickFloor - tickSpacing * tickSpread;\r\n        int24 tickToTickLower = currentTick - tickLower;\r\n\r\n        // Calculate the tickUpper & tickUpperToTick value\r\n        tickUpper = floorTick((currentTick + tickToTickLower), tickSpacing);\r\n        int24 tickUpperToTick = tickUpper - currentTick;\r\n\r\n        // Check\r\n        // if the tickSpacing is greater than 1\r\n        // and\r\n        // if the (tickToTickLower - tickUpperToTick) is greater than or equal to (tickSpacing / 2)\r\n        if (\r\n            tickSpacing > 1 &&\r\n            (tickToTickLower - tickUpperToTick) >= (tickSpacing / 2)\r\n        ) {\r\n            // Increment the tickUpper by the tickSpacing\r\n            tickUpper += tickSpacing;\r\n        }\r\n    }\r\n\r\n    function floorTick(\r\n        int24 tick,\r\n        int24 tickSpacing\r\n    ) internal pure returns (int24) {\r\n        int24 baseFloor = tick / tickSpacing;\r\n\r\n        if (tick < 0 && tick % tickSpacing != 0) {\r\n            return (baseFloor - 1) * tickSpacing;\r\n        }\r\n        return baseFloor * tickSpacing;\r\n    }\r\n\r\n    function ceilingTick(\r\n        int24 tick,\r\n        int24 tickSpacing\r\n    ) internal pure returns (int24) {\r\n        int24 baseFloor = tick / tickSpacing;\r\n\r\n        if (tick > 0 && tick % tickSpacing != 0) {\r\n            return (baseFloor + 1) * tickSpacing;\r\n        }\r\n        return baseFloor * tickSpacing;\r\n    }\r\n}\r\n\r\n// File contracts/Controller.sol\r\n\r\n/// @dev verified, private contract\r\n/// @dev only owner or operator/backend callable\r\ncontract Controller is AccessControl, IControllerEvent {\r\n    using SafeMath for uint256;\r\n\r\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\r\n\r\n    address public PANCAKE_V3_FACTORY_ADDRESS;\r\n    address public NONFUNGIBLE_POSITION_MANAGER_ADDRESS;\r\n\r\n    constructor(bool isTestnet, address _executor) {\r\n        if (isTestnet) {\r\n            PANCAKE_V3_FACTORY_ADDRESS = Constants\r\n                .TESTNET_PANCAKE_V3_FACTORY_ADDRESS;\r\n            NONFUNGIBLE_POSITION_MANAGER_ADDRESS = Constants\r\n                .TESTNET_NONFUNGIBLE_POSITION_MANAGER_ADDRESS;\r\n        } else {\r\n            PANCAKE_V3_FACTORY_ADDRESS = Constants.PANCAKE_V3_FACTORY_ADDRESS;\r\n            NONFUNGIBLE_POSITION_MANAGER_ADDRESS = Constants\r\n                .NONFUNGIBLE_POSITION_MANAGER_ADDRESS;\r\n        }\r\n        // set deployer as EXECUTOR_ROLE roleAdmin\r\n        _setRoleAdmin(EXECUTOR_ROLE, DEFAULT_ADMIN_ROLE);\r\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\r\n        // set EXECUTOR_ROLE memebers\r\n        _setupRole(EXECUTOR_ROLE, _executor);\r\n    }\r\n\r\n    /// @dev backend get function support\r\n    function isNftWithinRange(\r\n        address _strategyContract\r\n    ) public view returns (bool isWithinRange) {\r\n        uint256 liquidityNftId = IStrategyInfo(_strategyContract)\r\n            .liquidityNftId();\r\n\r\n        require(\r\n            liquidityNftId != 0,\r\n            \"not allow calling when liquidityNftId is 0\"\r\n        );\r\n\r\n        (isWithinRange, ) = LiquidityNftHelper\r\n            .verifyCurrentPriceInLiquidityNftRange(\r\n                liquidityNftId,\r\n                PANCAKE_V3_FACTORY_ADDRESS,\r\n                NONFUNGIBLE_POSITION_MANAGER_ADDRESS\r\n            );\r\n    }\r\n\r\n    function isNftWithinOneTickSpacingRange(\r\n        address _strategyContract\r\n    ) public view returns (bool isWithinOneTickSpacingRange) {\r\n        uint256 liquidityNftId = IStrategyInfo(_strategyContract)\r\n            .liquidityNftId();\r\n\r\n        require(\r\n            liquidityNftId != 0,\r\n            \"not allow calling when liquidityNftId is 0\"\r\n        );\r\n\r\n        int24 tickSpacing = IStrategyInfo(_strategyContract).tickSpacing();\r\n        isWithinOneTickSpacingRange = LiquidityNftHelper\r\n            .verifyCurrentPriceInLiquidityNftValidGapRange(\r\n                tickSpacing,\r\n                liquidityNftId,\r\n                PANCAKE_V3_FACTORY_ADDRESS,\r\n                NONFUNGIBLE_POSITION_MANAGER_ADDRESS\r\n            );\r\n    }\r\n\r\n    function getEarningFlag(\r\n        address _strategyContract\r\n    ) public view returns (bool isEarningFlag) {\r\n        return IStrategyInfo(_strategyContract).isEarning();\r\n    }\r\n\r\n    function getRescalingFlag(\r\n        address _strategyContract\r\n    ) public view returns (bool isRescalingFlag) {\r\n        uint256 liquidityNftId = IStrategyInfo(_strategyContract)\r\n            .liquidityNftId();\r\n\r\n        if (liquidityNftId == 0) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function getRemainingEarnCountDown(\r\n        address _strategyContract\r\n    ) public view returns (uint256 remainingEarn) {\r\n        bool isEarningFlag = getEarningFlag(_strategyContract);\r\n        if (isEarningFlag == false) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 userListLength = IStrategyInfo(_strategyContract)\r\n            .getAllUsersInUserList()\r\n            .length;\r\n        uint256 earnLoopStartIndex = IStrategyInfo(_strategyContract)\r\n            .earnLoopStartIndex();\r\n\r\n        uint256 remainingUserNumber = userListLength.sub(earnLoopStartIndex);\r\n        uint256 earnLoopSegmentSize = IStrategyInfo(_strategyContract)\r\n            .earnLoopSegmentSize();\r\n\r\n        (uint256 quotient, uint256 remainder) = calculateQuotientAndRemainder(\r\n            remainingUserNumber,\r\n            earnLoopSegmentSize\r\n        );\r\n\r\n        return remainder > 0 ? (quotient.add(1)) : quotient;\r\n    }\r\n\r\n    function calculateQuotientAndRemainder(\r\n        uint256 dividend,\r\n        uint256 divisor\r\n    ) internal pure returns (uint256 quotient, uint256 remainder) {\r\n        quotient = dividend.div(divisor);\r\n        remainder = dividend.mod(divisor);\r\n    }\r\n\r\n    function getAllFundManagers(\r\n        address _fundManagerVaultContract\r\n    ) public view returns (IFundManagerVault.FundManager[4] memory) {\r\n        return\r\n            IFundManagerVault(_fundManagerVaultContract).getAllFundManagers();\r\n    }\r\n\r\n    /// @dev transactionDeadlineDuration setter\r\n    function setTransactionDeadlineDuration(\r\n        address _strategyContract,\r\n        uint256 _transactionDeadlineDuration\r\n    ) public onlyRole(EXECUTOR_ROLE) {\r\n        IStrategySetter(_strategyContract).setTransactionDeadlineDuration(\r\n            _transactionDeadlineDuration\r\n        );\r\n\r\n        emit SetTransactionDeadlineDuration(\r\n            _strategyContract,\r\n            msg.sender,\r\n            _transactionDeadlineDuration\r\n        );\r\n    }\r\n\r\n    /// @dev tickSpreadUpper setter\r\n    function setTickSpreadUpper(\r\n        address _strategyContract,\r\n        int24 _tickSpreadUpper\r\n    ) public onlyRole(EXECUTOR_ROLE) {\r\n        IStrategySetter(_strategyContract).setTickSpreadUpper(_tickSpreadUpper);\r\n\r\n        emit SetTickSpreadUpper(\r\n            _strategyContract,\r\n            msg.sender,\r\n            _tickSpreadUpper\r\n        );\r\n    }\r\n\r\n    /// @dev tickSpreadLower setter\r\n    function setTickSpreadLower(\r\n        address _strategyContract,\r\n        int24 _tickSpreadLower\r\n    ) public onlyRole(EXECUTOR_ROLE) {\r\n        IStrategySetter(_strategyContract).setTickSpreadLower(_tickSpreadLower);\r\n\r\n        emit SetTickSpreadLower(\r\n            _strategyContract,\r\n            msg.sender,\r\n            _tickSpreadLower\r\n        );\r\n    }\r\n\r\n    /// @dev buyBackToken setter\r\n    function setBuyBackToken(\r\n        address _strategyContract,\r\n        address _buyBackToken\r\n    ) public onlyRole(EXECUTOR_ROLE) {\r\n        IStrategySetter(_strategyContract).setBuyBackToken(_buyBackToken);\r\n\r\n        emit SetBuyBackToken(_strategyContract, msg.sender, _buyBackToken);\r\n    }\r\n\r\n    /// @dev buyBackNumerator setter\r\n    function setBuyBackNumerator(\r\n        address _strategyContract,\r\n        uint24 _buyBackNumerator\r\n    ) public onlyRole(EXECUTOR_ROLE) {\r\n        IStrategySetter(_strategyContract).setBuyBackNumerator(\r\n            _buyBackNumerator\r\n        );\r\n\r\n        emit SetBuyBackNumerator(\r\n            _strategyContract,\r\n            msg.sender,\r\n            _buyBackNumerator\r\n        );\r\n    }\r\n\r\n    /// @dev fundManagerVault setter\r\n    function setFundManagerVaultByIndex(\r\n        address _strategyContract,\r\n        uint256 _index,\r\n        address _fundManagerVaultAddress,\r\n        uint24 _fundManagerProfitVaultNumerator\r\n    ) public onlyRole(EXECUTOR_ROLE) {\r\n        IStrategySetter(_strategyContract).setFundManagerVaultByIndex(\r\n            _index,\r\n            _fundManagerVaultAddress,\r\n            _fundManagerProfitVaultNumerator\r\n        );\r\n\r\n        emit SetFundManagerVaultByIndex(\r\n            _strategyContract,\r\n            msg.sender,\r\n            _index,\r\n            _fundManagerVaultAddress,\r\n            _fundManagerProfitVaultNumerator\r\n        );\r\n    }\r\n\r\n    /// @dev fundManager setter\r\n    function setFundManagerByIndex(\r\n        address _fundManagerVaultContract,\r\n        uint256 _index,\r\n        address _fundManagerAddress,\r\n        uint24 _fundManagerProfitNumerator\r\n    ) public onlyRole(EXECUTOR_ROLE) {\r\n        IFundManagerVault(_fundManagerVaultContract).setFundManagerByIndex(\r\n            _index,\r\n            _fundManagerAddress,\r\n            _fundManagerProfitNumerator\r\n        );\r\n\r\n        emit SetFundManagerByIndex(\r\n            _fundManagerVaultContract,\r\n            msg.sender,\r\n            _index,\r\n            _fundManagerAddress,\r\n            _fundManagerProfitNumerator\r\n        );\r\n    }\r\n\r\n    /// @dev earnLoopSegmentSize setter\r\n    function setEarnLoopSegmentSize(\r\n        address _strategyContract,\r\n        uint256 _earnLoopSegmentSize\r\n    ) public onlyRole(EXECUTOR_ROLE) {\r\n        IStrategySetter(_strategyContract).setEarnLoopSegmentSize(\r\n            _earnLoopSegmentSize\r\n        );\r\n\r\n        emit SetEarnLoopSegmentSize(\r\n            _strategyContract,\r\n            msg.sender,\r\n            _earnLoopSegmentSize\r\n        );\r\n    }\r\n\r\n    /// @dev stakeNext setter\r\n    function setStakeNext(\r\n        address _strategyContract,\r\n        bool _stakeNext\r\n    ) public onlyRole(EXECUTOR_ROLE) {\r\n        IStrategySetter(_strategyContract).setStakeNext(_stakeNext);\r\n\r\n        emit SetStakeNext(_strategyContract, msg.sender, _stakeNext);\r\n    }\r\n\r\n    /// @dev earn related\r\n    function collectRewards(\r\n        address _strategyContract\r\n    ) public onlyRole(EXECUTOR_ROLE) {\r\n        IStrategy(_strategyContract).collectRewards();\r\n\r\n        emit CollectRewards(\r\n            _strategyContract,\r\n            msg.sender,\r\n            IStrategyInfo(_strategyContract).liquidityNftId(),\r\n            IStrategyInfo(_strategyContract).rewardToken0Amount(),\r\n            IStrategyInfo(_strategyContract).rewardToken1Amount(),\r\n            IStrategyInfo(_strategyContract).rewardCakeAmount(),\r\n            IStrategyInfo(_strategyContract).rewardUsdtAmount()\r\n        );\r\n    }\r\n\r\n    function earnPreparation(\r\n        address _strategyContract,\r\n        uint256 _minimumToken0SwapOutAmount,\r\n        uint256 _minimumToken1SwapOutAmount,\r\n        uint256 _minimumCakeSwapOutAmount,\r\n        uint256 _minimumBuybackSwapOutAmount\r\n    ) public onlyRole(EXECUTOR_ROLE) {\r\n        IStrategy(_strategyContract).earnPreparation(\r\n            _minimumToken0SwapOutAmount,\r\n            _minimumToken1SwapOutAmount,\r\n            _minimumCakeSwapOutAmount,\r\n            _minimumBuybackSwapOutAmount\r\n        );\r\n        require(getEarningFlag(_strategyContract) == true, \"earn prep error\");\r\n\r\n        emit EarnPreparation(\r\n            _strategyContract,\r\n            msg.sender,\r\n            IStrategyInfo(_strategyContract).liquidityNftId(),\r\n            IStrategyInfo(_strategyContract).rewardUsdtAmount(),\r\n            getRemainingEarnCountDown(_strategyContract)\r\n        );\r\n    }\r\n\r\n    function earn(address _strategyContract) public onlyRole(EXECUTOR_ROLE) {\r\n        IStrategy(_strategyContract).earn();\r\n\r\n        emit Earn(\r\n            _strategyContract,\r\n            msg.sender,\r\n            IStrategyInfo(_strategyContract).liquidityNftId(),\r\n            getRemainingEarnCountDown(_strategyContract)\r\n        );\r\n    }\r\n\r\n    function work(\r\n        address _fundManagerVaultContract\r\n    ) public onlyRole(EXECUTOR_ROLE) {\r\n        distribute(_fundManagerVaultContract);\r\n    }\r\n\r\n    function enter(\r\n        address _fundManagerVaultContract\r\n    ) public onlyRole(EXECUTOR_ROLE) {\r\n        distribute(_fundManagerVaultContract);\r\n    }\r\n\r\n    function allocate(\r\n        address _fundManagerVaultContract\r\n    ) public onlyRole(EXECUTOR_ROLE) {\r\n        distribute(_fundManagerVaultContract);\r\n    }\r\n\r\n    function distribute(address _fundManagerVaultContract) private {\r\n        uint256 usdtBeforeTx = IFundManagerVault(_fundManagerVaultContract)\r\n            .getUsdtBalance();\r\n\r\n        IFundManagerVault(_fundManagerVaultContract).allocate();\r\n\r\n        uint256 usdtAfterTx = IFundManagerVault(_fundManagerVaultContract)\r\n            .getUsdtBalance();\r\n\r\n        emit Allocate(\r\n            _fundManagerVaultContract,\r\n            msg.sender,\r\n            usdtBeforeTx.sub(usdtAfterTx),\r\n            usdtAfterTx\r\n        );\r\n    }\r\n\r\n    /// @dev rescale related\r\n    function rescale(address _strategyContract) public onlyRole(EXECUTOR_ROLE) {\r\n        IStrategy(_strategyContract).rescale();\r\n\r\n        emit Rescale(\r\n            _strategyContract,\r\n            msg.sender,\r\n            IStrategyInfo(_strategyContract).dustToken0Amount(),\r\n            IStrategyInfo(_strategyContract).dustToken1Amount()\r\n        );\r\n    }\r\n\r\n    /// @dev deposit dust token related\r\n    function depositDustToken(\r\n        address _strategyContract,\r\n        bool _depositDustToken0\r\n    ) public onlyRole(EXECUTOR_ROLE) {\r\n        (\r\n            uint256 increasedToken0Amount,\r\n            uint256 increasedToken1Amount\r\n        ) = IStrategy(_strategyContract).depositDustToken(_depositDustToken0);\r\n\r\n        emit DepositDustToken(\r\n            _strategyContract,\r\n            msg.sender,\r\n            IStrategyInfo(_strategyContract).liquidityNftId(),\r\n            _depositDustToken0,\r\n            increasedToken0Amount,\r\n            increasedToken1Amount,\r\n            IStrategyInfo(_strategyContract).dustToken0Amount(),\r\n            IStrategyInfo(_strategyContract).dustToken1Amount()\r\n        );\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isTestnet\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_executor\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fundManagerVaultAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"executorAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"allocatedUsdtAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"remainingUsdtAmount\",\"type\":\"uint256\"}],\"name\":\"Allocate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategyContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"executorAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"liquidityNftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardToken0Amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardToken1Amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardCakeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardUsdtAmount\",\"type\":\"uint256\"}],\"name\":\"CollectRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategyContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"executorAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"liquidityNftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"depositDustToken0\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"increasedToken0Amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"increasedToken1Amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dustToken0Amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dustToken1Amount\",\"type\":\"uint256\"}],\"name\":\"DepositDustToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategyContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"executorAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"liquidityNftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"remainingEarnCountDown\",\"type\":\"uint256\"}],\"name\":\"Earn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategyContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"executorAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"liquidityNftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardUsdtAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"remainingEarnCountDown\",\"type\":\"uint256\"}],\"name\":\"EarnPreparation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategyContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"executorAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dustToken0Amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dustToken1Amount\",\"type\":\"uint256\"}],\"name\":\"Rescale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategyContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"executorAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint24\",\"name\":\"buyBackNumerator\",\"type\":\"uint24\"}],\"name\":\"SetBuyBackNumerator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategyContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"executorAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyBackToken\",\"type\":\"address\"}],\"name\":\"SetBuyBackToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategyContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"executorAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"earnLoopSegmentSize\",\"type\":\"uint256\"}],\"name\":\"SetEarnLoopSegmentSize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fundManagerVaultAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"executorAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fundManagerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint24\",\"name\":\"fundManagerProfitNumerator\",\"type\":\"uint24\"}],\"name\":\"SetFundManagerByIndex\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategyContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"executorAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fundManagerVaultAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint24\",\"name\":\"fundManagerProfitVaultNumerator\",\"type\":\"uint24\"}],\"name\":\"SetFundManagerVaultByIndex\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategyContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"executorAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"stakeNext\",\"type\":\"bool\"}],\"name\":\"SetStakeNext\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategyContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"executorAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int24\",\"name\":\"tickSpreadLower\",\"type\":\"int24\"}],\"name\":\"SetTickSpreadLower\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategyContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"executorAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int24\",\"name\":\"tickSpreadUpper\",\"type\":\"int24\"}],\"name\":\"SetTickSpreadUpper\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategyContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"executorAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"transactionDeadlineDuration\",\"type\":\"uint256\"}],\"name\":\"SetTransactionDeadlineDuration\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EXECUTOR_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NONFUNGIBLE_POSITION_MANAGER_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PANCAKE_V3_FACTORY_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fundManagerVaultContract\",\"type\":\"address\"}],\"name\":\"allocate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategyContract\",\"type\":\"address\"}],\"name\":\"collectRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategyContract\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_depositDustToken0\",\"type\":\"bool\"}],\"name\":\"depositDustToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategyContract\",\"type\":\"address\"}],\"name\":\"earn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategyContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minimumToken0SwapOutAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minimumToken1SwapOutAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minimumCakeSwapOutAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minimumBuybackSwapOutAmount\",\"type\":\"uint256\"}],\"name\":\"earnPreparation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fundManagerVaultContract\",\"type\":\"address\"}],\"name\":\"enter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fundManagerVaultContract\",\"type\":\"address\"}],\"name\":\"getAllFundManagers\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"fundManagerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fundManagerProfitNumerator\",\"type\":\"uint256\"}],\"internalType\":\"struct IFundManagerVault.FundManager[4]\",\"name\":\"\",\"type\":\"tuple[4]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategyContract\",\"type\":\"address\"}],\"name\":\"getEarningFlag\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isEarningFlag\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategyContract\",\"type\":\"address\"}],\"name\":\"getRemainingEarnCountDown\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remainingEarn\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategyContract\",\"type\":\"address\"}],\"name\":\"getRescalingFlag\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isRescalingFlag\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategyContract\",\"type\":\"address\"}],\"name\":\"isNftWithinOneTickSpacingRange\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isWithinOneTickSpacingRange\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategyContract\",\"type\":\"address\"}],\"name\":\"isNftWithinRange\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isWithinRange\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategyContract\",\"type\":\"address\"}],\"name\":\"rescale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategyContract\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"_buyBackNumerator\",\"type\":\"uint24\"}],\"name\":\"setBuyBackNumerator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategyContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_buyBackToken\",\"type\":\"address\"}],\"name\":\"setBuyBackToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategyContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_earnLoopSegmentSize\",\"type\":\"uint256\"}],\"name\":\"setEarnLoopSegmentSize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fundManagerVaultContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_fundManagerAddress\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"_fundManagerProfitNumerator\",\"type\":\"uint24\"}],\"name\":\"setFundManagerByIndex\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategyContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_fundManagerVaultAddress\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"_fundManagerProfitVaultNumerator\",\"type\":\"uint24\"}],\"name\":\"setFundManagerVaultByIndex\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategyContract\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_stakeNext\",\"type\":\"bool\"}],\"name\":\"setStakeNext\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategyContract\",\"type\":\"address\"},{\"internalType\":\"int24\",\"name\":\"_tickSpreadLower\",\"type\":\"int24\"}],\"name\":\"setTickSpreadLower\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategyContract\",\"type\":\"address\"},{\"internalType\":\"int24\",\"name\":\"_tickSpreadUpper\",\"type\":\"int24\"}],\"name\":\"setTickSpreadUpper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_strategyContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_transactionDeadlineDuration\",\"type\":\"uint256\"}],\"name\":\"setTransactionDeadlineDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fundManagerVaultContract\",\"type\":\"address\"}],\"name\":\"work\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Controller", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000002bad4b88bec01e42b41ad38f5039662447f8d630", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://681bebd6a375ca286850cbf8d37c55d469c29d58227d739efb14e992f03caa45"}