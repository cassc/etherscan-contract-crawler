{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@mimic-fi/v2-bridge-connector/contracts/IBridgeConnector.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.8.0;\\n\\nimport '@mimic-fi/v2-registry/contracts/implementations/IImplementation.sol';\\n\\n/**\\n * @title IBridgeConnector\\n * @dev Bridge Connector interface to bridge tokens between different chains. It must follow IImplementation interface.\\n */\\ninterface IBridgeConnector is IImplementation {\\n    /**\\n     * @dev Enum identifying the sources proposed: Hop only for now.\\n     */\\n    enum Source {\\n        Hop\\n    }\\n\\n    /**\\n     * @dev Bridge assets to a different chain\\n     * @param source Source to execute the requested bridge op\\n     * @param chainId ID of the destination chain\\n     * @param token Address of the token to be bridged\\n     * @param amountIn Amount of tokens to be bridged\\n     * @param minAmountOut Minimum amount of tokens willing to receive on the destination chain\\n     * @param recipient Address that will receive the tokens on the destination chain\\n     * @param data ABI encoded data that will depend on the requested source\\n     */\\n    function bridge(\\n        uint8 source,\\n        uint256 chainId,\\n        address token,\\n        uint256 amountIn,\\n        uint256 minAmountOut,\\n        address recipient,\\n        bytes memory data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-bridge-connector/contracts/interfaces/IHopL1Bridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.8.0;\\n\\ninterface IHopL1Bridge {\\n    /**\\n     * @notice To send funds L1->L2, call the sendToL2 method on the L1 Bridge contract\\n     * @notice `amountOutMin` and `deadline` should be 0 when no swap is intended at the destination.\\n     * @notice `amount` is the total amount the user wants to send including the relayer fee\\n     * @dev Send tokens to a supported layer-2 to mint hToken and optionally swap the hToken in the\\n     * AMM at the destination.\\n     * @param chainId The chainId of the destination chain\\n     * @param recipient The address receiving funds at the destination\\n     * @param amount The amount being sent\\n     * @param amountOutMin The minimum amount received after attempting to swap in the destination\\n     * AMM market. 0 if no swap is intended.\\n     * @param deadline The deadline for swapping in the destination AMM market. 0 if no\\n     * swap is intended.\\n     * @param relayer The address of the relayer at the destination.\\n     * @param relayerFee The amount distributed to the relayer at the destination. This is subtracted from the `amount`.\\n     */\\n    function sendToL2(\\n        uint256 chainId,\\n        address recipient,\\n        uint256 amount,\\n        uint256 amountOutMin,\\n        uint256 deadline,\\n        address relayer,\\n        uint256 relayerFee\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-bridge-connector/contracts/interfaces/IHopL2AMM.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.8.0;\\n\\ninterface IHopL2AMM {\\n    function hToken() external view returns (address);\\n\\n    function exchangeAddress() external view returns (address);\\n\\n    /**\\n     * @notice To send funds L2->L1 or L2->L2, call the swapAndSend method on the L2 AMM Wrapper contract\\n     * @dev Do not set destinationAmountOutMin and destinationDeadline when sending to L1 because there is no AMM on L1,\\n     * otherwise the calculated transferId will be invalid and the transfer will be unbondable. These parameters should\\n     * be set to 0 when sending to L1.\\n     * @param amount is the amount the user wants to send plus the Bonder fee\\n     */\\n    function swapAndSend(\\n        uint256 chainId,\\n        address recipient,\\n        uint256 amount,\\n        uint256 bonderFee,\\n        uint256 amountOutMin,\\n        uint256 deadline,\\n        uint256 destinationAmountOutMin,\\n        uint256 destinationDeadline\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-helpers/contracts/auth/Authorizer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport './IAuthorizer.sol';\\n\\n/**\\n * @title Authorizer\\n * @dev Authorization module to be used by contracts that need to implement permissions for their methods.\\n * It provides a permissions model to list who is allowed to call what function in a contract. And only accounts\\n * authorized to manage those permissions are the ones that are allowed to authorize or unauthorize accounts.\\n */\\ncontract Authorizer is IAuthorizer {\\n    // Constant used to denote that a permission is open to anyone\\n    address public constant ANY_ADDRESS = address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);\\n\\n    // Internal mapping to tell who is allowed to do what indexed by (account, function selector)\\n    mapping (address => mapping (bytes4 => bool)) private authorized;\\n\\n    /**\\n     * @dev Modifier that should be used to tag protected functions\\n     */\\n    modifier auth() {\\n        _authenticate(msg.sender, msg.sig);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Tells whether someone is allowed to call a function or not. It returns true if it's allowed to anyone.\\n     * @param who Address asking permission for\\n     * @param what Function selector asking permission for\\n     */\\n    function isAuthorized(address who, bytes4 what) public view override returns (bool) {\\n        return authorized[ANY_ADDRESS][what] || authorized[who][what];\\n    }\\n\\n    /**\\n     * @dev Authorizes someone to call a function. Sender must be authorize to do so.\\n     * @param who Address to be authorized\\n     * @param what Function selector to be granted\\n     */\\n    function authorize(address who, bytes4 what) external override auth {\\n        _authorize(who, what);\\n    }\\n\\n    /**\\n     * @dev Unauthorizes someone to call a function. Sender must be authorize to do so.\\n     * @param who Address to be unauthorized\\n     * @param what Function selector to be revoked\\n     */\\n    function unauthorize(address who, bytes4 what) external override auth {\\n        _unauthorize(who, what);\\n    }\\n\\n    /**\\n     * @dev Internal function to authenticate someone over a function.\\n     * It reverts if the given account is not authorized to call the requested function.\\n     * @param who Address to be authenticated\\n     * @param what Function selector to be authenticated\\n     */\\n    function _authenticate(address who, bytes4 what) internal view {\\n        require(isAuthorized(who, what), 'AUTH_SENDER_NOT_ALLOWED');\\n    }\\n\\n    /**\\n     * @dev Internal function to authorize someone to call a function\\n     * @param who Address to be authorized\\n     * @param what Function selector to be granted\\n     */\\n    function _authorize(address who, bytes4 what) internal {\\n        authorized[who][what] = true;\\n        emit Authorized(who, what);\\n    }\\n\\n    /**\\n     * @dev Internal function to unauthorize someone to call a function\\n     * @param who Address to be unauthorized\\n     * @param what Function selector to be revoked\\n     */\\n    function _unauthorize(address who, bytes4 what) internal {\\n        authorized[who][what] = false;\\n        emit Unauthorized(who, what);\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-helpers/contracts/auth/IAuthorizer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.8.0;\\n\\n/**\\n * @title IAuthorizer\\n */\\ninterface IAuthorizer {\\n    /**\\n     * @dev Emitted when an account is authorized to call a function\\n     */\\n    event Authorized(address indexed who, bytes4 what);\\n\\n    /**\\n     * @dev Emitted when an account is unauthorized to call a function\\n     */\\n    event Unauthorized(address indexed who, bytes4 what);\\n\\n    /**\\n     * @dev Authorizes someone to call a function. Sender must be authorize to do so.\\n     * @param who Address to be authorized\\n     * @param what Function selector to be granted\\n     */\\n    function authorize(address who, bytes4 what) external;\\n\\n    /**\\n     * @dev Unauthorizes someone to call a function. Sender must be authorize to do so.\\n     * @param who Address to be unauthorized\\n     * @param what Function selector to be revoked\\n     */\\n    function unauthorize(address who, bytes4 what) external;\\n\\n    /**\\n     * @dev Tells whether someone is allowed to call a function or not. It returns true if it's allowed to anyone.\\n     * @param who Address asking permission for\\n     * @param what Function selector asking permission for\\n     */\\n    function isAuthorized(address who, bytes4 what) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-helpers/contracts/math/FixedPoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title FixedPoint\\n * @dev Math library to operate with fixed point values with 18 decimals\\n */\\nlibrary FixedPoint {\\n    // 1 in fixed point value: 18 decimal places\\n    uint256 internal constant ONE = 1e18;\\n\\n    /**\\n     * @dev Multiplies two fixed point numbers rounding down\\n     */\\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 product = a * b;\\n            require(a == 0 || product / a == b, 'MUL_OVERFLOW');\\n            return product / ONE;\\n        }\\n    }\\n\\n    /**\\n     * @dev Multiplies two fixed point numbers rounding up\\n     */\\n    function mulUp(uint256 a, uint256 b) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 product = a * b;\\n            require(a == 0 || product / a == b, 'MUL_OVERFLOW');\\n            return product == 0 ? 0 : (((product - 1) / ONE) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Divides two fixed point numbers rounding down\\n     */\\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\\n        unchecked {\\n            require(b != 0, 'ZERO_DIVISION');\\n            if (a == 0) return 0;\\n            uint256 aInflated = a * ONE;\\n            require(aInflated / a == ONE, 'DIV_INTERNAL');\\n            return aInflated / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Divides two fixed point numbers rounding up\\n     */\\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\\n        unchecked {\\n            require(b != 0, 'ZERO_DIVISION');\\n            if (a == 0) return 0;\\n            uint256 aInflated = a * ONE;\\n            require(aInflated / a == ONE, 'DIV_INTERNAL');\\n            return ((aInflated - 1) / b) + 1;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-helpers/contracts/math/UncheckedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title UncheckedMath\\n * @dev Math library to perform unchecked operations\\n */\\nlibrary UncheckedMath {\\n    /**\\n     * @dev Unsafely adds two unsigned integers\\n     */\\n    function uncheckedAdd(uint256 a, uint256 b) internal pure returns (uint256) {\\n        unchecked {\\n            return a + b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Unsafely subtracts two unsigned integers\\n     */\\n    function uncheckedSub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        unchecked {\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Unsafely multiplies two unsigned integers\\n     */\\n    function uncheckedMul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        unchecked {\\n            return a * b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Unsafely multiplies two signed integers\\n     */\\n    function uncheckedMul(int256 a, int256 b) internal pure returns (int256) {\\n        unchecked {\\n            return a * b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Unsafely divides two unsigned integers\\n     */\\n    function uncheckedDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        unchecked {\\n            return a / b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-helpers/contracts/utils/Arrays.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '../math/UncheckedMath.sol';\\n\\n/**\\n * @title Arrays\\n * @dev Helper methods to operate arrays\\n */\\nlibrary Arrays {\\n    using UncheckedMath for uint256;\\n\\n    /**\\n     * @dev Tells if an array of addresses includes the given ones\\n     */\\n    function includes(address[] memory arr, address a, address b) internal pure returns (bool) {\\n        bool containsA;\\n        bool containsB;\\n        for (uint256 i = 0; i < arr.length; i = i.uncheckedAdd(1)) {\\n            if (arr[i] == a) containsA = true;\\n            if (arr[i] == b) containsB = true;\\n        }\\n        return containsA && containsB;\\n    }\\n\\n    /**\\n     * @dev Builds an array of addresses based on the given ones\\n     */\\n    function from(address a, address b) internal pure returns (address[] memory result) {\\n        result = new address[](2);\\n        result[0] = a;\\n        result[1] = b;\\n    }\\n\\n    /**\\n     * @dev Builds an array of addresses based on the given ones\\n     */\\n    function from(address a, address[] memory b, address c) internal pure returns (address[] memory result) {\\n        // No need for checked math since we are simply adding one to a memory array's length\\n        result = new address[](b.length.uncheckedAdd(2));\\n        result[0] = a;\\n\\n        // No need for checked math since we are using it to compute indexes manually, always within boundaries\\n        for (uint256 i = 0; i < b.length; i = i.uncheckedAdd(1)) result[i.uncheckedAdd(1)] = b[i];\\n        result[b.length.uncheckedAdd(1)] = c;\\n    }\\n\\n    /**\\n     * @dev Builds an array of addresses based on the given ones\\n     */\\n    function from(address a, address[] memory b, address[] memory c) internal pure returns (address[] memory result) {\\n        // No need for checked math since we are simply adding two memory array's length\\n        result = new address[](b.length.uncheckedAdd(c.length).uncheckedAdd(1));\\n        result[0] = a;\\n\\n        // No need for checked math since we are using it to compute indexes manually, always within boundaries\\n        for (uint256 i = 0; i < b.length; i = i.uncheckedAdd(1)) {\\n            result[i.uncheckedAdd(1)] = b[i];\\n        }\\n\\n        // No need for checked math since we are using it to compute indexes manually, always within boundaries\\n        for (uint256 i = 0; i < c.length; i = i.uncheckedAdd(1)) {\\n            result[b.length.uncheckedAdd(1).uncheckedAdd(i)] = c[i];\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-helpers/contracts/utils/Denominations.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Denominations\\n * @dev Provides a list of ground denominations for those tokens that cannot be represented by an ERC20.\\n * For now, the only needed is the native token that could be ETH, MATIC, or other depending on the layer being operated.\\n */\\nlibrary Denominations {\\n    address internal constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    // Fiat currencies follow https://en.wikipedia.org/wiki/ISO_4217\\n    address internal constant USD = address(840);\\n\\n    function isNativeToken(address token) internal pure returns (bool) {\\n        return token == NATIVE_TOKEN;\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-helpers/contracts/utils/EnumerableMap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// Based on the EnumerableMap library from OpenZeppelin Contracts\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\\n\\n/**\\n * @dev Library for managing an enumerable variant of Solidity's\\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\\n * type.\\n *\\n * Maps have the following properties:\\n *\\n * - Entries are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableMap for EnumerableMap.AddressToAddressMap;\\n *\\n *     // Declare a set state variable\\n *     EnumerableMap.AddressToAddressMap private myMap;\\n * }\\n * ```\\n */\\n\\nlibrary EnumerableMap {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Map type with\\n    // address keys and values.\\n    // The Map implementation uses private functions, and user-facing\\n    // implementations (such as AddressToAddressMap) are just wrappers around\\n    // the underlying Map.\\n    // This means that we can only create new EnumerableMaps for types that fit\\n    // in address.\\n\\n    struct AddressToAddressMap {\\n        // Storage of keys\\n        EnumerableSet.AddressSet _keys;\\n        mapping (address => address) _values;\\n    }\\n\\n    /**\\n     * @dev Returns the number of key-value pairs in the map. O(1).\\n     */\\n    function length(AddressToAddressMap storage map) internal view returns (uint256) {\\n        return map._keys.length();\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(AddressToAddressMap storage map, address key) internal view returns (bool) {\\n        return map._keys.contains(key);\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(AddressToAddressMap storage map, address key, address value) internal returns (bool) {\\n        map._values[key] = value;\\n        return map._keys.add(key);\\n    }\\n\\n    /**\\n     * @dev Removes a key-value pair from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(AddressToAddressMap storage map, address key) internal returns (bool) {\\n        delete map._values[key];\\n        return map._keys.remove(key);\\n    }\\n\\n    /**\\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of entries inside the\\n     * array, and it may change when more entries are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressToAddressMap storage map, uint256 index) internal view returns (address, address) {\\n        address key = map._keys.at(index);\\n        return (key, map._values[key]);\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(AddressToAddressMap storage map, address key) internal view returns (address) {\\n        address value = map._values[key];\\n        require(value != address(0) || contains(map, key), 'EnumerableMap: nonexistent key');\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`.  O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(AddressToAddressMap storage map, address key) internal view returns (bool, address) {\\n        address value = map._values[key];\\n        if (value == address(0)) {\\n            return (contains(map, key), address(0));\\n        } else {\\n            return (true, value);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-helpers/contracts/utils/ERC20Helpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\\n\\nimport './Denominations.sol';\\n\\n/**\\n * @title ERC20Helpers\\n * @dev Provides a list of ERC20 helper methods\\n */\\nlibrary ERC20Helpers {\\n    function approve(address token, address to, uint256 amount) internal {\\n        SafeERC20.safeApprove(IERC20(token), to, 0);\\n        SafeERC20.safeApprove(IERC20(token), to, amount);\\n    }\\n\\n    function transfer(address token, address to, uint256 amount) internal {\\n        if (Denominations.isNativeToken(token)) Address.sendValue(payable(to), amount);\\n        else SafeERC20.safeTransfer(IERC20(token), to, amount);\\n    }\\n\\n    function balanceOf(address token, address account) internal view returns (uint256) {\\n        if (Denominations.isNativeToken(token)) return address(account).balance;\\n        else return IERC20(token).balanceOf(address(account));\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-helpers/contracts/utils/IWrappedNativeToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\n/**\\n * @title IWrappedNativeToken\\n */\\ninterface IWrappedNativeToken is IERC20 {\\n    /**\\n     * @dev Wraps msg.value into the wrapped-native token\\n     */\\n    function deposit() external payable;\\n\\n    /**\\n     * @dev Unwraps requested amount to the native token\\n     */\\n    function withdraw(uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-price-oracle/contracts/feeds/IPriceFeedProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.8.0;\\n\\n/**\\n * @title IPriceFeedProvider\\n * @dev Contract providing price feed references for (base, quote) token pairs\\n */\\ninterface IPriceFeedProvider {\\n    /**\\n     * @dev Emitted every time a price feed is set for (base, quote) pair\\n     */\\n    event PriceFeedSet(address indexed base, address indexed quote, address feed);\\n\\n    /**\\n     * @dev Tells the price feed address for (base, quote) pair. It returns the zero address if there is no one set.\\n     * @param base Token to be rated\\n     * @param quote Token used for the price rate\\n     */\\n    function getPriceFeed(address base, address quote) external view returns (address);\\n\\n    /**\\n     * @dev Sets a of price feed\\n     * @param base Token base to be set\\n     * @param quote Token quote to be set\\n     * @param feed Price feed to be set\\n     */\\n    function setPriceFeed(address base, address quote, address feed) external;\\n\\n    /**\\n     * @dev Sets a list of price feeds\\n     * @param bases List of token bases to be set\\n     * @param quotes List of token quotes to be set\\n     * @param feeds List of price feeds to be set\\n     */\\n    function setPriceFeeds(address[] memory bases, address[] memory quotes, address[] memory feeds) external;\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-price-oracle/contracts/feeds/PriceFeedProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@mimic-fi/v2-helpers/contracts/math/UncheckedMath.sol';\\n\\nimport './IPriceFeedProvider.sol';\\n\\n/**\\n * @title IPriceFeedProvider\\n * @dev Contract providing price feed references for (base, quote) token pairs\\n */\\ncontract PriceFeedProvider is IPriceFeedProvider {\\n    using UncheckedMath for uint256;\\n\\n    // Mapping of price feeds from \\\"token A\\\" to \\\"token B\\\"\\n    mapping (address => mapping (address => address)) private _priceFeeds;\\n\\n    /**\\n     * @dev Tells the price feed address for (base, quote) pair. It returns the zero address if there is no one set.\\n     * @param base Token to be rated\\n     * @param quote Token used for the price rate\\n     */\\n    function getPriceFeed(address base, address quote) external view override returns (address) {\\n        return _priceFeeds[base][quote];\\n    }\\n\\n    /**\\n     * @dev Sets a of price feed\\n     * @param base Token base to be set\\n     * @param quote Token quote to be set\\n     * @param feed Price feed to be set\\n     */\\n    function setPriceFeed(address base, address quote, address feed) public virtual override {\\n        _priceFeeds[base][quote] = feed;\\n        emit PriceFeedSet(base, quote, feed);\\n    }\\n\\n    /**\\n     * @dev Sets a list of price feeds. Sender must be authorized.\\n     * @param bases List of token bases to be set\\n     * @param quotes List of token quotes to be set\\n     * @param feeds List of price feeds to be set\\n     */\\n    function setPriceFeeds(address[] memory bases, address[] memory quotes, address[] memory feeds)\\n        public\\n        virtual\\n        override\\n    {\\n        require(bases.length == quotes.length, 'SET_FEEDS_INVALID_QUOTES_LENGTH');\\n        require(bases.length == feeds.length, 'SET_FEEDS_INVALID_FEEDS_LENGTH');\\n        for (uint256 i = 0; i < bases.length; i = i.uncheckedAdd(1)) setPriceFeed(bases[i], quotes[i], feeds[i]);\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-price-oracle/contracts/oracle/IPriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.8.0;\\n\\nimport '@mimic-fi/v2-registry/contracts/implementations/IImplementation.sol';\\n\\n/**\\n * @title IPriceOracle\\n * @dev Oracle that interfaces with external feeds to provide quotes for tokens based on any other token.\\n * It must support also `IImplementation`.\\n */\\ninterface IPriceOracle is IImplementation {\\n    /**\\n     * @dev Tells the price of a token (base) in a given quote. The response is expressed using the corresponding\\n     * number of decimals so that when performing a fixed point product of it by a `base` amount it results in\\n     * a value expressed in `quote` decimals. For example, if `base` is ETH and `quote` is USDC, then the returned\\n     * value is expected to be expressed using 6 decimals:\\n     *\\n     * FixedPoint.mul(X[ETH], price[USDC/ETH]) = FixedPoint.mul(X[18], price[6]) = X * price [6]\\n     *\\n     * @param provider Contract providing the price feeds to use by the oracle\\n     * @param base Token to rate\\n     * @param quote Token used for the price rate\\n     */\\n    function getPrice(address provider, address base, address quote) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-registry/contracts/implementations/BaseAuthorizedImplementation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@mimic-fi/v2-helpers/contracts/auth/Authorizer.sol';\\n\\nimport './BaseImplementation.sol';\\n\\n/**\\n * @title BaseAuthorizedImplementation\\n * @dev BaseImplementation using the Authorizer mixin. Base implementations that want to use the Authorizer\\n * permissions mechanism should inherit from this contract instead.\\n */\\nabstract contract BaseAuthorizedImplementation is BaseImplementation, Authorizer {\\n    /**\\n     * @dev Creates a new BaseAuthorizedImplementation\\n     * @param admin Address to be granted authorize and unauthorize permissions\\n     * @param registry Address of the Mimic Registry\\n     */\\n    constructor(address admin, address registry) BaseImplementation(registry) {\\n        _authorize(admin, Authorizer.authorize.selector);\\n        _authorize(admin, Authorizer.unauthorize.selector);\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-registry/contracts/implementations/BaseImplementation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/proxy/utils/Initializable.sol';\\n\\nimport './IImplementation.sol';\\nimport '../registry/IRegistry.sol';\\n\\n/**\\n * @title BaseImplementation\\n * @dev This implementation contract comes with an immutable reference to an implementations registry where it should\\n * be registered as well (checked during initialization). It allows requesting new instances of other registered\\n * implementations to as another safety check to make sure valid instances are referenced in case it's needed.\\n */\\nabstract contract BaseImplementation is IImplementation {\\n    // Immutable implementations registry reference\\n    address public immutable override registry;\\n\\n    /**\\n     * @dev Creates a new BaseImplementation\\n     * @param _registry Address of the Mimic Registry where dependencies will be validated against\\n     */\\n    constructor(address _registry) {\\n        registry = _registry;\\n    }\\n\\n    /**\\n     * @dev Internal function to validate a new dependency that must be registered as stateless.\\n     * It checks the new dependency is registered, not deprecated, and stateless.\\n     * @param dependency New stateless dependency to be set\\n     */\\n    function _validateStatelessDependency(address dependency) internal view {\\n        require(_validateDependency(dependency), 'DEPENDENCY_NOT_STATELESS');\\n    }\\n\\n    /**\\n     * @dev Internal function to validate a new dependency that cannot be registered as stateless.\\n     * It checks the new dependency is registered, not deprecated, and not stateful.\\n     * @param dependency New stateful dependency to be set\\n     */\\n    function _validateStatefulDependency(address dependency) internal view {\\n        require(!_validateDependency(dependency), 'DEPENDENCY_NOT_STATEFUL');\\n    }\\n\\n    /**\\n     * @dev Internal function to validate a new dependency. It checks the dependency is registered and not deprecated.\\n     * @param dependency New dependency to be set\\n     * @return Whether the dependency is stateless or not\\n     */\\n    function _validateDependency(address dependency) private view returns (bool) {\\n        (bool stateless, bool deprecated, bytes32 namespace) = IRegistry(registry).implementationData(dependency);\\n        require(namespace != bytes32(0), 'DEPENDENCY_NOT_REGISTERED');\\n        require(!deprecated, 'DEPENDENCY_DEPRECATED');\\n        return stateless;\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-registry/contracts/implementations/IImplementation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.8.0;\\n\\n// solhint-disable func-name-mixedcase\\n\\n/**\\n * @title IImplementation\\n * @dev Implementation interface that must be followed for implementations to be registered in the Mimic Registry\\n */\\ninterface IImplementation {\\n    /**\\n     * @dev Tells the namespace under which the implementation is registered in the Mimic Registry\\n     */\\n    function NAMESPACE() external view returns (bytes32);\\n\\n    /**\\n     * @dev Tells the address of the Mimic Registry\\n     */\\n    function registry() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-registry/contracts/implementations/InitializableAuthorizedImplementation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@mimic-fi/v2-helpers/contracts/auth/Authorizer.sol';\\n\\nimport './InitializableImplementation.sol';\\n\\n/**\\n * @title InitializableAuthorizedImplementation\\n * @dev InitializableImplementation using the Authorizer mixin. Initializable implementations that want to use the\\n * Authorizer permissions mechanism should inherit from this contract instead.\\n */\\nabstract contract InitializableAuthorizedImplementation is InitializableImplementation, Authorizer {\\n    /**\\n     * @dev Creates a new InitializableAuthorizedImplementation\\n     * @param registry Address of the Mimic Registry\\n     */\\n    constructor(address registry) InitializableImplementation(registry) {\\n        // solhint-disable-previous-line no-empty-blocks\\n    }\\n\\n    /**\\n     * @dev Initialization function that authorizes an admin account to authorize and unauthorize accounts.\\n     * Note this function can only be called from a function marked with the `initializer` modifier.\\n     * @param admin Address to be granted authorize and unauthorize permissions\\n     */\\n    function _initialize(address admin) internal onlyInitializing {\\n        _initialize();\\n        _authorize(admin, Authorizer.authorize.selector);\\n        _authorize(admin, Authorizer.unauthorize.selector);\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-registry/contracts/implementations/InitializableImplementation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/proxy/utils/Initializable.sol';\\n\\nimport './BaseImplementation.sol';\\n\\n/**\\n * @title InitializableImplementation\\n * @dev Implementation contract to be used through proxies. Inheriting contracts are meant to be initialized through\\n * initialization functions instead of constructor functions. It allows re-using the same logic contract while making\\n * deployments cheaper.\\n */\\nabstract contract InitializableImplementation is BaseImplementation, Initializable {\\n    /**\\n     * @dev Creates a new BaseImplementation. Note that initializers are disabled at creation time.\\n     */\\n    constructor(address registry) BaseImplementation(registry) {\\n        _disableInitializers();\\n    }\\n\\n    /**\\n     * @dev Initialization function.\\n     * Note this function can only be called from a function marked with the `initializer` modifier.\\n     */\\n    function _initialize() internal view onlyInitializing {\\n        // solhint-disable-previous-line no-empty-blocks\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-registry/contracts/registry/IRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.8.0;\\n\\nimport '@mimic-fi/v2-helpers/contracts/auth/IAuthorizer.sol';\\n\\n/**\\n * @title IRegistry\\n * @dev Registry interface, it must follow the IAuthorizer interface.\\n */\\ninterface IRegistry is IAuthorizer {\\n    /**\\n     * @dev Emitted every time a new implementation is registered\\n     */\\n    event Registered(bytes32 indexed namespace, address indexed implementation, bool stateless);\\n\\n    /**\\n     * @dev Emitted every time an implementation is deprecated\\n     */\\n    event Deprecated(bytes32 indexed namespace, address indexed implementation);\\n\\n    /**\\n     * @dev Tells the data of an implementation:\\n     * @param implementation Address of the implementation to request it's data\\n     */\\n    function implementationData(address implementation)\\n        external\\n        view\\n        returns (bool stateless, bool deprecated, bytes32 namespace);\\n\\n    /**\\n     * @dev Tells if a specific implementation is registered under a certain namespace and it's not deprecated\\n     * @param namespace Namespace asking for\\n     * @param implementation Address of the implementation to be checked\\n     */\\n    function isActive(bytes32 namespace, address implementation) external view returns (bool);\\n\\n    /**\\n     * @dev Registers a new implementation for a given namespace\\n     * @param namespace Namespace to be used for the implementation\\n     * @param implementation Address of the implementation to be registered\\n     * @param stateless Whether the implementation is stateless or not\\n     */\\n    function register(bytes32 namespace, address implementation, bool stateless) external;\\n\\n    /**\\n     * @dev Deprecates a registered implementation\\n     * @param implementation Address of the implementation to be deprecated\\n     */\\n    function deprecate(address implementation) external;\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-smart-vault/contracts/helpers/BridgeConnectorLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/utils/Address.sol';\\n\\nimport '@mimic-fi/v2-bridge-connector/contracts/IBridgeConnector.sol';\\n\\n/**\\n * @title BridgeConnectorLib\\n * @dev Library used to delegate-call bridge ops and decode return data correctly\\n */\\nlibrary BridgeConnectorLib {\\n    /**\\n     * @dev Delegate-calls a bridge to the bridge connector and decodes de expected data\\n     * IMPORTANT! This helper method does not check any of the given params, these should be checked beforehand.\\n     */\\n    function bridge(\\n        address connector,\\n        uint8 source,\\n        uint256 chainId,\\n        address token,\\n        uint256 amountIn,\\n        uint256 minAmountOut,\\n        address recipient,\\n        bytes memory data\\n    ) internal {\\n        bytes memory bridgeData = abi.encodeWithSelector(\\n            IBridgeConnector.bridge.selector,\\n            source,\\n            chainId,\\n            token,\\n            amountIn,\\n            minAmountOut,\\n            recipient,\\n            data\\n        );\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = connector.delegatecall(bridgeData);\\n        Address.verifyCallResult(success, returndata, 'BRIDGE_CALL_REVERTED');\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-smart-vault/contracts/helpers/StrategyLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/utils/Address.sol';\\n\\nimport '@mimic-fi/v2-strategies/contracts/IStrategy.sol';\\n\\n/**\\n * @title StrategyLib\\n * @dev Library used to delegate-call to strategy and decode return data correctly\\n */\\nlibrary StrategyLib {\\n    /**\\n     * @dev Delegate-calls a claim to a strategy and decodes de expected data\\n     * IMPORTANT! This helper method does not check any of the given params, these should be checked beforehand.\\n     */\\n    function claim(address strategy, bytes memory data) internal returns (address[] memory, uint256[] memory) {\\n        bytes memory claimData = abi.encodeWithSelector(IStrategy.claim.selector, data);\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = strategy.delegatecall(claimData);\\n        Address.verifyCallResult(success, returndata, 'CLAIM_CALL_REVERTED');\\n        return abi.decode(returndata, (address[], uint256[]));\\n    }\\n\\n    /**\\n     * @dev Delegate-calls a join to a strategy and decodes de expected data\\n     * IMPORTANT! This helper method does not check any of the given params, these should be checked beforehand.\\n     */\\n    function join(\\n        address strategy,\\n        address[] memory tokensIn,\\n        uint256[] memory amountsIn,\\n        uint256 slippage,\\n        bytes memory data\\n    ) internal returns (address[] memory tokensOut, uint256[] memory amountsOut, uint256 value) {\\n        bytes memory joinData = abi.encodeWithSelector(IStrategy.join.selector, tokensIn, amountsIn, slippage, data);\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = strategy.delegatecall(joinData);\\n        Address.verifyCallResult(success, returndata, 'JOIN_CALL_REVERTED');\\n        return abi.decode(returndata, (address[], uint256[], uint256));\\n    }\\n\\n    /**\\n     * @dev Delegate-calls a exit to a strategy and decodes de expected data\\n     * IMPORTANT! This helper method does not check any of the given params, these should be checked beforehand.\\n     */\\n    function exit(\\n        address strategy,\\n        address[] memory tokensIn,\\n        uint256[] memory amountsIn,\\n        uint256 slippage,\\n        bytes memory data\\n    ) internal returns (address[] memory tokensOut, uint256[] memory amountsOut, uint256 value) {\\n        bytes memory exitData = abi.encodeWithSelector(IStrategy.exit.selector, tokensIn, amountsIn, slippage, data);\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = strategy.delegatecall(exitData);\\n        Address.verifyCallResult(success, returndata, 'EXIT_CALL_REVERTED');\\n        return abi.decode(returndata, (address[], uint256[], uint256));\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-smart-vault/contracts/helpers/SwapConnectorLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/utils/Address.sol';\\n\\nimport '@mimic-fi/v2-swap-connector/contracts/ISwapConnector.sol';\\n\\n/**\\n * @title SwapConnectorLib\\n * @dev Library used to delegate-call swaps and decode return data correctly\\n */\\nlibrary SwapConnectorLib {\\n    /**\\n     * @dev Delegate-calls a swap to the swap connector and decodes de expected data\\n     * IMPORTANT! This helper method does not check any of the given params, these should be checked beforehand.\\n     */\\n    function swap(\\n        address connector,\\n        uint8 source,\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 amountIn,\\n        uint256 minAmountOut,\\n        bytes memory data\\n    ) internal returns (uint256 amountOut) {\\n        bytes memory swapData = abi.encodeWithSelector(\\n            ISwapConnector.swap.selector,\\n            source,\\n            tokenIn,\\n            tokenOut,\\n            amountIn,\\n            minAmountOut,\\n            data\\n        );\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = connector.delegatecall(swapData);\\n        Address.verifyCallResult(success, returndata, 'SWAP_CALL_REVERTED');\\n        return abi.decode(returndata, (uint256));\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-smart-vault/contracts/ISmartVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@mimic-fi/v2-helpers/contracts/auth/IAuthorizer.sol';\\nimport '@mimic-fi/v2-price-oracle/contracts/feeds/IPriceFeedProvider.sol';\\nimport '@mimic-fi/v2-registry/contracts/implementations/IImplementation.sol';\\n\\n/**\\n * @title ISmartVault\\n * @dev Mimic Smart Vault interface to manage assets. It must support also `IImplementation` and `IAuthorizer`\\n */\\ninterface ISmartVault is IPriceFeedProvider, IImplementation, IAuthorizer {\\n    enum SwapLimit {\\n        Slippage,\\n        MinAmountOut\\n    }\\n\\n    enum BridgeLimit {\\n        Slippage,\\n        MinAmountOut\\n    }\\n\\n    /**\\n     * @dev Emitted every time a new strategy is set for the Smart Vault\\n     */\\n    event StrategySet(address indexed strategy, bool allowed);\\n\\n    /**\\n     * @dev Emitted every time a new price oracle is set for the Smart Vault\\n     */\\n    event PriceOracleSet(address indexed priceOracle);\\n\\n    /**\\n     * @dev Emitted every time a new swap connector is set for the Smart Vault\\n     */\\n    event SwapConnectorSet(address indexed swapConnector);\\n\\n    /**\\n     * @dev Emitted every time a new bridge connector is set for the Smart Vault\\n     */\\n    event BridgeConnectorSet(address indexed bridgeConnector);\\n\\n    /**\\n     * @dev Emitted every time a new fee collector is set\\n     */\\n    event FeeCollectorSet(address indexed feeCollector);\\n\\n    /**\\n     * @dev Emitted every time the withdraw fee percentage is set\\n     */\\n    event WithdrawFeeSet(uint256 pct, uint256 cap, address token, uint256 period);\\n\\n    /**\\n     * @dev Emitted every time the performance fee percentage is set\\n     */\\n    event PerformanceFeeSet(uint256 pct, uint256 cap, address token, uint256 period);\\n\\n    /**\\n     * @dev Emitted every time the swap fee percentage is set\\n     */\\n    event SwapFeeSet(uint256 pct, uint256 cap, address token, uint256 period);\\n\\n    /**\\n     * @dev Emitted every time the bridge fee percentage is set\\n     */\\n    event BridgeFeeSet(uint256 pct, uint256 cap, address token, uint256 period);\\n\\n    /**\\n     * @dev Emitted every time `call` is called\\n     */\\n    event Call(address indexed target, bytes callData, uint256 value, bytes result, bytes data);\\n\\n    /**\\n     * @dev Emitted every time `collect` is called\\n     */\\n    event Collect(address indexed token, address indexed from, uint256 collected, bytes data);\\n\\n    /**\\n     * @dev Emitted every time `withdraw` is called\\n     */\\n    event Withdraw(address indexed token, address indexed recipient, uint256 withdrawn, uint256 fee, bytes data);\\n\\n    /**\\n     * @dev Emitted every time `wrap` is called\\n     */\\n    event Wrap(uint256 amount, uint256 wrapped, bytes data);\\n\\n    /**\\n     * @dev Emitted every time `unwrap` is called\\n     */\\n    event Unwrap(uint256 amount, uint256 unwrapped, bytes data);\\n\\n    /**\\n     * @dev Emitted every time `claim` is called\\n     */\\n    event Claim(address indexed strategy, address[] tokens, uint256[] amounts, bytes data);\\n\\n    /**\\n     * @dev Emitted every time `join` is called\\n     */\\n    event Join(\\n        address indexed strategy,\\n        address[] tokensIn,\\n        uint256[] amountsIn,\\n        address[] tokensOut,\\n        uint256[] amountsOut,\\n        uint256 value,\\n        uint256 slippage,\\n        bytes data\\n    );\\n\\n    /**\\n     * @dev Emitted every time `exit` is called\\n     */\\n    event Exit(\\n        address indexed strategy,\\n        address[] tokensIn,\\n        uint256[] amountsIn,\\n        address[] tokensOut,\\n        uint256[] amountsOut,\\n        uint256 value,\\n        uint256[] fees,\\n        uint256 slippage,\\n        bytes data\\n    );\\n\\n    /**\\n     * @dev Emitted every time `swap` is called\\n     */\\n    event Swap(\\n        uint8 indexed source,\\n        address indexed tokenIn,\\n        address indexed tokenOut,\\n        uint256 amountIn,\\n        uint256 amountOut,\\n        uint256 minAmountOut,\\n        uint256 fee,\\n        bytes data\\n    );\\n\\n    /**\\n     * @dev Emitted every time `bridge` is called\\n     */\\n    event Bridge(\\n        uint8 indexed source,\\n        uint256 indexed chainId,\\n        address indexed token,\\n        uint256 amountIn,\\n        uint256 minAmountOut,\\n        uint256 fee,\\n        address recipient,\\n        bytes data\\n    );\\n\\n    /**\\n     * @dev Tells a strategy is allowed or not\\n     * @param strategy Address of the strategy being queried\\n     */\\n    function isStrategyAllowed(address strategy) external view returns (bool);\\n\\n    /**\\n     * @dev Tells the invested value for a strategy\\n     * @param strategy Address of the strategy querying the invested value of\\n     */\\n    function investedValue(address strategy) external view returns (uint256);\\n\\n    /**\\n     * @dev Tells the last value accrued for a strategy. Note this value can be outdated.\\n     * @param strategy Address of the strategy querying the last value of\\n     */\\n    function lastValue(address strategy) external view returns (uint256);\\n\\n    /**\\n     * @dev Tells the price oracle associated to a Smart Vault\\n     */\\n    function priceOracle() external view returns (address);\\n\\n    /**\\n     * @dev Tells the swap connector associated to a Smart Vault\\n     */\\n    function swapConnector() external view returns (address);\\n\\n    /**\\n     * @dev Tells the bridge connector associated to a Smart Vault\\n     */\\n    function bridgeConnector() external view returns (address);\\n\\n    /**\\n     * @dev Tells the address where fees will be deposited\\n     */\\n    function feeCollector() external view returns (address);\\n\\n    /**\\n     * @dev Tells the withdraw fee configuration\\n     */\\n    function withdrawFee()\\n        external\\n        view\\n        returns (uint256 pct, uint256 cap, address token, uint256 period, uint256 totalCharged, uint256 nextResetTime);\\n\\n    /**\\n     * @dev Tells the performance fee configuration\\n     */\\n    function performanceFee()\\n        external\\n        view\\n        returns (uint256 pct, uint256 cap, address token, uint256 period, uint256 totalCharged, uint256 nextResetTime);\\n\\n    /**\\n     * @dev Tells the swap fee configuration\\n     */\\n    function swapFee()\\n        external\\n        view\\n        returns (uint256 pct, uint256 cap, address token, uint256 period, uint256 totalCharged, uint256 nextResetTime);\\n\\n    /**\\n     * @dev Tells the bridge fee configuration\\n     */\\n    function bridgeFee()\\n        external\\n        view\\n        returns (uint256 pct, uint256 cap, address token, uint256 period, uint256 totalCharged, uint256 nextResetTime);\\n\\n    /**\\n     * @dev Tells the address of the wrapped native token\\n     */\\n    function wrappedNativeToken() external view returns (address);\\n\\n    /**\\n     * @dev Sets a new strategy as allowed or not for a Smart Vault\\n     * @param strategy Address of the strategy to be set\\n     * @param allowed Whether the strategy is allowed or not\\n     */\\n    function setStrategy(address strategy, bool allowed) external;\\n\\n    /**\\n     * @dev Sets a new price oracle to a Smart Vault\\n     * @param newPriceOracle Address of the new price oracle to be set\\n     */\\n    function setPriceOracle(address newPriceOracle) external;\\n\\n    /**\\n     * @dev Sets a new swap connector to a Smart Vault\\n     * @param newSwapConnector Address of the new swap connector to be set\\n     */\\n    function setSwapConnector(address newSwapConnector) external;\\n\\n    /**\\n     * @dev Sets a new bridge connector to a Smart Vault\\n     * @param newBridgeConnector Address of the new bridge connector to be set\\n     */\\n    function setBridgeConnector(address newBridgeConnector) external;\\n\\n    /**\\n     * @dev Sets a new fee collector\\n     * @param newFeeCollector Address of the new fee collector to be set\\n     */\\n    function setFeeCollector(address newFeeCollector) external;\\n\\n    /**\\n     * @dev Sets a new withdraw fee configuration\\n     * @param pct Withdraw fee percentage to be set\\n     * @param cap New maximum amount of withdraw fees to be charged per period\\n     * @param token Address of the token cap to be set\\n     * @param period New cap period length in seconds for the withdraw fee\\n     */\\n    function setWithdrawFee(uint256 pct, uint256 cap, address token, uint256 period) external;\\n\\n    /**\\n     * @dev Sets a new performance fee configuration\\n     * @param pct Performance fee percentage to be set\\n     * @param cap New maximum amount of performance fees to be charged per period\\n     * @param token Address of the token cap to be set\\n     * @param period New cap period length in seconds for the performance fee\\n     */\\n    function setPerformanceFee(uint256 pct, uint256 cap, address token, uint256 period) external;\\n\\n    /**\\n     * @dev Sets a new swap fee configuration\\n     * @param pct Swap fee percentage to be set\\n     * @param cap New maximum amount of swap fees to be charged per period\\n     * @param token Address of the token cap to be set\\n     * @param period New cap period length in seconds for the swap fee\\n     */\\n    function setSwapFee(uint256 pct, uint256 cap, address token, uint256 period) external;\\n\\n    /**\\n     * @dev Sets a new bridge fee configuration\\n     * @param pct Bridge fee percentage to be set\\n     * @param cap New maximum amount of bridge fees to be charged per period\\n     * @param token Address of the token cap to be set\\n     * @param period New cap period length in seconds for the bridge fee\\n     */\\n    function setBridgeFee(uint256 pct, uint256 cap, address token, uint256 period) external;\\n\\n    /**\\n     * @dev Tells the price of a token (base) in a given quote\\n     * @param base Token to rate\\n     * @param quote Token used for the price rate\\n     */\\n    function getPrice(address base, address quote) external view returns (uint256);\\n\\n    /**\\n     * @dev Execute an arbitrary call from a Smart Vault\\n     * @param target Address where the call will be sent\\n     * @param callData Calldata to be used for the call\\n     * @param value Value in wei that will be attached to the call\\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\\n     * @return result Call response if it was successful, otherwise it reverts\\n     */\\n    function call(address target, bytes memory callData, uint256 value, bytes memory data)\\n        external\\n        returns (bytes memory result);\\n\\n    /**\\n     * @dev Collect tokens from a sender to a Smart Vault\\n     * @param token Address of the token to be collected\\n     * @param from Address where the tokens will be transfer from\\n     * @param amount Amount of tokens to be transferred\\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\\n     * @return collected Amount of tokens assigned to the Smart Vault\\n     */\\n    function collect(address token, address from, uint256 amount, bytes memory data)\\n        external\\n        returns (uint256 collected);\\n\\n    /**\\n     * @dev Withdraw tokens to an external account\\n     * @param token Address of the token to be withdrawn\\n     * @param amount Amount of tokens to withdraw\\n     * @param recipient Address where the tokens will be transferred to\\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\\n     * @return withdrawn Amount of tokens transferred to the recipient address\\n     */\\n    function withdraw(address token, uint256 amount, address recipient, bytes memory data)\\n        external\\n        returns (uint256 withdrawn);\\n\\n    /**\\n     * @dev Wrap an amount of native tokens to the wrapped ERC20 version of it\\n     * @param amount Amount of native tokens to be wrapped\\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\\n     * @return wrapped Amount of tokens wrapped\\n     */\\n    function wrap(uint256 amount, bytes memory data) external returns (uint256 wrapped);\\n\\n    /**\\n     * @dev Unwrap an amount of wrapped native tokens\\n     * @param amount Amount of wrapped native tokens to unwrapped\\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\\n     * @return unwrapped Amount of tokens unwrapped\\n     */\\n    function unwrap(uint256 amount, bytes memory data) external returns (uint256 unwrapped);\\n\\n    /**\\n     * @dev Claim strategy rewards\\n     * @param strategy Address of the strategy to claim rewards\\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\\n     * @return tokens Addresses of the tokens received as rewards\\n     * @return amounts Amounts of the tokens received as rewards\\n     */\\n    function claim(address strategy, bytes memory data)\\n        external\\n        returns (address[] memory tokens, uint256[] memory amounts);\\n\\n    /**\\n     * @dev Join a strategy with an amount of tokens\\n     * @param strategy Address of the strategy to join\\n     * @param tokensIn List of token addresses to join with\\n     * @param amountsIn List of token amounts to join with\\n     * @param slippage Slippage that will be used to compute the join\\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\\n     * @return tokensOut List of token addresses received after the join\\n     * @return amountsOut List of token amounts received after the join\\n     */\\n    function join(\\n        address strategy,\\n        address[] memory tokensIn,\\n        uint256[] memory amountsIn,\\n        uint256 slippage,\\n        bytes memory data\\n    ) external returns (address[] memory tokensOut, uint256[] memory amountsOut);\\n\\n    /**\\n     * @dev Exit a strategy\\n     * @param strategy Address of the strategy to exit\\n     * @param tokensIn List of token addresses to exit with\\n     * @param amountsIn List of token amounts to exit with\\n     * @param slippage Slippage that will be used to compute the exit\\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\\n     * @return tokensOut List of token addresses received after the exit\\n     * @return amountsOut List of token amounts received after the exit\\n     */\\n    function exit(\\n        address strategy,\\n        address[] memory tokensIn,\\n        uint256[] memory amountsIn,\\n        uint256 slippage,\\n        bytes memory data\\n    ) external returns (address[] memory tokensOut, uint256[] memory amountsOut);\\n\\n    /**\\n     * @dev Swaps two tokens\\n     * @param source Source to request the swap. It depends on the Swap Connector attached to a Smart Vault.\\n     * @param tokenIn Token being sent\\n     * @param tokenOut Token being received\\n     * @param amountIn Amount of tokenIn being swapped\\n     * @param limitType Swap limit to be applied: slippage or min amount out\\n     * @param limitAmount Amount of the swap limit to be applied depending on limitType\\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\\n     * @return amountOut Received amount of tokens out\\n     */\\n    function swap(\\n        uint8 source,\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 amountIn,\\n        SwapLimit limitType,\\n        uint256 limitAmount,\\n        bytes memory data\\n    ) external returns (uint256 amountOut);\\n\\n    /**\\n     * @dev Bridge assets to another chain\\n     * @param source Source to request the bridge. It depends on the Bridge Connector attached to a Smart Vault.\\n     * @param chainId ID of the destination chain\\n     * @param token Address of the token to be bridged\\n     * @param amount Amount of tokens to be bridged\\n     * @param limitType Swap limit to be applied: slippage or min amount out\\n     * @param limitAmount Amount of the swap limit to be applied depending on limitType\\n     * @param recipient Address that will receive the tokens on the destination chain\\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\\n     * @return bridged Amount requested to be bridged after fees\\n     */\\n    function bridge(\\n        uint8 source,\\n        uint256 chainId,\\n        address token,\\n        uint256 amount,\\n        BridgeLimit limitType,\\n        uint256 limitAmount,\\n        address recipient,\\n        bytes memory data\\n    ) external returns (uint256 bridged);\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-smart-vault/contracts/ISmartVaultsFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.8.0;\\n\\nimport '@mimic-fi/v2-registry/contracts/implementations/IImplementation.sol';\\n\\n/**\\n * @title ISmartVaultsFactory\\n * @dev Smart Vaults Factory interface, it must follow the IImplementation interface.\\n */\\ninterface ISmartVaultsFactory is IImplementation {\\n    /**\\n     * @dev Emitted every time a new Smart Vault instance is created\\n     */\\n    event Created(address indexed implementation, address indexed instance, bytes initializeResult);\\n\\n    /**\\n     * @dev Tells the implementation associated to a contract instance\\n     * @param instance Address of the instance to request it's implementation\\n     */\\n    function implementationOf(address instance) external view returns (address);\\n\\n    /**\\n     * @dev Creates a new Smart Vault pointing to a registered implementation\\n     * @param salt Salt bytes to derivate the address of the new instance\\n     * @param implementation Address of the implementation to be instanced\\n     * @param initializeData Arbitrary data to be sent after deployment\\n     * @return instance Address of the new instance created\\n     */\\n    function create(bytes32 salt, address implementation, bytes memory initializeData) external returns (address);\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-smart-vault/contracts/SmartVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\\nimport '@openzeppelin/contracts/utils/Address.sol';\\nimport '@openzeppelin/contracts/utils/math/Math.sol';\\n\\nimport '@mimic-fi/v2-bridge-connector/contracts/IBridgeConnector.sol';\\nimport '@mimic-fi/v2-helpers/contracts/math/FixedPoint.sol';\\nimport '@mimic-fi/v2-helpers/contracts/math/UncheckedMath.sol';\\nimport '@mimic-fi/v2-helpers/contracts/utils/Denominations.sol';\\nimport '@mimic-fi/v2-helpers/contracts/utils/IWrappedNativeToken.sol';\\nimport '@mimic-fi/v2-price-oracle/contracts/oracle/IPriceOracle.sol';\\nimport '@mimic-fi/v2-price-oracle/contracts/feeds/PriceFeedProvider.sol';\\nimport '@mimic-fi/v2-strategies/contracts/IStrategy.sol';\\nimport '@mimic-fi/v2-swap-connector/contracts/ISwapConnector.sol';\\nimport '@mimic-fi/v2-registry/contracts/implementations/InitializableAuthorizedImplementation.sol';\\n\\nimport './ISmartVault.sol';\\nimport './helpers/StrategyLib.sol';\\nimport './helpers/SwapConnectorLib.sol';\\nimport './helpers/BridgeConnectorLib.sol';\\n\\n/**\\n * @title Smart Vault\\n * @dev Smart Vault contract where funds are being held offering a bunch of primitives to allow users model any\\n * type of action to manage them, these are: collector, withdraw, swap, bridge, join, exit, bridge, wrap, and unwrap.\\n *\\n * It inherits from InitializableAuthorizedImplementation which means it's implementation can be cloned\\n * from the Mimic Registry and should be initialized depending on each case.\\n */\\ncontract SmartVault is ISmartVault, PriceFeedProvider, InitializableAuthorizedImplementation {\\n    using SafeERC20 for IERC20;\\n    using FixedPoint for uint256;\\n    using UncheckedMath for uint256;\\n    using StrategyLib for address;\\n    using SwapConnectorLib for address;\\n    using BridgeConnectorLib for address;\\n\\n    // Namespace under which the Smart Vault is registered in the Mimic Registry\\n    bytes32 public constant override NAMESPACE = keccak256('SMART_VAULT');\\n\\n    /**\\n     * @dev Fee configuration parameters\\n     * @param pct Percentage expressed using 16 decimals (1e18 = 100%)\\n     * @param cap Maximum amount of fees to be charged per period\\n     * @param token Address of the token to express the cap amount\\n     * @param period Period length in seconds\\n     * @param totalCharged Total amount of fees charged in the current period\\n     * @param nextResetTime Current cap period end date\\n     */\\n    struct Fee {\\n        uint256 pct;\\n        uint256 cap;\\n        address token;\\n        uint256 period;\\n        uint256 totalCharged;\\n        uint256 nextResetTime;\\n    }\\n\\n    // Price oracle reference\\n    address public override priceOracle;\\n\\n    // Swap connector reference\\n    address public override swapConnector;\\n\\n    // Bridge connector reference\\n    address public override bridgeConnector;\\n\\n    // List of allowed strategies indexed by strategy address\\n    mapping (address => bool) public override isStrategyAllowed;\\n\\n    // List of invested values indexed by strategy address\\n    mapping (address => uint256) public override investedValue;\\n\\n    // Fee collector address where fees will be deposited\\n    address public override feeCollector;\\n\\n    // Withdraw fee configuration\\n    Fee public override withdrawFee;\\n\\n    // Performance fee configuration\\n    Fee public override performanceFee;\\n\\n    // Swap fee configuration\\n    Fee public override swapFee;\\n\\n    // Bridge fee configuration\\n    Fee public override bridgeFee;\\n\\n    // Wrapped native token reference\\n    address public immutable override wrappedNativeToken;\\n\\n    /**\\n     * @dev Creates a new Smart Vault implementation with references that should be shared among all implementations\\n     * @param _wrappedNativeToken Address of the wrapped native token to be used\\n     * @param _registry Address of the Mimic Registry to be referenced\\n     */\\n    constructor(address _wrappedNativeToken, address _registry) InitializableAuthorizedImplementation(_registry) {\\n        wrappedNativeToken = _wrappedNativeToken;\\n    }\\n\\n    /**\\n     * @dev Initializes the Smart Vault instance\\n     * @param admin Address that will be granted with admin rights\\n     */\\n    function initialize(address admin) external initializer {\\n        _initialize(admin);\\n    }\\n\\n    /**\\n     * @dev It allows receiving native token transfers\\n     */\\n    receive() external payable {\\n        // solhint-disable-previous-line no-empty-blocks\\n    }\\n\\n    /**\\n     * @dev Sets a new strategy as allowed or not for a Smart Vault. Sender must be authorized.\\n     * @param strategy Address of the strategy to be set\\n     * @param allowed Whether the strategy is allowed or not\\n     */\\n    function setStrategy(address strategy, bool allowed) external override auth {\\n        _setStrategy(strategy, allowed);\\n    }\\n\\n    /**\\n     * @dev Sets a new price oracle to a Smart Vault. Sender must be authorized.\\n     * @param newPriceOracle Address of the new price oracle to be set\\n     */\\n    function setPriceOracle(address newPriceOracle) external override auth {\\n        _setPriceOracle(newPriceOracle);\\n    }\\n\\n    /**\\n     * @dev Sets a new swap connector to a Smart Vault. Sender must be authorized.\\n     * @param newSwapConnector Address of the new swap connector to be set\\n     */\\n    function setSwapConnector(address newSwapConnector) external override auth {\\n        _setSwapConnector(newSwapConnector);\\n    }\\n\\n    /**\\n     * @dev Sets a new bridge connector to a Smart Vault. Sender must be authorized.\\n     * @param newBridgeConnector Address of the new bridge connector to be set\\n     */\\n    function setBridgeConnector(address newBridgeConnector) external override auth {\\n        _setBridgeConnector(newBridgeConnector);\\n    }\\n\\n    /**\\n     * @dev Sets a new fee collector. Sender must be authorized.\\n     * @param newFeeCollector Address of the new fee collector to be set\\n     */\\n    function setFeeCollector(address newFeeCollector) external override auth {\\n        _setFeeCollector(newFeeCollector);\\n    }\\n\\n    /**\\n     * @dev Sets a new withdraw fee. Sender must be authorized.\\n     * @param pct Withdraw fee percentage to be set\\n     * @param cap New maximum amount of withdraw fees to be charged per period\\n     * @param token Address of the token cap to be set\\n     * @param period New cap period length in seconds for the withdraw fee\\n     */\\n    function setWithdrawFee(uint256 pct, uint256 cap, address token, uint256 period) external override auth {\\n        _setFeeConfiguration(withdrawFee, pct, cap, token, period);\\n        emit WithdrawFeeSet(pct, cap, token, period);\\n    }\\n\\n    /**\\n     * @dev Sets a new performance fee. Sender must be authorized.\\n     * @param pct Performance fee percentage to be set\\n     * @param cap New maximum amount of performance fees to be charged per period\\n     * @param token Address of the token cap to be set\\n     * @param period New cap period length in seconds for the performance fee\\n     */\\n    function setPerformanceFee(uint256 pct, uint256 cap, address token, uint256 period) external override auth {\\n        _setFeeConfiguration(performanceFee, pct, cap, token, period);\\n        emit PerformanceFeeSet(pct, cap, token, period);\\n    }\\n\\n    /**\\n     * @dev Sets a new swap fee. Sender must be authorized.\\n     * @param pct New swap fee percentage to be set\\n     * @param cap New maximum amount of swap fees to be charged per period\\n     * @param token Address of the token cap to be set\\n     * @param period New cap period length in seconds for the swap fee\\n     */\\n    function setSwapFee(uint256 pct, uint256 cap, address token, uint256 period) external override auth {\\n        _setFeeConfiguration(swapFee, pct, cap, token, period);\\n        emit SwapFeeSet(pct, cap, token, period);\\n    }\\n\\n    /**\\n     * @dev Sets a new bridge fee. Sender must be authorized.\\n     * @param pct New bridge fee percentage to be set\\n     * @param cap New maximum amount of bridge fees to be charged per period\\n     * @param token Address of the token cap to be set\\n     * @param period New cap period length in seconds for the bridge fee\\n     */\\n    function setBridgeFee(uint256 pct, uint256 cap, address token, uint256 period) external override auth {\\n        _setFeeConfiguration(bridgeFee, pct, cap, token, period);\\n        emit BridgeFeeSet(pct, cap, token, period);\\n    }\\n\\n    /**\\n     * @dev Sets a of price feed\\n     * @param base Token base to be set\\n     * @param quote Token quote to be set\\n     * @param feed Price feed to be set\\n     */\\n    function setPriceFeed(address base, address quote, address feed)\\n        public\\n        override(IPriceFeedProvider, PriceFeedProvider)\\n        auth\\n    {\\n        super.setPriceFeed(base, quote, feed);\\n    }\\n\\n    /**\\n     * @dev Tells the price of a token (base) in a given quote\\n     * @param base Token to rate\\n     * @param quote Token used for the price rate\\n     */\\n    function getPrice(address base, address quote) public view override returns (uint256) {\\n        return IPriceOracle(priceOracle).getPrice(address(this), base, quote);\\n    }\\n\\n    /**\\n     * @dev Tells the last value accrued for a strategy. Note this value can be outdated.\\n     * @param strategy Address of the strategy querying the last value of\\n     */\\n    function lastValue(address strategy) public view override returns (uint256) {\\n        return IStrategy(strategy).lastValue(address(this));\\n    }\\n\\n    /**\\n     * @dev Execute an arbitrary call from a Smart Vault. Sender must be authorized.\\n     * @param target Address where the call will be sent\\n     * @param data Calldata to be used for the call\\n     * @param value Value in wei that will be attached to the call\\n     * @return result Call response if it was successful, otherwise it reverts\\n     */\\n    function call(address target, bytes memory callData, uint256 value, bytes memory data)\\n        external\\n        override\\n        auth\\n        returns (bytes memory result)\\n    {\\n        result = Address.functionCallWithValue(target, callData, value, 'SMART_VAULT_ARBITRARY_CALL_FAIL');\\n        emit Call(target, callData, value, result, data);\\n    }\\n\\n    /**\\n     * @dev Collect tokens from an external account to a Smart Vault. Sender must be authorized.\\n     * @param token Address of the token to be collected\\n     * @param from Address where the tokens will be transfer from\\n     * @param amount Amount of tokens to be transferred\\n     * @param data Extra data only logged\\n     * @return collected Amount of tokens collected\\n     */\\n    function collect(address token, address from, uint256 amount, bytes memory data)\\n        external\\n        override\\n        auth\\n        returns (uint256 collected)\\n    {\\n        require(amount > 0, 'COLLECT_AMOUNT_ZERO');\\n\\n        uint256 previousBalance = IERC20(token).balanceOf(address(this));\\n        IERC20(token).safeTransferFrom(from, address(this), amount);\\n        uint256 currentBalance = IERC20(token).balanceOf(address(this));\\n\\n        collected = currentBalance - previousBalance;\\n        emit Collect(token, from, collected, data);\\n    }\\n\\n    /**\\n     * @dev Withdraw tokens to an external account. Sender must be authorized.\\n     * @param token Address of the token to be withdrawn\\n     * @param amount Amount of tokens to withdraw\\n     * @param recipient Address where the tokens will be transferred to\\n     * @param data Extra data only logged\\n     * @return withdrawn Amount of tokens transferred to the recipient address\\n     */\\n    function withdraw(address token, uint256 amount, address recipient, bytes memory data)\\n        external\\n        override\\n        auth\\n        returns (uint256 withdrawn)\\n    {\\n        require(amount > 0, 'WITHDRAW_AMOUNT_ZERO');\\n        require(recipient != address(0), 'RECIPIENT_ZERO');\\n\\n        uint256 withdrawFeeAmount = recipient == feeCollector ? 0 : _payFee(token, amount, withdrawFee);\\n        withdrawn = amount - withdrawFeeAmount;\\n        _safeTransfer(token, recipient, withdrawn);\\n        emit Withdraw(token, recipient, withdrawn, withdrawFeeAmount, data);\\n    }\\n\\n    /**\\n     * @dev Wrap an amount of native tokens to the wrapped ERC20 version of it. Sender must be authorized.\\n     * @param amount Amount of native tokens to be wrapped\\n     * @param data Extra data only logged\\n     * @return wrapped Amount of tokens wrapped\\n     */\\n    function wrap(uint256 amount, bytes memory data) external override auth returns (uint256 wrapped) {\\n        require(amount > 0, 'WRAP_AMOUNT_ZERO');\\n        require(address(this).balance >= amount, 'WRAP_INSUFFICIENT_AMOUNT');\\n\\n        IWrappedNativeToken wrappedToken = IWrappedNativeToken(wrappedNativeToken);\\n        uint256 previousBalance = wrappedToken.balanceOf(address(this));\\n        wrappedToken.deposit{ value: amount }();\\n        uint256 currentBalance = wrappedToken.balanceOf(address(this));\\n\\n        wrapped = currentBalance - previousBalance;\\n        emit Wrap(amount, wrapped, data);\\n    }\\n\\n    /**\\n     * @dev Unwrap an amount of wrapped native tokens. Sender must be authorized.\\n     * @param amount Amount of wrapped native tokens to unwrapped\\n     * @param data Extra data only logged\\n     * @return unwrapped Amount of tokens unwrapped\\n     */\\n    function unwrap(uint256 amount, bytes memory data) external override auth returns (uint256 unwrapped) {\\n        require(amount > 0, 'UNWRAP_AMOUNT_ZERO');\\n\\n        uint256 previousBalance = address(this).balance;\\n        IWrappedNativeToken(wrappedNativeToken).withdraw(amount);\\n        uint256 currentBalance = address(this).balance;\\n\\n        unwrapped = currentBalance - previousBalance;\\n        emit Unwrap(amount, unwrapped, data);\\n    }\\n\\n    /**\\n     * @dev Claim strategy rewards. Sender must be authorized.\\n     * @param strategy Address of the strategy to claim rewards\\n     * @param data Extra data passed to the strategy and logged\\n     * @return tokens Addresses of the tokens received as rewards\\n     * @return amounts Amounts of the tokens received as rewards\\n     */\\n    function claim(address strategy, bytes memory data)\\n        external\\n        override\\n        auth\\n        returns (address[] memory tokens, uint256[] memory amounts)\\n    {\\n        require(isStrategyAllowed[strategy], 'STRATEGY_NOT_ALLOWED');\\n        (tokens, amounts) = strategy.claim(data);\\n        emit Claim(strategy, tokens, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Join a strategy with an amount of tokens. Sender must be authorized.\\n     * @param strategy Address of the strategy to join\\n     * @param tokensIn List of token addresses to join with\\n     * @param amountsIn List of token amounts to join with\\n     * @param slippage Slippage that will be used to compute the join\\n     * @param data Extra data passed to the strategy and logged\\n     * @return tokensOut List of token addresses received after the join\\n     * @return amountsOut List of token amounts received after the join\\n     */\\n    function join(\\n        address strategy,\\n        address[] memory tokensIn,\\n        uint256[] memory amountsIn,\\n        uint256 slippage,\\n        bytes memory data\\n    ) external override auth returns (address[] memory tokensOut, uint256[] memory amountsOut) {\\n        require(isStrategyAllowed[strategy], 'STRATEGY_NOT_ALLOWED');\\n        require(slippage <= FixedPoint.ONE, 'JOIN_SLIPPAGE_ABOVE_ONE');\\n        require(tokensIn.length == amountsIn.length, 'JOIN_INPUT_INVALID_LENGTH');\\n\\n        uint256 value;\\n        (tokensOut, amountsOut, value) = strategy.join(tokensIn, amountsIn, slippage, data);\\n        require(tokensOut.length == amountsOut.length, 'JOIN_OUTPUT_INVALID_LENGTH');\\n\\n        investedValue[strategy] = investedValue[strategy] + value;\\n        emit Join(strategy, tokensIn, amountsIn, tokensOut, amountsOut, value, slippage, data);\\n    }\\n\\n    /**\\n     * @dev Exit a strategy. Sender must be authorized.\\n     * @param strategy Address of the strategy to exit\\n     * @param tokensIn List of token addresses to exit with\\n     * @param amountsIn List of token amounts to exit with\\n     * @param slippage Slippage that will be used to compute the exit\\n     * @param data Extra data passed to the strategy and logged\\n     * @return tokensOut List of token addresses received after the exit\\n     * @return amountsOut List of token amounts received after the exit\\n     */\\n    function exit(\\n        address strategy,\\n        address[] memory tokensIn,\\n        uint256[] memory amountsIn,\\n        uint256 slippage,\\n        bytes memory data\\n    ) external override auth returns (address[] memory tokensOut, uint256[] memory amountsOut) {\\n        require(isStrategyAllowed[strategy], 'STRATEGY_NOT_ALLOWED');\\n        require(investedValue[strategy] > 0, 'EXIT_NO_INVESTED_VALUE');\\n        require(slippage <= FixedPoint.ONE, 'EXIT_SLIPPAGE_ABOVE_ONE');\\n        require(tokensIn.length == amountsIn.length, 'EXIT_INPUT_INVALID_LENGTH');\\n\\n        uint256 value;\\n        (tokensOut, amountsOut, value) = strategy.exit(tokensIn, amountsIn, slippage, data);\\n        require(tokensOut.length == amountsOut.length, 'EXIT_OUTPUT_INVALID_LENGTH');\\n        uint256[] memory performanceFeeAmounts = new uint256[](amountsOut.length);\\n\\n        // It can rely on the last updated value since we have just exited, no need to compute current value\\n        uint256 valueBeforeExit = lastValue(strategy) + value;\\n        if (valueBeforeExit <= investedValue[strategy]) {\\n            // There were losses, invested value is simply reduced using the exited ratio compared to the value\\n            // before exit. Invested value is round up to avoid interpreting losses due to rounding errors\\n            investedValue[strategy] -= investedValue[strategy].mulUp(value).divUp(valueBeforeExit);\\n        } else {\\n            // If value gains are greater than the exit value, it means only gains are being withdrawn. In that case\\n            // the taxable amount is the entire exited amount, otherwise it should be the equivalent gains ratio of it.\\n            uint256 valueGains = valueBeforeExit.uncheckedSub(investedValue[strategy]);\\n            bool onlyGains = valueGains >= value;\\n\\n            // If the exit value is greater than the value gains, the invested value should be reduced by the portion\\n            // of the invested value being exited. Otherwise, it's still the same, only gains are being withdrawn.\\n            // No need for checked math as we are checking it manually beforehand\\n            uint256 decrement = onlyGains ? 0 : value.uncheckedSub(valueGains);\\n            investedValue[strategy] = investedValue[strategy] - decrement;\\n\\n            // Compute performance fees per token out\\n            for (uint256 i = 0; i < tokensOut.length; i = i.uncheckedAdd(1)) {\\n                address token = tokensOut[i];\\n                uint256 amount = amountsOut[i];\\n                uint256 taxableAmount = onlyGains ? amount : ((amount * valueGains) / value);\\n                uint256 feeAmount = _payFee(token, taxableAmount, performanceFee);\\n                amountsOut[i] = amount - feeAmount;\\n                performanceFeeAmounts[i] = feeAmount;\\n            }\\n        }\\n\\n        emit Exit(strategy, tokensIn, amountsIn, tokensOut, amountsOut, value, performanceFeeAmounts, slippage, data);\\n    }\\n\\n    /**\\n     * @dev Swaps two tokens. Sender must be authorized.\\n     * @param source Source to request the swap: Uniswap V2, Uniswap V3, Balancer V2, or Paraswap V5.\\n     * @param tokenIn Token being sent\\n     * @param tokenOut Token being received\\n     * @param amountIn Amount of tokenIn being swapped\\n     * @param limitType Swap limit to be applied: slippage or min amount out\\n     * @param limitAmount Amount of the swap limit to be applied depending on limitType\\n     * @param data Encoded data to specify different swap parameters depending on the source picked\\n     * @return amountOut Received amount of tokens out\\n     */\\n    function swap(\\n        uint8 source,\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 amountIn,\\n        SwapLimit limitType,\\n        uint256 limitAmount,\\n        bytes memory data\\n    ) external override auth returns (uint256 amountOut) {\\n        require(tokenIn != tokenOut, 'SWAP_SAME_TOKEN');\\n        require(swapConnector != address(0), 'SWAP_CONNECTOR_NOT_SET');\\n\\n        uint256 minAmountOut;\\n        if (limitType == SwapLimit.MinAmountOut) {\\n            minAmountOut = limitAmount;\\n        } else if (limitType == SwapLimit.Slippage) {\\n            require(limitAmount <= FixedPoint.ONE, 'SWAP_SLIPPAGE_ABOVE_ONE');\\n            uint256 price = getPrice(tokenIn, tokenOut);\\n            // No need for checked math as we are checking it manually beforehand\\n            // Always round up the expected min amount out. Limit amount is slippage.\\n            minAmountOut = amountIn.mulUp(price).mulUp(FixedPoint.ONE.uncheckedSub(limitAmount));\\n        } else {\\n            revert('SWAP_INVALID_LIMIT_TYPE');\\n        }\\n\\n        uint256 preBalanceIn = IERC20(tokenIn).balanceOf(address(this));\\n        uint256 preBalanceOut = IERC20(tokenOut).balanceOf(address(this));\\n        swapConnector.swap(source, tokenIn, tokenOut, amountIn, minAmountOut, data);\\n\\n        uint256 postBalanceIn = IERC20(tokenIn).balanceOf(address(this));\\n        require(postBalanceIn >= preBalanceIn - amountIn, 'SWAP_BAD_TOKEN_IN_BALANCE');\\n\\n        uint256 amountOutBeforeFees = IERC20(tokenOut).balanceOf(address(this)) - preBalanceOut;\\n        require(amountOutBeforeFees >= minAmountOut, 'SWAP_MIN_AMOUNT');\\n\\n        uint256 swapFeeAmount = _payFee(tokenOut, amountOutBeforeFees, swapFee);\\n        amountOut = amountOutBeforeFees - swapFeeAmount;\\n        emit Swap(source, tokenIn, tokenOut, amountIn, amountOut, minAmountOut, swapFeeAmount, data);\\n    }\\n\\n    /**\\n     * @dev Bridge assets to another chain\\n     * @param source Source to request the bridge. It depends on the Bridge Connector attached to a Smart Vault.\\n     * @param chainId ID of the destination chain\\n     * @param token Address of the token to be bridged\\n     * @param amount Amount of tokens to be bridged\\n     * @param limitType Bridge limit to be applied: slippage or min amount out\\n     * @param limitAmount Amount of the swap limit to be applied depending on limitType\\n     * @param recipient Address that will receive the tokens on the destination chain\\n     * @param data Encoded data to specify different bridge parameters depending on the source picked\\n     * @return bridged Amount requested to be bridged after fees\\n     */\\n    function bridge(\\n        uint8 source,\\n        uint256 chainId,\\n        address token,\\n        uint256 amount,\\n        BridgeLimit limitType,\\n        uint256 limitAmount,\\n        address recipient,\\n        bytes memory data\\n    ) external override auth returns (uint256 bridged) {\\n        require(block.chainid != chainId, 'BRIDGE_SAME_CHAIN');\\n        require(recipient != address(0), 'BRIDGE_RECIPIENT_ZERO');\\n        require(bridgeConnector != address(0), 'BRIDGE_CONNECTOR_NOT_SET');\\n\\n        uint256 bridgeFeeAmount = _payFee(token, amount, bridgeFee);\\n        bridged = amount - bridgeFeeAmount;\\n\\n        uint256 minAmountOut;\\n        if (limitType == BridgeLimit.MinAmountOut) {\\n            minAmountOut = limitAmount;\\n        } else if (limitType == BridgeLimit.Slippage) {\\n            require(limitAmount <= FixedPoint.ONE, 'BRIDGE_SLIPPAGE_ABOVE_ONE');\\n            // No need for checked math as we are checking it manually beforehand\\n            // Always round up the expected min amount out. Limit amount is slippage.\\n            minAmountOut = bridged.mulUp(FixedPoint.ONE.uncheckedSub(limitAmount));\\n        } else {\\n            revert('BRIDGE_INVALID_LIMIT_TYPE');\\n        }\\n\\n        uint256 preBalanceIn = IERC20(token).balanceOf(address(this));\\n        bridgeConnector.bridge(source, chainId, token, bridged, minAmountOut, recipient, data);\\n        uint256 postBalanceIn = IERC20(token).balanceOf(address(this));\\n        require(postBalanceIn >= preBalanceIn - bridged, 'BRIDGE_BAD_TOKEN_IN_BALANCE');\\n\\n        emit Bridge(source, chainId, token, bridged, minAmountOut, bridgeFeeAmount, recipient, data);\\n    }\\n\\n    /**\\n     * @dev Internal function to pay the amount of fees to be charged based on a fee configuration to the fee collector\\n     * @param token Token being charged\\n     * @param amount Token amount to be taxed with fees\\n     * @param fee Fee configuration to be applied\\n     * @return paidAmount Amount of fees paid to the fee collector\\n     */\\n    function _payFee(address token, uint256 amount, Fee storage fee) internal returns (uint256 paidAmount) {\\n        // Fee amounts are always rounded down\\n        uint256 feeAmount = amount.mulDown(fee.pct);\\n\\n        // If cap amount or cap period are not set, charge the entire amount\\n        if (fee.token == address(0) || fee.cap == 0 || fee.period == 0) {\\n            _safeTransfer(token, feeCollector, feeAmount);\\n            return feeAmount;\\n        }\\n\\n        // Reset cap totalizator if necessary\\n        if (block.timestamp >= fee.nextResetTime) {\\n            fee.totalCharged = 0;\\n            fee.nextResetTime = block.timestamp + fee.period;\\n        }\\n\\n        // Calc fee amount in the fee token used for the cap\\n        uint256 feeTokenPrice = getPrice(token, fee.token);\\n        uint256 feeAmountInFeeToken = feeAmount.mulDown(feeTokenPrice);\\n\\n        // Compute fee amount picking the minimum between the chargeable amount and the remaining part for the cap\\n        if (fee.totalCharged + feeAmountInFeeToken <= fee.cap) {\\n            paidAmount = feeAmount;\\n            fee.totalCharged += feeAmountInFeeToken;\\n        } else if (fee.totalCharged < fee.cap) {\\n            paidAmount = (fee.cap.uncheckedSub(fee.totalCharged) * feeAmount) / feeAmountInFeeToken;\\n            fee.totalCharged = fee.cap;\\n        } else {\\n            // This case is when the total charged amount is already greater than the cap amount. It could happen if\\n            // the cap amounts is decreased or if the cap token is changed. In this case the total charged amount is\\n            // not updated, and the amount to paid is zero.\\n            paidAmount = 0;\\n        }\\n\\n        // Pay fee amount to the fee collector\\n        _safeTransfer(token, feeCollector, paidAmount);\\n    }\\n\\n    /**\\n     * @dev Internal method to transfer ERC20 or native tokens from a Smart Vault\\n     * @param token Address of the ERC20 token to transfer\\n     * @param to Address transferring the tokens to\\n     * @param amount Amount of tokens to transfer\\n     */\\n    function _safeTransfer(address token, address to, uint256 amount) internal {\\n        if (amount == 0) return;\\n        if (Denominations.isNativeToken(token)) Address.sendValue(payable(to), amount);\\n        else IERC20(token).safeTransfer(to, amount);\\n    }\\n\\n    /**\\n     * @dev Sets a new strategy as allowed or not\\n     * @param strategy Address of the strategy to be set\\n     * @param allowed Whether the strategy is allowed or not\\n     */\\n    function _setStrategy(address strategy, bool allowed) internal {\\n        if (allowed) _validateStatelessDependency(strategy);\\n        isStrategyAllowed[strategy] = allowed;\\n        emit StrategySet(strategy, allowed);\\n    }\\n\\n    /**\\n     * @dev Sets a new price oracle\\n     * @param newPriceOracle New price oracle to be set\\n     */\\n    function _setPriceOracle(address newPriceOracle) internal {\\n        _validateStatelessDependency(newPriceOracle);\\n        priceOracle = newPriceOracle;\\n        emit PriceOracleSet(newPriceOracle);\\n    }\\n\\n    /**\\n     * @dev Sets a new swap connector\\n     * @param newSwapConnector New swap connector to be set\\n     */\\n    function _setSwapConnector(address newSwapConnector) internal {\\n        _validateStatelessDependency(newSwapConnector);\\n        swapConnector = newSwapConnector;\\n        emit SwapConnectorSet(newSwapConnector);\\n    }\\n\\n    /**\\n     * @dev Sets a new bridge connector\\n     * @param newBridgeConnector New bridge connector to be set\\n     */\\n    function _setBridgeConnector(address newBridgeConnector) internal {\\n        _validateStatelessDependency(newBridgeConnector);\\n        bridgeConnector = newBridgeConnector;\\n        emit BridgeConnectorSet(newBridgeConnector);\\n    }\\n\\n    /**\\n     * @dev Internal method to set the fee collector\\n     * @param newFeeCollector New fee collector to be set\\n     */\\n    function _setFeeCollector(address newFeeCollector) internal {\\n        require(newFeeCollector != address(0), 'FEE_COLLECTOR_ZERO');\\n        feeCollector = newFeeCollector;\\n        emit FeeCollectorSet(newFeeCollector);\\n    }\\n\\n    /**\\n     * @dev Internal method to set a new fee cap configuration\\n     * @param fee Fee configuration to be updated\\n     * @param pct Fee percentage to be set\\n     * @param cap New maximum amount of fees to be charged per period\\n     * @param token Address of the token cap to be set\\n     * @param period New cap period length in seconds\\n     */\\n    function _setFeeConfiguration(Fee storage fee, uint256 pct, uint256 cap, address token, uint256 period) internal {\\n        require(pct <= FixedPoint.ONE, 'FEE_PCT_ABOVE_ONE');\\n\\n        // If there is no fee percentage, there must not be a fee cap\\n        bool isZeroCap = token == address(0) && cap == 0 && period == 0;\\n        require(pct != 0 || isZeroCap, 'INVALID_CAP_WITH_FEE_ZERO');\\n\\n        // If there is a cap, all values must be non-zero\\n        bool isNonZeroCap = token != address(0) && cap != 0 && period != 0;\\n        require(isZeroCap || isNonZeroCap, 'INCONSISTENT_CAP_VALUES');\\n\\n        // Changing the fee percentage does not affect the totalizator at all, it only affects future fee charges\\n        fee.pct = pct;\\n\\n        // Changing the fee cap amount does not affect the totalizator, it only applies when changing the for the total\\n        // charged amount. Note that it can happen that the cap amount is lower than the total charged amount if the\\n        // cap amount is lowered. However, there shouldn't be any accounting issues with that.\\n        fee.cap = cap;\\n\\n        // Changing the cap period only affects the end time of the next period, but not the end date of the current one\\n        fee.period = period;\\n\\n        // Therefore, only clean the totalizators if the cap is being removed\\n        if (isZeroCap) {\\n            fee.totalCharged = 0;\\n            fee.nextResetTime = 0;\\n        } else {\\n            // If cap values are not zero, set the next reset time if it wasn't set already\\n            // Otherwise, if the cap token is being changed the total charged amount must be updated accordingly\\n            if (fee.nextResetTime == 0) {\\n                fee.nextResetTime = block.timestamp + period;\\n            } else if (fee.token != token) {\\n                uint256 newTokenPrice = getPrice(fee.token, token);\\n                fee.totalCharged = fee.totalCharged.mulDown(newTokenPrice);\\n            }\\n        }\\n\\n        // Finally simply set the new requested token\\n        fee.token = token;\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-smart-vaults-base/contracts/actions/BaseAction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\\n\\nimport '@mimic-fi/v2-smart-vault/contracts/ISmartVault.sol';\\nimport '@mimic-fi/v2-helpers/contracts/auth/Authorizer.sol';\\nimport '@mimic-fi/v2-helpers/contracts/utils/Denominations.sol';\\nimport '@mimic-fi/v2-helpers/contracts/utils/ERC20Helpers.sol';\\nimport '@mimic-fi/v2-registry/contracts/implementations/BaseAuthorizedImplementation.sol';\\n\\nimport './IAction.sol';\\n\\n/**\\n * @title BaseAction\\n * @dev Simple action implementation with a Smart Vault reference and using the Authorizer mixin\\n */\\ncontract BaseAction is IAction, BaseAuthorizedImplementation, ReentrancyGuard {\\n    bytes32 public constant override NAMESPACE = keccak256('ACTION');\\n\\n    // Smart Vault reference\\n    ISmartVault public override smartVault;\\n\\n    /**\\n     * @dev Emitted every time a new smart vault is set\\n     */\\n    event SmartVaultSet(address indexed smartVault);\\n\\n    /**\\n     * @dev Creates a new BaseAction\\n     * @param admin Address to be granted authorize and unauthorize permissions\\n     * @param registry Address of the Mimic Registry\\n     */\\n    constructor(address admin, address registry) BaseAuthorizedImplementation(admin, registry) {\\n        // solhint-disable-previous-line no-empty-blocks\\n    }\\n\\n    /**\\n     * @dev Sets the Smart Vault tied to the Action. Sender must be authorized. It can be set only once.\\n     * @param newSmartVault Address of the smart vault to be set\\n     */\\n    function setSmartVault(address newSmartVault) external auth {\\n        require(address(smartVault) == address(0), 'SMART_VAULT_ALREADY_SET');\\n        smartVault = ISmartVault(newSmartVault);\\n        emit SmartVaultSet(newSmartVault);\\n    }\\n\\n    /**\\n     * @dev Tells the balance of the Smart Vault for a given token\\n     * @param token Address of the token querying the balance of\\n     * @notice Denominations.NATIVE_TOKEN_ADDRESS can be used to query the native token balance\\n     */\\n    function _balanceOf(address token) internal view returns (uint256) {\\n        return ERC20Helpers.balanceOf(token, address(smartVault));\\n    }\\n\\n    /**\\n     * @dev Tells the wrapped native token address if the given address is the native token\\n     * @param token Address of the token to be checked\\n     */\\n    function _wrappedIfNative(address token) internal view returns (address) {\\n        return Denominations.isNativeToken(token) ? smartVault.wrappedNativeToken() : token;\\n    }\\n\\n    /**\\n     * @dev Tells whether the given token is either the native or wrapped native token\\n     * @param token Address of the token being queried\\n     */\\n    function _isWrappedOrNativeToken(address token) internal view returns (bool) {\\n        return Denominations.isNativeToken(token) || token == smartVault.wrappedNativeToken();\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-smart-vaults-base/contracts/actions/IAction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.8.0;\\n\\nimport '@mimic-fi/v2-smart-vault/contracts/ISmartVault.sol';\\nimport '@mimic-fi/v2-helpers/contracts/auth/IAuthorizer.sol';\\n\\n/**\\n * @title IAction\\n * @dev Action interface it must follow the IAuthorizer interface\\n */\\ninterface IAction is IAuthorizer {\\n    /**\\n     * @dev Emitted every time an action is executed\\n     */\\n    event Executed();\\n\\n    /**\\n     * @dev Tells the address of the Smart Vault tied to it, it cannot be changed\\n     */\\n    function smartVault() external view returns (ISmartVault);\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-smart-vaults-base/contracts/actions/ReceiverAction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\\nimport '@openzeppelin/contracts/utils/Address.sol';\\n\\nimport './BaseAction.sol';\\n\\nabstract contract ReceiverAction is BaseAction {\\n    using SafeERC20 for IERC20;\\n\\n    receive() external payable {\\n        // solhint-disable-previous-line no-empty-blocks\\n    }\\n\\n    function withdraw(address token, uint256 amount) external auth {\\n        _transferToSmartVault(token, amount);\\n    }\\n\\n    function _transferToSmartVault(address token, uint256 amount) internal {\\n        ERC20Helpers.transfer(token, address(smartVault), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-smart-vaults-base/contracts/actions/RelayedAction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nimport '@mimic-fi/v2-helpers/contracts/math/FixedPoint.sol';\\nimport '@mimic-fi/v2-helpers/contracts/utils/Denominations.sol';\\n\\nimport './BaseAction.sol';\\n\\n/**\\n * @title RelayedAction\\n * @dev Action that offers a relayed mechanism to allow reimbursing tx costs after execution in any ERC20 token.\\n * This type of action at least require having withdraw permissions from the Smart Vault tied to it.\\n */\\nabstract contract RelayedAction is BaseAction {\\n    using FixedPoint for uint256;\\n\\n    // Base gas amount charged to cover default amounts\\n    // solhint-disable-next-line func-name-mixedcase\\n    function BASE_GAS() external view virtual returns (uint256);\\n\\n    // Note to be used to mark tx cost payments\\n    bytes private constant REDEEM_GAS_NOTE = bytes('RELAYER');\\n\\n    // Internal variable used to allow a better developer experience to reimburse tx gas cost\\n    uint256 internal _initialGas;\\n\\n    // Allows relaying transactions even if there is not enough balance in the Smart Vault to pay for the tx gas cost\\n    bool public isPermissiveModeActive;\\n\\n    // Gas price limit, if surpassed it wont relay the transaction\\n    uint256 public gasPriceLimit;\\n\\n    // Total cost limit expressed in `payingGasToken`, if surpassed it wont relay the transaction\\n    uint256 public totalCostLimit;\\n\\n    // Address of the ERC20 token that will be used to pay the total tx cost\\n    address public payingGasToken;\\n\\n    // List of allowed relayers indexed by address\\n    mapping (address => bool) public isRelayer;\\n\\n    /**\\n     * @dev Emitted every time the permissive mode is changed\\n     */\\n    event PermissiveModeSet(bool active);\\n\\n    /**\\n     * @dev Emitted every time the relayers list is changed\\n     */\\n    event RelayerSet(address indexed relayer, bool allowed);\\n\\n    /**\\n     * @dev Emitted every time the relayer limits are set\\n     */\\n    event LimitsSet(uint256 gasPriceLimit, uint256 totalCostLimit, address payingGasToken);\\n\\n    /**\\n     * @dev Modifier that can be used to reimburse the gas cost of the tagged function\\n     */\\n    modifier redeemGas() {\\n        _beforeCall();\\n        _;\\n        _afterCall();\\n    }\\n\\n    /**\\n     * @dev Sets the relayed action permissive mode. If active, it won't fail when trying to redeem gas costs to the\\n     * relayer if the smart vault does not have enough balance. Sender must be authorized.\\n     * @param active Whether the permissive mode should be active or not\\n     */\\n    function setPermissiveMode(bool active) external auth {\\n        isPermissiveModeActive = active;\\n        emit PermissiveModeSet(active);\\n    }\\n\\n    /**\\n     * @dev Sets a relayer address. Sender must be authorized.\\n     * @param relayer Address of the relayer to be set\\n     * @param allowed Whether it should be allowed or not\\n     */\\n    function setRelayer(address relayer, bool allowed) external auth {\\n        isRelayer[relayer] = allowed;\\n        emit RelayerSet(relayer, allowed);\\n    }\\n\\n    /**\\n     * @dev Sets the relayer limits. Sender must be authorized.\\n     * @param _gasPriceLimit New gas price limit to be set\\n     * @param _totalCostLimit New total cost limit to be set\\n     * @param _payingGasToken New paying gas token to be set\\n     */\\n    function setLimits(uint256 _gasPriceLimit, uint256 _totalCostLimit, address _payingGasToken) external auth {\\n        require(_payingGasToken != address(0), 'PAYING_GAS_TOKEN_ZERO');\\n        gasPriceLimit = _gasPriceLimit;\\n        totalCostLimit = _totalCostLimit;\\n        payingGasToken = _payingGasToken;\\n        emit LimitsSet(_gasPriceLimit, _totalCostLimit, _payingGasToken);\\n    }\\n\\n    /**\\n     * @dev Internal before call hook where limit validations are checked\\n     */\\n    function _beforeCall() internal {\\n        _initialGas = gasleft();\\n        require(isRelayer[msg.sender], 'SENDER_NOT_RELAYER');\\n        uint256 limit = gasPriceLimit;\\n        require(limit == 0 || tx.gasprice <= limit, 'GAS_PRICE_ABOVE_LIMIT');\\n    }\\n\\n    /**\\n     * @dev Internal after call hook where tx cost is reimburse\\n     */\\n    function _afterCall() internal {\\n        uint256 totalGas = _initialGas - gasleft();\\n        uint256 totalCostNative = (totalGas + RelayedAction(this).BASE_GAS()) * tx.gasprice;\\n\\n        uint256 limit = totalCostLimit;\\n        address payingToken = payingGasToken;\\n        // Total cost is rounded down to make sure we always match at least the threshold\\n        uint256 totalCostToken = totalCostNative.mulDown(_getPayingGasTokenPrice(payingToken));\\n        require(limit == 0 || totalCostToken <= limit, 'TX_COST_ABOVE_LIMIT');\\n\\n        if (_shouldTryRedeemFromSmartVault(payingToken, totalCostToken)) {\\n            smartVault.withdraw(payingToken, totalCostToken, smartVault.feeCollector(), REDEEM_GAS_NOTE);\\n        }\\n\\n        delete _initialGas;\\n    }\\n\\n    /**\\n     * @dev Internal function to fetch the paying gas token rate from the Smart Vault's price oracle\\n     */\\n    function _getPayingGasTokenPrice(address token) private view returns (uint256) {\\n        bool isUsingNativeToken = _isWrappedOrNativeToken(token);\\n        return isUsingNativeToken ? FixedPoint.ONE : smartVault.getPrice(smartVault.wrappedNativeToken(), token);\\n    }\\n\\n    /**\\n     * @dev Internal function to tell if the relayed action should try to redeem the gas cost from the Smart Vault\\n     * @param token Address of the token to pay the relayed gas cost\\n     * @param amount Amount of tokens to pay for the relayed gas cost\\n     */\\n    function _shouldTryRedeemFromSmartVault(address token, uint256 amount) private view returns (bool) {\\n        if (!isPermissiveModeActive) return true;\\n        return _balanceOf(token) >= amount;\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-smart-vaults-base/contracts/actions/TimeLockedAction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nimport './BaseAction.sol';\\n\\n/**\\n * @title Time-locked action\\n * @dev Action that offers a time-lock mechanism to allow executing it only once during a set period of time\\n */\\nabstract contract TimeLockedAction is BaseAction {\\n    // Period in seconds\\n    uint256 public period;\\n\\n    // Next timestamp in the future when the action can be executed again\\n    uint256 public nextResetTime;\\n\\n    /**\\n     * @dev Emitted every time a time-lock is set\\n     */\\n    event TimeLockSet(uint256 period);\\n\\n    /**\\n     * @dev Creates a new time-locked action\\n     */\\n    constructor() {\\n        nextResetTime = block.timestamp;\\n    }\\n\\n    /**\\n     * @dev Sets a new period for the time-locked action\\n     * @param newPeriod New period to be set\\n     */\\n    function setTimeLock(uint256 newPeriod) external auth {\\n        period = newPeriod;\\n        emit TimeLockSet(newPeriod);\\n    }\\n\\n    /**\\n     * @dev Internal function to tell whether the current time-lock has passed\\n     */\\n    function _passesTimeLock() internal view returns (bool) {\\n        return block.timestamp >= nextResetTime;\\n    }\\n\\n    /**\\n     * @dev Internal function to validate the time-locked action\\n     */\\n    function _validateTimeLock() internal {\\n        require(_passesTimeLock(), 'TIME_LOCK_NOT_EXPIRED');\\n        nextResetTime = block.timestamp + period;\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-smart-vaults-base/contracts/actions/TokenThresholdAction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@mimic-fi/v2-helpers/contracts/math/FixedPoint.sol';\\n\\nimport './BaseAction.sol';\\n\\n/**\\n * @title TokenThresholdAction\\n * @dev Action that offers a token threshold limit. It can be used for minimum swap amounts, or minimum withdrawal\\n * amounts, etc. This type of action does not require any specific permission on the Smart Vault.\\n */\\nabstract contract TokenThresholdAction is BaseAction {\\n    using FixedPoint for uint256;\\n\\n    address public thresholdToken;\\n    uint256 public thresholdAmount;\\n\\n    event ThresholdSet(address indexed token, uint256 amount);\\n\\n    /**\\n     * @dev Sets a new threshold configuration. Sender must be authorized.\\n     * @param token New token threshold to be set\\n     * @param amount New amount threshold to be set\\n     */\\n    function setThreshold(address token, uint256 amount) external auth {\\n        thresholdToken = token;\\n        thresholdAmount = amount;\\n        emit ThresholdSet(token, amount);\\n    }\\n\\n    /**\\n     * @dev Internal function to check the set threshold\\n     * @param token Token address of the given amount to evaluate the threshold\\n     * @param amount Amount of tokens to validate the threshold\\n     */\\n    function _passesThreshold(address token, uint256 amount) internal view returns (bool) {\\n        uint256 price = smartVault.getPrice(_wrappedIfNative(token), thresholdToken);\\n        // Result balance is rounded down to make sure we always match at least the threshold\\n        return amount.mulDown(price) >= thresholdAmount;\\n    }\\n\\n    /**\\n     * @dev Internal function to validate the set threshold\\n     * @param token Token address of the given amount to evaluate the threshold\\n     * @param amount Amount of tokens to validate the threshold\\n     */\\n    function _validateThreshold(address token, uint256 amount) internal view {\\n        require(_passesThreshold(token, amount), 'MIN_THRESHOLD_NOT_MET');\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-smart-vaults-base/contracts/actions/WithdrawalAction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nimport './BaseAction.sol';\\n\\n/**\\n * @title Withdrawal action\\n * @dev Action that offers a recipient address where funds can be withdrawn. This type of action at least require\\n * having withdraw permissions from the Smart Vault tied to it.\\n */\\nabstract contract WithdrawalAction is BaseAction {\\n    // Address where tokens will be transferred to\\n    address public recipient;\\n\\n    /**\\n     * @dev Emitted every time the recipient is set\\n     */\\n    event RecipientSet(address indexed recipient);\\n\\n    /**\\n     * @dev Sets the recipient address. Sender must be authorized.\\n     * @param newRecipient Address of the new recipient to be set\\n     */\\n    function setRecipient(address newRecipient) external auth {\\n        require(newRecipient != address(0), 'RECIPIENT_ZERO');\\n        recipient = newRecipient;\\n        emit RecipientSet(newRecipient);\\n    }\\n\\n    /**\\n     * @dev Internal function to withdraw all the available balance of a token from the Smart Vault to the recipient\\n     * @param token Address of the token to be withdrawn\\n     */\\n    function _withdraw(address token) internal {\\n        uint256 balance = _balanceOf(token);\\n        _withdraw(token, balance);\\n    }\\n\\n    /**\\n     * @dev Internal function to withdraw a specific amount of a token from the Smart Vault to the recipient\\n     * @param token Address of the token to be withdrawn\\n     * @param amount Amount of tokens to be withdrawn\\n     */\\n    function _withdraw(address token, uint256 amount) internal {\\n        smartVault.withdraw(token, amount, recipient, new bytes(0));\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-smart-vaults-base/contracts/deploy/Deployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@mimic-fi/v2-smart-vault/contracts/SmartVault.sol';\\nimport '@mimic-fi/v2-smart-vault/contracts/ISmartVaultsFactory.sol';\\nimport '@mimic-fi/v2-helpers/contracts/auth/IAuthorizer.sol';\\nimport '@mimic-fi/v2-helpers/contracts/math/UncheckedMath.sol';\\nimport '@mimic-fi/v2-registry/contracts/registry/IRegistry.sol';\\n\\nimport '../actions/ReceiverAction.sol';\\nimport '../actions/RelayedAction.sol';\\nimport '../actions/TimeLockedAction.sol';\\nimport '../actions/TokenThresholdAction.sol';\\nimport '../actions/WithdrawalAction.sol';\\n\\n/**\\n * @title Deployer\\n * @dev Deployer library offering a bunch of set-up methods to deploy and customize smart vaults\\n */\\nlibrary Deployer {\\n    using UncheckedMath for uint256;\\n\\n    // Namespace to use by this deployer to fetch ISmartVaultFactory implementations from the Mimic Registry\\n    bytes32 private constant SMART_VAULT_FACTORY_NAMESPACE = keccak256('SMART_VAULTS_FACTORY');\\n\\n    // Namespace to use by this deployer to fetch ISmartVault implementations from the Mimic Registry\\n    bytes32 private constant SMART_VAULT_NAMESPACE = keccak256('SMART_VAULT');\\n\\n    // Namespace to use by this deployer to fetch IStrategy implementations from the Mimic Registry\\n    bytes32 private constant STRATEGY_NAMESPACE = keccak256('STRATEGY');\\n\\n    // Namespace to use by this deployer to fetch IPriceOracle implementations from the Mimic Registry\\n    bytes32 private constant PRICE_ORACLE_NAMESPACE = keccak256('PRICE_ORACLE');\\n\\n    // Namespace to use by this deployer to fetch ISwapConnector implementations from the Mimic Registry\\n    bytes32 private constant SWAP_CONNECTOR_NAMESPACE = keccak256('SWAP_CONNECTOR');\\n\\n    // Namespace to use by this deployer to fetch IBridgeConnector implementations from the Mimic Registry\\n    bytes32 private constant BRIDGE_CONNECTOR_NAMESPACE = keccak256('BRIDGE_CONNECTOR');\\n\\n    /**\\n     * @dev Smart vault params\\n     * @param factory Address of the factory that will be used to deploy an instance of the Smart Vault implementation\\n     * @param impl Address of the Smart Vault implementation to be used\\n     * @param salt Salt bytes to derivate the address of the new Smart Vault instance\\n     * @param admin Address that will be granted with admin rights for the deployed Smart Vault\\n     * @param bridgeConnector Optional Bridge Connector to set for the Smart Vault\\n     * @param swapConnector Optional Swap Connector to set for the Smart Vault\\n     * @param strategies List of strategies to be allowed for the Smart Vault\\n     * @param priceOracle Optional Price Oracle to set for the Smart Vault\\n     * @param priceFeedParams List of price feeds to be set for the Smart Vault\\n     * @param feeCollector Address to be set as the fee collector\\n     * @param swapFee Swap fee params\\n     * @param bridgeFee Bridge fee params\\n     * @param withdrawFee Withdraw fee params\\n     * @param performanceFee Performance fee params\\n     */\\n    struct SmartVaultParams {\\n        address factory;\\n        address impl;\\n        bytes32 salt;\\n        address admin;\\n        address[] strategies;\\n        address bridgeConnector;\\n        address swapConnector;\\n        address priceOracle;\\n        PriceFeedParams[] priceFeedParams;\\n        address feeCollector;\\n        SmartVaultFeeParams swapFee;\\n        SmartVaultFeeParams bridgeFee;\\n        SmartVaultFeeParams withdrawFee;\\n        SmartVaultFeeParams performanceFee;\\n    }\\n\\n    /**\\n     * @dev Smart Vault price feed params\\n     * @param base Base token of the price feed\\n     * @param quote Quote token of the price feed\\n     * @param feed Address of the price feed\\n     */\\n    struct PriceFeedParams {\\n        address base;\\n        address quote;\\n        address feed;\\n    }\\n\\n    /**\\n     * @dev Smart Vault fee configuration parameters\\n     * @param pct Percentage expressed using 16 decimals (1e18 = 100%)\\n     * @param cap Maximum amount of fees to be charged per period\\n     * @param token Address of the token to express the cap amount\\n     * @param period Period length in seconds\\n     */\\n    struct SmartVaultFeeParams {\\n        uint256 pct;\\n        uint256 cap;\\n        address token;\\n        uint256 period;\\n    }\\n\\n    /**\\n     * @dev Relayed action params\\n     * @param relayers List of addresses to be marked as allowed executors and in particular as authorized relayers\\n     * @param gasPriceLimit Gas price limit to be used for the relayed action\\n     * @param totalCostLimit Total cost limit to be used for the relayed action\\n     * @param payingGasToken Paying gas token to be used for the relayed action\\n     * @param isPermissiveModeActive Whether permissive mode is active or not\\n     */\\n    struct RelayedActionParams {\\n        address[] relayers;\\n        uint256 gasPriceLimit;\\n        uint256 totalCostLimit;\\n        address payingGasToken;\\n        bool isPermissiveModeActive;\\n        address permissiveModeAdmin;\\n    }\\n\\n    /**\\n     * @dev Token threshold action params\\n     * @param token Address of the token of the threshold\\n     * @param amount Amount of tokens of the threshold\\n     */\\n    struct TokenThresholdActionParams {\\n        address token;\\n        uint256 amount;\\n    }\\n\\n    /**\\n     * @dev Time-locked action params\\n     * @param period Period in seconds to be set for the time lock\\n     */\\n    struct TimeLockedActionParams {\\n        uint256 period;\\n    }\\n\\n    /**\\n     * @dev Withdrawal action params\\n     * @param recipient Address that will receive the funds from the withdraw action\\n     */\\n    struct WithdrawalActionParams {\\n        address recipient;\\n    }\\n\\n    /**\\n     * @dev Create a new Smart Vault instance\\n     * @param registry Address of the registry to validate the Smart Vault implementation\\n     * @param params Params to customize the Smart Vault to be deployed\\n     * @param transferPermissions Whether the Smart Vault admin permissions should be transfer to the admin right after\\n     * creating the Smart Vault. Sometimes this is not desired if further customization might take in place.\\n     */\\n    function createSmartVault(IRegistry registry, SmartVaultParams memory params, bool transferPermissions)\\n        external\\n        returns (SmartVault smartVault)\\n    {\\n        // Clone requested Smart Vault implementation and initialize\\n        require(registry.isActive(SMART_VAULT_FACTORY_NAMESPACE, params.factory), 'BAD_SMART_VAULT_FACTORY_IMPL');\\n        ISmartVaultsFactory factory = ISmartVaultsFactory(params.factory);\\n\\n        bytes memory initializeData = abi.encodeWithSelector(SmartVault.initialize.selector, address(this));\\n        bytes32 senderSalt = keccak256(abi.encodePacked(msg.sender, params.salt));\\n        smartVault = SmartVault(payable(factory.create(senderSalt, params.impl, initializeData)));\\n\\n        // Authorize admin to perform any action except setting the fee collector, see below\\n        smartVault.authorize(params.admin, smartVault.collect.selector);\\n        smartVault.authorize(params.admin, smartVault.withdraw.selector);\\n        smartVault.authorize(params.admin, smartVault.wrap.selector);\\n        smartVault.authorize(params.admin, smartVault.unwrap.selector);\\n        smartVault.authorize(params.admin, smartVault.claim.selector);\\n        smartVault.authorize(params.admin, smartVault.join.selector);\\n        smartVault.authorize(params.admin, smartVault.exit.selector);\\n        smartVault.authorize(params.admin, smartVault.swap.selector);\\n        smartVault.authorize(params.admin, smartVault.bridge.selector);\\n        smartVault.authorize(params.admin, smartVault.setStrategy.selector);\\n        smartVault.authorize(params.admin, smartVault.setPriceFeed.selector);\\n        smartVault.authorize(params.admin, smartVault.setPriceFeeds.selector);\\n        smartVault.authorize(params.admin, smartVault.setPriceOracle.selector);\\n        smartVault.authorize(params.admin, smartVault.setSwapConnector.selector);\\n        smartVault.authorize(params.admin, smartVault.setBridgeConnector.selector);\\n        smartVault.authorize(params.admin, smartVault.setWithdrawFee.selector);\\n        smartVault.authorize(params.admin, smartVault.setPerformanceFee.selector);\\n        smartVault.authorize(params.admin, smartVault.setSwapFee.selector);\\n        smartVault.authorize(params.admin, smartVault.setBridgeFee.selector);\\n\\n        // Set price feeds if any\\n        if (params.priceFeedParams.length > 0) {\\n            smartVault.authorize(address(this), smartVault.setPriceFeed.selector);\\n            for (uint256 i = 0; i < params.priceFeedParams.length; i = i.uncheckedAdd(1)) {\\n                PriceFeedParams memory feedParams = params.priceFeedParams[i];\\n                smartVault.setPriceFeed(feedParams.base, feedParams.quote, feedParams.feed);\\n            }\\n            smartVault.unauthorize(address(this), smartVault.setPriceFeed.selector);\\n        }\\n\\n        // Set price oracle if given\\n        if (params.priceOracle != address(0)) {\\n            require(registry.isActive(PRICE_ORACLE_NAMESPACE, params.priceOracle), 'BAD_PRICE_ORACLE_DEPENDENCY');\\n            smartVault.authorize(address(this), smartVault.setPriceOracle.selector);\\n            smartVault.setPriceOracle(params.priceOracle);\\n            smartVault.unauthorize(address(this), smartVault.setPriceOracle.selector);\\n        }\\n\\n        // Set strategies if any\\n        if (params.strategies.length > 0) {\\n            smartVault.authorize(address(this), smartVault.setStrategy.selector);\\n            for (uint256 i = 0; i < params.strategies.length; i = i.uncheckedAdd(1)) {\\n                require(registry.isActive(STRATEGY_NAMESPACE, params.strategies[i]), 'BAD_STRATEGY_DEPENDENCY');\\n                smartVault.setStrategy(params.strategies[i], true);\\n            }\\n            smartVault.unauthorize(address(this), smartVault.setStrategy.selector);\\n        }\\n\\n        // Set swap connector if given\\n        if (params.swapConnector != address(0)) {\\n            require(registry.isActive(SWAP_CONNECTOR_NAMESPACE, params.swapConnector), 'BAD_SWAP_CONNECTOR_DEPENDENCY');\\n            smartVault.authorize(address(this), smartVault.setSwapConnector.selector);\\n            smartVault.setSwapConnector(params.swapConnector);\\n            smartVault.unauthorize(address(this), smartVault.setSwapConnector.selector);\\n        }\\n\\n        // Set bridge connector if given\\n        if (params.bridgeConnector != address(0)) {\\n            bool isActive = registry.isActive(BRIDGE_CONNECTOR_NAMESPACE, params.bridgeConnector);\\n            require(isActive, 'BAD_BRIDGE_CONNECTOR_DEPENDENCY');\\n            smartVault.authorize(address(this), smartVault.setBridgeConnector.selector);\\n            smartVault.setBridgeConnector(params.bridgeConnector);\\n            smartVault.unauthorize(address(this), smartVault.setBridgeConnector.selector);\\n        }\\n\\n        // Set fee collector if given, if not make sure no fee amounts were requested too\\n        // If there is a fee collector, authorize that address to change it, otherwise authorize the requested admin\\n        if (params.feeCollector != address(0)) {\\n            smartVault.authorize(params.feeCollector, smartVault.setFeeCollector.selector);\\n            smartVault.authorize(address(this), smartVault.setFeeCollector.selector);\\n            smartVault.setFeeCollector(params.feeCollector);\\n            smartVault.unauthorize(address(this), smartVault.setFeeCollector.selector);\\n        } else {\\n            bool noFees = params.withdrawFee.pct == 0 &&\\n                params.swapFee.pct == 0 &&\\n                params.bridgeFee.pct == 0 &&\\n                params.performanceFee.pct == 0;\\n            require(noFees, 'SMART_VAULT_FEES_NO_COLLECTOR');\\n            smartVault.authorize(params.admin, smartVault.setFeeCollector.selector);\\n        }\\n\\n        // Set withdraw fee if not zero\\n        SmartVaultFeeParams memory withdrawFee = params.withdrawFee;\\n        if (withdrawFee.pct != 0) {\\n            smartVault.authorize(address(this), smartVault.setWithdrawFee.selector);\\n            smartVault.setWithdrawFee(withdrawFee.pct, withdrawFee.cap, withdrawFee.token, withdrawFee.period);\\n            smartVault.unauthorize(address(this), smartVault.setWithdrawFee.selector);\\n        }\\n\\n        // Set swap fee if not zero\\n        SmartVaultFeeParams memory swapFee = params.swapFee;\\n        if (swapFee.pct != 0) {\\n            smartVault.authorize(address(this), smartVault.setSwapFee.selector);\\n            smartVault.setSwapFee(swapFee.pct, swapFee.cap, swapFee.token, swapFee.period);\\n            smartVault.unauthorize(address(this), smartVault.setSwapFee.selector);\\n        }\\n\\n        // Set bridge fee if not zero\\n        SmartVaultFeeParams memory bridgeFee = params.bridgeFee;\\n        if (bridgeFee.pct != 0) {\\n            smartVault.authorize(address(this), smartVault.setBridgeFee.selector);\\n            smartVault.setBridgeFee(bridgeFee.pct, bridgeFee.cap, bridgeFee.token, bridgeFee.period);\\n            smartVault.unauthorize(address(this), smartVault.setBridgeFee.selector);\\n        }\\n\\n        // Set performance fee if not zero\\n        SmartVaultFeeParams memory perfFee = params.performanceFee;\\n        if (perfFee.pct != 0) {\\n            smartVault.authorize(address(this), smartVault.setPerformanceFee.selector);\\n            smartVault.setPerformanceFee(perfFee.pct, perfFee.cap, perfFee.token, perfFee.period);\\n            smartVault.unauthorize(address(this), smartVault.setPerformanceFee.selector);\\n        }\\n\\n        if (transferPermissions) transferAdminPermissions(smartVault, params.admin);\\n    }\\n\\n    /**\\n     * @dev Set up a base action\\n     * @param action Base action to be set up\\n     * @param admin Address that will be granted with admin rights for the Base Action\\n     * @param smartVault Address of the Smart Vault to be set in the Base Action\\n     */\\n    function setupBaseAction(BaseAction action, address admin, address smartVault) external {\\n        action.authorize(admin, action.setSmartVault.selector);\\n        action.authorize(address(this), action.setSmartVault.selector);\\n        action.setSmartVault(smartVault);\\n        action.unauthorize(address(this), action.setSmartVault.selector);\\n    }\\n\\n    /**\\n     * @dev Set up a list of executors for a given action\\n     * @param action Action whose executors are being allowed\\n     * @param executors List of addresses to be allowed to call the given action\\n     * @param callSelector Selector of the function to allow the list of executors\\n     */\\n    function setupActionExecutors(BaseAction action, address[] memory executors, bytes4 callSelector) external {\\n        for (uint256 i = 0; i < executors.length; i = i.uncheckedAdd(1)) {\\n            action.authorize(executors[i], callSelector);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set up a Relayed action\\n     * @param action Relayed action to be configured\\n     * @param admin Address that will be granted with admin rights for the Relayed action\\n     * @param params Params to customize the Relayed action\\n     */\\n    function setupRelayedAction(RelayedAction action, address admin, RelayedActionParams memory params) external {\\n        // Authorize admin to set relayers and txs limits\\n        action.authorize(admin, action.setLimits.selector);\\n        action.authorize(admin, action.setRelayer.selector);\\n\\n        // Authorize permissive mode admin\\n        action.authorize(params.permissiveModeAdmin, action.setPermissiveMode.selector);\\n\\n        // Authorize relayers to call action\\n        action.authorize(address(this), action.setRelayer.selector);\\n        for (uint256 i = 0; i < params.relayers.length; i = i.uncheckedAdd(1)) {\\n            action.setRelayer(params.relayers[i], true);\\n        }\\n        action.unauthorize(address(this), action.setRelayer.selector);\\n\\n        // Set relayed transactions limits\\n        action.authorize(address(this), action.setLimits.selector);\\n        action.setLimits(params.gasPriceLimit, params.totalCostLimit, params.payingGasToken);\\n        action.unauthorize(address(this), action.setLimits.selector);\\n\\n        // Set permissive mode if necessary\\n        if (params.isPermissiveModeActive) {\\n            action.authorize(address(this), action.setPermissiveMode.selector);\\n            action.setPermissiveMode(true);\\n            action.unauthorize(address(this), action.setPermissiveMode.selector);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set up a Token Threshold action\\n     * @param action Token threshold action to be configured\\n     * @param admin Address that will be granted with admin rights for the Token Threshold action\\n     * @param params Params to customize the Token Threshold action\\n     */\\n    function setupTokenThresholdAction(\\n        TokenThresholdAction action,\\n        address admin,\\n        TokenThresholdActionParams memory params\\n    ) external {\\n        action.authorize(admin, action.setThreshold.selector);\\n        action.authorize(address(this), action.setThreshold.selector);\\n        action.setThreshold(params.token, params.amount);\\n        action.unauthorize(address(this), action.setThreshold.selector);\\n    }\\n\\n    /**\\n     * @dev Set up a Time-locked action\\n     * @param action Time-locked action to be configured\\n     * @param admin Address that will be granted with admin rights for the Time-locked action\\n     * @param params Params to customize the Time-locked action\\n     */\\n    function setupTimeLockedAction(TimeLockedAction action, address admin, TimeLockedActionParams memory params)\\n        external\\n    {\\n        action.authorize(admin, action.setTimeLock.selector);\\n        action.authorize(address(this), action.setTimeLock.selector);\\n        action.setTimeLock(params.period);\\n        action.unauthorize(address(this), action.setTimeLock.selector);\\n    }\\n\\n    /**\\n     * @dev Set up a Withdrawal action\\n     * @param action Relayed action to be configured\\n     * @param admin Address that will be granted with admin rights for the Withdrawal action\\n     * @param params Params to customize the Withdrawal action\\n     */\\n    function setupWithdrawalAction(WithdrawalAction action, address admin, WithdrawalActionParams memory params)\\n        external\\n    {\\n        action.authorize(admin, action.setRecipient.selector);\\n        action.authorize(address(this), action.setRecipient.selector);\\n        action.setRecipient(params.recipient);\\n        action.unauthorize(address(this), action.setRecipient.selector);\\n    }\\n\\n    /**\\n     * @dev Set up a Receiver action\\n     * @param action Relayed action to be configured\\n     * @param admin Address that will be granted with admin rights for the Receiver action\\n     */\\n    function setupReceiverAction(ReceiverAction action, address admin) external {\\n        action.authorize(admin, action.withdraw.selector);\\n    }\\n\\n    /**\\n     * @dev Transfer admin rights from the deployer to another account\\n     * @param target Contract whose permissions are being transferred\\n     * @param to Address that will receive the admin rights\\n     */\\n    function transferAdminPermissions(IAuthorizer target, address to) public {\\n        grantAdminPermissions(target, to);\\n        revokeAdminPermissions(target, address(this));\\n    }\\n\\n    /**\\n     * @dev Grant admin permissions to an account\\n     * @param target Contract whose permissions are being granted\\n     * @param to Address that will receive the admin rights\\n     */\\n    function grantAdminPermissions(IAuthorizer target, address to) public {\\n        target.authorize(to, target.authorize.selector);\\n        target.authorize(to, target.unauthorize.selector);\\n    }\\n\\n    /**\\n     * @dev Revoke admin permissions from an account\\n     * @param target Contract whose permissions are being revoked\\n     * @param from Address that will be revoked\\n     */\\n    function revokeAdminPermissions(IAuthorizer target, address from) public {\\n        target.unauthorize(from, target.authorize.selector);\\n        target.unauthorize(from, target.unauthorize.selector);\\n    }\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-strategies/contracts/IStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@mimic-fi/v2-registry/contracts/implementations/IImplementation.sol';\\n\\n/**\\n * @title IStrategy\\n * @dev Strategy interface required by Mimic Smart Vaults. It must follow the IImplementation interface.\\n */\\ninterface IStrategy is IImplementation {\\n    /**\\n     * @dev Tokens accepted to join the strategy\\n     */\\n    function joinTokens() external view returns (address[] memory);\\n\\n    /**\\n     * @dev Tokens accepted to exit the strategy\\n     */\\n    function exitTokens() external view returns (address[] memory);\\n\\n    /**\\n     * @dev Tells how much a value unit means expressed in the asset token.\\n     * For example, if a strategy has a value of 100 in T0, and then it has a value of 120 in T1,\\n     * and the value rate is 1.5, it means the strategy has earned 30 strategy tokens between T0 and T1.\\n     */\\n    function valueRate() external view returns (uint256);\\n\\n    /**\\n     * @dev Tells the last value an account has over time. Note this value can be outdated: there could be rewards to\\n     * be claimed that will affect the accrued value. For example, if an account has a value of 100 in T0, and then it\\n     * has a value of 120 in T1, it means it gained a 20% between T0 and T1.\\n     * @param account Address of the account querying the last value of\\n     */\\n    function lastValue(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Claim any existing rewards\\n     * @param data Arbitrary extra data\\n     * @return tokens Addresses of the tokens received as rewards\\n     * @return amounts Amounts of the tokens received as rewards\\n     */\\n    function claim(bytes memory data) external returns (address[] memory tokens, uint256[] memory amounts);\\n\\n    /**\\n     * @dev Join the interfaced DeFi protocol\\n     * @param tokensIn List of token addresses to join with\\n     * @param amountsIn List of token amounts to join with\\n     * @param slippage Slippage value to join with\\n     * @param data Arbitrary extra data\\n     * @return tokensOut List of token addresses received after the join\\n     * @return amountsOut List of token amounts received after the join\\n     * @return value Value represented by the joined amount\\n     */\\n    function join(address[] memory tokensIn, uint256[] memory amountsIn, uint256 slippage, bytes memory data)\\n        external\\n        returns (address[] memory tokensOut, uint256[] memory amountsOut, uint256 value);\\n\\n    /**\\n     * @dev Exit the interfaced DeFi protocol\\n     * @param tokensIn List of token addresses to exit with\\n     * @param amountsIn List of token amounts to exit with\\n     * @param slippage Slippage value to exit with\\n     * @param data Arbitrary extra data\\n     * @return tokensOut List of token addresses received after the exit\\n     * @return amountsOut List of token amounts received after the exit\\n     * @return value Value represented by the exited amount\\n     */\\n    function exit(address[] memory tokensIn, uint256[] memory amountsIn, uint256 slippage, bytes memory data)\\n        external\\n        returns (address[] memory tokensOut, uint256[] memory amountsOut, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@mimic-fi/v2-swap-connector/contracts/ISwapConnector.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity >=0.8.0;\\n\\nimport '@mimic-fi/v2-registry/contracts/implementations/IImplementation.sol';\\n\\n/**\\n * @title ISwapConnector\\n * @dev Swap Connector interface to perform token swaps. It must follow the IImplementation interface.\\n */\\ninterface ISwapConnector is IImplementation {\\n    /**\\n     * @dev Enum identifying the sources proposed: Uniswap V2, Uniswap V3, Balancer V2, Paraswap V5, 1inch V5, and Hop.\\n     */\\n    enum Source {\\n        UniswapV2,\\n        UniswapV3,\\n        BalancerV2,\\n        ParaswapV5,\\n        OneInchV5,\\n        Hop\\n    }\\n\\n    /**\\n     * @dev Swaps two tokens\\n     * @param source Source to execute the requested swap\\n     * @param tokenIn Token being sent\\n     * @param tokenOut Token being received\\n     * @param amountIn Amount of tokenIn being swapped\\n     * @param minAmountOut Minimum amount of tokenOut willing to receive\\n     * @param data Encoded data to specify different swap parameters depending on the source picked\\n     */\\n    function swap(\\n        uint8 source,\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 amountIn,\\n        uint256 minAmountOut,\\n        bytes memory data\\n    ) external returns (uint256 amountOut);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\\n     * initialization.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`.\\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\\n        // This gives `2**k < a <= 2**(k+1)` \u2192 `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1;\\n        uint256 x = a;\\n        if (x >> 128 > 0) {\\n            x >>= 128;\\n            result <<= 64;\\n        }\\n        if (x >> 64 > 0) {\\n            x >>= 64;\\n            result <<= 32;\\n        }\\n        if (x >> 32 > 0) {\\n            x >>= 32;\\n            result <<= 16;\\n        }\\n        if (x >> 16 > 0) {\\n            x >>= 16;\\n            result <<= 8;\\n        }\\n        if (x >> 8 > 0) {\\n            x >>= 8;\\n            result <<= 4;\\n        }\\n        if (x >> 4 > 0) {\\n            x >>= 4;\\n            result <<= 2;\\n        }\\n        if (x >> 2 > 0) {\\n            result <<= 1;\\n        }\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = sqrt(a);\\n        if (rounding == Rounding.Up && result * result < a) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableSet.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.\\n *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n *  In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        return _values(set._inner);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/actions/BaseHopBridger.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@mimic-fi/v2-smart-vaults-base/contracts/actions/BaseAction.sol';\\nimport '@mimic-fi/v2-smart-vaults-base/contracts/actions/TokenThresholdAction.sol';\\nimport '@mimic-fi/v2-smart-vaults-base/contracts/actions/ReceiverAction.sol';\\nimport '@mimic-fi/v2-smart-vaults-base/contracts/actions/RelayedAction.sol';\\n\\nabstract contract BaseHopBridger is BaseAction, TokenThresholdAction {\\n    // Hop Exchange source number\\n    uint8 internal constant HOP_SOURCE = 0;\\n\\n    // Chain IDs\\n    uint256 internal constant MAINNET_CHAIN_ID = 1;\\n    uint256 internal constant GOERLI_CHAIN_ID = 5;\\n\\n    uint256 public maxDeadline;\\n    uint256 public maxSlippage;\\n    mapping (uint256 => bool) public isChainAllowed;\\n\\n    event MaxDeadlineSet(uint256 maxDeadline);\\n    event MaxSlippageSet(uint256 maxSlippage);\\n    event AllowedChainSet(uint256 indexed chainId, bool allowed);\\n\\n    function getTokens() external view virtual returns (address[] memory);\\n\\n    function getTokensLength() external view virtual returns (uint256);\\n\\n    function setMaxDeadline(uint256 newMaxDeadline) external auth {\\n        require(newMaxDeadline > 0, 'BRIDGER_MAX_DEADLINE_ZERO');\\n        maxDeadline = newMaxDeadline;\\n        emit MaxDeadlineSet(newMaxDeadline);\\n    }\\n\\n    function setMaxSlippage(uint256 newMaxSlippage) external auth {\\n        require(newMaxSlippage <= FixedPoint.ONE, 'BRIDGER_SLIPPAGE_ABOVE_ONE');\\n        maxSlippage = newMaxSlippage;\\n        emit MaxSlippageSet(newMaxSlippage);\\n    }\\n\\n    function setAllowedChain(uint256 chainId, bool allowed) external auth {\\n        require(chainId != 0, 'BRIDGER_CHAIN_ID_ZERO');\\n        require(chainId != block.chainid, 'BRIDGER_SAME_CHAIN_ID');\\n        isChainAllowed[chainId] = allowed;\\n        emit AllowedChainSet(chainId, allowed);\\n    }\\n\\n    function _bridgingToL1(uint256 chainId) internal pure returns (bool) {\\n        return chainId == MAINNET_CHAIN_ID || chainId == GOERLI_CHAIN_ID;\\n    }\\n\\n    function _bridge(uint256 chainId, address token, uint256 amount, uint256 slippage, bytes memory data) internal {\\n        smartVault.bridge(\\n            HOP_SOURCE,\\n            chainId,\\n            _wrappedIfNative(token),\\n            amount,\\n            ISmartVault.BridgeLimit.Slippage,\\n            slippage,\\n            address(smartVault),\\n            data\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/actions/Funder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@mimic-fi/v2-helpers/contracts/math/FixedPoint.sol';\\nimport '@mimic-fi/v2-helpers/contracts/utils/Denominations.sol';\\nimport '@mimic-fi/v2-smart-vaults-base/contracts/actions/BaseAction.sol';\\nimport '@mimic-fi/v2-smart-vaults-base/contracts/actions/WithdrawalAction.sol';\\n\\ncontract Funder is BaseAction, WithdrawalAction {\\n    using FixedPoint for uint256;\\n\\n    address public tokenIn;\\n    uint256 public minBalance;\\n    uint256 public maxBalance;\\n    uint256 public maxSlippage;\\n\\n    event TokenInSet(address indexed tokenIn);\\n    event MaxSlippageSet(uint256 maxSlippage);\\n    event BalanceLimitsSet(uint256 min, uint256 max);\\n\\n    constructor(address admin, address registry) BaseAction(admin, registry) {\\n        // solhint-disable-previous-line no-empty-blocks\\n    }\\n\\n    function fundeableAmount() external view returns (uint256) {\\n        if (recipient.balance >= minBalance) return 0;\\n\\n        uint256 diff = maxBalance - recipient.balance;\\n        if (_isWrappedOrNativeToken(tokenIn)) return diff;\\n\\n        uint256 price = smartVault.getPrice(smartVault.wrappedNativeToken(), tokenIn);\\n        return diff.mulUp(price);\\n    }\\n\\n    function canExecute(uint256 slippage) external view returns (bool) {\\n        return\\n            recipient != address(0) &&\\n            minBalance > 0 &&\\n            maxBalance > 0 &&\\n            recipient.balance < minBalance &&\\n            tokenIn != address(0) &&\\n            slippage <= maxSlippage;\\n    }\\n\\n    function setTokenIn(address token) external auth {\\n        require(token != address(0), 'FUNDER_TOKEN_IN_ZERO');\\n        tokenIn = token;\\n        emit TokenInSet(token);\\n    }\\n\\n    function setBalanceLimits(uint256 min, uint256 max) external auth {\\n        require(min <= max, 'FUNDER_MIN_GT_MAX');\\n        minBalance = min;\\n        maxBalance = max;\\n        emit BalanceLimitsSet(min, max);\\n    }\\n\\n    function setMaxSlippage(uint256 newMaxSlippage) external auth {\\n        require(newMaxSlippage <= FixedPoint.ONE, 'SWAPPER_SLIPPAGE_ABOVE_ONE');\\n        maxSlippage = newMaxSlippage;\\n        emit MaxSlippageSet(newMaxSlippage);\\n    }\\n\\n    function call(uint8 source, uint256 slippage, bytes memory data) external auth nonReentrant {\\n        require(recipient != address(0), 'FUNDER_RECIPIENT_NOT_SET');\\n        require(minBalance > 0, 'FUNDER_BALANCE_LIMIT_NOT_SET');\\n        require(recipient.balance < minBalance, 'FUNDER_BALANCE_ABOVE_MIN');\\n        require(tokenIn != address(0), 'FUNDER_TOKEN_IN_NOT_SET');\\n        require(slippage <= maxSlippage, 'FUNDER_SLIPPAGE_ABOVE_MAX');\\n\\n        uint256 toWithdraw = 0;\\n        uint256 diff = maxBalance - recipient.balance;\\n        if (Denominations.isNativeToken(tokenIn)) toWithdraw = diff;\\n        else {\\n            uint256 toUnwrap = 0;\\n            address wrappedNativeToken = smartVault.wrappedNativeToken();\\n            if (tokenIn == wrappedNativeToken) toUnwrap = diff;\\n            else {\\n                uint256 price = smartVault.getPrice(wrappedNativeToken, tokenIn);\\n                uint256 amountIn = diff.mulUp(price);\\n                toUnwrap = smartVault.swap(\\n                    source,\\n                    tokenIn,\\n                    wrappedNativeToken,\\n                    amountIn,\\n                    ISmartVault.SwapLimit.Slippage,\\n                    slippage,\\n                    data\\n                );\\n            }\\n            toWithdraw = smartVault.unwrap(toUnwrap, new bytes(0));\\n        }\\n\\n        _withdraw(Denominations.NATIVE_TOKEN, toWithdraw);\\n        emit Executed();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/actions/FunderV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@mimic-fi/v2-helpers/contracts/math/FixedPoint.sol';\\nimport '@mimic-fi/v2-helpers/contracts/utils/Denominations.sol';\\nimport '@mimic-fi/v2-smart-vaults-base/contracts/actions/BaseAction.sol';\\nimport '@mimic-fi/v2-smart-vaults-base/contracts/actions/WithdrawalAction.sol';\\n\\ncontract FunderV2 is BaseAction, WithdrawalAction {\\n    using FixedPoint for uint256;\\n\\n    address public tokenIn;\\n    uint256 public minBalance;\\n    uint256 public maxBalance;\\n    uint256 public maxSlippage;\\n\\n    event TokenInSet(address indexed tokenIn);\\n    event MaxSlippageSet(uint256 maxSlippage);\\n    event BalanceLimitsSet(uint256 min, uint256 max);\\n\\n    constructor(\\n        address _smartVault,\\n        address _tokenIn,\\n        uint256 _minBalance,\\n        uint256 _maxBalance,\\n        uint256 _maxSlippage,\\n        address _recipient,\\n        address _admin,\\n        address _owner,\\n        address _registry\\n    ) BaseAction(_owner, _registry) {\\n        require(address(_smartVault) != address(0), 'SMART_VAULT_ZERO');\\n        smartVault = ISmartVault(_smartVault);\\n        emit SmartVaultSet(_smartVault);\\n\\n        _setTokenIn(_tokenIn);\\n        _setBalanceLimits(_minBalance, _maxBalance);\\n        _setMaxSlippage(_maxSlippage);\\n\\n        require(_recipient != address(0), 'RECIPIENT_ZERO');\\n        recipient = _recipient;\\n        emit RecipientSet(_recipient);\\n\\n        _authorize(_admin, BaseAction.setSmartVault.selector);\\n        _authorize(_admin, FunderV2.setTokenIn.selector);\\n        _authorize(_admin, FunderV2.setBalanceLimits.selector);\\n        _authorize(_admin, FunderV2.setMaxSlippage.selector);\\n        _authorize(_admin, WithdrawalAction.setRecipient.selector);\\n    }\\n\\n    function fundeableAmount() public view returns (uint256) {\\n        if (recipient.balance >= minBalance) return 0;\\n\\n        uint256 diff = maxBalance - recipient.balance;\\n        if (_isWrappedOrNativeToken(tokenIn)) return diff;\\n\\n        uint256 price = smartVault.getPrice(smartVault.wrappedNativeToken(), tokenIn);\\n        return diff.mulUp(price);\\n    }\\n\\n    function canExecute(uint256 amountIn, uint256 slippage) external view returns (bool) {\\n        return\\n            recipient != address(0) &&\\n            tokenIn != address(0) &&\\n            minBalance > 0 &&\\n            maxBalance > 0 &&\\n            amountIn <= fundeableAmount() &&\\n            slippage <= maxSlippage;\\n    }\\n\\n    function setTokenIn(address token) external auth {\\n        _setTokenIn(token);\\n    }\\n\\n    function setBalanceLimits(uint256 min, uint256 max) external auth {\\n        _setBalanceLimits(min, max);\\n    }\\n\\n    function setMaxSlippage(uint256 newMaxSlippage) external auth {\\n        _setMaxSlippage(newMaxSlippage);\\n    }\\n\\n    function call(uint8 source, uint256 amountIn, uint256 slippage, bytes memory data) external auth nonReentrant {\\n        require(recipient != address(0), 'FUNDER_RECIPIENT_NOT_SET');\\n        require(minBalance > 0, 'FUNDER_BALANCE_LIMIT_NOT_SET');\\n        require(tokenIn != address(0), 'FUNDER_TOKEN_IN_NOT_SET');\\n        require(amountIn > 0, 'FUNDER_AMOUNT_IN_ZERO');\\n        require(amountIn <= fundeableAmount(), 'FUNDER_AMOUNT_IN_ABOVE_MAX');\\n        require(slippage <= maxSlippage, 'FUNDER_SLIPPAGE_ABOVE_MAX');\\n\\n        uint256 toWithdraw = Denominations.isNativeToken(tokenIn) ? amountIn : _swap(source, amountIn, slippage, data);\\n        _withdraw(Denominations.NATIVE_TOKEN, toWithdraw);\\n        emit Executed();\\n    }\\n\\n    function _swap(uint8 source, uint256 amountIn, uint256 slippage, bytes memory data) private returns (uint256) {\\n        address wrappedNativeToken = smartVault.wrappedNativeToken();\\n        uint256 toUnwrap = tokenIn == wrappedNativeToken\\n            ? amountIn\\n            : smartVault.swap(\\n                source,\\n                tokenIn,\\n                wrappedNativeToken,\\n                amountIn,\\n                ISmartVault.SwapLimit.Slippage,\\n                slippage,\\n                data\\n            );\\n        return smartVault.unwrap(toUnwrap, new bytes(0));\\n    }\\n\\n    function _setTokenIn(address token) private {\\n        require(token != address(0), 'FUNDER_TOKEN_IN_ZERO');\\n        tokenIn = token;\\n        emit TokenInSet(token);\\n    }\\n\\n    function _setBalanceLimits(uint256 min, uint256 max) private {\\n        require(min <= max, 'FUNDER_MIN_GT_MAX');\\n        minBalance = min;\\n        maxBalance = max;\\n        emit BalanceLimitsSet(min, max);\\n    }\\n\\n    function _setMaxSlippage(uint256 newMaxSlippage) private {\\n        require(newMaxSlippage <= FixedPoint.ONE, 'SWAPPER_SLIPPAGE_ABOVE_ONE');\\n        maxSlippage = newMaxSlippage;\\n        emit MaxSlippageSet(newMaxSlippage);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/actions/Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\nimport '@mimic-fi/v2-swap-connector/contracts/ISwapConnector.sol';\\nimport '@mimic-fi/v2-smart-vaults-base/contracts/actions/BaseAction.sol';\\nimport '@mimic-fi/v2-smart-vaults-base/contracts/actions/TokenThresholdAction.sol';\\n\\ncontract Holder is BaseAction, TokenThresholdAction {\\n    address public tokenOut;\\n    uint256 public maxSlippage;\\n\\n    event TokenOutSet(address indexed tokenOut);\\n    event MaxSlippageSet(uint256 maxSlippage);\\n\\n    constructor(address admin, address registry) BaseAction(admin, registry) {\\n        // solhint-disable-previous-line no-empty-blocks\\n    }\\n\\n    function canExecute(address tokenIn, uint256 amountIn, uint256 slippage) external view returns (bool) {\\n        if (tokenOut == address(0) || slippage > maxSlippage) return false;\\n        return _passesThreshold(tokenIn, amountIn);\\n    }\\n\\n    function setTokenOut(address token) external auth {\\n        require(token != address(0), 'HOLDER_TOKEN_OUT_ZERO');\\n        require(!Denominations.isNativeToken(token), 'HOLDER_NATIVE_TOKEN_OUT');\\n        tokenOut = token;\\n        emit TokenOutSet(token);\\n    }\\n\\n    function setMaxSlippage(uint256 newMaxSlippage) external auth {\\n        require(newMaxSlippage <= FixedPoint.ONE, 'HOLDER_SLIPPAGE_ABOVE_ONE');\\n        maxSlippage = newMaxSlippage;\\n        emit MaxSlippageSet(newMaxSlippage);\\n    }\\n\\n    function call(uint8 source, address tokenIn, uint256 amountIn, uint256 slippage, bytes memory data)\\n        external\\n        auth\\n        nonReentrant\\n    {\\n        require(tokenOut != address(0), 'HOLDER_TOKEN_OUT_NOT_SET');\\n        require(tokenIn != address(0), 'HOLDER_TOKEN_IN_ZERO');\\n        require(tokenIn != tokenOut, 'HOLDER_TOKEN_IN_EQ_OUT');\\n        require(slippage <= maxSlippage, 'HOLDER_SLIPPAGE_ABOVE_MAX');\\n        _validateThreshold(tokenIn, amountIn);\\n\\n        if (Denominations.isNativeToken(tokenIn)) amountIn = smartVault.wrap(amountIn, new bytes(0));\\n        tokenIn = _wrappedIfNative(tokenIn);\\n\\n        if (tokenIn != tokenOut) {\\n            // token in might haven been updated to be the wrapped native token\\n            smartVault.swap(source, tokenIn, tokenOut, amountIn, ISmartVault.SwapLimit.Slippage, slippage, data);\\n        }\\n\\n        emit Executed();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/actions/L1HopBridger.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@mimic-fi/v2-bridge-connector/contracts/interfaces/IHopL1Bridge.sol';\\nimport '@mimic-fi/v2-helpers/contracts/math/FixedPoint.sol';\\nimport '@mimic-fi/v2-helpers/contracts/utils/EnumerableMap.sol';\\n\\nimport './BaseHopBridger.sol';\\n\\ncontract L1HopBridger is BaseHopBridger {\\n    using FixedPoint for uint256;\\n    using EnumerableMap for EnumerableMap.AddressToAddressMap;\\n\\n    EnumerableMap.AddressToAddressMap private tokenBridges;\\n    mapping (address => uint256) public getMaxRelayerFeePct;\\n\\n    event TokenBridgeSet(address indexed token, address indexed bridge);\\n    event MaxRelayerFeePctSet(address indexed relayer, uint256 maxFeePct);\\n\\n    constructor(address admin, address registry) BaseAction(admin, registry) {\\n        // solhint-disable-previous-line no-empty-blocks\\n    }\\n\\n    function getTokensLength() external view override returns (uint256) {\\n        return tokenBridges.length();\\n    }\\n\\n    function getTokenBridge(address token) external view returns (address bridge) {\\n        (, bridge) = tokenBridges.tryGet(token);\\n    }\\n\\n    function getTokens() external view override returns (address[] memory tokens) {\\n        tokens = new address[](tokenBridges.length());\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            (address token, ) = tokenBridges.at(i);\\n            tokens[i] = token;\\n        }\\n    }\\n\\n    function getTokenBridges() external view returns (address[] memory tokens, address[] memory bridges) {\\n        tokens = new address[](tokenBridges.length());\\n        bridges = new address[](tokens.length);\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            (address token, address bridge) = tokenBridges.at(i);\\n            tokens[i] = token;\\n            bridges[i] = bridge;\\n        }\\n    }\\n\\n    function canExecute(\\n        uint256 chainId,\\n        address token,\\n        uint256 amount,\\n        uint256 slippage,\\n        address relayer,\\n        uint256 relayerFee\\n    ) external view returns (bool) {\\n        return\\n            tokenBridges.contains(token) &&\\n            amount > 0 &&\\n            isChainAllowed[chainId] &&\\n            slippage <= maxSlippage &&\\n            relayerFee.divUp(amount) <= getMaxRelayerFeePct[relayer] &&\\n            _passesThreshold(token, amount);\\n    }\\n\\n    function setMaxRelayerFeePct(address relayer, uint256 newMaxFeePct) external auth {\\n        require(newMaxFeePct <= FixedPoint.ONE, 'BRIDGER_RELAYER_FEE_PCT_GT_ONE');\\n        getMaxRelayerFeePct[relayer] = newMaxFeePct;\\n        emit MaxRelayerFeePctSet(relayer, newMaxFeePct);\\n    }\\n\\n    function setTokenBridge(address token, address bridge) external auth {\\n        require(token != address(0), 'BRIDGER_TOKEN_ZERO');\\n        bridge == address(0) ? tokenBridges.remove(token) : tokenBridges.set(token, bridge);\\n        emit TokenBridgeSet(token, bridge);\\n    }\\n\\n    function call(uint256 chainId, address token, uint256 amount, uint256 slippage, address relayer, uint256 relayerFee)\\n        external\\n        auth\\n        nonReentrant\\n    {\\n        (bool existsBridge, address bridge) = tokenBridges.tryGet(token);\\n        require(existsBridge, 'BRIDGER_TOKEN_BRIDGE_NOT_SET');\\n        require(amount > 0, 'BRIDGER_AMOUNT_ZERO');\\n        require(isChainAllowed[chainId], 'BRIDGER_CHAIN_NOT_ALLOWED');\\n        require(slippage <= maxSlippage, 'BRIDGER_SLIPPAGE_ABOVE_MAX');\\n        require(relayerFee.divUp(amount) <= getMaxRelayerFeePct[relayer], 'BRIDGER_RELAYER_FEE_ABOVE_MAX');\\n        _validateThreshold(token, amount);\\n\\n        if (Denominations.isNativeToken(token)) smartVault.wrap(amount, new bytes(0));\\n        uint256 deadline = block.timestamp + maxDeadline;\\n        bytes memory data = abi.encode(bridge, deadline, relayer, relayerFee);\\n        _bridge(chainId, token, amount, slippage, data);\\n        emit Executed();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/actions/L2HopBridger.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@mimic-fi/v2-bridge-connector/contracts/interfaces/IHopL2AMM.sol';\\nimport '@mimic-fi/v2-helpers/contracts/math/FixedPoint.sol';\\nimport '@mimic-fi/v2-helpers/contracts/utils/EnumerableMap.sol';\\n\\nimport './BaseHopBridger.sol';\\n\\ncontract L2HopBridger is BaseHopBridger {\\n    using FixedPoint for uint256;\\n    using EnumerableMap for EnumerableMap.AddressToAddressMap;\\n\\n    uint256 public maxBonderFeePct;\\n    EnumerableMap.AddressToAddressMap private tokenAmms;\\n\\n    event MaxBonderFeePctSet(uint256 maxBonderFeePct);\\n    event TokenAmmSet(address indexed token, address indexed amm);\\n\\n    constructor(address admin, address registry) BaseAction(admin, registry) {\\n        // solhint-disable-previous-line no-empty-blocks\\n    }\\n\\n    function getTokensLength() external view override returns (uint256) {\\n        return tokenAmms.length();\\n    }\\n\\n    function getTokenAmm(address token) external view returns (address amm) {\\n        (, amm) = tokenAmms.tryGet(token);\\n    }\\n\\n    function getTokens() external view override returns (address[] memory tokens) {\\n        tokens = new address[](tokenAmms.length());\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            (address token, ) = tokenAmms.at(i);\\n            tokens[i] = token;\\n        }\\n    }\\n\\n    function getTokenAmms() external view returns (address[] memory tokens, address[] memory amms) {\\n        tokens = new address[](tokenAmms.length());\\n        amms = new address[](tokens.length);\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            (address token, address amm) = tokenAmms.at(i);\\n            tokens[i] = token;\\n            amms[i] = amm;\\n        }\\n    }\\n\\n    function canExecute(uint256 chainId, address token, uint256 amount, uint256 slippage, uint256 bonderFee)\\n        external\\n        view\\n        returns (bool)\\n    {\\n        return\\n            tokenAmms.contains(token) &&\\n            amount > 0 &&\\n            isChainAllowed[chainId] &&\\n            slippage <= maxSlippage &&\\n            bonderFee.divUp(amount) <= maxBonderFeePct &&\\n            _passesThreshold(token, amount);\\n    }\\n\\n    function setMaxBonderFeePct(uint256 newMaxBonderFeePct) external auth {\\n        require(newMaxBonderFeePct <= FixedPoint.ONE, 'BRIDGER_BONDER_FEE_PCT_ABOVE_ONE');\\n        maxBonderFeePct = newMaxBonderFeePct;\\n        emit MaxBonderFeePctSet(newMaxBonderFeePct);\\n    }\\n\\n    function setTokenAmm(address token, address amm) external auth {\\n        require(token != address(0), 'BRIDGER_TOKEN_ZERO');\\n        amm == address(0) ? tokenAmms.remove(token) : tokenAmms.set(token, amm);\\n        emit TokenAmmSet(token, amm);\\n    }\\n\\n    function call(uint256 chainId, address token, uint256 amount, uint256 slippage, uint256 bonderFee)\\n        external\\n        auth\\n        nonReentrant\\n    {\\n        (bool existsAmm, address amm) = tokenAmms.tryGet(token);\\n        require(existsAmm, 'BRIDGER_TOKEN_AMM_NOT_SET');\\n        require(amount > 0, 'BRIDGER_AMOUNT_ZERO');\\n        require(isChainAllowed[chainId], 'BRIDGER_CHAIN_NOT_ALLOWED');\\n        require(slippage <= maxSlippage, 'BRIDGER_SLIPPAGE_ABOVE_MAX');\\n        require(bonderFee.divUp(amount) <= maxBonderFeePct, 'BRIDGER_BONDER_FEE_ABOVE_MAX');\\n        _validateThreshold(token, amount);\\n\\n        if (Denominations.isNativeToken(token)) smartVault.wrap(amount, new bytes(0));\\n        bytes memory data = _bridgingToL1(chainId)\\n            ? abi.encode(amm, bonderFee)\\n            : abi.encode(amm, bonderFee, block.timestamp + maxDeadline);\\n\\n        _bridge(chainId, token, amount, slippage, data);\\n        emit Executed();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/actions/L2HopSwapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@mimic-fi/v2-bridge-connector/contracts/interfaces/IHopL2AMM.sol';\\nimport '@mimic-fi/v2-helpers/contracts/math/FixedPoint.sol';\\nimport '@mimic-fi/v2-helpers/contracts/math/UncheckedMath.sol';\\nimport '@mimic-fi/v2-helpers/contracts/utils/EnumerableMap.sol';\\nimport '@mimic-fi/v2-smart-vaults-base/contracts/actions/BaseAction.sol';\\nimport '@mimic-fi/v2-smart-vaults-base/contracts/actions/TokenThresholdAction.sol';\\nimport '@mimic-fi/v2-smart-vaults-base/contracts/actions/RelayedAction.sol';\\n\\ncontract L2HopSwapper is BaseAction {\\n    using FixedPoint for uint256;\\n    using UncheckedMath for uint256;\\n    using EnumerableMap for EnumerableMap.AddressToAddressMap;\\n\\n    // Hop Exchange source number\\n    uint8 internal constant HOP_SOURCE = 5;\\n\\n    uint256 public maxSlippage;\\n    EnumerableMap.AddressToAddressMap private tokenAmms;\\n\\n    event MaxSlippageSet(uint256 maxSlippage);\\n    event TokenAmmSet(address indexed token, address indexed amm);\\n\\n    constructor(address admin, address registry) BaseAction(admin, registry) {\\n        // solhint-disable-previous-line no-empty-blocks\\n    }\\n\\n    function getTokensLength() external view returns (uint256) {\\n        return tokenAmms.length();\\n    }\\n\\n    function getTokenAmm(address token) external view returns (address amm) {\\n        (, amm) = tokenAmms.tryGet(token);\\n    }\\n\\n    function getTokens() external view returns (address[] memory tokens) {\\n        tokens = new address[](tokenAmms.length());\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            (address token, ) = tokenAmms.at(i);\\n            tokens[i] = token;\\n        }\\n    }\\n\\n    function getTokenAmms() external view returns (address[] memory tokens, address[] memory amms) {\\n        tokens = new address[](tokenAmms.length());\\n        amms = new address[](tokens.length);\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            (address token, address amm) = tokenAmms.at(i);\\n            tokens[i] = token;\\n            amms[i] = amm;\\n        }\\n    }\\n\\n    function canExecute(address token, uint256 amount, uint256 slippage) external view returns (bool) {\\n        (bool existsAmm, address amm) = tokenAmms.tryGet(token);\\n        return existsAmm && amount <= _balanceOf(IHopL2AMM(amm).hToken()) && slippage <= maxSlippage;\\n    }\\n\\n    function setMaxSlippage(uint256 newMaxSlippage) external auth {\\n        require(newMaxSlippage <= FixedPoint.ONE, 'SWAPPER_SLIPPAGE_ABOVE_ONE');\\n        maxSlippage = newMaxSlippage;\\n        emit MaxSlippageSet(newMaxSlippage);\\n    }\\n\\n    function setTokenAmm(address token, address amm) external auth {\\n        require(token != address(0), 'SWAPPER_TOKEN_ZERO');\\n        amm == address(0) ? tokenAmms.remove(token) : tokenAmms.set(token, amm);\\n        emit TokenAmmSet(token, amm);\\n    }\\n\\n    function call(address token, uint256 amount, uint256 slippage) external auth nonReentrant {\\n        (bool existsAmm, address amm) = tokenAmms.tryGet(token);\\n        require(existsAmm, 'SWAPPER_TOKEN_AMM_NOT_SET');\\n\\n        address hToken = IHopL2AMM(amm).hToken();\\n        require(amount <= _balanceOf(hToken), 'SWAPPER_AMOUNT_EXCEEDS_BALANCE');\\n        require(slippage <= maxSlippage, 'SWAPPER_SLIPPAGE_ABOVE_MAX');\\n\\n        bytes memory data = abi.encode(IHopL2AMM(amm).exchangeAddress());\\n        uint256 minAmountOut = amount.mulUp(FixedPoint.ONE.uncheckedSub(slippage));\\n        smartVault.swap(HOP_SOURCE, hToken, token, amount, ISmartVault.SwapLimit.MinAmountOut, minAmountOut, data);\\n        emit Executed();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/BaseSmartVaultDeployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@mimic-fi/v2-helpers/contracts/utils/Arrays.sol';\\nimport '@mimic-fi/v2-smart-vault/contracts/SmartVault.sol';\\nimport '@mimic-fi/v2-smart-vaults-base/contracts/deploy/Deployer.sol';\\n\\nimport './actions/Funder.sol';\\nimport './actions/Holder.sol';\\n\\n// solhint-disable avoid-low-level-calls\\n\\ncontract BaseSmartVaultDeployer {\\n    struct FunderActionParams {\\n        address impl;\\n        address admin;\\n        address[] managers;\\n        address tokenIn;\\n        uint256 minBalance;\\n        uint256 maxBalance;\\n        uint256 maxSlippage;\\n        Deployer.WithdrawalActionParams withdrawalActionParams;\\n    }\\n\\n    struct HolderActionParams {\\n        address impl;\\n        address admin;\\n        address[] managers;\\n        address tokenOut;\\n        uint256 maxSlippage;\\n        Deployer.TokenThresholdActionParams tokenThresholdActionParams;\\n    }\\n\\n    function _setupFunderAction(SmartVault smartVault, FunderActionParams memory params) internal {\\n        // Create and setup action\\n        Funder funder = Funder(params.impl);\\n        Deployer.setupBaseAction(funder, params.admin, address(smartVault));\\n        address[] memory executors = Arrays.from(params.admin, params.managers, new address[](0));\\n        Deployer.setupActionExecutors(funder, executors, funder.call.selector);\\n        Deployer.setupWithdrawalAction(funder, params.admin, params.withdrawalActionParams);\\n\\n        // Set funder token in\\n        funder.authorize(params.admin, funder.setTokenIn.selector);\\n        funder.authorize(address(this), funder.setTokenIn.selector);\\n        funder.setTokenIn(params.tokenIn);\\n        funder.unauthorize(address(this), funder.setTokenIn.selector);\\n\\n        // Set funder balance limits\\n        funder.authorize(params.admin, funder.setBalanceLimits.selector);\\n        funder.authorize(address(this), funder.setBalanceLimits.selector);\\n        funder.setBalanceLimits(params.minBalance, params.maxBalance);\\n        funder.unauthorize(address(this), funder.setBalanceLimits.selector);\\n\\n        // Set funder max slippage\\n        funder.authorize(params.admin, funder.setMaxSlippage.selector);\\n        funder.authorize(address(this), funder.setMaxSlippage.selector);\\n        funder.setMaxSlippage(params.maxSlippage);\\n        funder.unauthorize(address(this), funder.setMaxSlippage.selector);\\n\\n        // Transfer admin permissions to admin\\n        Deployer.transferAdminPermissions(funder, params.admin);\\n\\n        // Authorize action to swap, unwrap, and withdraw from Smart Vault\\n        smartVault.authorize(address(funder), smartVault.swap.selector);\\n        smartVault.authorize(address(funder), smartVault.unwrap.selector);\\n        smartVault.authorize(address(funder), smartVault.withdraw.selector);\\n    }\\n\\n    function _setupHolderAction(SmartVault smartVault, HolderActionParams memory params) internal {\\n        // Create and setup action\\n        Holder holder = Holder(params.impl);\\n        Deployer.setupBaseAction(holder, params.admin, address(smartVault));\\n        address[] memory executors = Arrays.from(params.admin, params.managers, new address[](0));\\n        Deployer.setupActionExecutors(holder, executors, holder.call.selector);\\n        Deployer.setupTokenThresholdAction(holder, params.admin, params.tokenThresholdActionParams);\\n\\n        // Set holder token out\\n        holder.authorize(params.admin, holder.setTokenOut.selector);\\n        holder.authorize(address(this), holder.setTokenOut.selector);\\n        holder.setTokenOut(params.tokenOut);\\n        holder.unauthorize(address(this), holder.setTokenOut.selector);\\n\\n        // Set holder max slippage\\n        holder.authorize(params.admin, holder.setMaxSlippage.selector);\\n        holder.authorize(address(this), holder.setMaxSlippage.selector);\\n        holder.setMaxSlippage(params.maxSlippage);\\n        holder.unauthorize(address(this), holder.setMaxSlippage.selector);\\n\\n        // Transfer admin permissions to admin\\n        Deployer.transferAdminPermissions(holder, params.admin);\\n\\n        // Authorize action to wrap and swap from Smart Vault\\n        smartVault.authorize(address(holder), smartVault.wrap.selector);\\n        smartVault.authorize(address(holder), smartVault.swap.selector);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/L1SmartVaultDeployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@mimic-fi/v2-helpers/contracts/utils/Arrays.sol';\\nimport '@mimic-fi/v2-helpers/contracts/math/UncheckedMath.sol';\\nimport '@mimic-fi/v2-registry/contracts/registry/IRegistry.sol';\\nimport '@mimic-fi/v2-smart-vault/contracts/SmartVault.sol';\\nimport '@mimic-fi/v2-smart-vaults-base/contracts/deploy/Deployer.sol';\\n\\nimport './actions/L1HopBridger.sol';\\nimport './BaseSmartVaultDeployer.sol';\\n\\n// solhint-disable avoid-low-level-calls\\n\\ncontract L1SmartVaultDeployer is BaseSmartVaultDeployer {\\n    using UncheckedMath for uint256;\\n\\n    struct Params {\\n        IRegistry registry;\\n        Deployer.SmartVaultParams smartVaultParams;\\n        FunderActionParams funderActionParams;\\n        HolderActionParams holderActionParams;\\n        L1HopBridgerActionParams l1HopBridgerActionParams;\\n    }\\n\\n    struct L1HopBridgerActionParams {\\n        address impl;\\n        address admin;\\n        address[] managers;\\n        uint256 maxDeadline;\\n        uint256 maxSlippage;\\n        uint256[] allowedChainIds;\\n        HopBridgeParams[] hopBridgeParams;\\n        HopRelayerParams[] hopRelayerParams;\\n        Deployer.TokenThresholdActionParams tokenThresholdActionParams;\\n    }\\n\\n    struct HopBridgeParams {\\n        address token;\\n        address bridge;\\n    }\\n\\n    struct HopRelayerParams {\\n        address relayer;\\n        uint256 maxFeePct;\\n    }\\n\\n    function deploy(Params memory params) external {\\n        SmartVault smartVault = Deployer.createSmartVault(params.registry, params.smartVaultParams, false);\\n        _setupFunderAction(smartVault, params.funderActionParams);\\n        _setupHolderAction(smartVault, params.holderActionParams);\\n        _setupL1HopBridgerAction(smartVault, params.l1HopBridgerActionParams);\\n        Deployer.transferAdminPermissions(smartVault, params.smartVaultParams.admin);\\n    }\\n\\n    function _setupL1HopBridgerAction(SmartVault smartVault, L1HopBridgerActionParams memory params) internal {\\n        // Create and setup action\\n        L1HopBridger bridger = L1HopBridger(payable(params.impl));\\n        Deployer.setupBaseAction(bridger, params.admin, address(smartVault));\\n        address[] memory executors = Arrays.from(params.admin, params.managers, new address[](0));\\n        Deployer.setupActionExecutors(bridger, executors, bridger.call.selector);\\n        Deployer.setupTokenThresholdAction(bridger, params.admin, params.tokenThresholdActionParams);\\n\\n        // Set bridger max deadline\\n        bridger.authorize(params.admin, bridger.setMaxDeadline.selector);\\n        bridger.authorize(address(this), bridger.setMaxDeadline.selector);\\n        bridger.setMaxDeadline(params.maxDeadline);\\n        bridger.unauthorize(address(this), bridger.setMaxDeadline.selector);\\n\\n        // Set bridger max slippage\\n        bridger.authorize(params.admin, bridger.setMaxSlippage.selector);\\n        bridger.authorize(address(this), bridger.setMaxSlippage.selector);\\n        bridger.setMaxSlippage(params.maxSlippage);\\n        bridger.unauthorize(address(this), bridger.setMaxSlippage.selector);\\n\\n        // Set bridger max relayer fee pcts\\n        bridger.authorize(params.admin, bridger.setMaxRelayerFeePct.selector);\\n        bridger.authorize(address(this), bridger.setMaxRelayerFeePct.selector);\\n        for (uint256 i = 0; i < params.hopRelayerParams.length; i = i.uncheckedAdd(1)) {\\n            HopRelayerParams memory hopRelayerParam = params.hopRelayerParams[i];\\n            bridger.setMaxRelayerFeePct(hopRelayerParam.relayer, hopRelayerParam.maxFeePct);\\n        }\\n        bridger.unauthorize(address(this), bridger.setMaxRelayerFeePct.selector);\\n\\n        // Set bridger AMMs\\n        bridger.authorize(params.admin, bridger.setTokenBridge.selector);\\n        bridger.authorize(address(this), bridger.setTokenBridge.selector);\\n        for (uint256 i = 0; i < params.hopBridgeParams.length; i = i.uncheckedAdd(1)) {\\n            HopBridgeParams memory hopBridgeParam = params.hopBridgeParams[i];\\n            bridger.setTokenBridge(hopBridgeParam.token, hopBridgeParam.bridge);\\n        }\\n        bridger.unauthorize(address(this), bridger.setTokenBridge.selector);\\n\\n        // Set bridger chain IDs\\n        bridger.authorize(params.admin, bridger.setAllowedChain.selector);\\n        bridger.authorize(address(this), bridger.setAllowedChain.selector);\\n        for (uint256 i = 0; i < params.allowedChainIds.length; i = i.uncheckedAdd(1)) {\\n            bridger.setAllowedChain(params.allowedChainIds[i], true);\\n        }\\n        bridger.unauthorize(address(this), bridger.setAllowedChain.selector);\\n\\n        // Transfer admin permissions to admin\\n        Deployer.transferAdminPermissions(bridger, params.admin);\\n\\n        // Authorize action to bridge from Smart Vault\\n        smartVault.authorize(address(bridger), smartVault.bridge.selector);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/L2BridgingSmartVaultDeployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@mimic-fi/v2-helpers/contracts/utils/Arrays.sol';\\nimport '@mimic-fi/v2-helpers/contracts/math/UncheckedMath.sol';\\nimport '@mimic-fi/v2-registry/contracts/registry/IRegistry.sol';\\nimport '@mimic-fi/v2-smart-vault/contracts/SmartVault.sol';\\nimport '@mimic-fi/v2-smart-vaults-base/contracts/deploy/Deployer.sol';\\n\\nimport './actions/L2HopBridger.sol';\\nimport './actions/L2HopSwapper.sol';\\nimport './BaseSmartVaultDeployer.sol';\\n\\n// solhint-disable avoid-low-level-calls\\n\\ncontract L2BridgingSmartVaultDeployer is BaseSmartVaultDeployer {\\n    using UncheckedMath for uint256;\\n\\n    struct Params {\\n        IRegistry registry;\\n        Deployer.SmartVaultParams smartVaultParams;\\n        FunderActionParams funderActionParams;\\n        HolderActionParams holderActionParams;\\n        L2HopSwapperActionParams l2HopSwapperActionParams;\\n        L2HopBridgerActionParams l2HopBridgerActionParams;\\n    }\\n\\n    struct L2HopSwapperActionParams {\\n        address impl;\\n        address admin;\\n        address[] managers;\\n        uint256 maxSlippage;\\n        HopAmmParams[] hopAmmParams;\\n    }\\n\\n    struct L2HopBridgerActionParams {\\n        address impl;\\n        address admin;\\n        address[] managers;\\n        uint256 maxDeadline;\\n        uint256 maxSlippage;\\n        uint256 maxBonderFeePct;\\n        uint256[] allowedChainIds;\\n        HopAmmParams[] hopAmmParams;\\n        Deployer.TokenThresholdActionParams tokenThresholdActionParams;\\n    }\\n\\n    struct HopAmmParams {\\n        address token;\\n        address amm;\\n    }\\n\\n    function deploy(Params memory params) external {\\n        SmartVault smartVault = Deployer.createSmartVault(params.registry, params.smartVaultParams, false);\\n        _setupFunderAction(smartVault, params.funderActionParams);\\n        _setupHolderAction(smartVault, params.holderActionParams);\\n        _setupL2HopSwapperAction(smartVault, params.l2HopSwapperActionParams);\\n        _setupL2HopBridgerAction(smartVault, params.l2HopBridgerActionParams);\\n        Deployer.transferAdminPermissions(smartVault, params.smartVaultParams.admin);\\n    }\\n\\n    function _setupL2HopSwapperAction(SmartVault smartVault, L2HopSwapperActionParams memory params) internal {\\n        // Create and setup action\\n        L2HopSwapper swapper = L2HopSwapper(params.impl);\\n        Deployer.setupBaseAction(swapper, params.admin, address(smartVault));\\n        address[] memory executors = Arrays.from(params.admin, params.managers, new address[](0));\\n        Deployer.setupActionExecutors(swapper, executors, swapper.call.selector);\\n\\n        // Set swapper max slippage\\n        swapper.authorize(params.admin, swapper.setMaxSlippage.selector);\\n        swapper.authorize(address(this), swapper.setMaxSlippage.selector);\\n        swapper.setMaxSlippage(params.maxSlippage);\\n        swapper.unauthorize(address(this), swapper.setMaxSlippage.selector);\\n\\n        // Set swapper AMMs\\n        swapper.authorize(params.admin, swapper.setTokenAmm.selector);\\n        swapper.authorize(address(this), swapper.setTokenAmm.selector);\\n        for (uint256 i = 0; i < params.hopAmmParams.length; i = i.uncheckedAdd(1)) {\\n            HopAmmParams memory hopAmmParam = params.hopAmmParams[i];\\n            swapper.setTokenAmm(hopAmmParam.token, hopAmmParam.amm);\\n        }\\n        swapper.unauthorize(address(this), swapper.setTokenAmm.selector);\\n\\n        // Transfer admin permissions to admin\\n        Deployer.transferAdminPermissions(swapper, params.admin);\\n\\n        // Authorize action to swap from Smart Vault\\n        smartVault.authorize(address(swapper), smartVault.swap.selector);\\n    }\\n\\n    function _setupL2HopBridgerAction(SmartVault smartVault, L2HopBridgerActionParams memory params) internal {\\n        // Create and setup action\\n        L2HopBridger bridger = L2HopBridger(payable(params.impl));\\n        Deployer.setupBaseAction(bridger, params.admin, address(smartVault));\\n        address[] memory executors = Arrays.from(params.admin, params.managers, new address[](0));\\n        Deployer.setupActionExecutors(bridger, executors, bridger.call.selector);\\n        Deployer.setupTokenThresholdAction(bridger, params.admin, params.tokenThresholdActionParams);\\n\\n        // Set bridger max deadline\\n        bridger.authorize(params.admin, bridger.setMaxDeadline.selector);\\n        bridger.authorize(address(this), bridger.setMaxDeadline.selector);\\n        bridger.setMaxDeadline(params.maxDeadline);\\n        bridger.unauthorize(address(this), bridger.setMaxDeadline.selector);\\n\\n        // Set bridger max slippage\\n        bridger.authorize(params.admin, bridger.setMaxSlippage.selector);\\n        bridger.authorize(address(this), bridger.setMaxSlippage.selector);\\n        bridger.setMaxSlippage(params.maxSlippage);\\n        bridger.unauthorize(address(this), bridger.setMaxSlippage.selector);\\n\\n        // Set bridger max bonder fee pct\\n        bridger.authorize(params.admin, bridger.setMaxBonderFeePct.selector);\\n        bridger.authorize(address(this), bridger.setMaxBonderFeePct.selector);\\n        bridger.setMaxBonderFeePct(params.maxBonderFeePct);\\n        bridger.unauthorize(address(this), bridger.setMaxBonderFeePct.selector);\\n\\n        // Set bridger AMMs\\n        bridger.authorize(params.admin, bridger.setTokenAmm.selector);\\n        bridger.authorize(address(this), bridger.setTokenAmm.selector);\\n        for (uint256 i = 0; i < params.hopAmmParams.length; i = i.uncheckedAdd(1)) {\\n            HopAmmParams memory hopAmmParam = params.hopAmmParams[i];\\n            bridger.setTokenAmm(hopAmmParam.token, hopAmmParam.amm);\\n        }\\n        bridger.unauthorize(address(this), bridger.setTokenAmm.selector);\\n\\n        // Set bridger chain IDs\\n        bridger.authorize(params.admin, bridger.setAllowedChain.selector);\\n        bridger.authorize(address(this), bridger.setAllowedChain.selector);\\n        for (uint256 i = 0; i < params.allowedChainIds.length; i = i.uncheckedAdd(1)) {\\n            bridger.setAllowedChain(params.allowedChainIds[i], true);\\n        }\\n        bridger.unauthorize(address(this), bridger.setAllowedChain.selector);\\n\\n        // Transfer admin permissions to admin\\n        Deployer.transferAdminPermissions(bridger, params.admin);\\n\\n        // Authorize action to bridge from Smart Vault\\n        smartVault.authorize(address(bridger), smartVault.bridge.selector);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/L2NoBridgingSmartVaultDeployer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\nimport '@mimic-fi/v2-registry/contracts/registry/IRegistry.sol';\\nimport '@mimic-fi/v2-smart-vault/contracts/SmartVault.sol';\\nimport '@mimic-fi/v2-smart-vaults-base/contracts/deploy/Deployer.sol';\\n\\nimport './BaseSmartVaultDeployer.sol';\\n\\ncontract L2NoBridgingSmartVaultDeployer is BaseSmartVaultDeployer {\\n    struct Params {\\n        IRegistry registry;\\n        Deployer.SmartVaultParams smartVaultParams;\\n        FunderActionParams funderActionParams;\\n        HolderActionParams holderActionParams;\\n    }\\n\\n    function deploy(Params memory params) external {\\n        SmartVault smartVault = Deployer.createSmartVault(params.registry, params.smartVaultParams, false);\\n        _setupFunderAction(smartVault, params.funderActionParams);\\n        _setupHolderAction(smartVault, params.holderActionParams);\\n        Deployer.transferAdminPermissions(smartVault, params.smartVaultParams.admin);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_smartVault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxSlippage\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_registry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"what\",\"type\":\"bytes4\"}],\"name\":\"Authorized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"BalanceLimitsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Executed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxSlippage\",\"type\":\"uint256\"}],\"name\":\"MaxSlippageSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"RecipientSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"smartVault\",\"type\":\"address\"}],\"name\":\"SmartVaultSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"}],\"name\":\"TokenInSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"what\",\"type\":\"bytes4\"}],\"name\":\"Unauthorized\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ANY_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NAMESPACE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"what\",\"type\":\"bytes4\"}],\"name\":\"authorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"source\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slippage\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"call\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slippage\",\"type\":\"uint256\"}],\"name\":\"canExecute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundeableAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"what\",\"type\":\"bytes4\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSlippage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"setBalanceLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMaxSlippage\",\"type\":\"uint256\"}],\"name\":\"setMaxSlippage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRecipient\",\"type\":\"address\"}],\"name\":\"setRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newSmartVault\",\"type\":\"address\"}],\"name\":\"setSmartVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"setTokenIn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"smartVault\",\"outputs\":[{\"internalType\":\"contract ISmartVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenIn\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"what\",\"type\":\"bytes4\"}],\"name\":\"unauthorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "FunderV2", "CompilerVersion": "v0.8.3+commit.8d00100c", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "0000000000000000000000004629c578a9e49ef4aaabfee03f238cb11625f78b0000000000000000000000008ac76a51cc950d9822d68b83fe1ad97b32cd580d00000000000000000000000000000000000000000000000000470de4df82000000000000000000000000000000000000000000000000000002c68af0bb14000000000000000000000000000000000000000000000000000000038d7ea4c68000000000000000000000000000b3afb6db38a8e72905165c1fbb96772e635607900000000000000000000000005d52f9878f1a46302e3c4167bac8374a6b8b5d40000000000000000000000000ad243c868e74b23c2ad778b201cdd4074ed98cdc000000000000000000000000de6d4872c0c8167fb4f405c7854fd2fed7edca21", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}