{"SourceCode": "pragma solidity ^0.4.26;\r\n\r\nlibrary SafeMath {\r\n    \r\n/**\r\n * @dev Multiplies two unsigned integers, reverts on overflow.\r\n */\r\n \r\nfunction mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n\r\nif (_a == 0) {\r\nreturn 0;\r\n}\r\n\r\nuint256 c = _a * _b;\r\n require(c / _a == _b, \"SafeMath: multiplication overflow\");\r\nreturn c;\r\n}\r\n\r\n/**\r\n * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n */\r\n \r\nfunction div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n// Solidity only automatically asserts when dividing by 0\r\n require(_b > 0, \"SafeMath: division by zero\");\r\nuint256 c = _a / _b;\r\n // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\nreturn c;\r\n\r\n}\r\n\r\n/**\r\n * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n */\r\n     \r\nfunction sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n\r\nrequire(_b <= _a, \"SafeMath: subtraction overflow\");\r\nreturn _a - _b;\r\n}\r\n\r\n/**\r\n * @dev Adds two unsigned integers, reverts on overflow.\r\n */\r\n \r\nfunction add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n\r\nuint256 c = _a + _b;\r\nrequire(c >= _a, \"SafeMath: addition overflow\");\r\nreturn c;\r\n\r\n}\r\n\r\n/**\r\n  * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n   */\r\nfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0, \"SafeMath: modulo by zero\");\r\n    return a % b;\r\n}\r\n}\r\n\r\n/*\r\n * Ownable\r\n *\r\n * Base contract with an owner.\r\n * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\r\n*/\r\n\r\ncontract Ownable {\r\naddress public owner;\r\naddress public newOwner;\r\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\nconstructor() public {\r\nowner = msg.sender;\r\nnewOwner = address(0);\r\n}\r\n\r\n// allows execution by the owner only\r\n\r\nmodifier onlyOwner() {\r\nrequire(msg.sender == owner, \"Ownable: caller is not the owner\");\r\n_;\r\n}\r\n\r\nmodifier onlyNewOwner() {\r\nrequire(msg.sender != address(0), \"Ownable: zero address\");\r\nrequire(msg.sender == newOwner, \"Ownable: caller is not new owner\");\r\n_;\r\n}\r\n\r\n/**\r\n    @dev allows transferring the contract ownership\r\n    the new owner still needs to accept the transfer\r\n    can only be called by the contract owner\r\n    @param _newOwner    new contract owner\r\n*/\r\n\r\nfunction transferOwnership(address _newOwner) public onlyOwner {\r\nrequire(_newOwner != address(0));\r\nnewOwner = _newOwner;\r\n}\r\n\r\n/**\r\n    @dev used by a new owner to accept an ownership transfer\r\n*/\r\n\r\nfunction acceptOwnership() public onlyNewOwner {\r\nemit OwnershipTransferred(owner, newOwner);\r\nowner = newOwner;\r\n}\r\n}\r\n\r\n/*\r\n    BEP20 Token interface\r\n*/\r\n\r\ncontract BEP20 {\r\n\r\nfunction totalSupply() public view returns (uint256);\r\nfunction balanceOf(address who) public view returns (uint256);\r\nfunction allowance(address owner, address spender) public view returns (uint256);\r\nfunction transfer(address to, uint256 value) public returns (bool);\r\nfunction transferFrom(address from, address to, uint256 value) public returns (bool);\r\nfunction approve(address spender, uint256 value) public returns (bool);\r\n\r\nevent Approval(address indexed owner, address indexed spender, uint256 value);\r\nevent Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ninterface TokenRecipient {\r\nfunction receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external;\r\n}\r\n\r\ncontract Cratos_BEP20 is BEP20, Ownable {\r\nusing SafeMath for uint256;\r\n\r\nstring public name;\r\nstring public symbol;\r\nuint8 public decimals;\r\nuint256 internal totalSupply_;\r\nmapping(address => uint256) internal balances;\r\nmapping(address => mapping(address => uint256)) internal allowed;\r\n\r\nevent Mint(address indexed owner, uint256 value);\r\nevent Burn(address indexed owner, uint256 value);\r\n\r\nconstructor() public {\r\nname = \"Cratos BEP20\";\r\nsymbol = \"CRTS\";\r\ndecimals = 18;\r\ntotalSupply_ = 36e26;\r\nbalances[owner] = totalSupply_;\r\nemit Transfer(address(0), owner, totalSupply_);\r\n}\r\n\r\nfunction () public payable {\r\nrevert();\r\n}\r\n\r\n/**\r\n  * @dev Total number of tokens in existence\r\n  */\r\n   \r\nfunction totalSupply() public view returns (uint256) {\r\nreturn totalSupply_;\r\n}\r\n\r\n/**\r\n * @dev Transfer token for a specified addresses\r\n * @param _from The address to transfer from.\r\n * @param _to The address to transfer to.\r\n * @param _value The amount to be transferred.\r\n */ \r\n\r\nfunction _transfer(address _from, address _to, uint _value) internal {\r\n\r\nrequire(_to != address(0), \"Transfer to the zero address\");\r\nbalances[_from] = balances[_from].sub(_value);\r\nbalances[_to] = balances[_to].add(_value);\r\nallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\nemit Transfer(_from, _to, _value);\r\n}\r\n\r\n/**\r\n * @dev Transfer token for a specified address\r\n * @param _to The address to transfer to.\r\n * @param _value The amount to be transferred.\r\n */\r\n     \r\n \r\nfunction transfer(address _to, uint256 _value) public returns (bool) {\r\n\r\nrequire(_to != address(0), \"Transfer to the zero address\");\r\nbalances[msg.sender] = balances[msg.sender].sub(_value);\r\nbalances[_to] = balances[_to].add(_value);\r\nemit Transfer(msg.sender, _to, _value);\r\nreturn true;\r\n}\r\n\r\n/**\r\n * @dev Gets the balance of the specified address.\r\n * @param _holder The address to query the balance of.\r\n * @return An uint256 representing the amount owned by the passed address.\r\n */\r\n \r\nfunction balanceOf(address _holder) public view returns (uint256 balance) {\r\nreturn balances[_holder];\r\n}\r\n\r\n/**\r\n * @dev Transfer tokens from one address to another.\r\n * Note that while this function emits an Approval event, this is not required as per the specification,\r\n * and other compliant implementations may not emit the event.\r\n * @param _from address The address which you want to send tokens from\r\n * @param _to address The address which you want to transfer to\r\n * @param _value uint256 the amount of tokens to be transferred\r\n */\r\n     \r\nfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n\r\nrequire(_to != address(0));\r\nrequire(_value <= balances[_from]);\r\nrequire(_value <= allowed[_from][msg.sender]);\r\n_transfer(_from, _to, _value);\r\nreturn true;\r\n}\r\n\r\n/**\r\n * @dev Approve the passed address to _spender the specified amount of tokens on behalf of msg.sender.\r\n * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n * @param _spender The address which will spend the funds.\r\n * @param _value The amount of tokens to be spent.\r\n */ \r\n\r\nfunction approve(address _spender, uint256 _value) public returns (bool) {\r\nallowed[msg.sender][_spender] = _value;\r\nemit Approval(msg.sender, _spender, _value);\r\nreturn true;\r\n}\r\n\r\n/**\r\n * @dev Function to check the amount of tokens that an _holder allowed to a spender.\r\n * @param _holder address The address which owns the funds.\r\n * @param _spender address The address which will spend the funds.\r\n * @return A uint256 specifying the amount of tokens still available for the spender.\r\n*/\r\n     \r\nfunction allowance(address _holder, address _spender) public view returns (uint256) {\r\nreturn allowed[_holder][_spender];\r\n\r\n}\r\n\r\n/**\r\n  * Token Mint.\r\n */\r\n\r\nfunction mint(uint256 _value) public onlyOwner returns (bool) {\r\n    \r\nrequire(_value <= balances[msg.sender]);\r\naddress minter = msg.sender;\r\nbalances[minter] = balances[minter].add(_value);\r\ntotalSupply_ = totalSupply_.add(_value);\r\nemit Mint(minter, _value);\r\n\r\nreturn true;\r\n}\r\n\r\n/**\r\n  * Token Burn.\r\n */\r\n\r\nfunction burn(uint256 _value) public onlyOwner returns (bool) {\r\n    \r\nrequire(_value <= balances[msg.sender]);\r\naddress burner = msg.sender;\r\nbalances[burner] = balances[burner].sub(_value);\r\ntotalSupply_ = totalSupply_.sub(_value);\r\nemit Burn(burner, _value);\r\n\r\nreturn true;\r\n}\r\n \r\n\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_holder\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_holder\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]", "ContractName": "Cratos_BEP20", "CompilerVersion": "v0.4.26+commit.4563c3fc", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://02a33ce1f1b5e8f0252c38c9a322a65e4b33022880877bd1aa320a2d1d2e9a36"}