{"SourceCode": "/**\r\n *Submitted for verification at BscScan.com on 2022-06-09\r\n*/\r\n\r\n// SPDX-License-Identifier: Unlicensed\r\npragma solidity ^0.6.5;\r\n\r\n\r\ncontract Context {\r\n\r\n  constructor () internal { }\r\n\r\n  function _msgSender() internal view returns (address payable) {\r\n    return msg.sender;\r\n  }\r\n\r\n  function _msgData() internal view returns (bytes memory) {\r\n    this; \r\n    return msg.data;\r\n  }\r\n}\r\n\r\ncontract Ownable is Context {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  constructor () internal {\r\n    address msgSender = _msgSender();\r\n    _owner = msgSender;\r\n    emit OwnershipTransferred(address(0), msgSender);\r\n  }\r\n\r\n  function owner() public view returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n    _;\r\n  }\r\n\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  function _transferOwnership(address newOwner) internal {\r\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return sub(a, b, \"SafeMath: subtraction overflow\");\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    require(b <= a, errorMessage);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return div(a, b, \"SafeMath: division by zero\");\r\n  }\r\n\r\n  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    // Solidity only automatically asserts when dividing by 0\r\n    require(b > 0, errorMessage);\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return mod(a, b, \"SafeMath: modulo by zero\");\r\n  }\r\n\r\n  function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n    require(b != 0, errorMessage);\r\n    return a % b;\r\n  }\r\n}\r\n\r\ninterface IBEP20 {\r\n\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function decimals() external view returns (uint8);\r\n\r\n  function symbol() external view returns (string memory);\r\n\r\n  function name() external view returns (string memory);\r\n\r\n  function getOwner() external view returns (address);\r\n\r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n  function allowance(address _owner, address spender) external view returns (uint256);\r\n\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface DataContract{\r\n  function GetRoots(address _token, address _userAddr) external view returns (address[30] memory roots, uint256[30] memory recommends);\r\n  function UpdateUserData(address _token, address _userAddr, bool _valid) external;\r\n}\r\n\r\ninterface OldPower{\r\n  function tatolpower() external view returns (uint256);\r\n  function otherProfit() external view returns (uint256);\r\n  function card() external view returns (address);\r\n  function locker() external view returns (address);\r\n  function IDO() external view returns (address);\r\n  function token() external view returns (address);\r\n  function datacontract() external view returns (address);\r\n  function other() external view returns (address);\r\n  function MintProfitIndex() external view returns (uint);\r\n  function limitBusd() external view returns (uint256);\r\n  function users(uint) external view returns (address);\r\n  function _userpower(address) external view returns ( uint256, uint256, uint256, uint256, uint256, uint256, uint256);\r\n  function GetUser(address who) external view returns (\r\n        uint256 cardpower,\r\n        uint256 lockerpower,\r\n        uint256 IDOpower,\r\n        uint256 powerUsed,\r\n        uint256 profit,\r\n        uint256 recommendProfit,\r\n        uint256 cardProfit\r\n    );\r\n  function GetMintProfit(uint _index) external view returns (\r\n        uint256 nowtatolpower,\r\n        uint256 subtatolpower,\r\n        uint256 profittoken,\r\n        uint profitprice,\r\n        uint blocknumber\r\n    );\r\n  function GetUserTips(address who) external view returns ( uint index, bool updated );\r\n  function ToUpdate(address who) external;\r\n}\r\n\r\ncontract PowerContract is  Context,  Pausable{\r\n    using SafeMath for uint256;\r\n\r\n    struct UserPower {\r\n        uint256 cardpower;\r\n        uint256 lockerpower;\r\n        uint256 IDOpower;\r\n        uint256 powerUsed;\r\n        uint256 profit;\r\n        uint256 recommendProfit;\r\n        uint256 cardProfit;\r\n    }\r\n\r\n    struct UserTips {\r\n        uint index;\r\n        bool updated;\r\n    }\r\n\r\n    struct UserRProfit {\r\n        uint256 profit;\r\n        uint256 subpower;\r\n    }\r\n\r\n    struct MintProfit {\r\n        uint256 nowtatolpower;\r\n        uint256 subtatolpower;\r\n        uint256 profittoken;\r\n        uint profitprice;\r\n        uint blocknumber;\r\n    }\r\n\r\n    uint256 public tatolpower;\r\n    uint256 public otherProfit;\r\n    mapping(address => UserPower) public _userpower;\r\n\r\n    mapping(uint => MintProfit) public _mintProfit;\r\n    uint public MintProfitIndex;\r\n\r\n    mapping (address => UserTips) private _usertips;\r\n    mapping (address => UserRProfit) private _userRp;\r\n\r\n    address public card;\r\n    address public locker;\r\n    address public IDO;\r\n    address public token;\r\n    address public datacontract;\r\n    address public other;\r\n    address[] public users;\r\n    address public oldPowerAddr;\r\n//    address public rawPowerAddr;\r\n\r\n    uint256 public limitBusd = 200 * 10**18;\r\n    uint256[] public recommendpoint = [30,5,5,5,5,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2];\r\n\r\n    uint256 public validPower = 200;\r\n    address public dataToken;\r\n\r\n    event Profit(uint256 _token, uint _price);\r\n//**********************query function******************************* */\r\n    function isUser(address who) public view returns (bool) {\r\n       \r\n        for (uint256 i = 0; i < users.length; i++) {\r\n            if (users[i] == who) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function GetUserLen() public view returns (uint) {\r\n        return users.length;\r\n    }\r\n\r\n    function GetMintProfit(uint _index) public view returns (\r\n        uint256 nowtatolpower,\r\n        uint256 subtatolpower,\r\n        uint256 profittoken,\r\n        uint profitprice,\r\n        uint blocknumber\r\n    ) { \r\n      nowtatolpower = _mintProfit[_index].nowtatolpower;\r\n      subtatolpower = _mintProfit[_index].subtatolpower;\r\n      profittoken = _mintProfit[_index].profittoken;\r\n      profitprice = _mintProfit[_index].profitprice;\r\n      blocknumber = _mintProfit[_index].blocknumber;\r\n    }\r\n\r\n    function GetUser(address who) public view returns (\r\n        uint256 cardpower,\r\n        uint256 lockerpower,\r\n        uint256 IDOpower,\r\n        uint256 powerUsed,\r\n        uint256 profit,\r\n        uint256 recommendProfit,\r\n        uint256 cardProfit\r\n    ) { \r\n        return getProfitAndPower(who);\r\n    }\r\n\r\n    function GetUserTips(address who) public view returns (\r\n        uint index,\r\n        bool updated\r\n    ) { \r\n        index = _usertips[who].index;\r\n        updated = _usertips[who].updated;\r\n    }\r\n\r\n/********************************internal function*********************************/\r\n    function getProfit(uint256 _token, uint256 _i) internal view  returns (uint256 _profit) {\r\n      if (_i < recommendpoint.length){\r\n        _profit = _token.mul(recommendpoint[_i]).div(100);\r\n      }else {\r\n        _profit = 0;\r\n      }\r\n    }\r\n\r\n    function getProfitAndPower(address who) internal view  returns (uint256 cardpower, uint256 lockerpower, uint256 IDOpower, uint256 powerUsed, uint256 profit, uint256 recommendProfit,uint256 cardProfit) {\r\n      uint _index = 0;\r\n      if (!_usertips[who].updated  && oldPowerAddr != address(0)){\r\n        (cardpower, lockerpower, IDOpower, powerUsed, profit, recommendProfit,cardProfit) = OldPower(oldPowerAddr).GetUser(who);\r\n        _index = OldPower(oldPowerAddr).MintProfitIndex();\r\n        /*\r\n        if((cardpower + IDOpower + powerUsed) == 0 && rawPowerAddr != address(0)) {\r\n          (cardpower, lockerpower, IDOpower, powerUsed, profit, recommendProfit,cardProfit) = OldPower(rawPowerAddr)._userpower(who);\r\n          _index = 0;\r\n        }\r\n        */\r\n      }else{\r\n        cardProfit = _userpower[who].cardProfit;\r\n        powerUsed = _userpower[who].powerUsed;\r\n        cardpower = _userpower[who].cardpower;\r\n        IDOpower = _userpower[who].IDOpower;\r\n        lockerpower = _userpower[who].lockerpower;\r\n        profit = _userpower[who].profit;\r\n        recommendProfit = _userpower[who].recommendProfit;\r\n        _index = _usertips[who].index;\r\n      }\r\n      uint256 _useroldpower = cardpower + IDOpower; \r\n      if(_useroldpower == 0 ) {\r\n        _index = MintProfitIndex;\r\n      }      \r\n      if (_index < MintProfitIndex){        \r\n        uint256 _usersubpower = _useroldpower.mul(_mintProfit[MintProfitIndex].subtatolpower.sub(_mintProfit[_index].subtatolpower)).div(_mintProfit[MintProfitIndex].nowtatolpower.sub(_mintProfit[_index].subtatolpower));\r\n        uint256 _userprofit = _usersubpower.mul(_mintProfit[MintProfitIndex].profittoken.sub(_mintProfit[_index].profittoken)).div(_mintProfit[MintProfitIndex].subtatolpower.sub(_mintProfit[_index].subtatolpower));\r\n\r\n        if (cardpower < _usersubpower) {\r\n            IDOpower = _useroldpower.sub(_usersubpower);\r\n            cardpower = 0;\r\n        }else{\r\n            cardpower = cardpower.sub(_usersubpower); \r\n        }\r\n        cardProfit = cardProfit.add(_userprofit);\r\n        profit = profit.add(_userprofit);\r\n        powerUsed = powerUsed.add(_usersubpower);\r\n        _useroldpower = _useroldpower.sub(_usersubpower);\r\n      }\r\n      if (_userRp[who].profit > 0 && _useroldpower != 0){\r\n        uint256 subpower = _userRp[who].subpower;uint256 reporfit = _userRp[who].profit;\r\n        if(_useroldpower < subpower){\r\n          reporfit = reporfit.mul(_useroldpower).div(subpower);\r\n          subpower = _useroldpower;\r\n        }\r\n        if(IDOpower > subpower){\r\n          IDOpower = IDOpower.sub(subpower);\r\n        }else{\r\n          cardpower = _useroldpower.sub(subpower);\r\n          IDOpower = 0;\r\n        }\r\n        profit = profit.add(reporfit);\r\n        recommendProfit = recommendProfit.add(reporfit);\r\n        powerUsed = powerUsed.add(subpower);\r\n      }\r\n    }\r\n/*****************************************private function *****************************/\r\n    function updateUser(address who) private {\r\n      /*\r\n      readInOldUser(who);\r\n      if((_userpower[who].cardpower + _userpower[who].IDOpower) == 0) {\r\n        _usertips[who].index = MintProfitIndex;\r\n        _usertips[who].updated = true;\r\n      }\r\n      */\r\n      if ( _usertips[who].index != MintProfitIndex || _userRp[who].profit > 0){\r\n        uint256 rep = _userpower[who].recommendProfit;\r\n        (uint256 cardpower, uint256 lockerpower, uint256 IDOpower, uint256 powerUsed, uint256 profit, uint256 recommendProfit,uint256 cardProfit) = getProfitAndPower(who);\r\n        _userpower[who] = UserPower({\r\n          cardpower: cardpower,\r\n          lockerpower: lockerpower,\r\n          IDOpower: IDOpower,\r\n          powerUsed: powerUsed,\r\n          profit: profit,\r\n          recommendProfit: recommendProfit,\r\n          cardProfit: cardProfit\r\n        });\r\n        _usertips[who].index = MintProfitIndex;\r\n        if (!_usertips[who].updated){\r\n          _usertips[who].updated = true;\r\n          users.push(who);\r\n        } \r\n        if(_userRp[who].profit > 0){\r\n          rep = rep.add(_userRp[who].profit).sub(_userpower[who].recommendProfit);\r\n          if(rep > 0 ){\r\n            otherProfit = otherProfit.add(rep);\r\n          }        \r\n          rep = (_userRp[who].profit.sub(rep)).mul(_userRp[who].subpower);\r\n          tatolpower = tatolpower.sub(rep.div(_userRp[who].profit));\r\n          _userRp[who].profit = 0; _userRp[who].subpower = 0;\r\n        }\r\n      }      \r\n    }\r\n\r\n    function readInOldUser(address who) private {\r\n      if (!_usertips[who].updated && oldPowerAddr != address(0)){\r\n//        OldPower(oldPowerAddr).ToUpdate(who);\r\n        (uint256 cardpower, uint256 lockerpower, uint256 IDOpower, uint256 powerUsed, uint256 profit, uint256 recommendProfit,uint256 cardProfit) = OldPower(oldPowerAddr)._userpower(who);\r\n        _userpower[who] = UserPower({\r\n          cardpower: cardpower,\r\n          lockerpower: lockerpower,\r\n          IDOpower: IDOpower,\r\n          powerUsed: powerUsed,\r\n          profit: profit,\r\n          recommendProfit: recommendProfit,\r\n          cardProfit: cardProfit\r\n        });\r\n        if (!isUser(who)) {\r\n            users.push(who);\r\n        }\r\n        ( uint index, ) = OldPower(oldPowerAddr).GetUserTips(who);\r\n        _usertips[who].index = index;\r\n        _usertips[who].updated = true;\r\n      }     \r\n    }\r\n\r\n    function UpdateUserData(address _userAddr) private {\r\n        bool valid = true;\r\n        if( _userpower[_userAddr].cardpower < validPower){\r\n            valid = false;\r\n        }\r\n        DataContract(datacontract).UpdateUserData(dataToken, _userAddr, valid);\r\n    }\r\n\r\n/*************************************public onlyOwner function**********************************/\r\n    function SetContracts(address _card, address _locker, address _IDO, address _token, address _datacontract, address _other) public onlyOwner {\r\n        locker = _locker;\r\n        card = _card;\r\n        IDO = _IDO;\r\n        token = _token;\r\n        datacontract = _datacontract;\r\n        other = _other;\r\n    }\r\n\r\n    function SetOldPowerAddr(address _oldPowerAddr) public onlyOwner {\r\n        oldPowerAddr = _oldPowerAddr;\r\n    }\r\n/*\r\n    function SetRawPowerAddr(address _rawPowerAddr) public onlyOwner {\r\n        rawPowerAddr = _rawPowerAddr;\r\n    }\r\n*/\r\n    function SetDataToken(address _dataToken) public onlyOwner {\r\n        dataToken = _dataToken;\r\n    }\r\n\r\n    function SetValidPower(uint256 _validPower) public onlyOwner {\r\n        validPower = _validPower;\r\n    }\r\n\r\n    function SetLimitBusd(uint256 _limitBusd) public onlyOwner {\r\n        limitBusd = _limitBusd;\r\n    }\r\n\r\n    function SetRecommendPoint(uint256[] memory _recommendpoint) public onlyOwner {\r\n      uint256 all = 0;\r\n      for(uint i = 0; i < _recommendpoint.length; i++){\r\n        all += _recommendpoint[i];\r\n      }\r\n      require(all <= 100, \"all big than 100\");\r\n      recommendpoint = _recommendpoint;\r\n    }\r\n\r\n    function ReadOldIn() public onlyOwner {\r\n      tatolpower = OldPower(oldPowerAddr).tatolpower();\r\n      otherProfit = OldPower(oldPowerAddr).otherProfit();\r\n      card = OldPower(oldPowerAddr).card();\r\n      locker = OldPower(oldPowerAddr).locker();\r\n      IDO = OldPower(oldPowerAddr).IDO();\r\n      token = OldPower(oldPowerAddr).token();\r\n      datacontract = OldPower(oldPowerAddr).datacontract();\r\n      other = OldPower(oldPowerAddr).other();\r\n      limitBusd = OldPower(oldPowerAddr).limitBusd();\r\n      dataToken = token;\r\n      MintProfitIndex = OldPower(oldPowerAddr).MintProfitIndex();\r\n    }\r\n\r\n    function ReadOldMintProfitIn() public onlyOwner {\r\n      for (uint i = 1; i < MintProfitIndex +1; i++) {\r\n        (_mintProfit[i].nowtatolpower, _mintProfit[i].subtatolpower, _mintProfit[i].profittoken, _mintProfit[i].profitprice, _mintProfit[i].blocknumber)\r\n        = OldPower(oldPowerAddr).GetMintProfit(i);\r\n      }\r\n    }\r\n\r\n    function ReadInOldMintProfitOf(address _oldPower, uint _start, uint _end) public onlyOwner {\r\n      require(_end > _start, \"end must big than start\");\r\n      require(_start > 0, \"start must big than zero\");\r\n      for(uint i = _start; i < _end; i++){\r\n        (_mintProfit[i].nowtatolpower, _mintProfit[i].subtatolpower, _mintProfit[i].profittoken, _mintProfit[i].profitprice, _mintProfit[i].blocknumber)\r\n        = OldPower(_oldPower).GetMintProfit(i);\r\n      }\r\n    }\r\n\r\n    function ReadOldUserIn(address _oldPower, uint _start, uint _end) public onlyOwner {\r\n      require(_end > _start, \"end must big than start\");\r\n      for(uint i = _start; i < _end; i++){\r\n        address user = OldPower(_oldPower).users(i);\r\n        updateUser(user);\r\n        UpdateUserData(user);\r\n      }\r\n    }\r\n\r\n    function WriteInUser(address who, uint256 cardpower, uint256 lockerpower, uint256 IDOpower, uint256 powerUsed, uint256 profit, uint256 recommendProfit,uint256 cardProfit) public onlyOwner {\r\n        _userpower[who] = UserPower({\r\n          cardpower: cardpower,\r\n          lockerpower: lockerpower,\r\n          IDOpower: IDOpower,\r\n          powerUsed: powerUsed,\r\n          profit: profit,\r\n          recommendProfit: recommendProfit,\r\n          cardProfit: cardProfit\r\n        });\r\n        if (!_usertips[who].updated){\r\n          _usertips[who].updated = true;\r\n          users.push(who);\r\n        }\r\n        _usertips[who].index = MintProfitIndex;\r\n        UpdateUserData(who);\r\n    }\r\n\r\n    function ReplaceUser(address[] memory who, uint256[] memory cardpower, uint256[] memory IDOpower, uint256[] memory powerUsed, uint256[] memory profit) public onlyOwner {\r\n        for (uint i = 0; i < who.length; i++){\r\n            _userpower[who[i]].cardpower = cardpower[i];\r\n            _userpower[who[i]].IDOpower = IDOpower[i];\r\n            _userpower[who[i]].powerUsed = powerUsed[i];\r\n            _userpower[who[i]].profit = profit[i];\r\n            if (!_usertips[who[i]].updated){\r\n            _usertips[who[i]].updated = true;\r\n            users.push(who[i]);\r\n            }\r\n            _usertips[who[i]].index = MintProfitIndex;\r\n        }\r\n    }\r\n\r\n    function ReplaceOldUser(address[] memory who) public onlyOwner {\r\n        for (uint i = 0; i < who.length; i++){\r\n            _userpower[who[i]].IDOpower = 457924496927700858509;\r\n            _userpower[who[i]].powerUsed = 542075503072299141491;\r\n            _userpower[who[i]].profit = 14400023634385838776;\r\n            _userpower[who[i]].cardProfit = 14400023634385838776;\r\n            if (!_usertips[who[i]].updated){\r\n            _usertips[who[i]].updated = true;\r\n            users.push(who[i]);\r\n            }\r\n            _usertips[who[i]].index = MintProfitIndex;\r\n        }\r\n    }\r\n\r\n    function WriteMintProfit(address[] memory _users, uint256[] memory _profitTokens, uint256[] memory _subPowers) public onlyOwner{\r\n        require(_users.length == _profitTokens.length, \"data len no eq\");\r\n        require(_users.length == _subPowers.length, \"data len no eq\");\r\n        uint256 subPowerAll = 0;\r\n        for (uint i = 0; i < _users.length; i++){\r\n            _userpower[_users[i]].powerUsed = _userpower[_users[i]].powerUsed.add(_subPowers[i]);\r\n            _userpower[_users[i]].profit = _userpower[_users[i]].profit.add(_profitTokens[i]);\r\n            _userpower[_users[i]].cardProfit = _userpower[_users[i]].cardProfit.add(_profitTokens[i]);\r\n            uint256 _useroldpower = _userpower[_users[i]].cardpower + _userpower[_users[i]].IDOpower;\r\n            if (_userpower[_users[i]].IDOpower < _subPowers[i]){\r\n                  _userpower[_users[i]].IDOpower = 0;\r\n                  _userpower[_users[i]].cardpower = _useroldpower.sub(_subPowers[i]);\r\n                  UpdateUserData(_users[i]);\r\n              }else{\r\n                  _userpower[_users[i]].IDOpower = _userpower[_users[i]].IDOpower.sub(_subPowers[i]);\r\n              }\r\n            subPowerAll += _subPowers[i];\r\n         }\r\n         tatolpower = tatolpower.sub(subPowerAll);\r\n    }\r\n\r\n    function WithdrawToken(address _token) public whenPaused onlyOwner{\r\n        uint256 tokenvalue = IBEP20(_token).balanceOf(address(this));\r\n        require(tokenvalue > 0, \"no token\");\r\n        IBEP20(_token).transfer(msg.sender,tokenvalue);\r\n    }    \r\n/*********************************************public function for contract **************/\r\n    function AddCardPower(address _user, uint256 _power) whenNotPaused public {\r\n        require(msg.sender == card, \"only call by card-contract\");\r\n        updateUser(_user);\r\n        _userpower[_user].cardpower = _userpower[_user].cardpower.add(_power);\r\n        tatolpower = tatolpower.add(_power);\r\n        UpdateUserData(_user);\r\n    }\r\n\r\n    function AddLockerPower(address _user, uint256 _power) whenNotPaused public {\r\n        require(msg.sender == locker, \"only call by card-contract\");\r\n        updateUser(_user);\r\n        _userpower[_user].lockerpower = _userpower[_user].lockerpower.add(_power);\r\n        UpdateUserData(_user);\r\n    }\r\n\r\n    function SubLockerPower(address _user, uint256 _power) whenNotPaused public {\r\n        require(msg.sender == locker, \"only call by locker-contract\");\r\n        updateUser(_user);\r\n        _userpower[_user].lockerpower = _userpower[_user].lockerpower.sub(_power);\r\n        UpdateUserData(_user);\r\n    }\r\n\r\n    function AddIDOPower(address _user, uint256 _power) whenNotPaused public {\r\n        require(msg.sender == IDO, \"only call by IDO-contract\");\r\n        updateUser(_user);\r\n        _userpower[_user].IDOpower = _userpower[_user].IDOpower.add(_power);\r\n        tatolpower = tatolpower.add(_power);\r\n        UpdateUserData(_user);\r\n    }\r\n\r\n    function NewCardProfit(address _composer, uint256 _token, uint256 _busd, uint _price) whenNotPaused public {\r\n        require(msg.sender == card, \"only call by card-contract\");\r\n        if (_busd >= limitBusd){\r\n          address[30] memory roots; uint256[30] memory recommends;\r\n          uint256 _subrootpower = 0;uint256 _rootprofit = 0; \r\n          (roots,recommends) = DataContract(datacontract).GetRoots(dataToken, _composer);\r\n          for (uint i = 0; i < 30; i++){\r\n            if (roots[i] != address(0) && recommends[i] > i){\r\n              if (roots[i] == address(0)) break;\r\n              _rootprofit = getProfit(_token,i);\r\n              _subrootpower = _rootprofit.mul(_price).div(100 * 10**18);\r\n              _userRp[roots[i]].profit = _userRp[roots[i]].profit.add(_rootprofit);\r\n              _userRp[roots[i]].subpower = _userRp[roots[i]].subpower.add(_subrootpower);\r\n            }\r\n          }\r\n        }else{\r\n          otherProfit = otherProfit.add(_token);\r\n        }\r\n        emit Profit(_token, _price);\r\n    }\r\n/*******************************************public function************************************ */\r\n    function NewMintProfit(uint256 _token, uint _price) whenNotPaused public {\r\n      IBEP20(token).transferFrom(msg.sender, address(this), _token);\r\n      if (tatolpower == 0){\r\n        otherProfit = otherProfit.add(_token);\r\n        return;\r\n      }\r\n      MintProfitIndex +=1;\r\n      uint256 new_sub = _token.mul(_price).div(100 * 10**18);\r\n      if(new_sub > tatolpower){\r\n        _token = _token.mul(tatolpower).div(new_sub);\r\n        new_sub = tatolpower;\r\n      }\r\n\r\n      _mintProfit[MintProfitIndex] = MintProfit({\r\n        nowtatolpower: tatolpower.add(_mintProfit[MintProfitIndex-1].subtatolpower),\r\n        subtatolpower: _mintProfit[MintProfitIndex-1].subtatolpower.add(new_sub),\r\n        profittoken: _mintProfit[MintProfitIndex-1].profittoken.add(_token),\r\n        profitprice: _price,\r\n        blocknumber: block.number\r\n        });\r\n      tatolpower = tatolpower.sub(new_sub);\r\n      emit Profit(_token, _price);\r\n    }\r\n\r\n    function WithdrawProfit(address who) whenNotPaused public {\r\n        updateUser(who);\r\n        uint256 _profits = _userpower[who].cardProfit.add(_userpower[who].recommendProfit);\r\n        require(_profits > 0, \"no Profit\");\r\n        _userpower[who].cardProfit = 0;\r\n        _userpower[who].recommendProfit = 0;\r\n\r\n        UpdateUserData(who);\r\n\r\n        IBEP20(token).transfer( who,_profits);\r\n    }\r\n\r\n    function WithdrawOtherProfit() public{\r\n        require(otherProfit > 0, \"no Profit\");\r\n        uint256 _otherProfit = otherProfit;\r\n        otherProfit = 0;\r\n        IBEP20(token).transfer( other,_otherProfit);\r\n    }\r\n\r\n    function ToUpdate(address who) public {\r\n      updateUser(who);\r\n      UpdateUserData(who);\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_token\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"Profit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_power\",\"type\":\"uint256\"}],\"name\":\"AddCardPower\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_power\",\"type\":\"uint256\"}],\"name\":\"AddIDOPower\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_power\",\"type\":\"uint256\"}],\"name\":\"AddLockerPower\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"GetMintProfit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nowtatolpower\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"subtatolpower\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"profittoken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"profitprice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blocknumber\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"GetUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cardpower\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockerpower\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"IDOpower\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"powerUsed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"recommendProfit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cardProfit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetUserLen\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"GetUserTips\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"updated\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"IDO\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MintProfitIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_composer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_token\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_busd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"NewCardProfit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_token\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"NewMintProfit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oldPower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_end\",\"type\":\"uint256\"}],\"name\":\"ReadInOldMintProfitOf\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ReadOldIn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ReadOldMintProfitIn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oldPower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_end\",\"type\":\"uint256\"}],\"name\":\"ReadOldUserIn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"who\",\"type\":\"address[]\"}],\"name\":\"ReplaceOldUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"who\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"cardpower\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"IDOpower\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"powerUsed\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"profit\",\"type\":\"uint256[]\"}],\"name\":\"ReplaceUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_card\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_locker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_IDO\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_datacontract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_other\",\"type\":\"address\"}],\"name\":\"SetContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dataToken\",\"type\":\"address\"}],\"name\":\"SetDataToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_limitBusd\",\"type\":\"uint256\"}],\"name\":\"SetLimitBusd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oldPowerAddr\",\"type\":\"address\"}],\"name\":\"SetOldPowerAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_recommendpoint\",\"type\":\"uint256[]\"}],\"name\":\"SetRecommendPoint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_validPower\",\"type\":\"uint256\"}],\"name\":\"SetValidPower\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_power\",\"type\":\"uint256\"}],\"name\":\"SubLockerPower\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"ToUpdate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WithdrawOtherProfit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"WithdrawProfit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"WithdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cardpower\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockerpower\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"IDOpower\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"powerUsed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"recommendProfit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cardProfit\",\"type\":\"uint256\"}],\"name\":\"WriteInUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_users\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_profitTokens\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_subPowers\",\"type\":\"uint256[]\"}],\"name\":\"WriteMintProfit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_mintProfit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nowtatolpower\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"subtatolpower\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"profittoken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"profitprice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blocknumber\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_userpower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cardpower\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockerpower\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"IDOpower\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"powerUsed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"recommendProfit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cardProfit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"card\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dataToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"datacontract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"isUser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"limitBusd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"locker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oldPowerAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"other\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"otherProfit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"recommendpoint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tatolpower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validPower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "PowerContract", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://0c831d7ec5b54250c312cf44b45eac5f94038b2275c8b193783f9938fbc965d3"}