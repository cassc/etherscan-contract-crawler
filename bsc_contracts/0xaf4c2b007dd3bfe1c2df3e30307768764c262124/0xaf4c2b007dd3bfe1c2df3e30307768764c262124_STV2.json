{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/STV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\r\\nimport \\\"./interfaces/IValidationManager.sol\\\";\\r\\nimport \\\"./BaseERC20.sol\\\";\\r\\nimport \\\"./Deployerable.sol\\\";\\r\\nimport \\\"./Roles.sol\\\";\\r\\nimport \\\"./Whitelist.sol\\\";\\r\\nimport \\\"./Limits.sol\\\";\\r\\nimport \\\"./LockUps.sol\\\";\\r\\n\\r\\n/// @title STV2\\r\\n/// @author Stobox Technologies Inc.\\r\\n/// @notice Smart Contract of security token. Version 2.0\\r\\n/// @dev STV2 is ERC20-token with additional restrictions and abilities\\r\\ncontract STV2 is\\r\\n    Pausable,\\r\\n    Deployerable,\\r\\n    Roles,\\r\\n    Whitelist,\\r\\n    Limits,\\r\\n    LockUps,\\r\\n    BaseERC20\\r\\n{\\r\\n    address private _validationManager;\\r\\n\\r\\n    /// @notice oficial corporate wallet of the Company, to which tokens are minted and then distributed\\r\\n    address private _corporateTreasury;\\r\\n\\r\\n    modifier onlyWhitelisted(address _account) override {\\r\\n        if (_isEnabledWhitelist) {\\r\\n            require(userData[_account].whitelisted, \\\"STV2: Not whitelisted\\\");\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier ifTokenNotPaused() override {\\r\\n        _requireNotPaused();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlySuperAdmin() override {\\r\\n        _checkRole(DEFAULT_ADMIN_ROLE);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyRecoveryManager() override {\\r\\n        _checkRole(RECOVERY_MANAGER_ROLE);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyComplianceManager() override {\\r\\n        _checkRole(COMPLIANCE_MANAGER_ROLE);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyFinancialManager() override {\\r\\n        _checkRole(FINANCIAL_MANAGER_ROLE);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /// @dev in constructor, except that the values \u200b\u200bof important variables will be set,\\r\\n    /// will be executed next actions:\\r\\n    /// * whitelisted msg.sender(deployer of the contract),\\r\\n    /// * whitelisted all addresses which will be granted roles (superAdmin,\\r\\n    ///   financialManager, complianceOfficer, masterManager)\\r\\n    /// * corporateTreasury will be whitelisted and it will be assigned maximum\\r\\n    ///   secondary trading & transaction count limits (2**256 - 1)\\r\\n    /// * financialManager will be approved to make unlimited transactions from corporateTreasury\\r\\n    constructor(\\r\\n        //official corporate wallet, where tokens will be minted\\r\\n        address corporateTreasury_,\\r\\n        //list of addresses which will be assigned important roles (see contract {Roles}):\\r\\n        // * address[0] - superAdmin - will have rights to assign all roles (see contract {Roles})\\r\\n        // * address[1] - financialManager\\r\\n        // * address[2] - complianceManager\\r\\n        // * address[3] - recoveryManager\\r\\n        address[4] memory _managers,\\r\\n        //flag determines whether the whitelist is enabled\\r\\n        bool isEnabledWhitelist_,\\r\\n        //flag determines whether the whitelist is enabled\\r\\n        bool isEnabledLockUps_,\\r\\n        //list of flags determines whether the SecondaryTradingLimit & TransactionCountLimit are enabled.\\r\\n        //bool-values which will show if the limits have to be switch-ON (see contract {Limits}):\\r\\n        // * enableLimits[0] - true: the SecondaryTradingLimit will be switchON, false: switchOFF\\r\\n        // * enableLimits[1] - true: the TransactionCountLimit will be switchON, false: switchOFF\\r\\n        bool[2] memory _enableLimits,\\r\\n        //list of values which will be set as default Secondary &\\r\\n        //Transaction Limits (see contract {Limits}):\\r\\n        // * defaultLimits[0] - the value of defaultSecondaryTradingLimit_\\r\\n        // * defaultLimits[1] - the value of defaultTransactionCountLimit_\\r\\n        uint256[2] memory _defaultLimits,\\r\\n        //name of token\\r\\n        string memory name_,\\r\\n        //symbol of token\\r\\n        string memory symbol_,\\r\\n        //value of decimals for token. For security token must be `0`\\r\\n        uint8 decimals_\\r\\n    )\\r\\n        BaseERC20(name_, symbol_, decimals_)\\r\\n        Roles(_managers)\\r\\n        Whitelist(isEnabledWhitelist_)\\r\\n        LockUps(isEnabledLockUps_)\\r\\n        Limits(corporateTreasury_, _enableLimits, _defaultLimits)\\r\\n    {\\r\\n        _corporateTreasury = corporateTreasury_;\\r\\n\\r\\n        _addAddressToWhitelist(_msgSender());\\r\\n        _addAddressToWhitelist(_managers[0]);\\r\\n        _addAddressToWhitelist(_managers[1]);\\r\\n        _addAddressToWhitelist(_managers[2]);\\r\\n        _addAddressToWhitelist(_managers[3]);\\r\\n        _addAddressToWhitelist(corporateTreasury_);\\r\\n    }\\r\\n\\r\\n    /// @notice Pauses all functions of contract which have modifier `whenNotPaused`\\r\\n    /// @dev Allowed only for SuperAdmin\\r\\n    function pauseContract() external onlySuperAdmin {\\r\\n        _pause();\\r\\n    }\\r\\n\\r\\n    /// @notice Unpauses all functions of contract\\r\\n    /// @dev Allowed only for SuperAdmin\\r\\n    function unpauseContract() external onlySuperAdmin {\\r\\n        _unpause();\\r\\n    }\\r\\n\\r\\n    /// @notice Set the address of ValidationManager with which validation will be done\\r\\n    /// @dev Allowed only for Deployer (see contract Deployerable)\\r\\n    function setValidationManager(\\r\\n        address _validationAddress\\r\\n    ) external onlyDeployer {\\r\\n        _validationManager = _validationAddress;\\r\\n    }\\r\\n\\r\\n    /// @notice Moves the the corporate official wallet to another\\r\\n    ///         address with all necessary changes such as:\\r\\n    ///         moving the whole balance of tokens, setting proper limits for old and new treasuries\\r\\n    ///         giving rights fo Financial Manager(s) to use new corporate wallet.\\r\\n    /// @dev Allowed only for SuperAdmin.\\r\\n    ///      `_newTreasury` can not be zero-address\\r\\n    /// @param _newTreasury new address of the wallet to set.\\r\\n    function replacementOfCorporateTreasury(\\r\\n        address _newTreasury\\r\\n    ) external onlySuperAdmin {\\r\\n        require(_newTreasury != address(0), \\\"STV2:Treasury can not be zero\\\");\\r\\n\\r\\n        address oldTreasury = corporateTreasury();\\r\\n        uint256 oldTreasuryBalance = balanceOf(oldTreasury);\\r\\n        uint256 newTreasuryBalance = balanceOf(_newTreasury);\\r\\n\\r\\n        //whitelisting of the address of new Treasury\\r\\n        _addAddressToWhitelist(_newTreasury);\\r\\n\\r\\n        //moves the whole balance of tokens from old Treasury to the new one\\r\\n        _transfer(oldTreasury, _newTreasury, oldTreasuryBalance);\\r\\n\\r\\n        //checks if the balance of tokens was successfully moved\\r\\n        require(\\r\\n            balanceOf(oldTreasury) == 0 &&\\r\\n                balanceOf(_newTreasury) ==\\r\\n                newTreasuryBalance + oldTreasuryBalance,\\r\\n            \\\"STV2: balance of Treasury was not replaced\\\"\\r\\n        );\\r\\n\\r\\n        //resets the limits(secondary trading and transction count) of\\r\\n        //old Treasury to the default values\\r\\n        userData[oldTreasury].hasOwnSecondaryLimit = false;\\r\\n        userData[oldTreasury].hasOwnTransactionCountLimit = false;\\r\\n\\r\\n        //sets the address of new Treasury as the proper parameter of smart contract\\r\\n        _corporateTreasury = _newTreasury;\\r\\n\\r\\n        //sets the maximum limits for the new Treasury (2**256-1)\\r\\n        _setSecondaryTradingLimitFor(_newTreasury, MAX_UINT);\\r\\n        _setTransactionCountLimitFor(_newTreasury, MAX_UINT);\\r\\n\\r\\n        //removing of the address of old Treasury from whitelist\\r\\n        _removeAddressFromWhitelist(oldTreasury);\\r\\n    }\\r\\n\\r\\n    /// @notice Burns amounts of tokens from the array `_bundleAmounts`\\r\\n    ///         from the addresses of the array of addresses `_bundleFrom`\\r\\n    /// @dev Allowed only for RecoveryManager\\r\\n    ///      Address => value burnt according to indexes of arrays:\\r\\n    ///      from [0]indexed address will be burnt [0]indexed amount of tokens,\\r\\n    ///      from [1]indexed address will be burnt [1]indexed amount of tokens and so on\\r\\n    /// @param _bundleFrom array of addresses to burn tokens from\\r\\n    /// @param _bundleAmounts array of amounts of tokens to burn\\r\\n    function burnBundle(\\r\\n        address[] memory _bundleFrom,\\r\\n        uint256[] memory _bundleAmounts\\r\\n    ) external onlyRecoveryManager {\\r\\n        _bundlesLoop(_bundleFrom, _bundleAmounts, _burn);\\r\\n    }\\r\\n\\r\\n    /// @notice Burns whole balance of tokens from all addresses of the array of addresses `_bundleFrom`\\r\\n    /// @dev Allowed only for RecoveryManager\\r\\n    /// @param _bundleFrom array of addresses to burn tokens from\\r\\n    function redemption(\\r\\n        address[] memory _bundleFrom\\r\\n    ) external onlyRecoveryManager returns (bool) {\\r\\n        for (uint256 i = 0; i < _bundleFrom.length; i++) {\\r\\n            uint256 amountToBurn = balanceOf(_bundleFrom[i]);\\r\\n            _burn(_bundleFrom[i], amountToBurn);\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// @notice This function can release ERC20-tokens `_tokensToWithdraw`, which\\r\\n    ///         got stuck in this smart contract (were transferred here by the mistake)\\r\\n    /// @dev Allowed only for SuperAdmin.\\r\\n    ///      Transfers all balance of stuck `_tokensToWithdraw` from\\r\\n    ///      this contract to {_corporateTreasury} wallet\\r\\n    /// @param _tokensToWithdraw address of ERC20-token to withdraw\\r\\n    function withdrawStuckTokens(\\r\\n        address _tokensToWithdraw\\r\\n    ) external onlySuperAdmin {\\r\\n        address from = address(this);\\r\\n        uint256 amount = IERC20(_tokensToWithdraw).balanceOf(from);\\r\\n        IERC20(_tokensToWithdraw).transfer(_corporateTreasury, amount);\\r\\n    }\\r\\n\\r\\n    /// @notice Transfers amounts from array `_bundleAmounts` of tokens from {_corporateTreasury}\\r\\n    ///          to all addresses from array of addresses `_bundleTo`\\r\\n    /// @dev Allowed only for FinancialManager.\\r\\n    ///      Function blocked when contract is paused.\\r\\n    ///      To be able to call this function FinancialManager has\\r\\n    ///      to be given unlimited {approve} from {_corporateTreasury}\\r\\n    ///      Address => value are transferred according to indexes of arrays:\\r\\n    ///      [0]indexed amount of tokens will be transferred to [0]indexed address,\\r\\n    ///      [1]indexed amount of tokens will be transferred to [1]indexed address and so on\\r\\n    /// @param _bundleTo array of addresses which will receive tokens\\r\\n    /// @param _bundleAmounts array of amounts of tokens to transfer\\r\\n    /// @return true if function passed successfully\\r\\n    function transferFromTreasuryToInvestor(\\r\\n        address[] memory _bundleTo,\\r\\n        uint256[] memory _bundleAmounts\\r\\n    ) external whenNotPaused onlyFinancialManager returns (bool) {\\r\\n        _bundlesLoop(_corporateTreasury, _bundleTo, _bundleAmounts, _transfer);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the personal data of `_account`\\r\\n    ///         returns the array with next data of this account:\\r\\n    /// *userAddress,\\r\\n    /// *whole user Balance of tokens,\\r\\n    /// *amount of Locked tokens of user,\\r\\n    /// *is address whitelisted(true/false),\\r\\n    /// *left Secondary Limit for account (user can spend yet),\\r\\n    /// *SecondaryLimit which is set for this account,\\r\\n    /// *left Transaction Limit for account (user can spend yet),\\r\\n    /// *TransactionCountLimit which is set for this account,\\r\\n    /// *outputAmount of tokens,\\r\\n    /// *transactionCount of transfers,\\r\\n    /// *personalLockUps - array of arrays of 2 elements([0]:timestamp, [1]:blocked amount)\\r\\n    function getUserData(\\r\\n        address _account\\r\\n    ) external view returns (ActualUserInfo memory) {\\r\\n        ActualUserInfo memory actualInfo;\\r\\n        actualInfo = ActualUserInfo(\\r\\n            _account,\\r\\n            balanceOf(_account),\\r\\n            getAmountOfLockedTokens(_account),\\r\\n            userData[_account].whitelisted,\\r\\n            getAllowedToTransfer(_account),\\r\\n            secondaryTradingLimitOf(_account),\\r\\n            getLeftTransactionCountLimit(_account),\\r\\n            transactionCountLimitOf(_account),\\r\\n            userData[_account].outputAmount,\\r\\n            userData[_account].transactionCount,\\r\\n            userData[_account].personalLockUps\\r\\n        );\\r\\n\\r\\n        return actualInfo;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the address of the official corporate wallet\\r\\n    function corporateTreasury() public view override returns (address) {\\r\\n        return _corporateTreasury;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the address of the current ValidationManager smart contract\\r\\n    function getValidationManager() public view returns (address) {\\r\\n        return _validationManager;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the value of amount of tokens which `_account`\\r\\n    ///         can spend(transfer) this moment\\r\\n    /// @dev Function takes two numbers: {_availableBalance} & {_availableLimit}\\r\\n    ///      and compaire them.\\r\\n    ///      {_availableBalance} - subtracts from the total balance value of lockUps\\r\\n    ///      {_availableLimit} - returns currently available limit for this address\\r\\n    ///      Then returns the smaller value.\\r\\n    function getAllowedToTransfer(\\r\\n        address _account\\r\\n    ) public view returns (uint256 result) {\\r\\n        _availableBalance(_account) < _availableLimit(_account)\\r\\n            ? result = _availableBalance(_account)\\r\\n            : result = _availableLimit(_account);\\r\\n    }\\r\\n\\r\\n    /// @notice Moves `_amount` of tokens from the array of amounts `_bundleAmounts` from\\r\\n    ///         the caller's account to each address\\r\\n    ///         from array of  addresses `_bundleTo`.\\r\\n    /// @dev Emits a {Transfer} event for each transfer of this multi-sending function.\\r\\n    ///      Function blocked when contract is paused.\\r\\n    ///      Function has a number of checks and conditions - see {_transfer} internal function.\\r\\n    ///      Address => value transferred according to indexes of arrays:\\r\\n    ///      to [0]indexed address will be sent [0]indexed amount of tokens,\\r\\n    ///      to [1]indexed address will be sent [1]indexed amount of tokens and so on\\r\\n    /// @param _bundleTo array of addresses which will get tokens\\r\\n    /// @param _bundleAmounts array of amounts to transfer\\r\\n    /// @return true if function passed successfully\\r\\n    function transferBundle(\\r\\n        address[] memory _bundleTo,\\r\\n        uint256[] memory _bundleAmounts\\r\\n    ) public whenNotPaused returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        _bundlesLoop(owner, _bundleTo, _bundleAmounts, _transfer);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// @dev This hook is called before any transfer of tokens(except minting & burning).\\r\\n    ///      Increases the {PersonalInfo.outputAmount} of `_from` account by `_amount`\\r\\n    ///      Increases the counter of transactions of `_from` account\\r\\n    ///      by 1 ({PersonalInfo.transactionCount})\\r\\n    ///      Requirements:\\r\\n    ///      *available Transaction Count Limit of `_from` has to be > 0\\r\\n    ///      *{_availableLimit} of `_from` account cannot be less then `_amount` to transfer\\r\\n    ///      *{_availableBalance} of `_from` account cannot be less then `_amount` to transfer\\r\\n    function _beforeTokenTransfer(\\r\\n        address _from,\\r\\n        address _to,\\r\\n        uint256 _amount\\r\\n    ) internal override {\\r\\n        require(\\r\\n            getLeftTransactionCountLimit(_from) > 0,\\r\\n            \\\"STV2: Has no TransactionCountLimit\\\"\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            _availableLimit(_from) >= _amount,\\r\\n            \\\"STV2: Not enough SecondaryTradingLimit\\\"\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            _availableBalance(_from) >= _amount,\\r\\n            \\\"STV2: Not enough balance or you transfer locked tokens\\\"\\r\\n        );\\r\\n\\r\\n        _validateToInteract(_from, _to);\\r\\n        _validateToTransfer(_from, _to, _amount);\\r\\n\\r\\n        userData[_from].outputAmount += _amount;\\r\\n        userData[_from].transactionCount++;\\r\\n    }\\r\\n\\r\\n    /// @dev This hook is called after any transfer of tokens(except minting & burning).\\r\\n    ///      Updates(actualize) PersonalInfo.personalLockUps of `_from`\\r\\n    ///      account => see {updateDataOfLockedTokensOf}\\r\\n    function _afterTokenTransfer(address _from) internal override {\\r\\n        updateDataOfLockedTokensOf(_from);\\r\\n    }\\r\\n\\r\\n    /// @dev Makes validation of the single address\\r\\n    ///     If ValidationManager address was not set (= address(0)), validation is skipped\\r\\n    function _validateToInteractSingle(\\r\\n        address _account\\r\\n    ) internal view override(BaseERC20, Roles) {\\r\\n        if (_validationManager != address(0)) {\\r\\n            IValidationManager(_validationManager).validateToInteractSingle(\\r\\n                _account\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Makes validation if the method has to validste two addresses.\\r\\n    ///     If ValidationManager address was not set (= address(0)), validation is skipped\\r\\n    function _validateToInteract(address _from, address _to) internal view {\\r\\n        if (_validationManager != address(0)) {\\r\\n            IValidationManager(_validationManager).validateToInteract(\\r\\n                _from,\\r\\n                _to\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Makes transfer-validation, which has different rules than _validateToInteract\\r\\n    ///     If ValidationManager address was not set (= address(0)), validation is skipped\\r\\n    function _validateToTransfer(\\r\\n        address _from,\\r\\n        address _to,\\r\\n        uint256 _amount\\r\\n    ) internal view {\\r\\n        if (_validationManager != address(0)) {\\r\\n            IValidationManager(_validationManager).validateToTransfer(\\r\\n                _from,\\r\\n                _to,\\r\\n                _amount\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev Returns currently available amount of tokens to use (transfer) by `_account`:\\r\\n    ///      calculates the difference between the whole balance of tokens and\\r\\n    ///      locked tokens on the `_account`\\r\\n    function _availableBalance(\\r\\n        address _account\\r\\n    ) internal view override returns (uint256) {\\r\\n        return balanceOf(_account) - getAmountOfLockedTokens(_account);\\r\\n    }\\r\\n\\r\\n    /// @dev Helping function for {transferFromTreasuryLockedTokens}\\r\\n    ///      to combine two actions: {_lockTokens} & {_transfer}\\r\\n    function _lockAndTransfer(\\r\\n        address _from,\\r\\n        address _to,\\r\\n        uint256 _amount,\\r\\n        uint256 _daysToLock\\r\\n    ) internal override {\\r\\n        _lockTokens(_to, _amount, _daysToLock);\\r\\n        _transfer(_from, _to, _amount);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/interfaces/IValidationManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IValidationManager {\\r\\n    event LinkedRule(address indexed rule, uint256 indexed ruleIndex);\\r\\n\\r\\n    event UnLinkedRule(address indexed rule);\\r\\n\\r\\n    event ValidationDisabled(address account);\\r\\n\\r\\n    event ValidationEnabled(address account);\\r\\n\\r\\n    function linkRule(address _ruleAddress, uint256 _index) external;\\r\\n\\r\\n    function unlinkRule(address _ruleAddress) external;\\r\\n\\r\\n    function disableValidation() external;\\r\\n\\r\\n    function enableValidation() external;\\r\\n\\r\\n    function getSecurityTokenAddress() external view returns (address);\\r\\n\\r\\n    function getListOfAllRules() external view returns (address[] memory);\\r\\n\\r\\n    function validationDisabled() external view returns (bool);\\r\\n\\r\\n    function validateToTransfer(\\r\\n        address _from,\\r\\n        address _to,\\r\\n        uint256 _amount\\r\\n    ) external view;\\r\\n\\r\\n    function validateToInteractSingle(address _account) external view;\\r\\n\\r\\n    function validateToInteract(address _from, address _to) external view;\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/Whitelist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./Utils.sol\\\";\\r\\n\\r\\nabstract contract Whitelist is Utils {\\r\\n    /// @notice flag true - whitelist turned on, otherwise - turn off\\r\\n    bool public _isEnabledWhitelist;\\r\\n\\r\\n    /// @notice Event emitted when `creator` whitelists `_account`\\r\\n    event Whitelisted(address creator, address indexed _account);\\r\\n\\r\\n    /// @notice Event emitted when 'creator' removes `_account` from whitelist\\r\\n    event DeWhitelisted(address creator, address indexed _account);\\r\\n\\r\\n    constructor(bool isEnabledWhitelist_) {\\r\\n        _isEnabledWhitelist = isEnabledWhitelist_;\\r\\n    }\\r\\n\\r\\n    /// @notice Toggle of checking whitelist, turns it on or off\\r\\n    /// @dev Allowed only for SuperAdmin.\\r\\n    ///      When `_isEnabledWhitelist` false, all whitelisted addresses do not lose status true-whitelisted,\\r\\n    ///      but contract just doesn't check if the address whitelisted.\\r\\n    /// @param _value set `true`, if you want to turn on checking of whitelist, otherwise - set `false`\\r\\n    function toggleWhitelist(bool _value) external onlySuperAdmin {\\r\\n        _isEnabledWhitelist = _value;\\r\\n    }\\r\\n\\r\\n    /// @notice Adds array of addresses (`_bundleAddresses`) to whitelist\\r\\n    /// @dev Allowed only for ComplianceManager.\\r\\n    ///      Function blocked when contract is paused.\\r\\n    ///      Emits event {Whitelisted} for all addresses of array\\r\\n    /// @param _bundleAddresses array of addresses to add to whitelist\\r\\n    function addAddressToWhitelist(\\r\\n        address[] calldata _bundleAddresses\\r\\n    ) external ifTokenNotPaused onlyComplianceManager {\\r\\n        _checkArray(_bundleAddresses);\\r\\n        for (uint256 i = 0; i < _bundleAddresses.length; i++) {\\r\\n            address ad = _bundleAddresses[i];\\r\\n            _addAddressToWhitelist(ad);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Removes array of addresses (`_bundleAddresses`) from whitelist\\r\\n    /// @dev Allowed only for ComplianceManager.\\r\\n    ///      Function blocked when contract is paused.\\r\\n    ///      Emits event {DeWhitelisted} for all addresses of array\\r\\n    /// @param _bundleAddresses array of addresses to remove from whitelist\\r\\n    function removeAddressFromWhitelist(\\r\\n        address[] calldata _bundleAddresses\\r\\n    ) external ifTokenNotPaused onlyComplianceManager {\\r\\n        _checkArray(_bundleAddresses);\\r\\n        for (uint256 i = 0; i < _bundleAddresses.length; i++) {\\r\\n            address ad = _bundleAddresses[i];\\r\\n            _removeAddressFromWhitelist(ad);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Checks is `_address` whitelisted\\r\\n    /// @return true if `_address` whitelisted and false, if not\\r\\n    function isWhitelistedAddress(\\r\\n        address _address\\r\\n    ) external view returns (bool) {\\r\\n        return userData[_address].whitelisted;\\r\\n    }\\r\\n\\r\\n    /// @dev Whitelists the `_address`:\\r\\n    ///      - adds the address to the {PersonalInfo.userAddress}\\r\\n    ///      - sets the value `true` for {PersonalInfo.whitelisted}\\r\\n    ///      Emits {Whitelisted} event.\\r\\n    function _addAddressToWhitelist(address _address) internal {\\r\\n        userData[_address].userAddress = _address;\\r\\n        userData[_address].whitelisted = true;\\r\\n        emit Whitelisted(_msgSender(), _address);\\r\\n    }\\r\\n\\r\\n    /// @dev Dewhitelists the `_address`:\\r\\n    ///      - sets the value `false` for {PersonalInfo.whitelisted}\\r\\n    ///      Emits {DeWhitelisted} event.\\r\\n    function _removeAddressFromWhitelist(address _address) internal {\\r\\n        userData[_address].whitelisted = false;\\r\\n        emit DeWhitelisted(_msgSender(), _address);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\r\\n\\r\\nabstract contract Utils is Context {\\r\\n    uint256 internal MAX_ARRAY_LENGTH = 256;\\r\\n\\r\\n    /// @notice Struct that contains all information about address of user.\\r\\n    struct PersonalInfo {\\r\\n        //user's wallet, appointed at the moment when user is whitelisted.\\r\\n        //default value - address(0)\\r\\n        address userAddress;\\r\\n        //true - if address is whitelisted, otherwise - false.\\r\\n        bool whitelisted;\\r\\n        //true - if address has individual Secondary limit, otherwise - false.\\r\\n        bool hasOwnSecondaryLimit;\\r\\n        //true - if address has individual Transaction Count limit, otherwise - false.\\r\\n        bool hasOwnTransactionCountLimit;\\r\\n        //value of individual Secondary limit(if exists), default - 0\\r\\n        uint256 individualSecondaryTradingLimit;\\r\\n        //value of individual Transaction Count limit(if exists), default - 0\\r\\n        uint256 individualTransactionCountLimit;\\r\\n        //the total amount of all tokens ever sent by the user(address)\\r\\n        uint256 outputAmount;\\r\\n        //the total number of all transfers ever made by user(address)\\r\\n        uint256 transactionCount;\\r\\n        //dynamic array of arrays of 2 elements([0]:timestamp, [1]:blocked amount)\\r\\n        uint256[2][] personalLockUps;\\r\\n    }\\r\\n\\r\\n    /// @dev service struct to get whole necessary data of User in function `getUserData()`\\r\\n    ///      without this struct contract get the error:\\r\\n    ///      {CompilerError: Stack too deep. Try compiling with `--via-ir` (cli) or the equivalent\\r\\n    ///      `viaIR: true` (standard JSON) while enabling the optimizer.\\r\\n    ///      Otherwise, try removing local variables.}\\r\\n    struct ActualUserInfo {\\r\\n        address userAddress;\\r\\n        uint256 userBalance;\\r\\n        uint256 userLockedBalance;\\r\\n        bool isWhitelisted;\\r\\n        uint256 leftSecondaryLimit;\\r\\n        uint256 setSecondaryLimit;\\r\\n        uint256 leftTransactions;\\r\\n        uint256 setTransactionLimit;\\r\\n        uint256 outputAmount;\\r\\n        uint256 transactionCount;\\r\\n        uint256[2][] lockUps;\\r\\n    }\\r\\n\\r\\n    // mapping address of user => to its struct PersonalInfo\\r\\n    mapping(address => PersonalInfo) userData;\\r\\n\\r\\n    modifier onlyWhitelisted(address _account) virtual {\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier ifTokenNotPaused() virtual {\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlySuperAdmin() virtual {\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyComplianceManager() virtual {\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyFinancialManager() virtual {\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyRecoveryManager() virtual {\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /// @dev Helpful function to check if the length of array less then `MAX_ARRAY_LENGTH`\\r\\n    ///      This check is helpful to avoid the dDOS attack to the smart contract\\r\\n    function _checkArray(address[] memory _array) internal view {\\r\\n        require(\\r\\n            _array.length <= MAX_ARRAY_LENGTH,\\r\\n            \\\"STV2: Too long array for input\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @dev Helpful function to check if the length of input arrays are equal.\\r\\n    function _equalArrays(\\r\\n        address[] memory _addresses,\\r\\n        uint256[] memory _amounts\\r\\n    ) internal view {\\r\\n        _checkArray(_addresses);\\r\\n        require(\\r\\n            _addresses.length == _amounts.length,\\r\\n            \\\"STV2: Different quantity of elements in arrays\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    // Helping functions {_bundlesLoop} serves for using for-loops for arrays in\\r\\n    // many multi-transaction functions of the contract.\\r\\n    // They contain the logic how should interact with each other\\r\\n    // inputed parameters to correctly pass through the loop.\\r\\n    // The value from first array has to match the other value or\\r\\n    // the values from second array according to the indexes.\\r\\n    // One of inputed parameters is internal function, which\\r\\n    // is executed in the loop too.\\r\\n\\r\\n    function _bundlesLoop(\\r\\n        address[] memory _bundleAddress,\\r\\n        uint256[] memory _bundleAmounts,\\r\\n        function(address, uint256) internal _foo\\r\\n    ) internal {\\r\\n        _equalArrays(_bundleAddress, _bundleAmounts);\\r\\n        for (uint256 i = 0; i < _bundleAddress.length; i++) {\\r\\n            _foo(_bundleAddress[i], _bundleAmounts[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _bundlesLoop(\\r\\n        address _accountFrom,\\r\\n        address[] memory _bundleAddress,\\r\\n        uint256[] memory _bundleAmounts,\\r\\n        function(address, address, uint256) internal _foo\\r\\n    ) internal {\\r\\n        _equalArrays(_bundleAddress, _bundleAmounts);\\r\\n        for (uint256 i = 0; i < _bundleAddress.length; i++) {\\r\\n            _foo(_accountFrom, _bundleAddress[i], _bundleAmounts[i]);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/Roles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/AccessControlEnumerable.sol\\\";\\r\\n\\r\\n/// @title Roles\\r\\n/// @author Stobox Technologies Inc.\\r\\n/// @notice A contract for assigning and managing roles when interacting with a security token\\r\\nabstract contract Roles is AccessControlEnumerable {\\r\\n    bytes32 public constant FINANCIAL_MANAGER_ROLE =\\r\\n        keccak256(\\\"FINANCIAL_MANAGER_ROLE\\\");\\r\\n    bytes32 public constant COMPLIANCE_MANAGER_ROLE =\\r\\n        keccak256(\\\"COMPLIANCE_MANAGER_ROLE\\\");\\r\\n    bytes32 public constant RECOVERY_MANAGER_ROLE =\\r\\n        keccak256(\\\"RECOVERY_MANAGER_ROLE\\\");\\r\\n\\r\\n    constructor(\\r\\n        //list of addresses which will be assigned important roles (see contract {Roles}):\\r\\n        // * address[0] - superAdmin\\r\\n        // * address[1] - financialManager\\r\\n        // * address[2] - complianceOfficer\\r\\n        // * address[3] - masterManager\\r\\n        address[4] memory _managers\\r\\n    ) {\\r\\n        _grantRole(DEFAULT_ADMIN_ROLE, _managers[0]);\\r\\n        _grantRole(FINANCIAL_MANAGER_ROLE, _managers[1]);\\r\\n        _grantRole(COMPLIANCE_MANAGER_ROLE, _managers[2]);\\r\\n        _grantRole(RECOVERY_MANAGER_ROLE, _managers[3]);\\r\\n    }\\r\\n\\r\\n    /// @dev Creates list of addresses with necessary `_role`\\r\\n    function getListOfRoleOwners(\\r\\n        bytes32 _role\\r\\n    ) public view returns (address[] memory) {\\r\\n        uint256 len = getRoleMemberCount(_role);\\r\\n        address[] memory resultedList = new address[](len);\\r\\n\\r\\n        for (uint256 i = 0; i < len; i++) {\\r\\n            resultedList[i] = getRoleMember(_role, i);\\r\\n        }\\r\\n        return resultedList;\\r\\n    }\\r\\n\\r\\n    /// @dev Overload {_grantRole} to validate caller and `account` to grant role\\r\\n    function _grantRole(bytes32 role, address account) internal override {\\r\\n        _validateToInteractSingle(account);\\r\\n        super._grantRole(role, account);\\r\\n    }\\r\\n\\r\\n    function _revokeRole(bytes32 role, address account) internal override {\\r\\n        if (role == DEFAULT_ADMIN_ROLE) {\\r\\n            require(getRoleMemberCount(role) > 1, \\\"Last SuperAdmin\\\");\\r\\n        }\\r\\n        super._revokeRole(role, account);\\r\\n    }\\r\\n\\r\\n    function _checkRole(bytes32 role) internal view override {\\r\\n        _validateToInteractSingle(_msgSender());\\r\\n        super._checkRole(role, _msgSender());\\r\\n    }\\r\\n\\r\\n    function _validateToInteractSingle(address _account) internal view virtual;\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/LockUps.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./Utils.sol\\\";\\r\\n\\r\\nabstract contract LockUps is Utils {\\r\\n    /// @notice flag true - LockUps turned on, otherwise - turn off\\r\\n    bool public _isEnabledLockUps;\\r\\n\\r\\n    /// @notice Event emited when 'creator' locks `lockedAmount` of tokens\\r\\n    /// on the address of `tokensOwner` until `timestampToUnlock` will come\\r\\n    event LockTokens(\\r\\n        address creator,\\r\\n        address tokensOwner,\\r\\n        uint256 timestampToUnlock,\\r\\n        uint256 lockedAmount\\r\\n    );\\r\\n\\r\\n    /// @notice Event emited when locked tokens unlock\\r\\n    event UnlockTokens(\\r\\n        address tokensOwner,\\r\\n        uint256 timestampWhenUnlocked,\\r\\n        uint256 unlockedAmount\\r\\n    );\\r\\n\\r\\n    constructor(bool isEnabledLockUps_) {\\r\\n        _isEnabledLockUps = isEnabledLockUps_;\\r\\n    }\\r\\n\\r\\n    /// @notice Toggle of checking lockUps, turns it on or off\\r\\n    /// @dev Allowed only for SuperAdmin.\\r\\n    ///      When `isEnabledLockUps_` false, all information abount locked tokens stay and will not be deleted,\\r\\n    ///      but contract just doesn't check if the address has locked tokens.\\r\\n    ///      If `isEnabledLockUps_` will become true again - locked tokens will be unavailable again\\r\\n    /// @param _value set `true`, if you want to turn on checking of lockUps, otherwise - set `false`\\r\\n    function toggleLockUps(bool _value) external onlySuperAdmin {\\r\\n        _isEnabledLockUps = _value;\\r\\n    }\\r\\n\\r\\n    /// @notice Transfers amount of tokens from array `_bundleAmounts` from {_corporateTreasury}\\r\\n    ///         to addresses from array of addresses `_bundleTo`\\r\\n    ///         and at one time locks these tokens for the `_daysToLock` quantity of days\\r\\n    /// @dev Allowed only for FinancialManager.\\r\\n    ///      Function blocked when contract is paused.\\r\\n    ///      To be able to call this function FinancialManager has\\r\\n    ///      to be given unlimited {approve} from {_corporateTreasury}\\r\\n    ///      The proper pair of data: (timestamp when tokens can be unlocked & proper\\r\\n    ///      amount from `_bundleAmounts`) is written to\\r\\n    ///      the parametr of account: {personalLockUps} for each account from the array\\r\\n    ///      Address => value transferred and locked according to indexes of arrays:\\r\\n    ///      to [0]indexed address will be transferred and locked [0]indexed amount of tokens,\\r\\n    ///      to [1]indexed address will be transferred and locked [1]indexed amount of tokens and so on\\r\\n    /// @param _bundleTo array of addresses which will receive tokens and on which they will be locked\\r\\n    /// @param _bundleAmounts array of amounts of tokens to transfer & lock\\r\\n    /// @param _daysToLock the quantity of days you want to lock tokens for\\r\\n    /// @return true if function passed successfully\\r\\n    function transferFromTreasuryLockedTokens(\\r\\n        address[] memory _bundleTo,\\r\\n        uint256[] memory _bundleAmounts,\\r\\n        uint256 _daysToLock\\r\\n    ) external ifTokenNotPaused onlyFinancialManager returns (bool) {\\r\\n        require(_isEnabledLockUps, \\\"STV2: LockUps switched off\\\");\\r\\n\\r\\n        _equalArrays(_bundleTo, _bundleAmounts);\\r\\n        for (uint256 i = 0; i < _bundleTo.length; i++) {\\r\\n            _lockAndTransfer(\\r\\n                corporateTreasury(),\\r\\n                _bundleTo[i],\\r\\n                _bundleAmounts[i],\\r\\n                _daysToLock\\r\\n            );\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// @notice Locks amount of tokens from `_bundleAmounts` on account from the array of\\r\\n    ///         addresses `_bundleTo` for the `_daysToLock` quantity of days\\r\\n    /// @dev Allowed only for FinancialManager.\\r\\n    ///      Function blocked when contract is paused.\\r\\n    ///      The proper pair of data: ([0]timestamp when tokens can be unlocked & [1]locked amount of token)\\r\\n    ///      is written to the parametr of account: {personalLockUps} for each account from the array\\r\\n    ///      Function checks the opportunity to lock `_amountToLock`=> see\\r\\n    ///      comments to function {_checkAmountToLock} to know how is it checked.\\r\\n    ///      And lock amount from `_bundleAmounts` of tokens or the\\r\\n    ///      whole available balance of account from `_bundleTo`.\\r\\n    ///      Address => value locked according to indexes of arrays:\\r\\n    ///      on [0]indexed address will be locked [0]indexed amount of tokens,\\r\\n    ///      on [1]indexed address will be locked [1]indexed amount of tokens and so on\\r\\n    /// @param _bundleTo array of addresses on which tokens will be locked\\r\\n    /// @param _bundleAmounts array of amounts of tokens to lock\\r\\n    /// @param _daysToLock the quantity of days you want to lock tokens for\\r\\n    /// @return true if function passed successfully\\r\\n    function lockUpTokensOnAddress(\\r\\n        address[] memory _bundleTo,\\r\\n        uint256[] memory _bundleAmounts,\\r\\n        uint256 _daysToLock\\r\\n    ) external ifTokenNotPaused onlyFinancialManager returns (bool) {\\r\\n        require(_isEnabledLockUps, \\\"STV2: LockUps switched off\\\");\\r\\n\\r\\n        _equalArrays(_bundleTo, _bundleAmounts);\\r\\n        for (uint256 i = 0; i < _bundleTo.length; i++) {\\r\\n            _lockTokens(\\r\\n                _bundleTo[i],\\r\\n                _checkAmountToLock(_bundleTo[i], _bundleAmounts[i]),\\r\\n                _daysToLock\\r\\n            );\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the array of pairs of locked tokens and their timestamps to\\r\\n    ///         be unlocked for the `_account`\\r\\n    /// @dev Array of arrays of 2 elements([0]:timestamp, [1]:blocked amount)\\r\\n    function getListOfLockUps(\\r\\n        address _account\\r\\n    ) public view returns (uint256[2][] memory) {\\r\\n        return userData[_account].personalLockUps;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the whole value of all locked tokens on the `_account`\\r\\n    ///         if toggle `_isEnabledLockUps` is false - returns 0\\r\\n    /// @dev Function gets the list of all LockUps on the `_account` (see {getListOfLockUps}),\\r\\n    ///      loops through the pairs, checks whether the\\r\\n    ///      required timestamp has not yet arrived and if not - adds the amounts\\r\\n    /// @param _account address to find out locked amount of tokens\\r\\n    /// @return (the) sum of amounts of locked tokens of all lockUps on this address\\r\\n    function getAmountOfLockedTokens(\\r\\n        address _account\\r\\n    ) public view returns (uint256) {\\r\\n        uint256 result = 0;\\r\\n\\r\\n        if (!(_isEnabledLockUps)) {\\r\\n            return result;\\r\\n        } else {\\r\\n            uint256[2][] memory lockUps = getListOfLockUps(_account);\\r\\n            uint256 len = lockUps.length;\\r\\n\\r\\n            if (len == 0) {\\r\\n                return result;\\r\\n            } else {\\r\\n                for (uint256 i = 0; i < len; i++) {\\r\\n                    if (lockUps[i][0] >= block.timestamp) {\\r\\n                        result += lockUps[i][1];\\r\\n                    }\\r\\n                }\\r\\n                return result;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Updates the lockUps of the `_account` according to timestamps.\\r\\n    ///         If the time to unlock certain amount of tokens has come,\\r\\n    ///         it makes these tokens \\\"free\\\".\\r\\n    /// @dev Function loops through the array of pairs with data about locked tokens:\\r\\n    ///      {PersonalInfo.personalLockUps}\\r\\n    ///      If the [0]indexed parametr of pair (timestamp to unlock) is less then current\\r\\n    ///      timestamp - {block.timestamp} => it will be deleted from the array\\r\\n    ///      and the [1]indexed amount of tokens will be unlocked in such a way\\r\\n    ///      and Event {UnlockTokens} emits.\\r\\n    ///      Otherwise - this pair is passed and tokens stay locked.\\r\\n    /// @param _account address to update its LockUps\\r\\n    /// @return true if function passed successfully\\r\\n    function updateDataOfLockedTokensOf(\\r\\n        address _account\\r\\n    ) public returns (bool) {\\r\\n        if (userData[_account].personalLockUps.length == 0) {\\r\\n            return true;\\r\\n        } else {\\r\\n            uint count = 0;\\r\\n            uint256[2][] memory memoryArray = new uint256[2][](\\r\\n                userData[_account].personalLockUps.length\\r\\n            );\\r\\n            for (uint256 i = 0; i < memoryArray.length; i++) {\\r\\n                if (\\r\\n                    userData[_account].personalLockUps[i][0] <= block.timestamp\\r\\n                ) {\\r\\n                    emit UnlockTokens(\\r\\n                        _account,\\r\\n                        block.timestamp,\\r\\n                        userData[_account].personalLockUps[i][1]\\r\\n                    );\\r\\n                } else {\\r\\n                    memoryArray[i] = userData[_account].personalLockUps[i];\\r\\n                    count++;\\r\\n                }\\r\\n            }\\r\\n\\r\\n            uint256[2][] memory finalArray = new uint256[2][](count);\\r\\n            uint k = 0;\\r\\n\\r\\n            for (uint256 i = 0; i < memoryArray.length; i++) {\\r\\n                if (memoryArray[i][0] > 0) {\\r\\n                    finalArray[k] = memoryArray[i];\\r\\n                    k++;\\r\\n                }\\r\\n            }\\r\\n\\r\\n            userData[_account].personalLockUps = finalArray;\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the address of the official corporate wallet\\r\\n    function corporateTreasury() public view virtual returns (address);\\r\\n\\r\\n    /// @dev Returns currently available amount of tokens to use (transfer) by `_account`:\\r\\n    ///      calculates the difference between the whole balance of tokens and\\r\\n    ///      locked tokens on the `_account`\\r\\n    function _availableBalance(\\r\\n        address _account\\r\\n    ) internal view virtual returns (uint256);\\r\\n\\r\\n    /// @dev Checks what amount to lock on `_account`:\\r\\n    ///      compare {_availableBalance} of `_account` and `_amountToLock`\\r\\n    ///      and returns the less value.\\r\\n    ///      This function does not allow to lock tockens which `_account` does not have\\r\\n    ///      on its balance yet, in other words, to get a \\\"negative balance\\\" for `_account`\\r\\n    function _checkAmountToLock(\\r\\n        address _account,\\r\\n        uint256 _amountToLock\\r\\n    ) internal view returns (uint256 resultedAmount) {\\r\\n        _availableBalance(_account) > _amountToLock\\r\\n            ? resultedAmount = _amountToLock\\r\\n            : resultedAmount = _availableBalance(_account);\\r\\n    }\\r\\n\\r\\n    /// @dev locks `_amount` of tokens on `_account` for `_daysToLock` quantity of days:\\r\\n    ///      Adds the pair ([0]timestemp when tokens can be unlocked, [1] `_amount`) to the\\r\\n    ///      array {PersonalInfo.personalLockUps}\\r\\n    ///      Emits {LockTokens} event.\\r\\n    function _lockTokens(\\r\\n        address _account,\\r\\n        uint256 _amount,\\r\\n        uint256 _daysToLock\\r\\n    ) internal {\\r\\n        uint256[2] memory lockedPair;\\r\\n        // Calculates the timstamp, when tokens can be unlocked:\\r\\n        // interprets a function parameter in days `_daysToLock`\\r\\n        // into Unix Timestamp( in seconds since JAN 01 1970)\\r\\n        lockedPair[0] = block.timestamp + (_daysToLock * 1 days);\\r\\n        lockedPair[1] = _amount;\\r\\n\\r\\n        userData[_account].personalLockUps.push(lockedPair);\\r\\n        emit LockTokens(_msgSender(), _account, lockedPair[0], _amount);\\r\\n    }\\r\\n\\r\\n    /// @dev Helping function for {transferFromTreasuryLockedTokens}\\r\\n    ///      to combine two actions: {_lockTokens} & {_transfer}\\r\\n    function _lockAndTransfer(\\r\\n        address _from,\\r\\n        address _to,\\r\\n        uint256 _amount,\\r\\n        uint256 _daysToLock\\r\\n    ) internal virtual;\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/Limits.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./Utils.sol\\\";\\r\\n\\r\\ncontract Limits is Utils {\\r\\n    /// @notice flag true - Secondary limit turned on, otherwise - turn off\\r\\n    bool public _isEnabledSecondaryTradingLimit;\\r\\n\\r\\n    /// @notice flag true - Transaction count limit turned on, otherwise - turn off\\r\\n    bool public _isEnabledTransactionCountLimit;\\r\\n\\r\\n    /// @notice secondary trading limit which is used for every address without individual limit\\r\\n    /// (when flag `_isEnabledSecondaryTradingLimit` is true)\\r\\n    uint256 internal _defaultSecondaryTradingLimit;\\r\\n\\r\\n    /// @notice transaction count limit which is used for every address without individual limit\\r\\n    /// (when flag `_isEnabledTransactionCountLimit` is true)\\r\\n    uint256 internal _defaultTransactionCountLimit;\\r\\n\\r\\n    /// @notice integer = 2**256 - 1\\r\\n    uint256 internal MAX_UINT = type(uint256).max;\\r\\n\\r\\n    constructor(\\r\\n        address corporateTreasury_,\\r\\n        bool[2] memory _enableLimits,\\r\\n        uint256[2] memory _defaultLimits\\r\\n    ) {\\r\\n        _isEnabledSecondaryTradingLimit = _enableLimits[0];\\r\\n        _isEnabledTransactionCountLimit = _enableLimits[1];\\r\\n        _defaultSecondaryTradingLimit = _defaultLimits[0];\\r\\n        _defaultTransactionCountLimit = _defaultLimits[1];\\r\\n\\r\\n        _setSecondaryTradingLimitFor(corporateTreasury_, MAX_UINT);\\r\\n        _setTransactionCountLimitFor(corporateTreasury_, MAX_UINT);\\r\\n    }\\r\\n\\r\\n    /// @notice Toggle of checking TransactionCount limit, turns it on or off\\r\\n    /// @dev Allowed only for SuperAdmin.\\r\\n    ///      When `_isEnabledTransactionCountLimit` false, all values\\r\\n    ///      of limits(default limit or individual limits of addresses) stay saved,\\r\\n    ///      but contract just doesn't check TransactionCount limit at all.\\r\\n    /// @param _value set `true`, if you want to turn on checking of limit, otherwise - set `false`\\r\\n    function toggleTransactionCount(bool _value) external onlySuperAdmin {\\r\\n        _isEnabledTransactionCountLimit = _value;\\r\\n    }\\r\\n\\r\\n    /// @notice Toggle of checking SecondaryTrading limit, turns it on or off\\r\\n    /// @dev Allowed only for SuperAdmin.\\r\\n    ///      When `_isEnabledSecondaryTradingLimit` false, all values\\r\\n    ///      of limits(default limit or individual limits of addresses) stay saved,\\r\\n    ///      but contract just doesn't check SecondaryTrading limit at all.\\r\\n    /// @param _value set `true`, if you want to turn on checking of limit, otherwise - set `false`\\r\\n    function toggleSecondaryTradingLimit(bool _value) external onlySuperAdmin {\\r\\n        _isEnabledSecondaryTradingLimit = _value;\\r\\n    }\\r\\n\\r\\n    /// @notice Sets the value of `_defaultSecondaryTradingLimit`.\\r\\n    /// @dev Allowed only for ComplianceManager.\\r\\n    ///      Function blocked when contract is paused.\\r\\n    /// @param _newLimit the value of limit to set\\r\\n    function setDefaultSecondaryTradingLimit(\\r\\n        uint256 _newLimit\\r\\n    ) external ifTokenNotPaused onlyComplianceManager {\\r\\n        _defaultSecondaryTradingLimit = _newLimit;\\r\\n    }\\r\\n\\r\\n    /// @notice Sets the value of `_defaultTransactionCountLimit`.\\r\\n    /// @dev Allowed only for ComplianceManager.\\r\\n    ///      Function blocked when contract is paused.\\r\\n    /// @param _newLimit the value of limit to set\\r\\n    function setDefaultTransactionCountLimit(\\r\\n        uint256 _newLimit\\r\\n    ) external ifTokenNotPaused onlyComplianceManager {\\r\\n        _defaultTransactionCountLimit = _newLimit;\\r\\n    }\\r\\n\\r\\n    /// @notice Sets the value of `individualSecondaryTradingLimit` for\\r\\n    ///         each address from array of addresses `_bundleAccounts` as\\r\\n    ///         the value from array of numbers `_bundleNewLimits`\\r\\n    /// @dev Allowed only for ComplianceManager.\\r\\n    ///      Function blocked when contract is paused.\\r\\n    ///      Address => value set according to indexes of arrays:\\r\\n    ///      [0]indexed address will have [0]indexed value of limit,\\r\\n    ///      [1]indexed address will have [1]indexed value of limit and so on\\r\\n    /// @param _bundleAccounts array of addresses to set new `individualSecondaryTradingLimit`\\r\\n    /// @param _bundleNewLimits array of the values of limit to set.\\r\\n    function setSecondaryTradingLimitFor(\\r\\n        address[] calldata _bundleAccounts,\\r\\n        uint256[] calldata _bundleNewLimits\\r\\n    ) external ifTokenNotPaused onlyComplianceManager {\\r\\n        _bundlesLoop(\\r\\n            _bundleAccounts,\\r\\n            _bundleNewLimits,\\r\\n            _setSecondaryTradingLimitFor\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @notice Sets the value of `individualTransactionCountLimit` for\\r\\n    ///         each address from array of addresses `_bundleAccounts` as\\r\\n    ///         the value from array of numbers `_bundleNewLimits`\\r\\n    /// @dev Allowed only for ComplianceManager.\\r\\n    ///      Function blocked when contract is paused.\\r\\n    ///      Address => value set according to indexes of arrays:\\r\\n    ///      [0]indexed address will have [0]indexed value of limit,\\r\\n    ///      [1]indexed address will have [1]indexed value of limit and so on\\r\\n    /// @param _bundleAccounts array of addresses to set new `individualTransactionCountLimit`\\r\\n    /// @param _bundleNewLimits array of the values of limit to set.\\r\\n    function setTransactionCountLimitFor(\\r\\n        address[] calldata _bundleAccounts,\\r\\n        uint256[] calldata _bundleNewLimits\\r\\n    ) external ifTokenNotPaused onlyComplianceManager {\\r\\n        _bundlesLoop(\\r\\n            _bundleAccounts,\\r\\n            _bundleNewLimits,\\r\\n            _setTransactionCountLimitFor\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @notice After calling this function the {_defaultSecondaryTradingLimit}\\r\\n    ///         will apply to addresses from array `_accountsToReset`\\r\\n    ///         instead of there {individualSecondaryTradingLimit} (if they had it)\\r\\n    /// @dev Allowed only for ComplianceManager.\\r\\n    /// @param _accountsToReset array of addresses to reset limit to default\\r\\n    function resetSecondaryTradingLimitToDefault(\\r\\n        address[] calldata _accountsToReset\\r\\n    ) external ifTokenNotPaused onlyComplianceManager {\\r\\n        _checkArray(_accountsToReset);\\r\\n        for (uint256 i = 0; i < _accountsToReset.length; i++) {\\r\\n            userData[_accountsToReset[i]].hasOwnSecondaryLimit = false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice After calling this function the {_defaultSecondaryTradingLimit}\\r\\n    ///         will apply to addresses from array `_accountsToReset`\\r\\n    ///         instead of there {individualTransactionCountLimit} (if they had it)\\r\\n    /// @dev Allowed only for ComplianceManager.\\r\\n    ///      Function blocked when contract is paused.\\r\\n    ///      Function just changes flag {hasOwnTransactionCountLimit} to `false`\\r\\n    ///      for the addresses from `_accountsToReset`\\r\\n    ///      and contract will ignore value which is set in\\r\\n    ///      the parametr {individualTransactionCountLimit} for each account from array\\r\\n    /// @param _accountsToReset array of addresses to reset limit to default\\r\\n    function resetTransactionCountLimitToDefault(\\r\\n        address[] calldata _accountsToReset\\r\\n    ) external ifTokenNotPaused onlyComplianceManager {\\r\\n        _checkArray(_accountsToReset);\\r\\n        for (uint256 i = 0; i < _accountsToReset.length; i++) {\\r\\n            userData[_accountsToReset[i]].hasOwnTransactionCountLimit = false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the value of the default Secondary Trading limit\\r\\n    function defaultSecondaryTradingLimit() external view returns (uint256) {\\r\\n        return _defaultSecondaryTradingLimit;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the value of the default Transaction Count limit\\r\\n    function defaultTransactionCountLimit() external view returns (uint256) {\\r\\n        return _defaultTransactionCountLimit;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the available number of transfers `_account` can do yet\\r\\n    /// @dev The function gets two values:\\r\\n    ///      {transactionCountLimitOf} - the current limit of transfers for the `_account`\\r\\n    ///      {PersonalInfo.transactionCount} - the number of transfers which `_account` already has made.\\r\\n    ///      Function returns the substraction: (current limit - made transfers) or revert\\r\\n    ///      with proper message, if the `_account` doesn't have avalaible limit.\\r\\n    /// @param _account address to find out its limit\\r\\n    function getLeftTransactionCountLimit(\\r\\n        address _account\\r\\n    ) public view returns (uint256) {\\r\\n        uint256 limit = transactionCountLimitOf(_account);\\r\\n        if (userData[_account].transactionCount >= limit) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        return limit - userData[_account].transactionCount;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the value of the Secondary Trading limit that applies to this '_account'\\r\\n    /// @dev The function makes several steps of verification:\\r\\n    ///      * Checks if the control of Secondary Limits turned on:\\r\\n    ///        the flag {_isEnabledSecondaryTradingLimit}\\r\\n    ///        is false - returns {MAX_UINT}\\r\\n    ///        is true:\\r\\n    ///\\r\\n    ///          * Checks if the `_account` {hasOwnSecondaryLimit}:\\r\\n    ///            if true - returns PersonalInfo.individualSecondaryTradingLimit of `_account`\\r\\n    ///            if false - returns {_defaultSecondaryTradingLimit}\\r\\n    /// @param _account address to find out the value of its current Secondary Trading limit\\r\\n    function secondaryTradingLimitOf(\\r\\n        address _account\\r\\n    ) public view returns (uint256) {\\r\\n        if (_isEnabledSecondaryTradingLimit) {\\r\\n            if (userData[_account].hasOwnSecondaryLimit) {\\r\\n                return userData[_account].individualSecondaryTradingLimit;\\r\\n            } else {\\r\\n                return _defaultSecondaryTradingLimit;\\r\\n            }\\r\\n        }\\r\\n        return MAX_UINT;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the value of the Transaction Count limit that applies to this '_account'\\r\\n    /// @dev The function makes several steps of verification:\\r\\n    ///      * Checks if the control of Transaction Count limit turned on:\\r\\n    ///        the flag {_isEnabledTransactionCountLimit}\\r\\n    ///        is false - returns {MAX_UINT}\\r\\n    ///        is true:\\r\\n    ///\\r\\n    ///          * Checks if the `_account` {hasOwnTransactionCountLimit}:\\r\\n    ///            if true - returns PersonalInfo.individualTransactionCountLimit of `_account`\\r\\n    ///            if false - returns {_defaultTransactionCountLimit}\\r\\n    /// @param _account address to find out the value of its current Transaction Count limit\\r\\n    function transactionCountLimitOf(\\r\\n        address _account\\r\\n    ) public view returns (uint256) {\\r\\n        if (_isEnabledTransactionCountLimit) {\\r\\n            if (userData[_account].hasOwnTransactionCountLimit) {\\r\\n                return userData[_account].individualTransactionCountLimit;\\r\\n            } else {\\r\\n                return _defaultTransactionCountLimit;\\r\\n            }\\r\\n        }\\r\\n        return MAX_UINT;\\r\\n    }\\r\\n\\r\\n    /// @dev Sets the `_newLimit` as Individual Secondary Trading Limit for `_account`:\\r\\n    ///      - sets the value `true` for {PersonalInfo.hasOwnSecondaryLimit}\\r\\n    ///      - sets the value `_newLimit` for {PersonalInfo.individualSecondaryTradingLimit}\\r\\n    function _setSecondaryTradingLimitFor(\\r\\n        address _account,\\r\\n        uint256 _newLimit\\r\\n    ) internal {\\r\\n        userData[_account].hasOwnSecondaryLimit = true;\\r\\n        userData[_account].individualSecondaryTradingLimit = _newLimit;\\r\\n    }\\r\\n\\r\\n    /// @dev Sets the `_newLimit` as Individual Transaction Count Limit for `_account`:\\r\\n    ///      - sets the value `true` for {PersonalInfo.hasOwnTransactionCountLimit}\\r\\n    ///      - sets the value `_newLimit` for {PersonalInfo.individualTransactionCountLimit}\\r\\n    function _setTransactionCountLimitFor(\\r\\n        address _account,\\r\\n        uint256 _newLimit\\r\\n    ) internal {\\r\\n        userData[_account].hasOwnTransactionCountLimit = true;\\r\\n        userData[_account].individualTransactionCountLimit = _newLimit;\\r\\n    }\\r\\n\\r\\n    /// @dev Returns currently available Secondary Trading limit of `_account`:\\r\\n    ///      calculates difference between the current limit of `_account` and\\r\\n    ///      the amount already sent by this address\\r\\n    function _availableLimit(address _account) internal view returns (uint256) {\\r\\n        uint256 limit = secondaryTradingLimitOf(_account);\\r\\n        if (userData[_account].outputAmount >= limit) {\\r\\n            return 0;\\r\\n        }\\r\\n        return limit - userData[_account].outputAmount;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/Deployerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (a deployer) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the deployer account will be the one that deploys the contract.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyDeployer`, which can be applied to your functions to restrict their use to\\r\\n * the deployer.\\r\\n */\\r\\nabstract contract Deployerable is Context {\\r\\n    address private _deployer;\\r\\n\\r\\n    event DeployershipTransferred(\\r\\n        address indexed previousDeployer,\\r\\n        address indexed newDeployer\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial deployer.\\r\\n     */\\r\\n    constructor() {\\r\\n        _transferDeployership(_msgSender());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the deployer.\\r\\n     */\\r\\n    modifier onlyDeployer() {\\r\\n        _checkDeployer();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current deployer.\\r\\n     */\\r\\n    function deployer() public view returns (address) {\\r\\n        return _deployer;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if the sender is not the deployer.\\r\\n     */\\r\\n    function _checkDeployer() internal view {\\r\\n        require(\\r\\n            deployer() == _msgSender(),\\r\\n            \\\"Deployerable: caller is not deployer\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without deployer. It will not be possible to call\\r\\n     * `onlyDeployer` functions anymore. Can only be called by the current deployer.\\r\\n     *\\r\\n     * NOTE: Renouncing deployership will leave the contract without an deployer,\\r\\n     * thereby removing any functionality that is only available to the deployer.\\r\\n     */\\r\\n    function renounceDeployership() external onlyDeployer {\\r\\n        _transferDeployership(address(0));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers deployership of the contract to a new account (`newDeployer`).\\r\\n     * Can only be called by the current deployer.\\r\\n     */\\r\\n    function transferDeployership(address newDeployer) external onlyDeployer {\\r\\n        require(newDeployer != address(0), \\\"Deployerable: invalid newDeployer\\\");\\r\\n        _transferDeployership(newDeployer);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers deployership of the contract to a new account (`newDeployer`).\\r\\n     * Internal function without access restriction.\\r\\n     */\\r\\n    function _transferDeployership(address newDeployer) internal {\\r\\n        address oldDeployer = _deployer;\\r\\n        _deployer = newDeployer;\\r\\n        emit DeployershipTransferred(oldDeployer, newDeployer);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/BaseERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\r\\nimport \\\"./interfaces/IValidationManager.sol\\\";\\r\\nimport \\\"./Utils.sol\\\";\\r\\n\\r\\n/// @title BaseERC20\\r\\n/// @author Stobox Technologies Inc.\\r\\n/// @notice A contract for implementing of the standard ERC20-token functionality for security token\\r\\nabstract contract BaseERC20 is IERC20Metadata, Utils {\\r\\n    mapping(address => uint256) private _balances;\\r\\n\\r\\n    mapping(address => mapping(address => uint256)) private _allowances;\\r\\n\\r\\n    /// @notice The number of decimals used to get its user representation.\\r\\n    ///         For example, if `decimals` equals `2`, a balance of `505` tokens should\\r\\n    ///         be displayed to a user as `5.05` (`505 / 10 ** 2`).\\r\\n    ///         Security Token has to have decimals = `0`\\r\\n    ///         Common ERC20-Tokens usually opt for a value of 18, imitating the\\r\\n    ///         relationship between Ether and Wei.\\r\\n    uint8 private _decimals;\\r\\n\\r\\n    /// @notice Total amount of emited tokens\\r\\n    uint256 private _totalSupply;\\r\\n\\r\\n    string private _name;\\r\\n    string private _symbol;\\r\\n\\r\\n    constructor(string memory name_, string memory symbol_, uint8 decimals_) {\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n        _decimals = decimals_;\\r\\n    }\\r\\n\\r\\n    /// @notice Mints `_amount` of tokens to the address `_to`\\r\\n    /// @dev Allowed only for RecoveryManager\\r\\n    /// @param _to address to mint on it tokens\\r\\n    /// @param _amount amount of tokens to mint\\r\\n    function mint(address _to, uint256 _amount) external onlyRecoveryManager {\\r\\n        _mint(_to, _amount);\\r\\n    }\\r\\n\\r\\n    /// @notice Burns `_amount` of tokens from the address `_from`\\r\\n    /// @dev Allowed only for RecoveryManager\\r\\n    /// @param _from address to burn tokens from\\r\\n    /// @param _amount amount of tokens to burn\\r\\n    function burn(address _from, uint256 _amount) external onlyRecoveryManager {\\r\\n        _burn(_from, _amount);\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the name of the token.\\r\\n    function name() public view returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the symbol of the token, usually a shorter version of the name.\\r\\n    function symbol() public view returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the number of decimals of token\\r\\n    function decimals() public view returns (uint8) {\\r\\n        return _decimals;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the amount of tokens in existence.\\r\\n    function totalSupply() public view returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the amount of tokens owned by `_account`.\\r\\n    function balanceOf(address _account) public view returns (uint256) {\\r\\n        return _balances[_account];\\r\\n    }\\r\\n\\r\\n    /// @notice Moves `_amount` of tokens from the caller's account to `_to` address.\\r\\n    /// @dev Emits a {Transfer} event.\\r\\n    ///      Function blocked when contract is paused.\\r\\n    ///      Function has a number of checks and conditions - see {_transfer} internal function.\\r\\n    /// @return true if function passed successfully\\r\\n    function transfer(\\r\\n        address _to,\\r\\n        uint256 _amount\\r\\n    ) public ifTokenNotPaused returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        _transfer(owner, _to, _amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// @dev Returns the remaining number of tokens that `_spender` will be\\r\\n    ///      allowed to spend on behalf of `_owner` through {transferFrom}. This is\\r\\n    ///      zero by default.\\r\\n    ///      This value changes when {approve} or {transferFrom} are called.\\r\\n    function allowance(\\r\\n        address _owner,\\r\\n        address _spender\\r\\n    ) public view returns (uint256) {\\r\\n        return _allowances[_owner][_spender];\\r\\n    }\\r\\n\\r\\n    /// @notice Sets `_amount` as the allowance of `_spender` over the caller's tokens.\\r\\n    ///         Returns a boolean value indicating whether the operation succeeded.\\r\\n    /// @dev IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n    ///      that someone may use both the old and the new allowance by unfortunate\\r\\n    ///      transaction ordering. One possible solution to mitigate this race\\r\\n    ///      condition is to first reduce the spender's allowance to 0 and set the\\r\\n    ///      desired value afterwards.\\r\\n    ///\\r\\n    ///      Function blocked when contract is paused.\\r\\n    ///      Emits an {Approval} event.\\r\\n    ///      Function has a number of checks and conditions - see {_approve} internal function.\\r\\n    function approve(\\r\\n        address _spender,\\r\\n        uint256 _amount\\r\\n    ) public ifTokenNotPaused returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        _validateToInteractSingle(owner);\\r\\n        _approve(owner, _spender, _amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// @notice Moves `_amount` of tokens from `_from` to `_to` using the allowance mechanism.\\r\\n    ///         `_amount` is then deducted from the caller's allowance.\\r\\n    ///         Returns a boolean value indicating whether the operation succeeded.\\r\\n    /// @dev Function blocked when contract is paused.\\r\\n    ///      Emits a {Transfer} event.\\r\\n    ///      Function has a number of checks and conditions - see:\\r\\n    ///      {_transfer} & {_spendAllowance} internal function.\\r\\n    function transferFrom(\\r\\n        address _from,\\r\\n        address _to,\\r\\n        uint256 _amount\\r\\n    ) public ifTokenNotPaused returns (bool) {\\r\\n        address spender = _msgSender();\\r\\n        _spendAllowance(_from, spender, _amount);\\r\\n        _transfer(_from, _to, _amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// @notice This function can move `_amount` of tokens from\\r\\n    ///         any `_from` address to any whitelisted `_to` address\\r\\n    /// @dev Allowed only for RecoveryManager.\\r\\n    ///      Addresses `_from` and `_to` can not be zero-addresses.\\r\\n    /// @param _from address from which tokens will be transfered\\r\\n    /// @param _to address where tokens will be transfered\\r\\n    /// @param _amount of tokens to transfer\\r\\n    function transferFunds(\\r\\n        address _from,\\r\\n        address _to,\\r\\n        uint256 _amount\\r\\n    ) external onlyRecoveryManager onlyWhitelisted(_to) {\\r\\n        require(_from != address(0), \\\"STV2: transfer from zero address\\\");\\r\\n        require(_to != address(0), \\\"STV2: transfer to zero address\\\");\\r\\n\\r\\n        uint256 fromBalance = _balances[_from];\\r\\n        require(\\r\\n            fromBalance >= _amount,\\r\\n            \\\"STV2: transfer amount exceeds balance\\\"\\r\\n        );\\r\\n\\r\\n        _validateToInteractSingle(_to);\\r\\n\\r\\n        unchecked {\\r\\n            _balances[_from] = fromBalance - _amount;\\r\\n            _balances[_to] += _amount;\\r\\n        }\\r\\n        emit Transfer(_from, _to, _amount);\\r\\n    }\\r\\n\\r\\n    /// @notice Increases the allowance granted to `_spender` by the caller.\\r\\n    /// @dev This is an alternative to {approve} that can be used as a mitigation for\\r\\n    ///      problems described in {approve}.\\r\\n    ///      Function blocked when contract is paused.\\r\\n    ///      Emits an {Approval} event indicating the updated allowance.\\r\\n    ///      Function has a number of checks and conditions - see {_approve} internal function.\\r\\n    ///      Requirements:\\r\\n    ///      `spender` cannot be the zero address.\\r\\n    function increaseAllowance(\\r\\n        address _spender,\\r\\n        uint256 _addedValue\\r\\n    ) public ifTokenNotPaused returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        _validateToInteractSingle(owner);\\r\\n        _approve(owner, _spender, allowance(owner, _spender) + _addedValue);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// @notice Decreases the allowance granted to `_spender` by the caller.\\r\\n    /// @dev This is an alternative to {approve} that can be used as a mitigation for\\r\\n    ///      problems described in {approve}.\\r\\n    ///      Function blocked when contract is paused.\\r\\n    ///      Emits an {Approval} event indicating the updated allowance.\\r\\n    ///      Function has a number of checks and conditions - see {_approve} internal function.\\r\\n    ///      Requirements:\\r\\n    ///      `_spender` cannot be the zero address.\\r\\n    ///      `_spender` must have allowance for the caller of at least `subtractedValue`.\\r\\n    function decreaseAllowance(\\r\\n        address _spender,\\r\\n        uint256 _subtractedValue\\r\\n    ) public ifTokenNotPaused returns (bool) {\\r\\n        address owner = _msgSender();\\r\\n        _validateToInteractSingle(owner);\\r\\n        uint256 currentAllowance = allowance(owner, _spender);\\r\\n        require(\\r\\n            currentAllowance >= _subtractedValue,\\r\\n            \\\"STV2: decreased allowance below zero\\\"\\r\\n        );\\r\\n        unchecked {\\r\\n            _approve(owner, _spender, currentAllowance - _subtractedValue);\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /// @dev Moves `_amount` of tokens from `_from` to `_to`.\\r\\n    ///      Emits a {Transfer} event\\r\\n    ///      Requirements:\\r\\n    ///      * `_from` cannot be the zero address and has to be whitelisted\\r\\n    ///      * `_to` cannot be the zero address and has to be whitelisted.\\r\\n    ///      * `_from` must have a balance of at least `amount`.\\r\\n    ///      Function checks limits, balance of `_from` address => see {_beforeTokenTransfer}\\r\\n    ///      Function updates DataOfLockedTokens for `_from` address => see {_afterTokenTransfer}\\r\\n    function _transfer(\\r\\n        address _from,\\r\\n        address _to,\\r\\n        uint256 _amount\\r\\n    ) internal onlyWhitelisted(_from) onlyWhitelisted(_to) {\\r\\n        require(_from != address(0), \\\"STV2: transfer from zero address\\\");\\r\\n        require(_to != address(0), \\\"STV2: transfer to zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(_from, _to, _amount);\\r\\n\\r\\n        uint256 fromBalance = _balances[_from];\\r\\n        require(\\r\\n            fromBalance >= _amount,\\r\\n            \\\"STV2: transfer amount exceeds balance\\\"\\r\\n        );\\r\\n        unchecked {\\r\\n            _balances[_from] = fromBalance - _amount;\\r\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\r\\n            // decrementing then incrementing.\\r\\n            _balances[_to] += _amount;\\r\\n        }\\r\\n\\r\\n        emit Transfer(_from, _to, _amount);\\r\\n\\r\\n        _afterTokenTransfer(_from);\\r\\n    }\\r\\n\\r\\n    /// @dev Creates `_amount` tokens and assigns them to `_account`, increasing\\r\\n    ///      the total supply.\\r\\n    ///      Emits a {Transfer} event with `from` set to the zero address.\\r\\n    ///      Requirements:\\r\\n    ///      `_account` cannot be the zero address and has to be whitelisted.\\r\\n    function _mint(\\r\\n        address _account,\\r\\n        uint256 _amount\\r\\n    ) internal onlyWhitelisted(_account) {\\r\\n        require(_account != address(0), \\\"STV2: mint to zero address\\\");\\r\\n\\r\\n        _validateToInteractSingle(_account);\\r\\n\\r\\n        _totalSupply += _amount;\\r\\n        unchecked {\\r\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\r\\n            _balances[_account] += _amount;\\r\\n        }\\r\\n        emit Transfer(address(0), _account, _amount);\\r\\n    }\\r\\n\\r\\n    /// @dev Destroys `_amount` tokens from `_account`, reducing the total supply.\\r\\n    ///      Emits a {Transfer} event with `to` set to the zero address.\\r\\n    ///      Requirements:\\r\\n    ///      * `_account` cannot be the zero address.\\r\\n    ///      * `_account` must have at least `_amount` tokens.\\r\\n    function _burn(address _account, uint256 _amount) internal {\\r\\n        require(_account != address(0), \\\"STV2: burn from zero address\\\");\\r\\n\\r\\n        uint256 accountBalance = _balances[_account];\\r\\n        require(accountBalance >= _amount, \\\"STV2: burn amount exceeds balance\\\");\\r\\n\\r\\n        unchecked {\\r\\n            _balances[_account] = accountBalance - _amount;\\r\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\r\\n            _totalSupply -= _amount;\\r\\n        }\\r\\n\\r\\n        emit Transfer(_account, address(0), _amount);\\r\\n    }\\r\\n\\r\\n    /// @dev Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\\r\\n    ///      This internal function is equivalent to `approve`, and can be used to\\r\\n    ///      e.g. set automatic allowances for certain subsystems, etc.\\r\\n    ///      Emits an {Approval} event.\\r\\n    ///      Requirements:\\r\\n    ///      *`_owner` cannot be the zero address and has to be whitelisted.\\r\\n    ///      *`_spender` cannot be the zero address and has to be whitelisted.\\r\\n    function _approve(\\r\\n        address _owner,\\r\\n        address _spender,\\r\\n        uint256 _amount\\r\\n    ) internal onlyWhitelisted(_owner) onlyWhitelisted(_spender) {\\r\\n        require(_owner != address(0), \\\"STV2: approve from zero address\\\");\\r\\n        require(_spender != address(0), \\\"STV2: approve to zero address\\\");\\r\\n\\r\\n        _validateToInteractSingle(_spender);\\r\\n\\r\\n        _allowances[_owner][_spender] = _amount;\\r\\n        emit Approval(_owner, _spender, _amount);\\r\\n    }\\r\\n\\r\\n    /// @dev Updates `_owner` s allowance for `_spender` based on spent `_amount`.\\r\\n    ///      Does not update the allowance amount in case of infinite allowance.\\r\\n    ///      Revert if not enough allowance is available.\\r\\n    ///      Might emit an {Approval} event.\\r\\n    function _spendAllowance(\\r\\n        address _owner,\\r\\n        address _spender,\\r\\n        uint256 _amount\\r\\n    ) internal {\\r\\n        uint256 currentAllowance = allowance(_owner, _spender);\\r\\n        if (currentAllowance != type(uint256).max) {\\r\\n            require(\\r\\n                currentAllowance >= _amount,\\r\\n                \\\"STV2: insufficient allowance\\\"\\r\\n            );\\r\\n            unchecked {\\r\\n                _approve(_owner, _spender, currentAllowance - _amount);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @dev This hook is called before any transfer of tokens(except minting & burning).\\r\\n    function _beforeTokenTransfer(\\r\\n        address _from,\\r\\n        address _to,\\r\\n        uint256 _amount\\r\\n    ) internal virtual;\\r\\n\\r\\n    /// @dev This hook is called after any transfer of tokens(except minting & burning).\\r\\n    function _afterTokenTransfer(address _from) internal virtual;\\r\\n\\r\\n    function _validateToInteractSingle(address _account) internal view virtual;\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/IAccessControlEnumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControlEnumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControl.sol\\\";\\n\\n/**\\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\\n */\\ninterface IAccessControlEnumerable is IAccessControl {\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControlEnumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControlEnumerable.sol\\\";\\nimport \\\"./AccessControl.sol\\\";\\nimport \\\"../utils/structs/EnumerableSet.sol\\\";\\n\\n/**\\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\\n */\\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) public view virtual override returns (address) {\\n        return _roleMembers[role].at(index);\\n    }\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) public view virtual override returns (uint256) {\\n        return _roleMembers[role].length();\\n    }\\n\\n    /**\\n     * @dev Overload {_grantRole} to track enumerable memberships\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual override {\\n        super._grantRole(role, account);\\n        _roleMembers[role].add(account);\\n    }\\n\\n    /**\\n     * @dev Overload {_revokeRole} to track enumerable memberships\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual override {\\n        super._revokeRole(role, account);\\n        _roleMembers[role].remove(account);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControl.sol\\\";\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"../utils/Strings.sol\\\";\\nimport \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```solidity\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```solidity\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\\n * to enforce additional security measures for this role.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\\n     *\\n     * Format of the revert message is described in {_checkRole}.\\n     *\\n     * _Available since v4.6._\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(account),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * May emit a {RoleGranted} event.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     *\\n     * NOTE: This function is deprecated in favor of {_grantRole}.\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"corporateTreasury_\",\"type\":\"address\"},{\"internalType\":\"address[4]\",\"name\":\"_managers\",\"type\":\"address[4]\"},{\"internalType\":\"bool\",\"name\":\"isEnabledWhitelist_\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isEnabledLockUps_\",\"type\":\"bool\"},{\"internalType\":\"bool[2]\",\"name\":\"_enableLimits\",\"type\":\"bool[2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"_defaultLimits\",\"type\":\"uint256[2]\"},{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals_\",\"type\":\"uint8\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"DeWhitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousDeployer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newDeployer\",\"type\":\"address\"}],\"name\":\"DeployershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokensOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestampToUnlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockedAmount\",\"type\":\"uint256\"}],\"name\":\"LockTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokensOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestampWhenUnlocked\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unlockedAmount\",\"type\":\"uint256\"}],\"name\":\"UnlockTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"Whitelisted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"COMPLIANCE_MANAGER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FINANCIAL_MANAGER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RECOVERY_MANAGER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_isEnabledLockUps\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_isEnabledSecondaryTradingLimit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_isEnabledTransactionCountLimit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_isEnabledWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_bundleAddresses\",\"type\":\"address[]\"}],\"name\":\"addAddressToWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_bundleFrom\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_bundleAmounts\",\"type\":\"uint256[]\"}],\"name\":\"burnBundle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"corporateTreasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultSecondaryTradingLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultTransactionCountLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getAllowedToTransfer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getAmountOfLockedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getLeftTransactionCountLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getListOfLockUps\",\"outputs\":[{\"internalType\":\"uint256[2][]\",\"name\":\"\",\"type\":\"uint256[2][]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_role\",\"type\":\"bytes32\"}],\"name\":\"getListOfRoleOwners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRoleMember\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleMemberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getUserData\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"userBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userLockedBalance\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isWhitelisted\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"leftSecondaryLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"setSecondaryLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"leftTransactions\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"setTransactionLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"transactionCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256[2][]\",\"name\":\"lockUps\",\"type\":\"uint256[2][]\"}],\"internalType\":\"struct Utils.ActualUserInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getValidationManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isWhitelistedAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_bundleTo\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_bundleAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_daysToLock\",\"type\":\"uint256\"}],\"name\":\"lockUpTokensOnAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_bundleFrom\",\"type\":\"address[]\"}],\"name\":\"redemption\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_bundleAddresses\",\"type\":\"address[]\"}],\"name\":\"removeAddressFromWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceDeployership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newTreasury\",\"type\":\"address\"}],\"name\":\"replacementOfCorporateTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accountsToReset\",\"type\":\"address[]\"}],\"name\":\"resetSecondaryTradingLimitToDefault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accountsToReset\",\"type\":\"address[]\"}],\"name\":\"resetTransactionCountLimitToDefault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"secondaryTradingLimitOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDefaultSecondaryTradingLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setDefaultTransactionCountLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_bundleAccounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_bundleNewLimits\",\"type\":\"uint256[]\"}],\"name\":\"setSecondaryTradingLimitFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_bundleAccounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_bundleNewLimits\",\"type\":\"uint256[]\"}],\"name\":\"setTransactionCountLimitFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_validationAddress\",\"type\":\"address\"}],\"name\":\"setValidationManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"toggleLockUps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"toggleSecondaryTradingLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"toggleTransactionCount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"toggleWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"transactionCountLimitOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_bundleTo\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_bundleAmounts\",\"type\":\"uint256[]\"}],\"name\":\"transferBundle\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDeployer\",\"type\":\"address\"}],\"name\":\"transferDeployership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_bundleTo\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_bundleAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_daysToLock\",\"type\":\"uint256\"}],\"name\":\"transferFromTreasuryLockedTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_bundleTo\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_bundleAmounts\",\"type\":\"uint256[]\"}],\"name\":\"transferFromTreasuryToInvestor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpauseContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"updateDataOfLockedTokensOf\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokensToWithdraw\",\"type\":\"address\"}],\"name\":\"withdrawStuckTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "STV2", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000734f6ba6445289a2c45cd846e84944132a33338000000000000000000000000b78565a3ded20c1f338234355b208dc14a5d46850000000000000000000000000734f6ba6445289a2c45cd846e84944132a333380000000000000000000000000734f6ba6445289a2c45cd846e84944132a33338000000000000000000000000b78565a3ded20c1f338234355b208dc14a5d468500000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001c00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000085541542053545632000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000955415453544b4e56320000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}