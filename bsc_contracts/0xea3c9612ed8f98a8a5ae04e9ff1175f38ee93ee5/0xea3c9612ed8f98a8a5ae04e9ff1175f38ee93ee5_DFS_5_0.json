{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// CAUTION\r\n// This version of SafeMath should only be used with Solidity 0.8 or later,\r\n// because it relies on the compiler's built in overflow checks.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n                /// @solidity memory-safe-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\nlibrary ContractUnti {\r\n  function isContract(address addr) internal view returns (bool) {\r\n    uint256 size;\r\n    assembly { size := extcodesize(addr) }\r\n    return size > 0;\r\n  }\r\n}\r\n\r\n\r\nlibrary DFS_Model {\r\n\r\n    address public constant _blackAddr = 0x0000000000000000000000000000000000000001;\r\n    uint256 public constant MAX_INT = 2**256 - 1;\r\n\r\n    // user\r\n    struct User {\r\n        address addr;\r\n        address inviterAddr;\r\n    }\r\n\r\n    // level\r\n    struct Level  {\r\n        uint256 level;     \r\n        uint256 commission;\r\n    }\r\n}\r\n\r\n\r\n\r\ninterface IDFSUser {\r\n    function bindInviter(address inviterAddr) external returns(bool);\r\n    function bindInviter(address msgAddr,address inviterAddr) external returns(bool);\r\n    function getInviterUserByAddr(address userAddr) external view returns(address);\r\n    function existUser(address userAddr) external view returns(bool);\r\n}\r\n\r\ninterface ILottery {\r\n    function swapInvest() external;\r\n}\r\n\r\n\r\ninterface ILotteryLp {\r\n    function swapLpInvest() external;\r\n}\r\n\r\n\r\ncontract BaseConfig is Ownable {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    IDFSUser private _iDFSUser;\r\n    ILotteryLp private _ilotteryLp;\r\n    ILottery private _ilottery;\r\n\r\n    bool private _isOpenSwap = true;\r\n\r\n    address[] private uniswapBuyBlackArray;\r\n    address[] private uniswapSellBlackArray;\r\n    address[] private uniswapWhiteArray;\r\n\r\n    uint256 private _deflationBalances = 3000 *10**18;\r\n\tuint256 private _holdBalances = 1 *10**18;\r\n\tuint256 private _lplottleLimit = 1 *10**18;\r\n\tuint256 private _marketLottleLimit = 1 *10**18;\r\n\r\n    uint256 private _lockTime = 30 days; \r\n    // uint256 private _lockTime = 10 minutes;\r\n    uint256 private _deleteLPFee = 99;\r\n\r\n\tuint256 private _incomeNet1 = 50;\r\n\tuint256 private _incomeNet2 = 30;\r\n\tuint256 private _incomeNet3 = 20;\r\n\r\n    address private _marketAddrReal;\r\n\taddress private _marketAddr;\r\n\taddress private _lpAddr;\r\n\r\n    IUniswapV2Pair private _uniswapV2UsdtPair;\r\n    address private _uniswapV2Pair;\r\n\r\n    constructor(IDFSUser iDFSUser) {\r\n        require(address(iDFSUser) != address(0), \"Invalid iDFSUser\");\r\n        _iDFSUser = iDFSUser;\r\n\r\n        // add whitelist\r\n        _push(0x9845d8d405263020A7FceF14334630cc8b3030e2);\r\n        _push(0xf2531CAaB848b49600Ddf4A8E76Ae6bF9d64e137);\r\n        _push(0x54119D999B8778E6C83BdbE0323075b72CCB7067);\r\n        _push(0x555d3cd428C637Bb4F44E135Fc96B5397A88fF85);\r\n        _push(0x5adb3e8bfEF493Eb1Ee21a25E6706f9c81bBEc67);\r\n        _push(0xDF6d43186848370A3C0d10768180831256C4dB27);\r\n        _push(0x60BC71125B3F9177B3a60759977935fD485EF546);\r\n        _push(0xE73F970B9caD47c62fF937CccAb3Ca55905DE61E);\r\n    }\r\n\r\n    function setIDFSUser(IDFSUser iDFSUser) private {\r\n        require(address(_iDFSUser) != address(0), \"Invalid _iDFSUser\");\r\n        _iDFSUser = iDFSUser;\r\n    }\r\n\r\n    function queryIDFSUser() public view returns(IDFSUser){\r\n       return _iDFSUser;\r\n    }\r\n\r\n    function setIsOpenSwap(bool isOpen) private {\r\n        _isOpenSwap = isOpen;\r\n    }\r\n\r\n    function queryIsOpenSwap() public view returns(bool){\r\n       return _isOpenSwap;\r\n    }\r\n\r\n    function setDeleteLPFee(uint256 _fee) private {\r\n        _deleteLPFee = _fee;\r\n    }\r\n\r\n    function queryDeleteLPFee() public view returns(uint256){\r\n       return _deleteLPFee;\r\n    }\r\n\r\n    function setLockTime(uint256 lockTime) private {\r\n        _lockTime = lockTime;\r\n    }\r\n\r\n    function queryLockTime() public view returns(uint256){\r\n       return _lockTime;\r\n    }\r\n\r\n    function setMarketAddr(address addr) private {\r\n        _marketAddr = addr;\r\n    }\r\n\r\n    function queryMarketAddr() public view returns(address){\r\n       return _marketAddr;\r\n    }\r\n\r\n    function setMarketAddrReal(address addr) private {\r\n        _marketAddrReal = addr;\r\n    }\r\n\r\n    function queryMarketAddrReal() public view returns(address){\r\n       return _marketAddrReal;\r\n    }\r\n\r\n    function setLPAddr(address addr) private {\r\n        _lpAddr = addr;\r\n    }\r\n\r\n    function queryLPAddr() public view returns(address){\r\n       return _lpAddr;\r\n    }\r\n\r\n    function seteLotteryLp(ILotteryLp ilotteryLp) private {\r\n        require(address(ilotteryLp) != address(0), \"Invalid ilotteryLp\");\r\n        _ilotteryLp = ilotteryLp;\r\n    }\r\n\r\n    function queryeLotteryLp() public view returns(ILotteryLp){\r\n       return _ilotteryLp;\r\n    }\r\n\r\n    function seteLottery(ILottery ilottery) private {\r\n        require(address(ilottery) != address(0), \"Invalid ilottery\");\r\n        _ilottery = ilottery;\r\n    }\r\n\r\n    function queryeLottery() public view returns(ILottery){\r\n       return _ilottery;\r\n    }\r\n\r\n    function seteDeflationBalances(uint256 deflationBalances) private {\r\n        _deflationBalances = deflationBalances;\r\n    }\r\n\r\n    function queryeDeflationBalances() public view returns(uint256){\r\n       return _deflationBalances;\r\n    }\r\n\r\n    function seteHoldBalances(uint256 holdBalances) private {\r\n        _holdBalances = holdBalances;\r\n    }\r\n\r\n    function queryeHoldBalances() public view returns(uint256){\r\n       return _holdBalances;\r\n    }\r\n    function seteLplottleLimit(uint256 lplottleLimit) private {\r\n        _lplottleLimit = lplottleLimit;\r\n    }\r\n\r\n    function queryeLplottleLimit() public view returns(uint256){\r\n       return _lplottleLimit;\r\n    }\r\n\r\n    function seteMarketLottleLimit(uint256 marketLottleLimit) private {\r\n        _marketLottleLimit = marketLottleLimit;\r\n    }\r\n\r\n    function queryeMarketLottleLimit() public view returns(uint256){\r\n       return _marketLottleLimit;\r\n    }\r\n\r\n    function seteIncomeNet1(uint256 incomeNet1) private {\r\n        _incomeNet1 = incomeNet1;\r\n    }\r\n\r\n    function queryeIncomeNet1() public view returns(uint256){\r\n       return _incomeNet1;\r\n    }\r\n\r\n    function seteIncomeNet2(uint256 incomeNet2) private {\r\n        _incomeNet2 = incomeNet2;\r\n    }\r\n\r\n    function queryeIncomeNet2() public view returns(uint256){\r\n       return _incomeNet2;\r\n    }\r\n\r\n    function seteIncomeNet3(uint256 incomeNet3) private {\r\n        _incomeNet3 = incomeNet3;\r\n    }\r\n\r\n    function queryeIncomeNet3() public view returns(uint256){\r\n       return _incomeNet3;\r\n    }\r\n\r\n    function _getIndex(address addr,address[] memory array) public pure returns (uint){\r\n        if(addr == address(0)){\r\n            return DFS_Model.MAX_INT;\r\n        }\r\n        for(uint i = 0;i < array.length; i++){\r\n            if(addr == array[i]){\r\n                return i;\r\n            }\r\n        }\r\n        return DFS_Model.MAX_INT;\r\n    }\r\n\r\n    function _push(address addr) private returns(bool){\r\n        if(_getIndex(addr,uniswapWhiteArray) == DFS_Model.MAX_INT){\r\n            uniswapWhiteArray.push(addr);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function _remove(address addr)private returns(bool){\r\n        if(addr == address(0)){\r\n            return false;\r\n        }\r\n        uint index = _getIndex(addr,uniswapWhiteArray);\r\n        if(index >= uniswapWhiteArray.length){\r\n            return false;\r\n        }\r\n        uniswapWhiteArray[index]=uniswapWhiteArray[uniswapWhiteArray.length-1];\r\n        uniswapWhiteArray.pop();\r\n        return true;\r\n    }\r\n\r\n    function getUniswapWhiteArray() public view returns(address[] memory){\r\n        return uniswapWhiteArray;\r\n    }\r\n\r\n    function _pushBuy(address addr) private returns(bool){\r\n        if(_getIndex(addr,uniswapBuyBlackArray) == DFS_Model.MAX_INT){\r\n            uniswapBuyBlackArray.push(addr);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function _removeBuy(address addr)private returns(bool){\r\n        if(addr == address(0)){\r\n            return false;\r\n        }\r\n        uint index = _getIndex(addr,uniswapBuyBlackArray);\r\n        if(index >= uniswapBuyBlackArray.length){\r\n            return false;\r\n        }\r\n        uniswapBuyBlackArray[index]=uniswapBuyBlackArray[uniswapBuyBlackArray.length-1];\r\n        uniswapBuyBlackArray.pop();\r\n        return true;\r\n    }\r\n\r\n    function getUniswapBuyBlackArray() public view returns(address[] memory){\r\n        return uniswapBuyBlackArray;\r\n    }\r\n\r\n    function _pushSell(address addr) private returns(bool){\r\n        if(_getIndex(addr,uniswapSellBlackArray) == DFS_Model.MAX_INT){\r\n            uniswapSellBlackArray.push(addr);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function _removeSell(address addr)private returns(bool){\r\n        if(addr == address(0)){\r\n            return false;\r\n        }\r\n        uint index = _getIndex(addr,uniswapSellBlackArray);\r\n        if(index >= uniswapSellBlackArray.length){\r\n            return false;\r\n        }\r\n        uniswapSellBlackArray[index]=uniswapSellBlackArray[uniswapSellBlackArray.length-1];\r\n        uniswapSellBlackArray.pop();\r\n        return true;\r\n    }\r\n\r\n    function getUniswapSellBlackArray() public view returns(address[] memory){\r\n        return uniswapSellBlackArray;\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\ncontract DFS_5_0 is IERC20, Ownable {\r\n\tusing SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    BaseConfig private _baseConfig;\r\n    address private tokenHiveAddr = 0x3C7d3939fd3A2E0fF6316B07A5D0549B1F37A0bb;\r\n\tmapping(address => uint256) private _balances;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\tuint256 private constant _allBalances = 9000 *10**18;\r\n    string private _name = \"Future Star\";\r\n    string private _symbol = \"FST\";\r\n    uint8 private _decimals = 18;\r\n    address[] private LpList;\r\n    address[] private LpWhiteList;\r\n\r\n    uint256 private lpWhiteLockTime = 30 days;\r\n    uint256 private lpWhiteLockStartTime = block.timestamp;\r\n    mapping(uint256 => DFS_Model.Level) private levelMap;\r\n\r\n    mapping(address => uint256) private userAddLPTime;\r\n    uint256 private _liqBuyNetIncome = 3;\r\n\tuint256 private constant _liqBuyMarketing = 1;\r\n\tuint256 private constant _liqSellLP = 2;\r\n\tuint256 private _liqSellBlack = 1;\r\n\tuint256 private constant _liqSellMarket = 1;\r\n\t\r\n    IERC20 public constant usdt = IERC20(0x55d398326f99059fF775485246999027B3197955);\r\n    address private _uniswapV2Pair;\r\n\tIUniswapV2Pair private _uniswapV2UsdtPair;\r\n\tmapping(address => bool) private _isSetUniswapV2UsdtPair;\r\n    \r\n\t//to recieve ETH from uniswapV2Router when swaping\r\n    receive() external payable {}\r\n\r\n\tconstructor(BaseConfig baseConfig) {\r\n        require(address(baseConfig) != address(0), \"Invalid baseConfig\");\r\n        _baseConfig = baseConfig;\r\n        _balances[tokenHiveAddr] = _allBalances;\r\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(\r\n            0x10ED43C718714eb63d5aA57B78B54704E256024E\r\n            // 0xD99D1c33F9fC3444f8101754aBC46c52416550D1\r\n        );\r\n        // Create a uniswap pair for this new token\r\n        _uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\r\n            .createPair(_uniswapV2Router.WETH(),address(this));\r\n        // _isSetUniswapV2UsdtPair[address(_uniswapV2Pair)] = true;\r\n\r\n        _uniswapV2UsdtPair = IUniswapV2Pair(IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this),address(usdt)));\r\n        // //exclude owner and this contract from fee\r\n        _isSetUniswapV2UsdtPair[address(_uniswapV2UsdtPair)] = true;\r\n\r\n         // \u6dfb\u52a0LP\u6c60\u5b50\u767d\u540d\u5355\r\n        _pushLpWhite(0x009a2865d92dF0fBBff291341a1F14585Bef8f76);\r\n        _pushLpWhite(0x02B98DcdA172f32fd6791b350782F318Fb1Ab923);\r\n        _pushLpWhite(0x051344214b56fc55d4b929C6ab9146B2f346d109);\r\n        _pushLpWhite(0x064DcDa0005334f13138001E3D021498a8233DA7);\r\n        _pushLpWhite(0x0aBB5c5897091C3057FD23F18625F0c7Aa533daB);\r\n        _pushLpWhite(0x0ED943Ce24BaEBf257488771759F9BF482C39706);\r\n        _pushLpWhite(0x11A92045bb167902936404d29F2dB7B9a486c5cF);\r\n        _pushLpWhite(0x12c2B208e7fdBD9b87DbEad65A445649e686B1A5);\r\n        _pushLpWhite(0x142Eb51629Af20Fa411904E8d8Af9746993b5697);\r\n        _pushLpWhite(0x16d4e5d3ebbb64c7Bf8234DD705CbC2a2a97c94A);\r\n        _pushLpWhite(0x199F4bC22E7A987d47b108Eaeb635AABC1453FA4);\r\n        _pushLpWhite(0x1A953D448a8d27e5F7B14B7ccc2600097B50ddB8);\r\n        _pushLpWhite(0x1B2Aba7BcF03c39d679A940a8C8d3B5c3f507222);\r\n        _pushLpWhite(0x1b5B7F98dBC555b4F79ac0705490C1a3Da9B130D);\r\n        _pushLpWhite(0x1B775e6AB004706FfB02293e4E3C06f29a8Ad01C);\r\n        _pushLpWhite(0x1C2c390ac9469De70d2A543A92fBEFa1A4d0E256);\r\n        _pushLpWhite(0x1C3586a44D7b12e2c9f74FEc4afcD93f0e3C1F2D);\r\n        _pushLpWhite(0x1e8Cd6f0c43f0dee4B0e049F114d2e8455eC3DbD);\r\n        _pushLpWhite(0x1f5222987f5f66ceff8B26C64c0b606d16813936);\r\n        _pushLpWhite(0x20C0806Da61460ddE497944E05995AaB668F6b4D);\r\n        _pushLpWhite(0x21d177842A17F323ca6bFeA46ce9C42cDFc587DE);\r\n        _pushLpWhite(0x226188136bffE0ED10F1e42f2e2129908B17588b);\r\n        _pushLpWhite(0x22dCb0bbBa2DE54549776f4D8deF536Fa1c0Dd5F);\r\n        _pushLpWhite(0x233b3e8a182C856bb7e11768ab7FDb3BFf160AD1);\r\n        _pushLpWhite(0x236E49c4CA680840D6855aBFFadC757B34547A39);\r\n        _pushLpWhite(0x250C5B3d6b5131627C4d9280BF65ec55f83B08A0);\r\n        _pushLpWhite(0x2613090e43f107FC069347CfDAE27dF4D7720Ed6);\r\n        _pushLpWhite(0x28a032F1FbfA9dC90bb351a441F9a142667e9428);\r\n        _pushLpWhite(0x28Ea72bDE0E717F7810EFE4A9545Ec0Fd38675cE);\r\n        _pushLpWhite(0x2Af33dbb7c36C5286bB39ccA941E495F0647aae2);\r\n        _pushLpWhite(0x2C90779c1954d3dEaa0E8d221F216E97e2e033C3);\r\n        _pushLpWhite(0x2fD2D67ed2E28D78EAa66c0B229044c396e7e624);\r\n        _pushLpWhite(0x30E4b9b5d21d439340DA3CB1BcD9c0E4cCfC37D5);\r\n        _pushLpWhite(0x314Fa0e1a0c5d39c37fC43c07CCC1608d082cd5e);\r\n        _pushLpWhite(0x3160e01428F4500dd6EaFA2bd8208E1BB51526c5);\r\n        _pushLpWhite(0x32027DC582DA8d1571A33A2A091D7324C27a371B);\r\n        _pushLpWhite(0x3Da9bB4627eE40B4eFa99e7B21347bc99A291C7B);\r\n        _pushLpWhite(0x3e259600FFed5ceCB1b5E3B2270F5EA3BBBB6e6f);\r\n        _pushLpWhite(0x3E5c134F8C51dbF11174AF4fF60dBc2E88DB64F2);\r\n        _pushLpWhite(0x3E8d42C7241d2c94b0AF7C35D9C2A4A58663016F);\r\n        _pushLpWhite(0x405669fD33C751D108c647217Dc360894dDC51CD);\r\n        _pushLpWhite(0x4250fb6E42c5464e84954c30Dc54C3bCc3dAB1D2);\r\n        _pushLpWhite(0x4579ca567149643dd6AE1Bec302cEbA2491c7699);\r\n        _pushLpWhite(0x494DC21178Aa44B147e38915292e7b122e7b5438);\r\n        _pushLpWhite(0x505f75085593C1c16F9dEB28E4D4E794eE42ab07);\r\n        _pushLpWhite(0x52eA01e9347a99A3dba304e802DB22f828dA1282);\r\n        _pushLpWhite(0x54111EE8b3762c4fD17C46317EAdB73C3Faae259);\r\n        _pushLpWhite(0x547A1FaE80bc8c8785A88c6E17914De5b168B590);\r\n        _pushLpWhite(0x5569b5FE0A5e51892aDFC42b58c707D970D28965);\r\n        _pushLpWhite(0x56e8cD6ae873665389d3c702B9002aA615f107C2);\r\n        _pushLpWhite(0x594F47bB4E5DB127068d90A93bd593991be5907d);\r\n        _pushLpWhite(0x5BBaA66e05c3BeCb059Bb685C6B87780B33A8062);\r\n        _pushLpWhite(0x5Deb9E2757438d99Aeabb6Ad3c769Da779Fa8e8d);\r\n        _pushLpWhite(0x5fBA4565e891eA8194F60E32F4e27eB9bF9b93De);\r\n        _pushLpWhite(0x61866347a67B434579a4CCf09EC6Df98d0b3947b);\r\n        _pushLpWhite(0x618Cf9702339a5058860f74720Bdd973AB85aB74);\r\n        _pushLpWhite(0x667d187E4D510119cFa1DB3f6CB4bcFC303c0240);\r\n        _pushLpWhite(0x699b67f6Af80AeA2594313DaAd34c1dA1d0951B1);\r\n        _pushLpWhite(0x6a4b9CC9BeA88D96793c0C160101c7014C449CAf);\r\n        _pushLpWhite(0x6c020c8900139F116e6c4cDAa6FC0d2Cb855cd5E);\r\n        _pushLpWhite(0x6d49014177BECEF754824646499AE847Fa7a6C44);\r\n        _pushLpWhite(0x6d57B7E38af2f349e07318f805b6da14DA6b3EDd);\r\n        _pushLpWhite(0x6e31b70566cBa630eF6B9FCc3ef7a3B45f32512e);\r\n        _pushLpWhite(0x6Ffd215488392d07329DC663ddC4AA82c80E2f8B);\r\n        _pushLpWhite(0x70C78075aa3FCd06baBa458a416CDe2b4E0f3537);\r\n        _pushLpWhite(0x730b454c08b1bE8B059771ba9b9181170F47d9e2);\r\n        _pushLpWhite(0x75CB5292f7b01A9eA0692e4e31dAAb1A4B4f4FBc);\r\n        _pushLpWhite(0x75cE88Bd0dCD60C94Bc062d7dB4A5482168B3EfF);\r\n        _pushLpWhite(0x761e0b95d08D1Cb96B609540908122733BcfCD80);\r\n        _pushLpWhite(0x763aF7205c1BCFeFb8eF6Db2E1cFFf450DFbeac7);\r\n        _pushLpWhite(0x778f323a807dD8d65a8BD734abC1A58939fe2933);\r\n        _pushLpWhite(0x7a27E908D76c5cE6bC43c6579A50806390F1Eb8b);\r\n        _pushLpWhite(0x7A2bD635804bFe7e6D7a3a826C1896F9794d0473);\r\n        _pushLpWhite(0x7aA93A7956623e8b4C590926B3cd32e81D79A7B4);\r\n        _pushLpWhite(0x7b1b285D2304eDe3669994D39ee1e00617645042);\r\n        _pushLpWhite(0x7bF3C5f4D9dD2b68fB29dABA8650e2971106aFCc);\r\n        _pushLpWhite(0x7c7c96ef10057f1fBc84b44bb8606d409Cc50B99);\r\n        _pushLpWhite(0x7fa3D0826961B3c016e991936a3ECB6f6179bcc9);\r\n        _pushLpWhite(0x7fcE8Bbd899b4b4Cc3B09684ed65be394bB0C66A);\r\n        _pushLpWhite(0x7FDef6C013719C725865A45E4E72C5212D118559);\r\n        _pushLpWhite(0x81bE525CAEc67A8ef9316972193657bF23C84A89);\r\n        _pushLpWhite(0x85728f88212eFA25040CE43C61211b6450d4c3cc);\r\n        _pushLpWhite(0x85F839DDF58586388a922e56ECf5876D04AC21B9);\r\n        _pushLpWhite(0x8710486265e83e21e85e507FbB54A8240aD8e08e);\r\n        _pushLpWhite(0x8838D2687d8B69D5aa907692F13B6426aA2908f3);\r\n        _pushLpWhite(0x8a2Cd2ACa0D996146D4334516e8EA7D65Aaf9067);\r\n        _pushLpWhite(0x8A49F2DA43C8d649942604668046b1796a041456);\r\n        _pushLpWhite(0x8b3334C565DF9986b29eef03AB59F795BE2EC2B9);\r\n        _pushLpWhite(0x8B948832264EFb89f68a652704a498024dc16De2);\r\n        _pushLpWhite(0x8Ce214C5F39EF9D8d3ff5E0a8cf5f63d17d51Ee2);\r\n        _pushLpWhite(0x8E04335c7fC519D8958B2A4133fd4a46ef296013);\r\n        _pushLpWhite(0x8ec2bf9620EB31A3A952Eb22d84Ea5e8bb1046D6);\r\n        _pushLpWhite(0x8fa54aEeB7ad66bA4Aad13D5D08D102a5Cd3c278);\r\n        _pushLpWhite(0x9202c261d497fB7019D76D09F17488D71475c7aF);\r\n        _pushLpWhite(0x946Dc958188E578469F11dAdEDc993A3Ff2eBe34);\r\n        _pushLpWhite(0x9A1Bc9980dE6863251D91492C6658a6Be295E19E);\r\n        _pushLpWhite(0x9baC921Ceb43aB076cD0dB531F60a8E44d7e2488);\r\n        _pushLpWhite(0x9c306D44a13b01704903D57B3884842BCA90693a);\r\n        _pushLpWhite(0x9D1b188e9d809d394Ed27D5296D8A6632c8fed41);\r\n        _pushLpWhite(0xA3D07478250316FE9aCA889dC63b23ce4c09Cb74);\r\n        _pushLpWhite(0xA5F54C8a302c89AE4dD8031087e9857b3d9bba95);\r\n        _pushLpWhite(0xa897705E5e513deB20b5CF784F2040f02Fb7AE2f);\r\n        _pushLpWhite(0xAB4d0c86eddbfC650568067eE33e74CCA09728F6);\r\n        _pushLpWhite(0xaBb7Cb04A6DD9Ec4744B9980181A604d1161C5B9);\r\n        _pushLpWhite(0xADb4dE8B676FE547b092C6EAb1c213DF14DB6166);\r\n        _pushLpWhite(0xb28374498399e6bD48100f712B8832a5AE56403f);\r\n        _pushLpWhite(0xB341a52cd77b3762140A25E29aA115B982DbFD1c);\r\n        _pushLpWhite(0xb461383961967A1be05EC5c0C67fF5c0a344d4bA);\r\n        _pushLpWhite(0xb473083Ab81b156B3C021A8003c6CA109349d108);\r\n        _pushLpWhite(0xb51737f5375523d84ceB5348aAf5B0e1E4D773A3);\r\n        _pushLpWhite(0xb74E5C66Aadc0f55136DdE0c86142D7e18FCE5fA);\r\n        _pushLpWhite(0xb882D58cdaE11bB3f98cC474125D7820e97e1A2E);\r\n        _pushLpWhite(0xB986bd054ea17226051a572fc4DAB334d12631B6);\r\n        _pushLpWhite(0xbD5bA96D7e4e9D702c4915713b298182bB3358F2);\r\n        _pushLpWhite(0xBf20Be5586443F56DF6F25837EbCb3cEADAB7e95);\r\n        _pushLpWhite(0xbFA30EF1E1554f7c7cf50F4bDD4b7b5174191E97);\r\n        _pushLpWhite(0xC1fc1cB07A10967C18cA6588F8E4Ae86Ed1361e7);\r\n        _pushLpWhite(0xc54aBce2ec67e4c189a9de97d12bC09fb9f1832C);\r\n        _pushLpWhite(0xc7808C37Fb7e4eCe5136560B3711F97d8e5a8C59);\r\n        _pushLpWhite(0xC89871c4120271e10B384e12A3838be08b8524DF);\r\n        _pushLpWhite(0xcB4A7436a5d49be2479207013cA944e7bec2243F);\r\n        _pushLpWhite(0xCe3408a9570c42759c43352F4D1E2FE09Fb256CC);\r\n        _pushLpWhite(0xd03979962D295f634E17eCF9338020aff6Fbd16f);\r\n        _pushLpWhite(0xd26f18318450ba873954593d82B4387aEfeb47C8);\r\n        _pushLpWhite(0xD488862F3DBD0ECe17266f0e49d68B7B09a72a56);\r\n        _pushLpWhite(0xd7bEAE44D17441dCFda3D589F12A93fF33D745CF);\r\n        _pushLpWhite(0xD8240328773db413d14179eEf78427EE0E42af25);\r\n        _pushLpWhite(0xd92a963473190bCe0F4d32d9938CDC4f7923097F);\r\n        _pushLpWhite(0xd93E52B799F45F15dfF15F64e25794e89CF140e7);\r\n        _pushLpWhite(0xDC44f8eD799D8c6c586B4e05bFb55660D8FA2bC5);\r\n        _pushLpWhite(0xdDd9865d7CE60C867ab476dB5b2BcbD79396A6F4);\r\n        _pushLpWhite(0xde62cEDA0aA0EF462ca57d323F2CaBc039A1A428);\r\n        _pushLpWhite(0xe143E74e43239B7a295457B47A269DF0ed1FD063);\r\n        _pushLpWhite(0xE206e8ac5c75C011d2e3D10BE40078FF88Abc54C);\r\n        _pushLpWhite(0xE66640534808Ee35414649dc128460Cbda17EdEA);\r\n        _pushLpWhite(0xe9a79928e961E3669CaF6b99abC92E6723839808);\r\n        _pushLpWhite(0xeABd88b0fC5A2659De32Ccee82a43810eD3B89f6);\r\n        _pushLpWhite(0xec2329BF2f196bCD56DdD1f5D696A542C4AAbF96);\r\n        _pushLpWhite(0xEC72581CeD704b0cC32e09d0DD022e77323379D8);\r\n        _pushLpWhite(0xEC8d4eC689caC3E507A82489155DD3dd47Aa0A33);\r\n        _pushLpWhite(0xED97828b7073Fb9D6C3a16975A3c7c082760D06E);\r\n        _pushLpWhite(0xEE86EF16aA16A2c2E8223E39E3C00aA09872ebD6);\r\n        _pushLpWhite(0xf10b24802EB89Beb3B75d2718b924a2Be33e10Bb);\r\n        _pushLpWhite(0xf191F73B3b875a29fcd3d7F3fCed82363c642d57);\r\n        _pushLpWhite(0xF2F84f3a3d0E466b4F1c805f9EBE9f9253A340e7);\r\n        _pushLpWhite(0xF34162cD76053eca03d8eEDcb22d06AFe25FFb63);\r\n        _pushLpWhite(0xfC7CB9464e80E5bA75e95e1A1E861Abce33fB8E3);\r\n        _pushLpWhite(0x53EE22e89F28746109Dc3EdA1a1e518296Fff737);\r\n        _pushLpWhite(0xac775656550B42c3C5aF61CB08F71E870aeE2ADA);\r\n\r\n        levelMap[0] = DFS_Model.Level({\r\n            level: 0,\r\n            commission: _baseConfig.queryeIncomeNet1()\r\n        });\r\n        levelMap[1] = DFS_Model.Level({\r\n            level: 1,\r\n            commission: _baseConfig.queryeIncomeNet2()\r\n        });\r\n        levelMap[2] = DFS_Model.Level({\r\n            level: 2,\r\n            commission: _baseConfig.queryeIncomeNet3()\r\n        });\r\n\r\n        emit Transfer(address(0), tokenHiveAddr, _allBalances);\r\n    }\r\n\t\r\n\tfunction name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns (uint256) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public pure override returns (uint256) {\r\n        return _allBalances;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(\r\n            sender,\r\n            msg.sender,\r\n            _allowances[sender][msg.sender].sub(\r\n                amount,\r\n                \"ERC20: transfer amount exceeds allowance\"\r\n            )\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue)\r\n        public\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        _approve(\r\n            msg.sender,\r\n            spender,\r\n            _allowances[msg.sender][spender].add(addedValue)\r\n        );\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue)\r\n        public\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        _approve(\r\n            msg.sender,\r\n            spender,\r\n            _allowances[msg.sender][spender].sub(\r\n                subtractedValue,\r\n                \"ERC20: decreased allowance below zero\"\r\n            )\r\n        );\r\n        return true;\r\n    }\r\n\t\r\n\tfunction _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) private {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\t\r\n\tfunction _takeLiquidity(address fromAddress,address toAddress,uint256 tLiquidityFee ,uint256 amount,uint8 tpl ) private {\r\n        if(tpl == 1 ){\r\n            // sell\r\n            uint256 _liqSellLPFee = calcRatio(amount,_liqSellLP);\r\n            _balances[_baseConfig.queryLPAddr()] = _balances[_baseConfig.queryLPAddr()].add(_liqSellLPFee);\r\n            emit Transfer(fromAddress, _baseConfig.queryLPAddr(), _liqSellLPFee);\r\n\r\n            uint256 _liqSellMarketFee = calcRatio(amount,_liqSellMarket);\r\n            _balances[_baseConfig.queryMarketAddr()] = _balances[_baseConfig.queryMarketAddr()].add(_liqSellMarketFee);\r\n            emit Transfer(fromAddress, _baseConfig.queryMarketAddr(), _liqSellMarketFee);\r\n\r\n            if(tLiquidityFee == 4 && _liqSellBlack > 0){\r\n                uint256 _liqSellBlackFee = calcRatio(amount,_liqSellBlack);\r\n                _balances[DFS_Model._blackAddr] = _balances[DFS_Model._blackAddr].add(_liqSellBlackFee);\r\n                emit Transfer(fromAddress, DFS_Model._blackAddr, _liqSellBlackFee);\r\n            }\r\n        }else if(tpl == 2) {\r\n            // buy\r\n            uint256 _liqBuyMarketingFee = calcRatio(amount,_liqBuyMarketing);\r\n            _balances[_baseConfig.queryMarketAddr()] = _balances[_baseConfig.queryMarketAddr()].add(_liqBuyMarketingFee);\r\n            emit Transfer(fromAddress, _baseConfig.queryMarketAddr(), _liqBuyMarketingFee);\r\n\r\n            if(tLiquidityFee == 4 && _liqBuyNetIncome > 0){\r\n                uint256 _liqBuyNetIncomeFee = calcRatio(amount,_liqBuyNetIncome);\r\n                bool isBindFrom = _baseConfig.queryIDFSUser().existUser(toAddress);\r\n                if(!isBindFrom){\r\n                    _balances[DFS_Model._blackAddr] = _balances[DFS_Model._blackAddr].add(_liqBuyNetIncomeFee);\r\n                    emit Transfer(fromAddress, DFS_Model._blackAddr, _liqBuyNetIncomeFee);\r\n                }else{\r\n                    address curAddr = toAddress;\r\n                    uint256 _liqBuyNetIncomeFeeAll =0;\r\n                    for(uint  i = 0; i < 3 ; i++){\r\n                        address inviterAddr = _baseConfig.queryIDFSUser().getInviterUserByAddr(curAddr);\r\n                        if(inviterAddr == address(0)){\r\n                            break;\r\n                        }\r\n                        uint256 customTokenBalance = _balances[inviterAddr];\r\n                        if(customTokenBalance >= _baseConfig.queryeHoldBalances()){\r\n                            uint256 _liqBuyNetIncomeFeeTmp = calcRatio(_liqBuyNetIncomeFee,levelMap[i].commission);\r\n                            _balances[inviterAddr] = _balances[inviterAddr].add(_liqBuyNetIncomeFeeTmp);\r\n                            _liqBuyNetIncomeFeeAll = _liqBuyNetIncomeFeeAll.add(_liqBuyNetIncomeFeeTmp);\r\n                            emit Transfer(fromAddress, inviterAddr, _liqBuyNetIncomeFeeTmp);\r\n                        }\r\n                        curAddr = inviterAddr;\r\n                    }\r\n                    if(_liqBuyNetIncomeFeeAll == 0){\r\n                        _balances[DFS_Model._blackAddr] = _balances[DFS_Model._blackAddr].add(_liqBuyNetIncomeFee);\r\n                        emit Transfer(fromAddress, DFS_Model._blackAddr, _liqBuyNetIncomeFee);\r\n                    }else{\r\n                        if(_liqBuyNetIncomeFee.sub(_liqBuyNetIncomeFeeAll) > 0){\r\n                            _balances[DFS_Model._blackAddr] = _balances[DFS_Model._blackAddr].add(_liqBuyNetIncomeFee.sub(_liqBuyNetIncomeFeeAll));\r\n                            emit Transfer(fromAddress, DFS_Model._blackAddr, _liqBuyNetIncomeFee.sub(_liqBuyNetIncomeFeeAll));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\t\r\n\tfunction calcRatio(uint256 amount,uint256 liquidityFee)\r\n        private\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return amount.mul(liquidityFee).div(10**2);\r\n    }\r\n\r\n    function calcRetain(uint256 amount)\r\n        private\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return amount.mul(1).div(10**4);\r\n    }\r\n\t\r\n\tfunction _getValues(uint256 tAmount,uint256 _liquidityFee)\r\n        private\r\n        pure\r\n        returns (\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        uint256 tLiquidity = calcRatio(tAmount,_liquidityFee);\r\n        uint256 tTransferAmount = tAmount.sub(tLiquidity);\r\n        return (tTransferAmount, tLiquidity);\r\n    }\r\n\t\r\n\tfunction _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) private {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n        require(amount > 0, \"Transfer amount must be greater than zero\");\r\n\r\n        // The entire network is deflated to 3,000, buy 3% of the network income, sell 1% of the black hole destruction, return to zero\r\n        uint256 blackAddrBanlance = balanceOf(DFS_Model._blackAddr);\r\n        if( (blackAddrBanlance >= _allBalances.sub(_baseConfig.queryeDeflationBalances())) && _liqBuyNetIncome != 0 ){\r\n            _liqBuyNetIncome = 0;\r\n            _liqSellBlack = 0;\r\n        }\r\n\r\n\t\tbool isAdd = false;\r\n        bool isDel = false;\r\n        uint8 tpl = 10;\r\n        uint256 tLiquidityFee = 0 ;\r\n\t\tif(to == address(_uniswapV2UsdtPair)) \r\n\t\t{\r\n            tpl = 0;\r\n            (isAdd,) = getLPStatus(from,to);\r\n            if(!isAdd){\r\n                require(_baseConfig.queryIsOpenSwap(), \"Whether to open the main switch for buying and selling\"); \r\n                require(_baseConfig._getIndex(from,_baseConfig.getUniswapBuyBlackArray()) == DFS_Model.MAX_INT, \"Sell blacklist\");\r\n                if(_baseConfig._getIndex(from,_baseConfig.getUniswapWhiteArray()) == DFS_Model.MAX_INT){\r\n                    tpl = 1;\r\n                    tLiquidityFee = _liqSellLP.add(_liqSellBlack).add(_liqSellMarket);\r\n                    // One ten-thousandth is automatically reserved when selling coins\r\n                    amount = amount.sub(calcRetain(amount));\r\n                }\r\n            }else{\r\n                _push(from);\r\n                userAddLPTime[from] = block.timestamp;\r\n            }\r\n\t\t}\r\n        bool isLPLocking = false;\r\n        if(from == address(_uniswapV2UsdtPair)) \r\n\t\t{\r\n            tpl = 0;\r\n            (,isDel) = getLPStatus(from,to);\r\n            if(!isDel){\r\n                require(_baseConfig.queryIsOpenSwap(), \"Whether to open the main switch for buying and selling\"); \r\n                require(_baseConfig._getIndex(to,_baseConfig.getUniswapBuyBlackArray()) == DFS_Model.MAX_INT, \"Buy blacklist\");\r\n                if(_baseConfig._getIndex(to,_baseConfig.getUniswapWhiteArray()) == DFS_Model.MAX_INT){\r\n                    tpl = 2;\r\n                    tLiquidityFee = _liqBuyNetIncome.add(_liqBuyMarketing);\r\n                }\r\n            }else{\r\n                // _remove(to);\r\n                //uint256 userTime = userAddLPTime[to];\r\n                // userAddLPTime[to] = 0;\r\n                //isLPLocking = userTime.add(_baseConfig.queryLockTime()) >= block.timestamp;\r\n                // bool isLpWhiteList = _getIndex(to,LpWhiteList) != DFS_Model.MAX_INT;\r\n                // bool isLpList = _getIndex(to,LpList) != DFS_Model.MAX_INT;\r\n                bool isLPDel = false;\r\n                if(_getIndex(to,LpList) != DFS_Model.MAX_INT){\r\n                    isLPDel = true;\r\n                    if( _uniswapV2UsdtPair.balanceOf(to) == amount){\r\n                        _remove(to);\r\n                        userAddLPTime[to] = 0;\r\n                    }\r\n                    uint256 userTime = userAddLPTime[to];\r\n                    // userAddLPTime[to] = 0;\r\n                    isLPLocking = userTime.add(_baseConfig.queryLockTime()) >= block.timestamp;\r\n                }else if(_getIndex(to,LpWhiteList) != DFS_Model.MAX_INT){\r\n                    isLPDel = true;\r\n                    isLPLocking = lpWhiteLockTime.add(lpWhiteLockStartTime) >= block.timestamp;\r\n                }\r\n                require(isLPDel, \"No permission to withdraw LP\"); \r\n            }\r\n\t\t}\r\n        \r\n        // Automatic binding relationship\r\n        if(_baseConfig.queryIDFSUser().existUser(from) && (!_baseConfig.queryIDFSUser().existUser(to)) && (!ContractUnti.isContract(to)) && tpl == 10 ){\r\n            _baseConfig.queryIDFSUser().bindInviter(to,from);\r\n        }\r\n\r\n        // transfer amount, liquidity fee\r\n        if(!isLPLocking){\r\n            _tokenTransfer(from, to, amount, tLiquidityFee,tpl);\r\n        }else{\r\n            _tokenTransfer(from, to, amount);\r\n        }\r\n\r\n        if(tpl == 10){\r\n            _swap();\r\n        }\r\n        \r\n    }\r\n\t\r\n    function _tokenTransfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount,\r\n\t\tuint256 tLiquidityFee,\r\n        uint8 tpl\r\n    ) private {\r\n        (\r\n            uint256 tTransferAmount,\r\n            uint256 tLiquidity\r\n        ) = _getValues(amount,tLiquidityFee);\r\n        _balances[sender] = _balances[sender].sub(amount);\r\n        _balances[recipient] = _balances[recipient].add(tTransferAmount);\r\n\r\n        if (tLiquidity > 0) _takeLiquidity(sender,recipient,tLiquidityFee,amount,tpl);\r\n        emit Transfer(sender, recipient, tTransferAmount);\r\n    }\r\n\r\n    function _tokenTransfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) private {\r\n        (\r\n            uint256 tTransferAmount,\r\n            uint256 tFee\r\n        ) = _getValues(amount,_baseConfig.queryDeleteLPFee());\r\n\r\n        _balances[sender] = _balances[sender].sub(amount);\r\n        _balances[recipient] = _balances[recipient].add(tTransferAmount);\r\n        emit Transfer(sender, recipient, tTransferAmount);\r\n\r\n        _balances[_baseConfig.queryMarketAddrReal()] = _balances[_baseConfig.queryMarketAddrReal()].add(tFee);\r\n        emit Transfer(sender, _baseConfig.queryMarketAddrReal(), tFee);\r\n    }\r\n\r\n    function _swap() private {\r\n        // When the LP pool reaches the specified number, it will start to distribute dividends\r\n        if(balanceOf(_baseConfig.queryLPAddr()) >= _baseConfig.queryeLplottleLimit() && address(_baseConfig.queryeLotteryLp()) != address(0)){\r\n            _baseConfig.queryeLotteryLp().swapLpInvest();\r\n        }\r\n        // The marketing management pool reaches the specified number and starts to distribute dividends\r\n        if(balanceOf(_baseConfig.queryMarketAddr()) >= _baseConfig.queryeMarketLottleLimit() && address(_baseConfig.queryeLottery()) != address(0)){\r\n            _baseConfig.queryeLottery().swapInvest();\r\n        }\r\n    }\r\n\r\n    function getLPStatus(address from,address to) internal view  returns (bool isAdd,bool isDel){\r\n        IUniswapV2Pair pair;\r\n        address token = address(this);\r\n        if(_isSetUniswapV2UsdtPair[to]){\r\n            pair = IUniswapV2Pair(to);\r\n        }else{\r\n            pair = IUniswapV2Pair(from);\r\n        }\r\n        isAdd = false;\r\n        isDel = false;\r\n        address token0 = pair.token0();\r\n        address token1 = pair.token1();\r\n        (uint r0,uint r1,) = pair.getReserves();\r\n        uint bal1 = IERC20(token1).balanceOf(address(pair));\r\n        uint bal0 = IERC20(token0).balanceOf(address(pair));\r\n        if (_isSetUniswapV2UsdtPair[to]) {\r\n            if (token0 == token) {\r\n                if (bal1 > r1) {\r\n                    uint change1 = bal1 - r1;\r\n                    isAdd = change1 > 1000;\r\n                }\r\n            } else {\r\n                if (bal0 > r0) {\r\n                    uint change0 = bal0 - r0;\r\n                    isAdd = change0 > 1000;\r\n                }\r\n            }\r\n        }else {\r\n            if (token0 == token) {\r\n                if (bal1 < r1 && r1 > 0) {\r\n                    uint change1 = r1 - bal1;\r\n                    isDel = change1 > 0;\r\n                }\r\n            } else {\r\n                if (bal0 < r0 && r0 > 0) {\r\n                    uint change0 = r0 - bal0;\r\n                    isDel = change0 > 0;\r\n                }\r\n            }\r\n        }\r\n        return (isAdd,isDel);\r\n    }\r\n\r\n    function queryLiqBuyNetIncome() public view onlyOwner returns(uint256){\r\n       return _liqBuyNetIncome;\r\n    }\r\n\r\n    function queryLiqSellBlack() public view onlyOwner returns(uint256){\r\n       return _liqSellBlack;\r\n    }\r\n\r\n    function queryeUserAddLPTime(address addr) public view returns(uint256){\r\n       return userAddLPTime[addr];\r\n    }\r\n\r\n    function seteUserAddLPTime(address addr,uint256 _time) public onlyOwner{\r\n        require(addr != address(0), \"Invalid addr\");\r\n        userAddLPTime[addr] = _time;\r\n    }\r\n\r\n    function queryUniswapV2Pair() public view onlyOwner returns(address){\r\n       return _uniswapV2Pair;\r\n    }\r\n\r\n    function queryUniswapV2USDTPair() public view returns(IUniswapV2Pair){\r\n       return _uniswapV2UsdtPair;\r\n    }\r\n\r\n    function queryeBaseConfig() public view returns(BaseConfig){\r\n       return _baseConfig;\r\n    }\r\n\r\n    function seteBaseConfig(BaseConfig baseConfig) public onlyOwner{\r\n        require(address(baseConfig) != address(0), \"Invalid baseConfig\");\r\n        _baseConfig = baseConfig;\r\n    }\r\n\r\n\r\n    function _getIndex(address addr,address[] memory array) public pure returns (uint){\r\n        if(addr == address(0)){\r\n            return DFS_Model.MAX_INT;\r\n        }\r\n        for(uint i = 0;i < array.length; i++){\r\n            if(addr == array[i]){\r\n                return i;\r\n            }\r\n        }\r\n        return DFS_Model.MAX_INT;\r\n    }\r\n\r\n    function _push(address addr) private returns(bool){\r\n        if(_getIndex(addr,LpList) == DFS_Model.MAX_INT){\r\n            LpList.push(addr);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function push(address addr) public onlyOwner returns(bool){\r\n        return _push(addr);\r\n    }\r\n\r\n    function remove(address addr) public onlyOwner returns(bool){\r\n        return _remove(addr);\r\n    }\r\n\r\n    function _remove(address addr)private returns(bool){\r\n        if(addr == address(0)){\r\n            return false;\r\n        }\r\n        uint index = _getIndex(addr,LpList);\r\n        if(index >= LpList.length){\r\n            return false;\r\n        }\r\n        LpList[index]=LpList[LpList.length-1];\r\n        LpList.pop();\r\n        return true;\r\n    }\r\n\r\n    function getLpArray() public view returns(address[] memory){\r\n        return LpList;\r\n    }\r\n\r\n    function _pushLpWhite(address addr) private returns(bool){\r\n        if(_getIndex(addr,LpWhiteList) == DFS_Model.MAX_INT){\r\n            LpWhiteList.push(addr);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function pushLpWhite(address addr) public onlyOwner returns(bool){\r\n        return _pushLpWhite(addr);\r\n    }\r\n\r\n    function removeLpWhite(address addr) public onlyOwner returns(bool){\r\n        return _removeLpWhite(addr);\r\n    }\r\n\r\n    function _removeLpWhite(address addr)private returns(bool){\r\n        if(addr == address(0)){\r\n            return false;\r\n        }\r\n        uint index = _getIndex(addr,LpWhiteList);\r\n        if(index >= LpWhiteList.length){\r\n            return false;\r\n        }\r\n        LpWhiteList[index]=LpWhiteList[LpWhiteList.length-1];\r\n        LpWhiteList.pop();\r\n        return true;\r\n    }\r\n\r\n    function getLpWhite() public view returns(address[] memory){\r\n        return LpWhiteList;\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract BaseConfig\",\"name\":\"baseConfig\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"array\",\"type\":\"address[]\"}],\"name\":\"_getIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLpArray\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLpWhite\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"push\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"pushLpWhite\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"queryLiqBuyNetIncome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"queryLiqSellBlack\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"queryUniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"queryUniswapV2USDTPair\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"queryeBaseConfig\",\"outputs\":[{\"internalType\":\"contract BaseConfig\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"queryeUserAddLPTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"remove\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeLpWhite\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract BaseConfig\",\"name\":\"baseConfig\",\"type\":\"address\"}],\"name\":\"seteBaseConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"seteUserAddLPTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdt\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DFS_5_0", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000005207a06304e44e6565ffb0247b38c8e31c0978e5", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://dba7e66b910835e3b5ebddae1e4028d70c43fb3d71dc4707ec9679fdc15472fe"}