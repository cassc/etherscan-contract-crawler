{"SourceCode": "/********************** @2023 Wizarre, All rights reserved *********************\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMMmMMMMMMMMMMMMMNNMMMMNddNMMMMmmmmmNMMMMNddNMMMMNMMMMMMMMMMMMMMmMMMMMMMMM\r\nMMMMMMMMdysNhoossydNMmosyyMM+ddd-NhssdNMMNdsshN-ddd+MMsysomMNdyssoohNysdMMMMMMMM\r\nMMMMMMMMmss::NMMh/+o+/-ohhMMhhdm`:hNNmMMMMmMNy:.mdhhMNhho-/+o+/dMMN-:ssmMMMMMMMM\r\nMMMMMMMMNoMhyhdNNNmsoyNh/:mMMMs.oNMhoNMMMMmodMNo.yMMMd:/hNyoymNNNdhyhNoNMMMMMMMM\r\nMMMMMMMNy/:shhhhy/-syyhhy`.hho :hho-yhhhhhhy-shh: ohh.`yhhyyo./yhhhhs:/hNMMMMMMM\r\nMMMMMMMd `+://sso:`.`---/:osoo.syhh+yyyssyyyohhyo-osso:/---`.`/oss//:o  mMMMMMMM\r\nMMMMMMMd `s+s+:..``.-+yhmyddhhsmyoyosddyyddsoyoymsyhdhymhy+-.``..:+s+y  mMMMMMMM\r\nMMMMMMMd  sm`  -shhy. sMNys+ho+ssymyoodmmhooydyos+oh+yyMMo -yhhs-  `ms  mMMMMMMM\r\nMMMMMMMd `yds` `/ss+:/hddddhhodNNhdssyNMMNyssdhNNhshhddddh/:+ss/` `ydy  mMMMMMMM\r\nMMMMMMMd  ooNh/-..`````     :sdhdssddshmmhsddsydhdo-     `````..-/dNoo  mMMMMMMM\r\nMMMMMMMd `md+ymddysohs.   `odmmdoyNoNmohhoNNoNssdmmho`   .yhosyddmy+dm  mMMMMMMM\r\nMMMMMMMd `Nmh+/oyo-+o` `  syMMsM/dy/NhdyhhhN:yd+MsMNyo  ` `o+-oyo:+hmm  mMMMMMMM\r\nMMMMMMMd  -NNy+/+yy.  :../odyhohssohyhsooshshossh+hyd+/`-:  -yy+/+yNm.  mMMMMMMM\r\nMMMMMMMd -/-::yNN/   +/`so/shhssyhyy+yy++hy+hshysyhho:oo`++   +Nms::-/. mMMMMMMM\r\nMMMMMMMd oMy/MMh.   ss hMNNhs+:/++++/yhyyhy/++++::oshNhNy ys   .hMM:hM+ mMMMMMMM\r\nMMMMMMMd hMooMo    ym`oMdhymhyo/    `ooo+oo`    .shhdmyhM+`ms    oM+oMy mMMMMMMM\r\nMMMMMMMd mMsy-    yM:`Nmsdyhysys:  ` `:ys/` ` `hmMMdsshsom /My    :ysMm mMMMMMMM\r\nMMMMMMMd.MMd.    yMh :yssMNhshymNy: /``Nm .: .yNdMN/hmMddM- dMs    .mMM`mMMMMMMM\r\nMMMMMMMdoMh`    oMM- :omdoMMMMdhddm/ s.--.s /mhshMhydhhdoN/ :MM+    `dM+mMMMMMMM\r\nMMMMMMMdmh`    :MMd  /yhhh+s:ysyy+hN+`d..d`+ddhyyssNNyddss+  mMM-    `ddmMMMMMMM\r\nMMMMMMMMh`     dMMy  :hodoNoy+hysdmym-+dd/-mymhdhdyd+NNmyN-  hMMd     `hMMMMMMMM\r\nMMMMMMMM.      .sNMh- /yddyms+NMm:mmhs`Nm yMmhdssyhs+dy+o: -dMNs`      .MMMMMMMM\r\nMMMMMMMNd:       .sNNs.`sNNyhhoNMm+dh-`dd`:Moymhhdyhsdho`.sNNs.       /mMMMMMMMM\r\nMMMMMMMdhmo:`      .odm+`:sddmmsmmo/o +--+ /dymddhhmms-`+md+`      `:sNymMMMMMMM\r\nMMMMMMMd/sy:do-      `:hh/`:sdmdydm- ./  /``odmyhydo-./dy:`      -sh:yy:mMMMMMMM\r\nMMMMMMMd`m/.+shh+-      .os/`:ohdds  - // - `hMNhs-./s+.     `-+hhs/./m mMMMMMMM\r\nMMMMMMMd -.mho/-hNds:.    `-/-`.oo`    --    `oo-`-/-`   `./sdNy-/sdm`- mMMMMMMM\r\nMMMMMMMd  oMoo/.mNyooss+/-`  ``       `/:`       ``  .-/+ssoohMm.+osMo  mMMMMMMM\r\nMMMMMMMd  myssh+hN.`o++/oNmo+/-.`  `.+hddh/.`  `.-++smm+/++o`.Nhohssyd  mMMMMMMM\r\nMMMMMMMd  ++++osys-..--:/++:/yso+/:/o+-``-+o/:/+oss::++/:--..:syso++++  mMMMMMMM\r\nMMMMMMMMh/.`-+hdmoohdmmmmddhmmmy+ooh/ .ys` +hoo+ymmmhddmmmmdhoomdh+-`.+hMMMMMMMM\r\nMMMMMMMMMNmhs.`::`yhymdyoshNdsddyy. .+mNNm+` -yydhsmNhsoymdyhs /:`.sdmNMMMMMMMMM\r\nMMMMMMMMMsohh.ymhy+//+./NMNssh+::.`+dmymmymd/`.::+hosNMm/.+//+yhmy.dh+yMMMMMMMMM\r\nMMMMMMMMMNhysmMMMMMMMMh+MNhNMMMNNMdysyNMMNssydMNNMMMNhNN+dMMMMMMMMmsydNMMMMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\r\nMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*/\r\n// SPDX-License-Identifier: None\r\n\r\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.4.1\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/interfaces/IERC20.sol@v4.4.1\r\n\r\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\npragma solidity 0.8.6;\r\n\r\n// Based on StableMath from mStable\r\n// https://github.com/mstable/mStable-contracts/blob/master/contracts/shared/StableMath.sol\r\n\r\nlibrary StableMath {\r\n    /**\r\n     * @dev Scaling unit for use in specific calculations,\r\n     * where 1 * 10**18, or 1e18 represents a unit '1'\r\n     */\r\n    uint256 private constant FULL_SCALE = 1e18;\r\n\r\n    /**\r\n     * @dev Provides an interface to the scaling unit\r\n     * @return Scaling unit (1e18 or 1 * 10**18)\r\n     */\r\n    function getFullScale() internal pure returns (uint256) {\r\n        return FULL_SCALE;\r\n    }\r\n\r\n    /**\r\n     * @dev Scales a given integer to the power of the full scale.\r\n     * @param x   Simple uint256 to scale\r\n     * @return    Scaled value a to an exact number\r\n     */\r\n    function scaleInteger(uint256 x) internal pure returns (uint256) {\r\n        return x * FULL_SCALE;\r\n    }\r\n\r\n    /***************************************\r\n              PRECISE ARITHMETIC\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Multiplies two precise units, and then truncates by the full scale\r\n     * @param x     Left hand input to multiplication\r\n     * @param y     Right hand input to multiplication\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              scale unit\r\n     */\r\n    function mulTruncate(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return mulTruncateScale(x, y, FULL_SCALE);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two precise units, and then truncates by the given scale. For example,\r\n     * when calculating 90% of 10e18, (10e18 * 9e17) / 1e18 = (9e36) / 1e18 = 9e18\r\n     * @param x     Left hand input to multiplication\r\n     * @param y     Right hand input to multiplication\r\n     * @param scale Scale unit\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              scale unit\r\n     */\r\n    function mulTruncateScale(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 scale\r\n    ) internal pure returns (uint256) {\r\n        // e.g. assume scale = fullScale\r\n        // z = 10e18 * 9e17 = 9e36\r\n        // return 9e36 / 1e18 = 9e18\r\n        return (x * y) / scale;\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two precise units, and then truncates by the full scale, rounding up the result\r\n     * @param x     Left hand input to multiplication\r\n     * @param y     Right hand input to multiplication\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              scale unit, rounded up to the closest base unit.\r\n     */\r\n    function mulTruncateCeil(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        // e.g. 8e17 * 17268172638 = 138145381104e17\r\n        uint256 scaled = x * y;\r\n        // e.g. 138145381104e17 + 9.99...e17 = 138145381113.99...e17\r\n        uint256 ceil = scaled + FULL_SCALE - 1;\r\n        // e.g. 13814538111.399...e18 / 1e18 = 13814538111\r\n        return ceil / FULL_SCALE;\r\n    }\r\n\r\n    /**\r\n     * @dev Precisely divides two units, by first scaling the left hand operand. Useful\r\n     *      for finding percentage weightings, i.e. 8e18/10e18 = 80% (or 8e17)\r\n     * @param x     Left hand input to division\r\n     * @param y     Right hand input to division\r\n     * @return      Result after multiplying the left operand by the scale, and\r\n     *              executing the division on the right hand input.\r\n     */\r\n    function divPrecisely(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        // e.g. 8e18 * 1e18 = 8e36\r\n        // e.g. 8e36 / 10e18 = 8e17\r\n        return (x * FULL_SCALE) / y;\r\n    }\r\n\r\n    /***************************************\r\n                    HELPERS\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Calculates minimum of two numbers\r\n     * @param x     Left hand input\r\n     * @param y     Right hand input\r\n     * @return      Minimum of the two inputs\r\n     */\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return x > y ? y : x;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculated maximum of two numbers\r\n     * @param x     Left hand input\r\n     * @param y     Right hand input\r\n     * @return      Maximum of the two inputs\r\n     */\r\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return x > y ? x : y;\r\n    }\r\n\r\n    /**\r\n     * @dev Clamps a value to an upper bound\r\n     * @param x           Left hand input\r\n     * @param upperBound  Maximum possible value to return\r\n     * @return            Input x clamped to a maximum value, upperBound\r\n     */\r\n    function clamp(uint256 x, uint256 upperBound) internal pure returns (uint256) {\r\n        return x > upperBound ? upperBound : x;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\npragma solidity 0.8.6;\r\n\r\ncontract OwnableData {\r\n    address public owner;\r\n    address public pendingOwner;\r\n}\r\n\r\ncontract Ownable is OwnableData {\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev `owner` defaults to msg.sender on construction.\r\n     */\r\n    constructor() {\r\n        _setOwner(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\r\n     *      Can only be invoked by the current `owner`.\r\n     * @param _newOwner Address of the new owner.\r\n     * @param _direct True if `_newOwner` should be set immediately. False if `_newOwner` needs to use `claimOwnership`.\r\n     * @param _renounce Allows the `_newOwner` to be `address(0)` if `_direct` and `_renounce` is True. Has no effect otherwise\r\n     */\r\n    function transferOwnership(\r\n        address _newOwner,\r\n        bool _direct,\r\n        bool _renounce\r\n    ) external onlyOwner {\r\n        if (_direct) {\r\n            require(_newOwner != address(0) || _renounce, \"zero address\");\r\n\r\n            emit OwnershipTransferred(owner, _newOwner);\r\n            owner = _newOwner;\r\n            pendingOwner = address(0);\r\n        } else {\r\n            pendingOwner = _newOwner;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Needs to be called by `pendingOwner` to claim ownership.\r\n     */\r\n    function claimOwnership() external {\r\n        address _pendingOwner = pendingOwner;\r\n        require(msg.sender == _pendingOwner, \"caller != pending owner\");\r\n\r\n        emit OwnershipTransferred(owner, _pendingOwner);\r\n        owner = _pendingOwner;\r\n        pendingOwner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the Owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function _setOwner(address newOwner) internal {\r\n        address oldOwner = owner;\r\n        owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\npragma solidity 0.8.6;\r\n\r\n\r\n\r\ncontract SCRLVestingHashedWallets is Ownable {\r\n    using StableMath for uint256;\r\n\r\n    // @notice address of vested token\r\n    address public token;\r\n    // @notice total tokens vested in contract\r\n    uint256 public totalVested;\r\n    // @notice total tokens already claimed form vesting\r\n    uint256 public totalClaimed;\r\n\r\n    struct Vest {\r\n        uint256 dateStart; // start of claiming, can claim startTokens\r\n        uint256 dateEnd; // after it all tokens can be claimed\r\n        uint256 totalTokens; // total tokens to claim\r\n        uint256 startTokens; // tokens to claim on start\r\n        uint256 claimedTokens; // tokens already claimed\r\n        uint256 cliffLength;\r\n    }\r\n    // @notice storage of vestings\r\n    Vest[] internal vestings;\r\n    // @notice map of vestings for user\r\n    mapping(bytes32 => uint256[]) internal user2vesting;\r\n\r\n    // @dev events\r\n    event Claimed(address indexed user, uint256 amount);\r\n\r\n    /**\r\n     * @dev Contract initiator\r\n     * @param _token address of vested token\r\n     */\r\n    function init(address _token) external onlyOwner {\r\n        require(_token != address(0), \"_token address cannot be 0\");\r\n        require(token == address(0), \"init already done\");\r\n        token = _token;\r\n    }\r\n\r\n    /**\r\n     * @dev Add multiple vesting to contract by arrays of data\r\n     * @param _hashedUsers[] hashed addresses of holders\r\n     * @param _startTokens[] tokens that can be withdrawn at startDate\r\n     * @param _totalTokens[] total tokens in vesting\r\n     * @param _startDate date from when tokens can be claimed\r\n     * @param _cliff cliff length after TGE initial distribution\r\n     * @param _duration duration of the vesting after the cliff\r\n     */\r\n    function massAddHolders(\r\n        bytes32[] calldata _hashedUsers,\r\n        uint256[] calldata _startTokens,\r\n        uint256[] calldata _totalTokens,\r\n        uint256 _startDate,\r\n        uint256 _cliff,\r\n        uint256 _duration\r\n    ) external onlyOwner {\r\n        uint256 len = _hashedUsers.length;\r\n        //cheaper to use one variable\r\n        require((len == _startTokens.length) && (len == _totalTokens.length), \"data size mismatch\");\r\n        uint256 i;\r\n        for (i; i < len; i++) {\r\n            _addHolder(_hashedUsers[i], _startTokens[i], _totalTokens[i], _startDate, _cliff, _duration);\r\n        }\r\n    }\r\n\r\n    function stopVestingForWallet(address _user) external onlyOwner {\r\n        bytes32 _hashedUser = keccak256(abi.encodePacked(_user));\r\n        stopVestingForHashedWallet(_hashedUser);\r\n    }\r\n\r\n    function stopVestingForHashedWallet(bytes32 _hashedUser) public onlyOwner {\r\n        uint256 len = user2vesting[_hashedUser].length;\r\n        require(len > 0, \"no vestings for user\");\r\n        uint256 i;\r\n        for (i; i < len; i++) {\r\n            Vest storage v = vestings[user2vesting[_hashedUser][i] - 1];\r\n            uint256 _restClaimable = _claimable(v);\r\n            totalVested -= v.totalTokens - _restClaimable;\r\n            v.totalTokens = _restClaimable + v.claimedTokens;\r\n            v.dateEnd = block.timestamp;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Add new vesting to contract\r\n     * @param _user hashed address of a holder\r\n     * @param _startTokens how many tokens are claimable at start date\r\n     * @param _totalTokens total number of tokens in added vesting\r\n     * @param _startDate date from when tokens can be claimed\r\n     * @param _cliff cliff length after TGE initial distribution\r\n     * @param _duration duration of the vesting after the cliff\r\n     */\r\n    function _addHolder(\r\n        bytes32 _user,\r\n        uint256 _startTokens,\r\n        uint256 _totalTokens,\r\n        uint256 _startDate,\r\n        uint256 _cliff,\r\n        uint256 _duration\r\n    ) internal {\r\n        Vest memory v;\r\n        v.startTokens = _startTokens;\r\n        v.totalTokens = _totalTokens;\r\n        v.dateStart = _startDate;\r\n        v.cliffLength = _cliff;\r\n        v.dateEnd = _startDate + _cliff + _duration;\r\n\r\n        totalVested += _totalTokens;\r\n        vestings.push(v);\r\n        user2vesting[_user].push(vestings.length);\r\n    }\r\n\r\n    /**\r\n     * @dev Claim tokens from msg.sender vestings\r\n     */\r\n    function claim() external {\r\n        _claim(msg.sender, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Claim tokens from msg.sender vestings to external address\r\n     * @param _target transfer address for claimed tokens\r\n     */\r\n    function claimTo(address _target) external {\r\n        _claim(msg.sender, _target);\r\n    }\r\n\r\n    /**\r\n     * @dev internal claim function\r\n     * @param _user address of holder\r\n     * @param _target where tokens should be send\r\n     * @return amt number of tokens claimed\r\n     */\r\n    function _claim(address _user, address _target) internal returns (uint256 amt) {\r\n        require(_target != address(0), \"claim, then burn\");\r\n        bytes32 _hashedUser = keccak256(abi.encodePacked(_user));\r\n        uint256 len = user2vesting[_hashedUser].length;\r\n        require(len > 0, \"no vestings for user\");\r\n        uint256 cl;\r\n        uint256 i;\r\n        for (i; i < len; i++) {\r\n            Vest storage v = vestings[user2vesting[_hashedUser][i] - 1];\r\n            cl = _claimable(v);\r\n            v.claimedTokens += cl;\r\n            amt += cl;\r\n        }\r\n        if (amt > 0) {\r\n            totalClaimed += amt;\r\n            _transfer(_target, amt);\r\n            emit Claimed(_user, amt);\r\n        } else revert(\"nothing to claim\");\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to send out claimed tokens\r\n     * @param _user address that we send tokens\r\n     * @param _amt amount of tokens\r\n     */\r\n    function _transfer(address _user, uint256 _amt) internal {\r\n        require(IERC20(token).transfer(_user, _amt), \"token transfer failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Count how many tokens can be claimed from vesting to date\r\n     * @param _vesting Vesting object\r\n     * @return canWithdraw number of tokens\r\n     */\r\n    function _claimable(Vest memory _vesting) internal view returns (uint256 canWithdraw) {\r\n        uint256 currentTime = block.timestamp;\r\n        uint256 cliffTime = _vesting.dateStart + _vesting.cliffLength;\r\n\r\n        // not started\r\n        if (_vesting.dateStart > currentTime) return 0;\r\n\r\n        if (currentTime <= cliffTime) {\r\n            // we are after start but before cliff\r\n            canWithdraw = _vesting.startTokens;\r\n        } else if (currentTime > cliffTime && currentTime < _vesting.dateEnd) {\r\n            // we are somewhere in the middle\r\n\r\n            // how much time passed (as fraction * 10^18)\r\n            // timeRatio = (time passed * 1e18) / duration\r\n            uint256 timeRatio = (currentTime - cliffTime).divPrecisely(_vesting.dateEnd - cliffTime);\r\n            // how much tokens we can get in total to date\r\n            canWithdraw = (_vesting.totalTokens - _vesting.startTokens).mulTruncate(timeRatio) + _vesting.startTokens;\r\n        }\r\n        // time has passed, we can take all tokens\r\n        else {\r\n            canWithdraw = _vesting.totalTokens;\r\n        }\r\n        // but maybe we take something earlier?\r\n        canWithdraw -= _vesting.claimedTokens;\r\n    }\r\n\r\n    /**\r\n     * @dev Read number of claimable tokens by user and vesting no\r\n     * @param _user address of holder\r\n     * @param _id his vesting number (starts from 0)\r\n     * @return amount number of tokens\r\n     */\r\n    function getClaimable(address _user, uint256 _id) external view returns (uint256 amount) {\r\n        bytes32 _hashedUser = keccak256(abi.encodePacked(_user));\r\n        amount = _claimable(vestings[user2vesting[_hashedUser][_id] - 1]);\r\n    }\r\n\r\n    /**\r\n     * @dev Read total amount of tokens that user can claim to date from all vestings\r\n     *      Function also includes tokens to claim from sale contracts that were not\r\n     *      yet initiated for user.\r\n     * @param _user address of holder\r\n     * @return amount number of tokens\r\n     */\r\n    function getAllClaimable(address _user) public view returns (uint256 amount) {\r\n        bytes32 _hashedUser = keccak256(abi.encodePacked(_user));\r\n        uint256 len = user2vesting[_hashedUser].length;\r\n        uint256 i;\r\n        for (i; i < len; i++) {\r\n            amount += _claimable(vestings[user2vesting[_hashedUser][i] - 1]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Extract all the vestings for the user\r\n     *      Also extract not initialized vestings from\r\n     *      sale contracts.\r\n     * @param _user address of holder\r\n     * @return v array of Vest objects\r\n     */\r\n    function getVestings(address _user) external view returns (Vest[] memory) {\r\n        bytes32 _hashedUser = keccak256(abi.encodePacked(_user));\r\n        uint256 len = user2vesting[_hashedUser].length;\r\n        Vest[] memory v = new Vest[](len);\r\n\r\n        // copy vestings\r\n        uint256 i;\r\n        for (i; i < len; i++) {\r\n            v[i] = vestings[user2vesting[_hashedUser][i] - 1];\r\n        }\r\n\r\n        return v;\r\n    }\r\n\r\n    /**\r\n     * @dev Read total number of vestings registered\r\n     * @return number of registered vestings on contract\r\n     */\r\n    function getVestingsCount() external view returns (uint256) {\r\n        return vestings.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Read single registered vesting entry\r\n     * @param _id index of vesting in storage\r\n     * @return Vest object\r\n     */\r\n    function getVestingByIndex(uint256 _id) external view returns (Vest memory) {\r\n        return vestings[_id];\r\n    }\r\n\r\n    /**\r\n     * @dev Read registered vesting list by range from-to\r\n     * @param _start first index\r\n     * @param _end last index\r\n     * @return array of Vest objects\r\n     */\r\n    function getVestingsByRange(uint256 _start, uint256 _end) external view returns (Vest[] memory) {\r\n        uint256 cnt = _end - _start + 1;\r\n        uint256 len = vestings.length;\r\n        require(_end < len, \"range error\");\r\n        Vest[] memory v = new Vest[](cnt);\r\n        uint256 i;\r\n        for (i; i < cnt; i++) {\r\n            v[i] = vestings[_start + i];\r\n        }\r\n        return v;\r\n    }\r\n\r\n    /**\r\n     * @dev Recover BSC from contract to owner address.\r\n     */\r\n    function recoverBSC() external onlyOwner {\r\n        payable(owner).transfer(address(this).balance);\r\n    }\r\n\r\n    /**\r\n     * @dev Recover given ERC20 token from contract to owner address.\r\n     *      Can't recover vested tokens.\r\n     * @param _token address of ERC20 token to recover\r\n     */\r\n    function recoverErc20(address _token) external onlyOwner {\r\n        uint256 _tokenBalance = IERC20(_token).balanceOf(address(this));\r\n        require(_tokenBalance > 0, \"nothing to recover\");\r\n\r\n        uint256 _tokenAvailableToClaim = _tokenBalance - (totalVested - totalClaimed);\r\n        require(_tokenAvailableToClaim > 0, \"not available to recover\");\r\n\r\n        IBadErc20(_token).transfer(owner, _tokenAvailableToClaim);\r\n    }\r\n}\r\n\r\n/**\r\n * @title IBadErc20\r\n * @dev Interface for emergency recover any ERC20-tokens,\r\n *      even non-erc20-compliant like USDT not returning boolean\r\n */\r\ninterface IBadErc20 {\r\n    function transfer(address _recipient, uint256 _amount) external;\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"claimTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getAllClaimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getClaimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getVestingByIndex\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"dateStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dateEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cliffLength\",\"type\":\"uint256\"}],\"internalType\":\"struct SCRLVestingHashedWallets.Vest\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getVestings\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"dateStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dateEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cliffLength\",\"type\":\"uint256\"}],\"internalType\":\"struct SCRLVestingHashedWallets.Vest[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_end\",\"type\":\"uint256\"}],\"name\":\"getVestingsByRange\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"dateStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dateEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimedTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cliffLength\",\"type\":\"uint256\"}],\"internalType\":\"struct SCRLVestingHashedWallets.Vest[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVestingsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_hashedUsers\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_startTokens\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_totalTokens\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_startDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_cliff\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"massAddHolders\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoverBSC\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"recoverErc20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hashedUser\",\"type\":\"bytes32\"}],\"name\":\"stopVestingForHashedWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"stopVestingForWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalVested\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_direct\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_renounce\",\"type\":\"bool\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SCRLVestingHashedWallets", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://727efe2e71633ea772f2030f722e1b00c0d2ee19f7d85de0e0367d3c10e09dea"}