{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/RewardsDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\npragma solidity 0.8.13;\\r\\n\\r\\nimport './libraries/Math.sol';\\r\\nimport './interfaces/IERC20.sol';\\r\\nimport './interfaces/IRewardsDistributor.sol';\\r\\nimport './interfaces/IVotingEscrow.sol';\\r\\n\\r\\n/*\\r\\n\\r\\n@title Curve Fee Distribution modified for ve(3,3) emissions\\r\\n@author Curve Finance, andrecronje\\r\\n@license MIT\\r\\n\\r\\n*/\\r\\n\\r\\ncontract RewardsDistributor is IRewardsDistributor {\\r\\n\\r\\n    event CheckpointToken(\\r\\n        uint time,\\r\\n        uint tokens\\r\\n    );\\r\\n\\r\\n    event Claimed(\\r\\n        uint tokenId,\\r\\n        uint amount,\\r\\n        uint claim_epoch,\\r\\n        uint max_epoch\\r\\n    );\\r\\n\\r\\n    uint constant WEEK = 7 * 86400;\\r\\n\\r\\n    uint public start_time;\\r\\n    uint public time_cursor;\\r\\n    mapping(uint => uint) public time_cursor_of;\\r\\n    mapping(uint => uint) public user_epoch_of;\\r\\n\\r\\n    uint public last_token_time;\\r\\n    uint[1000000000000000] public tokens_per_week;\\r\\n    uint public token_last_balance;\\r\\n    uint[1000000000000000] public ve_supply;\\r\\n\\r\\n    address public owner;\\r\\n    address public voting_escrow;\\r\\n    address public token;\\r\\n    address public depositor;\\r\\n\\r\\n    constructor(address _voting_escrow) {\\r\\n        uint _t = block.timestamp / WEEK * WEEK;\\r\\n        start_time = _t;\\r\\n        last_token_time = _t;\\r\\n        time_cursor = _t;\\r\\n        address _token = IVotingEscrow(_voting_escrow).token();\\r\\n        token = _token;\\r\\n        voting_escrow = _voting_escrow;\\r\\n        depositor = msg.sender;\\r\\n        owner = msg.sender;\\r\\n        require(IERC20(_token).approve(_voting_escrow, type(uint).max));\\r\\n    }\\r\\n\\r\\n    function timestamp() external view returns (uint) {\\r\\n        return block.timestamp / WEEK * WEEK;\\r\\n    }\\r\\n\\r\\n    function _checkpoint_token() internal {\\r\\n        uint token_balance = IERC20(token).balanceOf(address(this));\\r\\n        uint to_distribute = token_balance - token_last_balance;\\r\\n        token_last_balance = token_balance;\\r\\n\\r\\n        uint t = last_token_time;\\r\\n        uint since_last = block.timestamp - t;\\r\\n        last_token_time = block.timestamp;\\r\\n        uint this_week = t / WEEK * WEEK;\\r\\n        uint next_week = 0;\\r\\n\\r\\n        for (uint i = 0; i < 20; i++) {\\r\\n            next_week = this_week + WEEK;\\r\\n            if (block.timestamp < next_week) {\\r\\n                if (since_last == 0 && block.timestamp == t) {\\r\\n                    tokens_per_week[this_week] += to_distribute;\\r\\n                } else {\\r\\n                    tokens_per_week[this_week] += to_distribute * (block.timestamp - t) / since_last;\\r\\n                }\\r\\n                break;\\r\\n            } else {\\r\\n                if (since_last == 0 && next_week == t) {\\r\\n                    tokens_per_week[this_week] += to_distribute;\\r\\n                } else {\\r\\n                    tokens_per_week[this_week] += to_distribute * (next_week - t) / since_last;\\r\\n                }\\r\\n            }\\r\\n            t = next_week;\\r\\n            this_week = next_week;\\r\\n        }\\r\\n        emit CheckpointToken(block.timestamp, to_distribute);\\r\\n    }\\r\\n\\r\\n    function checkpoint_token() external {\\r\\n        assert(msg.sender == depositor);\\r\\n        _checkpoint_token();\\r\\n    }\\r\\n\\r\\n    function _find_timestamp_epoch(address ve, uint _timestamp) internal view returns (uint) {\\r\\n        uint _min = 0;\\r\\n        uint _max = IVotingEscrow(ve).epoch();\\r\\n        for (uint i = 0; i < 128; i++) {\\r\\n            if (_min >= _max) break;\\r\\n            uint _mid = (_min + _max + 2) / 2;\\r\\n            IVotingEscrow.Point memory pt = IVotingEscrow(ve).point_history(_mid);\\r\\n            if (pt.ts <= _timestamp) {\\r\\n                _min = _mid;\\r\\n            } else {\\r\\n                _max = _mid - 1;\\r\\n            }\\r\\n        }\\r\\n        return _min;\\r\\n    }\\r\\n\\r\\n    function _find_timestamp_user_epoch(address ve, uint tokenId, uint _timestamp, uint max_user_epoch) internal view returns (uint) {\\r\\n        uint _min = 0;\\r\\n        uint _max = max_user_epoch;\\r\\n        for (uint i = 0; i < 128; i++) {\\r\\n            if (_min >= _max) break;\\r\\n            uint _mid = (_min + _max + 2) / 2;\\r\\n            IVotingEscrow.Point memory pt = IVotingEscrow(ve).user_point_history(tokenId, _mid);\\r\\n            if (pt.ts <= _timestamp) {\\r\\n                _min = _mid;\\r\\n            } else {\\r\\n                _max = _mid -1;\\r\\n            }\\r\\n        }\\r\\n        return _min;\\r\\n    }\\r\\n\\r\\n    function ve_for_at(uint _tokenId, uint _timestamp) external view returns (uint) {\\r\\n        address ve = voting_escrow;\\r\\n        uint max_user_epoch = IVotingEscrow(ve).user_point_epoch(_tokenId);\\r\\n        uint epoch = _find_timestamp_user_epoch(ve, _tokenId, _timestamp, max_user_epoch);\\r\\n        IVotingEscrow.Point memory pt = IVotingEscrow(ve).user_point_history(_tokenId, epoch);\\r\\n        return Math.max(uint(int256(pt.bias - pt.slope * (int128(int256(_timestamp - pt.ts))))), 0);\\r\\n    }\\r\\n\\r\\n    function _checkpoint_total_supply() internal {\\r\\n        address ve = voting_escrow;\\r\\n        uint t = time_cursor;\\r\\n        uint rounded_timestamp = block.timestamp / WEEK * WEEK;\\r\\n        IVotingEscrow(ve).checkpoint();\\r\\n\\r\\n        for (uint i = 0; i < 20; i++) {\\r\\n            if (t > rounded_timestamp) {\\r\\n                break;\\r\\n            } else {\\r\\n                uint epoch = _find_timestamp_epoch(ve, t);\\r\\n                IVotingEscrow.Point memory pt = IVotingEscrow(ve).point_history(epoch);\\r\\n                int128 dt = 0;\\r\\n                if (t > pt.ts) {\\r\\n                    dt = int128(int256(t - pt.ts));\\r\\n                }\\r\\n                ve_supply[t] = Math.max(uint(int256(pt.bias - pt.slope * dt)), 0);\\r\\n            }\\r\\n            t += WEEK;\\r\\n        }\\r\\n        time_cursor = t;\\r\\n    }\\r\\n\\r\\n    function checkpoint_total_supply() external {\\r\\n        _checkpoint_total_supply();\\r\\n    }\\r\\n\\r\\n    function _claim(uint _tokenId, address ve, uint _last_token_time) internal returns (uint) {\\r\\n        uint user_epoch = 0;\\r\\n        uint to_distribute = 0;\\r\\n\\r\\n        uint max_user_epoch = IVotingEscrow(ve).user_point_epoch(_tokenId);\\r\\n        uint _start_time = start_time;\\r\\n\\r\\n        if (max_user_epoch == 0) return 0;\\r\\n\\r\\n        uint week_cursor = time_cursor_of[_tokenId];\\r\\n        if (week_cursor == 0) {\\r\\n            user_epoch = _find_timestamp_user_epoch(ve, _tokenId, _start_time, max_user_epoch);\\r\\n        } else {\\r\\n            user_epoch = user_epoch_of[_tokenId];\\r\\n        }\\r\\n\\r\\n        if (user_epoch == 0) user_epoch = 1;\\r\\n\\r\\n        IVotingEscrow.Point memory user_point = IVotingEscrow(ve).user_point_history(_tokenId, user_epoch);\\r\\n\\r\\n        if (week_cursor == 0) week_cursor = (user_point.ts + WEEK - 1) / WEEK * WEEK;\\r\\n        if (week_cursor >= last_token_time) return 0;\\r\\n        if (week_cursor < _start_time) week_cursor = _start_time;\\r\\n\\r\\n        IVotingEscrow.Point memory old_user_point;\\r\\n\\r\\n        for (uint i = 0; i < 50; i++) {\\r\\n            if (week_cursor >= _last_token_time) break;\\r\\n\\r\\n            if (week_cursor >= user_point.ts && user_epoch <= max_user_epoch) {\\r\\n                user_epoch += 1;\\r\\n                old_user_point = user_point;\\r\\n                if (user_epoch > max_user_epoch) {\\r\\n                    user_point = IVotingEscrow.Point(0,0,0,0);\\r\\n                } else {\\r\\n                    user_point = IVotingEscrow(ve).user_point_history(_tokenId, user_epoch);\\r\\n                }\\r\\n            } else {\\r\\n                int128 dt = int128(int256(week_cursor - old_user_point.ts));\\r\\n                uint balance_of = Math.max(uint(int256(old_user_point.bias - dt * old_user_point.slope)), 0);\\r\\n                if (balance_of == 0 && user_epoch > max_user_epoch) break;\\r\\n                if (balance_of != 0) {\\r\\n                    to_distribute += balance_of * tokens_per_week[week_cursor] / ve_supply[week_cursor];\\r\\n                }\\r\\n                week_cursor += WEEK;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        user_epoch = Math.min(max_user_epoch, user_epoch - 1);\\r\\n        user_epoch_of[_tokenId] = user_epoch;\\r\\n        time_cursor_of[_tokenId] = week_cursor;\\r\\n\\r\\n        emit Claimed(_tokenId, to_distribute, user_epoch, max_user_epoch);\\r\\n\\r\\n        return to_distribute;\\r\\n    }\\r\\n\\r\\n    function _claimable(uint _tokenId, address ve, uint _last_token_time) internal view returns (uint) {\\r\\n        uint user_epoch = 0;\\r\\n        uint to_distribute = 0;\\r\\n\\r\\n        uint max_user_epoch = IVotingEscrow(ve).user_point_epoch(_tokenId);\\r\\n        uint _start_time = start_time;\\r\\n\\r\\n        if (max_user_epoch == 0) return 0;\\r\\n\\r\\n        uint week_cursor = time_cursor_of[_tokenId];\\r\\n        if (week_cursor == 0) {\\r\\n            user_epoch = _find_timestamp_user_epoch(ve, _tokenId, _start_time, max_user_epoch);\\r\\n        } else {\\r\\n            user_epoch = user_epoch_of[_tokenId];\\r\\n        }\\r\\n\\r\\n        if (user_epoch == 0) user_epoch = 1;\\r\\n\\r\\n        IVotingEscrow.Point memory user_point = IVotingEscrow(ve).user_point_history(_tokenId, user_epoch);\\r\\n\\r\\n        if (week_cursor == 0) week_cursor = (user_point.ts + WEEK - 1) / WEEK * WEEK;\\r\\n        if (week_cursor >= last_token_time) return 0;\\r\\n        if (week_cursor < _start_time) week_cursor = _start_time;\\r\\n\\r\\n        IVotingEscrow.Point memory old_user_point;\\r\\n\\r\\n        for (uint i = 0; i < 50; i++) {\\r\\n            if (week_cursor >= _last_token_time) break;\\r\\n\\r\\n            if (week_cursor >= user_point.ts && user_epoch <= max_user_epoch) {\\r\\n                user_epoch += 1;\\r\\n                old_user_point = user_point;\\r\\n                if (user_epoch > max_user_epoch) {\\r\\n                    user_point = IVotingEscrow.Point(0,0,0,0);\\r\\n                } else {\\r\\n                    user_point = IVotingEscrow(ve).user_point_history(_tokenId, user_epoch);\\r\\n                }\\r\\n            } else {\\r\\n                int128 dt = int128(int256(week_cursor - old_user_point.ts));\\r\\n                uint balance_of = Math.max(uint(int256(old_user_point.bias - dt * old_user_point.slope)), 0);\\r\\n                if (balance_of == 0 && user_epoch > max_user_epoch) break;\\r\\n                if (balance_of != 0) {\\r\\n                    to_distribute += balance_of * tokens_per_week[week_cursor] / ve_supply[week_cursor];\\r\\n                }\\r\\n                week_cursor += WEEK;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return to_distribute;\\r\\n    }\\r\\n\\r\\n    function claimable(uint _tokenId) external view returns (uint) {\\r\\n        uint _last_token_time = last_token_time / WEEK * WEEK;\\r\\n        return _claimable(_tokenId, voting_escrow, _last_token_time);\\r\\n    }\\r\\n\\r\\n    function claim(uint _tokenId) external returns (uint) {\\r\\n        if (block.timestamp >= time_cursor) _checkpoint_total_supply();\\r\\n        uint _last_token_time = last_token_time;\\r\\n        _last_token_time = _last_token_time / WEEK * WEEK;\\r\\n        uint amount = _claim(_tokenId, voting_escrow, _last_token_time);\\r\\n        if (amount != 0) {\\r\\n            // if locked.end then send directly\\r\\n            IVotingEscrow.LockedBalance memory _locked = IVotingEscrow(voting_escrow).locked(_tokenId);\\r\\n            if(_locked.end < block.timestamp){\\r\\n                address _nftOwner = IVotingEscrow(voting_escrow).ownerOf(_tokenId);\\r\\n                IERC20(token).transfer(_nftOwner, amount);\\r\\n            } else {\\r\\n                IVotingEscrow(voting_escrow).deposit_for(_tokenId, amount);\\r\\n            }\\r\\n            token_last_balance -= amount;\\r\\n        }\\r\\n        return amount;\\r\\n    }\\r\\n\\r\\n    function claim_many(uint[] memory _tokenIds) external returns (bool) {\\r\\n        if (block.timestamp >= time_cursor) _checkpoint_total_supply();\\r\\n        uint _last_token_time = last_token_time;\\r\\n        _last_token_time = _last_token_time / WEEK * WEEK;\\r\\n        address _voting_escrow = voting_escrow;\\r\\n        uint total = 0;\\r\\n\\r\\n        for (uint i = 0; i < _tokenIds.length; i++) {\\r\\n            uint _tokenId = _tokenIds[i];\\r\\n            if (_tokenId == 0) break;\\r\\n            uint amount = _claim(_tokenId, _voting_escrow, _last_token_time);\\r\\n            if (amount != 0) {\\r\\n                // if locked.end then send directly\\r\\n                IVotingEscrow.LockedBalance memory _locked = IVotingEscrow(_voting_escrow).locked(_tokenId);\\r\\n                if(_locked.end < block.timestamp){\\r\\n                    address _nftOwner = IVotingEscrow(_voting_escrow).ownerOf(_tokenId);\\r\\n                    IERC20(token).transfer(_nftOwner, amount);\\r\\n                } else {\\r\\n                    IVotingEscrow(_voting_escrow).deposit_for(_tokenId, amount);\\r\\n                }\\r\\n                total += amount;\\r\\n            }\\r\\n        }\\r\\n        if (total != 0) {\\r\\n            token_last_balance -= total;\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function setDepositor(address _depositor) external {\\r\\n        require(msg.sender == owner);\\r\\n        depositor = _depositor;\\r\\n    }\\r\\n\\r\\n    function setOwner(address _owner) external {\\r\\n        require(msg.sender == owner);\\r\\n        owner = _owner;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.13;\\r\\n\\r\\nlibrary Math {\\r\\n    function max(uint a, uint b) internal pure returns (uint) {\\r\\n        return a >= b ? a : b;\\r\\n    }\\r\\n    function min(uint a, uint b) internal pure returns (uint) {\\r\\n        return a < b ? a : b;\\r\\n    }\\r\\n    function sqrt(uint y) internal pure returns (uint z) {\\r\\n        if (y > 3) {\\r\\n            z = y;\\r\\n            uint x = y / 2 + 1;\\r\\n            while (x < z) {\\r\\n                z = x;\\r\\n                x = (y / x + x) / 2;\\r\\n            }\\r\\n        } else if (y != 0) {\\r\\n            z = 1;\\r\\n        }\\r\\n    }\\r\\n    function cbrt(uint256 n) internal pure returns (uint256) { unchecked {\\r\\n        uint256 x = 0;\\r\\n        for (uint256 y = 1 << 255; y > 0; y >>= 3) {\\r\\n            x <<= 1;\\r\\n            uint256 z = 3 * x * (x + 1) + 1;\\r\\n            if (n / y >= z) {\\r\\n                n -= y * z;\\r\\n                x += 1;\\r\\n            }\\r\\n        }\\r\\n        return x;\\r\\n    }}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.13;\\r\\n\\r\\ninterface IERC20 {\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function transfer(address recipient, uint amount) external returns (bool);\\r\\n    function decimals() external view returns (uint8);\\r\\n    function symbol() external view returns (string memory);\\r\\n    function balanceOf(address) external view returns (uint);\\r\\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n    function approve(address spender, uint value) external returns (bool);\\r\\n\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IRewardsDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.13;\\r\\n\\r\\ninterface IRewardsDistributor {\\r\\n    function checkpoint_token() external;\\r\\n    function voting_escrow() external view returns(address);\\r\\n    function checkpoint_total_supply() external;\\r\\n    function claimable(uint _tokenId) external view returns (uint);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IVotingEscrow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.13;\\r\\n\\r\\ninterface IVotingEscrow {\\r\\n\\r\\n    struct Point {\\r\\n        int128 bias;\\r\\n        int128 slope; // # -dweight / dt\\r\\n        uint256 ts;\\r\\n        uint256 blk; // block\\r\\n    }\\r\\n\\r\\n    struct LockedBalance {\\r\\n        int128 amount;\\r\\n        uint end;\\r\\n    }\\r\\n\\r\\n    function create_lock_for(uint _value, uint _lock_duration, address _to) external returns (uint);\\r\\n\\r\\n    function locked(uint id) external view returns(LockedBalance memory);\\r\\n    function tokenOfOwnerByIndex(address _owner, uint _tokenIndex) external view returns (uint);\\r\\n\\r\\n    function token() external view returns (address);\\r\\n    function team() external returns (address);\\r\\n    function epoch() external view returns (uint);\\r\\n    function point_history(uint loc) external view returns (Point memory);\\r\\n    function user_point_history(uint tokenId, uint loc) external view returns (Point memory);\\r\\n    function user_point_epoch(uint tokenId) external view returns (uint);\\r\\n\\r\\n    function ownerOf(uint) external view returns (address);\\r\\n    function isApprovedOrOwner(address, uint) external view returns (bool);\\r\\n    function transferFrom(address, address, uint) external;\\r\\n\\r\\n    function voted(uint) external view returns (bool);\\r\\n    function attachments(uint) external view returns (uint);\\r\\n    function voting(uint tokenId) external;\\r\\n    function abstain(uint tokenId) external;\\r\\n    function attach(uint tokenId) external;\\r\\n    function detach(uint tokenId) external;\\r\\n\\r\\n    function checkpoint() external;\\r\\n    function deposit_for(uint tokenId, uint value) external;\\r\\n\\r\\n    function balanceOfNFT(uint _id) external view returns (uint);\\r\\n    function balanceOf(address _owner) external view returns (uint);\\r\\n    function totalSupply() external view returns (uint);\\r\\n    function supply() external view returns (uint);\\r\\n\\r\\n\\r\\n    function decimals() external view returns(uint8);\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_voting_escrow\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"CheckpointToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claim_epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"max_epoch\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"checkpoint_token\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkpoint_total_supply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"claim_many\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"claimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"last_token_time\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_depositor\",\"type\":\"address\"}],\"name\":\"setDepositor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"start_time\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"time_cursor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"time_cursor_of\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token_last_balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens_per_week\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"user_epoch_of\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"ve_for_at\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ve_supply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"voting_escrow\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "RewardsDistributor", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000fbbf371c9b0b994eebfcc977cef603f7f31c070d", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}