{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.0;\r\n\r\ninterface IERC721Metadata {\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\r\n}\r\n\r\nabstract contract IERC721TokenReceiver {\r\n    bytes4 internal constant ERC721_RECEIVER_RETURN = 0x150b7a02;\r\n    bytes4 internal constant ERC721_BATCH_RECEIVER_RETURN = 0x0f7b88e3;\r\n\r\n    /// @notice Handle the receipt of an NFT\r\n    /// @dev The ERC721 smart contract calls this function on the recipient\r\n    ///  after a `transfer`. This function MAY throw to revert and reject the\r\n    ///  transfer. Return of other than the magic value MUST result in the\r\n    ///  transaction being reverted.\r\n    ///  Note: the contract address is always the message sender.\r\n    /// @param _operator The address which called `safeTransferFrom` function\r\n    /// @param _from The address which previously owned the token\r\n    /// @param _tokenId The NFT identifier which is being transferred\r\n    /// @param _data Additional data with no specified format\r\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    ///  unless throwing\r\n    function onERC721Received(\r\n        address _operator,\r\n        address _from,\r\n        uint256 _tokenId,\r\n        bytes memory _data\r\n    ) external virtual returns (bytes4);\r\n\r\n    // bytes4(keccak256(\"onERC721ExReceived(address,address,uint256[],bytes)\")) = 0x0f7b88e3\r\n    function onERC721ExReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] memory tokenIds,\r\n        bytes memory data\r\n    ) external virtual returns (bytes4);\r\n}\r\n\r\ninterface IERC721 {\r\n    event Transfer(\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 indexed _tokenId\r\n    );\r\n\r\n    event Approval(\r\n        address indexed _owner,\r\n        address indexed _approved,\r\n        uint256 indexed _tokenId\r\n    );\r\n\r\n    event ApprovalForAll(\r\n        address indexed _owner,\r\n        address indexed _operator,\r\n        bool _approved\r\n    );\r\n\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes calldata data\r\n    ) external payable;\r\n\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    ) external payable;\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    ) external payable;\r\n\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata tokenIds\r\n    ) external;\r\n\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata tokenIds,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function batchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata tokenIds\r\n    ) external;\r\n\r\n    function approve(address _approved, uint256 _tokenId) external payable;\r\n\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n\r\n    function isApprovedForAll(address _owner, address _operator)\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n\r\nabstract contract IERC165 {\r\n    function supportsInterface(bytes4 interfaceID)\r\n        external\r\n        view\r\n        virtual\r\n        returns (bool);\r\n}\r\n\r\nlibrary Address {\r\n    // \u8be5\u65b9\u6cd5\u76ee\u7684\u662f\u4e3a\u4e86\u9632\u6b62\u5408\u7ea6\u8c03\u7528\u65b9\u6cd5.\u4f46\u5408\u7ea6\u6784\u9020\u65f6codesize\u4e3a0,\u6240\u4ee5\u4e0d\u80fd\u603b\u662f\u7b26\u5408\u9884\u671f\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    function toString(address _addr) internal pure returns (string memory) {\r\n        bytes32 value = bytes32(uint256(uint160(_addr)));\r\n\r\n        bytes memory alphabet = \"0123456789abcdef\";\r\n        bytes memory str = new bytes(42);\r\n        str[0] = \"0\";\r\n        str[1] = \"x\";\r\n\r\n        for (uint256 i = 0; i < 20; i++) {\r\n            str[2 + i * 2] = alphabet[uint8(value[i + 12] >> 4)];\r\n            str[3 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\r\n        }\r\n        return string(str);\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(\r\n            address(this).balance >= amount,\r\n            \"Address: insufficient balance\"\r\n        );\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(\r\n            success,\r\n            \"Address: unable to send value, recipient may have reverted\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data)\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return\r\n            functionCallWithValue(\r\n                target,\r\n                data,\r\n                value,\r\n                \"Address: low-level call with value failed\"\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(\r\n            address(this).balance >= value,\r\n            \"Address: insufficient balance for call\"\r\n        );\r\n        return _functionCallWithValue(target, data, value, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 weiValue,\r\n        string memory errorMessage\r\n    ) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{value: weiValue}(\r\n            data\r\n        );\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract Context {\r\n    function _msgSender() internal view returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this;\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\nlibrary ECDSA {\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature`. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise\r\n     * be too long), and then calling {toEthSignedMessageHash} on it.\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature)\r\n        internal\r\n        pure\r\n        returns (address)\r\n    {\r\n        // Divide the signature in r, s and v variables\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        // Check the signature length\r\n        // - case 65: r,s,v signature (standard)\r\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\r\n        if (signature.length == 65) {\r\n            // ecrecover takes the signature parameters, and the only way to get them\r\n            // currently is to use assembly.\r\n            // solhint-disable-next-line no-inline-assembly\r\n            assembly {\r\n                r := mload(add(signature, 0x20))\r\n                s := mload(add(signature, 0x40))\r\n                v := byte(0, mload(add(signature, 0x60)))\r\n            }\r\n        } else if (signature.length == 64) {\r\n            // ecrecover takes the signature parameters, and the only way to get them\r\n            // currently is to use assembly.\r\n            // solhint-disable-next-line no-inline-assembly\r\n            assembly {\r\n                let vs := mload(add(signature, 0x40))\r\n                r := mload(add(signature, 0x20))\r\n                s := and(\r\n                    vs,\r\n                    0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\r\n                )\r\n                v := add(shr(255, vs), 27)\r\n            }\r\n        } else {\r\n            revert(\"ECDSA: invalid signature length\");\r\n        }\r\n\r\n        return recover(hash, v, r, s);\r\n    }\r\n\r\n    /**\r\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\r\n     * `r` and `s` signature fields separately.\r\n     */\r\n    function recover(\r\n        bytes32 hash,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal pure returns (address) {\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (281): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (282): v \u2208 {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        require(\r\n            uint256(s) <=\r\n                0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\r\n            \"ECDSA: invalid signature 's' value\"\r\n        );\r\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        address signer = ecrecover(hash, v, r, s);\r\n        require(signer != address(0), \"ECDSA: invalid signature\");\r\n\r\n        return signer;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\r\n     * produces hash corresponding to the one signed with the\r\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\r\n     * JSON-RPC method as part of EIP-191.\r\n     *\r\n     * See {recover}.\r\n     */\r\n    function toEthSignedMessageHash(bytes32 hash)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        return\r\n            keccak256(\r\n                abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Typed Data, created from a\r\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\r\n     * to the one signed with the\r\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\r\n     * JSON-RPC method as part of EIP-712.\r\n     *\r\n     * See {recover}.\r\n     */\r\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return\r\n            keccak256(\r\n                abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)\r\n            );\r\n    }\r\n}\r\n\r\nlibrary UintLibrary {\r\n    function toString(uint256 _value) internal pure returns (string memory) {\r\n        if (_value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = _value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (_value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(_value % 10)));\r\n            _value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\nlibrary String {\r\n    using UintLibrary for uint256;\r\n\r\n    function recover(\r\n        string memory message,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal pure returns (address) {\r\n        bytes memory msgBytes = bytes(message);\r\n        bytes memory fullMessage = concat(\r\n            bytes(\"\\x19Ethereum Signed Message:\\n\"),\r\n            bytes(msgBytes.length.toString()),\r\n            msgBytes,\r\n            new bytes(0),\r\n            new bytes(0),\r\n            new bytes(0),\r\n            new bytes(0)\r\n        );\r\n\r\n        return ECDSA.recover(keccak256(fullMessage), v, r, s);\r\n    }\r\n\r\n    function append(string memory _a, string memory _b)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory bab = new bytes(_ba.length + _bb.length);\r\n\r\n        uint256 k = 0;\r\n        for (uint256 i = 0; i < _ba.length; i++) bab[k++] = _ba[i];\r\n        for (uint256 i = 0; i < _bb.length; i++) bab[k++] = _bb[i];\r\n        return string(bab);\r\n    }\r\n\r\n    function append(\r\n        string memory _a,\r\n        string memory _b,\r\n        string memory _c\r\n    ) internal pure returns (string memory) {\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory babc = new bytes(_ba.length + _bb.length + _bc.length);\r\n\r\n        uint256 k = 0;\r\n        for (uint256 i = 0; i < _ba.length; i++) babc[k++] = _ba[i];\r\n        for (uint256 i = 0; i < _bb.length; i++) babc[k++] = _bb[i];\r\n        for (uint256 i = 0; i < _bc.length; i++) babc[k++] = _bc[i];\r\n\r\n        return string(babc);\r\n    }\r\n\r\n    function equals(string memory a, string memory b)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        bytes memory ba = bytes(a);\r\n        bytes memory bb = bytes(b);\r\n\r\n        uint256 la = ba.length;\r\n        uint256 lb = bb.length;\r\n\r\n        for (uint256 i = 0; i != la && i != lb; ++i) {\r\n            if (ba[i] != bb[i]) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return la == lb;\r\n    }\r\n\r\n    function toSigHash(string memory message) internal pure returns (bytes32) {\r\n        bytes memory msgBytes = bytes(message);\r\n        bytes memory fullMessage = concat(\r\n            bytes(\"\\x19Ethereum Signed Message:\\n\"),\r\n            bytes(msgBytes.length.toString()),\r\n            msgBytes,\r\n            new bytes(0),\r\n            new bytes(0),\r\n            new bytes(0),\r\n            new bytes(0)\r\n        );\r\n        return keccak256(fullMessage);\r\n    }\r\n\r\n    function concat(\r\n        bytes memory _ba,\r\n        bytes memory _bb,\r\n        bytes memory _bc,\r\n        bytes memory _bd,\r\n        bytes memory _be,\r\n        bytes memory _bf,\r\n        bytes memory _bg\r\n    ) internal pure returns (bytes memory) {\r\n        bytes memory resultBytes = new bytes(\r\n            _ba.length +\r\n                _bb.length +\r\n                _bc.length +\r\n                _bd.length +\r\n                _be.length +\r\n                _bf.length +\r\n                _bg.length\r\n        );\r\n\r\n        uint256 k = 0;\r\n\r\n        for (uint256 i = 0; i < _ba.length; i++) resultBytes[k++] = _ba[i];\r\n        for (uint256 i = 0; i < _bb.length; i++) resultBytes[k++] = _bb[i];\r\n        for (uint256 i = 0; i < _bc.length; i++) resultBytes[k++] = _bc[i];\r\n        for (uint256 i = 0; i < _bd.length; i++) resultBytes[k++] = _bd[i];\r\n        for (uint256 i = 0; i < _be.length; i++) resultBytes[k++] = _be[i];\r\n        for (uint256 i = 0; i < _bf.length; i++) resultBytes[k++] = _bf[i];\r\n        for (uint256 i = 0; i < _bg.length; i++) resultBytes[k++] = _bg[i];\r\n\r\n        return resultBytes;\r\n    }\r\n}\r\n\r\nlibrary StringLibrary {\r\n    using UintLibrary for uint256;\r\n\r\n    function append(string memory _a, string memory _b)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory bab = new bytes(_ba.length + _bb.length);\r\n\r\n        uint256 k = 0;\r\n\r\n        for (uint256 i = 0; i < _ba.length; i++) bab[k++] = _ba[i];\r\n        for (uint256 i = 0; i < _bb.length; i++) bab[k++] = _bb[i];\r\n\r\n        return string(bab);\r\n    }\r\n\r\n    function append(\r\n        string memory _a,\r\n        string memory _b,\r\n        string memory _c\r\n    ) internal pure returns (string memory) {\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory babc = new bytes(_ba.length + _bb.length + _bc.length);\r\n\r\n        uint256 k = 0;\r\n        for (uint256 i = 0; i < _ba.length; i++) babc[k++] = _ba[i];\r\n        for (uint256 i = 0; i < _bb.length; i++) babc[k++] = _bb[i];\r\n        for (uint256 i = 0; i < _bc.length; i++) babc[k++] = _bc[i];\r\n\r\n        return string(babc);\r\n    }\r\n\r\n    function recover(\r\n        string memory message,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal pure returns (address) {\r\n        bytes memory msgBytes = bytes(message);\r\n        bytes memory fullMessage = concat(\r\n            bytes(\"\\x19Ethereum Signed Message:\\n\"),\r\n            bytes(msgBytes.length.toString()),\r\n            msgBytes,\r\n            new bytes(0),\r\n            new bytes(0),\r\n            new bytes(0),\r\n            new bytes(0)\r\n        );\r\n\r\n        return ECDSA.recover(keccak256(fullMessage), v, r, s);\r\n    }\r\n\r\n    function concat(\r\n        bytes memory _ba,\r\n        bytes memory _bb,\r\n        bytes memory _bc,\r\n        bytes memory _bd,\r\n        bytes memory _be,\r\n        bytes memory _bf,\r\n        bytes memory _bg\r\n    ) internal pure returns (bytes memory) {\r\n        bytes memory resultBytes = new bytes(\r\n            _ba.length +\r\n                _bb.length +\r\n                _bc.length +\r\n                _bd.length +\r\n                _be.length +\r\n                _bf.length +\r\n                _bg.length\r\n        );\r\n\r\n        uint256 k = 0;\r\n\r\n        for (uint256 i = 0; i < _ba.length; i++) resultBytes[k++] = _ba[i];\r\n        for (uint256 i = 0; i < _bb.length; i++) resultBytes[k++] = _bb[i];\r\n        for (uint256 i = 0; i < _bc.length; i++) resultBytes[k++] = _bc[i];\r\n        for (uint256 i = 0; i < _bd.length; i++) resultBytes[k++] = _bd[i];\r\n        for (uint256 i = 0; i < _be.length; i++) resultBytes[k++] = _be[i];\r\n        for (uint256 i = 0; i < _bf.length; i++) resultBytes[k++] = _bf[i];\r\n        for (uint256 i = 0; i < _bg.length; i++) resultBytes[k++] = _bg[i];\r\n\r\n        return resultBytes;\r\n    }\r\n}\r\n\r\nabstract contract ERC721TokenURI {\r\n    using String for string;\r\n    using UintLibrary for uint256;\r\n    // Token URI prefix\r\n    string public tokenURIPrefix;\r\n\r\n    constructor(string memory _tokenURIPrefix) {\r\n        tokenURIPrefix = _tokenURIPrefix;\r\n    }\r\n\r\n    // Returns an URI for a given token ID\r\n    function _tokenURI(uint256 tokenId) internal view returns (string memory) {\r\n        return tokenURIPrefix.append(tokenId.toString());\r\n    }\r\n}\r\n\r\nabstract contract ERC721 is\r\n    IERC165,\r\n    IERC721,\r\n    IERC721Metadata,\r\n    ERC721TokenURI,\r\n    Ownable\r\n{\r\n    using Address for address;\r\n\r\n    //* bytes4(keccak256(\"supportsInterface(bytes4)\")) == 0x01ffc9a7\r\n    bytes4 private constant INTERFACE_ID_ERC165 = 0x01ffc9a7;\r\n\r\n    /*\r\n     *     bytes4(keccak256(\"balanceOf(address)\")) == 0x70a08231\r\n     *     bytes4(keccak256(\"ownerOf(uint256)\")) == 0x6352211e\r\n     *     bytes4(keccak256(\"approve(address,uint256)\")) == 0x095ea7b3\r\n     *     bytes4(keccak256(\"getApproved(uint256)\")) == 0x081812fc\r\n     *     bytes4(keccak256(\"setApprovalForAll(address,bool)\")) == 0xa22cb465\r\n     *     bytes4(keccak256(\"isApprovedForAll(address,address)\")) == 0xe985e9c5\r\n     *     bytes4(keccak256(\"transferFrom(address,address,uint256)\")) == 0x23b872dd\r\n     *     bytes4(keccak256(\"safeTransferFrom(address,address,uint256)\")) == 0x42842e0e\r\n     *     bytes4(keccak256(\"safeTransferFrom(address,address,uint256,bytes)\")) == 0xb88d4fde\r\n     *\r\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\r\n     *        0xa22cb465 ^ 0xe985e9c ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\r\n     */\r\n    bytes4 private constant INTERFACE_ID_ERC721 = 0x80ac58cd;\r\n\r\n    bytes4 private constant INTERFACE_ID_ERC721Metadata = 0x5b5e139f;\r\n\r\n    bytes4 private constant ERC721_RECEIVER_RETURN = 0x150b7a02;\r\n    bytes4 internal constant ERC721_BATCH_RECEIVER_RETURN = 0x0f7b88e3;\r\n\r\n    string public override name;\r\n    string public override symbol;\r\n\r\n    uint256 public totalSupply = 0;\r\n\r\n    mapping(address => uint256[]) internal ownerTokens;\r\n    mapping(uint256 => uint256) internal tokenIndexs;\r\n    mapping(uint256 => address) internal tokenOwners;\r\n\r\n    mapping(uint256 => address) internal tokenApprovals;\r\n    mapping(address => mapping(address => bool)) internal approvalForAlls;\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        string memory _tokenURIPrefix\r\n    ) ERC721TokenURI(_tokenURIPrefix) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n    }\r\n\r\n    function changeTokenURIPrefix(string memory _tokenURIPrefix)\r\n        public\r\n        onlyOwner\r\n    {\r\n        tokenURIPrefix = _tokenURIPrefix;\r\n    }\r\n\r\n    function balanceOf(address owner) external view override returns (uint256) {\r\n        require(owner != address(0), \"erc721:owner is zero address\");\r\n        return ownerTokens[owner].length;\r\n    }\r\n\r\n    function tokenOf(address owner) external view returns (uint256[] memory) {\r\n        require(owner != address(0), \"erc721:owner is zero address\");\r\n\r\n        uint256[] storage tokens = ownerTokens[owner];\r\n        return tokens;\r\n    }\r\n\r\n    function ownerOf(uint256 tokenId) external view override returns (address) {\r\n        address owner = tokenOwners[tokenId];\r\n        return owner;\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    ) external payable override {\r\n        safeTransferFrom(_from, _to, _tokenId, \"\");\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes memory _data\r\n    ) public payable override {\r\n        _transferFrom(_from, _to, _tokenId);\r\n\r\n        if (_to.isContract()) {\r\n            require(\r\n                IERC721TokenReceiver(_to).onERC721Received(\r\n                    msg.sender,\r\n                    _from,\r\n                    _tokenId,\r\n                    _data\r\n                ) == ERC721_RECEIVER_RETURN,\r\n                \"erc721:onERC721Received() return invalid\"\r\n            );\r\n        }\r\n    }\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    ) external payable override {\r\n        _transferFrom(_from, _to, _tokenId);\r\n    }\r\n\r\n    function _transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    ) internal {\r\n        require(_from != address(0), \"erc721:from is zero address\");\r\n        require(_from == tokenOwners[_tokenId], \"erc721:from must be owner\");\r\n        require(\r\n            msg.sender == _from ||\r\n                msg.sender == tokenApprovals[_tokenId] ||\r\n                approvalForAlls[_from][msg.sender],\r\n            \"sender must be owner or approvaled\"\r\n        );\r\n\r\n        if (tokenApprovals[_tokenId] != address(0)) {\r\n            delete tokenApprovals[_tokenId];\r\n        }\r\n\r\n        _removeTokenFrom(_from, _tokenId);\r\n        _addTokenTo(_to, _tokenId);\r\n\r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory tokenIds\r\n    ) external override {\r\n        safeBatchTransferFrom(from, to, tokenIds, \"\");\r\n    }\r\n\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory tokenIds,\r\n        bytes memory data\r\n    ) public override {\r\n        batchTransferFrom(from, to, tokenIds);\r\n\r\n        if (to.isContract()) {\r\n            require(\r\n                IERC721TokenReceiver(to).onERC721ExReceived(\r\n                    msg.sender,\r\n                    from,\r\n                    tokenIds,\r\n                    data\r\n                ) == ERC721_BATCH_RECEIVER_RETURN,\r\n                \"onERC721ExReceived() return invalid\"\r\n            );\r\n        }\r\n    }\r\n\r\n    function batchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory tokenIds\r\n    ) public override {\r\n        require(from != address(0), \"from is zero address\");\r\n        require(to != address(0), \"to is zero address\");\r\n\r\n        uint256 length = tokenIds.length;\r\n        address sender = msg.sender;\r\n\r\n        bool approval = from == sender || approvalForAlls[from][sender];\r\n\r\n        for (uint256 i = 0; i != length; ++i) {\r\n            uint256 tokenId = tokenIds[i];\r\n\r\n            require(from == tokenOwners[tokenId], \"from must be owner\");\r\n            require(\r\n                approval || sender == tokenApprovals[tokenId],\r\n                \"sender must be owner or approvaled\"\r\n            );\r\n\r\n            if (tokenApprovals[tokenId] != address(0)) {\r\n                delete tokenApprovals[tokenId];\r\n            }\r\n\r\n            _removeTokenFrom(from, tokenId);\r\n            _addTokenTo(to, tokenId);\r\n\r\n            emit Transfer(from, to, tokenId);\r\n        }\r\n    }\r\n\r\n    function _mint(address to, uint256 tokenId) internal {\r\n        require(\r\n            tokenOwners[tokenId] == address(0x00),\r\n            \"ERC721: tokenId has been mint\"\r\n        );\r\n        _addTokenTo(to, tokenId);\r\n        ++totalSupply;\r\n\r\n        emit Transfer(address(0), to, tokenId);\r\n    }\r\n\r\n    function _burn(uint256 tokenId) internal {\r\n        address owner = tokenOwners[tokenId];\r\n        _removeTokenFrom(owner, tokenId);\r\n\r\n        if (tokenApprovals[tokenId] != address(0)) {\r\n            delete tokenApprovals[tokenId];\r\n        }\r\n\r\n        emit Transfer(owner, address(0), tokenId);\r\n    }\r\n\r\n    function _removeTokenFrom(address _from, uint256 _tokenId) internal {\r\n        uint256 index = tokenIndexs[_tokenId];\r\n\r\n        uint256[] storage tokens = ownerTokens[_from];\r\n        uint256 indexLast = tokens.length - 1;\r\n\r\n        uint256 tokenIdLast = tokens[indexLast];\r\n        tokens[index] = tokenIdLast;\r\n        tokenIndexs[tokenIdLast] = index;\r\n\r\n        tokens.pop();\r\n\r\n        delete tokenOwners[_tokenId];\r\n    }\r\n\r\n    function _addTokenTo(address _to, uint256 _tokenId) internal {\r\n        uint256[] storage tokens = ownerTokens[_to];\r\n        tokenIndexs[_tokenId] = tokens.length;\r\n        tokens.push(_tokenId);\r\n\r\n        tokenOwners[_tokenId] = _to;\r\n    }\r\n\r\n    function approve(address _to, uint256 _tokenId) external payable override {\r\n        address _owner = tokenOwners[_tokenId];\r\n        require(\r\n            msg.sender == _owner || approvalForAlls[_owner][msg.sender],\r\n            \"erc721:sender must be owner or approved for all\"\r\n        );\r\n\r\n        tokenApprovals[_tokenId] = _to;\r\n        emit Approval(_owner, _to, _tokenId);\r\n    }\r\n\r\n    function setApprovalForAll(address _to, bool _approved) external override {\r\n        approvalForAlls[msg.sender][_to] = _approved;\r\n        emit ApprovalForAll(msg.sender, _to, _approved);\r\n    }\r\n\r\n    function getApproved(uint256 _tokenId)\r\n        external\r\n        view\r\n        override\r\n        returns (address)\r\n    {\r\n        require(tokenOwners[_tokenId] != address(0), \"nobody own then token\");\r\n        return tokenApprovals[_tokenId];\r\n    }\r\n\r\n    function isApprovedForAll(address _owner, address _operator)\r\n        external\r\n        view\r\n        override\r\n        returns (bool)\r\n    {\r\n        return approvalForAlls[_owner][_operator];\r\n    }\r\n\r\n    function supportsInterface(bytes4 _interfaceId)\r\n        external\r\n        pure\r\n        override\r\n        returns (bool)\r\n    {\r\n        return\r\n            _interfaceId == INTERFACE_ID_ERC165 ||\r\n            _interfaceId == INTERFACE_ID_ERC721 ||\r\n            _interfaceId == INTERFACE_ID_ERC721Metadata;\r\n    }\r\n\r\n    function tokenURI(uint256 id) public view override returns (string memory) {\r\n        return _tokenURI(id);\r\n    }\r\n}\r\n\r\ncontract LVA is ERC721 {\r\n    constructor()\r\n        ERC721(\r\n            \"Liberty Ventures Alliance\",\r\n            \"LVA\",\r\n            \"http://gateway.freeventurecapital.info:9000/token/\"\r\n        )\r\n    {}\r\n\r\n    function mint(address to) external onlyOwner {\r\n        uint256 cardId = totalSupply + 1;\r\n        _mint(to, cardId);\r\n    }\r\n\r\n    function burn(uint256 cardId) external {\r\n        address owner = tokenOwners[cardId];\r\n\r\n        require(\r\n            msg.sender == owner ||\r\n                msg.sender == tokenApprovals[cardId] ||\r\n                approvalForAlls[owner][msg.sender],\r\n            \"msg.sender must be owner or approved\"\r\n        );\r\n\r\n        _burn(cardId);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cardId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_tokenURIPrefix\",\"type\":\"string\"}],\"name\":\"changeTokenURIPrefix\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"tokenOf\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenURIPrefix\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LVA", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://439958826ec8491fa166b25a7c79301c52b9ac1b6921827df5aef8aad24b1a60"}