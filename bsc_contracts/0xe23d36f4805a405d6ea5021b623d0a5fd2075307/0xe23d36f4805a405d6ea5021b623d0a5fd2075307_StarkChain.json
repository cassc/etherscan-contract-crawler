{"SourceCode": "pragma solidity >=0.5.16 <0.6.9;\r\npragma experimental ABIEncoderV2;\r\n//YOUWILLNEVERWALKALONE\r\ninterface tokenRecipient {\r\n    function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external;\r\n}\r\n\r\ncontract StarkChain {\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals = 18;\r\n    uint256 public totalSupply;\r\n    address payable public fundsWallet;\r\n    uint256 public maximumTarget;\r\n    uint256 public lastBlock;\r\n    uint256 public rewardTimes;\r\n    uint256 public genesisReward;\r\n    uint256 public premined;\r\n    uint256 public nRewarMod;\r\n    uint256 public nWtime;\r\n\r\n\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    event Burn(address indexed from, uint256 value);\r\n\r\n    constructor(\r\n        uint256 initialSupply,\r\n        string memory tokenName,\r\n        string memory tokenSymbol\r\n    ) public {\r\n        initialSupply = 8886000  * 10 ** uint256(decimals);\r\n        tokenName = \"Stark Chain\";\r\n        tokenSymbol = \"STARK\";\r\n        lastBlock = 206;\r\n        nRewarMod = 34344;        \r\n        nWtime = 7776000;        \r\n        genesisReward = (10**uint256(decimals)); // \u00d6d\u00fcl Miktar\u0131\r\n        maximumTarget = 100  * 10 ** uint256(decimals);\r\n        fundsWallet = msg.sender;\r\n        premined = 73005 * 10 ** uint256(decimals);\r\n        balanceOf[msg.sender] = premined;\r\n        balanceOf[address(this)] = initialSupply;\r\n        totalSupply =  initialSupply + premined;\r\n        name = tokenName;\r\n        symbol = tokenSymbol;\r\n    }\r\n\r\n    function _transfer(address _from, address _to, uint _value) internal {\r\n        require(_to != address(0x0));\r\n        require(balanceOf[_from] >= _value);\r\n        require(balanceOf[_to] + _value >= balanceOf[_to]);\r\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\r\n        balanceOf[_from] -= _value;\r\n        balanceOf[_to] += _value;\r\n        emit Transfer(_from, _to, _value);\r\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        _transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\r\n        allowance[_from][msg.sender] -= _value;\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public\r\n        returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)\r\n        public\r\n        returns (bool success) {\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, address(this), _extraData);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function burn(uint256 _value) public returns (bool success) {\r\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\r\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\r\n        totalSupply -= _value;                      // Updates totalSupply\r\n        emit Burn(msg.sender, _value);\r\n        return true;\r\n    }\r\n\r\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\r\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\r\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\r\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\r\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\r\n        totalSupply -= _value;                              // Update totalSupply\r\n        emit Burn(_from, _value);\r\n        return true;\r\n    }\r\n\r\n    function uintToString(uint256 v) internal pure returns(string memory str) {\r\n        uint maxlength = 100;\r\n        bytes memory reversed = new bytes(maxlength);\r\n        uint i = 0;\r\n        while (v != 0) {\r\n            uint remainder = v % 10;\r\n            v = v / 10;\r\n            reversed[i++] = byte(uint8(48 + remainder));\r\n        }\r\n        bytes memory s = new bytes(i + 1);\r\n        for (uint j = 0; j <= i; j++) {\r\n            s[j] = reversed[i - j];\r\n        }\r\n        str = string(s);\r\n    }\r\n\r\n    function append(string memory a, string memory b) internal pure returns (string memory) {\r\n        return string(abi.encodePacked(a,\"-\",b));\r\n    }\r\n   \r\n\r\n    function getCurrentBlockHash() public view returns (uint256) {\r\n            return uint256(blockhash(block.number-1));\r\n    }\r\n\r\n    function getBlockHashAlgoritm(uint256 _blocknumber) public view returns(uint256, uint256){\r\n        uint256 crew = uint256(blockhash(_blocknumber)) % nRewarMod;\r\n        return (crew, block.number-1);\r\n    }\r\n\r\n    function checkBlockReward() public view returns (uint256, uint256) {\r\n        uint256 crew = uint256(blockhash(block.number-1)) % nRewarMod;\r\n        return (crew, block.number-1);\r\n    }\r\n\r\n    struct stakeInfo {\r\n      uint256 _stocktime;\r\n      uint256 _stockamount;\r\n    }\r\n\r\n    address[] totalminers;\r\n\r\n    mapping (address => stakeInfo) nStockDetails;\r\n\r\n    struct rewarddetails {\r\n        uint256 _artyr;\r\n        bool _didGetReward;\r\n        bool _didisign;\r\n    }\r\n\r\n    mapping (string => rewarddetails) nRewardDetails;\r\n\r\n    struct nBlockDetails {\r\n        uint256 _bTime;\r\n        uint256 _tInvest;\r\n    }\r\n\r\n    mapping (uint256 => nBlockDetails) bBlockIteration;\r\n\r\n    struct activeMiners {\r\n        address bUser;\r\n    }\r\n\r\n    mapping(uint256 => activeMiners[]) aMiners;\r\n\r\n\r\n    function totalMinerCount() view public returns (uint256) {\r\n        return totalminers.length;\r\n    }\r\n\r\n\r\n    function addressHashs() view public returns (uint256) {\r\n        return uint256(msg.sender) % 10000000000;\r\n    }    \r\n\r\n\r\n    function stakerStatus(address _addr) view public returns(bool){\r\n\r\n        if(nStockDetails[_addr]._stocktime == 0)\r\n        {\r\n            return false;\r\n        }\r\n        else \r\n        {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function stakerAmount(address _addr) view public returns(uint256){\r\n\r\n        if(nStockDetails[_addr]._stocktime == 0)\r\n        {\r\n            return 0;\r\n        } \r\n        else \r\n        {\r\n            return nStockDetails[_addr]._stockamount;\r\n        }\r\n    }\r\n\r\n    function stakerTimeStart(address _addr) view public returns(uint256){\r\n\r\n        return nStockDetails[_addr]._stocktime;\r\n    }\r\n\r\n\r\n    function stakerActiveTotal() view public returns(uint256) {\r\n        return aMiners[lastBlock].length; \r\n    }\r\n   \r\n   \r\n    function generalCheckPoint()  private view returns(string memory) {\r\n       return append(uintToString(addressHashs()),uintToString(lastBlock));\r\n    }  \r\n    \r\n   \r\n    function necessarySignForReward(uint256 _bnumber) public returns (uint256)  { \r\n       require(stakerStatus(msg.sender) == true);\r\n       require((block.number-1) - _bnumber  <= 200);        \r\n       require(nStockDetails[msg.sender]._stocktime + nWtime > now);   \r\n       require(uint256(blockhash(_bnumber)) % nRewarMod == 1);\r\n       \r\n       if(bBlockIteration[lastBlock]._bTime + 1800 < now)       \r\n       {\r\n           lastBlock += 1;\r\n           bBlockIteration[lastBlock]._bTime = now;\r\n       }\r\n       require(nRewardDetails[generalCheckPoint()]._artyr == 0);\r\n\r\n       bBlockIteration[lastBlock]._tInvest += nStockDetails[msg.sender]._stockamount;\r\n       nRewardDetails[generalCheckPoint()]._artyr = now;\r\n       nRewardDetails[generalCheckPoint()]._didGetReward = false;\r\n       nRewardDetails[generalCheckPoint()]._didisign = true;\r\n       aMiners[lastBlock].push(activeMiners(msg.sender));\r\n       return 200;\r\n   }\r\n\r\n   \r\n   function rewardGet(uint256 _bnumber) public returns(uint256) { \r\n       require(stakerStatus(msg.sender) == true);\r\n       require((block.number-1) - _bnumber  > 200);        \r\n       require(uint256(blockhash(_bnumber)) % nRewarMod == 1);\r\n       require(nStockDetails[msg.sender]._stocktime + nWtime > now  ); \r\n       require(nRewardDetails[generalCheckPoint()]._didGetReward == false);\r\n       require(nRewardDetails[generalCheckPoint()]._didisign == true);\r\n       \r\n       uint256 halving = lastBlock / 365;   \r\n       \r\n\r\n       uint256 totalRA = 128 * genesisReward;\r\n       \r\n       if(halving==0)\r\n       {\r\n           totalRA = 128 * genesisReward;\r\n       }\r\n       else if(halving==1)\r\n       {\r\n           totalRA = 256 * genesisReward;\r\n       }\r\n       else if(halving==2)\r\n       {\r\n           totalRA = 512 * genesisReward;\r\n       }\r\n       else if(halving==3)\r\n       {\r\n           totalRA = 1024 * genesisReward;\r\n       }\r\n       else if(halving==4)\r\n       {\r\n           totalRA = 2048 * genesisReward;\r\n       }\r\n       else if(halving==5)\r\n       {\r\n           totalRA = 4096 * genesisReward;\r\n       }\r\n       else if(halving==6)\r\n       {\r\n           totalRA = 8192 * genesisReward;\r\n       }\r\n       else if(halving==7)\r\n       {\r\n           totalRA = 4096 * genesisReward;\r\n       }\r\n       else if(halving==8)\r\n       {\r\n           totalRA = 2048 * genesisReward;\r\n       }\r\n       else if(halving==9)\r\n       {\r\n           totalRA = 1024 * genesisReward;\r\n       }\r\n       else if(halving==10)\r\n       {\r\n           totalRA = 512 * genesisReward;\r\n       }\r\n       else if(halving==11)\r\n       {\r\n           totalRA = 256 * genesisReward;\r\n       }\r\n       else if(halving==12)\r\n       {\r\n           totalRA = 128 * genesisReward;\r\n       }\r\n       else if(halving==13)\r\n       {\r\n           totalRA = 64 * genesisReward;\r\n       }\r\n       else if(halving==14)\r\n       {\r\n           totalRA = 32 * genesisReward;\r\n       }\r\n       else if(halving==15)\r\n       {\r\n           totalRA = 16 * genesisReward;\r\n       }\r\n       else if(halving==16)\r\n       {\r\n           totalRA = 8 * genesisReward;\r\n       }\r\n       else if(halving==17)\r\n       {\r\n           totalRA = 4 * genesisReward;\r\n       }\r\n       else if(halving==18)\r\n       {\r\n           totalRA = 2 * genesisReward;\r\n       }\r\n       else if(halving==19)\r\n       {\r\n           totalRA = 1 * genesisReward;\r\n       }\r\n       else if(halving>19)\r\n       {\r\n           totalRA = 1 * genesisReward;\r\n       }\r\n\r\n       uint256 usersReward = (totalRA * (nStockDetails[msg.sender]._stockamount * 100) / bBlockIteration[lastBlock]._tInvest) /  100;\r\n       nRewardDetails[generalCheckPoint()]._didGetReward = true;\r\n       _transfer(address(this), msg.sender, usersReward);\r\n       return usersReward;\r\n   }\r\n\r\n   function startMining(uint256 mineamount) public returns (uint256) {\r\n\r\n      uint256 realMineAmount = mineamount * 10 ** uint256(decimals);     \r\n      require(realMineAmount >= 10 * 10 ** uint256(decimals)); \r\n      require(nStockDetails[msg.sender]._stocktime == 0);     \r\n      maximumTarget +=  realMineAmount;\r\n      nStockDetails[msg.sender]._stocktime = now;\r\n      nStockDetails[msg.sender]._stockamount = realMineAmount;\r\n      totalminers.push(msg.sender);\r\n      _transfer(msg.sender, address(this), realMineAmount);\r\n      return 200;\r\n   }\r\n\r\n   function tokenPayBack() public returns(uint256) {\r\n       require(stakerStatus(msg.sender) == true);\r\n       require(nStockDetails[msg.sender]._stocktime + nWtime < now  );\r\n       nStockDetails[msg.sender]._stocktime = 0;\r\n       _transfer(address(this),msg.sender,nStockDetails[msg.sender]._stockamount);\r\n       return nStockDetails[msg.sender]._stockamount;\r\n   }\r\n\r\n   struct memoInfo {\r\n       uint256 _receiveTime;\r\n       uint256 _receiveAmount;\r\n       address _senderAddr;\r\n       string _senderMemo;\r\n   }\r\n\r\n  mapping(address => memoInfo[]) memoGetProcess;\r\n\r\n  function sendMemoToken(uint256 _amount, address _to, string memory _memo)  public returns(uint256) {\r\n      memoGetProcess[_to].push(memoInfo(now, _amount, msg.sender, _memo));\r\n      _transfer(msg.sender, _to, _amount);\r\n      return 200;\r\n  }\r\n\r\n  function sendMemoOnly(address _to, string memory _memo)  public returns(uint256) {\r\n      memoGetProcess[_to].push(memoInfo(now,0, msg.sender, _memo));\r\n      _transfer(msg.sender, _to, 0);\r\n      return 200;\r\n  }\r\n\r\n\r\n  function yourMemos(address _addr, uint256 _index) view public returns(uint256,\r\n   uint256,\r\n   string memory,\r\n   address) {\r\n\r\n       uint256 rTime = memoGetProcess[_addr][_index]._receiveTime;\r\n       uint256 rAmount = memoGetProcess[_addr][_index]._receiveAmount;\r\n       string memory sMemo = memoGetProcess[_addr][_index]._senderMemo;\r\n       address sAddr = memoGetProcess[_addr][_index]._senderAddr;\r\n       if(memoGetProcess[_addr][_index]._receiveTime == 0){\r\n            return (0, 0,\"0\", _addr);\r\n       }else {\r\n            return (rTime, rAmount,sMemo, sAddr);\r\n       }\r\n  }\r\n\r\n\r\n   function yourMemosCount(address _addr) view public returns(uint256) {\r\n       return  memoGetProcess[_addr].length;\r\n   }\r\n\r\n   function appendMemos(string memory a, string memory b,string memory c,string memory d) internal pure returns (string memory) {\r\n        return string(abi.encodePacked(a,\"#\",b,\"#\",c,\"#\",d));\r\n   }\r\n\r\n   function addressToString(address _addr) public pure returns(string memory) {\r\n    bytes32 value = bytes32(uint256(_addr));\r\n    bytes memory alphabet = \"0123456789abcdef\";\r\n\r\n    bytes memory str = new bytes(51);\r\n    str[0] = \"0\";\r\n    str[1] = \"x\";\r\n    for (uint i = 0; i < 20; i++) {\r\n        str[2+i*2] = alphabet[uint(uint8(value[i + 12] >> 4))];\r\n        str[3+i*2] = alphabet[uint(uint8(value[i + 12] & 0x0f))];\r\n    }\r\n    return string(str);\r\n}\r\n\r\n   function getYourMemosOnly(address _addr) view public returns(string[] memory) {\r\n       \r\n       uint total =  memoGetProcess[_addr].length;\r\n       string[] memory messages = new string[](total);\r\n      \r\n       for (uint i=0; i < total; i++) {\r\n             \r\n            messages[i] = appendMemos(uintToString(memoGetProcess[_addr][i]._receiveTime),memoGetProcess[_addr][i]._senderMemo,uintToString(memoGetProcess[_addr][i]._receiveAmount),addressToString(memoGetProcess[_addr][i]._senderAddr));\r\n       }\r\n\r\n       return messages;\r\n   }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"initialSupply\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"tokenName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"tokenSymbol\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"addressHashs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"addressToString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkBlockReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundsWallet\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"genesisReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_blocknumber\",\"type\":\"uint256\"}],\"name\":\"getBlockHashAlgoritm\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentBlockHash\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getYourMemosOnly\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maximumTarget\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nRewarMod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nWtime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bnumber\",\"type\":\"uint256\"}],\"name\":\"necessarySignForReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"premined\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bnumber\",\"type\":\"uint256\"}],\"name\":\"rewardGet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardTimes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_memo\",\"type\":\"string\"}],\"name\":\"sendMemoOnly\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_memo\",\"type\":\"string\"}],\"name\":\"sendMemoToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakerActiveTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"stakerAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"stakerStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"stakerTimeStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mineamount\",\"type\":\"uint256\"}],\"name\":\"startMining\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenPayBack\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalMinerCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"yourMemos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"yourMemosCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "StarkChain", "CompilerVersion": "v0.6.0+commit.26b70077", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000759af0675d23d85c00000000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000b537461726b20436861696e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005535441524b000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://1e48d952109170ce51fd297070739e448f0c2dd98c044781f72c23739afcd2c4"}