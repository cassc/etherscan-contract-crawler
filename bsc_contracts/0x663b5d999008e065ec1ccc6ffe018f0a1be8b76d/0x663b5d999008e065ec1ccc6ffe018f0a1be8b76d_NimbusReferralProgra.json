{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/NimbusReferralProgramLogic.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\ninterface IBEP20 {\\n    function totalSupply() external view returns (uint256);\\n    function decimals() external view returns (uint8);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    function getOwner() external view returns (address);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\ninterface IWBNB {\\n    function deposit() external payable;\\n    function transfer(address to, uint value) external returns (bool);\\n    function withdraw(uint) external;\\n}\\n\\nlibrary Address {\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n}\\n\\ncontract Ownable {\\n    address public owner;\\n    address public newOwner;\\n\\n    event OwnershipTransferred(address indexed from, address indexed to);\\n\\n    constructor() {\\n        owner = msg.sender;\\n        emit OwnershipTransferred(address(0), owner);\\n    }\\n\\n    modifier onlyOwner {\\n        require(msg.sender == owner, \\\"Ownable: Caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function getOwner() external view returns (address) {\\n        return owner;\\n    }\\n\\n    function transferOwnership(address transferOwner) external onlyOwner {\\n        require(transferOwner != newOwner);\\n        newOwner = transferOwner;\\n    }\\n\\n    function acceptOwnership() virtual external {\\n        require(msg.sender == newOwner);\\n        emit OwnershipTransferred(owner, newOwner);\\n        owner = newOwner;\\n        newOwner = address(0);\\n    }\\n}\\n\\ninterface INimbusReferralProgram {\\n    function userSponsor(uint user) external view returns (uint);\\n    function userSponsorByAddress(address user) external view returns (uint);\\n    function userIdByAddress(address user) external view returns (uint);\\n    function userAddressById(uint id) external view returns (address);\\n    function userSponsorAddressByAddress(address user) external view returns (address);\\n}\\n\\ncontract NimbusReferralProgramLogic is Ownable { \\n    INimbusReferralProgram public immutable users;\\n    IWBNB public WBNB;\\n\\n    uint[] public levels;\\n    uint public maxLevel;\\n    uint256 public totalFeePercent;\\n\\n    mapping(address => mapping(uint => uint)) private _undistributedFees;\\n    mapping(address => uint) private _recordedBalances;\\n\\n    address public specialReserveFund;\\n\\n    event DistributeFees(address indexed token, uint indexed userId, uint amount);\\n    event DistributeFeesForUser(address indexed token, uint indexed recipientId, uint amount);\\n    event ClaimEarnedFunds(address indexed token, uint indexed userId, uint unclaimedAmount);\\n    event TransferToNimbusSpecialReserveFund(address indexed token, uint indexed fromUserId, uint undistributedAmount);\\n    event UpdateLevels(uint totalFeePercent, uint[] newLevels);\\n    event UpdateSpecialReserveFund(address newSpecialReserveFund);\\n    event Rescue(address indexed to, uint amount);\\n\\n    uint private unlocked = 1;\\n    modifier lock() {\\n        require(unlocked == 1, 'Nimbus Referral: LOCKED');\\n        unlocked = 0;\\n        _;\\n        unlocked = 1;\\n    }\\n\\n    constructor(address referralUsers, address wbnb)  {\\n        require(referralUsers != address(0) && wbnb != address(0), \\\"Nimbus Referral: Address is zero\\\");\\n        require(Address.isContract(referralUsers) && Address.isContract(wbnb), \\\"Nimbus Referral: Address is not contract\\\");\\n        levels = [600, 300, 200, 150, 150, 100];   // amount * levels[line] / totalFeePercent\\n        totalFeePercent = 1500;\\n        maxLevel = levels.length;\\n        WBNB = IWBNB(wbnb);\\n        users = INimbusReferralProgram(referralUsers);\\n    }\\n\\n    function undistributedFees(address token, uint userId) external view returns (uint) {\\n        return _undistributedFees[token][userId];\\n    }\\n\\n    receive() external payable {\\n            \\n    }\\n\\n    function recordFee(address token, address recipient, uint amount) external lock { \\n        uint actualBalance = IBEP20(token).balanceOf(address(this));\\n        require(actualBalance - amount >= _recordedBalances[token], \\\"Nimbus Referral: Balance check failed\\\");\\n        if (Address.isContract(recipient)) recipient = tx.origin;\\n        uint uiserId = users.userIdByAddress(recipient);\\n        if (users.userSponsor(uiserId) == 0) uiserId = 0;\\n        _undistributedFees[token][uiserId] += amount;\\n        _recordedBalances[token] = actualBalance;\\n    }\\n\\n    function distributeEarnedFees(address token, uint userId) external lock {\\n        if (_undistributedFees[token][userId] > 0) distributeFees(token, userId);\\n        uint callerId = users.userIdByAddress(msg.sender);\\n        if (_undistributedFees[token][callerId] > 0) distributeFees(token, callerId);\\n    }\\n\\n    function distributeEarnedFees(address token, uint[] memory userIds) external lock {\\n        for (uint i; i < userIds.length; i++) {\\n            if (_undistributedFees[token][userIds[i]] > 0) distributeFees(token, userIds[i]);\\n        }\\n        \\n        uint callerId = users.userIdByAddress(msg.sender);\\n        if (_undistributedFees[token][callerId] > 0) distributeFees(token, callerId);\\n    }\\n\\n    function distributeEarnedFees(address[] memory tokens, uint userId) external lock {\\n        uint callerId = users.userIdByAddress(msg.sender);\\n        for (uint i; i < tokens.length; i++) {\\n            if (_undistributedFees[tokens[i]][userId] > 0) distributeFees(tokens[i], userId);\\n            if (_undistributedFees[tokens[i]][callerId] > 0) distributeFees(tokens[i], callerId);\\n        }\\n    }\\n    \\n    function distributeFees(address token, uint userId) private {\\n        require(_undistributedFees[token][userId] > 0, \\\"Nimbus Referral: Undistributed fee is 0\\\");\\n        uint amount = _undistributedFees[token][userId];\\n        if (token == address(WBNB) && IBEP20(address(WBNB)).balanceOf(address(this)) >= amount) {\\n            WBNB.withdraw(amount);\\n            _recordedBalances[token] = _recordedBalances[token] - amount;\\n        }\\n        uint level = transferToSponsor(token, userId, amount, 0, 0); \\n\\n        if (level < maxLevel) {\\n            uint undistributedPercentage;\\n            for (uint ii = level; ii < maxLevel; ii++) {\\n                undistributedPercentage += levels[ii];\\n            }\\n            uint undistributedAmount = amount * undistributedPercentage / totalFeePercent;\\n            _undistributedFees[token][0] += undistributedAmount;\\n            emit TransferToNimbusSpecialReserveFund(token, userId, undistributedAmount);\\n        }\\n\\n        emit DistributeFees(token, userId, amount);\\n        _undistributedFees[token][userId] = 0;\\n    }\\n\\n    function transferToSponsor(address token, uint userId, uint amount, uint level, uint levelGuard) private returns (uint) {\\n        if (level >= maxLevel) return maxLevel;\\n        uint sponsorId = users.userSponsor(userId);\\n        if (sponsorId <= 1000000001) return level;\\n        address sponsorAddress = users.userAddressById(sponsorId);\\n        uint bonusAmount = amount * levels[level] / totalFeePercent;\\n        if (token == address(WBNB)) {\\n            if (Address.isContract(sponsorAddress)) {\\n                WBNB.deposit{value: bonusAmount}();\\n                TransferHelper.safeTransfer(token, sponsorAddress, bonusAmount);\\n            }\\n            else TransferHelper.safeTransferBNB(sponsorAddress, bonusAmount);\\n        } else {\\n            TransferHelper.safeTransfer(token, sponsorAddress, bonusAmount);\\n            _recordedBalances[token] = _recordedBalances[token] - bonusAmount;\\n        }\\n        emit DistributeFeesForUser(token, sponsorId, bonusAmount);\\n        return transferToSponsor(token, sponsorId, amount, ++level, ++levelGuard);         \\n    }\\n\\n    function calculateRewardsDistribution(address token, uint userId) public view returns(uint[] memory) {\\n        uint[] memory rewards = new uint[](levels.length);\\n        uint amount = _undistributedFees[token][userId];\\n        for (uint i; i < levels.length; i++) {\\n            rewards[i] = amount * levels[i] / totalFeePercent;\\n        }\\n        return rewards;\\n    }\\n\\n    function claimSpecialReserveFundBatch(address[] memory tokens) external onlyOwner {\\n        for (uint i; i < tokens.length; i++) {\\n            claimSpecialReserveFund(tokens[i]);\\n        }\\n    }\\n\\n    function claimSpecialReserveFund(address token) public onlyOwner {\\n        uint amount = _undistributedFees[token][0]; \\n        require(amount > 0, \\\"Nimbus Referral: No unclaimed funds for selected token\\\");\\n        TransferHelper.safeTransfer(token, specialReserveFund, amount);\\n        _recordedBalances[token] -= amount;\\n        _undistributedFees[token][0] = 0;\\n    }\\n\\n    function updateWBNB(address newWBNB) external onlyOwner {\\n        require(newWBNB != address(0) && Address.isContract(newWBNB), \\\"Nimbus Referral: Address is zero or not contract\\\");\\n        WBNB = IWBNB(newWBNB);\\n    }\\n    \\n    function updateSpecialReserveFund(address newSpecialReserveFund) external onlyOwner {\\n        require(newSpecialReserveFund != address(0), \\\"Nimbus Referral: Address is zero\\\");\\n        specialReserveFund = newSpecialReserveFund;\\n        emit UpdateSpecialReserveFund(newSpecialReserveFund);\\n    }\\n\\n    function updateLevels(uint[] memory newLevels, uint newTotalFeePercent) external onlyOwner {\\n        uint checkSum;\\n        for (uint i; i < newLevels.length; i++) {\\n            checkSum += newLevels[i];\\n        }\\n        require(checkSum == newTotalFeePercent, \\\"Nimbus Referral: Wrong levels amounts\\\");\\n        levels = newLevels;\\n        maxLevel = newLevels.length;\\n        totalFeePercent = newTotalFeePercent;\\n        emit UpdateLevels(newTotalFeePercent, newLevels);\\n    }\\n\\n    function rescueBNB(address payable to, uint256 amount) external onlyOwner {\\n        require(to != address(0), \\\"Nimbus Referral: Cannot rescue to the zero address\\\");\\n        require(amount > 0, \\\"Nimbus Referral: Cannot rescue 0\\\");\\n\\n        to.transfer(amount);\\n        emit Rescue(to, amount);\\n    }\\n}\\n\\n//helper methods for interacting with BEP20 tokens and sending BNB that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(address token, address to, uint value) internal {\\n        //bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\\n    }\\n\\n    function safeTransfer(address token, address to, uint value) internal {\\n        //bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\\n    }\\n\\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\\n        //bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\\n    }\\n\\n    function safeTransferBNB(address to, uint value) internal {\\n        (bool success,) = to.call{value:value}(new bytes(0));\\n        require(success, 'TransferHelper: BNB_TRANSFER_FAILED');\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referralUsers\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wbnb\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"userId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unclaimedAmount\",\"type\":\"uint256\"}],\"name\":\"ClaimEarnedFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"userId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DistributeFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"recipientId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DistributeFeesForUser\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Rescue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fromUserId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"undistributedAmount\",\"type\":\"uint256\"}],\"name\":\"TransferToNimbusSpecialReserveFund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalFeePercent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"newLevels\",\"type\":\"uint256[]\"}],\"name\":\"UpdateLevels\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newSpecialReserveFund\",\"type\":\"address\"}],\"name\":\"UpdateSpecialReserveFund\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"WBNB\",\"outputs\":[{\"internalType\":\"contract IWBNB\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"userId\",\"type\":\"uint256\"}],\"name\":\"calculateRewardsDistribution\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"claimSpecialReserveFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"claimSpecialReserveFundBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"userIds\",\"type\":\"uint256[]\"}],\"name\":\"distributeEarnedFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"userId\",\"type\":\"uint256\"}],\"name\":\"distributeEarnedFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"userId\",\"type\":\"uint256\"}],\"name\":\"distributeEarnedFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"levels\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"recordFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rescueBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"specialReserveFund\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFeePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"transferOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"userId\",\"type\":\"uint256\"}],\"name\":\"undistributedFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"newLevels\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"newTotalFeePercent\",\"type\":\"uint256\"}],\"name\":\"updateLevels\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newSpecialReserveFund\",\"type\":\"address\"}],\"name\":\"updateSpecialReserveFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWBNB\",\"type\":\"address\"}],\"name\":\"updateWBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"users\",\"outputs\":[{\"internalType\":\"contract INimbusReferralProgram\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "NimbusReferralProgramLogic", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000008a1d859110cf6c5a93538c258bb6eeb6bcb4a0bf000000000000000000000000a2ca18fc541b7b101c64e64bbc2834b05066248b", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}