{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"LockedEPX.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n\\nimport \\\"Ownable.sol\\\";\\nimport \\\"IERC20.sol\\\";\\nimport \\\"IBondedFeeDistributor.sol\\\";\\nimport \\\"IEpsProxy.sol\\\";\\nimport \\\"ITokenLocker.sol\\\";\\n\\n\\ncontract LockedEPX is IERC20, Ownable {\\n\\n    string public constant symbol = \\\"dEPX\\\";\\n    string public constant name = \\\"DotDot Tokenized EPX Lock\\\";\\n    uint8 public constant decimals = 18;\\n    uint256 public override totalSupply;\\n\\n    mapping(address => uint256) public override balanceOf;\\n    mapping(address => mapping(address => uint256)) public override allowance;\\n    mapping(address => bool) public blockThirdPartyActions;\\n\\n    IERC20 public immutable EPX;\\n    ITokenLocker public immutable epsLocker;\\n\\n    IBondedFeeDistributor public bondedDistributor;\\n    IEllipsisProxy public proxy;\\n\\n    uint256 constant WEEK = 604800;\\n    uint256 immutable MAX_LOCK_WEEKS;\\n    uint256 lastLockWeek;\\n\\n    event Deposit(address indexed caller, address indexed receiver, uint256 amount, bool bond);\\n    event ExtendLocks(uint256 lastLockWeek);\\n\\n    constructor(\\n        IERC20 _EPX,\\n        ITokenLocker _epsLocker\\n    ) {\\n        EPX = _EPX;\\n\\n        epsLocker = _epsLocker;\\n        MAX_LOCK_WEEKS = _epsLocker.MAX_LOCK_WEEKS();\\n        lastLockWeek = block.timestamp / WEEK;\\n        emit Transfer(address(0), msg.sender, 0);\\n    }\\n\\n    function setAddresses(\\n        IBondedFeeDistributor _bondedDistributor,\\n        IEllipsisProxy _proxy\\n    ) external onlyOwner {\\n        bondedDistributor = _bondedDistributor;\\n        proxy = _proxy;\\n\\n        renounceOwnership();\\n    }\\n\\n    function setBlockThirdPartyActions(bool _block) external {\\n        blockThirdPartyActions[msg.sender] = _block;\\n    }\\n\\n    function approve(address _spender, uint256 _value) external override returns (bool) {\\n        allowance[msg.sender][_spender] = _value;\\n        emit Approval(msg.sender, _spender, _value);\\n        return true;\\n    }\\n\\n    /** shared logic for transfer and transferFrom */\\n    function _transfer(address _from, address _to, uint256 _value) internal {\\n        require(balanceOf[_from] >= _value, \\\"Insufficient balance\\\");\\n        balanceOf[_from] -= _value;\\n        balanceOf[_to] += _value;\\n        emit Transfer(_from, _to, _value);\\n    }\\n\\n    /**\\n        @notice Transfer tokens to a specified address\\n        @param _to The address to transfer to\\n        @param _value The amount to be transferred\\n        @return bool Success\\n     */\\n    function transfer(address _to, uint256 _value) public override returns (bool) {\\n        _transfer(msg.sender, _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n        @notice Transfer tokens from one address to another\\n        @param _from The address which you want to send tokens from\\n        @param _to The address which you want to transfer to\\n        @param _value The amount of tokens to be transferred\\n        @return bool Success\\n     */\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    )\\n        public\\n        override\\n        returns (bool)\\n    {\\n        uint256 allowed = allowance[_from][msg.sender];\\n        require(allowed >= _value, \\\"Insufficient allowance\\\");\\n        if (allowed != type(uint256).max) {\\n            allowance[_from][msg.sender] = allowed - _value;\\n        }\\n        _transfer(_from, _to, _value);\\n        return true;\\n    }\\n\\n    /**\\n        @notice Lock EPX and receive dEPX\\n        @param _receiver Address to receive the minted dEPX\\n        @param _amount Amount of EPX to lock. The balance is transferred from the caller.\\n        @param _bond If true, minted dEPX is immediately deposited in `BondedFeeDistributor`\\n        @return bool Success\\n     */\\n    function deposit(address _receiver, uint256 _amount, bool _bond) external returns (bool) {\\n        if (msg.sender != _receiver) {\\n            require(!blockThirdPartyActions[_receiver], \\\"Cannot deposit on behalf of this account\\\");\\n        }\\n        extendLock();\\n        EPX.transferFrom(msg.sender, address(proxy), _amount);\\n        proxy.lock(_amount);\\n        totalSupply += _amount;\\n        if (_bond) {\\n            balanceOf[address(bondedDistributor)] += _amount;\\n            emit Transfer(address(0), address(bondedDistributor), _amount);\\n            bondedDistributor.deposit(_receiver, _amount);\\n        } else {\\n            balanceOf[_receiver] += _amount;\\n            emit Transfer(address(0), _receiver, _amount);\\n        }\\n        emit Deposit(msg.sender, _receiver, _amount, _bond);\\n        return true;\\n    }\\n\\n    /**\\n        @notice Extend all dEPX locks to the maximum lock weeks\\n        @dev This function is called once per week by `deposit`, which in turn is called\\n             daily by `LpDepositor`. With normal protocol usage there should never be a\\n             requirement to manually extend locks.\\n     */\\n    function extendLock() public returns (bool) {\\n        if (lastLockWeek < block.timestamp / WEEK) {\\n            uint256[2][] memory locks = epsLocker.getActiveUserLocks(address(proxy));\\n            for (uint i = 0; i < locks.length; i++) {\\n                (uint256 week, uint256 amount) = (locks[i][0], locks[i][1]);\\n                if (week < MAX_LOCK_WEEKS) proxy.extendLock(amount, week);\\n            }\\n            lastLockWeek = block.timestamp / WEEK;\\n            emit ExtendLocks(block.timestamp / WEEK);\\n        }\\n        return true;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable {\\n    address public owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = owner;\\n        owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.12;\\n\\n/**\\n * Based on the OpenZeppelin IER20 interface:\\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\\n *\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"IBondedFeeDistributor.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n\\ninterface IBondedFeeDistributor {\\n    function notifyFeeAmounts(uint256 _epxAmount, uint256 _dddAmount) external returns (bool);\\n    function deposit(address _user, uint256 _amount) external returns (bool);\\n}\"\r\n    },\r\n    \"IEpsProxy.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n\\ninterface IEllipsisProxy {\\n    function lock(uint256 _amount) external returns (bool);\\n    function extendLock(uint256 _amount, uint256 _weeks) external returns (bool);\\n    function deposit(address _token, uint256 _amount) external returns (uint256);\\n    function withdraw(address _receiver, address _token, uint256 _amount) external returns (uint256);\\n    function claimEmissions(address _token) external returns (uint256);\\n    function claimFees(address[] calldata _tokens) external returns (bool);\\n    function vote(address[] calldata _tokens, uint256[] calldata _votes) external returns (bool);\\n    function createTokenApprovalVote(address _token) external returns (uint256 _voteIndex);\\n    function voteForTokenApproval(uint256 _voteIndex, uint256 _yesVotes) external returns (bool);\\n    function getReward(address _lpToken, address[] calldata _rewards) external returns (bool);\\n}\"\r\n    },\r\n    \"ITokenLocker.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n\\n\\ninterface ITokenLocker {\\n\\n    function MAX_LOCK_WEEKS() external view returns (uint256);\\n    function getWeek() external view returns (uint256);\\n    function userWeight(address _user) external view returns (uint256);\\n    function totalWeight() external view returns (uint256);\\n    function weeklyWeight(address _user, uint256 _week) external view returns (uint256, uint256);\\n    function startTime() external view returns (uint256);\\n    function weeklyTotalWeight(uint256 week) external view returns (uint256);\\n    function weeklyWeightOf(address user, uint256 week) external view returns (uint256);\\n\\n    /**\\n        @notice Get data on a user's active token locks\\n        @param _user Address to query data for\\n        @return lockData dynamic array of [weeks until expiration, balance of lock]\\n     */\\n    function getActiveUserLocks(address _user) external view returns (uint256[2][] memory lockData);\\n\\n    /**\\n        @notice Allow or block third-party calls to deposit, withdraw\\n                or claim rewards on behalf of the caller\\n     */\\n    function setBlockThirdPartyActions(bool _block) external;\\n\\n    /**\\n        @notice Deposit tokens into the contract to create a new lock.\\n        @param _user Address to create a new lock for (does not have to be the caller)\\n        @param _amount Amount of tokens to lock. This balance transfered from the caller.\\n        @param _weeks The number of weeks for the lock.\\n     */\\n    function lock(\\n        address _user,\\n        uint256 _amount,\\n        uint256 _weeks\\n    ) external returns (bool);\\n\\n    /**\\n        @notice Extend the length of an existing lock.\\n        @param _amount Amount of tokens to extend the lock for.\\n        @param _weeks The number of weeks for the lock that is being extended.\\n        @param _newWeeks The number of weeks to extend the lock until.\\n     */\\n    function extendLock(\\n        uint256 _amount,\\n        uint256 _weeks,\\n        uint256 _newWeeks\\n    ) external returns (bool);\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {\r\n      \"LockedEPX.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_EPX\",\"type\":\"address\"},{\"internalType\":\"contract ITokenLocker\",\"name\":\"_epsLocker\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"bond\",\"type\":\"bool\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastLockWeek\",\"type\":\"uint256\"}],\"name\":\"ExtendLocks\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"EPX\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"blockThirdPartyActions\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bondedDistributor\",\"outputs\":[{\"internalType\":\"contract IBondedFeeDistributor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_bond\",\"type\":\"bool\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epsLocker\",\"outputs\":[{\"internalType\":\"contract ITokenLocker\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"extendLock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxy\",\"outputs\":[{\"internalType\":\"contract IEllipsisProxy\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IBondedFeeDistributor\",\"name\":\"_bondedDistributor\",\"type\":\"address\"},{\"internalType\":\"contract IEllipsisProxy\",\"name\":\"_proxy\",\"type\":\"address\"}],\"name\":\"setAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_block\",\"type\":\"bool\"}],\"name\":\"setBlockThirdPartyActions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LockedEPX", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000af41054c1487b0e5e2b9250c0332ecbce6ce9d7100000000000000000000000022a93f53a0a3e6847d05dd504283e8e296a49aae", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}