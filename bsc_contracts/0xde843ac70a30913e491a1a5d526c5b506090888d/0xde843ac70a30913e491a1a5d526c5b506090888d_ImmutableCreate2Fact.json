{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.18;\r\n\r\n/**\r\n * @title Immutable Create2 Contract Factory\r\n * @author 0age\r\n * @notice This contract provides a safeCreate2 function that takes a salt value\r\n * and a block of initialization code as arguments and passes them into inline\r\n * assembly. The contract prevents redeploys by maintaining a mapping of all\r\n * contracts that have already been deployed, and prevents frontrunning or other\r\n * collisions by requiring that the first 20 bytes of the salt are equal to the\r\n * address of the caller (this can be bypassed by setting the first 20 bytes to\r\n * the null address). There is also a view function that computes the address of\r\n * the contract that will be created when submitting a given salt or nonce along\r\n * with a given block of initialization code.\r\n * @dev CREATE2 will not be available on mainnet until (at least) block\r\n * 7,280,000. This contract has not yet been fully tested or audited - proceed\r\n * with caution and please share any exploits or optimizations you discover.\r\n */\r\ncontract ImmutableCreate2Factory {\r\n    // mapping to track which addresses have already been deployed.\r\n    mapping(address => bool) private _deployed;\r\n\r\n    /**\r\n     * @dev Create a contract using CREATE2 by submitting a given salt or nonce\r\n     * along with the initialization code for the contract. Note that the first 20\r\n     * bytes of the salt must match those of the calling address, which prevents\r\n     * contract creation events from being submitted by unintended parties.\r\n     * @param salt bytes32 The nonce that will be passed into the CREATE2 call.\r\n     * @param initializationCode bytes The initialization code that will be passed\r\n     * into the CREATE2 call.\r\n     * @return deploymentAddress Address of the contract that will be created, or the null address\r\n     * if a contract already exists at that address.\r\n     */\r\n    function safeCreate2(\r\n        bytes32 salt,\r\n        bytes calldata initializationCode\r\n    )\r\n        external\r\n        payable\r\n        containsCaller(salt)\r\n        returns (address deploymentAddress)\r\n    {\r\n        // move the initialization code from calldata to memory.\r\n        bytes memory initCode = initializationCode;\r\n\r\n        // determine the target address for contract deployment.\r\n        address targetDeploymentAddress = address(\r\n            uint160( // downcast to match the address type.\r\n                uint256( // convert to uint to truncate upper digits.\r\n                    keccak256( // compute the CREATE2 hash using 4 inputs.\r\n                        abi.encodePacked( // pack all inputs to the hash together.\r\n                            hex\"ff\", // start with 0xff to distinguish from RLP.\r\n                            address(this), // this contract will be the caller.\r\n                            salt, // pass in the supplied salt value.\r\n                            keccak256(abi.encodePacked(initCode)) // pass in the hash of initialization code.\r\n                        )\r\n                    )\r\n                )\r\n            )\r\n        );\r\n\r\n        // ensure that a contract hasn't been previously deployed to target address.\r\n        require(\r\n            !_deployed[targetDeploymentAddress],\r\n            \"Invalid contract creation - contract has already been deployed.\"\r\n        );\r\n\r\n        // using inline assembly: load data and length of data, then call CREATE2.\r\n        assembly {\r\n            // solhint-disable-line\r\n            let encoded_data := add(0x20, initCode) // load initialization code.\r\n            let encoded_size := mload(initCode) // load the init code's length.\r\n            deploymentAddress := create2(\r\n                // call CREATE2 with 4 arguments.\r\n                callvalue(), // forward any attached value.\r\n                encoded_data, // pass in initialization code.\r\n                encoded_size, // pass in init code's length.\r\n                salt // pass in the salt value.\r\n            )\r\n        }\r\n\r\n        // check address against target to ensure that deployment was successful.\r\n        require(\r\n            deploymentAddress == targetDeploymentAddress,\r\n            \"Failed to deploy contract using provided salt and initialization code.\"\r\n        );\r\n\r\n        // record the deployment of the contract to prevent redeploys.\r\n        _deployed[deploymentAddress] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Compute the address of the contract that will be created when\r\n     * submitting a given salt or nonce to the contract along with the contract's\r\n     * initialization code. The CREATE2 address is computed in accordance with\r\n     * EIP-1014, and adheres to the formula therein of\r\n     * `keccak256( 0xff ++ address ++ salt ++ keccak256(init_code)))[12:]` when\r\n     * performing the computation. The computed address is then checked for any\r\n     * existing contract code - if so, the null address will be returned instead.\r\n     * @param salt bytes32 The nonce passed into the CREATE2 address calculation.\r\n     * @param initCode bytes The contract initialization code to be used.\r\n     * that will be passed into the CREATE2 address calculation.\r\n     * @return deploymentAddress Address of the contract that will be created, or the null address\r\n     * if a contract has already been deployed to that address.\r\n     */\r\n    function findCreate2Address(\r\n        bytes32 salt,\r\n        bytes calldata initCode\r\n    ) external view returns (address deploymentAddress) {\r\n        // determine the address where the contract will be deployed.\r\n        deploymentAddress = address(\r\n            uint160( // downcast to match the address type.\r\n                uint256( // convert to uint to truncate upper digits.\r\n                    keccak256( // compute the CREATE2 hash using 4 inputs.\r\n                        abi.encodePacked( // pack all inputs to the hash together.\r\n                            hex\"ff\", // start with 0xff to distinguish from RLP.\r\n                            address(this), // this contract will be the caller.\r\n                            salt, // pass in the supplied salt value.\r\n                            keccak256(abi.encodePacked(initCode)) // pass in the hash of initialization code.\r\n                        )\r\n                    )\r\n                )\r\n            )\r\n        );\r\n\r\n        // return null address to signify failure if contract has been deployed.\r\n        if (_deployed[deploymentAddress]) {\r\n            return address(0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Compute the address of the contract that will be created when\r\n     * submitting a given salt or nonce to the contract along with the keccak256\r\n     * hash of the contract's initialization code. The CREATE2 address is computed\r\n     * in accordance with EIP-1014, and adheres to the formula therein of\r\n     * `keccak256( 0xff ++ address ++ salt ++ keccak256(init_code)))[12:]` when\r\n     * performing the computation. The computed address is then checked for any\r\n     * existing contract code - if so, the null address will be returned instead.\r\n     * @param salt bytes32 The nonce passed into the CREATE2 address calculation.\r\n     * @param initCodeHash bytes32 The keccak256 hash of the initialization code\r\n     * that will be passed into the CREATE2 address calculation.\r\n     * @return deploymentAddress Address of the contract that will be created, or the null address\r\n     * if a contract has already been deployed to that address.\r\n     */\r\n    function findCreate2AddressViaHash(\r\n        bytes32 salt,\r\n        bytes32 initCodeHash\r\n    ) external view returns (address deploymentAddress) {\r\n        // determine the address where the contract will be deployed.\r\n        deploymentAddress = address(\r\n            uint160( // downcast to match the address type.\r\n                uint256( // convert to uint to truncate upper digits.\r\n                    keccak256( // compute the CREATE2 hash using 4 inputs.\r\n                        abi.encodePacked( // pack all inputs to the hash together.\r\n                            hex\"ff\", // start with 0xff to distinguish from RLP.\r\n                            address(this), // this contract will be the caller.\r\n                            salt, // pass in the supplied salt value.\r\n                            initCodeHash // pass in the hash of initialization code.\r\n                        )\r\n                    )\r\n                )\r\n            )\r\n        );\r\n\r\n        // return null address to signify failure if contract has been deployed.\r\n        if (_deployed[deploymentAddress]) {\r\n            return address(0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Determine if a contract has already been deployed by the factory to a\r\n     * given address.\r\n     * @param deploymentAddress address The contract address to check.\r\n     * @return True if the contract has been deployed, false otherwise.\r\n     */\r\n    function hasBeenDeployed(\r\n        address deploymentAddress\r\n    ) external view returns (bool) {\r\n        // determine if a contract has been deployed to the provided address.\r\n        return _deployed[deploymentAddress];\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to ensure that the first 20 bytes of a submitted salt match\r\n     * those of the calling account. This provides protection against the salt\r\n     * being stolen by frontrunners or other attackers. The protection can also be\r\n     * bypassed if desired by setting each of the first 20 bytes to zero.\r\n     * @param salt bytes32 The salt value to check against the calling address.\r\n     */\r\n    modifier containsCaller(bytes32 salt) {\r\n        // prevent contract submissions from being stolen from tx.pool by requiring\r\n        // that the first 20 bytes of the submitted salt match msg.sender.\r\n        require(\r\n            (address(bytes20(salt)) == msg.sender) ||\r\n                (bytes20(salt) == bytes20(0)),\r\n            \"Invalid salt - first 20 bytes of the salt must match calling address.\"\r\n        );\r\n        _;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"initCode\",\"type\":\"bytes\"}],\"name\":\"findCreate2Address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"deploymentAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"initCodeHash\",\"type\":\"bytes32\"}],\"name\":\"findCreate2AddressViaHash\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"deploymentAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"deploymentAddress\",\"type\":\"address\"}],\"name\":\"hasBeenDeployed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"initializationCode\",\"type\":\"bytes\"}],\"name\":\"safeCreate2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"deploymentAddress\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "ImmutableCreate2Factory", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://244877cb1fcdea36c79e2463f5af4c10c27109732ade49e693bb054c8dea6986"}