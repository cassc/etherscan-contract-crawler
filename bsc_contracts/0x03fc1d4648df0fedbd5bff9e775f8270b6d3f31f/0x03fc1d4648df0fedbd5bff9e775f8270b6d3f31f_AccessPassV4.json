{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */ \r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\ncontract AccessPassV4  {\r\n    using Address for address;\r\n    address public owner;\r\n    mapping(address => userDetails) public userProfile;\r\n    struct userDetails {\r\n        address userAddress;\r\n        uint256 TokensDeposited;\r\n        uint256 accessPassedTokenPrice;\r\n        uint256 latestTrxPrice;\r\n        uint256 totalPriceBUSD;\r\n        uint256 trxTime;\r\n        uint256 worthIncrease;\r\n        bool hasDeposited;\r\n        bool status;\r\n        bool autoWithdraw;\r\n    }\r\n    userDetails[] private userDetailsHistory;\r\n    userDetails[] private inactiveUserTransferHistory;\r\n    IUniswapV2Router02 public uniswapV2Router;\r\n\r\n    event Withdraw(address indexed user, uint256 amount, address token);\r\n    event Deposit(address indexed user, uint256 amount, address token);\r\n    event bnbSwapped(address user, uint256 amount);\r\n    event tokensBought(address user, uint256 amount);\r\n    event BalanceClear(uint256 amount);\r\n    event clearToken(address TokenAddressCleared, uint256 Amount);\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n\r\n    address public currentToken;\r\n    address public BUSD;\r\n    uint256 public currentDepositBusdLimit = 25 *10**18;  //25 BUSD minimum deposit amount\r\n    uint256 public tokenWorthIncrease = 25; //25% worth increase\r\n    uint256 oneToken = 1 *10**18;\r\n    bool public feeEnabled = true;\r\n    uint256 public feePercentage = 10000; //10 % upto three decimals points such as 10.000% \r\n\r\n\r\n    constructor(address _curToken, address _busd ) {\r\n\r\n        currentToken = _curToken ;\r\n        BUSD = _busd ;\r\n        //BUSD: 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56\r\n        //NSI: 0x7efb55d9ac57b23cc6811c9068db3cf83cbdfe39\r\n        uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E); \r\n        owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n \r\n\r\n    function depositTokens(uint _amount) public  {\r\n        require(msg.sender == owner, \"Only Owner\");\r\n        IERC20(currentToken).transferFrom(msg.sender, address(this), _amount);\r\n        userProfile[msg.sender].TokensDeposited += _amount;\r\n        emit Deposit(msg.sender, _amount, currentToken);\r\n    }\r\n\r\n    \r\n    function accessPassTokens(uint256 amountOutMin ,address[] memory path ) external payable  {        \r\n        require(!userProfile[msg.sender].hasDeposited, \"Cannot deposit more than once.\");\r\n        address  WBNB = uniswapV2Router.WETH();\r\n        uint256 minimumDepositLimit = getAmountOutMin(BUSD, WBNB, currentDepositBusdLimit);\r\n        require(msg.value >= minimumDepositLimit, \"AccessPass amount is less than the minimum required amount.\");\r\n        uint256 deadline = block.timestamp + 3600;\r\n        uint256 currentPricePerToken = currentTokenPrice();\r\n        uint[] memory amounts = uniswapV2Router.swapExactETHForTokens{value: msg.value}(amountOutMin, path, address(this), deadline );\r\n        uint256 AmountIN = amounts[0];\r\n        \r\n        uint256 AmountOUTBeforeTax = amounts[amounts.length -1];\r\n        uint256 AmountOUT = AmountOUTBeforeTax; \r\n        if (feeEnabled == true){\r\n\r\n         AmountOUT  = subtractPercent(AmountOUTBeforeTax,feePercentage );\r\n        }\r\n\r\n        userProfile[msg.sender].userAddress = msg.sender;\r\n        userProfile[msg.sender].TokensDeposited = AmountOUT;\r\n        userProfile[msg.sender].accessPassedTokenPrice = currentPricePerToken;\r\n        userProfile[msg.sender].latestTrxPrice = currentPricePerToken;\r\n        userProfile[msg.sender].totalPriceBUSD = currentDepositBusdLimit;\r\n        userProfile[msg.sender].trxTime = block.timestamp;\r\n        userProfile[msg.sender].worthIncrease = tokenWorthIncrease;\r\n        userProfile[msg.sender].hasDeposited = true;\r\n        userProfile[msg.sender].status = true;\r\n        userProfile[msg.sender].autoWithdraw = true;\r\n        userDetailsHistory.push(userDetails(msg.sender,AmountOUT,currentPricePerToken, currentPricePerToken ,currentDepositBusdLimit,block.timestamp, tokenWorthIncrease, true, true, true));\r\n        emit Deposit(msg.sender, AmountOUT, currentToken); \r\n        emit tokensBought(msg.sender, AmountOUT);\r\n        emit bnbSwapped(msg.sender, AmountIN);       \r\n    }\r\n\r\n    function subtractPercent(uint256 amount, uint256 percent) public pure returns (uint256) {\r\n        uint256 amountMinusPercent = amount * (100000 - percent) / 100000;\r\n        return amountMinusPercent;\r\n    }\r\n\r\n    \r\n    // Fallback function to receive ETH\r\n    receive() external payable {}\r\n\r\n\r\n    function canWithdraw(address user) internal view returns(bool){\r\n       require(userProfile[user].hasDeposited == true, \"Deposit First\");\r\n       uint256 UserDepositTokens = userProfile[user].TokensDeposited;\r\n       uint256 UserDepositLimitBUSD = userProfile[user].totalPriceBUSD;\r\n       uint256 UserTokenWorthIncrease = userProfile[user].worthIncrease;\r\n       uint256 currentTotalPrice = getAmountOutMin(BUSD, currentToken, UserDepositLimitBUSD);\r\n       uint256 withdrawThreshold = (UserDepositTokens * UserTokenWorthIncrease)/100;\r\n       uint256 minPrice = UserDepositTokens - withdrawThreshold;\r\n       return currentTotalPrice <= minPrice;\r\n    }\r\n\r\n    function isEligibleToWithdraw(address user) external view \r\n       returns (uint256 current, uint256 expected, bool withdraw_possible) {        \r\n       require(userProfile[user].hasDeposited == true, \"Deposit First.\");\r\n       uint256 UserDepositTokens = userProfile[user].TokensDeposited;\r\n       uint256 UserDepositLimitBUSD = userProfile[user].totalPriceBUSD;       \r\n       uint256 UserTokenWorthIncrease = userProfile[user].worthIncrease;\r\n       uint256 currentTotalPrice = getAmountOutMin(BUSD, currentToken, UserDepositLimitBUSD);\r\n       uint256 withdrawThreshold = (UserDepositTokens * UserTokenWorthIncrease)/100;\r\n       uint256 minPrice = UserDepositTokens - withdrawThreshold;\r\n       return (currentTotalPrice ,minPrice, currentTotalPrice <= minPrice);\r\n    }\r\n  \r\n    function updateUserDetails(address user,  uint256 TokensDeposited,\r\n        uint256 accessPassedTokenPrice, uint256 latestTrxPrice, uint256 totalPrice, uint256 trxTime, uint256 worthIncrease, \r\n        bool hasDeposited, bool status, bool autoWithdrawStatus\r\n        ) external {\r\n        require(msg.sender == owner,\"Only Owner\");\r\n        userProfile[user].userAddress = user;\r\n        userProfile[user].TokensDeposited = TokensDeposited;\r\n        userProfile[user].accessPassedTokenPrice = accessPassedTokenPrice;\r\n        userProfile[user].latestTrxPrice = latestTrxPrice;\r\n        userProfile[user].totalPriceBUSD = totalPrice;\r\n        userProfile[user].trxTime = trxTime;\r\n        userProfile[user].worthIncrease = worthIncrease;\r\n        userProfile[user].hasDeposited = hasDeposited;\r\n        userProfile[user].status = status;\r\n        userProfile[user].autoWithdraw = autoWithdrawStatus;\r\n        userDetailsHistory.push(userDetails(user ,TokensDeposited, accessPassedTokenPrice, latestTrxPrice ,totalPrice, trxTime, worthIncrease, hasDeposited, status, autoWithdrawStatus));       \r\n    }\r\n        \r\n    function getAmountOutMin(address _tokenIn, address _tokenOut, uint256 _amountIn) public view returns (uint256) {            \r\n        address[] memory path;\r\n        address  WETH = uniswapV2Router.WETH();\r\n        if (_tokenIn == WETH || _tokenOut == WETH) {\r\n            path = new address[](2);\r\n            path[0] = _tokenIn;\r\n            path[1] = _tokenOut;\r\n        } else {\r\n            path = new address[](3);\r\n            path[0] = _tokenIn;\r\n            path[1] = WETH;\r\n            path[2] = _tokenOut;\r\n        }            \r\n        uint256[] memory amountOutMins = IUniswapV2Router02(uniswapV2Router).getAmountsOut(_amountIn, path);\r\n        return amountOutMins[path.length -1];  \r\n    }\r\n\r\n    function withdraw(uint256 _amount) external {\r\n        require(msg.sender == owner, \"Only Owner\");\r\n        require(_amount <=userProfile[owner].TokensDeposited, \"Withdraw amount exceeds current balance.\");\r\n        IERC20(currentToken).transfer(msg.sender, _amount);\r\n        userProfile[owner].TokensDeposited -= _amount;\r\n        emit Withdraw(msg.sender, _amount, currentToken);\r\n    }\r\n\r\n    function userWithdrawProfit() external  {\r\n        require(userProfile[msg.sender].TokensDeposited > 0,\"Insufficient funds to withdraw.\");\r\n        require(userProfile[msg.sender].status ,\"User is Inactive.\");\r\n        require(canWithdraw(msg.sender) , \"Not eligible to withdraw.\");\r\n        uint256 currentPricePerToken = currentTokenPrice();\r\n        uint256 UserDepositTokens = userProfile[msg.sender].TokensDeposited;\r\n        uint256 UserDepositLimitBUSD = userProfile[msg.sender].totalPriceBUSD;\r\n        uint256 currentTotalPrice = getAmountOutMin(BUSD, currentToken, UserDepositLimitBUSD);\r\n        uint256 withdrawableAmount = UserDepositTokens - currentTotalPrice ;\r\n        IERC20(currentToken).transfer(msg.sender, withdrawableAmount); \r\n        userProfile[msg.sender].TokensDeposited -= withdrawableAmount;\r\n        userProfile[msg.sender].latestTrxPrice = currentPricePerToken;\r\n        userProfile[msg.sender].trxTime = block.timestamp;\r\n        userDetailsHistory.push(userDetails(msg.sender,withdrawableAmount,userProfile[msg.sender].accessPassedTokenPrice, currentPricePerToken, userProfile[msg.sender].totalPriceBUSD,block.timestamp, userProfile[msg.sender].worthIncrease, true, true, userProfile[msg.sender].autoWithdraw));\r\n        emit Withdraw(msg.sender, withdrawableAmount, currentToken);\r\n    }\r\n\r\n    function autoWithdraw(address[] memory addresses) external {\r\n        require(msg.sender == owner, \"Only Owner\");\r\n        for (uint i = 0; i < addresses.length; i++) {\r\n            address user = addresses[i];\r\n            if (userProfile[user].autoWithdraw && canWithdraw(user) && userProfile[user].status ) {\r\n                require(userProfile[user].TokensDeposited > 0,\"Insufficient funds to withdraw.\");\r\n                require(canWithdraw(user), \"Not eligible to withdraw.\");\r\n                require(userProfile[user].status,\"User is Inactive.\");\r\n                uint256 currentPricePerToken = currentTokenPrice();\r\n                uint256 UserDepositTokens = userProfile[user].TokensDeposited;\r\n                uint256 UserDepositLimitBUSD = userProfile[user].totalPriceBUSD;\r\n                uint256 currentTotalPrice = getAmountOutMin(BUSD, currentToken, UserDepositLimitBUSD);\r\n                uint256 withdrawableAmount =  UserDepositTokens - currentTotalPrice;\r\n                IERC20(currentToken).transfer(user, withdrawableAmount);\r\n                userProfile[user].TokensDeposited -= withdrawableAmount;\r\n                userProfile[msg.sender].latestTrxPrice = currentPricePerToken;\r\n                userProfile[user].trxTime = block.timestamp;\r\n                userDetailsHistory.push(userDetails(user,userProfile[user].TokensDeposited,userProfile[user].accessPassedTokenPrice,currentPricePerToken,userProfile[user].totalPriceBUSD,block.timestamp,userProfile[msg.sender].worthIncrease ,true, true, userProfile[msg.sender].autoWithdraw));\r\n                emit Withdraw(msg.sender, withdrawableAmount, currentToken);\r\n            }\r\n        }\r\n    } \r\n\r\n    function CheckAutoWithdraw() external view returns(uint256 count, address[] memory Users) {\r\n        uint256 counter = 0;\r\n        address[] memory userAddresses = new address[](userDetailsHistory.length);\r\n        address[] memory addedUsers = new address[](userDetailsHistory.length);\r\n        for (uint i = 0; i < userDetailsHistory.length; i++) {\r\n            address user = userDetailsHistory[i].userAddress;\r\n            if (userProfile[user].autoWithdraw && canWithdraw(user) && userProfile[user].status ) {\r\n                if(addressNotAdded(addedUsers, user)) {\r\n                    addedUsers[counter] = userProfile[user].userAddress;\r\n                    userAddresses[counter] = userProfile[user].userAddress;\r\n                    counter++;\r\n                }\r\n            }\r\n        }\r\n        address[] memory resizedAddresses = new address[](counter);\r\n        for (uint i = 0; i < counter; i++) {\r\n            resizedAddresses[i] = userAddresses[i];\r\n        }\r\n        return (counter, resizedAddresses);\r\n    }\r\n\r\n    function addressNotAdded(address[] memory _addedUsers, address _address) internal  pure  returns (bool) {\r\n        for(uint i=0; i<_addedUsers.length; i++) {\r\n            if(_addedUsers[i] == _address) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function setDepositLimitInBusd(uint256 busdAmount) external {\r\n        require(msg.sender == owner , \"Only Owner\");\r\n        currentDepositBusdLimit = busdAmount * 10 **18;\r\n    }\r\n\r\n    function updateTokenWorthIncrease(uint256 percentage) external {\r\n        require(msg.sender == owner, \"Only Owner\");\r\n        tokenWorthIncrease = percentage;\r\n    }\r\n\r\n    function updatefeePercentage(uint256 _feepercent) external{\r\n        require(msg.sender == owner, \"Only Owner\");\r\n        feePercentage = _feepercent;\r\n    }\r\n\r\n    function updatefeeEnabled ( bool _isEnabled) external {\r\n        require(msg.sender == owner, \"Only Owner\");\r\n        feeEnabled = _isEnabled;\r\n    }\r\n\r\n    function currentTokenDepositPrice() public view returns (uint256){\r\n        return getAmountOutMin(BUSD, currentToken, currentDepositBusdLimit);\r\n    }\r\n\r\n    function currentTokenPrice() public view returns (uint256) {\r\n        return getAmountOutMin(currentToken, BUSD , oneToken);\r\n    }\r\n\r\n    function usersHistory() external view returns(userDetails[] memory){\r\n        return userDetailsHistory;\r\n    }\r\n\r\n    function inActiveUserTransferHistory() external view returns(userDetails[] memory){\r\n        return inactiveUserTransferHistory;\r\n    }\r\n\r\n    function updateAutoWithdrawStatus(address[] memory users, bool autoWithdrawStatus) external {\r\n        require(msg.sender == owner, \"Only Owner\");        \r\n        require(users.length < 501, \"Can not pass more than 500 addresses.\");\r\n        for (uint i= 0; i< users.length; i++) {\r\n            userProfile[users[i]].autoWithdraw = autoWithdrawStatus;\r\n        }\r\n    }\r\n\r\n    function updateOwnAutoWithdrawStatus (bool autoWithdrawStatus) external {\r\n        userProfile[msg.sender].autoWithdraw = autoWithdrawStatus;\r\n    }  \r\n\r\n    function userHistory(address user) external view returns (userDetails[] memory){\r\n        userDetails[] memory elements = new userDetails[](userDetailsHistory.length);\r\n        uint256 counter = 0;\r\n        for (uint i = 0; i < userDetailsHistory.length; i++) {\r\n            if (userDetailsHistory[i].userAddress == user ) {\r\n                counter++;\r\n                elements[counter-1] = userDetailsHistory[i];\r\n            }     \r\n        }\r\n\r\n        userDetails[] memory resizedAddresses = new userDetails[](counter);\r\n        for (uint i = 0; i < counter; i++) {\r\n            resizedAddresses[i] = elements[i]; \r\n        }\r\n        return (resizedAddresses);\r\n    }\r\n\r\n    function userStatus(address user) external view returns (bool active){\r\n        return userProfile[user].status;\r\n    } \r\n    \r\n    function userDepositBalane(address user) external view returns (uint256 amount){\r\n        return userProfile[user].TokensDeposited;\r\n    }\r\n\r\n    function updateUserStatus(address[] memory users, bool active) external {\r\n        require(msg.sender == owner, \"Only Owner\");        \r\n        require(users.length < 501, \"Can not pass more than 500 addresses.\");\r\n        for (uint i = 0; i< users.length; i++ ) {\r\n            userProfile[users[i]].status = active;\r\n        }\r\n    }\r\n\r\n    function updateCurrentToken(address newToken) external {\r\n        require(msg.sender == owner, \"Only Owner\");\r\n        currentToken = newToken;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer `BNBs` sent accidentaly on this address to the owner \r\n     * @param amountPercentage Owner can enter the percentage and transfer the BNBs back to the user\r\n     * @notice If this function is not present in the smart contract then the bnb/tokens will remian stuck in the smart contract forever.\r\n     */\r\n\r\n    function recoverStuckBnb(uint256 amountPercentage) external  {\r\n        require(msg.sender == owner, \"Only Owner\");\r\n        require(amountPercentage < 101, \"Max 100%\");\r\n        uint256 amountBNB = address(this).balance;\r\n        uint256 amountToClear = ( amountBNB * amountPercentage ) / 100;\r\n        payable(msg.sender).transfer(amountToClear);\r\n        emit BalanceClear(amountToClear);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer `tokenAddress` sent accidentaly on this address to the owner \r\n     * @param tokens Owner can enter the 0 and transfer all the tokens back to the user\r\n     * @notice If this function is not present in the smart contract then the bnb/tokens will remian stuck in the smart contract forever.\r\n     */\r\n\r\n    function recoverStuckToken(address tokenAddress, uint256 tokens) external  returns (bool success) {\r\n        require(msg.sender == owner, \"Only Owner\");\r\n        require(tokenAddress != currentToken , \"You can not Withdraw this Token.\"); \r\n        require(tokenAddress != address(0) , \"Enter Non Zero Wallet Address.\");        \r\n        if(tokens == 0){\r\n            tokens = IERC20(tokenAddress).balanceOf(address(this));\r\n        }\r\n        emit clearToken(tokenAddress, tokens);\r\n        return IERC20(tokenAddress).transfer(msg.sender, tokens);\r\n    }\r\n\r\n    function transferUsersBalanceToOwner(address[] memory inactiveUsers) external {\r\n        require(msg.sender == owner, \"Only Owner\");\r\n        require(inactiveUsers.length > 0,\"Pass at least one inactive user address\");\r\n        uint256 totalTokens =0;\r\n        for (uint i = 0; i < inactiveUsers.length; i++) {\r\n            address InActiveUser = inactiveUsers[i];\r\n            require(userProfile[InActiveUser].TokensDeposited > 0, \"The user does not have any funds to transfer.\");\r\n            require(!userProfile[InActiveUser].status, \"The status of user is Still active\");\r\n            uint256 userBalance = userProfile[InActiveUser].TokensDeposited;\r\n            totalTokens +=userBalance;\r\n            userProfile[InActiveUser].userAddress = InActiveUser;\r\n            userProfile[InActiveUser].TokensDeposited -= userBalance;\r\n            userProfile[InActiveUser].accessPassedTokenPrice = 0;\r\n            userProfile[InActiveUser].latestTrxPrice = 0;\r\n            userProfile[InActiveUser].totalPriceBUSD = 0;\r\n            userProfile[InActiveUser].trxTime = block.timestamp;\r\n            userProfile[InActiveUser].hasDeposited = false;\r\n            userProfile[InActiveUser].status = false;\r\n            userProfile[InActiveUser].autoWithdraw = false;\r\n            userDetailsHistory.push(userDetails(InActiveUser,0,0,0,0,block.timestamp, 0,false, false, false));\r\n            inactiveUserTransferHistory.push(userDetails(InActiveUser, userBalance,0,0,0,block.timestamp, 0, false, false, false));\r\n            \r\n        }\r\n        IERC20(currentToken).transfer(owner, totalTokens);\r\n    }\r\n\r\n    function renounceOwnership() public {\r\n        require(msg.sender == owner, \"Only Owner\");\r\n        emit OwnershipTransferred(owner, address(0));\r\n        owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public {\r\n        require(msg.sender == owner, \"Only Owner\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n    \r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }    \r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_curToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_busd\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BalanceClear\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"bnbSwapped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"TokenAddressCleared\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"}],\"name\":\"clearToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"tokensBought\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BUSD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CheckAutoWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"Users\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"accessPassTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"autoWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentDepositBusdLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentTokenDepositPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentTokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amountIn\",\"type\":\"uint256\"}],\"name\":\"getAmountOutMin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inActiveUserTransferHistory\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"TokensDeposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accessPassedTokenPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"latestTrxPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPriceBUSD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"trxTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"worthIncrease\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hasDeposited\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"autoWithdraw\",\"type\":\"bool\"}],\"internalType\":\"struct AccessPassV4.userDetails[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isEligibleToWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"current\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withdraw_possible\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountPercentage\",\"type\":\"uint256\"}],\"name\":\"recoverStuckBnb\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"recoverStuckToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"busdAmount\",\"type\":\"uint256\"}],\"name\":\"setDepositLimitInBusd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"subtractPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenWorthIncrease\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"inactiveUsers\",\"type\":\"address[]\"}],\"name\":\"transferUsersBalanceToOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"autoWithdrawStatus\",\"type\":\"bool\"}],\"name\":\"updateAutoWithdrawStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newToken\",\"type\":\"address\"}],\"name\":\"updateCurrentToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"autoWithdrawStatus\",\"type\":\"bool\"}],\"name\":\"updateOwnAutoWithdrawStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"}],\"name\":\"updateTokenWorthIncrease\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"TokensDeposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accessPassedTokenPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"latestTrxPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"trxTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"worthIncrease\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hasDeposited\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"autoWithdrawStatus\",\"type\":\"bool\"}],\"name\":\"updateUserDetails\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"name\":\"updateUserStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isEnabled\",\"type\":\"bool\"}],\"name\":\"updatefeeEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_feepercent\",\"type\":\"uint256\"}],\"name\":\"updatefeePercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"userDepositBalane\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"userHistory\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"TokensDeposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accessPassedTokenPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"latestTrxPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPriceBUSD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"trxTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"worthIncrease\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hasDeposited\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"autoWithdraw\",\"type\":\"bool\"}],\"internalType\":\"struct AccessPassV4.userDetails[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userProfile\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"TokensDeposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accessPassedTokenPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"latestTrxPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPriceBUSD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"trxTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"worthIncrease\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hasDeposited\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"autoWithdraw\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"userStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"userWithdrawProfit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usersHistory\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"TokensDeposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accessPassedTokenPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"latestTrxPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPriceBUSD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"trxTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"worthIncrease\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hasDeposited\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"autoWithdraw\",\"type\":\"bool\"}],\"internalType\":\"struct AccessPassV4.userDetails[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "AccessPassV4", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000007efb55d9ac57b23cc6811c9068db3cf83cbdfe39000000000000000000000000e9e7cea3dedca5984780bafc599bd69add087d56", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://844861c6944f2a2f608a61463e840862b1c14b734fff3403c3d31db0d2fd2b47"}