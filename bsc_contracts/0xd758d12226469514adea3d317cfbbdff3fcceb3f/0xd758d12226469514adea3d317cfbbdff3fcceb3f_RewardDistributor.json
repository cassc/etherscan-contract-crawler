{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/RewardDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\nimport \\\"./libraries/TransferHelper.sol\\\";\\nimport \\\"./common/Adminable.sol\\\";\\nimport \\\"./common/ReentrancyGuard.sol\\\";\\nimport \\\"./interface/IXOLE.sol\\\";\\nimport \\\"./interface/IUniV2ClassPair.sol\\\";\\n\\ncontract RewardDistributor is Adminable, ReentrancyGuard {\\n    using TransferHelper for IERC20;\\n    using TransferHelper for IUniV2ClassPair;\\n\\n    error InvalidAmount();\\n    error InvalidTime();\\n    error InvalidPenalty();\\n    error InsufficientTransfersIn();\\n    error NotStarted();\\n    error Expired();\\n    error NotExpired();\\n    error AlreadyRecycled();\\n    error AlreadyVested();\\n    error IncorrectMerkleProof();\\n    error ExceedMax(uint256 amount);\\n\\n    struct Epoch {\\n        bytes32 merkleRoot;\\n        uint256 total;\\n        uint256 vested;\\n        uint256 startTime; // vest start time\\n        uint256 expireTime; // vest expire time\\n        uint256 vestDuration; // vest duration, in seconds\\n        uint16 penaltyBase; // exit penalty base percentage, 2000 => 20%\\n        uint16 penaltyAdd; // exit penalty add percentage, 6000 => 60%\\n        bool recycled;\\n    }\\n\\n    struct Reward {\\n        uint256 amount; // total amount to be vested\\n        uint256 withdrawn; // withdrawn amount by the user\\n        uint256 vestStartTime; // vest start time\\n    }\\n\\n    uint256 internal constant PERCENT_DIVISOR = 10000;\\n    uint256 private constant WEEK = 7 * 86400;  // XOLE lock times are rounded by week\\n    uint256 private constant MIN_DURATION = 7 * 86400;  // 7 days\\n    uint256 private constant MAX_DURATION = 4 * 365 * 86400;  // 4 years\\n\\n    IERC20 public immutable oleToken;\\n    IUniV2ClassPair public immutable pair;\\n    address public immutable token1;  // token1 of lp\\n    address public immutable xole;\\n    uint256 public epochIdx;\\n    uint256 public minXOLELockDuration; // min XOLE lock duration in seconds when converting\\n    uint256 public withdrawablePenalty; // the withdrawable penalty for admin\\n\\n    // mapping of epochId, user to reward info\\n    mapping(uint256 => mapping(address => Reward)) public rewards;\\n    // mapping of epochId to epoch info\\n    mapping(uint256 => Epoch) public epochs;\\n\\n    constructor(address _oleToken, address _pair, address _token1, address _xole, uint256 _minXOLELockDuration) verifyDuration(_minXOLELockDuration){\\n        oleToken = IERC20(_oleToken);\\n        pair = IUniV2ClassPair(_pair);\\n        token1 = _token1;\\n        xole = _xole;\\n        minXOLELockDuration = _minXOLELockDuration;\\n        admin = payable(msg.sender);\\n    }\\n\\n    event VestStarted(uint256 epochId, address account, uint256 balance, uint256 vestTime);\\n    event Withdrawn(uint256 epochId, address account, uint256 amount, uint256 penalty);\\n    event ConvertedToXOLE(uint256 epochId, address account, uint256 amount);\\n\\n    event EpochAdded(uint256 epochId, bytes32 merkleRoot, uint256 total, uint256 startTime, uint256 expireTime, uint256 vestDuration, uint16 penaltyBase, uint16 penaltyAdd);\\n    event Recycled(uint256 epochId, uint256 recycledAmount);\\n    event PenaltyWithdrawn(uint256 amount);\\n\\n    function vest(uint256 _epochId, uint256 _balance, bytes32[] calldata _merkleProof) external {\\n        Epoch storage epoch = epochs[_epochId];\\n        if (block.timestamp < epoch.startTime) revert NotStarted();\\n        if (block.timestamp > epoch.expireTime) revert Expired();\\n        if (_balance == 0 || _balance + epoch.vested > epoch.total) revert InvalidAmount();\\n\\n        Reward memory reward = rewards[_epochId][msg.sender];\\n        if (reward.amount > 0) revert AlreadyVested();\\n        if (!_verifyVest(msg.sender, epoch.merkleRoot, _balance, _merkleProof)) revert IncorrectMerkleProof();\\n        epoch.vested += _balance;\\n        rewards[_epochId][msg.sender] = Reward(_balance, 0, block.timestamp);\\n        emit VestStarted(_epochId, msg.sender, _balance, block.timestamp);\\n    }\\n\\n    function withdrawMul(uint256[] calldata _epochIds) external {\\n        uint256 total;\\n        for (uint256 i = 0; i < _epochIds.length; i++) {\\n            total += _withdrawReward(_epochIds[i]);\\n        }\\n        oleToken.safeTransfer(msg.sender, total);\\n    }\\n\\n    function withdraw(uint256 epochId) external {\\n        uint256 withdrawing = _withdrawReward(epochId);\\n        oleToken.safeTransfer(msg.sender, withdrawing);\\n    }\\n\\n    function earlyExit(uint256 epochId) external {\\n        Reward storage reward = rewards[epochId][msg.sender];\\n        if (reward.amount == 0 || reward.amount == reward.withdrawn) revert InvalidAmount();\\n        (uint256 withdrawable, uint256 penalty) = _earlyExitWithdrawable(reward, epochId);\\n        reward.withdrawn = reward.amount;\\n        withdrawablePenalty += penalty;\\n        emit Withdrawn(epochId, msg.sender, withdrawable, penalty);\\n        oleToken.safeTransfer(msg.sender, withdrawable);\\n    }\\n\\n    /// @param token1MaxAmount, The token1 max supply amount when adding liquidity\\n    /// @param unlockTime, The unlock time for the XOLE lock\\n    function convertToNewXole(uint256 epochId, uint256 token1MaxAmount, uint256 unlockTime) external nonReentrant {\\n        uint256 conversion = _convertOLE(epochId, msg.sender);\\n        _convertToNewXole(msg.sender, conversion, token1MaxAmount, unlockTime);\\n    }\\n\\n    function convertToNewXoleForOthers(uint256 epochId, address account, uint256 token1MaxAmount, uint256 unlockTime) external nonReentrant {\\n        uint256 conversion = _convertOLE(epochId, msg.sender);\\n        _convertToNewXole(account, conversion, token1MaxAmount, unlockTime);\\n    }\\n\\n    function convertAndIncreaseXoleAmount(uint256 epochId, uint256 token1MaxAmount) external nonReentrant {\\n        uint256 conversion = _convertOLE(epochId, msg.sender);\\n        _convertAndIncreaseXoleAmount(msg.sender, conversion, token1MaxAmount);\\n    }\\n\\n    function convertAndIncreaseXoleAmountForOthers(uint256 epochId, address account, uint256 token1MaxAmount) external nonReentrant {\\n        uint256 conversion = _convertOLE(epochId, msg.sender);\\n        _convertAndIncreaseXoleAmount(account, conversion, token1MaxAmount);\\n    }\\n\\n    /*** View Functions ***/\\n    function verifyVest(address account, uint256 _epochId, uint256 _balance, bytes32[] calldata _merkleProof) external view returns (bool valid){\\n        return _verifyVest(account, epochs[_epochId].merkleRoot, _balance, _merkleProof);\\n    }\\n\\n    function getWithdrawable(address account, uint256[] calldata _epochIds) external view returns (uint256[] memory results){\\n        uint256 len = _epochIds.length;\\n        results = new uint256[](len);\\n        for (uint256 i = 0; i < len; i++) {\\n            Reward memory reward = rewards[_epochIds[i]][account];\\n            if (reward.amount == reward.withdrawn) {\\n                results[i] = 0;\\n                continue;\\n            }\\n            Epoch memory epoch = epochs[_epochIds[i]];\\n            uint256 releaseAble = _releaseable(reward, epoch);\\n            results[i] = releaseAble - reward.withdrawn;\\n        }\\n    }\\n\\n    function getEarlyExitWithdrawable(address account, uint256 _epochId) external view returns (uint256 amount, uint256 penalty){\\n        Reward memory reward = rewards[_epochId][account];\\n        if (reward.amount == reward.withdrawn) {\\n            (amount, penalty) = (0, 0);\\n        } else {\\n            (amount, penalty) = _earlyExitWithdrawable(reward, _epochId);\\n        }\\n    }\\n\\n    /*** Admin Functions ***/\\n    function newEpoch(\\n        bytes32 merkleRoot,\\n        uint256 total,\\n        uint256 startTime,\\n        uint256 expireTime,\\n        uint256 vestDuration,\\n        uint16 penaltyBase,\\n        uint16 penaltyAdd)\\n    external onlyAdminOrDeveloper verifyDuration(vestDuration) {\\n        if (expireTime <= startTime || expireTime <= block.timestamp) revert InvalidTime();\\n        if (total == 0 || penaltyBase + penaltyAdd >= PERCENT_DIVISOR) revert InvalidAmount();\\n        uint256 received = oleToken.safeTransferFrom(msg.sender, address(this), total);\\n        if(received != total) revert InsufficientTransfersIn();\\n        uint256 epochId = ++epochIdx;\\n        epochs[epochId] = Epoch(merkleRoot, total, 0, startTime, expireTime, vestDuration, penaltyBase, penaltyAdd, false);\\n        emit EpochAdded(epochId, merkleRoot, total, startTime, expireTime, vestDuration, penaltyBase, penaltyAdd);\\n    }\\n\\n    function recycle(uint256[] calldata _epochIds) external onlyAdmin {\\n        uint256 total;\\n        for (uint256 i = 0; i < _epochIds.length; i++) {\\n            Epoch storage epoch = epochs[_epochIds[i]];\\n            if (epoch.recycled) revert AlreadyRecycled();\\n            if (block.timestamp <= epoch.expireTime) revert NotExpired();\\n            uint256 recycleAmount = epoch.total - epoch.vested;\\n            total += recycleAmount;\\n            epoch.recycled = true;\\n            emit Recycled(_epochIds[i], recycleAmount);\\n        }\\n        if (total == 0) revert InvalidAmount();\\n        oleToken.safeTransfer(admin, total);\\n    }\\n\\n    function withdrawPenalty() external onlyAdmin {\\n        if (withdrawablePenalty == 0) revert InvalidAmount();\\n        uint256 _withdrawablePenalty = withdrawablePenalty;\\n        withdrawablePenalty = 0;\\n        oleToken.safeTransfer(admin, _withdrawablePenalty);\\n        emit PenaltyWithdrawn(_withdrawablePenalty);\\n    }\\n\\n    function setMinXOLELockDuration(uint256 _minXOLELockDuration) external onlyAdmin verifyDuration(_minXOLELockDuration) {\\n        minXOLELockDuration = _minXOLELockDuration;\\n    }\\n\\n    /*** Internal Functions ***/\\n    function _verifyVest(address account, bytes32 root, uint256 _balance, bytes32[] memory _merkleProof) internal pure returns (bool valid) {\\n        bytes32 leaf = keccak256(abi.encodePacked(account, _balance));\\n        return MerkleProof.verify(_merkleProof, root, leaf);\\n    }\\n\\n    function _withdrawReward(uint256 epochId) internal returns (uint256){\\n        Reward storage reward = rewards[epochId][msg.sender];\\n        if (reward.amount == 0 || reward.amount == reward.withdrawn) revert InvalidAmount();\\n        Epoch memory epoch = epochs[epochId];\\n        uint256 withdrawing = _releaseable(reward, epoch) - reward.withdrawn;\\n        if (withdrawing == 0) revert InvalidAmount();\\n        reward.withdrawn += withdrawing;\\n        emit Withdrawn(epochId, msg.sender, withdrawing, 0);\\n        return withdrawing;\\n    }\\n\\n    function _releaseable(Reward memory reward, Epoch memory epoch) internal view returns (uint256) {\\n        uint256 endTime = reward.vestStartTime + epoch.vestDuration;\\n        if (block.timestamp > endTime) {\\n            return reward.amount;\\n        } else {\\n            return (block.timestamp - reward.vestStartTime) * reward.amount / epoch.vestDuration;\\n        }\\n    }\\n\\n    function _earlyExitWithdrawable(Reward memory reward, uint256 epochId) internal view returns (uint256 withdrawable, uint256 penalty) {\\n        Epoch memory epoch = epochs[epochId];\\n        uint256 releaseable = _releaseable(reward, epoch);\\n        withdrawable = releaseable - reward.withdrawn;\\n        // cal penalty\\n        uint256 endTime = reward.vestStartTime + epoch.vestDuration;\\n        uint256 penaltyFactor = (endTime - block.timestamp) * epoch.penaltyAdd / epoch.vestDuration + epoch.penaltyBase;\\n        uint256 locked = reward.amount - releaseable;\\n        penalty = locked * penaltyFactor / PERCENT_DIVISOR;\\n        if (penalty >= locked) revert InvalidPenalty();\\n        withdrawable += locked - penalty;\\n        return (withdrawable, penalty);\\n    }\\n\\n    function _convertOLE(uint256 epochId, address account) internal returns (uint256) {\\n        Reward storage reward = rewards[epochId][account];\\n        uint256 convertible = reward.amount - reward.withdrawn;\\n        if (reward.amount == 0 || convertible == 0) revert InvalidAmount();\\n        reward.withdrawn = reward.amount;\\n        emit ConvertedToXOLE(epochId, account, convertible);\\n        return convertible;\\n    }\\n\\n    function _convertToNewXole(address account, uint256 oleAmount, uint256 token1MaxAmount, uint256 unlockTime) internal {\\n        unlockTime = unlockTime / WEEK * WEEK;\\n        verifyUnlockTime(unlockTime);\\n        uint256 liquidity = formLp(oleAmount, token1MaxAmount);\\n        pair.safeApprove(xole, liquidity);\\n        IXOLE(xole).create_lock_for(account, liquidity, unlockTime);\\n    }\\n\\n    function _convertAndIncreaseXoleAmount(address account, uint256 oleAmount, uint256 token1MaxAmount) internal {\\n        (,uint256 lockTime) = IXOLE(xole).locked(account);\\n        verifyUnlockTime(lockTime);\\n        uint256 liquidity = formLp(oleAmount, token1MaxAmount);\\n        pair.safeApprove(xole, liquidity);\\n        IXOLE(xole).increase_amount_for(account, liquidity);\\n    }\\n\\n    function formLp(uint256 oleAmount, uint256 token1MaxAmount) internal returns (uint256 liquidity){\\n        (uint256 reserveA, uint256 reserveB) = getReserves(address(oleToken), token1);\\n        uint256 amountBOptimal = oleAmount * reserveB / reserveA;\\n        if (amountBOptimal > token1MaxAmount) revert ExceedMax(amountBOptimal);\\n        IERC20(token1).safeTransferFrom(msg.sender, address(pair), amountBOptimal);\\n        oleToken.safeTransfer(address(pair), oleAmount);\\n        liquidity = pair.mint(address(this));\\n    }\\n\\n    function getReserves(address tokenA, address tokenB) internal view returns (uint256 reserveA, uint256 reserveB) {\\n        (uint256 reserve0, uint256 reserve1,) = pair.getReserves();\\n        (address _token0,) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        (reserveA, reserveB) = tokenA == _token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\n    }\\n\\n    function verifyUnlockTime(uint256 _unlockTime) internal view {\\n        if (_unlockTime < block.timestamp + minXOLELockDuration || _unlockTime > block.timestamp + MAX_DURATION) revert InvalidTime();\\n    }\\n\\n    modifier verifyDuration(uint256 _duration) {\\n        if (_duration < MIN_DURATION || _duration > MAX_DURATION) revert InvalidTime();\\n        _;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"/contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @title TransferHelper\\n * @dev Wrappers around ERC20 operations that returns the value received by recipent and the actual allowance of approval.\\n * To use this library you can add a `using TransferHelper for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary TransferHelper {\\n    function safeTransfer(\\n        IERC20 _token,\\n        address _to,\\n        uint256 _amount\\n    ) internal returns (uint256 amountReceived) {\\n        if (_amount > 0) {\\n            bool success;\\n            uint256 balanceBefore = _token.balanceOf(_to);\\n            (success, ) = address(_token).call(abi.encodeWithSelector(_token.transfer.selector, _to, _amount));\\n            require(success, \\\"TF\\\");\\n            uint256 balanceAfter = _token.balanceOf(_to);\\n            require(balanceAfter > balanceBefore, \\\"TF\\\");\\n            amountReceived = balanceAfter - balanceBefore;\\n        }\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 _token,\\n        address _from,\\n        address _to,\\n        uint256 _amount\\n    ) internal returns (uint256 amountReceived) {\\n        if (_amount > 0) {\\n            bool success;\\n            uint256 balanceBefore = _token.balanceOf(_to);\\n            (success, ) = address(_token).call(abi.encodeWithSelector(_token.transferFrom.selector, _from, _to, _amount));\\n            require(success, \\\"TFF\\\");\\n            uint256 balanceAfter = _token.balanceOf(_to);\\n            require(balanceAfter > balanceBefore, \\\"TFF\\\");\\n            amountReceived = balanceAfter - balanceBefore;\\n        }\\n    }\\n\\n    function safeApprove(\\n        IERC20 _token,\\n        address _spender,\\n        uint256 _amount\\n    ) internal returns (uint256) {\\n        bool success;\\n        if (_token.allowance(address(this), _spender) != 0) {\\n            (success, ) = address(_token).call(abi.encodeWithSelector(_token.approve.selector, _spender, 0));\\n            require(success, \\\"AF\\\");\\n        }\\n        (success, ) = address(_token).call(abi.encodeWithSelector(_token.approve.selector, _spender, _amount));\\n        require(success, \\\"AF\\\");\\n\\n        return _token.allowance(address(this), _spender);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/interface/IXOLE.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\ninterface IXOLE{\\n\\n    function create_lock_for(address to, uint256 _value, uint256 _unlock_time) external;\\n\\n    function increase_amount_for(address to, uint256 _value) external;\\n\\n    function balanceOf(address addr) external view returns (uint256);\\n\\n    function locked(address addr) external view returns (uint256 amount, uint256 lockTime);\\n\\n}\\n\\n\"\r\n    },\r\n    \"/contracts/interface/IUniV2ClassPair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IUniV2ClassPair is IERC20{\\n\\n    function mint(address to) external returns (uint liquidity);\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n}\\n\\n\"\r\n    },\r\n    \"/contracts/common/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.17;\\n\\ncontract ReentrancyGuard {\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    modifier nonReentrant() {\\n        check();\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    function check() private view {\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/common/Adminable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.17;\\n\\nabstract contract Adminable {\\n    address payable public admin;\\n    address payable public pendingAdmin;\\n    address payable public developer;\\n\\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\\n\\n    event NewAdmin(address oldAdmin, address newAdmin);\\n\\n    constructor() {\\n        developer = payable(msg.sender);\\n    }\\n\\n    modifier onlyAdmin() {\\n        checkAdmin();\\n        _;\\n    }\\n    modifier onlyAdminOrDeveloper() {\\n        require(msg.sender == admin || msg.sender == developer, \\\"Only admin or dev\\\");\\n        _;\\n    }\\n\\n    function setPendingAdmin(address payable newPendingAdmin) external virtual onlyAdmin {\\n        // Save current value, if any, for inclusion in log\\n        address oldPendingAdmin = pendingAdmin;\\n        // Store pendingAdmin with value newPendingAdmin\\n        pendingAdmin = newPendingAdmin;\\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\\n    }\\n\\n    function acceptAdmin() external virtual {\\n        require(msg.sender == pendingAdmin, \\\"Only pendingAdmin\\\");\\n        // Save current values for inclusion in log\\n        address oldAdmin = admin;\\n        address oldPendingAdmin = pendingAdmin;\\n        // Store admin with value pendingAdmin\\n        admin = pendingAdmin;\\n        // Clear the pending value\\n        pendingAdmin = payable(0);\\n        emit NewAdmin(oldAdmin, admin);\\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\\n    }\\n\\n    function checkAdmin() private view {\\n        require(msg.sender == admin, \\\"caller must be admin\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.2) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Tree proofs.\\n *\\n * The tree and the proofs can be generated using our\\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\\n * You will find a quickstart guide in the readme.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the merkle tree could be reinterpreted as a leaf value.\\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\\n * against this attack out of the box.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {verify}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\\n        return processProofCalldata(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processProof}\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            computedHash = _hashPair(computedHash, proof[i]);\\n        }\\n        return computedHash;\\n    }\\n\\n    /**\\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerify(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProof(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Calldata version of {multiProofVerify}\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function multiProofVerifyCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32 root,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bool) {\\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\\n     * respectively.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProof(\\n        bytes32[] memory proof,\\n        bool[] memory proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofLen = proof.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proofLen - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            require(proofPos == proofLen, \\\"MerkleProof: invalid multiproof\\\");\\n            unchecked {\\n                return hashes[totalHashes - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    /**\\n     * @dev Calldata version of {processMultiProof}.\\n     *\\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\\n     *\\n     * _Available since v4.7._\\n     */\\n    function processMultiProofCalldata(\\n        bytes32[] calldata proof,\\n        bool[] calldata proofFlags,\\n        bytes32[] memory leaves\\n    ) internal pure returns (bytes32 merkleRoot) {\\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\\n        // the merkle tree.\\n        uint256 leavesLen = leaves.length;\\n        uint256 proofLen = proof.length;\\n        uint256 totalHashes = proofFlags.length;\\n\\n        // Check proof validity.\\n        require(leavesLen + proofLen - 1 == totalHashes, \\\"MerkleProof: invalid multiproof\\\");\\n\\n        // The xxxPos values are \\\"pointers\\\" to the next value to consume in each array. All accesses are done using\\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \\\"pop\\\".\\n        bytes32[] memory hashes = new bytes32[](totalHashes);\\n        uint256 leafPos = 0;\\n        uint256 hashPos = 0;\\n        uint256 proofPos = 0;\\n        // At each step, we compute the next hash using two values:\\n        // - a value from the \\\"main queue\\\". If not all leaves have been consumed, we get the next leaf, otherwise we\\n        //   get the next hash.\\n        // - depending on the flag, either another value from the \\\"main queue\\\" (merging branches) or an element from the\\n        //   `proof` array.\\n        for (uint256 i = 0; i < totalHashes; i++) {\\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\\n            bytes32 b = proofFlags[i]\\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\\n                : proof[proofPos++];\\n            hashes[i] = _hashPair(a, b);\\n        }\\n\\n        if (totalHashes > 0) {\\n            require(proofPos == proofLen, \\\"MerkleProof: invalid multiproof\\\");\\n            unchecked {\\n                return hashes[totalHashes - 1];\\n            }\\n        } else if (leavesLen > 0) {\\n            return leaves[0];\\n        } else {\\n            return proof[0];\\n        }\\n    }\\n\\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oleToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_xole\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_minXOLELockDuration\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyRecycled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AlreadyVested\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ExceedMax\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Expired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IncorrectMerkleProof\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientTransfersIn\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPenalty\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTime\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotExpired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotStarted\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epochId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ConvertedToXOLE\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epochId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expireTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vestDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"penaltyBase\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"penaltyAdd\",\"type\":\"uint16\"}],\"name\":\"EpochAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"NewAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldPendingAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"NewPendingAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PenaltyWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epochId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"recycledAmount\",\"type\":\"uint256\"}],\"name\":\"Recycled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epochId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vestTime\",\"type\":\"uint256\"}],\"name\":\"VestStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epochId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"penalty\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epochId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1MaxAmount\",\"type\":\"uint256\"}],\"name\":\"convertAndIncreaseXoleAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epochId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"token1MaxAmount\",\"type\":\"uint256\"}],\"name\":\"convertAndIncreaseXoleAmountForOthers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epochId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1MaxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"}],\"name\":\"convertToNewXole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epochId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"token1MaxAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockTime\",\"type\":\"uint256\"}],\"name\":\"convertToNewXoleForOthers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"developer\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epochId\",\"type\":\"uint256\"}],\"name\":\"earlyExit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochIdx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"epochs\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expireTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"penaltyBase\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"penaltyAdd\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"recycled\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_epochId\",\"type\":\"uint256\"}],\"name\":\"getEarlyExitWithdrawable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"penalty\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_epochIds\",\"type\":\"uint256[]\"}],\"name\":\"getWithdrawable\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"results\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minXOLELockDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expireTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"penaltyBase\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"penaltyAdd\",\"type\":\"uint16\"}],\"name\":\"newEpoch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oleToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"contract IUniV2ClassPair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_epochIds\",\"type\":\"uint256[]\"}],\"name\":\"recycle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vestStartTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minXOLELockDuration\",\"type\":\"uint256\"}],\"name\":\"setMinXOLELockDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"setPendingAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_epochId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_balance\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"verifyVest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_epochId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_balance\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"vest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epochId\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_epochIds\",\"type\":\"uint256[]\"}],\"name\":\"withdrawMul\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawPenalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawablePenalty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"xole\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "RewardDistributor", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000b7e2713cf55cf4b469b5a8421ae6fc0ed18f146700000000000000000000000044f508dcda27e8afa647cd978510eac5e63e16a40000000000000000000000008ac76a51cc950d9822d68b83fe1ad97b32cd580d00000000000000000000000071f1158d76af5b6762d5ebcdee19105eab2c77d2000000000000000000000000000000000000000000000000000000000024ea00", "EVMVersion": "london", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}