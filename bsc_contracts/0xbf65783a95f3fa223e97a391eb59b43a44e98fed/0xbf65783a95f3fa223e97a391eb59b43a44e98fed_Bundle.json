{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/6/protocol/core/Bundle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.6.12;\\n\\nimport \\\"./BToken.sol\\\";\\nimport \\\"./BMath.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\\\";\\nimport \\\"../interfaces/IUnbinder.sol\\\";\\nimport \\\"../interfaces/IBundle.sol\\\";\\n\\n/************************************************************************************************\\nOriginally forked from https://github.com/balancer-labs/balancer-core/\\n\\nThis source code has been modified from the original, which was copied from the github repository\\nat commit hash f4ed5d65362a8d6cec21662fb6eae233b0babc1f.\\n\\nSubject to the GPL-3.0 license\\n*************************************************************************************************/\\n\\ncontract Bundle is Initializable, BToken, BMath, IBundle {\\n    using SafeERC20Upgradeable for IERC20Upgradeable;\\n\\n    /* ========== Modifiers ========== */\\n\\n    modifier _lock_() {\\n        require(!_mutex, \\\"ERR_REENTRY\\\");\\n        _mutex = true;\\n        _;\\n        _mutex = false;\\n    }\\n\\n    modifier _viewlock_() {\\n        require(!_mutex, \\\"ERR_REENTRY\\\");\\n        _;\\n    }\\n\\n    modifier _public_() {\\n        require(_publicSwap, \\\"ERR_NOT_PUBLIC\\\");\\n        _;\\n    }\\n\\n    modifier _control_() {\\n        require(msg.sender == _controller, \\\"ERR_NOT_CONTROLLER\\\");\\n        _;\\n    }\\n\\n    modifier _rebalance_() {\\n        require(msg.sender == _rebalancer && _rebalancable, \\\"ERR_BAD_REBALANCE\\\");\\n        _;\\n    }\\n\\n    /* ========== Storage ========== */\\n\\n    bool private _mutex;\\n\\n    // Can use functions behind the _control_ modifier\\n    address private _controller;\\n    \\n    // Can rebalance the pool\\n    address private _rebalancer;\\n\\n    // true if PUBLIC can call SWAP functions\\n    bool private _publicSwap;\\n\\n    // swap fee\\n    uint256 private _swapFee;\\n\\n    // exit fee\\n    uint256 private _exitFee;\\n\\n    // Array of token addresses\\n    address[] private _tokens;\\n\\n    // Records for each token\\n    mapping(address=>Record) private  _records;\\n\\n    // Mapping of minimum balances for tokens added to the pool \\n    mapping(address=>uint256) private _minBalances;\\n\\n    // Sum of token denorms\\n    uint256 private _totalWeight;\\n\\n    // Streaming fee\\n    uint256 private _streamingFee;\\n\\n    // Start time for streaming fee\\n    uint256 private _lastStreamingTime;\\n\\n    // Time delay for reweighting\\n    uint256 private _targetDelta;\\n\\n    // Is rebalancable\\n    bool private _rebalancable;\\n\\n    // Contract that handles unbound tokens\\n    IUnbinder private _unbinder;\\n\\n    /* ========== Initialization ========== */\\n\\n    /**\\n     * @dev Initializer function for upgradeability\\n     * TODO: Set unbound handler on initialization\\n     */\\n    function initialize(\\n        address controller, \\n        address rebalancer,\\n        address unbinder,\\n        string calldata name, \\n        string calldata symbol\\n    )\\n        public override\\n        initializer\\n    {\\n        _initializeToken(name, symbol);\\n        _controller = controller;\\n        _rebalancer = rebalancer;\\n        _unbinder = IUnbinder(unbinder);\\n        _swapFee = INIT_FEE;\\n        _streamingFee = INIT_STREAMING_FEE;\\n        _exitFee = INIT_EXIT_FEE;\\n        _publicSwap = false;\\n        _targetDelta = INIT_TARGET_DELTA;\\n    }\\n\\n    /** @dev Setup function to initialize the pool after contract creation */\\n    function setup(\\n        address[] calldata tokens,\\n        uint256[] calldata balances,\\n        uint256[] calldata denorms,\\n        address tokenProvider\\n    )\\n        external override\\n        _control_\\n    {\\n        require(_tokens.length == 0, \\\"ERR_ALREADY_SETUP\\\");\\n        require(tokens.length >= MIN_BOUND_TOKENS && tokens.length <= MAX_BOUND_TOKENS, \\\"ERR_BAD_TOKEN_LENGTH\\\");\\n        require(balances.length == tokens.length && denorms.length == tokens.length, \\\"ERR_ARR_LEN\\\");\\n\\n        uint256 totalWeight = 0;\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            uint256 denorm = denorms[i];\\n            uint256 balance = balances[i];\\n\\n            require(denorm >= MIN_WEIGHT && denorm <= MAX_WEIGHT, \\\"ERR_BAD_WEIGHT\\\");\\n            require(balance >= MIN_BALANCE, \\\"ERR_MIN_BALANCE\\\");\\n\\n            address token = tokens[i];\\n            require(!_records[token].bound, \\\"ERR_DUPLICATE_TOKEN\\\");\\n            _records[token] = Record({\\n                bound: true,\\n                ready: true,\\n                denorm: denorm,\\n                targetDenorm: denorm,\\n                targetTime: 0,\\n                lastUpdateTime: 0,\\n                index: uint8(i),\\n                balance: balance\\n            });\\n\\n            _tokens.push(token);\\n            totalWeight = badd(totalWeight, denorm);\\n            // Move underlying asset to pool\\n            _pullUnderlying(token, tokenProvider, balance);\\n        }\\n\\n        require(totalWeight <= MAX_TOTAL_WEIGHT, \\\"ERR_MAX_TOTAL_WEIGHT\\\");\\n        _totalWeight = totalWeight;\\n        _publicSwap = true;\\n        _lastStreamingTime = block.timestamp;\\n        _rebalancable = true;\\n        emit LogPublicSwapEnabled();\\n        _mintPoolShare(INIT_POOL_SUPPLY);\\n        _pushPoolShare(tokenProvider, INIT_POOL_SUPPLY);\\n    }\\n\\n    /* ==========  Control  ========== */\\n\\n    function setSwapFee(uint256 swapFee)\\n        external override\\n        _control_\\n    { \\n        require(swapFee >= MIN_FEE && swapFee <= MAX_FEE, \\\"ERR_BAD_FEE\\\");\\n        _swapFee = swapFee;\\n        emit LogSwapFeeUpdated(msg.sender, swapFee);\\n    }\\n\\n    function setRebalancable(bool rebalancable)\\n        external override\\n        _control_\\n    {\\n        _rebalancable = rebalancable;\\n        emit LogRebalancable(msg.sender, _rebalancable);\\n    }\\n\\n    function setMinBalance(address token, uint256 minBalance) \\n        external override\\n        _control_\\n    {\\n        require(_records[token].bound && !_records[token].ready, \\\"ERR_BAD_TOKEN\\\");\\n        _minBalances[token] = minBalance;\\n        emit LogMinBalance(msg.sender, token, minBalance);\\n    }\\n\\n    function setStreamingFee(uint256 streamingFee) \\n        external override\\n        _control_\\n    {\\n        require(streamingFee < MAX_STREAMING_FEE, \\\"ERR_MAX_STREAMING_FEE\\\");\\n        _streamingFee = streamingFee;\\n        emit LogStreamingFee(msg.sender, streamingFee);\\n    }\\n\\n    function setExitFee(uint256 exitFee) \\n        external override\\n        _control_\\n    {\\n        require(exitFee < MAX_EXIT_FEE, \\\"ERR_MAX_STREAMING_FEE\\\");\\n        _exitFee = exitFee;\\n        emit LogExitFee(msg.sender, exitFee);\\n    }\\n\\n    function setTargetDelta(uint256 targetDelta)\\n        external override\\n        _control_\\n    {\\n        require(targetDelta >= MIN_TARGET_DELTA && targetDelta <= MAX_TARGET_DELTA, \\\"ERR_TARGET_DELTA\\\");\\n        _targetDelta = targetDelta;\\n        emit LogTargetDelta(msg.sender, targetDelta);\\n    }\\n\\n    function collectStreamingFee()\\n        external override\\n        _lock_\\n        _control_\\n    {\\n        require(_tokens.length > 0, \\\"ERR_SETUP\\\");\\n        require(_lastStreamingTime < block.timestamp, \\\"ERR_COLLECTION_TO_SOON\\\");\\n\\n        uint256 timeDelta = bsub(block.timestamp, _lastStreamingTime);\\n\\n        for (uint256 i = 0; i < _tokens.length; i++) {\\n            address token = _tokens[i];\\n\\n            // Shouldnt withdraw tokens if not ready\\n            if (_records[token].ready) {\\n                uint256 fee = bdiv(\\n                    bmul(bmul(_records[token].balance, _streamingFee), timeDelta),\\n                    BPY\\n                );\\n\\n                _pushUnderlying(token, _controller, fee);\\n                _updateToken(token, bsub(_records[token].balance, fee));\\n            }\\n        }\\n\\n        _lastStreamingTime = block.timestamp;\\n        emit LogCollectFee(msg.sender);\\n    }\\n\\n    /* ==========  Getters  ========== */\\n\\n    function isPublicSwap()\\n        external view override\\n        returns (bool)\\n    {\\n        return _publicSwap;\\n    }\\n\\n    function isBound(address t)\\n        external view override\\n        returns (bool)\\n    {\\n        return _records[t].bound;\\n    }\\n\\n    function isReady(address t)\\n        external view override\\n        returns (bool)\\n    {\\n        return _records[t].ready;\\n    }\\n\\n    function getNumTokens()\\n        external view override\\n        returns (uint256) \\n    {\\n        return _tokens.length;\\n    }\\n\\n    function getCurrentTokens()\\n        external view override \\n        _viewlock_\\n        returns (address[] memory tokens)\\n    {\\n        return _tokens;\\n    }\\n\\n    function getDenormalizedWeight(address token)\\n        external view override\\n        _viewlock_\\n        returns (uint256)\\n    {\\n\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        return _records[token].denorm;\\n    }\\n\\n    function getTotalDenormalizedWeight()\\n        external view override\\n        _viewlock_\\n        returns (uint256)\\n    {\\n        return _totalWeight;\\n    }\\n\\n    function getBalance(address token)\\n        external view override\\n        _viewlock_\\n        returns (uint256)\\n    {\\n\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        return _records[token].balance;\\n    }\\n\\n    function getSwapFee()\\n        external view override\\n        _viewlock_\\n        returns (uint256)\\n    {\\n        return _swapFee;\\n    }\\n\\n    function getStreamingFee()\\n        external view override\\n        _viewlock_\\n        returns (uint256)\\n    {\\n        return _streamingFee;\\n    }\\n\\n    function getExitFee()\\n        external view override\\n        _viewlock_\\n        returns (uint256)\\n    {\\n        return _exitFee;\\n    }\\n\\n    function getController()\\n        external view override\\n        _viewlock_\\n        returns (address)\\n    {\\n        return _controller;\\n    }\\n\\n    function getRebalancer()\\n        external view override\\n        _viewlock_\\n        returns (address)\\n    {\\n        return _rebalancer;\\n    }\\n\\n    function getRebalancable()\\n        external view override\\n        _viewlock_\\n        returns (bool)\\n    {\\n        return _rebalancable;\\n    }\\n\\n    function getUnbinder()\\n        external view override\\n        _viewlock_\\n        returns (address)\\n    {\\n        return address(_unbinder);\\n    }\\n\\n    function getSpotPrice(address tokenIn, address tokenOut)\\n        external view override\\n        _viewlock_\\n        returns (uint256 spotPrice)\\n    {\\n        require(_records[tokenIn].bound && _records[tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\n        Record storage inRecord = _records[tokenIn];\\n        Record storage outRecord = _records[tokenOut];\\n        return calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, _swapFee);\\n    }\\n\\n    function getSpotPriceSansFee(address tokenIn, address tokenOut)\\n        external view override\\n        _viewlock_\\n        returns (uint256 spotPrice)\\n    {\\n        require(_records[tokenIn].bound && _records[tokenOut].bound, \\\"ERR_NOT_BOUND\\\");\\n        Record storage inRecord = _records[tokenIn];\\n        Record storage outRecord = _records[tokenOut];\\n        return calcSpotPrice(inRecord.balance, inRecord.denorm, outRecord.balance, outRecord.denorm, 0);\\n    }\\n\\n    /* ==========  External Token Weighting  ========== */\\n\\n    /**\\n     * @dev Adjust weights for existing tokens\\n     * @param tokens A set of token addresses to adjust\\n     * @param targetDenorms A set of denorms to linearly update to\\n     */\\n\\n    function reweighTokens(\\n        address[] calldata tokens,\\n        uint256[] calldata targetDenorms\\n    )\\n        external override\\n        _lock_\\n        _control_\\n    {\\n        require(targetDenorms.length == tokens.length, \\\"ERR_ARR_LEN\\\");\\n\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            uint256 denorm = targetDenorms[i];\\n            if (denorm < MIN_WEIGHT) denorm = MIN_WEIGHT;\\n            _setTargetDenorm(tokens[i], denorm);\\n        }\\n\\n        emit LogReweigh(msg.sender, tokens, targetDenorms);\\n    }\\n\\n    /**\\n     * @dev Reindex the pool on a new set of tokens\\n     *\\n     * @param tokens A set of token addresses to be indexed\\n     * @param targetDenorms A set of denorms to linearly update to\\n     * @param minBalances Minimum balance thresholds for unbound assets\\n     */\\n    function reindexTokens(\\n        address[] calldata tokens,\\n        uint256[] calldata targetDenorms,\\n        uint256[] calldata minBalances\\n    )\\n        external override\\n        _lock_\\n        _control_\\n    {\\n        require(\\n            targetDenorms.length == tokens.length && minBalances.length == tokens.length,\\n            \\\"ERR_ARR_LEN\\\"\\n        );\\n        uint256 unbindCounter = 0;\\n        bool[] memory receivedIndices = new bool[](_tokens.length);\\n        Record[] memory records = new Record[](tokens.length);\\n\\n        // Mark which tokens on reindexing call are already in pool\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            records[i] = _records[tokens[i]];\\n            if (records[i].bound) receivedIndices[records[i].index] = true;\\n        }\\n\\n        // If any bound tokens were not sent in this call\\n        // set their target weights to 0 and increment counter\\n        for (uint256 i = 0; i < _tokens.length; i++) {\\n            if (!receivedIndices[i]) {\\n                _setTargetDenorm(_tokens[i], 0);\\n                unbindCounter++;\\n            }\\n        }\\n\\n        require(unbindCounter <= _tokens.length - MIN_BOUND_TOKENS, \\\"ERR_MAX_UNBIND\\\");\\n\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            // If an input weight is less than the minimum weight, use that instead.\\n            uint256 denorm = targetDenorms[i];\\n            if (denorm < MIN_WEIGHT) denorm = MIN_WEIGHT;\\n            if (!records[i].bound) {\\n                // If the token is not bound, bind it.\\n                _bind(tokens[i], minBalances[i], denorm);\\n            } else {\\n                _setTargetDenorm(tokens[i], denorm);\\n            }\\n        }\\n\\n        // Ensure the number of tokens at equilibrium from this \\n        // operation is lte max bound tokens\\n        require(_tokens.length - unbindCounter <= MAX_BOUND_TOKENS, \\\"ERR_MAX_BOUND_TOKENS\\\");\\n        emit LogReindex(msg.sender, tokens, targetDenorms, minBalances);\\n\\n    }\\n\\n    /* ==========  Internal Token Weighting  ========== */\\n\\n    /**\\n     * @dev Bind a new token to the pool, may cause tokens to exceed max assets temporarily\\n     *\\n     * @param token Token to add to the pool\\n     * @param minBalance A set of denorms to linearly update to\\n     * @param denorm The target denorm to gradually adjust to\\n     */\\n    function _bind(address token, uint256 minBalance, uint256 denorm)\\n        internal\\n    {\\n        require(!_records[token].bound, \\\"ERR_IS_BOUND\\\");\\n        require(denorm >= MIN_WEIGHT && denorm <= MAX_WEIGHT, \\\"ERR_BAD_WEIGHT\\\");\\n        require(minBalance >= MIN_BALANCE, \\\"ERR_MIN_BALANCE\\\");\\n\\n        _records[token] = Record({\\n            bound: true,\\n            ready: false,\\n            denorm: 0,\\n            targetDenorm: denorm,\\n            targetTime: badd(block.timestamp, _targetDelta),\\n            lastUpdateTime: block.timestamp,\\n            index: uint8(_tokens.length),\\n            balance: 0\\n        });\\n\\n        _tokens.push(token);\\n        _minBalances[token] = minBalance;\\n        emit LogTokenBound(token);\\n    }\\n\\n    /**\\n     * @dev Unbind a token from the pool\\n     *\\n     * @param token Token to remove from the pool\\n     */\\n    function _unbind(address token)\\n        internal\\n    {\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n\\n        uint256 tokenBalance = _records[token].balance;\\n        _totalWeight = bsub(_totalWeight, _records[token].denorm);\\n\\n        // Swap the token-to-unbind with the last token,\\n        // then delete the last token\\n        uint256 index = _records[token].index;\\n        uint256 last = _tokens.length - 1;\\n        _tokens[index] = _tokens[last];\\n        _records[_tokens[index]].index = uint8(index);\\n        _tokens.pop();\\n        _records[token] = Record({\\n            bound: false,\\n            ready: false,\\n            index: 0,\\n            denorm: 0,\\n            targetDenorm: 0,\\n            targetTime: 0,\\n            lastUpdateTime: 0,\\n            balance: 0\\n        });\\n\\n        _pushUnderlying(token, address(_unbinder), tokenBalance);\\n        _unbinder.handleUnboundToken(token);\\n        emit LogTokenUnbound(token);\\n    }\\n\\n    /**\\n     * @dev Set the target denorm of a token\\n     * linearly adjusts by time + _targetDelta\\n     *\\n     * @param token Token to adjust\\n     * @param denorm Target denorm to set\\n     */\\n    function _setTargetDenorm(address token, uint256 denorm) \\n        internal\\n    {\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        require(denorm >= MIN_WEIGHT || denorm == 0, \\\"ERR_MIN_WEIGHT\\\");\\n        require(denorm <= MAX_WEIGHT, \\\"ERR_MAX_WEIGHT\\\");\\n        _updateDenorm(token);\\n        _records[token].targetDenorm = denorm;\\n        _records[token].targetTime = badd(block.timestamp, _targetDelta);\\n        _records[token].lastUpdateTime = block.timestamp;\\n    }\\n\\n    /**\\n     * @dev Updates the denorm on a given token to match target\\n     *\\n     * @param token Token to update denorm for\\n     */\\n    function _updateDenorm(address token)\\n        internal\\n    {\\n        require(_records[token].bound, \\\"ERR_NOT_BOUND\\\");\\n        Record storage record = _records[token];\\n\\n        if (record.denorm != record.targetDenorm) {\\n            _totalWeight = bsub(_totalWeight, record.denorm);\\n            record.denorm = calcDenorm(\\n                record.lastUpdateTime, \\n                block.timestamp, \\n                record.targetTime, \\n                record.denorm, \\n                record.targetDenorm\\n            );\\n            _totalWeight = badd(_totalWeight, record.denorm);\\n            record.lastUpdateTime = bmin(block.timestamp, record.targetTime);\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs a full update on a tokens state\\n     *\\n     * @param token Token to adjust\\n     * @param balance New token balance\\n     */\\n    function _updateToken(\\n        address token,\\n        uint256 balance\\n    )\\n        internal\\n    {\\n        Record storage record = _records[token];\\n        if (!record.ready) {\\n            // Check if the minimum balance has been reached\\n            if (balance >= _minBalances[token]) {\\n                // Mark the token as ready\\n                record.ready = true;\\n                emit LogTokenReady(token);\\n                // Set the initial denorm value to the minimum weight times one plus\\n                // the ratio of the increase in balance over the minimum to the minimum\\n                // balance.\\n                // weight = min((1 + ((bal - min_bal) / min_bal)) * min_weight, MAX_WEIGHT)\\n                uint256 denorm = bmin(\\n                    badd(\\n                        MIN_WEIGHT, \\n                        bmul(MIN_WEIGHT, bdiv(bsub(balance, _minBalances[token]), _minBalances[token]))\\n                    ),\\n                    MAX_WEIGHT\\n                );\\n\\n                record.denorm = denorm;\\n                record.lastUpdateTime = block.timestamp;\\n                record.targetTime = badd(block.timestamp, _targetDelta);\\n                _totalWeight = badd(_totalWeight, record.denorm);\\n                // Remove the minimum balance record\\n                _minBalances[token] = 0;\\n            } else {\\n                uint256 currBalance = _getBalance(token);\\n                uint256 realToMinRatio = bdiv(bsub(currBalance, balance), currBalance);\\n                uint256 weightPremium = bmul(MIN_WEIGHT / 10, realToMinRatio);\\n                record.denorm = badd(MIN_WEIGHT, weightPremium);\\n            }\\n            record.balance = balance;\\n        } else {\\n            // Update denorm if token is ready\\n            _updateDenorm(token);\\n            record.balance = balance;\\n            // Always check if token needs to be unbound\\n            if (record.denorm < MIN_WEIGHT) {\\n                _unbind(token);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Internal view to get the current treatment balance for a token\\n     *\\n     * @param token Token to get balance for\\n     */\\n    function _getBalance(\\n        address token\\n    )\\n        internal view\\n        returns (uint256)\\n    {\\n        if (_records[token].ready) {\\n            return _records[token].balance;\\n        } else {\\n            return _minBalances[token];\\n        }\\n    }\\n\\n    // Absorb any tokens that have been sent to this contract into the pool\\n    function gulp(address token)\\n        external override\\n        _lock_\\n    {\\n        Record storage record = _records[token];\\n        uint256 balance = IERC20Upgradeable(token).balanceOf(address(this));\\n        if (record.bound) {\\n            _updateToken(token, balance);\\n        } else {\\n            _pushUnderlying(token, address(_unbinder), balance);\\n            _unbinder.handleUnboundToken(token);\\n        }\\n    }\\n\\n    /* ==========  Pool Entry/Exit  ========== */\\n\\n    function joinPool(uint256 poolAmountOut, uint[] calldata maxAmountsIn)\\n        external override\\n        _public_\\n        _lock_\\n    {\\n        require(maxAmountsIn.length == _tokens.length, \\\"ERR_ARR_LEN\\\");\\n\\n        uint256 poolTotal = totalSupply();\\n        uint256 ratio = bdiv(poolAmountOut, poolTotal);\\n        require(ratio != 0, \\\"ERR_MATH_APPROX\\\");\\n\\n        for (uint256 i = 0; i < _tokens.length; i++) {\\n            address t = _tokens[i];\\n            uint256 bal = _getBalance(t);\\n            uint256 tokenAmountIn = bmul(ratio, bal);\\n            require(tokenAmountIn != 0, \\\"ERR_MATH_APPROX\\\");\\n            require(tokenAmountIn <= maxAmountsIn[i], \\\"ERR_LIMIT_IN\\\");\\n            _pullUnderlying(t, msg.sender, tokenAmountIn);\\n            _updateToken(t, badd(_records[t].balance, tokenAmountIn));\\n            emit LogJoin(msg.sender, t, tokenAmountIn);\\n        }\\n        _mintPoolShare(poolAmountOut);\\n        _pushPoolShare(msg.sender, poolAmountOut);\\n    }\\n\\n    function exitPool(uint256 poolAmountIn, uint[] calldata minAmountsOut)\\n        external override\\n        _public_\\n        _lock_\\n    {\\n        uint256 poolTotal = totalSupply();\\n        uint256 exitFee = bmul(poolAmountIn, _exitFee);\\n        uint256 pAiAfterExitFee = bsub(poolAmountIn, exitFee);\\n        uint256 ratio = bdiv(pAiAfterExitFee, poolTotal);\\n        require(ratio != 0, \\\"ERR_MATH_APPROX\\\");\\n\\n        _pullPoolShare(msg.sender, poolAmountIn);\\n        _pushPoolShare(_controller, exitFee);\\n        _burnPoolShare(pAiAfterExitFee);\\n\\n        for (uint256 i = 0; i < _tokens.length; i++) {\\n            address t = _tokens[i];\\n            Record storage record = _records[t];\\n\\n            if (record.ready) {\\n                uint256 tokenAmountOut = bmul(ratio, record.balance);\\n                require(tokenAmountOut != 0, \\\"ERR_MATH_APPROX\\\");\\n                require(tokenAmountOut >= minAmountsOut[i], \\\"ERR_LIMIT_OUT\\\");\\n                _pushUnderlying(t, msg.sender, tokenAmountOut);\\n                _updateToken(t, bsub(record.balance, tokenAmountOut));\\n                emit LogExit(msg.sender, t, tokenAmountOut);\\n            } else {\\n                // Uninitialized tokens cannot exit the pool\\n                require(minAmountsOut[i] == 0, \\\"ERR_NOT_READY\\\");\\n            }\\n        }\\n    }\\n\\n    /* ==========  Swaps  ========== */\\n\\n    function swapExactAmountIn(\\n        address tokenIn,\\n        uint256 tokenAmountIn,\\n        address tokenOut,\\n        uint256 minAmountOut,\\n        uint256 maxPrice\\n    )\\n        external override\\n        _lock_\\n        _public_\\n        _rebalance_\\n        returns (uint256 tokenAmountOut, uint256 spotPriceAfter)\\n    {\\n        require(_records[tokenIn].bound, \\\"ERR_TOKEN_IN\\\");\\n        require(_records[tokenOut].bound && _records[tokenOut].ready, \\\"ERR_TOKEN_OUT\\\");\\n\\n        Record storage inRecord = _records[tokenIn];\\n        uint256 inRecordBalance = _getBalance(tokenIn);\\n        Record storage outRecord = _records[tokenOut];\\n\\n        require(tokenAmountIn <= bmul(inRecord.balance, MAX_IN_RATIO), \\\"ERR_MAX_IN_RATIO\\\");\\n\\n        uint256 spotPriceBefore = calcSpotPrice(\\n                                    inRecordBalance,\\n                                    inRecord.denorm,\\n                                    outRecord.balance,\\n                                    outRecord.denorm,\\n                                    _swapFee\\n                                );\\n        require(spotPriceBefore <= maxPrice, \\\"ERR_BAD_LIMIT_PRICE\\\");\\n\\n        tokenAmountOut = calcOutGivenIn(\\n                            inRecordBalance,\\n                            inRecord.denorm,\\n                            outRecord.balance,\\n                            outRecord.denorm,\\n                            tokenAmountIn,\\n                            _swapFee\\n                        );\\n        require(tokenAmountOut >= minAmountOut, \\\"ERR_LIMIT_OUT\\\");\\n\\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\\n\\n        // Update tokens\\n        _updateToken(tokenIn, badd(inRecord.balance, tokenAmountIn));\\n        _updateToken(tokenOut, bsub(outRecord.balance, tokenAmountOut));\\n\\n        spotPriceAfter = calcSpotPrice(\\n                                _getBalance(tokenIn),\\n                                inRecord.denorm,\\n                                outRecord.balance,\\n                                outRecord.denorm,\\n                                _swapFee\\n                            );\\n        require(spotPriceAfter >= spotPriceBefore, \\\"ERR_MATH_APPROX\\\");     \\n        require(spotPriceAfter <= maxPrice, \\\"ERR_LIMIT_PRICE\\\");\\n        require(spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut), \\\"ERR_MATH_APPROX\\\");\\n\\n        emit LogSwap(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\\n\\n        return (tokenAmountOut, spotPriceAfter);\\n    }\\n\\n    function swapExactAmountOut(\\n        address tokenIn,\\n        uint256 maxAmountIn,\\n        address tokenOut,\\n        uint256 tokenAmountOut,\\n        uint256 maxPrice\\n    )\\n        external override\\n        _lock_\\n        _public_\\n        _rebalance_\\n        returns (uint256 tokenAmountIn, uint256 spotPriceAfter)\\n    {\\n        require(_records[tokenIn].bound, \\\"ERR_TOKEN_IN\\\");\\n        require(_records[tokenOut].bound && _records[tokenOut].ready, \\\"ERR_TOKEN_OUT\\\");\\n\\n        Record storage inRecord = _records[tokenIn];\\n        uint256 inRecordBalance = _getBalance(tokenIn);\\n        Record storage outRecord = _records[tokenOut];\\n\\n        require(tokenAmountOut <= bmul(outRecord.balance, MAX_OUT_RATIO), \\\"ERR_MAX_OUT_RATIO\\\");\\n\\n        uint256 spotPriceBefore = calcSpotPrice(\\n                                    inRecordBalance,\\n                                    inRecord.denorm,\\n                                    outRecord.balance,\\n                                    outRecord.denorm,\\n                                    _swapFee\\n                                );\\n        require(spotPriceBefore <= maxPrice, \\\"ERR_BAD_LIMIT_PRICE\\\");\\n\\n        tokenAmountIn = calcInGivenOut(\\n                            inRecordBalance,\\n                            inRecord.denorm,\\n                            outRecord.balance,\\n                            outRecord.denorm,\\n                            tokenAmountOut,\\n                            _swapFee\\n                        );\\n        require(tokenAmountIn <= maxAmountIn, \\\"ERR_LIMIT_IN\\\");\\n\\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\\n\\n        // Update tokens\\n        _updateToken(tokenIn, badd(inRecord.balance, tokenAmountIn));\\n        _updateToken(tokenOut, bsub(outRecord.balance, tokenAmountOut));\\n\\n        spotPriceAfter = calcSpotPrice(\\n                                _getBalance(tokenIn),\\n                                inRecord.denorm,\\n                                outRecord.balance,\\n                                outRecord.denorm,\\n                                _swapFee\\n                            );\\n        require(spotPriceAfter >= spotPriceBefore, \\\"ERR_MATH_APPROX\\\");\\n        require(spotPriceAfter <= maxPrice, \\\"ERR_LIMIT_PRICE\\\");\\n        require(spotPriceBefore <= bdiv(tokenAmountIn, tokenAmountOut), \\\"ERR_MATH_APPROX\\\");\\n\\n        emit LogSwap(msg.sender, tokenIn, tokenOut, tokenAmountIn, tokenAmountOut);\\n\\n        return (tokenAmountIn, spotPriceAfter);\\n    }\\n\\n    /* ==========  Internal Helpers  ========== */\\n\\n    // ==\\n    // 'Underlying' token-manipulation functions make external calls but are NOT locked\\n    // You must `_lock_` or otherwise ensure reentry-safety\\n\\n    function _pullUnderlying(address erc20, address from, uint256 amount)\\n        internal\\n    {\\n        IERC20Upgradeable(erc20).safeTransferFrom(from, address(this), amount);\\n    }\\n\\n    function _pushUnderlying(address erc20, address to, uint256 amount)\\n        internal\\n    {\\n        IERC20Upgradeable(erc20).safeTransfer(to, amount);\\n    }\\n\\n    function _pullPoolShare(address from, uint256 amount)\\n        internal\\n    {\\n        _pull(from, amount);\\n    }\\n\\n    function _pushPoolShare(address to, uint256 amount)\\n        internal\\n    {\\n        _push(to, amount);\\n    }\\n\\n    function _mintPoolShare(uint256 amount)\\n        internal\\n    {\\n        _mint(amount);\\n    }\\n\\n    function _burnPoolShare(uint256 amount)\\n        internal\\n    {\\n        _burn(amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/6/protocol/core/BToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.6.12;\\n\\nimport \\\"./BNum.sol\\\";\\nimport \\\"../interfaces/IERC20.sol\\\";\\n\\n/************************************************************************************************\\nOriginally forked from https://github.com/balancer-labs/balancer-core/\\n\\nThis source code has been modified from the original, which was copied from the github repository\\nat commit hash f4ed5d65362a8d6cec21662fb6eae233b0babc1f.\\n\\nSubject to the GPL-3.0 license\\n*************************************************************************************************/\\n\\n// Highly opinionated token implementation\\n\\ncontract BTokenBase is BNum {\\n\\n    mapping(address => uint) internal _balance;\\n    mapping(address => mapping(address=>uint)) internal _allowance;\\n    uint internal _totalSupply;\\n\\n    event Approval(address indexed src, address indexed dst, uint amt);\\n    event Transfer(address indexed src, address indexed dst, uint amt);\\n\\n    function _mint(uint amt) internal {\\n        _balance[address(this)] = badd(_balance[address(this)], amt);\\n        _totalSupply = badd(_totalSupply, amt);\\n        emit Transfer(address(0), address(this), amt);\\n    }\\n\\n    function _burn(uint amt) internal {\\n        require(_balance[address(this)] >= amt, \\\"ERR_INSUFFICIENT_BAL\\\");\\n        _balance[address(this)] = bsub(_balance[address(this)], amt);\\n        _totalSupply = bsub(_totalSupply, amt);\\n        emit Transfer(address(this), address(0), amt);\\n    }\\n\\n    function _move(address src, address dst, uint amt) internal {\\n        require(_balance[src] >= amt, \\\"ERR_INSUFFICIENT_BAL\\\");\\n        _balance[src] = bsub(_balance[src], amt);\\n        _balance[dst] = badd(_balance[dst], amt);\\n        emit Transfer(src, dst, amt);\\n    }\\n\\n    function _push(address to, uint amt) internal {\\n        _move(address(this), to, amt);\\n    }\\n\\n    function _pull(address from, uint amt) internal {\\n        _move(from, address(this), amt);\\n    }\\n}\\n\\ncontract BToken is BTokenBase, IERC20 {\\n\\n    uint8 private constant DECIMALS = 18;\\n    string private _name;\\n    string private _symbol;\\n\\n    function _initializeToken(string memory name, string memory symbol) internal {\\n        require(bytes(_name).length == 0, \\\"ERR_BTOKEN_INITIALIZED\\\");\\n        require(bytes(name).length != 0 && bytes(symbol).length != 0, \\\"ERR_BAD_PARAMS\\\");\\n        _name = name;\\n        _symbol = symbol;\\n    }\\n\\n    function name() external override view returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() external override view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() external override view returns(uint8) {\\n        return DECIMALS;\\n    }\\n\\n    function allowance(address src, address dst) external override view returns (uint) {\\n        return _allowance[src][dst];\\n    }\\n\\n    function balanceOf(address whom) external override view returns (uint) {\\n        return _balance[whom];\\n    }\\n\\n    function totalSupply() public override view returns (uint) {\\n        return _totalSupply;\\n    }\\n\\n    function approve(address dst, uint amt) external override returns (bool) {\\n        _allowance[msg.sender][dst] = amt;\\n        emit Approval(msg.sender, dst, amt);\\n        return true;\\n    }\\n\\n    function increaseApproval(address dst, uint amt) external returns (bool) {\\n        _allowance[msg.sender][dst] = badd(_allowance[msg.sender][dst], amt);\\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\\n        return true;\\n    }\\n\\n    function decreaseApproval(address dst, uint amt) external returns (bool) {\\n        uint oldValue = _allowance[msg.sender][dst];\\n        if (amt > oldValue) {\\n            _allowance[msg.sender][dst] = 0;\\n        } else {\\n            _allowance[msg.sender][dst] = bsub(oldValue, amt);\\n        }\\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\\n        return true;\\n    }\\n\\n    function transfer(address dst, uint amt) external override returns (bool) {\\n        _move(msg.sender, dst, amt);\\n        return true;\\n    }\\n\\n    function transferFrom(address src, address dst, uint amt) external override returns (bool) {\\n        require(msg.sender == src || amt <= _allowance[src][msg.sender], \\\"ERR_BTOKEN_BAD_CALLER\\\");\\n        _move(src, dst, amt);\\n        if (msg.sender != src && _allowance[src][msg.sender] != uint256(-1)) {\\n            _allowance[src][msg.sender] = bsub(_allowance[src][msg.sender], amt);\\n            emit Approval(msg.sender, dst, _allowance[src][msg.sender]);\\n        }\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/6/protocol/core/BMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.6.12;\\n\\nimport \\\"./BNum.sol\\\";\\n\\n/************************************************************************************************\\nOriginally forked from https://github.com/balancer-labs/balancer-core/\\n\\nThis source code has been modified from the original, which was copied from the github repository\\nat commit hash f4ed5d65362a8d6cec21662fb6eae233b0babc1f.\\n\\nSubject to the GPL-3.0 license\\n*************************************************************************************************/\\n\\ncontract BMath is BConst, BNum {\\n    /**********************************************************************************************\\n    // calcSpotPrice                                                                             //\\n    // sP = spotPrice                                                                            //\\n    // bI = tokenBalanceIn                ( bI / wI )         1                                  //\\n    // bO = tokenBalanceOut         sP =  -----------  *  ----------                             //\\n    // wI = tokenWeightIn                 ( bO / wO )     ( 1 - sF )                             //\\n    // wO = tokenWeightOut                                                                       //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n    function calcSpotPrice(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint swapFee\\n    )\\n        internal pure\\n        returns (uint spotPrice)\\n    {\\n        uint numer = bdiv(tokenBalanceIn, tokenWeightIn);\\n        uint denom = bdiv(tokenBalanceOut, tokenWeightOut);\\n        uint ratio = bdiv(numer, denom);\\n        uint scale = bdiv(BONE, bsub(BONE, swapFee));\\n        return  (spotPrice = bmul(ratio, scale));\\n    }\\n\\n    /**********************************************************************************************\\n    // calcOutGivenIn                                                                            //\\n    // aO = tokenAmountOut                                                                       //\\n    // bO = tokenBalanceOut                                                                      //\\n    // bI = tokenBalanceIn              /      /            bI             \\\\    (wI / wO) \\\\      //\\n    // aI = tokenAmountIn    aO = bO * |  1 - | --------------------------  | ^            |     //\\n    // wI = tokenWeightIn               \\\\      \\\\ ( bI + ( aI * ( 1 - sF )) /              /      //\\n    // wO = tokenWeightOut                                                                       //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n    function calcOutGivenIn(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint tokenAmountIn,\\n        uint swapFee\\n    )\\n        internal pure\\n        returns (uint tokenAmountOut)\\n    {\\n        uint weightRatio = bdiv(tokenWeightIn, tokenWeightOut);\\n        uint adjustedIn = bsub(BONE, swapFee);\\n        adjustedIn = bmul(tokenAmountIn, adjustedIn);\\n        uint y = bdiv(tokenBalanceIn, badd(tokenBalanceIn, adjustedIn));\\n        uint foo = bpow(y, weightRatio);\\n        uint bar = bsub(BONE, foo);\\n        tokenAmountOut = bmul(tokenBalanceOut, bar);\\n        return tokenAmountOut;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcInGivenOut                                                                            //\\n    // aI = tokenAmountIn                                                                        //\\n    // bO = tokenBalanceOut               /  /     bO      \\\\    (wO / wI)      \\\\                 //\\n    // bI = tokenBalanceIn          bI * |  | ------------  | ^            - 1  |                //\\n    // aO = tokenAmountOut    aI =        \\\\  \\\\ ( bO - aO ) /                   /                 //\\n    // wI = tokenWeightIn           --------------------------------------------                 //\\n    // wO = tokenWeightOut                          ( 1 - sF )                                   //\\n    // sF = swapFee                                                                              //\\n    **********************************************************************************************/\\n    function calcInGivenOut(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint tokenAmountOut,\\n        uint swapFee\\n    )\\n        internal pure\\n        returns (uint tokenAmountIn)\\n    {\\n        uint weightRatio = bdiv(tokenWeightOut, tokenWeightIn);\\n        uint diff = bsub(tokenBalanceOut, tokenAmountOut);\\n        uint y = bdiv(tokenBalanceOut, diff);\\n        uint foo = bpow(y, weightRatio);\\n        foo = bsub(foo, BONE);\\n        tokenAmountIn = bsub(BONE, swapFee);\\n        tokenAmountIn = bdiv(bmul(tokenBalanceIn, foo), tokenAmountIn);\\n        return tokenAmountIn;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcPoolOutGivenSingleIn                                                                  //\\n    // pAo = poolAmountOut         /                                              \\\\              //\\n    // tAi = tokenAmountIn        ///      /     //    wI \\\\      \\\\\\\\       \\\\     wI \\\\             //\\n    // wI = tokenWeightIn        //| tAi *| 1 - || 1 - --  | * sF || + tBi \\\\    --  \\\\            //\\n    // tW = totalWeight     pAo=||  \\\\      \\\\     \\\\\\\\    tW /      //         | ^ tW   | * pS - pS //\\n    // tBi = tokenBalanceIn      \\\\\\\\  ------------------------------------- /        /            //\\n    // pS = poolSupply            \\\\\\\\                    tBi               /        /             //\\n    // sF = swapFee                \\\\                                              /              //\\n    **********************************************************************************************/\\n    function calcPoolOutGivenSingleIn(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint poolSupply,\\n        uint totalWeight,\\n        uint tokenAmountIn,\\n        uint swapFee\\n    )\\n        internal pure\\n        returns (uint poolAmountOut)\\n    {\\n        // Charge the trading fee for the proportion of tokenAi\\n        // which is implicitly traded to the other pool tokens.\\n        // That proportion is (1- weightTokenIn)\\n        // tokenAiAfterFee = tAi * (1 - (1-weightTi) * poolFee);\\n        uint normalizedWeight = bdiv(tokenWeightIn, totalWeight);\\n        uint zaz = bmul(bsub(BONE, normalizedWeight), swapFee); \\n        uint tokenAmountInAfterFee = bmul(tokenAmountIn, bsub(BONE, zaz));\\n\\n        uint newTokenBalanceIn = badd(tokenBalanceIn, tokenAmountInAfterFee);\\n        uint tokenInRatio = bdiv(newTokenBalanceIn, tokenBalanceIn);\\n\\n        // uint newPoolSupply = (ratioTi ^ weightTi) * poolSupply;\\n        uint poolRatio = bpow(tokenInRatio, normalizedWeight);\\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\\n        poolAmountOut = bsub(newPoolSupply, poolSupply);\\n        return poolAmountOut;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcSingleInGivenPoolOut                                                                  //\\n    // tAi = tokenAmountIn              //(pS + pAo)\\\\     /    1    \\\\\\\\                           //\\n    // pS = poolSupply                 || ---------  | ^ | --------- || * bI - bI                //\\n    // pAo = poolAmountOut              \\\\\\\\    pS    /     \\\\(wI / tW)//                           //\\n    // bI = balanceIn          tAi =  --------------------------------------------               //\\n    // wI = weightIn                              /      wI  \\\\                                   //\\n    // tW = totalWeight                          |  1 - ----  |  * sF                            //\\n    // sF = swapFee                               \\\\      tW  /                                   //\\n    **********************************************************************************************/\\n    function calcSingleInGivenPoolOut(\\n        uint tokenBalanceIn,\\n        uint tokenWeightIn,\\n        uint poolSupply,\\n        uint totalWeight,\\n        uint poolAmountOut,\\n        uint swapFee\\n    )\\n        internal pure\\n        returns (uint tokenAmountIn)\\n    {\\n        uint normalizedWeight = bdiv(tokenWeightIn, totalWeight);\\n        uint newPoolSupply = badd(poolSupply, poolAmountOut);\\n        uint poolRatio = bdiv(newPoolSupply, poolSupply);\\n      \\n        //uint newBalTi = poolRatio^(1/weightTi) * balTi;\\n        uint boo = bdiv(BONE, normalizedWeight); \\n        uint tokenInRatio = bpow(poolRatio, boo);\\n        uint newTokenBalanceIn = bmul(tokenInRatio, tokenBalanceIn);\\n        uint tokenAmountInAfterFee = bsub(newTokenBalanceIn, tokenBalanceIn);\\n        // Do reverse order of fees charged in joinswap_ExternAmountIn, this way \\n        //     ``` pAo == joinswap_ExternAmountIn(Ti, joinswap_PoolAmountOut(pAo, Ti)) ```\\n        //uint tAi = tAiAfterFee / (1 - (1-weightTi) * swapFee) ;\\n        uint zar = bmul(bsub(BONE, normalizedWeight), swapFee);\\n        tokenAmountIn = bdiv(tokenAmountInAfterFee, bsub(BONE, zar));\\n        return tokenAmountIn;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcSingleOutGivenPoolIn                                                                  //\\n    // tAo = tokenAmountOut            /      /                                             \\\\\\\\   //\\n    // bO = tokenBalanceOut           /      // pS - (pAi * (1 - eF)) \\\\     /    1    \\\\      \\\\\\\\  //\\n    // pAi = poolAmountIn            | bO - || ----------------------- | ^ | --------- | * b0 || //\\n    // ps = poolSupply                \\\\      \\\\\\\\          pS           /     \\\\(wO / tW)/      //  //\\n    // wI = tokenWeightIn      tAo =   \\\\      \\\\                                             //   //\\n    // tW = totalWeight                    /     /      wO \\\\       \\\\                             //\\n    // sF = swapFee                    *  | 1 - |  1 - ---- | * sF  |                            //\\n    // eF = exitFee                        \\\\     \\\\      tW /       /                             //\\n    **********************************************************************************************/\\n    function calcSingleOutGivenPoolIn(\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint poolSupply,\\n        uint totalWeight,\\n        uint poolAmountIn,\\n        uint swapFee,\\n        uint exitFee\\n    )\\n        internal pure\\n        returns (uint tokenAmountOut)\\n    {\\n        // unused function but add variable exit fee for consistency\\n        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\\n        // charge exit fee on the pool token side\\n        // pAiAfterExitFee = pAi*(1-exitFee)\\n        uint poolAmountInAfterExitFee = bmul(poolAmountIn, bsub(BONE, exitFee));\\n        uint newPoolSupply = bsub(poolSupply, poolAmountInAfterExitFee);\\n        uint poolRatio = bdiv(newPoolSupply, poolSupply);\\n     \\n        // newBalTo = poolRatio^(1/weightTo) * balTo;\\n        uint tokenOutRatio = bpow(poolRatio, bdiv(BONE, normalizedWeight));\\n        uint newTokenBalanceOut = bmul(tokenOutRatio, tokenBalanceOut);\\n\\n        uint tokenAmountOutBeforeSwapFee = bsub(tokenBalanceOut, newTokenBalanceOut);\\n\\n        // charge swap fee on the output token side \\n        //uint tAo = tAoBeforeSwapFee * (1 - (1-weightTo) * swapFee)\\n        uint zaz = bmul(bsub(BONE, normalizedWeight), swapFee); \\n        tokenAmountOut = bmul(tokenAmountOutBeforeSwapFee, bsub(BONE, zaz));\\n        return tokenAmountOut;\\n    }\\n\\n    /**********************************************************************************************\\n    // calcPoolInGivenSingleOut                                                                  //\\n    // pAi = poolAmountIn               // /               tAo             \\\\\\\\     / wO \\\\     \\\\   //\\n    // bO = tokenBalanceOut            // | bO - -------------------------- |\\\\   | ---- |     \\\\  //\\n    // tAo = tokenAmountOut      pS - ||   \\\\     1 - ((1 - (tO / tW)) * sF)/  | ^ \\\\ tW /  * pS | //\\n    // ps = poolSupply                 \\\\\\\\ -----------------------------------/                /  //\\n    // wO = tokenWeightOut  pAi =       \\\\\\\\               bO                 /                /   //\\n    // tW = totalWeight           -------------------------------------------------------------  //\\n    // sF = swapFee                                        ( 1 - eF )                            //\\n    // eF = exitFee                                                                              //\\n    **********************************************************************************************/\\n    function calcPoolInGivenSingleOut(\\n        uint tokenBalanceOut,\\n        uint tokenWeightOut,\\n        uint poolSupply,\\n        uint totalWeight,\\n        uint tokenAmountOut,\\n        uint swapFee,\\n        uint exitFee\\n    )\\n        internal pure\\n        returns (uint poolAmountIn)\\n    {\\n        // unused function but add variable exit fee for consistency\\n        // charge swap fee on the output token side \\n        uint normalizedWeight = bdiv(tokenWeightOut, totalWeight);\\n        //uint tAoBeforeSwapFee = tAo / (1 - (1-weightTo) * swapFee) ;\\n        uint zoo = bsub(BONE, normalizedWeight);\\n        uint zar = bmul(zoo, swapFee); \\n        uint tokenAmountOutBeforeSwapFee = bdiv(tokenAmountOut, bsub(BONE, zar));\\n\\n        uint newTokenBalanceOut = bsub(tokenBalanceOut, tokenAmountOutBeforeSwapFee);\\n        uint tokenOutRatio = bdiv(newTokenBalanceOut, tokenBalanceOut);\\n\\n        //uint newPoolSupply = (ratioTo ^ weightTo) * poolSupply;\\n        uint poolRatio = bpow(tokenOutRatio, normalizedWeight);\\n        uint newPoolSupply = bmul(poolRatio, poolSupply);\\n        uint poolAmountInAfterExitFee = bsub(poolSupply, newPoolSupply);\\n\\n        // charge exit fee on the pool token side\\n        // pAi = pAiAfterExitFee/(1-exitFee)\\n        poolAmountIn = bdiv(poolAmountInAfterExitFee, bsub(BONE, exitFee));\\n        return poolAmountIn;\\n    }\\n\\n    // Computes the expected denorm for current timestamp\\n    function calcDenorm(\\n        uint256 lastUpdateTime,\\n        uint256 currTime,\\n        uint256 targetTime,\\n        uint256 denorm,\\n        uint256 targetDenorm\\n    )\\n        internal pure\\n        returns (uint256)\\n    {\\n        if (targetTime <= currTime) {\\n            return targetDenorm;\\n        }\\n\\n        uint256 timeDelta = bsub(currTime, lastUpdateTime);\\n        uint256 timeLeft = bsub(targetTime, lastUpdateTime);\\n        if (denorm > targetDenorm) {\\n            uint256 denormDelta = bsub(denorm, targetDenorm);\\n            uint256 diff = bdiv(bmul(denormDelta, timeDelta), timeLeft);\\n            return bmax(bsub(denorm, diff), targetDenorm);\\n        } else {\\n            uint256 denormDelta = bsub(targetDenorm, denorm);\\n            uint256 diff = bdiv(bmul(denormDelta, timeDelta), timeLeft);\\n            return bmin(badd(denorm, diff), targetDenorm);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// solhint-disable-next-line compiler-version\\npragma solidity >=0.4.24 <0.8.0;\\n\\nimport \\\"../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || _isConstructor() || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /// @dev Returns true if and only if the function is running in the constructor\\n    function _isConstructor() private view returns (bool) {\\n        return !AddressUpgradeable.isContract(address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/SafeERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC20Upgradeable.sol\\\";\\nimport \\\"../../math/SafeMathUpgradeable.sol\\\";\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20Upgradeable {\\n    using SafeMathUpgradeable for uint256;\\n    using AddressUpgradeable for address;\\n\\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/6/protocol/interfaces/IUnbinder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@bundle-dao/pancakeswap-peripheral/contracts/interfaces/IPancakeRouter02.sol\\\";\\nimport \\\"./IBundle.sol\\\";\\n\\ninterface IUnbinder {\\n    struct SwapToken {\\n        bool flag;\\n        uint256 index;\\n    }\\n\\n    event TokenUnbound(address token);\\n\\n    event LogSwapWhitelist(\\n        address indexed caller,\\n        address         token,\\n        bool            flag\\n    );\\n\\n    event LogPremium(\\n        address indexed caller,\\n        uint256         premium\\n    );\\n\\n    function initialize(address bundle, address router, address controller, address[] calldata whitelist) external;\\n\\n    function handleUnboundToken(address token) external;\\n\\n    function distributeUnboundToken(address token, uint256 amount, uint256 deadline, address[][] calldata paths) external;\\n\\n    function setPremium(uint256 premium) external;\\n\\n    function setSwapWhitelist(address token, bool flag) external;\\n\\n    function getPremium() external view returns (uint256);\\n\\n    function getController() external view returns (address);\\n\\n    function getBundle() external view returns (address);\\n\\n    function isSwapWhitelisted(address token) external view returns (bool);\\n\\n    function getSwapWhitelist() external view returns (address[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/6/protocol/interfaces/IBundle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\nimport \\\"./IUnbinder.sol\\\";\\n\\ninterface IBundle {\\n    struct Record {\\n        bool bound;               // is token bound to pool\\n        bool ready;               // is token ready for swaps\\n        uint256 denorm;           // denormalized weight\\n        uint256 targetDenorm;     // target denormalized weight\\n        uint256 targetTime;      // target block to update by\\n        uint256 lastUpdateTime;  // last update block\\n        uint8 index;              // token index\\n        uint256 balance;          // token balance\\n    }\\n\\n    /* ========== Events ========== */\\n\\n    event LogSwap(\\n        address indexed caller,\\n        address indexed tokenIn,\\n        address indexed tokenOut,\\n        uint256         tokenAmountIn,\\n        uint256         tokenAmountOut\\n    );\\n\\n    event LogJoin(\\n        address indexed caller,\\n        address indexed tokenIn,\\n        uint256         tokenAmountIn\\n    );\\n\\n    event LogExit(\\n        address indexed caller,\\n        address indexed tokenOut,\\n        uint256         tokenAmountOut\\n    );\\n\\n    event LogSwapFeeUpdated(\\n        address indexed caller,\\n        uint256         swapFee\\n    );\\n\\n    event LogTokenReady(\\n        address indexed token\\n    );\\n\\n    event LogPublicSwapEnabled();\\n\\n    event LogRebalancable(\\n        address indexed caller,\\n        bool            rebalancable\\n    );\\n\\n    event LogCollectFee(\\n        address indexed caller\\n    );\\n\\n    event LogStreamingFee(\\n        address indexed caller,\\n        uint256         fee\\n    );\\n\\n    event LogTokenBound(\\n        address indexed token\\n    );\\n\\n    event LogTokenUnbound(\\n        address indexed token\\n    );\\n\\n    event LogMinBalance(\\n        address indexed caller,\\n        address indexed token,\\n        uint256         minBalance\\n    );\\n\\n    event LogTargetDelta(\\n        address indexed caller,\\n        uint256         targetDelta\\n    );\\n\\n    event LogExitFee(\\n        address indexed caller,\\n        uint256         exitFee\\n    );\\n\\n    event LogReindex(\\n        address indexed caller,\\n        address[]       tokens,\\n        uint256[]       targetDenorms,\\n        uint256[]       minBalances\\n    );\\n\\n    event LogReweigh(\\n        address indexed caller,\\n        address[]       tokens,\\n        uint256[]       targetDenorms\\n    );\\n\\n    /* ========== Initialization ========== */\\n\\n    function initialize(\\n        address controller, \\n        address rebalancer,\\n        address unbinder,\\n        string calldata name, \\n        string calldata symbol\\n    ) external;\\n\\n    function setup(\\n        address[] calldata tokens,\\n        uint256[] calldata balances,\\n        uint256[] calldata denorms,\\n        address tokenProvider\\n    ) external;\\n\\n    function setSwapFee(uint256 swapFee) external;\\n\\n    function setRebalancable(bool rebalancable) external;\\n\\n    function setMinBalance(address token, uint256 minBalance) external;\\n\\n    function setStreamingFee(uint256 streamingFee) external;\\n\\n    function setExitFee(uint256 exitFee) external;\\n\\n    function setTargetDelta(uint256 targetDelta) external;\\n\\n    function collectStreamingFee() external;\\n\\n    function isPublicSwap() external view returns (bool);\\n\\n    function isBound(address t) external view returns (bool);\\n\\n    function isReady(address t) external view returns (bool);\\n\\n    function getNumTokens() external view returns (uint256) ;\\n\\n    function getCurrentTokens() external view returns (address[] memory tokens);\\n\\n    function getDenormalizedWeight(address token) external view returns (uint256);\\n\\n    function getTotalDenormalizedWeight() external view returns (uint256);\\n\\n    function getBalance(address token) external view returns (uint256);\\n\\n    function getSwapFee() external view returns (uint256);\\n\\n    function getStreamingFee() external view returns (uint256);\\n\\n    function getExitFee() external view returns (uint256);\\n\\n    function getController() external view returns (address);\\n\\n    function getRebalancer() external view returns (address);\\n\\n    function getRebalancable() external view returns (bool);\\n\\n    function getUnbinder() external view returns (address);\\n\\n    function getSpotPrice(\\n        address tokenIn, \\n        address tokenOut\\n    ) external view returns (uint256 spotPrice);\\n\\n    function getSpotPriceSansFee(\\n        address tokenIn, \\n        address tokenOut\\n    ) external view returns (uint256 spotPrice);\\n\\n    /* ==========  External Token Weighting  ========== */\\n\\n    /**\\n     * @dev Adjust weights for existing tokens\\n     * @param tokens A set of token addresses to adjust\\n     * @param targetDenorms A set of denorms to linearly update to\\n     */\\n\\n    function reweighTokens(\\n        address[] calldata tokens,\\n        uint256[] calldata targetDenorms\\n    ) external;\\n\\n    /**\\n     * @dev Reindex the pool on a new set of tokens\\n     *\\n     * @param tokens A set of token addresses to be indexed\\n     * @param targetDenorms A set of denorms to linearly update to\\n     * @param minBalances Minimum balance thresholds for unbound assets\\n     */\\n    function reindexTokens(\\n        address[] calldata tokens,\\n        uint256[] calldata targetDenorms,\\n        uint256[] calldata minBalances\\n    ) external;\\n\\n    function gulp(address token) external;\\n\\n    function joinPool(uint256 poolAmountOut, uint[] calldata maxAmountsIn) external;\\n\\n    function exitPool(uint256 poolAmountIn, uint[] calldata minAmountsOut) external;\\n\\n    function swapExactAmountIn(\\n        address tokenIn,\\n        uint256 tokenAmountIn,\\n        address tokenOut,\\n        uint256 minAmountOut,\\n        uint256 maxPrice\\n    ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter);\\n\\n    function swapExactAmountOut(\\n        address tokenIn,\\n        uint256 maxAmountIn,\\n        address tokenOut,\\n        uint256 tokenAmountOut,\\n        uint256 maxPrice\\n    ) external returns (uint256 tokenAmountIn, uint256 spotPriceAfter);\\n}\\n\"\r\n    },\r\n    \"contracts/6/protocol/core/BNum.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.6.12;\\n\\nimport \\\"./BConst.sol\\\";\\n\\n/************************************************************************************************\\nOriginally forked from https://github.com/balancer-labs/balancer-core/\\n\\nThis source code has been modified from the original, which was copied from the github repository\\nat commit hash f4ed5d65362a8d6cec21662fb6eae233b0babc1f.\\n\\nSubject to the GPL-3.0 license\\n*************************************************************************************************/\\n\\ncontract BNum is BConst {\\n\\n    function btoi(uint a)\\n        internal pure \\n        returns (uint)\\n    {\\n        return a / BONE;\\n    }\\n\\n    function bfloor(uint a)\\n        internal pure\\n        returns (uint)\\n    {\\n        return btoi(a) * BONE;\\n    }\\n\\n    function badd(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        uint c = a + b;\\n        require(c >= a, \\\"ERR_ADD_OVERFLOW\\\");\\n        return c;\\n    }\\n\\n    function bsub(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        (uint c, bool flag) = bsubSign(a, b);\\n        require(!flag, \\\"ERR_SUB_UNDERFLOW\\\");\\n        return c;\\n    }\\n\\n    function bsubSign(uint a, uint b)\\n        internal pure\\n        returns (uint, bool)\\n    {\\n        if (a >= b) {\\n            return (a - b, false);\\n        } else {\\n            return (b - a, true);\\n        }\\n    }\\n\\n    function bmul(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        uint c0 = a * b;\\n        require(a == 0 || c0 / a == b, \\\"ERR_MUL_OVERFLOW\\\");\\n        uint c1 = c0 + (BONE / 2);\\n        require(c1 >= c0, \\\"ERR_MUL_OVERFLOW\\\");\\n        uint c2 = c1 / BONE;\\n        return c2;\\n    }\\n\\n    function bdiv(uint a, uint b)\\n        internal pure\\n        returns (uint)\\n    {\\n        require(b != 0, \\\"ERR_DIV_ZERO\\\");\\n        uint c0 = a * BONE;\\n        require(a == 0 || c0 / a == BONE, \\\"ERR_DIV_INTERNAL\\\"); // bmul overflow\\n        uint c1 = c0 + (b / 2);\\n        require(c1 >= c0, \\\"ERR_DIV_INTERNAL\\\"); //  badd require\\n        uint c2 = c1 / b;\\n        return c2;\\n    }\\n\\n    // DSMath.wpow\\n    function bpowi(uint a, uint n)\\n        internal pure\\n        returns (uint)\\n    {\\n        uint z = n % 2 != 0 ? a : BONE;\\n\\n        for (n /= 2; n != 0; n /= 2) {\\n            a = bmul(a, a);\\n\\n            if (n % 2 != 0) {\\n                z = bmul(z, a);\\n            }\\n        }\\n        return z;\\n    }\\n\\n    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\\n    // Use `bpowi` for `b^e` and `bpowK` for k iterations\\n    // of approximation of b^0.w\\n    function bpow(uint base, uint exp)\\n        internal pure\\n        returns (uint)\\n    {\\n        require(base >= MIN_BPOW_BASE, \\\"ERR_BPOW_BASE_TOO_LOW\\\");\\n        require(base <= MAX_BPOW_BASE, \\\"ERR_BPOW_BASE_TOO_HIGH\\\");\\n\\n        uint whole  = bfloor(exp);   \\n        uint remain = bsub(exp, whole);\\n\\n        uint wholePow = bpowi(base, btoi(whole));\\n\\n        if (remain == 0) {\\n            return wholePow;\\n        }\\n\\n        uint partialResult = bpowApprox(base, remain, BPOW_PRECISION);\\n        return bmul(wholePow, partialResult);\\n    }\\n\\n    function bpowApprox(uint base, uint exp, uint precision)\\n        internal pure\\n        returns (uint)\\n    {\\n        // term 0:\\n        uint a     = exp;\\n        (uint x, bool xneg)  = bsubSign(base, BONE);\\n        uint term = BONE;\\n        uint sum   = term;\\n        bool negative = false;\\n\\n\\n        // term(k) = numer / denom \\n        //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\\n        // each iteration, multiply previous term by (a-(k-1)) * x / k\\n        // continue until term is less than precision\\n        for (uint i = 1; term >= precision; i++) {\\n            uint bigK = i * BONE;\\n            (uint c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\\n            term = bmul(term, bmul(c, x));\\n            term = bdiv(term, bigK);\\n            if (term == 0) break;\\n\\n            if (xneg) negative = !negative;\\n            if (cneg) negative = !negative;\\n            if (negative) {\\n                sum = bsub(sum, term);\\n            } else {\\n                sum = badd(sum, term);\\n            }\\n        }\\n\\n        return sum;\\n    }\\n\\n    function bmin(uint256 a, uint256 b)\\n        internal pure\\n        returns (uint256)\\n    {\\n        return a < b ? a : b;\\n    }\\n\\n    function bmax(uint256 a, uint256 b) \\n        internal pure \\n        returns (uint256)\\n    {\\n        return a >= b ? a : b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/6/protocol/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\ninterface IERC20 {\\n    event Approval(address indexed src, address indexed dst, uint amt);\\n    event Transfer(address indexed src, address indexed dst, uint amt);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address whom) external view returns (uint);\\n    function allowance(address src, address dst) external view returns (uint);\\n\\n    function approve(address dst, uint amt) external returns (bool);\\n    function transfer(address dst, uint amt) external returns (bool);\\n    function transferFrom(\\n        address src, address dst, uint amt\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/6/protocol/core/BConst.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.6.12;\\n\\n/************************************************************************************************\\nOriginally forked from https://github.com/balancer-labs/balancer-core/\\n\\nThis source code has been modified from the original, which was copied from the github repository\\nat commit hash f4ed5d65362a8d6cec21662fb6eae233b0babc1f.\\n\\nSubject to the GPL-3.0 license\\n*************************************************************************************************/\\n\\ncontract BConst {\\n    uint256 internal constant BONE               = 10**18;\\n\\n    uint256 internal constant MIN_BOUND_TOKENS   = 2;\\n    uint256 internal constant MAX_BOUND_TOKENS   = 15;\\n\\n    uint256 internal constant MIN_FEE            = BONE / 10**6;\\n    uint256 internal constant INIT_FEE           = (2 * BONE) / 10**2;\\n    uint256 internal constant MAX_FEE            = BONE / 10;\\n    \\n    uint256 internal constant INIT_EXIT_FEE      = (2 * BONE) / 10**2;\\n    uint256 internal constant MAX_EXIT_FEE       = (5 * BONE) / 10**2;\\n\\n    uint256 internal constant MAX_STREAMING_FEE  = (4 * BONE) / 10**2;\\n    uint256 internal constant INIT_STREAMING_FEE = (2 * BONE) / 10**2;\\n    uint256 internal constant BPY                = 365 days;\\n\\n    uint256 internal constant MIN_WEIGHT         = BONE / 2;\\n    uint256 internal constant MAX_WEIGHT         = BONE * 50;\\n    uint256 internal constant MAX_TOTAL_WEIGHT   = BONE * 51;\\n    uint256 internal constant MIN_BALANCE        = BONE / 10**12;\\n\\n    uint256 internal constant INIT_POOL_SUPPLY   = BONE * 100;\\n\\n    uint256 internal constant MIN_BPOW_BASE      = 1 wei;\\n    uint256 internal constant MAX_BPOW_BASE      = (2 * BONE) - 1 wei;\\n    uint256 internal constant BPOW_PRECISION     = BONE / 10**10;\\n\\n    uint256 internal constant MAX_TARGET_DELTA   = 14 days;\\n    uint256 internal constant INIT_TARGET_DELTA  = 7 days;\\n    uint256 internal constant MIN_TARGET_DELTA   = 1 days;\\n\\n    uint256 internal constant MAX_IN_RATIO       = BONE / 2;\\n    uint256 internal constant MAX_OUT_RATIO      = (BONE / 3) + 1 wei;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMathUpgradeable {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@bundle-dao/pancakeswap-peripheral/contracts/interfaces/IPancakeRouter02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\nimport './IPancakeRouter01.sol';\\n\\ninterface IPancakeRouter02 is IPancakeRouter01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@bundle-dao/pancakeswap-peripheral/contracts/interfaces/IPancakeRouter01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IPancakeRouter01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"LogCollectFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"name\":\"LogExit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"exitFee\",\"type\":\"uint256\"}],\"name\":\"LogExitFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"}],\"name\":\"LogJoin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minBalance\",\"type\":\"uint256\"}],\"name\":\"LogMinBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogPublicSwapEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"rebalancable\",\"type\":\"bool\"}],\"name\":\"LogRebalancable\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"targetDenorms\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"minBalances\",\"type\":\"uint256[]\"}],\"name\":\"LogReindex\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"targetDenorms\",\"type\":\"uint256[]\"}],\"name\":\"LogReweigh\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"LogStreamingFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"name\":\"LogSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"LogSwapFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"targetDelta\",\"type\":\"uint256\"}],\"name\":\"LogTargetDelta\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"LogTokenBound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"LogTokenReady\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"LogTokenUnbound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"whom\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectStreamingFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"minAmountsOut\",\"type\":\"uint256[]\"}],\"name\":\"exitPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getDenormalizedWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getExitFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRebalancable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRebalancer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"getSpotPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"spotPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"getSpotPriceSansFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"spotPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStreamingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSwapFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalDenormalizedWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getUnbinder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"gulp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rebalancer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"unbinder\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"isBound\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPublicSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"isReady\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"maxAmountsIn\",\"type\":\"uint256[]\"}],\"name\":\"joinPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"targetDenorms\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"minBalances\",\"type\":\"uint256[]\"}],\"name\":\"reindexTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"targetDenorms\",\"type\":\"uint256[]\"}],\"name\":\"reweighTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"exitFee\",\"type\":\"uint256\"}],\"name\":\"setExitFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minBalance\",\"type\":\"uint256\"}],\"name\":\"setMinBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"rebalancable\",\"type\":\"bool\"}],\"name\":\"setRebalancable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"streamingFee\",\"type\":\"uint256\"}],\"name\":\"setStreamingFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"setSwapFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"targetDelta\",\"type\":\"uint256\"}],\"name\":\"setTargetDelta\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"denorms\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"tokenProvider\",\"type\":\"address\"}],\"name\":\"setup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"name\":\"swapExactAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spotPriceAfter\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"name\":\"swapExactAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spotPriceAfter\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Bundle", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "1", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}