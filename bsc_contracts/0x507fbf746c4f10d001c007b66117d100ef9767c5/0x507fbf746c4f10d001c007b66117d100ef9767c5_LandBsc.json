{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/LandBsc.sol\": {\r\n      \"content\": \"/* solhint-disable no-empty-blocks */\\r\\n\\r\\npragma solidity 0.5.9;\\r\\n\\r\\nimport \\\"./Land/erc721/LandBaseToken.sol\\\";\\r\\n\\r\\ncontract LandBsc is LandBaseToken {\\r\\n    constructor(address metaTransactionContract, address admin) public LandBaseToken(metaTransactionContract, admin) {}\\r\\n\\r\\n    /**\\r\\n     * @notice Return the name of the token contract\\r\\n     * @return The name of the token contract\\r\\n     */\\r\\n    function name() external pure returns (string memory) {\\r\\n        return \\\"Ariva Wonderland\\\";\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Return the symbol of the token contract\\r\\n     * @return The symbol of the token contract\\r\\n     */\\r\\n    function symbol() external pure returns (string memory) {\\r\\n        return \\\"ARWL\\\";\\r\\n    }\\r\\n\\r\\n    // solium-disable-next-line security/no-assign-params\\r\\n    function uint2str(uint256 _i) internal pure returns (string memory) {\\r\\n        if (_i == 0) {\\r\\n            return \\\"0\\\";\\r\\n        }\\r\\n        uint256 j = _i;\\r\\n        uint256 len;\\r\\n        while (j != 0) {\\r\\n            len++;\\r\\n            j /= 10;\\r\\n        }\\r\\n        bytes memory bstr = new bytes(len);\\r\\n        uint256 k = len - 1;\\r\\n        while (_i != 0) {\\r\\n            bstr[k--] = bytes1(uint8(48 + (_i % 10)));\\r\\n            _i /= 10;\\r\\n        }\\r\\n        return string(bstr);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Return the URI of a specific token\\r\\n     * @param id The id of the token\\r\\n     * @return The URI of the token\\r\\n     */\\r\\n    function tokenURI(uint256 id) public view returns (string memory) {\\r\\n        require(_ownerOf(id) != address(0), \\\"Id does not exist\\\");\\r\\n\\r\\n        return\\r\\n            string(\\r\\n                abi.encodePacked(\\r\\n                    \\\"https://api.ariva.game/lands/bsc/\\\",\\r\\n                    uint2str(id),\\r\\n                    \\\"/metadata.json\\\"\\r\\n                )\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Check if the contract supports an interface\\r\\n     * 0x01ffc9a7 is ERC-165\\r\\n     * 0x80ac58cd is ERC-721\\r\\n     * 0x5b5e139f is ERC-721 metadata\\r\\n     * @param id The id of the interface\\r\\n     * @return True if the interface is supported\\r\\n     */\\r\\n    function supportsInterface(bytes4 id) external pure returns (bool) {\\r\\n        return id == 0x01ffc9a7 || id == 0x80ac58cd || id == 0x5b5e139f;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Land/erc721/LandBaseToken.sol\": {\r\n      \"content\": \"/* solhint-disable func-order, code-complexity */\\r\\npragma solidity 0.5.9;\\r\\n\\r\\nimport \\\"./ERC721BaseToken.sol\\\";\\r\\n\\r\\ncontract LandBaseToken is ERC721BaseToken {\\r\\n    // Our grid is 1562 x 1562 lands\\r\\n    uint256 internal constant GRID_SIZE = 1562;\\r\\n\\r\\n    uint256 internal constant LAYER = 0xFF00000000000000000000000000000000000000000000000000000000000000;\\r\\n    uint256 internal constant LAYER_1x1 = 0x0000000000000000000000000000000000000000000000000000000000000000;\\r\\n    uint256 internal constant LAYER_3x3 = 0x0100000000000000000000000000000000000000000000000000000000000000;\\r\\n    uint256 internal constant LAYER_6x6 = 0x0200000000000000000000000000000000000000000000000000000000000000;\\r\\n    uint256 internal constant LAYER_12x12 = 0x0300000000000000000000000000000000000000000000000000000000000000;\\r\\n    uint256 internal constant LAYER_24x24 = 0x0400000000000000000000000000000000000000000000000000000000000000;\\r\\n\\r\\n    mapping(address => bool) internal _minters;\\r\\n    event Minter(address superOperator, bool enabled);\\r\\n\\r\\n    /// @notice Enable or disable the ability of `minter` to mint tokens\\r\\n    /// @param minter address that will be given/removed minter right.\\r\\n    /// @param enabled set whether the minter is enabled or disabled.\\r\\n    function setMinter(address minter, bool enabled) external {\\r\\n        require(msg.sender == _admin, \\\"only admin is allowed to add minters\\\");\\r\\n        _minters[minter] = enabled;\\r\\n        emit Minter(minter, enabled);\\r\\n    }\\r\\n\\r\\n    /// @notice check whether address `who` is given minter rights.\\r\\n    /// @param who The address to query.\\r\\n    /// @return whether the address has minter rights.\\r\\n    function isMinter(address who) public view returns (bool) {\\r\\n        return _minters[who];\\r\\n    }\\r\\n\\r\\n    constructor(address metaTransactionContract, address admin)\\r\\n        public\\r\\n        ERC721BaseToken(metaTransactionContract, admin)\\r\\n    {}\\r\\n\\r\\n    /// @notice total width of the map\\r\\n    /// @return width\\r\\n    function width() external returns (uint256) {\\r\\n        return GRID_SIZE;\\r\\n    }\\r\\n\\r\\n    /// @notice total height of the map\\r\\n    /// @return height\\r\\n    function height() external returns (uint256) {\\r\\n        return GRID_SIZE;\\r\\n    }\\r\\n\\r\\n    /// @notice x coordinate of Land token\\r\\n    /// @param id tokenId\\r\\n    /// @return the x coordinates\\r\\n    function x(uint256 id) external returns (uint256) {\\r\\n        require(_ownerOf(id) != address(0), \\\"token does not exist\\\");\\r\\n        return id % GRID_SIZE;\\r\\n    }\\r\\n\\r\\n    /// @notice y coordinate of Land token\\r\\n    /// @param id tokenId\\r\\n    /// @return the y coordinates\\r\\n    function y(uint256 id) external returns (uint256) {\\r\\n        require(_ownerOf(id) != address(0), \\\"token does not exist\\\");\\r\\n        return id / GRID_SIZE;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Mint a new quad (aligned to a quad tree with size 3, 6, 12 or 24 only)\\r\\n     * @param to The recipient of the new quad\\r\\n     * @param size The size of the new quad\\r\\n     * @param x The top left x coordinate of the new quad\\r\\n     * @param y The top left y coordinate of the new quad\\r\\n     * @param data extra data to pass to the transfer\\r\\n     */\\r\\n    function mintQuad(\\r\\n        address to,\\r\\n        uint256 size,\\r\\n        uint256 x,\\r\\n        uint256 y,\\r\\n        bytes calldata data\\r\\n    ) external {\\r\\n        require(to != address(0), \\\"to is zero address\\\");\\r\\n        require(isMinter(msg.sender), \\\"Only a minter can mint\\\");\\r\\n        require(x <= GRID_SIZE - size && y <= GRID_SIZE - size, \\\"Out of bounds\\\");\\r\\n\\r\\n        uint256 quadId;\\r\\n        uint256 id = x + y * GRID_SIZE;\\r\\n\\r\\n        if (size == 1) {\\r\\n            quadId = id;\\r\\n        } else if (size == 3) {\\r\\n            quadId = LAYER_3x3 + id;\\r\\n        } else if (size == 6) {\\r\\n            quadId = LAYER_6x6 + id;\\r\\n        } else if (size == 12) {\\r\\n            quadId = LAYER_12x12 + id;\\r\\n        } else if (size == 24) {\\r\\n            quadId = LAYER_24x24 + id;\\r\\n        } else {\\r\\n            require(false, \\\"Invalid size\\\");\\r\\n        }\\r\\n\\r\\n        require(_owners[LAYER_24x24 + (x / 24) * 24 + ((y / 24) * 24) * GRID_SIZE] == 0, \\\"Already minted as 24x24\\\");\\r\\n\\r\\n        uint256 toX = x + size;\\r\\n        uint256 toY = y + size;\\r\\n        if (size <= 12) {\\r\\n            require(_owners[LAYER_12x12 + (x / 12) * 12 + ((y / 12) * 12) * GRID_SIZE] == 0, \\\"Already minted as 12x12\\\");\\r\\n        } else {\\r\\n            for (uint256 x12i = x; x12i < toX; x12i += 12) {\\r\\n                for (uint256 y12i = y; y12i < toY; y12i += 12) {\\r\\n                    uint256 id12x12 = LAYER_12x12 + x12i + y12i * GRID_SIZE;\\r\\n                    require(_owners[id12x12] == 0, \\\"Already minted as 12x12\\\");\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (size <= 6) {\\r\\n            require(_owners[LAYER_6x6 + (x / 6) * 6 + ((y / 6) * 6) * GRID_SIZE] == 0, \\\"Already minted as 6x6\\\");\\r\\n        } else {\\r\\n            for (uint256 x6i = x; x6i < toX; x6i += 6) {\\r\\n                for (uint256 y6i = y; y6i < toY; y6i += 6) {\\r\\n                    uint256 id6x6 = LAYER_6x6 + x6i + y6i * GRID_SIZE;\\r\\n                    require(_owners[id6x6] == 0, \\\"Already minted as 6x6\\\");\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (size <= 3) {\\r\\n            require(_owners[LAYER_3x3 + (x / 3) * 3 + ((y / 3) * 3) * GRID_SIZE] == 0, \\\"Already minted as 3x3\\\");\\r\\n        } else {\\r\\n            for (uint256 x3i = x; x3i < toX; x3i += 3) {\\r\\n                for (uint256 y3i = y; y3i < toY; y3i += 3) {\\r\\n                    uint256 id3x3 = LAYER_3x3 + x3i + y3i * GRID_SIZE;\\r\\n                    require(_owners[id3x3] == 0, \\\"Already minted as 3x3\\\");\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        for (uint256 i = 0; i < size * size; i++) {\\r\\n            uint256 id = _idInPath(i, size, x, y);\\r\\n            require(_owners[id] == 0, \\\"Already minted\\\");\\r\\n            emit Transfer(address(0), to, id);\\r\\n        }\\r\\n\\r\\n        _owners[quadId] = uint256(to);\\r\\n        _numNFTPerAddress[to] += size * size;\\r\\n\\r\\n        _checkBatchReceiverAcceptQuad(msg.sender, address(0), to, size, x, y, data);\\r\\n    }\\r\\n\\r\\n    function _idInPath(\\r\\n        uint256 i,\\r\\n        uint256 size,\\r\\n        uint256 x,\\r\\n        uint256 y\\r\\n    ) internal pure returns (uint256) {\\r\\n        uint256 row = i / size;\\r\\n        if (row % 2 == 0) {\\r\\n            // alow ids to follow a path in a quad\\r\\n            return (x + (i % size)) + ((y + row) * GRID_SIZE);\\r\\n        } else {\\r\\n            return ((x + size) - (1 + (i % size))) + ((y + row) * GRID_SIZE);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice transfer one quad (aligned to a quad tree with size 3, 6, 12 or 24 only)\\r\\n    /// @param from current owner of the quad\\r\\n    /// @param to destination\\r\\n    /// @param size size of the quad\\r\\n    /// @param x The top left x coordinate of the quad\\r\\n    /// @param y The top left y coordinate of the quad\\r\\n    /// @param data additional data\\r\\n    function transferQuad(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 size,\\r\\n        uint256 x,\\r\\n        uint256 y,\\r\\n        bytes calldata data\\r\\n    ) external {\\r\\n        require(from != address(0), \\\"from is zero address\\\");\\r\\n        require(to != address(0), \\\"can't send to zero address\\\");\\r\\n        bool metaTx = msg.sender != from && _metaTransactionContracts[msg.sender];\\r\\n        if (msg.sender != from && !metaTx) {\\r\\n            require(\\r\\n                _superOperators[msg.sender] || _operatorsForAll[from][msg.sender],\\r\\n                \\\"not authorized to transferQuad\\\"\\r\\n            );\\r\\n        }\\r\\n        _transferQuad(from, to, size, x, y);\\r\\n        _numNFTPerAddress[from] -= size * size;\\r\\n        _numNFTPerAddress[to] += size * size;\\r\\n\\r\\n        _checkBatchReceiverAcceptQuad(metaTx ? from : msg.sender, from, to, size, x, y, data);\\r\\n    }\\r\\n\\r\\n    function _checkBatchReceiverAcceptQuad(\\r\\n        address operator,\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 size,\\r\\n        uint256 x,\\r\\n        uint256 y,\\r\\n        bytes memory data\\r\\n    ) internal {\\r\\n        if (to.isContract() && _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\\r\\n            uint256[] memory ids = new uint256[](size * size);\\r\\n            for (uint256 i = 0; i < size * size; i++) {\\r\\n                ids[i] = _idInPath(i, size, x, y);\\r\\n            }\\r\\n            require(_checkOnERC721BatchReceived(operator, from, to, ids, data), \\\"erc721 batch transfer rejected by to\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice transfer multiple quad (aligned to a quad tree with size 3, 6, 12 or 24 only)\\r\\n    /// @param from current owner of the quad\\r\\n    /// @param to destination\\r\\n    /// @param sizes list of sizes for each quad\\r\\n    /// @param xs list of top left x coordinates for each quad\\r\\n    /// @param ys list of top left y coordinates for each quad\\r\\n    /// @param data additional data\\r\\n    function batchTransferQuad(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256[] calldata sizes,\\r\\n        uint256[] calldata xs,\\r\\n        uint256[] calldata ys,\\r\\n        bytes calldata data\\r\\n    ) external {\\r\\n        require(from != address(0), \\\"from is zero address\\\");\\r\\n        require(to != address(0), \\\"can't send to zero address\\\");\\r\\n        require(sizes.length == xs.length && xs.length == ys.length, \\\"invalid data\\\");\\r\\n        bool metaTx = msg.sender != from && _metaTransactionContracts[msg.sender];\\r\\n        if (msg.sender != from && !metaTx) {\\r\\n            require(\\r\\n                _superOperators[msg.sender] || _operatorsForAll[from][msg.sender],\\r\\n                \\\"not authorized to transferMultiQuads\\\"\\r\\n            );\\r\\n        }\\r\\n        uint256 numTokensTransfered = 0;\\r\\n        for (uint256 i = 0; i < sizes.length; i++) {\\r\\n            uint256 size = sizes[i];\\r\\n            _transferQuad(from, to, size, xs[i], ys[i]);\\r\\n            numTokensTransfered += size * size;\\r\\n        }\\r\\n        _numNFTPerAddress[from] -= numTokensTransfered;\\r\\n        _numNFTPerAddress[to] += numTokensTransfered;\\r\\n\\r\\n        if (to.isContract() && _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\\r\\n            uint256[] memory ids = new uint256[](numTokensTransfered);\\r\\n            uint256 counter = 0;\\r\\n            for (uint256 j = 0; j < sizes.length; j++) {\\r\\n                uint256 size = sizes[j];\\r\\n                for (uint256 i = 0; i < size * size; i++) {\\r\\n                    ids[counter] = _idInPath(i, size, xs[j], ys[j]);\\r\\n                    counter++;\\r\\n                }\\r\\n            }\\r\\n            require(\\r\\n                _checkOnERC721BatchReceived(metaTx ? from : msg.sender, from, to, ids, data),\\r\\n                \\\"erc721 batch transfer rejected by to\\\"\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _transferQuad(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 size,\\r\\n        uint256 x,\\r\\n        uint256 y\\r\\n    ) internal {\\r\\n        if (size == 1) {\\r\\n            uint256 id1x1 = x + y * GRID_SIZE;\\r\\n            address owner = _ownerOf(id1x1);\\r\\n            require(owner != address(0), \\\"token does not exist\\\");\\r\\n            require(owner == from, \\\"not owner in _transferQuad\\\");\\r\\n            _owners[id1x1] = uint256(to);\\r\\n        } else {\\r\\n            _regroup(from, to, size, x, y);\\r\\n        }\\r\\n        for (uint256 i = 0; i < size * size; i++) {\\r\\n            emit Transfer(from, to, _idInPath(i, size, x, y));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _checkAndClear(address from, uint256 id) internal returns (bool) {\\r\\n        uint256 owner = _owners[id];\\r\\n        if (owner != 0) {\\r\\n            require(address(owner) == from, \\\"not owner\\\");\\r\\n            _owners[id] = 0;\\r\\n            return true;\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    function _regroup(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 size,\\r\\n        uint256 x,\\r\\n        uint256 y\\r\\n    ) internal {\\r\\n        require(x <= GRID_SIZE - size && y <= GRID_SIZE - size, \\\"Out of bounds\\\");\\r\\n\\r\\n        if (size == 3) {\\r\\n            _regroup3x3(from, to, x, y, true);\\r\\n        } else if (size == 6) {\\r\\n            _regroup6x6(from, to, x, y, true);\\r\\n        } else if (size == 12) {\\r\\n            _regroup12x12(from, to, x, y, true);\\r\\n        } else if (size == 24) {\\r\\n            _regroup24x24(from, to, x, y, true);\\r\\n        } else {\\r\\n            require(false, \\\"Invalid size\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _regroup3x3(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 x,\\r\\n        uint256 y,\\r\\n        bool set\\r\\n    ) internal returns (bool) {\\r\\n        uint256 id = x + y * GRID_SIZE;\\r\\n        uint256 quadId = LAYER_3x3 + id;\\r\\n        bool ownerOfAll = true;\\r\\n        for (uint256 xi = x; xi < x + 3; xi++) {\\r\\n            for (uint256 yi = y; yi < y + 3; yi++) {\\r\\n                ownerOfAll = _checkAndClear(from, xi + yi * GRID_SIZE) && ownerOfAll;\\r\\n            }\\r\\n        }\\r\\n        if (set) {\\r\\n            if (!ownerOfAll) {\\r\\n                require(\\r\\n                    _owners[quadId] == uint256(from) ||\\r\\n                        _owners[LAYER_6x6 + (x / 6) * 6 + ((y / 6) * 6) * GRID_SIZE] == uint256(from) ||\\r\\n                        _owners[LAYER_12x12 + (x / 12) * 12 + ((y / 12) * 12) * GRID_SIZE] == uint256(from) ||\\r\\n                        _owners[LAYER_24x24 + (x / 24) * 24 + ((y / 24) * 24) * GRID_SIZE] == uint256(from),\\r\\n                    \\\"not owner of all sub quads nor parent quads\\\"\\r\\n                );\\r\\n            }\\r\\n            _owners[quadId] = uint256(to);\\r\\n            return true;\\r\\n        }\\r\\n        return ownerOfAll;\\r\\n    }\\r\\n\\r\\n    function _regroup6x6(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 x,\\r\\n        uint256 y,\\r\\n        bool set\\r\\n    ) internal returns (bool) {\\r\\n        uint256 id = x + y * GRID_SIZE;\\r\\n        uint256 quadId = LAYER_6x6 + id;\\r\\n        bool ownerOfAll = true;\\r\\n        for (uint256 xi = x; xi < x + 6; xi += 3) {\\r\\n            for (uint256 yi = y; yi < y + 6; yi += 3) {\\r\\n                bool ownAllIndividual = _regroup3x3(from, to, xi, yi, false);\\r\\n                uint256 id3x3 = LAYER_3x3 + xi + yi * GRID_SIZE;\\r\\n                uint256 owner3x3 = _owners[id3x3];\\r\\n                if (owner3x3 != 0) {\\r\\n                    if (!ownAllIndividual) {\\r\\n                        require(owner3x3 == uint256(from), \\\"not owner of 3x3 quad\\\");\\r\\n                    }\\r\\n                    _owners[id3x3] = 0;\\r\\n                }\\r\\n                ownerOfAll = (ownAllIndividual || owner3x3 != 0) && ownerOfAll;\\r\\n            }\\r\\n        }\\r\\n        if (set) {\\r\\n            if (!ownerOfAll) {\\r\\n                require(\\r\\n                    _owners[quadId] == uint256(from) ||\\r\\n                        _owners[LAYER_12x12 + (x / 12) * 12 + ((y / 12) * 12) * GRID_SIZE] == uint256(from) ||\\r\\n                        _owners[LAYER_24x24 + (x / 24) * 24 + ((y / 24) * 24) * GRID_SIZE] == uint256(from),\\r\\n                    \\\"not owner of all sub quads nor parent quads\\\"\\r\\n                );\\r\\n            }\\r\\n            _owners[quadId] = uint256(to);\\r\\n            return true;\\r\\n        }\\r\\n        return ownerOfAll;\\r\\n    }\\r\\n\\r\\n    function _regroup12x12(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 x,\\r\\n        uint256 y,\\r\\n        bool set\\r\\n    ) internal returns (bool) {\\r\\n        uint256 id = x + y * GRID_SIZE;\\r\\n        uint256 quadId = LAYER_12x12 + id;\\r\\n        bool ownerOfAll = true;\\r\\n        for (uint256 xi = x; xi < x + 12; xi += 6) {\\r\\n            for (uint256 yi = y; yi < y + 12; yi += 6) {\\r\\n                bool ownAllIndividual = _regroup6x6(from, to, xi, yi, false);\\r\\n                uint256 id6x6 = LAYER_6x6 + xi + yi * GRID_SIZE;\\r\\n                uint256 owner6x6 = _owners[id6x6];\\r\\n                if (owner6x6 != 0) {\\r\\n                    if (!ownAllIndividual) {\\r\\n                        require(owner6x6 == uint256(from), \\\"not owner of 6x6 quad\\\");\\r\\n                    }\\r\\n                    _owners[id6x6] = 0;\\r\\n                }\\r\\n                ownerOfAll = (ownAllIndividual || owner6x6 != 0) && ownerOfAll;\\r\\n            }\\r\\n        }\\r\\n        if (set) {\\r\\n            if (!ownerOfAll) {\\r\\n                require(\\r\\n                    _owners[quadId] == uint256(from) ||\\r\\n                        _owners[LAYER_24x24 + (x / 24) * 24 + ((y / 24) * 24) * GRID_SIZE] == uint256(from),\\r\\n                    \\\"not owner of all sub quads nor parent quads\\\"\\r\\n                );\\r\\n            }\\r\\n            _owners[quadId] = uint256(to);\\r\\n            return true;\\r\\n        }\\r\\n        return ownerOfAll;\\r\\n    }\\r\\n\\r\\n    function _regroup24x24(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 x,\\r\\n        uint256 y,\\r\\n        bool set\\r\\n    ) internal returns (bool) {\\r\\n        uint256 id = x + y * GRID_SIZE;\\r\\n        uint256 quadId = LAYER_24x24 + id;\\r\\n        bool ownerOfAll = true;\\r\\n        for (uint256 xi = x; xi < x + 24; xi += 12) {\\r\\n            for (uint256 yi = y; yi < y + 24; yi += 12) {\\r\\n                bool ownAllIndividual = _regroup12x12(from, to, xi, yi, false);\\r\\n                uint256 id12x12 = LAYER_12x12 + xi + yi * GRID_SIZE;\\r\\n                uint256 owner12x12 = _owners[id12x12];\\r\\n                if (owner12x12 != 0) {\\r\\n                    if (!ownAllIndividual) {\\r\\n                        require(owner12x12 == uint256(from), \\\"not owner of 12x12 quad\\\");\\r\\n                    }\\r\\n                    _owners[id12x12] = 0;\\r\\n                }\\r\\n                ownerOfAll = (ownAllIndividual || owner12x12 != 0) && ownerOfAll;\\r\\n            }\\r\\n        }\\r\\n        if (set) {\\r\\n            if (!ownerOfAll) {\\r\\n                require(_owners[quadId] == uint256(from), \\\"not owner of all sub quads not parent quad\\\");\\r\\n            }\\r\\n            _owners[quadId] = uint256(to);\\r\\n            return true;\\r\\n        }\\r\\n        return ownerOfAll || _owners[quadId] == uint256(from);\\r\\n    }\\r\\n\\r\\n    function _ownerOf(uint256 id) internal view returns (address) {\\r\\n        require(id & LAYER == 0, \\\"Invalid token id\\\");\\r\\n        uint256 x = id % GRID_SIZE;\\r\\n        uint256 y = id / GRID_SIZE;\\r\\n        uint256 owner1x1 = _owners[id];\\r\\n\\r\\n        if (owner1x1 != 0) {\\r\\n            return address(owner1x1); // cast to zero\\r\\n        } else {\\r\\n            address owner3x3 = address(_owners[LAYER_3x3 + (x / 3) * 3 + ((y / 3) * 3) * GRID_SIZE]);\\r\\n            if (owner3x3 != address(0)) {\\r\\n                return owner3x3;\\r\\n            } else {\\r\\n                address owner6x6 = address(_owners[LAYER_6x6 + (x / 6) * 6 + ((y / 6) * 6) * GRID_SIZE]);\\r\\n                if (owner6x6 != address(0)) {\\r\\n                    return owner6x6;\\r\\n                } else {\\r\\n                    address owner12x12 = address(_owners[LAYER_12x12 + (x / 12) * 12 + ((y / 12) * 12) * GRID_SIZE]);\\r\\n                    if (owner12x12 != address(0)) {\\r\\n                        return owner12x12;\\r\\n                    } else {\\r\\n                        return address(_owners[LAYER_24x24 + (x / 24) * 24 + ((y / 24) * 24) * GRID_SIZE]);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _ownerAndOperatorEnabledOf(uint256 id) internal view returns (address owner, bool operatorEnabled) {\\r\\n        require(id & LAYER == 0, \\\"Invalid token id\\\");\\r\\n        uint256 x = id % GRID_SIZE;\\r\\n        uint256 y = id / GRID_SIZE;\\r\\n        uint256 owner1x1 = _owners[id];\\r\\n\\r\\n        if (owner1x1 != 0) {\\r\\n            owner = address(owner1x1);\\r\\n            operatorEnabled = (owner1x1 / 2**255) == 1;\\r\\n        } else {\\r\\n            address owner3x3 = address(_owners[LAYER_3x3 + (x / 3) * 3 + ((y / 3) * 3) * GRID_SIZE]);\\r\\n            if (owner3x3 != address(0)) {\\r\\n                owner = owner3x3;\\r\\n                operatorEnabled = false;\\r\\n            } else {\\r\\n                address owner6x6 = address(_owners[LAYER_6x6 + (x / 6) * 6 + ((y / 6) * 6) * GRID_SIZE]);\\r\\n                if (owner6x6 != address(0)) {\\r\\n                    owner = owner6x6;\\r\\n                    operatorEnabled = false;\\r\\n                } else {\\r\\n                    address owner12x12 = address(_owners[LAYER_12x12 + (x / 12) * 12 + ((y / 12) * 12) * GRID_SIZE]);\\r\\n                    if (owner12x12 != address(0)) {\\r\\n                        owner = owner12x12;\\r\\n                        operatorEnabled = false;\\r\\n                    } else {\\r\\n                        owner = address(_owners[LAYER_24x24 + (x / 24) * 24 + ((y / 24) * 24) * GRID_SIZE]);\\r\\n                        operatorEnabled = false;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/Land/erc721/ERC721BaseToken.sol\": {\r\n      \"content\": \"/* solhint-disable func-order, code-complexity */\\r\\npragma solidity 0.5.9;\\r\\n\\r\\nimport \\\"../../contracts_common/Libraries/AddressUtils.sol\\\";\\r\\nimport \\\"../../contracts_common/Interfaces/ERC721TokenReceiver.sol\\\";\\r\\nimport \\\"../../contracts_common/Interfaces/ERC721Events.sol\\\";\\r\\nimport \\\"../../contracts_common/BaseWithStorage/SuperOperators.sol\\\";\\r\\nimport \\\"../../contracts_common/BaseWithStorage/MetaTransactionReceiver.sol\\\";\\r\\nimport \\\"../../contracts_common/Interfaces/ERC721MandatoryTokenReceiver.sol\\\";\\r\\n\\r\\ncontract ERC721BaseToken is ERC721Events, SuperOperators, MetaTransactionReceiver {\\r\\n    using AddressUtils for address;\\r\\n\\r\\n    bytes4 internal constant _ERC721_RECEIVED = 0x150b7a02;\\r\\n    bytes4 internal constant _ERC721_BATCH_RECEIVED = 0x4b808c46;\\r\\n\\r\\n    bytes4 internal constant ERC165ID = 0x01ffc9a7;\\r\\n    bytes4 internal constant ERC721_MANDATORY_RECEIVER = 0x5e8bf644;\\r\\n\\r\\n    mapping (address => uint256) public _numNFTPerAddress;\\r\\n    mapping (uint256 => uint256) public _owners;\\r\\n    mapping (address => mapping(address => bool)) public _operatorsForAll;\\r\\n    mapping (uint256 => address) public _operators;\\r\\n\\r\\n    constructor(\\r\\n        address metaTransactionContract,\\r\\n        address admin\\r\\n    ) internal {\\r\\n        _admin = admin;\\r\\n        _setMetaTransactionProcessor(metaTransactionContract, true);\\r\\n    }\\r\\n\\r\\n    function _transferFrom(address from, address to, uint256 id) internal {\\r\\n        _numNFTPerAddress[from]--;\\r\\n        _numNFTPerAddress[to]++;\\r\\n        _owners[id] = uint256(to);\\r\\n        emit Transfer(from, to, id);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Return the number of Land owned by an address\\r\\n     * @param owner The address to look for\\r\\n     * @return The number of Land token owned by the address\\r\\n     */\\r\\n    function balanceOf(address owner) external view returns (uint256) {\\r\\n        require(owner != address(0), \\\"owner is zero address\\\");\\r\\n        return _numNFTPerAddress[owner];\\r\\n    }\\r\\n\\r\\n\\r\\n    function _ownerOf(uint256 id) internal view returns (address) {\\r\\n        return address(_owners[id]);\\r\\n    }\\r\\n\\r\\n    function _ownerAndOperatorEnabledOf(uint256 id) internal view returns (address owner, bool operatorEnabled) {\\r\\n        uint256 data = _owners[id];\\r\\n        owner = address(data);\\r\\n        operatorEnabled = (data / 2**255) == 1;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Return the owner of a Land\\r\\n     * @param id The id of the Land\\r\\n     * @return The address of the owner\\r\\n     */\\r\\n    function ownerOf(uint256 id) external view returns (address owner) {\\r\\n        owner = _ownerOf(id);\\r\\n        require(owner != address(0), \\\"token does not exist\\\");\\r\\n    }\\r\\n\\r\\n    function _approveFor(address owner, address operator, uint256 id) internal {\\r\\n        if(operator == address(0)) {\\r\\n            _owners[id] = uint256(owner); // no need to resset the operator, it will be overriden next time\\r\\n        } else {\\r\\n            _owners[id] = uint256(owner) + 2**255;\\r\\n            _operators[id] = operator;\\r\\n        }\\r\\n        emit Approval(owner, operator, id);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Approve an operator to spend tokens on the sender behalf\\r\\n     * @param sender The address giving the approval\\r\\n     * @param operator The address receiving the approval\\r\\n     * @param id The id of the token\\r\\n     */\\r\\n    function approveFor(\\r\\n        address sender,\\r\\n        address operator,\\r\\n        uint256 id\\r\\n    ) external {\\r\\n        address owner = _ownerOf(id);\\r\\n        require(sender != address(0), \\\"sender is zero address\\\");\\r\\n        require(\\r\\n            msg.sender == sender ||\\r\\n            _metaTransactionContracts[msg.sender] ||\\r\\n            _superOperators[msg.sender] ||\\r\\n            _operatorsForAll[sender][msg.sender],\\r\\n            \\\"not authorized to approve\\\"\\r\\n        );\\r\\n        require(owner == sender, \\\"owner != sender\\\");\\r\\n        _approveFor(owner, operator, id);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Approve an operator to spend tokens on the sender behalf\\r\\n     * @param operator The address receiving the approval\\r\\n     * @param id The id of the token\\r\\n     */\\r\\n    function approve(address operator, uint256 id) external {\\r\\n        address owner = _ownerOf(id);\\r\\n        require(owner != address(0), \\\"token does not exist\\\");\\r\\n        require(\\r\\n            owner == msg.sender ||\\r\\n            _superOperators[msg.sender] ||\\r\\n            _operatorsForAll[owner][msg.sender],\\r\\n            \\\"not authorized to approve\\\"\\r\\n        );\\r\\n        _approveFor(owner, operator, id);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get the approved operator for a specific token\\r\\n     * @param id The id of the token\\r\\n     * @return The address of the operator\\r\\n     */\\r\\n    function getApproved(uint256 id) external view returns (address) {\\r\\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\\r\\n        require(owner != address(0), \\\"token does not exist\\\");\\r\\n        if (operatorEnabled) {\\r\\n            return _operators[id];\\r\\n        } else {\\r\\n            return address(0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _checkTransfer(address from, address to, uint256 id) internal view returns (bool isMetaTx) {\\r\\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\\r\\n        require(owner != address(0), \\\"token does not exist\\\");\\r\\n        require(owner == from, \\\"not owner in _checkTransfer\\\");\\r\\n        require(to != address(0), \\\"can't send to zero address\\\");\\r\\n        isMetaTx = msg.sender != from && _metaTransactionContracts[msg.sender];\\r\\n        if (msg.sender != from && !isMetaTx) {\\r\\n            require(\\r\\n                _superOperators[msg.sender] ||\\r\\n                _operatorsForAll[from][msg.sender] ||\\r\\n                (operatorEnabled && _operators[id] == msg.sender),\\r\\n                \\\"not approved to transfer\\\"\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _checkInterfaceWith10000Gas(address _contract, bytes4 interfaceId)\\r\\n        internal\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        bool success;\\r\\n        bool result;\\r\\n        bytes memory call_data = abi.encodeWithSelector(\\r\\n            ERC165ID,\\r\\n            interfaceId\\r\\n        );\\r\\n        // solium-disable-next-line security/no-inline-assembly\\r\\n        assembly {\\r\\n            let call_ptr := add(0x20, call_data)\\r\\n            let call_size := mload(call_data)\\r\\n            let output := mload(0x40) // Find empty storage location using \\\"free memory pointer\\\"\\r\\n            mstore(output, 0x0)\\r\\n            success := staticcall(\\r\\n                10000,\\r\\n                _contract,\\r\\n                call_ptr,\\r\\n                call_size,\\r\\n                output,\\r\\n                0x20\\r\\n            ) // 32 bytes\\r\\n            result := mload(output)\\r\\n        }\\r\\n        // (10000 / 63) \\\"not enough for supportsInterface(...)\\\" // consume all gas, so caller can potentially know that there was not enough gas\\r\\n        assert(gasleft() > 158);\\r\\n        return success && result;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfer a token between 2 addresses\\r\\n     * @param from The sender of the token\\r\\n     * @param to The recipient of the token\\r\\n     * @param id The id of the token\\r\\n    */\\r\\n    function transferFrom(address from, address to, uint256 id) external {\\r\\n        bool metaTx = _checkTransfer(from, to, id);\\r\\n        _transferFrom(from, to, id);\\r\\n        if (to.isContract() && _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\\r\\n            require(\\r\\n                _checkOnERC721Received(metaTx ? from : msg.sender, from, to, id, \\\"\\\"),\\r\\n                \\\"erc721 transfer rejected by to\\\"\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfer a token between 2 addresses letting the receiver knows of the transfer\\r\\n     * @param from The sender of the token\\r\\n     * @param to The recipient of the token\\r\\n     * @param id The id of the token\\r\\n     * @param data Additional data\\r\\n     */\\r\\n    function safeTransferFrom(address from, address to, uint256 id, bytes memory data) public {\\r\\n        bool metaTx = _checkTransfer(from, to, id);\\r\\n        _transferFrom(from, to, id);\\r\\n        if (to.isContract()) {\\r\\n            require(\\r\\n                _checkOnERC721Received(metaTx ? from : msg.sender, from, to, id, data),\\r\\n                \\\"ERC721: transfer rejected by to\\\"\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfer a token between 2 addresses letting the receiver knows of the transfer\\r\\n     * @param from The send of the token\\r\\n     * @param to The recipient of the token\\r\\n     * @param id The id of the token\\r\\n     */\\r\\n    function safeTransferFrom(address from, address to, uint256 id) external {\\r\\n        safeTransferFrom(from, to, id, \\\"\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfer many tokens between 2 addresses\\r\\n     * @param from The sender of the token\\r\\n     * @param to The recipient of the token\\r\\n     * @param ids The ids of the tokens\\r\\n     * @param data additional data\\r\\n    */\\r\\n    function batchTransferFrom(address from, address to, uint256[] calldata ids, bytes calldata data) external {\\r\\n        _batchTransferFrom(from, to, ids, data, false);\\r\\n    }\\r\\n\\r\\n    function _batchTransferFrom(address from, address to, uint256[] memory ids, bytes memory data, bool safe) internal {\\r\\n        bool metaTx = msg.sender != from && _metaTransactionContracts[msg.sender];\\r\\n        bool authorized = msg.sender == from ||\\r\\n            metaTx ||\\r\\n            _superOperators[msg.sender] ||\\r\\n            _operatorsForAll[from][msg.sender];\\r\\n\\r\\n        require(from != address(0), \\\"from is zero address\\\");\\r\\n        require(to != address(0), \\\"can't send to zero address\\\");\\r\\n\\r\\n        uint256 numTokens = ids.length;\\r\\n        for(uint256 i = 0; i < numTokens; i ++) {\\r\\n            uint256 id = ids[i];\\r\\n            (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\\r\\n            require(owner == from, \\\"not owner in batchTransferFrom\\\");\\r\\n            require(authorized || (operatorEnabled && _operators[id] == msg.sender), \\\"not authorized\\\");\\r\\n            _owners[id] = uint256(to);\\r\\n            emit Transfer(from, to, id);\\r\\n        }\\r\\n        if (from != to) {\\r\\n            _numNFTPerAddress[from] -= numTokens;\\r\\n            _numNFTPerAddress[to] += numTokens;\\r\\n        }\\r\\n\\r\\n        if (to.isContract() && (safe || _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER))) {\\r\\n            require(\\r\\n                _checkOnERC721BatchReceived(metaTx ? from : msg.sender, from, to, ids, data),\\r\\n                \\\"erc721 batch transfer rejected by to\\\"\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfer many tokens between 2 addresses ensuring the receiving contract has a receiver method\\r\\n     * @param from The sender of the token\\r\\n     * @param to The recipient of the token\\r\\n     * @param ids The ids of the tokens\\r\\n     * @param data additional data\\r\\n    */\\r\\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, bytes calldata data) external {\\r\\n        _batchTransferFrom(from, to, ids, data, true);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Check if the contract supports an interface\\r\\n     * 0x01ffc9a7 is ERC-165\\r\\n     * 0x80ac58cd is ERC-721\\r\\n     * @param id The id of the interface\\r\\n     * @return True if the interface is supported\\r\\n     */\\r\\n    function supportsInterface(bytes4 id) external pure returns (bool) {\\r\\n        return id == 0x01ffc9a7 || id == 0x80ac58cd;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Set the approval for an operator to manage all the tokens of the sender\\r\\n     * @param sender The address giving the approval\\r\\n     * @param operator The address receiving the approval\\r\\n     * @param approved The determination of the approval\\r\\n     */\\r\\n    function setApprovalForAllFor(\\r\\n        address sender,\\r\\n        address operator,\\r\\n        bool approved\\r\\n    ) external {\\r\\n        require(sender != address(0), \\\"Invalid sender address\\\");\\r\\n        require(\\r\\n            msg.sender == sender ||\\r\\n            _metaTransactionContracts[msg.sender] ||\\r\\n            _superOperators[msg.sender],\\r\\n            \\\"not authorized to approve for all\\\"\\r\\n        );\\r\\n\\r\\n        _setApprovalForAll(sender, operator, approved);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Set the approval for an operator to manage all the tokens of the sender\\r\\n     * @param operator The address receiving the approval\\r\\n     * @param approved The determination of the approval\\r\\n     */\\r\\n    function setApprovalForAll(address operator, bool approved) external {\\r\\n        _setApprovalForAll(msg.sender, operator, approved);\\r\\n    }\\r\\n\\r\\n\\r\\n    function _setApprovalForAll(\\r\\n        address sender,\\r\\n        address operator,\\r\\n        bool approved\\r\\n    ) internal {\\r\\n        require(\\r\\n            !_superOperators[operator],\\r\\n            \\\"super operator can't have their approvalForAll changed\\\"\\r\\n        );\\r\\n        _operatorsForAll[sender][operator] = approved;\\r\\n\\r\\n        emit ApprovalForAll(sender, operator, approved);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Check if the sender approved the operator\\r\\n     * @param owner The address of the owner\\r\\n     * @param operator The address of the operator\\r\\n     * @return The status of the approval\\r\\n     */\\r\\n    function isApprovedForAll(address owner, address operator)\\r\\n        external\\r\\n        view\\r\\n        returns (bool isOperator)\\r\\n    {\\r\\n        return _operatorsForAll[owner][operator] || _superOperators[operator];\\r\\n    }\\r\\n\\r\\n    function _burn(address from, address owner, uint256 id) internal {\\r\\n        require(from == owner, \\\"not owner\\\");\\r\\n        _owners[id] = 2**160; // cannot mint it again\\r\\n        _numNFTPerAddress[from]--;\\r\\n        emit Transfer(from, address(0), id);\\r\\n    }\\r\\n\\r\\n    /// @notice Burns token `id`.\\r\\n    /// @param id token which will be burnt.\\r\\n    function burn(uint256 id) external {\\r\\n        _burn(msg.sender, _ownerOf(id), id);\\r\\n    }\\r\\n\\r\\n    /// @notice Burn token`id` from `from`.\\r\\n    /// @param from address whose token is to be burnt.\\r\\n    /// @param id token which will be burnt.\\r\\n    function burnFrom(address from, uint256 id) external {\\r\\n        require(from != address(0), \\\"Invalid sender address\\\");\\r\\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\\r\\n        require(\\r\\n            msg.sender == from ||\\r\\n            _metaTransactionContracts[msg.sender] ||\\r\\n            (operatorEnabled && _operators[id] == msg.sender) ||\\r\\n            _superOperators[msg.sender] ||\\r\\n            _operatorsForAll[from][msg.sender],\\r\\n            \\\"not authorized to burn\\\"\\r\\n        );\\r\\n        _burn(from, owner, id);\\r\\n    }\\r\\n\\r\\n    function _checkOnERC721Received(address operator, address from, address to, uint256 tokenId, bytes memory _data)\\r\\n        internal returns (bool)\\r\\n    {\\r\\n        bytes4 retval = ERC721TokenReceiver(to).onERC721Received(operator, from, tokenId, _data);\\r\\n        return (retval == _ERC721_RECEIVED);\\r\\n    }\\r\\n\\r\\n    function _checkOnERC721BatchReceived(address operator, address from, address to, uint256[] memory ids, bytes memory _data)\\r\\n        internal returns (bool)\\r\\n    {\\r\\n        bytes4 retval = ERC721MandatoryTokenReceiver(to).onERC721BatchReceived(operator, from, ids, _data);\\r\\n        return (retval == _ERC721_BATCH_RECEIVED);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/contracts_common/Libraries/AddressUtils.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\r\\n\\r\\nlibrary AddressUtils {\\r\\n\\r\\n    function toPayable(address _address) internal pure returns (address payable _payable) {\\r\\n        return address(uint160(_address));\\r\\n    }\\r\\n\\r\\n    function isContract(address addr) internal view returns (bool) {\\r\\n        // for accounts without code, i.e. `keccak256('')`:\\r\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n\\r\\n        bytes32 codehash;\\r\\n        // solium-disable-next-line security/no-inline-assembly\\r\\n        assembly {\\r\\n            codehash := extcodehash(addr)\\r\\n        }\\r\\n        return (codehash != 0x0 && codehash != accountHash);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/contracts_common/Interfaces/ERC721TokenReceiver.sol\": {\r\n      \"content\": \"/* This Source Code Form is subject to the terms of the Mozilla Public\\r\\n * License, v. 2.0. If a copy of the MPL was not distributed with this\\r\\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\\r\\n *\\r\\n * This code has not been reviewed.\\r\\n * Do not use or deploy this code before reviewing it personally first.\\r\\n */\\r\\n// solhint-disable-next-line compiler-fixed\\r\\npragma solidity ^0.5.2;\\r\\n\\r\\ninterface ERC721TokenReceiver {\\r\\n    function onERC721Received(\\r\\n        address operator,\\r\\n        address from,\\r\\n        uint256 tokenId,\\r\\n        bytes calldata data\\r\\n    ) external returns (bytes4);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/contracts_common/Interfaces/ERC721Events.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\r\\n\\r\\n/**\\r\\n * @title ERC721 Non-Fungible Token Standard basic interface\\r\\n * @dev see https://eips.ethereum.org/EIPS/eip-721\\r\\n */\\r\\ninterface ERC721Events {\\r\\n    event Transfer(\\r\\n        address indexed _from,\\r\\n        address indexed _to,\\r\\n        uint256 indexed _tokenId\\r\\n    );\\r\\n    event Approval(\\r\\n        address indexed _owner,\\r\\n        address indexed _approved,\\r\\n        uint256 indexed _tokenId\\r\\n    );\\r\\n    event ApprovalForAll(\\r\\n        address indexed _owner,\\r\\n        address indexed _operator,\\r\\n        bool _approved\\r\\n    );\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/contracts_common/BaseWithStorage/SuperOperators.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\r\\n\\r\\nimport \\\"./Admin.sol\\\";\\r\\n\\r\\ncontract SuperOperators is Admin {\\r\\n\\r\\n    mapping(address => bool) internal _superOperators;\\r\\n\\r\\n    event SuperOperator(address superOperator, bool enabled);\\r\\n\\r\\n    /// @notice Enable or disable the ability of `superOperator` to transfer tokens of all (superOperator rights).\\r\\n    /// @param superOperator address that will be given/removed superOperator right.\\r\\n    /// @param enabled set whether the superOperator is enabled or disabled.\\r\\n    function setSuperOperator(address superOperator, bool enabled) external {\\r\\n        require(\\r\\n            msg.sender == _admin,\\r\\n            \\\"only admin is allowed to add super operators\\\"\\r\\n        );\\r\\n        _superOperators[superOperator] = enabled;\\r\\n        emit SuperOperator(superOperator, enabled);\\r\\n    }\\r\\n\\r\\n    /// @notice check whether address `who` is given superOperator rights.\\r\\n    /// @param who The address to query.\\r\\n    /// @return whether the address has superOperator rights.\\r\\n    function isSuperOperator(address who) public view returns (bool) {\\r\\n        return _superOperators[who];\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/contracts_common/BaseWithStorage/MetaTransactionReceiver.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\r\\n\\r\\nimport \\\"./Admin.sol\\\";\\r\\n\\r\\ncontract MetaTransactionReceiver is Admin{\\r\\n\\r\\n    mapping(address => bool) internal _metaTransactionContracts;\\r\\n    event MetaTransactionProcessor(address metaTransactionProcessor, bool enabled);\\r\\n\\r\\n    /// @notice Enable or disable the ability of `metaTransactionProcessor` to perform meta-tx (metaTransactionProcessor rights).\\r\\n    /// @param metaTransactionProcessor address that will be given/removed metaTransactionProcessor rights.\\r\\n    /// @param enabled set whether the metaTransactionProcessor is enabled or disabled.\\r\\n    function setMetaTransactionProcessor(address metaTransactionProcessor, bool enabled) public {\\r\\n        require(\\r\\n            msg.sender == _admin,\\r\\n            \\\"only admin can setup metaTransactionProcessors\\\"\\r\\n        );\\r\\n        _setMetaTransactionProcessor(metaTransactionProcessor, enabled);\\r\\n    }\\r\\n\\r\\n    function _setMetaTransactionProcessor(address metaTransactionProcessor, bool enabled) internal {\\r\\n        _metaTransactionContracts[metaTransactionProcessor] = enabled;\\r\\n        emit MetaTransactionProcessor(metaTransactionProcessor, enabled);\\r\\n    }\\r\\n\\r\\n    /// @notice check whether address `who` is given meta-transaction execution rights.\\r\\n    /// @param who The address to query.\\r\\n    /// @return whether the address has meta-transaction execution rights.\\r\\n    function isMetaTransactionProcessor(address who) external view returns(bool) {\\r\\n        return _metaTransactionContracts[who];\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/contracts_common/Interfaces/ERC721MandatoryTokenReceiver.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\r\\n\\r\\n/**\\r\\n    Note: The ERC-165 identifier for this interface is 0x5e8bf644.\\r\\n*/\\r\\ninterface ERC721MandatoryTokenReceiver {\\r\\n    function onERC721BatchReceived(\\r\\n        address operator,\\r\\n        address from,\\r\\n        uint256[] calldata ids,\\r\\n        bytes calldata data\\r\\n    ) external returns (bytes4); // needs to return 0x4b808c46\\r\\n\\r\\n    function onERC721Received(\\r\\n        address operator,\\r\\n        address from,\\r\\n        uint256 tokenId,\\r\\n        bytes calldata data\\r\\n    ) external returns (bytes4); // needs to return 0x150b7a02\\r\\n\\r\\n    // needs to implements EIP-165\\r\\n    // function supportsInterface(bytes4 interfaceId)\\r\\n    //     external\\r\\n    //     view\\r\\n    //     returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/contracts_common/BaseWithStorage/Admin.sol\": {\r\n      \"content\": \"pragma solidity ^0.5.2;\\r\\n\\r\\ncontract Admin {\\r\\n\\r\\n    address internal _admin;\\r\\n\\r\\n    event AdminChanged(address oldAdmin, address newAdmin);\\r\\n\\r\\n    /// @notice gives the current administrator of this contract.\\r\\n    /// @return the current administrator of this contract.\\r\\n    function getAdmin() external view returns (address) {\\r\\n        return _admin;\\r\\n    }\\r\\n\\r\\n    /// @notice change the administrator to be `newAdmin`.\\r\\n    /// @param newAdmin address of the new administrator.\\r\\n    function changeAdmin(address newAdmin) external {\\r\\n        require(msg.sender == _admin, \\\"only admin can change admin\\\");\\r\\n        emit AdminChanged(_admin, newAdmin);\\r\\n        _admin = newAdmin;\\r\\n    }\\r\\n\\r\\n    modifier onlyAdmin() {\\r\\n        require (msg.sender == _admin, \\\"only admin allowed\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"height\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"ids\",\"type\":\"uint256[]\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"batchTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"ids\",\"type\":\"uint256[]\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approveFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"size\",\"type\":\"uint256\"},{\"name\":\"x\",\"type\":\"uint256\"},{\"name\":\"y\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferQuad\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"x\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"y\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"isSuperOperator\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"size\",\"type\":\"uint256\"},{\"name\":\"x\",\"type\":\"uint256\"},{\"name\":\"y\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"mintQuad\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"_numNFTPerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"metaTransactionProcessor\",\"type\":\"address\"},{\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setMetaTransactionProcessor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_owners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"_operatorsForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"width\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"isMinter\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"superOperator\",\"type\":\"address\"},{\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setSuperOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_operators\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"minter\",\"type\":\"address\"},{\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"isMetaTransactionProcessor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"isOperator\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"sizes\",\"type\":\"uint256[]\"},{\"name\":\"xs\",\"type\":\"uint256[]\"},{\"name\":\"ys\",\"type\":\"uint256[]\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"batchTransferQuad\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAllFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"metaTransactionContract\",\"type\":\"address\"},{\"name\":\"admin\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"superOperator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"Minter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"metaTransactionProcessor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"MetaTransactionProcessor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"superOperator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"SuperOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]", "ContractName": "LandBsc", "CompilerVersion": "v0.5.9+commit.e560f70d", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000005281866308e3433a6c0306eff70ea4998f0ce248", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}