{"SourceCode": "/**\r\n    ***********************************************************\r\n    * Copyright (c) Avara Dev. 2021. (Telegram: @avara_cc)  *\r\n    ***********************************************************\r\n\r\n     \u2584\u2584\u2584\u00b7  \u258c \u2590\u00b7 \u2584\u2584\u2584\u00b7 \u2584\u2584\u2584   \u2584\u2584\u2584\u00b7\r\n    \u2590\u2588 \u2580\u2588 \u25aa\u2588\u00b7\u2588\u258c\u2590\u2588 \u2580\u2588 \u2580\u2584 \u2588\u00b7\u2590\u2588 \u2580\u2588\r\n    \u2584\u2588\u2580\u2580\u2588 \u2590\u2588\u2590\u2588\u2022\u2584\u2588\u2580\u2580\u2588 \u2590\u2580\u2580\u2584 \u2584\u2588\u2580\u2580\u2588\r\n    \u2590\u2588 \u25aa\u2590\u258c \u2588\u2588\u2588 \u2590\u2588 \u25aa\u2590\u258c\u2590\u2588\u2022\u2588\u258c\u2590\u2588 \u25aa\u2590\u258c\r\n     \u2580  \u2580 . \u2580   \u2580  \u2580 .\u2580  \u2580 \u2580  \u2580  - Binance Smart Chain\r\n\r\n    Avara - Always Vivid, Always Rising Above\r\n    https://avara.cc/\r\n    https://github.com/avara-cc\r\n    https://github.com/avara-cc/Avara/wiki\r\n*/\r\n\r\n// SPDX-License-Identifier: AGPL-3.0-or-later\r\n\r\npragma solidity 0.8.4;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data.\r\n */\r\nabstract contract Context {\r\n    /**\r\n     * @dev Returns the value of the msg.sender variable.\r\n     */\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value of the msg.data variable.\r\n     */\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        this;\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev The IBEP20 standards\r\n */\r\ninterface IBEP20 {\r\n    /**\r\n    * @dev Returns the amount of tokens in existence.\r\n    */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the token decimals.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Returns the token symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token name.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the bep token owner.\r\n     */\r\n    function getOwner() external view returns (address);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n */\r\nabstract contract Ownable is Context {\r\n    // Current owner address\r\n    address private _owner;\r\n    // Previous owner address\r\n    address private _previousOwner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the given address as the initial owner.\r\n     */\r\n    constructor(address initOwner) {\r\n        _setOwner(initOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the previous owner.\r\n     */\r\n    function previousOwner() public view virtual returns (address) {\r\n        return _previousOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: The caller is not the owner!\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without an owner. It won't be possible to call `onlyOwner` functions anymore.\r\n     * Can only be called by the current owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: The new owner is now, the zero address!\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the owner of the token to the given address.\r\n     *\r\n     * Emits an {OwnershipTransferred} event.\r\n     */\r\n    function _setOwner(address newOwner) private {\r\n        _previousOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(_previousOwner, newOwner);\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the benefit is lost if 'b' is also tested.\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @dev The PancakeSwapV2 standards\r\n */\r\ninterface IPancakeRouter01 {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable\r\n    returns (uint[] memory amounts);\r\n\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external returns (uint[] memory amounts);\r\n\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline) external payable\r\n    returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\n/**\r\n * @dev The PancakeSwapV2 standards\r\n */\r\ninterface IPancakeRouter02 is IPancakeRouter01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\n/**\r\n * @dev The PancakeSwapV2 standards\r\n */\r\ninterface IPancakePair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n\r\n    function symbol() external pure returns (string memory);\r\n\r\n    function decimals() external pure returns (uint8);\r\n\r\n    function totalSupply() external view returns (uint);\r\n\r\n    function balanceOf(address owner) external view returns (uint);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n\r\n    function transfer(address to, uint value) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n\r\n    function factory() external view returns (address);\r\n\r\n    function token0() external view returns (address);\r\n\r\n    function token1() external view returns (address);\r\n\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n\r\n    function price0CumulativeLast() external view returns (uint);\r\n\r\n    function price1CumulativeLast() external view returns (uint);\r\n\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n\r\n    function skim(address to) external;\r\n\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n/**\r\n * @dev The PancakeSwapV2 standards\r\n */\r\ninterface IPancakeFactory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n\r\n    function allPairs(uint) external view returns (address pair);\r\n\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ncontract Avara is Context, IBEP20, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    //\r\n    // Reward, fee and wallet related variables.\r\n    //\r\n    mapping(address => uint256) private _rewardOwned;\r\n    mapping(address => uint256) private _tokenOwned;\r\n    mapping(address => bool)    private _isExcludedFromFee;\r\n    mapping(address => bool)    private _isExcluded;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    address[] private _excluded;\r\n    address public _devWallet;\r\n\r\n    //\r\n    // Summary of the fees\r\n    //\r\n    uint256 private _bitDuelServiceFeeTotal;\r\n    uint256 private _developerFeeTotal;\r\n    uint256 private _eventFeeTotal;\r\n    uint256 private _feeTotal;\r\n    uint256 private _marketingFeeTotal;\r\n\r\n    //\r\n    // AvaraToken metadata\r\n    //\r\n    string private constant _tokenName = \"AVARA\";\r\n    string private constant _tokenSymbol = \"AVR\";\r\n    uint8 private constant _tokenDecimals = 9;\r\n\r\n    uint256 private constant MAX = ~uint256(0);\r\n    uint256 private constant _totalSupply = 500000000 * 10 ** uint256(_tokenDecimals);\r\n    uint256 private _rewardSupply = (MAX - (MAX % _totalSupply));\r\n\r\n    // 2% is going to the be the founding of the upcoming Events\r\n    uint256 public _eventFee = 200;\r\n    // 3% is going to Marketing.\r\n    uint256 public _marketingFee = 400;\r\n    // 3% is going to the Developers.\r\n    uint256 public _developerFee = 400;\r\n    // 2% service fee on BitDuel.\r\n    uint256 public _bitDuelServiceFee = 200;\r\n\r\n    uint256 public _maxTxAmount = 250000000 * 10 ** uint256(_tokenDecimals);\r\n\r\n    //\r\n    // BitDuel\r\n    //\r\n    mapping(address => uint256) private _playerPool;\r\n    address public _playerPoolWallet;\r\n\r\n    // A constant, used for checking the connection between the server and the contract.\r\n    string private constant _pong = \"PONG\";\r\n\r\n    //\r\n    // Liquidity related fields.\r\n    //\r\n\r\n    // The address of the PancakeRouter\r\n    address private constant _routerAddress = 0x10ED43C718714eb63d5aA57B78B54704E256024E;\r\n\r\n    IPancakeRouter02 public _pancakeSwapV2Router;\r\n    address public _pancakeSwapV2Pair;\r\n\r\n    event EventFeeChanged(uint256 oldFee, uint256 newFee);\r\n    event MarketingFeeChanged(uint256 oldFee, uint256 newFee);\r\n    event DeveloperFeeChanged(uint256 oldFee, uint256 newFee);\r\n    event BitDuelServiceFeeChanged(uint256 oldFee, uint256 newFee);\r\n    event DevWalletChanged(address oldAddress, address newAddress);\r\n    event PlayerPoolChanged(address oldAddress, address newAddress);\r\n    event PancakeRouterChanged(address oldAddress, address newAddress);\r\n    event PancakePairChanged(address oldAddress, address newAddress);\r\n    event MaxTransactionAmountChanged(uint256 oldAmount, uint256 newAmount);\r\n    event Received(address sender, uint value);\r\n    event FallBack(address sender, uint value);\r\n\r\n    /**\r\n    * @dev Executed on a call to the contract with empty call data.\r\n    */\r\n    receive() external payable {\r\n        emit Received(msg.sender, msg.value);\r\n    }\r\n\r\n    /**\r\n    * @dev Executed on a call to the contract that does not match any of the contract functions.\r\n    */\r\n    fallback() external payable {\r\n        emit FallBack(msg.sender, msg.value);\r\n    }\r\n\r\n    //\r\n    // The token constructor.\r\n    //\r\n\r\n    constructor (address cOwner, address devWallet, address playerPoolWallet) Ownable(cOwner) {\r\n        _devWallet = devWallet;\r\n        _playerPoolWallet = playerPoolWallet;\r\n\r\n        _rewardOwned[cOwner] = _rewardSupply;\r\n        _pancakeSwapV2Router = IPancakeRouter02(_routerAddress);\r\n\r\n        // Exclude the system addresses from the fee.\r\n        _isExcludedFromFee[owner()] = true;\r\n        _isExcludedFromFee[address(this)] = true;\r\n        _isExcludedFromFee[_devWallet] = true;\r\n\r\n        emit Transfer(address(0), cOwner, _totalSupply);\r\n    }\r\n\r\n    //\r\n    // Contract Modules\r\n    //\r\n\r\n    struct Module {\r\n        string moduleName;\r\n        string moduleVersion;\r\n        address moduleAddress;\r\n    }\r\n\r\n    Module[] private modules;\r\n\r\n    event ModuleAdded(address moduleAddress, string moduleName, string moduleVersion);\r\n    event ModuleRemoved(string moduleName);\r\n\r\n    /**\r\n    * @dev Adds a module to the contract with the given ModuleName and Version on the given ModuleAddress.\r\n    */\r\n    function addModule(string memory moduleName, string memory moduleVersion, address moduleAddress) external onlyOwner {\r\n        Module memory module;\r\n        module.moduleVersion = moduleVersion;\r\n        module.moduleAddress = moduleAddress;\r\n        module.moduleName = moduleName;\r\n\r\n        bool added = false;\r\n        for (uint256 i = 0; i < modules.length; i++) {\r\n            if (keccak256(abi.encodePacked(modules[i].moduleName)) == keccak256(abi.encodePacked(moduleName))) {\r\n                modules[i] = module;\r\n                added = true;\r\n            }\r\n        }\r\n\r\n        if (!added) {\r\n            modules.push(module);\r\n\r\n            emit ModuleAdded(moduleAddress, moduleName, moduleVersion);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Removes a module from the contract.\r\n    */\r\n    function removeModule(string memory moduleName) external onlyOwner {\r\n        uint256 index;\r\n        bool found = false;\r\n        for (uint256 i = 0; i < modules.length; i++) {\r\n            if (keccak256(abi.encodePacked(modules[i].moduleName)) == keccak256(abi.encodePacked(moduleName))) {\r\n                index = i;\r\n                found = true;\r\n            }\r\n        }\r\n\r\n        if (found) {\r\n            modules[index] = modules[modules.length - 1];\r\n            delete modules[modules.length - 1];\r\n            modules.pop();\r\n\r\n            emit ModuleRemoved(moduleName);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Retrieves a 2-tuple (success? + search result) by the given ModuleName.\r\n    */\r\n    function getModule(string memory moduleName) external view returns (bool, Module memory) {\r\n        Module memory result;\r\n        bool found = false;\r\n        for (uint256 i = 0; i < modules.length; i++) {\r\n            if (keccak256(abi.encodePacked(modules[i].moduleName)) == keccak256(abi.encodePacked(moduleName))) {\r\n                result = modules[i];\r\n                found = true;\r\n            }\r\n        }\r\n        return (found, result);\r\n    }\r\n\r\n    /**\r\n    * @dev A modifier that requires the message sender to be the owner of the contract or a Module on the contract.\r\n    */\r\n    modifier onlyOwnerOrModule() {\r\n        bool isModule = false;\r\n        for (uint256 i = 0; i < modules.length; i++) {\r\n            if (modules[i].moduleAddress == _msgSender()) {\r\n                isModule = true;\r\n            }\r\n        }\r\n\r\n        require(isModule || owner() == _msgSender(), \"The caller is not the owner nor an authenticated Avara module!\");\r\n        _;\r\n    }\r\n\r\n    //\r\n    // BitDuel functions\r\n    //\r\n\r\n    /**\r\n    * @dev Occasionally called (only) by the server to make sure that the connection with the contract is granted.\r\n    */\r\n    function ping() external view onlyOwnerOrModule returns (string memory) {\r\n        return _pong;\r\n    }\r\n\r\n    /**\r\n    * @dev A function used to withdraw from the player pool.\r\n    */\r\n    function withdraw(uint256 amount) external {\r\n        require(_playerPool[_msgSender()] >= amount, \"Invalid amount!\");\r\n        _transfer(_playerPoolWallet, _msgSender(), amount);\r\n        _playerPool[_msgSender()] -= amount;\r\n    }\r\n\r\n    /**\r\n    * @dev Retrieve the balance of a player from the player pool.\r\n    */\r\n    function balanceInPlayerPool(address playerAddress) external view returns (uint256) {\r\n        return _playerPool[playerAddress];\r\n    }\r\n\r\n    /**\r\n    * @dev Called by BitDuel after a won / lost game, to set the new balance of a user in the player pool.\r\n    * The gas price is provided by BitDuel.\r\n    */\r\n    function setPlayerBalance(address playerAddress, uint256 balance) external onlyOwnerOrModule {\r\n        _playerPool[playerAddress] = balance;\r\n    }\r\n\r\n    //\r\n    // Reward and Token related functionalities\r\n    //\r\n\r\n    struct RewardValues {\r\n        uint256 rAmount;\r\n        uint256 rTransferAmount;\r\n        uint256 rewardMarketingFee;\r\n        uint256 rewardDeveloperFee;\r\n        uint256 rewardEventFee;\r\n        uint256 rewardBitDuelServiceFee;\r\n    }\r\n\r\n    struct TokenValues {\r\n        uint256 tTransferAmount;\r\n        uint256 bitDuelServiceFee;\r\n        uint256 marketingFee;\r\n        uint256 developerFee;\r\n        uint256 eventFee;\r\n    }\r\n\r\n    /**\r\n    * @dev Retrieves the Reward equivalent of the given Token amount. (With the Fees optionally included or excluded.)\r\n    */\r\n    function rewardFromToken(uint256 tAmount, bool deductTransferFee) public view returns (uint256) {\r\n        require(tAmount <= _totalSupply, \"The amount must be less than the supply!\");\r\n\r\n        if (!deductTransferFee) {\r\n            uint256 currentRate = _getRate();\r\n            (TokenValues memory tv) = _getTokenValues(tAmount, address(0));\r\n            (RewardValues memory rv) = _getRewardValues(tAmount, tv, currentRate);\r\n\r\n            return rv.rAmount;\r\n        } else {\r\n            uint256 currentRate = _getRate();\r\n            (TokenValues memory tv) = _getTokenValues(tAmount, address(0));\r\n            (RewardValues memory rv) = _getRewardValues(tAmount, tv, currentRate);\r\n\r\n            return rv.rTransferAmount;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Retrieves the Token equivalent of the given Reward amount.\r\n    */\r\n    function tokenFromReward(uint256 rAmount) public view returns (uint256) {\r\n        require(rAmount <= _rewardSupply, \"The amount must be less than the total rewards!\");\r\n\r\n        uint256 currentRate = _getRate();\r\n        return rAmount.div(currentRate);\r\n    }\r\n\r\n    /**\r\n    * @dev Excludes an address from the Reward process.\r\n    */\r\n    function excludeFromReward(address account) public onlyOwner {\r\n        require(!_isExcluded[account], \"The account is already excluded!\");\r\n\r\n        if (_rewardOwned[account] > 0) {\r\n            _tokenOwned[account] = tokenFromReward(_rewardOwned[account]);\r\n        }\r\n        _isExcluded[account] = true;\r\n        _excluded.push(account);\r\n    }\r\n\r\n    /**\r\n    * @dev Includes an address in the Reward process.\r\n    */\r\n    function includeInReward(address account) external onlyOwner {\r\n        require(_isExcluded[account], \"The account is already included!\");\r\n\r\n        for (uint256 i = 0; i < _excluded.length; i++) {\r\n            if (_excluded[i] == account) {\r\n                _excluded[i] = _excluded[_excluded.length - 1];\r\n                _tokenOwned[account] = 0;\r\n                _isExcluded[account] = false;\r\n                _excluded.pop();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Retrieves the Total Fees deducted to date.\r\n    */\r\n    function totalFees() public view returns (uint256) {\r\n        return _feeTotal;\r\n    }\r\n\r\n    /**\r\n    * @dev Retrieves the Total Marketing Fees deducted to date.\r\n    */\r\n    function totalMarketingFees() public view returns (uint256) {\r\n        return _marketingFeeTotal;\r\n    }\r\n\r\n    /**\r\n    * @dev Retrieves the Total Event Fees deducted to date.\r\n    */\r\n    function totalEventFees() public view returns (uint256) {\r\n        return _eventFeeTotal;\r\n    }\r\n\r\n    /**\r\n    * @dev Retrieves the Total Development Fees deducted to date.\r\n    */\r\n    function totalDevelopmentFees() public view returns (uint256) {\r\n        return _developerFeeTotal;\r\n    }\r\n\r\n    /**\r\n    * @dev Retrieves the Total BitDuel Service Fees deducted to date.\r\n    */\r\n    function totalBitDuelServiceFees() public view returns (uint256) {\r\n        return _bitDuelServiceFeeTotal;\r\n    }\r\n\r\n    /**\r\n    * @dev Excludes an address from the Fee process.\r\n    */\r\n    function excludeFromFee(address account) public onlyOwner {\r\n        _isExcludedFromFee[account] = true;\r\n    }\r\n\r\n    /**\r\n    * @dev Includes an address in the Fee process.\r\n    */\r\n    function includeInFee(address account) public onlyOwner {\r\n        _isExcludedFromFee[account] = false;\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the given address as the Developer Wallet.\r\n    */\r\n    function setDevWallet(address devWallet) external onlyOwner {\r\n        address oldAddress = _devWallet;\r\n        _isExcludedFromFee[oldAddress] = false;\r\n        _devWallet = devWallet;\r\n        _isExcludedFromFee[_devWallet] = true;\r\n\r\n        emit DevWalletChanged(oldAddress, _devWallet);\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the given address as the Player Pool Hot Wallet.\r\n    */\r\n    function setPlayerPoolWallet(address playerPoolWallet) external onlyOwner {\r\n        address oldAddress = _playerPoolWallet;\r\n        _playerPoolWallet = playerPoolWallet;\r\n\r\n        emit PlayerPoolChanged(oldAddress, _playerPoolWallet);\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the Marketing Fee percentage.\r\n    */\r\n    function setMarketingFeePercent(uint256 marketingFee) external onlyOwner {\r\n        uint256 oldFee = _marketingFee;\r\n        _marketingFee = marketingFee;\r\n\r\n        emit MarketingFeeChanged(oldFee, _marketingFee);\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the Developer Fee percentage.\r\n    */\r\n    function setDeveloperFeePercent(uint256 developerFee) external onlyOwner {\r\n        uint256 oldFee = _developerFee;\r\n        _developerFee = developerFee;\r\n\r\n        emit DeveloperFeeChanged(oldFee, _developerFee);\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the BitDuel Service Fee percentage.\r\n    */\r\n    function setBitDuelServiceFeePercent(uint256 bitDuelServiceFee) external onlyOwner {\r\n        uint256 oldFee = _bitDuelServiceFee;\r\n        _bitDuelServiceFee = bitDuelServiceFee;\r\n\r\n        emit BitDuelServiceFeeChanged(oldFee, _bitDuelServiceFee);\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the Event Fee percentage.\r\n    */\r\n    function setEventFeePercent(uint256 eventFee) external onlyOwner {\r\n        uint256 oldFee = _eventFee;\r\n        _eventFee = eventFee;\r\n\r\n        emit EventFeeChanged(oldFee, _eventFee);\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the maximum transaction amount. (calculated by the given percentage)\r\n    */\r\n    function setMaxTxPercent(uint256 maxTxPercent) external onlyOwner {\r\n        uint256 oldAmount = _maxTxAmount;\r\n        _maxTxAmount = _totalSupply.mul(maxTxPercent).div(100);\r\n\r\n        emit MaxTransactionAmountChanged(oldAmount, _maxTxAmount);\r\n    }\r\n\r\n    /**\r\n    * @dev Retrieves if the given address is excluded from the Fee process.\r\n    */\r\n    function isExcludedFromFee(address account) public view returns (bool) {\r\n        return _isExcludedFromFee[account];\r\n    }\r\n\r\n    /**\r\n    * @dev Retrieves if the given address is excluded from the Reward process.\r\n    */\r\n    function isExcludedFromReward(address account) public view returns (bool) {\r\n        return _isExcluded[account];\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the given address as the Pancake Swap Router.\r\n    */\r\n    function setPancakeSwapRouter(address r) external onlyOwner {\r\n        address oldRouter = address(_pancakeSwapV2Router);\r\n        IPancakeRouter02 pancakeSwapV2Router = IPancakeRouter02(r);\r\n        _pancakeSwapV2Router = pancakeSwapV2Router;\r\n\r\n        emit PancakeRouterChanged(oldRouter, address(_pancakeSwapV2Router));\r\n    }\r\n\r\n    /**\r\n    * @dev Sets the given address as the Pancake Swap Pair.\r\n    */\r\n    function setPancakeSwapPair(address p) external onlyOwner {\r\n        address oldPair = _pancakeSwapV2Pair;\r\n        _pancakeSwapV2Pair = p;\r\n\r\n        emit PancakePairChanged(oldPair, _pancakeSwapV2Pair);\r\n    }\r\n\r\n    //\r\n    // The Implementation of the IBEP20 Functions\r\n    //\r\n\r\n    /**\r\n    * @dev Retrieves the Total Supply of the token.\r\n    */\r\n    function totalSupply() external pure override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n    * @dev Retrieves the Number of Decimal Points of the token.\r\n    */\r\n    function decimals() external pure override returns (uint8) {\r\n        return _tokenDecimals;\r\n    }\r\n\r\n    /**\r\n    * @dev Retrieves the Symbol of the token.\r\n    */\r\n    function symbol() external pure override returns (string memory) {\r\n        return _tokenSymbol;\r\n    }\r\n\r\n    /**\r\n    * @dev Retrieves the Name of the Token.\r\n    */\r\n    function name() external pure override returns (string memory) {\r\n        return _tokenName;\r\n    }\r\n\r\n    /**\r\n    * @dev Retrieves the Owner of the token.\r\n    */\r\n    function getOwner() external view override returns (address) {\r\n        return owner();\r\n    }\r\n\r\n    /**\r\n    * @dev Retrieves the Balance Of the given address.\r\n    * Note: If the address is included in the Reward process, retrieves the Token equivalent of the held Reward amount.\r\n    */\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        if (_isExcluded[account]) return _tokenOwned[account];\r\n        return tokenFromReward(_rewardOwned[account]);\r\n    }\r\n\r\n    /**\r\n    * @dev Transfers the given Amount of tokens (minus the fees, if any) from the\r\n    * Message Senders wallet to the Recipients wallet.\r\n    *\r\n    * Note: If the Recipient is the Player Pool Hot Wallet, the Message Sender will be able to play with\r\n    * the transferred amount of Tokens on BitDuel.\r\n    */\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        if (recipient == _playerPoolWallet) {\r\n            _playerPool[_msgSender()] += _transfer(_msgSender(), recipient, amount);\r\n        } else {\r\n            _transfer(_msgSender(), recipient, amount);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Retrieves the Allowance of the given Spender address in the given Owner wallet.\r\n    */\r\n    function allowance(address owner, address spender) external view override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n    * @dev Approves the given amount for the given Spender address in the Message Sender wallet.\r\n    */\r\n    function approve(address spender, uint256 amount) external override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfers the given Amount of tokens from the Sender to the Recipient address\r\n    * if the Sender approved on the Message Sender allowances.\r\n    */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"BEP20: The transfer amount exceeds the allowance.\"));\r\n        return true;\r\n    }\r\n\r\n    //\r\n    // Transfer and Approval processes\r\n    //\r\n\r\n    /**\r\n    * @dev Approves the given amount for the given Spender address in the Owner wallet.\r\n    */\r\n    function _approve(address owner, address spender, uint256 amount) private {\r\n        require(owner != address(0), \"BEP20: Cannot approve from the zero address.\");\r\n        require(spender != address(0), \"BEP20: Cannot approve to the zero address.\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers from and to the given address the given amount of token.\r\n     */\r\n    function _transfer(address from, address to, uint256 amount) private returns (uint256) {\r\n        require(from != address(0), \"BEP20: Cannot transfer from the zero address.\");\r\n        require(to != address(0), \"BEP20: Cannot transfer to the zero address.\");\r\n        require(amount > 0, \"The transfer amount must be greater than zero!\");\r\n\r\n        if (from != owner() && to != owner()) {\r\n            require(amount <= _maxTxAmount, \"The transfer amount exceeds the maxTxAmount.\");\r\n        }\r\n\r\n        bool takeFee = !(_isExcludedFromFee[from] || _isExcludedFromFee[to] || from == _playerPoolWallet);\r\n        return _tokenTransfer(from, to, amount, takeFee);\r\n    }\r\n\r\n    /**\r\n    * @dev Transfers the given Amount of tokens (minus the fees, if any) from the\r\n    * Senders wallet to the Recipients wallet.\r\n    */\r\n    function _tokenTransfer(address sender, address recipient, uint256 amount, bool takeFee) private returns (uint256) {\r\n        uint256 previousBitDuelServiceFee = _bitDuelServiceFee;\r\n        uint256 previousDeveloperFee = _developerFee;\r\n        uint256 previousEventFee = _eventFee;\r\n        uint256 previousMarketingFee = _marketingFee;\r\n\r\n        if (!takeFee) {\r\n            _bitDuelServiceFee = 0;\r\n            _developerFee = 0;\r\n            _eventFee = 0;\r\n            _marketingFee = 0;\r\n        }\r\n\r\n        uint256 transferredAmount;\r\n        if (_isExcluded[sender] && !_isExcluded[recipient]) {\r\n            transferredAmount = _transferFromExcluded(sender, recipient, amount);\r\n        } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\r\n            transferredAmount = _transferToExcluded(sender, recipient, amount);\r\n        } else if (_isExcluded[sender] && _isExcluded[recipient]) {\r\n            transferredAmount = _transferBothExcluded(sender, recipient, amount);\r\n        } else {\r\n            transferredAmount = _transferStandard(sender, recipient, amount);\r\n        }\r\n\r\n        if (!takeFee) {\r\n            _bitDuelServiceFee = previousBitDuelServiceFee;\r\n            _developerFee = previousDeveloperFee;\r\n            _eventFee = previousEventFee;\r\n            _marketingFee = previousMarketingFee;\r\n        }\r\n\r\n        return transferredAmount;\r\n    }\r\n\r\n    /**\r\n    * @dev The Transfer function used when both the Sender and Recipient is included in the Reward process.\r\n    */\r\n    function _transferStandard(address sender, address recipient, uint256 tAmount) private returns (uint256) {\r\n        uint256 currentRate = _getRate();\r\n        (TokenValues memory tv) = _getTokenValues(tAmount, recipient);\r\n        (RewardValues memory rv) = _getRewardValues(tAmount, tv, currentRate);\r\n\r\n        _rewardOwned[sender] = _rewardOwned[sender].sub(rv.rAmount);\r\n        _rewardOwned[recipient] = _rewardOwned[recipient].add(rv.rTransferAmount);\r\n\r\n        takeTransactionFee(_devWallet, tv, currentRate, recipient);\r\n        _rewardFee(rv);\r\n        _countTotalFee(tv);\r\n        emit Transfer(sender, recipient, tv.tTransferAmount);\r\n\r\n        return tv.tTransferAmount;\r\n    }\r\n\r\n    /**\r\n    * @dev The Transfer function used when both the Sender and Recipient is excluded from the Reward process.\r\n    */\r\n    function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private returns (uint256) {\r\n        uint256 currentRate = _getRate();\r\n        (TokenValues memory tv) = _getTokenValues(tAmount, recipient);\r\n        (RewardValues memory rv) = _getRewardValues(tAmount, tv, currentRate);\r\n\r\n        _tokenOwned[sender] = _tokenOwned[sender].sub(tAmount);\r\n        _rewardOwned[sender] = _rewardOwned[sender].sub(rv.rAmount);\r\n        _tokenOwned[recipient] = _tokenOwned[recipient].add(tv.tTransferAmount);\r\n        _rewardOwned[recipient] = _rewardOwned[recipient].add(rv.rTransferAmount);\r\n\r\n        takeTransactionFee(_devWallet, tv, currentRate, recipient);\r\n        _rewardFee(rv);\r\n        _countTotalFee(tv);\r\n        emit Transfer(sender, recipient, tv.tTransferAmount);\r\n\r\n        return tv.tTransferAmount;\r\n    }\r\n\r\n    /**\r\n    * @dev The Transfer function used when the Sender is included and the Recipient is excluded in / from the Reward process.\r\n    */\r\n    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private returns (uint256) {\r\n        uint256 currentRate = _getRate();\r\n        (TokenValues memory tv) = _getTokenValues(tAmount, recipient);\r\n        (RewardValues memory rv) = _getRewardValues(tAmount, tv, currentRate);\r\n\r\n        _rewardOwned[sender] = _rewardOwned[sender].sub(rv.rAmount);\r\n        _tokenOwned[recipient] = _tokenOwned[recipient].add(tv.tTransferAmount);\r\n        _rewardOwned[recipient] = _rewardOwned[recipient].add(rv.rTransferAmount);\r\n\r\n        takeTransactionFee(_devWallet, tv, currentRate, recipient);\r\n        _rewardFee(rv);\r\n        _countTotalFee(tv);\r\n        emit Transfer(sender, recipient, tv.tTransferAmount);\r\n\r\n        return tv.tTransferAmount;\r\n    }\r\n\r\n    /**\r\n    * @dev The Transfer function used when the Sender is excluded and the Recipient is included from / in the Reward process.\r\n    */\r\n    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private returns (uint256) {\r\n        uint256 currentRate = _getRate();\r\n        (TokenValues memory tv) = _getTokenValues(tAmount, recipient);\r\n        (RewardValues memory rv) = _getRewardValues(tAmount, tv, currentRate);\r\n\r\n        _tokenOwned[sender] = _tokenOwned[sender].sub(tAmount);\r\n        _rewardOwned[sender] = _rewardOwned[sender].sub(rv.rAmount);\r\n        _rewardOwned[recipient] = _rewardOwned[recipient].add(rv.rTransferAmount);\r\n\r\n        takeTransactionFee(_devWallet, tv, currentRate, recipient);\r\n        _rewardFee(rv);\r\n        _countTotalFee(tv);\r\n        emit Transfer(sender, recipient, tv.tTransferAmount);\r\n\r\n        return tv.tTransferAmount;\r\n    }\r\n\r\n    /**\r\n    * @dev Takes the Reward Fees from the Reward Supply.\r\n    */\r\n    function _rewardFee(RewardValues memory rv) private {\r\n        _rewardSupply = _rewardSupply.sub(rv.rewardMarketingFee).sub(rv.rewardDeveloperFee).sub(rv.rewardEventFee).sub(rv.rewardBitDuelServiceFee);\r\n    }\r\n\r\n    /**\r\n    * @dev Updates the Fee Counters by the Taken Fees.\r\n    */\r\n    function _countTotalFee(TokenValues memory tv) private {\r\n        _marketingFeeTotal = _marketingFeeTotal.add(tv.marketingFee);\r\n        _developerFeeTotal = _developerFeeTotal.add(tv.developerFee);\r\n        _eventFeeTotal = _eventFeeTotal.add(tv.eventFee);\r\n        _bitDuelServiceFeeTotal = _bitDuelServiceFeeTotal.add(tv.bitDuelServiceFee);\r\n        _feeTotal = _feeTotal.add(tv.marketingFee).add(tv.developerFee).add(tv.eventFee).add(tv.bitDuelServiceFee);\r\n    }\r\n\r\n    /**\r\n    * @dev Calculates the Token Values after taking the Fees.\r\n    */\r\n    function _getTokenValues(uint256 tAmount, address recipient) private view returns (TokenValues memory) {\r\n        TokenValues memory tv;\r\n        uint256 tTransferAmount = tAmount;\r\n\r\n        if (recipient == _playerPoolWallet) {\r\n            uint256 bitDuelServiceFee = tAmount.mul(_bitDuelServiceFee).div(10000);\r\n            tTransferAmount = tTransferAmount.sub(bitDuelServiceFee);\r\n\r\n            tv.tTransferAmount = tTransferAmount;\r\n            tv.bitDuelServiceFee = bitDuelServiceFee;\r\n\r\n            return (tv);\r\n        }\r\n\r\n        uint256 marketingFee = tAmount.mul(_marketingFee).div(10000);\r\n        uint256 developerFee = tAmount.mul(_developerFee).div(10000);\r\n        uint256 eventFee = tAmount.mul(_eventFee).div(10000);\r\n        tTransferAmount = tTransferAmount.sub(marketingFee).sub(developerFee).sub(eventFee);\r\n\r\n        tv.tTransferAmount = tTransferAmount;\r\n        tv.marketingFee = marketingFee;\r\n        tv.developerFee = developerFee;\r\n        tv.eventFee = eventFee;\r\n\r\n        return (tv);\r\n    }\r\n\r\n    /**\r\n    * @dev Calculates the Reward Values after taking the Fees.\r\n    */\r\n    function _getRewardValues(uint256 tAmount, TokenValues memory tv, uint256 currentRate) private pure returns (RewardValues memory) {\r\n        RewardValues memory rv;\r\n\r\n        uint256 rAmount = tAmount.mul(currentRate);\r\n        uint256 rewardBitDuelServiceFee = tv.bitDuelServiceFee.mul(currentRate);\r\n        uint256 rewardMarketingFee = tv.marketingFee.mul(currentRate);\r\n        uint256 rewardDeveloperFee = tv.developerFee.mul(currentRate);\r\n        uint256 rewardEventFee = tv.eventFee.mul(currentRate);\r\n        uint256 rTransferAmount = rAmount.sub(rewardMarketingFee).sub(rewardDeveloperFee).sub(rewardEventFee).sub(rewardBitDuelServiceFee);\r\n\r\n        rv.rAmount = rAmount;\r\n        rv.rTransferAmount = rTransferAmount;\r\n        rv.rewardBitDuelServiceFee = rewardBitDuelServiceFee;\r\n        rv.rewardMarketingFee = rewardMarketingFee;\r\n        rv.rewardDeveloperFee = rewardDeveloperFee;\r\n        rv.rewardEventFee = rewardEventFee;\r\n\r\n        return (rv);\r\n    }\r\n\r\n    /**\r\n    * @dev Retrieves the Rate between the Reward and Token Supply.\r\n    */\r\n    function _getRate() private view returns (uint256) {\r\n        (uint256 rewardSupply, uint256 tokenSupply) = _getCurrentSupply();\r\n        return rewardSupply.div(tokenSupply);\r\n    }\r\n\r\n    /**\r\n    * @dev Retrieves the current Reward and Token Supply.\r\n    */\r\n    function _getCurrentSupply() private view returns (uint256, uint256) {\r\n        uint256 rewardSupply = _rewardSupply;\r\n        uint256 tokenSupply = _totalSupply;\r\n        for (uint256 i = 0; i < _excluded.length; i++) {\r\n            if (_rewardOwned[_excluded[i]] > rewardSupply || _tokenOwned[_excluded[i]] > tokenSupply) return (_rewardSupply, _totalSupply);\r\n            rewardSupply = rewardSupply.sub(_rewardOwned[_excluded[i]]);\r\n            tokenSupply = tokenSupply.sub(_tokenOwned[_excluded[i]]);\r\n        }\r\n        if (rewardSupply < _rewardSupply.div(_totalSupply)) return (_rewardSupply, _totalSupply);\r\n        return (rewardSupply, tokenSupply);\r\n    }\r\n\r\n    /**\r\n    * @dev Takes the given Fees.\r\n    */\r\n    function takeTransactionFee(address to, TokenValues memory tv, uint256 currentRate, address recipient) private {\r\n        uint256 totalFee = recipient == _playerPoolWallet ? (tv.bitDuelServiceFee) : (tv.marketingFee + tv.developerFee + tv.eventFee);\r\n\r\n        if (totalFee <= 0) {return;}\r\n\r\n        uint256 rAmount = totalFee.mul(currentRate);\r\n        _rewardOwned[to] = _rewardOwned[to].add(rAmount);\r\n        if (_isExcluded[to]) {\r\n            _tokenOwned[to] = _tokenOwned[to].add(totalFee);\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"devWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"playerPoolWallet\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"BitDuelServiceFeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"DevWalletChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"DeveloperFeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"EventFeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"FallBack\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"MarketingFeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"MaxTransactionAmountChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"moduleAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"moduleName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"moduleVersion\",\"type\":\"string\"}],\"name\":\"ModuleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"moduleName\",\"type\":\"string\"}],\"name\":\"ModuleRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"PancakePairChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"PancakeRouterChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"PlayerPoolChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Received\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"_bitDuelServiceFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_devWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_developerFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_eventFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_marketingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_pancakeSwapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_pancakeSwapV2Router\",\"outputs\":[{\"internalType\":\"contract IPancakeRouter02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_playerPoolWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"moduleName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"moduleVersion\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"moduleAddress\",\"type\":\"address\"}],\"name\":\"addModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddress\",\"type\":\"address\"}],\"name\":\"balanceInPlayerPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"moduleName\",\"type\":\"string\"}],\"name\":\"getModule\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"moduleName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"moduleVersion\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"moduleAddress\",\"type\":\"address\"}],\"internalType\":\"struct Avara.Module\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ping\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"previousOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"moduleName\",\"type\":\"string\"}],\"name\":\"removeModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"deductTransferFee\",\"type\":\"bool\"}],\"name\":\"rewardFromToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bitDuelServiceFee\",\"type\":\"uint256\"}],\"name\":\"setBitDuelServiceFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"devWallet\",\"type\":\"address\"}],\"name\":\"setDevWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"developerFee\",\"type\":\"uint256\"}],\"name\":\"setDeveloperFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eventFee\",\"type\":\"uint256\"}],\"name\":\"setEventFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketingFee\",\"type\":\"uint256\"}],\"name\":\"setMarketingFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxTxPercent\",\"type\":\"uint256\"}],\"name\":\"setMaxTxPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"p\",\"type\":\"address\"}],\"name\":\"setPancakeSwapPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"r\",\"type\":\"address\"}],\"name\":\"setPancakeSwapRouter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"setPlayerBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerPoolWallet\",\"type\":\"address\"}],\"name\":\"setPlayerPoolWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rAmount\",\"type\":\"uint256\"}],\"name\":\"tokenFromReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBitDuelServiceFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDevelopmentFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalEventFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalMarketingFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Avara", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c46663771f01bc83d77a4e5cce4cb07e00fbcf7300000000000000000000000028c9fbf3bc6db37965e49ca485e89f27bb513b3700000000000000000000000027ac0d87dbfd124701a4f9d9c9f11c15be8d9249", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU AGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a77ebf080b5bf4e32808d544fe1e96b8e55750b233a94e27c67c7f30191018b6"}