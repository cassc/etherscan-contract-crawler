{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\ninterface IERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    ) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\nabstract contract Ownable {\r\n    address private _owner;\r\n\r\n    error NotOwner();\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    modifier onlyOwner() {\r\n        if (msg.sender != _owner) revert NotOwner();\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\nlibrary ERC20Helper {\r\n    error SafeTransferFailed();\r\n    error SafeTransferFromFailed();\r\n\r\n    function safeTransfer(address token, address to, uint256 amount) internal {\r\n        bool success;\r\n        bytes4 selector = 0xa9059cbb; // IERC20.transfer.selector\r\n        assembly {\r\n            let data := mload(0x40)\r\n            mstore(data, selector)\r\n            mstore(add(data, 0x04), to)\r\n            mstore(add(data, 0x24), amount)\r\n            success := call(gas(), token, 0, data, 0x44, 0x0, 0x20)\r\n            if success {\r\n                switch returndatasize()\r\n                case 0 {\r\n                    success := gt(extcodesize(token), 0)\r\n                }\r\n                default {\r\n                    success := and(gt(returndatasize(), 31), eq(mload(0), 1))\r\n                }\r\n            }\r\n        }\r\n        if (!success) revert SafeTransferFailed();\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bytes4 selector = 0x23b872dd; // IERC20.transferFrom.selector\r\n        bool success;\r\n        assembly {\r\n            let data := mload(0x40)\r\n            mstore(data, selector)\r\n            mstore(add(data, 0x04), from)\r\n            mstore(add(data, 0x24), to)\r\n            mstore(add(data, 0x44), amount)\r\n            success := call(gas(), token, 0, data, 100, 0x0, 0x20)\r\n            if success {\r\n                switch returndatasize()\r\n                case 0 {\r\n                    success := gt(extcodesize(token), 0)\r\n                }\r\n                default {\r\n                    success := and(gt(returndatasize(), 31), eq(mload(0), 1))\r\n                }\r\n            }\r\n        }\r\n        if (!success) revert SafeTransferFromFailed();\r\n    }\r\n}\r\n\r\ncontract Staking is Ownable {\r\n    struct IndexInfo {\r\n        uint256 totalDeposits;\r\n        uint256 totalRewards;\r\n        uint256 rewardPerShare;\r\n        uint256 blockExecution;\r\n    }\r\n\r\n    struct UserInfo {\r\n        uint256 totalDeposit;\r\n        uint256 totalReward;\r\n        uint256 lastIndex;\r\n    }\r\n\r\n    mapping(address => UserInfo) private _users;\r\n    mapping(uint256 => IndexInfo) private _indexes;\r\n\r\n    address private immutable _stakingToken;\r\n    address private immutable _rewardToken;\r\n\r\n    uint256 private _totalDeposits;\r\n    uint256 private _totalRewards;\r\n    uint256 private _totalRewardsDebt;\r\n    uint256 private _indexesLength;\r\n\r\n    uint256 private constant _DECIMALS_FACTOR = 1e18;\r\n\r\n    event Deposit(address indexed account, uint256 amount);\r\n    event Withdraw(address indexed account, uint256 amount);\r\n    event Claim(address indexed account, uint256 amount);\r\n    event CreateIndex(uint256 indexed id);\r\n\r\n    constructor(\r\n        address owner_,\r\n        address stakingToken_,\r\n        address rewardToken_\r\n    ) payable {\r\n        transferOwnership(owner_);\r\n        _stakingToken = stakingToken_;\r\n        _rewardToken = rewardToken_;\r\n    }\r\n\r\n    /**\r\n     * @dev Get the configuration of the smart contract.\r\n     */\r\n    function getConfig()\r\n        external\r\n        view\r\n        returns (\r\n            address stakingToken,\r\n            address rewardToken,\r\n            uint256 totalDeposits,\r\n            uint256 totalRewards,\r\n            uint256 totalRewardsDebt,\r\n            uint256 indexesLength\r\n        )\r\n    {\r\n        stakingToken = _stakingToken;\r\n        rewardToken = _rewardToken;\r\n        totalDeposits = _totalDeposits;\r\n        totalRewards = _totalRewards;\r\n        totalRewardsDebt = _totalRewardsDebt;\r\n        indexesLength = _indexesLength;\r\n    }\r\n\r\n    /**\r\n     * @dev Get user information.\r\n     */\r\n    function getUser(address account) external view returns (UserInfo memory) {\r\n        return _users[account];\r\n    }\r\n\r\n    /**\r\n     * @dev Get indexes information.\r\n     */\r\n    function getIndexes(\r\n        uint256[] calldata ids\r\n    ) external view returns (IndexInfo[] memory info) {\r\n        info = new IndexInfo[](ids.length);\r\n        for (uint256 i; i < ids.length; i++) {\r\n            info[i] = _indexes[ids[i]];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get the reward that awaits the user after creating new indexes.\r\n     */\r\n    function getPendingReward(address account) public view returns (uint256) {\r\n        if (_users[account].lastIndex == 0) return 0;\r\n        uint256 _pendingReward;\r\n        for (\r\n            uint256 i = _users[account].lastIndex;\r\n            i < _indexesLength + 1;\r\n            i++\r\n        ) {\r\n            _pendingReward +=\r\n                (_users[account].totalDeposit * _indexes[i].rewardPerShare) /\r\n                _DECIMALS_FACTOR;\r\n        }\r\n        return _pendingReward;\r\n    }\r\n\r\n    /**\r\n     * @dev Increasing deposit with variable updates and collecting rewards.\r\n     */\r\n    function deposit(uint256 amount_) external {\r\n        _claim();\r\n        if (amount_ > 0) _deposit(amount_);\r\n    }\r\n\r\n    /**\r\n     * @dev Decreasing deposit with variable updates and collecting rewards.\r\n     */\r\n    function withdraw(uint256 amount_) external {\r\n        _claim();\r\n        if (amount_ > 0) _withdraw(amount_);\r\n    }\r\n\r\n    /**\r\n     * @dev Only collecting the rewards.\r\n     */\r\n    function claim() external {\r\n        _claim();\r\n    }\r\n\r\n    function _claim() private {\r\n        uint256 _pendingReward = getPendingReward(msg.sender);\r\n        _users[msg.sender].lastIndex = _indexesLength + 1;\r\n        if (_pendingReward > 0) {\r\n            _users[msg.sender].totalReward += _pendingReward;\r\n            _totalRewardsDebt -= _pendingReward;\r\n            ERC20Helper.safeTransfer(_rewardToken, msg.sender, _pendingReward);\r\n            emit Claim(msg.sender, _pendingReward);\r\n        }\r\n    }\r\n\r\n    function _deposit(uint256 amount_) private {\r\n        ERC20Helper.safeTransferFrom(\r\n            _stakingToken,\r\n            msg.sender,\r\n            address(this),\r\n            amount_\r\n        );\r\n        _totalDeposits += amount_;\r\n        _users[msg.sender].totalDeposit += amount_;\r\n        emit Deposit(msg.sender, amount_);\r\n    }\r\n\r\n    function _withdraw(uint256 amount_) private {\r\n        _totalDeposits -= amount_;\r\n        _users[msg.sender].totalDeposit -= amount_;\r\n        ERC20Helper.safeTransfer(_stakingToken, msg.sender, amount_);\r\n        emit Withdraw(msg.sender, amount_);\r\n    }\r\n\r\n    /**\r\n     * @dev Creating a new index by the owner.\r\n     */\r\n    function createIndex() external onlyOwner {\r\n        _indexesLength++;\r\n        uint256 totalRewards_ = IERC20(_rewardToken).balanceOf(address(this)) -\r\n            _totalRewardsDebt;\r\n        _indexes[_indexesLength] = IndexInfo(\r\n            _totalDeposits,\r\n            totalRewards_,\r\n            (totalRewards_ * _DECIMALS_FACTOR) / _totalDeposits,\r\n            block.number\r\n        );\r\n        _totalRewards += totalRewards_;\r\n        _totalRewardsDebt += totalRewards_;\r\n        emit CreateIndex(_indexesLength);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"stakingToken_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardToken_\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"NotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeTransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeTransferFromFailed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"CreateIndex\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createIndex\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getConfig\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"stakingToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRewardsDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"indexesLength\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"getIndexes\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalDeposits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockExecution\",\"type\":\"uint256\"}],\"internalType\":\"struct Staking.IndexInfo[]\",\"name\":\"info\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getPendingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getUser\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct Staking.UserInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Staking", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000dcda94969127703ca3eb48cfa881a00593d95fbd00000000000000000000000027c019aa33f0f7ed2ec7f135e1c6b1a6deef198c00000000000000000000000055d398326f99059ff775485246999027b3197955", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://44ec36380de7f2e4de9904c475e65d214c483d79acee74893905651106bc2965"}