{"SourceCode": "/**\r\n *Submitted for verification at BscScan.com on 2023-11-17\r\n*/\r\n\r\n/**\r\n *Submitted for verification at basescan.org on 2023-08-05\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.16;\r\n\r\ninterface IBEP20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n   \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\ninterface AggregatorV3Interface {\r\n  function decimals() external view returns (uint8);\r\n\r\n  function description() external view returns (string memory);\r\n\r\n  function version() external view returns (uint256);\r\n\r\n  function getRoundData(\r\n    uint80 _roundId\r\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\r\n\r\n  function latestRoundData()\r\n    external\r\n    view\r\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\r\n}\r\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\ncontract PresaleBTCHALVING is ReentrancyGuard{\r\n    uint256 public totalTokensSold;\r\n    uint256 public startTime;\r\n    uint256 public endTime;\r\n    IBEP20 public saleToken;\r\n    IBEP20 public USDTInterface;\r\n    mapping(address => uint256) public commitments;\r\n    mapping(address => uint256) public missedEmissions;\r\n    uint256 public totalCommitments;\r\n    AggregatorV3Interface public priceFeed;\r\n    uint256 public TokenperUSDT;\r\n    address public owner;\r\n    constructor(\r\n        uint256 _startTime,\r\n        uint256 _endTime,\r\n        address _saleToken,\r\n        uint256 _TokenperUSDT\r\n    ){\r\n        require(\r\n            _startTime >= block.timestamp,\r\n            \"Start time must be in the future.\"\r\n        );\r\n        require(\r\n            _endTime > _startTime,\r\n            \"End time must be greater than start time.\"\r\n        );\r\n        startTime = _startTime;\r\n        endTime = _endTime;\r\n        saleToken = IBEP20(_saleToken);\r\n        USDTInterface = IBEP20(0x55d398326f99059fF775485246999027B3197955);\r\n        priceFeed = AggregatorV3Interface(0x0567F2323251f0Aab15c8dFb1967E4e8A7D42aeE);\r\n        TokenperUSDT = _TokenperUSDT;\r\n        owner = msg.sender;\r\n    }\r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    function getLatestPrice() public view returns (uint256) {\r\n        (\r\n            uint80 roundID, \r\n            int price,\r\n            uint startedAt,\r\n            uint timeStamp,\r\n            uint80 answeredInRound\r\n        ) = priceFeed.latestRoundData();\r\n        return uint256(price* (10 ** 10));\r\n    }\r\n    function calculatePrice(uint256 _amount) public view returns (uint256){\r\n        uint256 USDTAmount;\r\n        USDTAmount = (_amount*getLatestPrice())/(10**18);\r\n        return USDTAmount;\r\n    }\r\n    function buyHelper(uint256 _amount) public view returns (uint256){\r\n        uint256 TokenAmount;\r\n        TokenAmount = _amount*TokenperUSDT;\r\n        return  TokenAmount;\r\n    }\r\n    function buyWithBNB() external payable nonReentrant returns (bool) {\r\n        require(block.timestamp >= startTime && block.timestamp <= endTime, 'Invalid time for buying');\r\n        commitments[msg.sender] += calculatePrice(msg.value);\r\n        missedEmissions[msg.sender] += calculatePrice(msg.value)*TokenperUSDT;\r\n        totalCommitments += calculatePrice(msg.value);\r\n        totalTokensSold += calculatePrice(msg.value)*TokenperUSDT;\r\n        saleToken.transfer(msg.sender, calculatePrice(msg.value)*TokenperUSDT);\r\n        return true;\r\n    }\r\n    function buyWithUSDT(uint256 _amount) external nonReentrant returns (bool) {\r\n        require(block.timestamp >= startTime && block.timestamp <= endTime, 'Invalid time for buying');\r\n        USDTInterface.transferFrom(msg.sender, address(this), _amount);\r\n        commitments[msg.sender] += _amount;\r\n        missedEmissions[msg.sender] += _amount*TokenperUSDT;\r\n        totalCommitments += _amount;\r\n        totalTokensSold += _amount*TokenperUSDT;\r\n        saleToken.transfer(msg.sender, _amount*TokenperUSDT);\r\n        return true;\r\n    }\r\n    function changeSaleTimes(uint256 _startTime, uint256 _endTime) external onlyOwner {\r\n        require(_startTime > 0 || _endTime > 0, 'Invalid parameters');\r\n        if (_startTime > 0) {\r\n            require(block.timestamp < startTime, 'Sale already started');\r\n            require(block.timestamp < _startTime, 'Sale time in past');\r\n            startTime = _startTime;\r\n        }\r\n        if (_endTime > 0) {\r\n            require(_endTime > startTime, 'Invalid endTime');\r\n            endTime = _endTime;\r\n        }\r\n    }\r\n    function changeowner(address _newowner) external onlyOwner{\r\n        owner = _newowner;\r\n    }\r\n    function changesaleToken(address _newToken) external onlyOwner{\r\n        saleToken = IBEP20(_newToken);\r\n    }\r\n    function changeTokenperUSDT(uint256 _value) external onlyOwner{\r\n        TokenperUSDT = _value;\r\n    }\r\n    function withdrawBNB() external onlyOwner{\r\n        (bool success, ) = owner.call{\r\n                value: address(this).balance\r\n            }(\"\");\r\n            require(success, \"Failed to transfer ether\");\r\n    }\r\n    function withdrawUSDT() external onlyOwner{\r\n        USDTInterface.transfer(owner, USDTInterface.balanceOf(address(this)));\r\n    }\r\n    function withdrawToken() external onlyOwner{\r\n        saleToken.transfer(owner, saleToken.balanceOf(address(this)));\r\n    }\r\n    receive() external payable {}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endTime\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_saleToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_TokenperUSDT\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"TokenperUSDT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDTInterface\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"buyHelper\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyWithBNB\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"buyWithUSDT\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"calculatePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endTime\",\"type\":\"uint256\"}],\"name\":\"changeSaleTimes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"changeTokenperUSDT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newowner\",\"type\":\"address\"}],\"name\":\"changeowner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newToken\",\"type\":\"address\"}],\"name\":\"changesaleToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"commitments\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLatestPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"missedEmissions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceFeed\",\"outputs\":[{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleToken\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalCommitments\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTokensSold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawBNB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawUSDT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "PresaleBTCHALVING", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000006564c4bc00000000000000000000000000000000000000000000000000000000656767bc0000000000000000000000001931fac6e0775ed59d2fbf203ff45f4692d866560000000000000000000000000000000000000000000000000000000000000014", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6517b777dbc274f704502ceea56c30498b2b4f3331e1f4788f8f680eacc69f2d"}