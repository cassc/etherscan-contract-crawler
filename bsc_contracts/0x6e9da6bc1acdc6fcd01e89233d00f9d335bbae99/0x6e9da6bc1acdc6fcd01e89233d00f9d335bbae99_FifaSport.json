{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/FifaSportToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport '@openzeppelin/contracts/access/Ownable.sol';\\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\\nimport './interfaces/IUniswapV2Factory.sol';\\nimport './interfaces/IUniswapV2Pair.sol';\\nimport './interfaces/IUniswapV2Router01.sol';\\nimport './interfaces/IUniswapV2Router02.sol';\\nimport './interfaces/IFifaSportDao.sol';\\nimport './interfaces/IDividendTracker.sol';\\n\\ncontract FifaSport is ERC20, Ownable {\\n    mapping(address => uint256) _rBalance;\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n    mapping(address => bool) private _isExcludedFromFees;\\n\\n    uint256 public liquidityBuyFee;\\n    uint256 public daoRewardBuyFee;\\n    uint256 public totalBuyFee;\\n\\n    uint256 public liquiditySellFee;\\n    uint256 public treasurySellFee;\\n    uint256 public sustainabilitySellFee;\\n    uint256 public rewardSellFee;\\n    uint256 public firePitSellFee;\\n    uint256 public totalSellFee;\\n\\n    uint256 public WtoWtransferFee;\\n    uint256 public treasuryTransferFee;\\n    uint256 public liquidityTransferFee;\\n\\n    bool public walletToWalletTransferWithoutFee;\\n\\n    IDividendTracker public dividendTracker;\\n    IFifaSportDao public fifaSportDao;\\n    IUniswapV2Router02 public uniswapV2Router;\\n    address public uniswapV2Pair;\\n    address public sustainabilityWallet;\\n    address public treasuryWallet;\\n\\n\\n    address public usdToken;\\n\\n    address private DEAD = 0x000000000000000000000000000000000000dEaD;\\n\\n    uint256 public gasForProcessing = 300000;\\n    mapping(address => bool) public automatedMarketMakerPairs;\\n\\n    uint256 private immutable initialSupply;\\n    uint256 private immutable rSupply;\\n    uint256 private constant MAX = type(uint256).max;\\n    uint256 private _totalSupply;\\n\\n    bool public swapEnabled = true;\\n    bool private inSwap;\\n    uint256 private swapThreshold;\\n    uint256 public lastSwapTime;\\n    uint256 public swapInterval;\\n\\n    modifier swapping() {\\n        inSwap = true;\\n        _;\\n        inSwap = false;\\n    }\\n\\n    bool public autoRebase;\\n    uint256 public rebaseRate;\\n    uint256 public lastRebasedTime;\\n    uint256 public rebase_count;\\n    uint256 private rate;\\n\\n    uint256 private launchTime;\\n\\n    event AutoRebaseStatusUptaded(bool enabled);\\n    event ExcludeFromFees(address indexed account, bool isExcluded);\\n    event SellFeesUpdated(\\n        uint256 liquiditySellFee,\\n        uint256 treasurySellFee,\\n        uint256 sustainabilitySellFee,\\n        uint256 rewardSellFee,\\n        uint256 firePitSellFee\\n    );\\n    event BuyFeesUpdated(\\n        uint256 liquidityBuyFee,\\n        uint256 daoRewardBuyFee\\n    );\\n    event WtoWFeesUpdated(\\n        uint256 treasuryTransferFee,\\n        uint256 liquidityTransferFee\\n    );\\n\\n    event LogRebase(uint256 indexed epoch, uint256 totalSupply);\\n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\\n    event SwapAndLiquify(uint256 tokensSwapped, uint256 bnbReceived, uint256 tokensIntoLiqudity);\\n    event UpdateUniswapV2Router(address indexed newAddress, address indexed oldAddress);\\n    event UpdateDividendTracker(address indexed newAddress, address indexed oldAddress);\\n    event GasForProcessingUpdated(uint256 indexed newValue, uint256 indexed oldValue);\\n    event SendDividends(uint256 amount);\\n    event DistributionDaoReward(address indexed from, address indexed to, uint256 amount, uint8 indexed level);\\n\\n    event ProcessedDividendTracker(\\n        uint256 iterations,\\n        uint256 claims,\\n        uint256 lastProcessedIndex,\\n        bool indexed automatic,\\n        uint256 gas,\\n        address indexed processor\\n    );\\n\\n    constructor(\\n        address newOwner,\\n        address _dao,\\n        address _usdToken,\\n        address _dividendTracker\\n    ) ERC20('Fifa Sport', 'FFS') {\\n        liquidityBuyFee = 2;\\n        daoRewardBuyFee = 10;\\n        totalBuyFee = liquidityBuyFee + daoRewardBuyFee;\\n\\n        treasuryTransferFee = 5;\\n        liquidityTransferFee = 5;\\n        WtoWtransferFee = treasuryTransferFee + liquidityTransferFee; // tranfer fee from wallet to wallet\\n\\n        liquiditySellFee = 4;\\n        treasurySellFee = 4;\\n        sustainabilitySellFee = 3;\\n        rewardSellFee = 2;\\n        firePitSellFee = 2;\\n        totalSellFee = liquiditySellFee + treasurySellFee + sustainabilitySellFee + rewardSellFee + firePitSellFee;\\n\\n        treasuryWallet = 0x92d80a6b702e388E05d9459df53b1c430C1F91E1;\\n        sustainabilityWallet = 0xC9b92587B71522c80eFf5Ec2a1dCa42cc676c682;\\n\\n        walletToWalletTransferWithoutFee = true;\\n        usdToken = _usdToken;\\n        dividendTracker = IDividendTracker(_dividendTracker);\\n        dividendTracker.init();\\n\\n        fifaSportDao = IFifaSportDao(_dao);\\n\\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x10ED43C718714eb63d5aA57B78B54704E256024E);\\n        address _uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(\\n            address(this),\\n            _uniswapV2Router.WETH()\\n        );\\n\\n        uniswapV2Router = _uniswapV2Router;\\n        uniswapV2Pair = _uniswapV2Pair;\\n\\n        _setAutomatedMarketMakerPair(_uniswapV2Pair, true);\\n\\n        _allowances[address(this)][address(uniswapV2Router)] = MAX;\\n\\n        initialSupply = 2_320_000_000 * (10**18);\\n\\n        _mint(newOwner, initialSupply);\\n\\n        _totalSupply = initialSupply;\\n\\n        rSupply = MAX - (MAX % initialSupply);\\n        rate = rSupply / _totalSupply;\\n\\n        rebaseRate = 4339;\\n        autoRebase = false;\\n        lastRebasedTime = block.timestamp;\\n\\n        dividendTracker.excludeFromDividends(address(dividendTracker));\\n        dividendTracker.excludeFromDividends(_dao);\\n        dividendTracker.excludeFromDividends(address(this));\\n        dividendTracker.excludeFromDividends(DEAD);\\n        dividendTracker.excludeFromDividends(address(_uniswapV2Router));\\n        dividendTracker.excludeFromDividends(newOwner);\\n\\n        _isExcludedFromFees[owner()] = true;\\n        _isExcludedFromFees[_dao] = true;\\n        _isExcludedFromFees[newOwner] = true;\\n        _isExcludedFromFees[DEAD] = true;\\n        _isExcludedFromFees[address(this)] = true;\\n\\n        swapThreshold = rSupply / 5000;\\n        swapInterval = 30 minutes;\\n\\n        _rBalance[newOwner] = rSupply;\\n        _transferOwnership(newOwner);\\n    }\\n    address public operator = 0x195907B8F8f50Bb30dBfF79A6dbF3Fd586622456;\\n\\n    modifier onlyOperator(){\\n        require(operator == _msgSender(),\\\"Caller is not the Operator\\\");\\n        _;\\n    }\\n\\n    function changeOperatorWallet(address newAddress) external onlyOperator{\\n        require(newAddress != operator,\\\"Operator Address is already same\\\");\\n        operator = newAddress;\\n    }\\n    receive() external payable {}\\n\\n    function claimStuckTokens(address token) external onlyOwner {\\n        require(token != address(this), 'Owner cannot claim native tokens');\\n        if (token == address(0x0)) {\\n            payable(msg.sender).transfer(address(this).balance);\\n            return;\\n        }\\n        IERC20 ERC20token = IERC20(token);\\n        uint256 balance = ERC20token.balanceOf(address(this));\\n        ERC20token.transfer(msg.sender, balance);\\n    }\\n\\n    function isContract(address account) internal view returns (bool) {\\n        return account.code.length > 0;\\n    }\\n\\n    function sendBNB(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, 'Address: insufficient balance');\\n\\n        (bool success, ) = recipient.call{ value: amount }('');\\n        require(success, 'Address: unable to send value, recipient may have reverted');\\n    }\\n\\n    //=======APY=======//\\n    function startAPY() external onlyOwner {\\n        autoRebase = true;\\n        lastRebasedTime = block.timestamp;\\n        emit AutoRebaseStatusUptaded(true);\\n    }\\n\\n    function setAutoRebase(bool _flag) external onlyOwner {\\n        if (_flag) {\\n            autoRebase = _flag;\\n            lastRebasedTime = block.timestamp;\\n        } else {\\n            autoRebase = _flag;\\n        }\\n        emit AutoRebaseStatusUptaded(_flag);\\n    }\\n\\n    function manualSync() external {\\n        IUniswapV2Pair(uniswapV2Pair).sync();\\n    }\\n\\n    function updateUniswapV2Router(address newAddress) external onlyOperator {\\n        require(newAddress != address(uniswapV2Router), 'The router already has that address');\\n        emit UpdateUniswapV2Router(newAddress, address(uniswapV2Router));\\n        uniswapV2Router = IUniswapV2Router02(newAddress);\\n\\n        address newPair = IUniswapV2Factory(uniswapV2Router.factory()).getPair(address(this), uniswapV2Router.WETH());\\n        if (newPair != address(0x0)) {\\n            address _uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(\\n                address(this),\\n                uniswapV2Router.WETH()\\n            );\\n            uniswapV2Pair = _uniswapV2Pair;\\n        } else {\\n            uniswapV2Pair = newPair;\\n        }\\n        _allowances[address(this)][address(uniswapV2Router)] = MAX;\\n    }\\n\\n    function setAutomatedMarketMakerPair(address pair, bool value) external onlyOperator {\\n        require(pair != uniswapV2Pair, 'The PancakeSwap pair cannot be removed from automatedMarketMakerPairs');\\n\\n        _setAutomatedMarketMakerPair(pair, value);\\n    }\\n\\n    function _setAutomatedMarketMakerPair(address pair, bool value) private {\\n        require(automatedMarketMakerPairs[pair] != value, 'Automated market maker pair is already set to that value');\\n        automatedMarketMakerPairs[pair] = value;\\n\\n        if (value) {\\n            dividendTracker.excludeFromDividends(pair);\\n        }\\n\\n        emit SetAutomatedMarketMakerPair(pair, value);\\n    }\\n\\n    function shouldRebase() internal view returns (bool) {\\n        return\\n            autoRebase && msg.sender != uniswapV2Pair && !inSwap && block.timestamp >= (lastRebasedTime + 30 minutes);\\n    }\\n\\n    function rebase() internal {\\n        if (inSwap) return;\\n        uint256 times = (block.timestamp - lastRebasedTime) / 30 minutes;\\n\\n        for (uint256 i = 0; i < times; i++) {\\n            _totalSupply = (_totalSupply * (10_000_000 + rebaseRate)) / 10_000_000;\\n            rebase_count++;\\n        }\\n\\n        rate = rSupply / _totalSupply;\\n        lastRebasedTime = lastRebasedTime + (times * 30 minutes);\\n\\n        IUniswapV2Pair(uniswapV2Pair).sync();\\n        \\n        dividendTracker.updateMinimumTokenBalanceForDividends(_totalSupply/10**5);\\n\\n        emit LogRebase(rebase_count, _totalSupply);\\n    }\\n\\n    //=======BEP20=======//\\n    function approve(address spender, uint256 value) public override returns (bool) {\\n        _allowances[msg.sender][spender] = value;\\n        emit Approval(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    function allowance(address owner_, address spender) public view override returns (uint256) {\\n        return _allowances[owner_][spender];\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public override returns (bool) {\\n        uint256 oldValue = _allowances[msg.sender][spender];\\n        if (subtractedValue >= oldValue) {\\n            _allowances[msg.sender][spender] = 0;\\n        } else {\\n            _allowances[msg.sender][spender] = oldValue - subtractedValue;\\n        }\\n        emit Approval(msg.sender, spender, _allowances[msg.sender][spender]);\\n        return true;\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue) public override returns (bool) {\\n        _allowances[msg.sender][spender] = _allowances[msg.sender][spender] + addedValue;\\n        emit Approval(msg.sender, spender, _allowances[msg.sender][spender]);\\n        return true;\\n    }\\n\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _rBalance[account] / rate;\\n    }\\n\\n    function transfer(address to, uint256 value) public override returns (bool) {\\n        _transferFrom(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) public override returns (bool) {\\n        if (_allowances[from][msg.sender] != MAX) {\\n            _allowances[from][msg.sender] = _allowances[from][msg.sender] - value;\\n        }\\n        _transferFrom(from, to, value);\\n        return true;\\n    }\\n\\n    function _basicTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal returns (bool) {\\n        uint256 rAmount = amount * rate;\\n        _rBalance[from] = _rBalance[from] - rAmount;\\n        _rBalance[to] = _rBalance[to] + rAmount;\\n        emit Transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    function _transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal returns (bool) {\\n        require(recipient != address(0), 'ERC20: transfer to the zero address');\\n        if (inSwap) {\\n            return _basicTransfer(sender, recipient, amount);\\n        }\\n        if (recipient == uniswapV2Pair && launchTime == 0 && amount > 0) {\\n            launchTime = block.timestamp;\\n        }\\n\\n        uint256 rAmount = amount * rate;\\n\\n        if (shouldRebase()) {\\n            rebase();\\n        }\\n\\n        if (shouldSwapBack()) {\\n            swapBack();\\n        }\\n\\n        _rBalance[sender] = _rBalance[sender] - rAmount;\\n\\n        bool wtwWoFee = walletToWalletTransferWithoutFee && sender != uniswapV2Pair && recipient != uniswapV2Pair;\\n        uint256 amountReceived = (_isExcludedFromFees[sender] || _isExcludedFromFees[recipient] || wtwWoFee)\\n            ? rAmount\\n            : takeFee(sender, rAmount, recipient);\\n        _rBalance[recipient] = _rBalance[recipient] + amountReceived;\\n\\n        try dividendTracker.setBalance(payable(sender), balanceOf(sender)) {} catch {}\\n        try dividendTracker.setBalance(payable(recipient), balanceOf(recipient)) {} catch {}\\n\\n        if (!inSwap) {\\n            uint256 gas = gasForProcessing;\\n\\n            try dividendTracker.process(gas) returns (uint256 iterations, uint256 claims, uint256 lastProcessedIndex) {\\n                emit ProcessedDividendTracker(iterations, claims, lastProcessedIndex, true, gas, tx.origin);\\n            } catch {}\\n        }\\n        emit Transfer(sender, recipient, amountReceived / rate);\\n        return true;\\n    }\\n\\n    function takeFee(\\n        address sender,\\n        uint256 rAmount,\\n        address recipient\\n    ) internal returns (uint256) {\\n        uint256 _finalFee;\\n        uint256 _amountDaoReward;\\n\\n        if(block.timestamp - launchTime < 10 && launchTime != 0 && (uniswapV2Pair == recipient || uniswapV2Pair == sender) ) {\\n           _finalFee = 75;\\n        } else if (uniswapV2Pair == recipient) {\\n            _finalFee = totalSellFee;\\n        } else if (uniswapV2Pair == sender) {\\n            _finalFee = totalBuyFee;\\n            _amountDaoReward = (rAmount * daoRewardBuyFee) / 100;\\n        } else {\\n            _finalFee = WtoWtransferFee;\\n        }\\n\\n        uint256 feeAmount = (rAmount * _finalFee) / 100;\\n\\n        // distribute DAO reward - 10%\\n        if (_amountDaoReward > 0) {\\n            bool isPassed = true;\\n            address[10] memory _parents;\\n            try fifaSportDao.getParents(recipient) returns(address[10] memory result) {\\n                _parents = result;\\n            } catch {\\n                isPassed=false;\\n            }\\n\\n            if(isPassed){\\n                for (uint8 i = 0; i < _parents.length; i++) {\\n                    uint256 _parentFee = (_amountDaoReward / 100) * 5; // 5 %\\n                    if (i == 0) {\\n                        _parentFee = (_amountDaoReward / 10) * 4; // 40%\\n                    }\\n                    if (i == 1) {\\n                        _parentFee = (_amountDaoReward / 10) * 2; // 20%\\n                    }\\n                    _rBalance[_parents[i]] = _rBalance[_parents[i]] + _parentFee;\\n\\n                    emit DistributionDaoReward(recipient, _parents[i], _parentFee / rate, i);\\n                    emit Transfer(recipient, _parents[i], _parentFee / rate);\\n                }\\n            }\\n        }\\n\\n        _rBalance[address(this)] = _rBalance[address(this)] + (feeAmount - _amountDaoReward);\\n        emit Transfer(sender, address(this), (feeAmount - _amountDaoReward) / rate);\\n\\n        return rAmount - feeAmount;\\n    }\\n\\n    //=======FeeManagement=======//\\n    function excludeFromFees(address account) external onlyOwner {\\n        require(!_isExcludedFromFees[account], 'Account is already the value of true');\\n        _isExcludedFromFees[account] = true;\\n        emit ExcludeFromFees(account, true);\\n    }\\n\\n    function isExcludedFromFees(address account) public view returns (bool) {\\n        return _isExcludedFromFees[account];\\n    }\\n\\n\\n    function updateSellFees(\\n        uint256 _liquiditySellFee,\\n        uint256 _treasurySellFee,\\n        uint256 _sustainabilitySellFee,\\n        uint256 _rewardSellFee,\\n        uint256 _firePitSellFee\\n    ) external onlyOwner {\\n        liquiditySellFee = _liquiditySellFee;\\n        treasurySellFee = _treasurySellFee;\\n        sustainabilitySellFee = _sustainabilitySellFee;\\n        rewardSellFee = _rewardSellFee;\\n        firePitSellFee = _firePitSellFee;\\n        totalSellFee = liquiditySellFee + treasurySellFee + sustainabilitySellFee + rewardSellFee + firePitSellFee;\\n\\n        require(totalSellFee <= 25, 'Fees must be less than 25%');\\n        emit SellFeesUpdated(\\n            liquiditySellFee,\\n            treasurySellFee,\\n            sustainabilitySellFee,\\n            rewardSellFee,\\n            firePitSellFee\\n        );\\n    }\\n\\n    function updateBuyFees(uint256 _liquidityBuyFee, uint256 _daoRewardBuyFee) external onlyOwner {\\n        liquidityBuyFee = _liquidityBuyFee;\\n        daoRewardBuyFee = _daoRewardBuyFee;\\n        totalBuyFee = liquidityBuyFee + daoRewardBuyFee;\\n\\n        require(totalBuyFee <= 25, 'Fees must be less than 25%');\\n        emit BuyFeesUpdated(\\n            liquidityBuyFee,\\n            daoRewardBuyFee\\n        );\\n    }\\n\\n    function updateWtoWFees(uint256 _treasuryTransferFee, uint256 _liquidityTransferFee) external onlyOwner {\\n        treasuryTransferFee = _treasuryTransferFee;\\n        liquidityTransferFee = _liquidityTransferFee;\\n        WtoWtransferFee = treasuryTransferFee + liquidityTransferFee;\\n        require(WtoWtransferFee <= 25, 'Fees must be less than 25%');\\n        emit WtoWFeesUpdated(\\n            treasuryTransferFee,\\n            liquidityTransferFee\\n        );\\n    }\\n\\n    function enableWalletToWalletTransferWithoutFee(bool enable) external onlyOwner {\\n        require(\\n            walletToWalletTransferWithoutFee != enable,\\n            'Wallet to wallet transfer without fee is already set to that value'\\n        );\\n        walletToWalletTransferWithoutFee = enable;\\n    }\\n\\n    function updateDao(address _address) public onlyOwner {\\n        require(address(fifaSportDao) != _address, 'DAO is already set to that value');\\n        fifaSportDao = IFifaSportDao(_address);\\n    }\\n\\n    function changeTreasuryWallet(address _treasuryWallet) external onlyOwner {\\n        require(_treasuryWallet != treasuryWallet, 'Marketing wallet is already that address');\\n        require(!isContract(_treasuryWallet), 'Marketing wallet cannot be a contract');\\n        treasuryWallet = _treasuryWallet;\\n    }\\n\\n    function changeSustainabilityWallet(address _sustainabilityWallet) external onlyOwner {\\n        require(_sustainabilityWallet != sustainabilityWallet, 'Ecosystem wallet is already that address');\\n        require(!isContract(_sustainabilityWallet), 'Sustainability wallet cannot be a contract');\\n        sustainabilityWallet = _sustainabilityWallet;\\n    }\\n\\n    //=======Swap=======//\\n    function shouldSwapBack() internal view returns (bool) {\\n        return (msg.sender != uniswapV2Pair &&\\n            !inSwap &&\\n            swapEnabled &&\\n            _rBalance[address(this)] >= swapThreshold &&\\n            lastSwapTime + swapInterval < block.timestamp);\\n    }\\n\\n    function swapBack() internal swapping {\\n        uint256 contractTokenBalance = balanceOf(address(this));\\n\\n        uint256 totalFee = totalBuyFee - daoRewardBuyFee + totalSellFee + WtoWtransferFee;\\n        uint256 liquidityShare = liquidityBuyFee + liquiditySellFee + liquidityTransferFee;\\n        uint256 treasuryShare = treasurySellFee + treasuryTransferFee;\\n        uint256 sustainabilityShare = sustainabilitySellFee;\\n        uint256 firePitShare = firePitSellFee;\\n        uint256 rewardShare = rewardSellFee;\\n\\n        uint256 liquidityTokens;\\n        uint256 firePitTokens;\\n        if (liquidityShare > 0) {\\n            liquidityTokens = (contractTokenBalance * liquidityShare) / totalFee;\\n            swapAndLiquify(liquidityTokens);\\n        }\\n        \\n        if (firePitShare > 0) {\\n            firePitTokens = (contractTokenBalance * firePitShare) / totalFee;\\n            _basicTransfer(address(this), DEAD, firePitTokens);\\n        }\\n\\n        contractTokenBalance -= liquidityTokens + firePitTokens;\\n        uint256 bnbShare = treasuryShare + sustainabilityShare + rewardShare;\\n\\n        if (contractTokenBalance > 0 && bnbShare > 0) {\\n            uint256 initialBalance = address(this).balance;\\n\\n            address[] memory path = new address[](2);\\n            path[0] = address(this);\\n            path[1] = uniswapV2Router.WETH();\\n\\n            uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n                contractTokenBalance,\\n                0,\\n                path,\\n                address(this),\\n                block.timestamp\\n            );\\n\\n            uint256 newBalance = address(this).balance - initialBalance;\\n\\n            if (treasuryShare > 0) {\\n                uint256 marketingBNB = (newBalance * treasuryShare) / bnbShare;\\n                sendBNB(payable(treasuryWallet), marketingBNB);\\n            }\\n\\n            if (sustainabilityShare > 0) {\\n                uint256 sustainabilityAmount = (newBalance * sustainabilityShare) / bnbShare;\\n                sendBNB(payable(sustainabilityWallet), sustainabilityAmount);\\n            }\\n\\n            if (rewardShare > 0) {\\n                uint256 rewardBNB = (newBalance * rewardShare) / bnbShare;\\n                swapAndSendDividends(rewardBNB);\\n            }\\n        }\\n\\n        lastSwapTime = block.timestamp;\\n    }\\n\\n    function swapAndLiquify(uint256 tokens) private {\\n        uint256 half = tokens / 2;\\n        uint256 otherHalf = tokens - half;\\n\\n        uint256 initialBalance = address(this).balance;\\n\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = uniswapV2Router.WETH();\\n\\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            half,\\n            0, // accept any amount of ETH\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n\\n        uint256 newBalance = address(this).balance - initialBalance;\\n\\n        uniswapV2Router.addLiquidityETH{ value: newBalance }(\\n            address(this),\\n            otherHalf,\\n            0, // slippage is unavoidable\\n            0, // slippage is unavoidable\\n            DEAD,\\n            block.timestamp\\n        );\\n\\n        emit SwapAndLiquify(half, newBalance, otherHalf);\\n    }\\n\\n    function swapAndSendDividends(uint256 amount) private {\\n        address[] memory path = new address[](2);\\n        path[0] = uniswapV2Router.WETH();\\n        path[1] = usdToken;\\n\\n        uniswapV2Router.swapExactETHForTokensSupportingFeeOnTransferTokens{ value: amount }(\\n            0,\\n            path,\\n            address(dividendTracker),\\n            block.timestamp\\n        );\\n\\n        uint256 balanceRewardToken = IERC20(usdToken).balanceOf(address(dividendTracker));\\n\\n        dividendTracker.distributeDividends(balanceRewardToken);\\n        emit SendDividends(balanceRewardToken);\\n    }\\n\\n    function setSwapBackSettings(bool _enabled, uint256 _percentage_base100000) external onlyOwner {\\n        require(_percentage_base100000 >= 1, \\\"Swap back percentage must be more than 0.001%\\\");\\n        swapEnabled = _enabled;\\n        swapThreshold = rSupply / 100000 * _percentage_base100000;\\n    }\\n\\n    function checkSwapThreshold() external view returns (uint256) {\\n        return swapThreshold / rate;\\n    }\\n\\n    //=======Divivdend Tracker=======//\\n\\n    function updateDividendTracker(address newAddress) public onlyOperator {\\n        require(newAddress != address(dividendTracker), 'The dividend tracker already has that address');\\n\\n        dividendTracker = IDividendTracker(payable(newAddress));\\n        dividendTracker.init();\\n        require(\\n            dividendTracker.owner() == address(this),\\n            'The new dividend tracker must be owned by the token contract'\\n        );\\n\\n        dividendTracker.excludeFromDividends(address(dividendTracker));\\n        dividendTracker.excludeFromDividends(address(this));\\n        dividendTracker.excludeFromDividends(DEAD);\\n        dividendTracker.excludeFromDividends(address(uniswapV2Router));\\n        dividendTracker.excludeFromDividends(address(uniswapV2Pair));\\n        dividendTracker.excludeFromDividends(address(fifaSportDao));\\n\\n        emit UpdateDividendTracker(newAddress, address(dividendTracker));\\n    }\\n\\n    function updateGasForProcessing(uint256 newValue) public onlyOwner {\\n        require(newValue >= 200000 && newValue <= 500000, 'gasForProcessing must be between 200,000 and 500,000');\\n        require(newValue != gasForProcessing, 'Cannot update gasForProcessing to same value');\\n        emit GasForProcessingUpdated(newValue, gasForProcessing);\\n        gasForProcessing = newValue;\\n    }\\n\\n    function updateMinimumBalanceForDividends(uint256 newMinimumBalance) external onlyOperator {\\n        dividendTracker.updateMinimumTokenBalanceForDividends(newMinimumBalance);\\n    }\\n\\n    function updateClaimWait(uint256 claimWait) external onlyOwner {\\n        dividendTracker.updateClaimWait(claimWait);\\n    }\\n\\n    function getClaimWait() external view returns (uint256) {\\n        return dividendTracker.claimWait();\\n    }\\n\\n    function getTotalDividendsDistributed() external view returns (uint256) {\\n        return dividendTracker.totalDividendsDistributed();\\n    }\\n\\n    function withdrawableDividendOf(address account) public view returns (uint256) {\\n        return dividendTracker.withdrawableDividendOf(account);\\n    }\\n\\n    function dividendTokenBalanceOf(address account) public view returns (uint256) {\\n        return dividendTracker.balanceOf(account);\\n    }\\n\\n    function totalRewardsEarned(address account) public view returns (uint256) {\\n        return dividendTracker.accumulativeDividendOf(account);\\n    }\\n\\n    function excludeFromDividends(address account) external onlyOwner {\\n        dividendTracker.excludeFromDividends(account);\\n    }\\n\\n    function getAccountDividendsInfo(address account)\\n        external\\n        view\\n        returns (\\n            address,\\n            int256,\\n            int256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        return dividendTracker.getAccount(account);\\n    }\\n\\n    function getAccountDividendsInfoAtIndex(uint256 index)\\n        external\\n        view\\n        returns (\\n            address,\\n            int256,\\n            int256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        return dividendTracker.getAccountAtIndex(index);\\n    }\\n\\n    function processDividendTracker(uint256 gas) external {\\n        (uint256 iterations, uint256 claims, uint256 lastProcessedIndex) = dividendTracker.process(gas);\\n        emit ProcessedDividendTracker(iterations, claims, lastProcessedIndex, false, gas, tx.origin);\\n    }\\n\\n    function claim() external {\\n        dividendTracker.processAccount(payable(msg.sender), false);\\n    }\\n\\n    function claimAddress(address claimee) external onlyOwner {\\n        dividendTracker.processAccount(payable(claimee), false);\\n    }\\n\\n    function getLastProcessedIndex() external view returns (uint256) {\\n        return dividendTracker.getLastProcessedIndex();\\n    }\\n\\n    function setLastProcessedIndex(uint256 index) external onlyOwner {\\n        dividendTracker.setLastProcessedIndex(index);\\n    }\\n\\n    function getNumberOfDividendTokenHolders() external view returns (uint256) {\\n        return dividendTracker.getNumberOfTokenHolders();\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity ^0.8.3;\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\\n\\n    function feeTo() external view returns (address);\\n\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n\\n    function allPairs(uint256) external view returns (address pair);\\n\\n    function allPairsLength() external view returns (uint256);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n\\n    function setFeeToSetter(address) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity ^0.8.3;\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function name() external pure returns (string memory);\\n\\n    function symbol() external pure returns (string memory);\\n\\n    function decimals() external pure returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint256 amount0In,\\n        uint256 amount1In,\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n    function factory() external view returns (address);\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 reserve0,\\n            uint112 reserve1,\\n            uint32 blockTimestampLast\\n        );\\n\\n    function price0CumulativeLast() external view returns (uint256);\\n\\n    function price1CumulativeLast() external view returns (uint256);\\n\\n    function kLast() external view returns (uint256);\\n\\n    function mint(address to) external returns (uint256 liquidity);\\n\\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\\n\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external;\\n\\n    function skim(address to) external;\\n\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity ^0.8.3;\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        returns (\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 liquidity\\n        );\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256 amountToken,\\n            uint256 amountETH,\\n            uint256 liquidity\\n        );\\n\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    function removeLiquidityETH(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapTokensForExactTokens(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactETHForTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n\\n    function swapTokensForExactETH(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactTokensForETH(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapETHForExactTokens(\\n        uint256 amountOut,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n\\n    function quote(\\n        uint256 amountA,\\n        uint256 reserveA,\\n        uint256 reserveB\\n    ) external pure returns (uint256 amountB);\\n\\n    function getAmountOut(\\n        uint256 amountIn,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) external pure returns (uint256 amountOut);\\n\\n    function getAmountIn(\\n        uint256 amountOut,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) external pure returns (uint256 amountIn);\\n\\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\\n\\n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SEE LICENSE IN LICENSE\\npragma solidity ^0.8.3;\\n\\nimport './IUniswapV2Router01.sol';\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountETH);\\n\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable;\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFifaSportDao.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.3;\\ninterface IFifaSportDao {\\n    function distribution(address _to, uint256 _totalAmount) external;\\n\\n    function getParents(address _wallet) external view returns (address[10] memory);\\n\\n    function referral(address _from, address _to) external;\\n\\n    function relations(address, uint256) external view returns (address);\\n\\n    function setIsRecevicedAddress(address _to) external;\\n    \\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDividendTracker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.3;\\ninterface IDividendTracker {\\n  function accumulativeDividendOf ( address _owner ) external view returns ( uint256 );\\n  function allowance ( address owner, address spender ) external view returns ( uint256 );\\n  function approve ( address spender, uint256 amount ) external returns ( bool );\\n  function balanceOf ( address account ) external view returns ( uint256 );\\n  function claimWait (  ) external view returns ( uint256 );\\n  function decimals (  ) external view returns ( uint8 );\\n  function decreaseAllowance ( address spender, uint256 subtractedValue ) external returns ( bool );\\n  function distributeDividends ( uint256 amount ) external;\\n  function dividendOf ( address _owner ) external view returns ( uint256 );\\n  function excludeFromDividends ( address account ) external;\\n  function excludedFromDividends ( address ) external view returns ( bool );\\n  function getAccount ( address _account ) external view returns ( address account, int256 index, int256 iterationsUntilProcessed, uint256 withdrawableDividends, uint256 totalDividends, uint256 lastClaimTime, uint256 nextClaimTime, uint256 secondsUntilAutoClaimAvailable );\\n  function getAccountAtIndex ( uint256 index ) external view returns ( address, int256, int256, uint256, uint256, uint256, uint256, uint256 );\\n  function getLastProcessedIndex (  ) external view returns ( uint256 );\\n  function getNumberOfTokenHolders (  ) external view returns ( uint256 );\\n  function increaseAllowance ( address spender, uint256 addedValue ) external returns ( bool );\\n  function init (  ) external;\\n  function initialized (  ) external view returns ( bool );\\n  function lastClaimTimes ( address ) external view returns ( uint256 );\\n  function lastProcessedIndex (  ) external view returns ( uint256 );\\n  function minimumTokenBalanceForDividends (  ) external view returns ( uint256 );\\n  function name (  ) external view returns ( string memory );\\n  function owner (  ) external view returns ( address );\\n  function process ( uint256 gas ) external returns ( uint256, uint256, uint256 );\\n  function processAccount ( address account, bool automatic ) external returns ( bool );\\n  function renounceOwnership (  ) external;\\n  function rewardToken (  ) external view returns ( address );\\n  function setBalance ( address account, uint256 newBalance ) external;\\n  function setLastProcessedIndex ( uint256 index ) external;\\n  function symbol (  ) external view returns ( string memory );\\n  function totalDividendsDistributed (  ) external view returns ( uint256 );\\n  function totalSupply (  ) external view returns ( uint256 );\\n  function transfer ( address to, uint256 amount ) external returns ( bool );\\n  function transferFrom ( address from, address to, uint256 amount ) external returns ( bool );\\n  function transferOwnership ( address newOwner ) external;\\n  function updateClaimWait ( uint256 newClaimWait ) external;\\n  function updateMinimumTokenBalanceForDividends ( uint256 _newMinimumBalance ) external;\\n  function withdrawDividend (  ) external pure;\\n  function withdrawableDividendOf ( address _owner ) external view returns ( uint256 );\\n  function withdrawnDividendOf ( address _owner ) external view returns ( uint256 );\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dao\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_usdToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dividendTracker\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"AutoRebaseStatusUptaded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidityBuyFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"daoRewardBuyFee\",\"type\":\"uint256\"}],\"name\":\"BuyFeesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"DistributionDaoReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeFromFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"}],\"name\":\"GasForProcessingUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"name\":\"LogRebase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"iterations\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claims\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastProcessedIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"automatic\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"processor\",\"type\":\"address\"}],\"name\":\"ProcessedDividendTracker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquiditySellFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"treasurySellFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sustainabilitySellFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardSellFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"firePitSellFee\",\"type\":\"uint256\"}],\"name\":\"SellFeesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SendDividends\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetAutomatedMarketMakerPair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bnbReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiqudity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"}],\"name\":\"UpdateDividendTracker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"}],\"name\":\"UpdateUniswapV2Router\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"treasuryTransferFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidityTransferFee\",\"type\":\"uint256\"}],\"name\":\"WtoWFeesUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"WtoWtransferFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoRebase\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"automatedMarketMakerPairs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"changeOperatorWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sustainabilityWallet\",\"type\":\"address\"}],\"name\":\"changeSustainabilityWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasuryWallet\",\"type\":\"address\"}],\"name\":\"changeTreasuryWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkSwapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"claimee\",\"type\":\"address\"}],\"name\":\"claimAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"claimStuckTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daoRewardBuyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"dividendTokenBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendTracker\",\"outputs\":[{\"internalType\":\"contract IDividendTracker\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"enableWalletToWalletTransferWithoutFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromDividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fifaSportDao\",\"outputs\":[{\"internalType\":\"contract IFifaSportDao\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"firePitSellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasForProcessing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAccountDividendsInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getAccountDividendsInfoAtIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getClaimWait\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastProcessedIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumberOfDividendTokenHolders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalDividendsDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRebasedTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastSwapTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityBuyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquiditySellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityTransferFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualSync\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"}],\"name\":\"processDividendTracker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebaseRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebase_count\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardSellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_flag\",\"type\":\"bool\"}],\"name\":\"setAutoRebase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setAutomatedMarketMakerPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"setLastProcessedIndex\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_percentage_base100000\",\"type\":\"uint256\"}],\"name\":\"setSwapBackSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startAPY\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sustainabilitySellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sustainabilityWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBuyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"totalRewardsEarned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasurySellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryTransferFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquidityBuyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_daoRewardBuyFee\",\"type\":\"uint256\"}],\"name\":\"updateBuyFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"claimWait\",\"type\":\"uint256\"}],\"name\":\"updateClaimWait\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"updateDao\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"updateDividendTracker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"updateGasForProcessing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMinimumBalance\",\"type\":\"uint256\"}],\"name\":\"updateMinimumBalanceForDividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_liquiditySellFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_treasurySellFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sustainabilitySellFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardSellFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_firePitSellFee\",\"type\":\"uint256\"}],\"name\":\"updateSellFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"updateUniswapV2Router\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_treasuryTransferFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidityTransferFee\",\"type\":\"uint256\"}],\"name\":\"updateWtoWFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"walletToWalletTransferWithoutFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"withdrawableDividendOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "FifaSport", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "0000000000000000000000000740c2c5bb51b4541774cdb38dfb3a8d2981bc4e000000000000000000000000b2d978210b74deef6a5343709ffcbc5a0523c5d7000000000000000000000000e9e7cea3dedca5984780bafc599bd69add087d560000000000000000000000002af081b1ac99958ba1d7f715088dc3daab7aec6e", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}