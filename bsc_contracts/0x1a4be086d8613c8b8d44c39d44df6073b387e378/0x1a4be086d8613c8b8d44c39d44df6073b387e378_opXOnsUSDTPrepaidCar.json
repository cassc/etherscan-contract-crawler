{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\n\r\ninterface AggregatorV3Interface {\r\n  function decimals() external view returns (uint8);\r\n  function description() external view returns (string memory);\r\n  function version() external view returns (uint256);\r\n  function getRoundData(uint80 _roundId)\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n  function latestRoundData()\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _status == _ENTERED;\r\n    }\r\n}\r\n\r\ninterface IERC20Permit {\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n}\r\n\r\nlibrary Address {\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n\r\n                require(isContract(target), \"Address: call to non-contract\");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n\r\n        if (returndata.length > 0) {\r\n\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 oldAllowance = token.allowance(address(this), spender);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\r\n        }\r\n    }\r\n\r\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\r\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\r\n\r\n        if (!_callOptionalReturnBool(token, approvalCall)) {\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\r\n            _callOptionalReturn(token, approvalCall);\r\n        }\r\n    }\r\n\r\n    function safePermit(\r\n        IERC20Permit token,\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal {\r\n        uint256 nonceBefore = token.nonces(owner);\r\n        token.permit(owner, spender, value, deadline, v, r, s);\r\n        uint256 nonceAfter = token.nonces(owner);\r\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\r\n    }\r\n\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n    }\r\n\r\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\r\n\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        return\r\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\r\n    }\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\nabstract contract Pausable is Context {\r\n\r\n    event Paused(address account);\r\n\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    constructor() {\r\n        _paused = false;\r\n    }\r\n\r\n    modifier whenNotPaused() {\r\n        _requireNotPaused();\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused() {\r\n        _requirePaused();\r\n        _;\r\n    }\r\n\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    function _requireNotPaused() internal view virtual {\r\n        require(!paused(), \"Pausable: paused\");\r\n    }\r\n\r\n    function _requirePaused() internal view virtual {\r\n        require(paused(), \"Pausable: not paused\");\r\n    }\r\n\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\ncontract opXOnsUSDTPrepaidCard is Ownable, Pausable, ReentrancyGuard {\r\n    using SafeERC20 for IERC20;\r\n\r\n    IERC20 private token;\r\n    IERC20 private usdtToken;\r\n    address private constant FROM_WALLET = 0xd28bd5185091d831D75C9D902d337b735075272A;\r\n    address private constant USDT_USD_PRICE_FEED = 0xB97Ad0E74fa7d920791E90258A6E2085088b4320;\r\n\r\n    mapping(bytes32 => uint256) private validHashes;\r\n    mapping(bytes32 => bool) private blockedSecrets;\r\n    mapping(address => uint256) private pendingWithdrawals;\r\n    mapping(bytes32 => uint256) private secretTimestamps; \r\n\r\n    struct RedeemedInfo {\r\n        uint256 timestamp;\r\n        address beneficiary;\r\n        uint256 amount;\r\n    }\r\n\r\n    mapping(bytes32 => RedeemedInfo) private redeemedSecretsInfo;\r\n\r\n    uint256 private constant TWO_YEARS = 2 * 365 days;\r\n\r\n    event TokensUnlocked(address beneficiary, uint256 amount);\r\n    event TransactionFeeChanged(uint256 oldValue, uint256 newValue);\r\n\r\n    constructor(address _tokenAddress, address _usdtTokenAddress) {\r\n        token = IERC20(_tokenAddress);\r\n        usdtToken = IERC20(_usdtTokenAddress);\r\n    }\r\n\r\n    function pause() external onlyOwner {\r\n        _pause();\r\n    }\r\n\r\n    function unpause() external onlyOwner {\r\n        _unpause();\r\n    }\r\n\r\n    function blockSecrets(bytes32[] memory secretHashes) external onlyOwner whenNotPaused {\r\n        for (uint256 i = 0; i < secretHashes.length; i++) {\r\n            require(validHashes[secretHashes[i]] > 0, \"Invalid secret\");\r\n            blockedSecrets[secretHashes[i]] = true;\r\n        }\r\n    }\r\n\r\n    function unblockSecrets(bytes32[] memory secretHashes) external onlyOwner whenNotPaused {\r\n        for (uint256 i = 0; i < secretHashes.length; i++) {\r\n            require(validHashes[secretHashes[i]] > 0, \"Invalid secret\");\r\n            blockedSecrets[secretHashes[i]] = false;\r\n        }\r\n    }\r\n\r\n    function setTokenAddress(address _tokenAddress) external onlyOwner whenNotPaused {\r\n        token = IERC20(_tokenAddress);\r\n    }\r\n\r\n    function addSecrets(bytes32[] memory _hashedSecrets, uint256[] memory _amounts) external onlyOwner whenNotPaused {\r\n        require(_hashedSecrets.length == _amounts.length, \"Mismatched arrays\");\r\n        for (uint256 i = 0; i < _hashedSecrets.length; i++) {\r\n            validHashes[_hashedSecrets[i]] = _amounts[i];\r\n            secretTimestamps[_hashedSecrets[i]] = block.timestamp;\r\n        }\r\n    }\r\n\r\n    function unlockTokens(string memory _secret, address _beneficiary) external nonReentrant whenNotPaused {\r\n        bytes32 secretHash = keccak256(abi.encodePacked(_secret));\r\n        require(blockedSecrets[secretHash] == false, \"Secret is blocked\");\r\n        uint256 amount = validHashes[secretHash];\r\n        require(amount > 0, \"Invalid secret\");\r\n        require(token.balanceOf(FROM_WALLET) >= amount, \"Insufficient tokens\");\r\n        require(!isSecretExpired(_secret), \"Secret expired\");\r\n\r\n        redeemedSecretsInfo[secretHash] = RedeemedInfo({\r\n            timestamp: block.timestamp,\r\n            beneficiary: _beneficiary,\r\n            amount: amount\r\n        });\r\n\r\n        validHashes[secretHash] = 0;\r\n        secretTimestamps[secretHash] = 0;\r\n\r\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(USDT_USD_PRICE_FEED);\r\n        (, int256 price,,,) = priceFeed.latestRoundData();\r\n        uint256 usdtAmount = amount * 1e8 / uint256(price);\r\n\r\n        pendingWithdrawals[_beneficiary] += usdtAmount;\r\n\r\n        emit TokensUnlocked(_beneficiary, usdtAmount);\r\n    }\r\n\r\n    function withdrawTokens(address _beneficiary) external nonReentrant whenNotPaused {\r\n        uint256 amount = pendingWithdrawals[_beneficiary];\r\n        require(amount > 0, \"No tokens to withdraw\");\r\n\r\n        uint256 fee = (transactionFeePercentage * amount) / 100;\r\n\r\n        require(amount > fee, \"Amount should be greater than transaction fee\");\r\n\r\n        amount -= fee;\r\n\r\n        pendingWithdrawals[_beneficiary] = 0;\r\n        usdtToken.safeTransferFrom(FROM_WALLET, _beneficiary, amount);\r\n        usdtToken.safeTransferFrom(FROM_WALLET, feeAddress, fee);\r\n    }\r\n\r\n    function checkSecretBalance(string memory _secret) public view returns (uint256) {\r\n        bytes32 secretHash = keccak256(abi.encodePacked(_secret));\r\n        return validHashes[secretHash];\r\n    }\r\n\r\n    function getPendingWithdrawal(address _beneficiary) public view returns (uint256) {\r\n        return pendingWithdrawals[_beneficiary];\r\n    }\r\n\r\n    function withdrawETH() external onlyOwner whenNotPaused {\r\n        payable(owner()).transfer(address(this).balance);\r\n    }\r\n\r\n    function rescueTokens(IERC20 _token) external onlyOwner whenNotPaused {\r\n        uint256 balance = _token.balanceOf(address(this));\r\n        require(balance > 0, \"No tokens to rescue\");\r\n        _token.safeTransfer(owner(), balance);\r\n    }\r\n\r\n    function isSecretValid(string memory _secret) public view returns (bool) {\r\n        bytes32 secretHash = keccak256(abi.encodePacked(_secret));\r\n        uint256 amount = validHashes[secretHash];\r\n        bool isSecretBlocked = blockedSecrets[secretHash];\r\n    \r\n        if(amount > 0 && !isSecretBlocked && !isSecretExpired(_secret) && token.balanceOf(FROM_WALLET) >= amount) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    uint256 private transactionFeePercentage = 1; \r\n    address private feeAddress = 0xA26470Cd696CfB7cB4868442172075Ad7232251c;\r\n\r\n    function setTransactionFeePercentage(uint256 newFeePercentage) external onlyOwner whenNotPaused {\r\n        require(newFeePercentage <= 100, \"Percentage cannot be greater than 100\");\r\n        emit TransactionFeeChanged(transactionFeePercentage, newFeePercentage);\r\n        transactionFeePercentage = newFeePercentage;\r\n    }\r\n\r\n    function isSecretExpired(string memory _secret) public view returns (bool) {\r\n        bytes32 secretHash = keccak256(abi.encodePacked(_secret));\r\n        uint256 secretCreationTime = secretTimestamps[secretHash];\r\n        return block.timestamp > secretCreationTime + TWO_YEARS;\r\n    }\r\n\r\n    function setTransactionFeeAddress(address _feeAddress) external onlyOwner whenNotPaused {\r\n        feeAddress = _feeAddress;\r\n    }\r\n\r\n    function getSecretExpirationDate(string memory _secret) public view returns (uint256) {\r\n        bytes32 secretHash = keccak256(abi.encodePacked(_secret));\r\n        return secretTimestamps[secretHash] + TWO_YEARS;\r\n    }\r\n\r\n    function getRedeemedSecretInfo(string memory _secret) public view returns (uint256, address, uint256) {\r\n        bytes32 secretHash = keccak256(abi.encodePacked(_secret));\r\n        return (\r\n            redeemedSecretsInfo[secretHash].timestamp,\r\n            redeemedSecretsInfo[secretHash].beneficiary,\r\n            redeemedSecretsInfo[secretHash].amount\r\n        );\r\n    }\r\n\r\n    receive() external payable whenNotPaused {}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_usdtTokenAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensUnlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"TransactionFeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_hashedSecrets\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"addSecrets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"secretHashes\",\"type\":\"bytes32[]\"}],\"name\":\"blockSecrets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_secret\",\"type\":\"string\"}],\"name\":\"checkSecretBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"getPendingWithdrawal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_secret\",\"type\":\"string\"}],\"name\":\"getRedeemedSecretInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_secret\",\"type\":\"string\"}],\"name\":\"getSecretExpirationDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_secret\",\"type\":\"string\"}],\"name\":\"isSecretExpired\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_secret\",\"type\":\"string\"}],\"name\":\"isSecretValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"rescueTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"setTokenAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeAddress\",\"type\":\"address\"}],\"name\":\"setTransactionFeeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFeePercentage\",\"type\":\"uint256\"}],\"name\":\"setTransactionFeePercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"secretHashes\",\"type\":\"bytes32[]\"}],\"name\":\"unblockSecrets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_secret\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"unlockTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "opXOnsUSDTPrepaidCard", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000005df0aa30a59e1304e8dbb00b50343854e716821600000000000000000000000055d398326f99059ff775485246999027b3197955", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://75fee9bbc6cb9b94c50b99df5f939601c1db414b14977e39579979ad36e00ed2"}