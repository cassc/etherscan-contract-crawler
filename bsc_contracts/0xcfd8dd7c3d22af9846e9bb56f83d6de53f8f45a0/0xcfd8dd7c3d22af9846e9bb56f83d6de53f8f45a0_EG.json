{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\\n     * initialization.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20PermitUpgradeable {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\nimport \\\"../extensions/draft-IERC20PermitUpgradeable.sol\\\";\\nimport \\\"../../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20Upgradeable {\\n    using AddressUpgradeable for address;\\n\\n    function safeTransfer(\\n        IERC20Upgradeable token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20Upgradeable token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20PermitUpgradeable token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/EGToken.sol\": {\r\n      \"content\": \"// Copyright (c) 2023 EG Global Ltd. All rights reserved.\\r\\n// EG licenses this file to you under the MIT license.\\r\\n\\r\\n/*\\r\\n\\r\\nEG is a community token making a difference by maximising crypto's impact in a purposeful ecosystem.\\r\\n\\r\\nThe EG Token powers the EG Ecosystem that includes:\\r\\n\\r\\n* Salesforce Exchange for Enterprise\\r\\n* EGTrade\\r\\n* EGSwap (DEX)\\r\\n* EGMigrate\\r\\n* Gator Gang NFT Collection\\r\\n* Burn Party Platform\\r\\n* Blockchain Alliance for Global Good (BAGG)\\r\\n* EG Social Impact Portal\\r\\n* EG Blockchain Agency\\r\\n* and many more dApps & utilities to come.\\r\\n\\r\\n _______   _______    .___________.  ______    __  ___  _______ .__   __. \\r\\n|   ____| /  _____|   |           | /  __  \\\\  |  |/  / |   ____||  \\\\ |  | \\r\\n|  |__   |  |  __     `---|  |----`|  |  |  | |  '  /  |  |__   |   \\\\|  | \\r\\n|   __|  |  | |_ |        |  |     |  |  |  | |    <   |   __|  |  . `  | \\r\\n|  |____ |  |__| |        |  |     |  `--'  | |  .  \\\\  |  |____ |  |\\\\   | \\r\\n|_______| \\\\______|        |__|      \\\\______/  |__|\\\\__\\\\ |_______||__| \\\\__| \\r\\n\\r\\n\\r\\nFrom education initiatives to disaster relief, the EG community has \\r\\ndefied the limits of an online movement by donating over $3.7 Million\\r\\nin direct aid, around the world.\\r\\n\\r\\nLearn more about EG and our Ecosystem by visting\\r\\nhttps://www.EGToken.io\\r\\n\\r\\n*/\\r\\n\\r\\n// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.17;\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\\\";\\r\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\\\";\\r\\nimport \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\\\";\\r\\n\\r\\n// helper methods for discovering LP pair addresses\\r\\nlibrary PairHelper {\\r\\n    bytes private constant token0Selector =\\r\\n        abi.encodeWithSelector(IUniswapV2Pair.token0.selector);\\r\\n    bytes private constant token1Selector =\\r\\n        abi.encodeWithSelector(IUniswapV2Pair.token1.selector);\\r\\n\\r\\n    function token0(address pair) internal view returns (address) {\\r\\n        return token(pair, token0Selector);\\r\\n    }\\r\\n\\r\\n    function token1(address pair) internal view returns (address) {\\r\\n        return token(pair, token1Selector);\\r\\n    }\\r\\n\\r\\n    function token(\\r\\n        address pair,\\r\\n        bytes memory selector\\r\\n    ) private view returns (address) {\\r\\n        // Do not check if pair is not a contract to avoid warning in transaction log\\r\\n        if (!isContract(pair)) return address(0);\\r\\n\\r\\n        (bool success, bytes memory data) = pair.staticcall(selector);\\r\\n\\r\\n        if (success && data.length >= 32) {\\r\\n            return abi.decode(data, (address));\\r\\n        }\\r\\n\\r\\n        return address(0);\\r\\n    }\\r\\n\\r\\n    function isContract(address account) private view returns (bool) {\\r\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\r\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\r\\n        // for accounts without code, i.e. `keccak256('')`\\r\\n        bytes32 codehash;\\r\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly {\\r\\n            codehash := extcodehash(account)\\r\\n        }\\r\\n\\r\\n        return (codehash != accountHash && codehash != 0x0);\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract EG is IERC20Upgradeable, OwnableUpgradeable {\\r\\n    using PairHelper for address;\\r\\n    using SafeERC20Upgradeable for IERC20Upgradeable;\\r\\n\\r\\n    struct TransferDetails {\\r\\n        uint112 balance0; // balance of token0\\r\\n        uint112 balance1; // balance of token1\\r\\n        uint32 blockNumber; // block number of  transfer\\r\\n        address to; // receive address of transfer\\r\\n        address origin; // submitter address of transfer\\r\\n    }\\r\\n\\r\\n    uint256 public totalSupply; // total supply\\r\\n\\r\\n    uint8 public constant decimals = 18; // decimals of token\\r\\n\\r\\n    string public constant name = \\\"EG Token\\\"; // name of token\\r\\n    string public constant symbol = \\\"EG\\\"; // symbol of token\\r\\n\\r\\n    IUniswapV2Router02 public uniswapV2Router; // uniswap router\\r\\n    address public uniswapV2Pair; // uniswap pair\\r\\n\\r\\n    uint256 public buyFee; // buy fee\\r\\n    uint256 public sellFee; // sell fee\\r\\n    uint256 public transferFee; // transfer fee\\r\\n\\r\\n    address public marketingWallet; // marketing wallet address\\r\\n    address public liquidityWallet; // liquidity wallet address\\r\\n    address public techWallet; // tech wallet address\\r\\n    address public donationsWallet; // donations wallet address\\r\\n    address public stakingRewardsWallet; // staking rewards wallet address\\r\\n\\r\\n    uint256 public marketingWalletFee; // marketing wallet fee\\r\\n    uint256 public liquidityWalletFee; // liquidity wallet fee\\r\\n    uint256 public techWalletFee; // tech wallet fee\\r\\n    uint256 public donationsWalletFee; // donations wallet fee\\r\\n    uint256 public stakingRewardsWalletFee; // staking rewards wallet fee\\r\\n\\r\\n    uint256 public maxTransactionAmount; // max transaction amount, can be 0 if no limit\\r\\n    uint256 public maxTransactionCoolDownAmount; // max transaction amount during cooldown\\r\\n\\r\\n    mapping(address => uint256) private _balances; // balances of token\\r\\n\\r\\n    mapping(address => mapping(address => uint256)) private _allowances; // allowances of token\\r\\n\\r\\n    uint256 private constant MAX = ~uint256(0); // max uint256\\r\\n\\r\\n    uint256 private _tradingStart; // trading start time\\r\\n    uint256 private _tradingStartCooldown; // trading start time during cooldown\\r\\n\\r\\n    bool private _checkingTokens; // checking tokens flag\\r\\n\\r\\n    TransferDetails private _lastTransfer; // last transfer details\\r\\n\\r\\n    mapping(address => uint256) private _lastCoolDownTrade; // last cooldown trade time\\r\\n    mapping(address => bool) public whiteList; // white list => excluded from fee\\r\\n    mapping(address => bool) public blackList; // black list => disable _transfer\\r\\n\\r\\n    bool private _inSwap;\\r\\n    bool public autoSellTax;\\r\\n\\r\\n    modifier tokenCheck() {\\r\\n        require(!_checkingTokens);\\r\\n        _checkingTokens = true;\\r\\n        _;\\r\\n        // By storing the original value once again, a refund is triggered (see\\r\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\r\\n        _checkingTokens = false;\\r\\n    }\\r\\n\\r\\n    modifier lockTheSwap() {\\r\\n        _inSwap = true;\\r\\n        _;\\r\\n        _inSwap = false;\\r\\n    }\\r\\n    \\r\\n    event TradingEnabled();\\r\\n    event RouterAddressUpdated(address prevAddress, address newAddress);\\r\\n    event MarketingWalletUpdated(address prevAddress, address newAddress);\\r\\n    event MarketingWalletFeeUpdated(uint256 prevFee, uint256 newFee);\\r\\n    event LiquidityWalletUpdated(address prevAddress, address newAddress);\\r\\n    event LiquidityWalletFeeUpdated(uint256 prevFee, uint256 newFee);\\r\\n    event TechWalletUpdated(address prevAddress, address newAddress);\\r\\n    event TechWalletFeeUpdated(uint256 prevFee, uint256 newFee);\\r\\n    event DonationsWalletUpdated(address prevAddress, address newAddress);\\r\\n    event DonationsWalletFeeUpdated(uint256 prevFee, uint256 newFee);\\r\\n    event StakingRewardsWalletUpdated(address prevAddress, address newAddress);\\r\\n    event StakingRewardsWalletFeeUpdated(uint256 prevFee, uint256 newFee);\\r\\n\\r\\n    event BuyFeeUpdated(uint256 prevValue, uint256 newValue);\\r\\n    event SellFeeUpdated(uint256 prevValue, uint256 newValue);\\r\\n    event TransferFeeUpdated(uint256 prevValue, uint256 newValue);\\r\\n\\r\\n    event AddClientsToWhiteList(address[] account);\\r\\n    event RemoveClientsFromWhiteList(address[] account);\\r\\n\\r\\n    event WithdrawTokens(uint256 amount);\\r\\n    event WithdrawAlienTokens(\\r\\n        address indexed token,\\r\\n        address indexed to,\\r\\n        uint256 amount\\r\\n    );\\r\\n    event WithdrawNativeTokens(address indexed to, uint256 amount);\\r\\n    event MaxTransactionAmountUpdated(uint256 prevValue, uint256 nextValue);\\r\\n    event MaxTransactionCoolDownAmountUpdated(\\r\\n        uint256 prevValue,\\r\\n        uint256 nextValue\\r\\n    );\\r\\n    event AddClientsToBlackList(address[] accounts);\\r\\n    event RemoveClientsFromBlackList(address[] accounts);\\r\\n\\r\\n    /**\\r\\n     * @param _routerAddress BSC MAIN 0x10ed43c718714eb63d5aa57b78b54704e256024e\\r\\n     * @param _routerAddress BSC TEST 0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3\\r\\n     **/\\r\\n    function initialize(address _routerAddress) external initializer {\\r\\n        require(\\r\\n            _routerAddress != address(0),\\r\\n            \\\"EG: routerAddress should not be the zero address\\\"\\r\\n        );\\r\\n\\r\\n        __Ownable_init();\\r\\n\\r\\n        _tradingStart = MAX; // trading start time\\r\\n        _tradingStartCooldown = MAX; // trading start time during cooldown\\r\\n\\r\\n        totalSupply = 6 * 10 ** 9 * 10 ** decimals; // total supply of token (6 billion)\\r\\n\\r\\n        maxTransactionCoolDownAmount = totalSupply / 1000; // 0.1% of total supply\\r\\n\\r\\n        buyFee = 5; // 5%\\r\\n        sellFee = 5; // 5%\\r\\n        transferFee = 0; // 0%\\r\\n\\r\\n        marketingWalletFee = 20; // 20%\\r\\n        liquidityWalletFee = 20; // 20%\\r\\n        techWalletFee = 30; // 30%\\r\\n        donationsWalletFee = 10; // 10%\\r\\n        stakingRewardsWalletFee = 20; // 20%\\r\\n\\r\\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(\\r\\n            _routerAddress\\r\\n        );\\r\\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\\r\\n            .createPair(address(this), _uniswapV2Router.WETH());\\r\\n        uniswapV2Router = _uniswapV2Router;\\r\\n\\r\\n        _balances[msg.sender] = totalSupply;\\r\\n\\r\\n        whiteList[owner()] = true;\\r\\n        whiteList[address(this)] = true;\\r\\n\\r\\n        emit Transfer(address(0), _msgSender(), totalSupply);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to receive ETH when msg.data is empty\\r\\n     * @dev Receives ETH from uniswapV2Router when swapping\\r\\n     **/\\r\\n    receive() external payable {}\\r\\n\\r\\n    /**\\r\\n     * @dev Fallback function to receive ETH when msg.data is not empty\\r\\n     **/\\r\\n    fallback() external payable {}\\r\\n\\r\\n    function transfer(\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external override returns (bool) {\\r\\n        _transfer(_msgSender(), recipient, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external override returns (bool) {\\r\\n        _transfer(sender, recipient, amount);\\r\\n        _approve(\\r\\n            sender,\\r\\n            _msgSender(),\\r\\n            _allowances[sender][_msgSender()] - amount\\r\\n        );\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function approve(\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) external override returns (bool) {\\r\\n        _approve(_msgSender(), spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function allowance(\\r\\n        address from,\\r\\n        address spender\\r\\n    ) external view override returns (uint256) {\\r\\n        return _allowances[from][spender];\\r\\n    }\\r\\n\\r\\n    function balanceOf(\\r\\n        address account\\r\\n    ) external view override returns (uint256) {\\r\\n        uint256 balance0 = _balanceOf(account);\\r\\n        return balance0;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param accounts list of clients to whitelist so they do not pay tax on buy or sell\\r\\n     *\\r\\n     * @dev exclude a wallet from paying tax\\r\\n     **/\\r\\n    function addClientsToWhiteList(\\r\\n        address[] calldata accounts\\r\\n    ) external onlyOwner {\\r\\n        for (uint256 i; i < accounts.length; i++) {\\r\\n            require(\\r\\n                accounts[i] != address(0),\\r\\n                \\\"EG: Zero address can't be added to whitelist\\\"\\r\\n            );\\r\\n        }\\r\\n\\r\\n        for (uint256 i; i < accounts.length; i++) {\\r\\n            if (!whiteList[accounts[i]]) {\\r\\n                whiteList[accounts[i]] = true;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        emit AddClientsToWhiteList(accounts);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param accounts list of clients to remove from whitelist so they start paying tax on buy or sell\\r\\n     *\\r\\n     * @dev include a wallet to pay tax\\r\\n     **/\\r\\n    function removeClientsFromWhiteList(\\r\\n        address[] calldata accounts\\r\\n    ) external onlyOwner {\\r\\n        for (uint256 i; i < accounts.length; i++) {\\r\\n            if (whiteList[accounts[i]]) {\\r\\n                whiteList[accounts[i]] = false;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        emit RemoveClientsFromWhiteList(accounts);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param accounts list of clients to add to blacklist (trading not allowed)\\r\\n     *\\r\\n     * @dev add clients to blacklist\\r\\n     **/\\r\\n    function addClientsToBlackList(\\r\\n        address[] calldata accounts\\r\\n    ) external onlyOwner {\\r\\n        for (uint256 i; i < accounts.length; i++) {\\r\\n            require(\\r\\n                accounts[i] != address(0),\\r\\n                \\\"EG: Zero address can't be added to blacklist\\\"\\r\\n            );\\r\\n        }\\r\\n\\r\\n        for (uint256 i; i < accounts.length; i++) {\\r\\n            if (!blackList[accounts[i]]) {\\r\\n                blackList[accounts[i]] = true;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        emit AddClientsToBlackList(accounts);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param accounts list to remove from blacklist\\r\\n     *\\r\\n     * @dev remove accounts from blacklist\\r\\n     **/\\r\\n    function removeClientsFromBlackList(\\r\\n        address[] calldata accounts\\r\\n    ) external onlyOwner {\\r\\n        for (uint256 i; i < accounts.length; i++) {\\r\\n            if (blackList[accounts[i]]) {\\r\\n                blackList[accounts[i]] = false;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        emit RemoveClientsFromBlackList(accounts);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev check trading enabled\\r\\n     *\\r\\n     **/\\r\\n    function isTradingEnabled() public view returns (bool) {\\r\\n        // Trading has been set and time buffer has elapsed\\r\\n        return _tradingStart < block.timestamp;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev check trading start cool down\\r\\n     *\\r\\n     **/\\r\\n    function inTradingStartCoolDown() public view returns (bool) {\\r\\n        // Trading has been started and the cool down period has elapsed\\r\\n        return _tradingStartCooldown >= block.timestamp;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param to receiver address\\r\\n     * @param from sender address\\r\\n     *\\r\\n     * @dev Multiple trades in same block from the same source are not allowed during trading start cooldown period\\r\\n     **/\\r\\n    function validateDuringTradingCoolDown(address to, address from) private {\\r\\n        address pair = uniswapV2Pair;\\r\\n        bool disallow;\\r\\n\\r\\n        // Disallow multiple same source trades in same block\\r\\n        if (from == pair) {\\r\\n            disallow =\\r\\n                _lastCoolDownTrade[to] == block.number ||\\r\\n                _lastCoolDownTrade[tx.origin] == block.number;\\r\\n            _lastCoolDownTrade[to] = block.number;\\r\\n            _lastCoolDownTrade[tx.origin] = block.number;\\r\\n        } else if (to == pair) {\\r\\n            disallow =\\r\\n                _lastCoolDownTrade[from] == block.number ||\\r\\n                _lastCoolDownTrade[tx.origin] == block.number;\\r\\n            _lastCoolDownTrade[from] = block.number;\\r\\n            _lastCoolDownTrade[tx.origin] = block.number;\\r\\n        }\\r\\n\\r\\n        require(\\r\\n            !disallow,\\r\\n            \\\"EG: Multiple trades in same block from the same source are not allowed during trading start cooldown\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param _tradeStartDelay trade delay (uint is minute)\\r\\n     * @param _tradeStartCoolDown cooldown delay (unit is minute)\\r\\n     *\\r\\n     * @dev This function can only be called once\\r\\n     **/\\r\\n    function setTradingEnabled(\\r\\n        uint256 _tradeStartDelay,\\r\\n        uint256 _tradeStartCoolDown\\r\\n    ) external onlyOwner {\\r\\n        require(\\r\\n            _tradeStartDelay < 10,\\r\\n            \\\"EG: tradeStartDelay should be less than 10 minutes\\\"\\r\\n        );\\r\\n        require(\\r\\n            _tradeStartCoolDown < 120,\\r\\n            \\\"EG: tradeStartCoolDown should be less than 120 minutes\\\"\\r\\n        );\\r\\n        require(\\r\\n            _tradeStartDelay < _tradeStartCoolDown,\\r\\n            \\\"EG: tradeStartDelay must be less than tradeStartCoolDown\\\"\\r\\n        );\\r\\n        // This can only be called once\\r\\n        require(\\r\\n            _tradingStart == MAX && _tradingStartCooldown == MAX,\\r\\n            \\\"EG: Trading has started already\\\"\\r\\n        );\\r\\n\\r\\n        _tradingStart = block.timestamp + _tradeStartDelay * 1 minutes;\\r\\n        _tradingStartCooldown = _tradingStart + _tradeStartCoolDown * 1 minutes;\\r\\n        // Announce to the blockchain immediately, even though trading\\r\\n        // can't start until delay passes (stop those sniping bots!)\\r\\n        emit TradingEnabled();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param routerAddress SWAP router address\\r\\n     *\\r\\n     * @dev set swap router address\\r\\n     **/\\r\\n    function setRouterAddress(address routerAddress) external onlyOwner {\\r\\n        require(\\r\\n            routerAddress != address(0),\\r\\n            \\\"routerAddress should not be the zero address\\\"\\r\\n        );\\r\\n\\r\\n        address prevAddress = address(uniswapV2Router);\\r\\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(routerAddress);\\r\\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).getPair(\\r\\n            address(this),\\r\\n            _uniswapV2Router.WETH()\\r\\n        );\\r\\n\\r\\n        uniswapV2Router = _uniswapV2Router;\\r\\n        emit RouterAddressUpdated(prevAddress, routerAddress);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param _wallet, marketing wallet address\\r\\n     *\\r\\n     * @dev set Marketing Wallet Address\\r\\n     **/\\r\\n    function setMarketingWallet(address _wallet) external onlyOwner {\\r\\n        require(\\r\\n            _wallet != address(0),\\r\\n            \\\"EG: The marketing wallet should not be the zero address\\\"\\r\\n        );\\r\\n\\r\\n        address prevAddress = marketingWallet;\\r\\n\\r\\n        marketingWallet = _wallet;\\r\\n        emit MarketingWalletUpdated(prevAddress, marketingWallet);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param _fee, marketing wallet fee\\r\\n     *\\r\\n     * @dev set Marketing Wallet fee percent\\r\\n     **/\\r\\n    function setMarketingWalletFee(uint256 _fee) external onlyOwner {\\r\\n        require(_fee <= 100, \\\"EG: The fee should be less than 100%\\\");\\r\\n\\r\\n        uint256 prevFee = marketingWalletFee;\\r\\n\\r\\n        marketingWalletFee = _fee;\\r\\n        emit MarketingWalletFeeUpdated(prevFee, marketingWalletFee);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param _wallet, liquidity wallet address\\r\\n     *\\r\\n     * @dev set Liquidity Wallet Address\\r\\n     **/\\r\\n    function setLiquidityWallet(address _wallet) external onlyOwner {\\r\\n        require(\\r\\n            _wallet != address(0),\\r\\n            \\\"EG: The liquidity wallet should not be the zero address\\\"\\r\\n        );\\r\\n\\r\\n        address prevAddress = liquidityWallet;\\r\\n\\r\\n        liquidityWallet = _wallet;\\r\\n        emit LiquidityWalletUpdated(prevAddress, liquidityWallet);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param _fee, liquidity wallet fee\\r\\n     *\\r\\n     * @dev set Liquidity Wallet fee percent\\r\\n     **/\\r\\n    function setLiquidityWalletFee(uint256 _fee) external onlyOwner {\\r\\n        require(_fee <= 100, \\\"EG: The fee should be less than 100%\\\");\\r\\n\\r\\n        uint256 prevFee = liquidityWalletFee;\\r\\n\\r\\n        liquidityWalletFee = _fee;\\r\\n        emit LiquidityWalletFeeUpdated(prevFee, liquidityWalletFee);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param _wallet, tech wallet address\\r\\n     *\\r\\n     * @dev set Tech Wallet Address\\r\\n     **/\\r\\n    function setTechWallet(address _wallet) external onlyOwner {\\r\\n        require(\\r\\n            _wallet != address(0),\\r\\n            \\\"EG: The tech wallet should not be the zero address\\\"\\r\\n        );\\r\\n\\r\\n        address prevAddress = techWallet;\\r\\n\\r\\n        techWallet = _wallet;\\r\\n\\r\\n        emit TechWalletUpdated(prevAddress, techWallet);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param _fee, tech wallet fee\\r\\n     *\\r\\n     * @dev set Tech Wallet fee percent\\r\\n     **/\\r\\n    function setTechWalletFee(uint256 _fee) external onlyOwner {\\r\\n        require(_fee <= 100, \\\"EG: The fee should be less than 100%\\\");\\r\\n\\r\\n        uint256 prevFee = techWalletFee;\\r\\n\\r\\n        techWalletFee = _fee;\\r\\n\\r\\n        emit TechWalletFeeUpdated(prevFee, techWalletFee);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param _wallet, donation wallet address\\r\\n     *\\r\\n     * @dev set Donation Wallet Address\\r\\n     **/\\r\\n    function setDonationsWallet(address _wallet) external onlyOwner {\\r\\n        require(\\r\\n            _wallet != address(0),\\r\\n            \\\"EG: The donation wallet should not be the zero address\\\"\\r\\n        );\\r\\n\\r\\n        address prevAddress = donationsWallet;\\r\\n\\r\\n        donationsWallet = _wallet;\\r\\n        emit DonationsWalletUpdated(prevAddress, donationsWallet);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param _fee, donation wallet fee\\r\\n     *\\r\\n     * @dev set Donation Wallet fee percent\\r\\n     **/\\r\\n    function setDonationsWalletFee(uint256 _fee) external onlyOwner {\\r\\n        require(_fee <= 100, \\\"EG: The fee should be less than 100%\\\");\\r\\n\\r\\n        uint256 prevFee = donationsWalletFee;\\r\\n\\r\\n        donationsWalletFee = _fee;\\r\\n        emit DonationsWalletFeeUpdated(prevFee, donationsWalletFee);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param _wallet, staking rewards wallet address\\r\\n     *\\r\\n     * @dev set Staking Rewards Wallet Address\\r\\n     **/\\r\\n    function setStakingRewardsWallet(address _wallet) external onlyOwner {\\r\\n        require(\\r\\n            _wallet != address(0),\\r\\n            \\\"EG: The staking wallet should not be the zero address\\\"\\r\\n        );\\r\\n\\r\\n        address prevAddress = stakingRewardsWallet;\\r\\n\\r\\n        stakingRewardsWallet = _wallet;\\r\\n        emit StakingRewardsWalletUpdated(prevAddress, stakingRewardsWallet);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param _fee, staking rewards fee\\r\\n     *\\r\\n     * @dev set Staking Reward Wallet fee percent\\r\\n     **/\\r\\n    function setStakingRewardsWalletFee(uint256 _fee) external onlyOwner {\\r\\n        require(_fee <= 100, \\\"EG: The fee should be less than 100%\\\");\\r\\n\\r\\n        uint256 prevFee = stakingRewardsWalletFee;\\r\\n\\r\\n        stakingRewardsWalletFee = _fee;\\r\\n        emit StakingRewardsWalletFeeUpdated(prevFee, stakingRewardsWalletFee);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param amount Max txn amount\\r\\n     *\\r\\n     * @dev Max Amount allowed per Buy/Sell/Transfer transaction\\r\\n     **/\\r\\n    function setMaxTransactionAmount(uint256 amount) external onlyOwner {\\r\\n        uint256 _prevAmount = maxTransactionAmount;\\r\\n        maxTransactionAmount = amount;\\r\\n\\r\\n        emit MaxTransactionAmountUpdated(_prevAmount, maxTransactionAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param amount Max cooldown txn amount\\r\\n     *\\r\\n     * @dev Max transaction amount allowed during cooldown period\\r\\n     **/\\r\\n    function setMaxTransactionCoolDownAmount(\\r\\n        uint256 amount\\r\\n    ) external onlyOwner {\\r\\n        require(amount > 0, \\\"EG: Amount should be a positive number.\\\");\\r\\n        if (maxTransactionAmount > 0) {\\r\\n            require(\\r\\n                amount < maxTransactionAmount,\\r\\n                \\\"EG: Amount should be less than maxTransactionAmount.\\\"\\r\\n            );\\r\\n        }\\r\\n\\r\\n        uint256 _prevAmount = maxTransactionCoolDownAmount;\\r\\n        maxTransactionCoolDownAmount = amount;\\r\\n\\r\\n        emit MaxTransactionCoolDownAmountUpdated(\\r\\n            _prevAmount,\\r\\n            maxTransactionCoolDownAmount\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param _auto Flag if auto sell tax or not\\r\\n     *\\r\\n     * @dev Set to auto sell tax or not\\r\\n     **/\\r\\n    function setAutoSellTax(bool _auto) external onlyOwner {\\r\\n        autoSellTax = _auto;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param _amount amount\\r\\n     *\\r\\n     * @dev calculate buy fee\\r\\n     **/\\r\\n    function calculateBuyFee(uint256 _amount) private view returns (uint256) {\\r\\n        return (_amount * buyFee) / 100;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param _amount amount\\r\\n     *\\r\\n     * @dev calculate sell fee\\r\\n     **/\\r\\n    function calculateSellFee(uint256 _amount) private view returns (uint256) {\\r\\n        return (_amount * sellFee) / 100;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param _amount amount\\r\\n     *\\r\\n     * @dev calculate transfer fee\\r\\n     **/\\r\\n    function calculateTransferFee(\\r\\n        uint256 _amount\\r\\n    ) private view returns (uint256) {\\r\\n        return (_amount * transferFee) / 100;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param _buyFee. Buy fee percent (0% ~ 99%)\\r\\n     *\\r\\n     **/\\r\\n    function setBuyFee(uint256 _buyFee) external onlyOwner {\\r\\n        require(_buyFee < 100, \\\"EG: buyFeeRate should be less than 100%\\\");\\r\\n\\r\\n        uint256 prevValue = buyFee;\\r\\n        buyFee = _buyFee;\\r\\n        emit BuyFeeUpdated(prevValue, buyFee);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param _sellFee. Sell fee percent (0% ~ 99%)\\r\\n     *\\r\\n     **/\\r\\n    function setSellFee(uint256 _sellFee) external onlyOwner {\\r\\n        require(_sellFee < 100, \\\"EG: sellFeeRate should be less than 100%\\\");\\r\\n\\r\\n        uint256 prevValue = sellFee;\\r\\n        sellFee = _sellFee;\\r\\n        emit SellFeeUpdated(prevValue, sellFee);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param _transferFee. Transfer fee pcercent (0% ~ 99%)\\r\\n     *\\r\\n     **/\\r\\n    function setTransferFee(uint256 _transferFee) external onlyOwner {\\r\\n        require(\\r\\n            _transferFee < 100,\\r\\n            \\\"EG: transferFeeRate should be less than 100%\\\"\\r\\n        );\\r\\n\\r\\n        uint256 prevValue = transferFee;\\r\\n        transferFee = _transferFee;\\r\\n        emit TransferFeeUpdated(prevValue, transferFee);\\r\\n    }\\r\\n\\r\\n    function _balanceOf(address account) private view returns (uint256) {\\r\\n        return _balances[account];\\r\\n    }\\r\\n\\r\\n    function _approve(\\r\\n        address _owner,\\r\\n        address _spender,\\r\\n        uint256 _amount\\r\\n    ) private {\\r\\n        require(_owner != address(0), \\\"ERC20: approve from the zero address\\\");\\r\\n        require(_spender != address(0), \\\"ERC20: approve to the zero address\\\");\\r\\n\\r\\n        _allowances[_owner][_spender] = _amount;\\r\\n        emit Approval(_owner, _spender, _amount);\\r\\n    }\\r\\n\\r\\n    function isEGPair(address _pair) public view returns (bool) {\\r\\n        bool _result;\\r\\n        if (_pair.token0() != address(0) && _pair.token1() != address(0)) {\\r\\n            if (\\r\\n                _pair.token0() == address(this) ||\\r\\n                _pair.token1() == address(this)\\r\\n            ) {\\r\\n                _result = true;\\r\\n            }\\r\\n        }\\r\\n        return _result;\\r\\n    }\\r\\n\\r\\n    function _transfer(address from, address to, uint256 amount) private {\\r\\n        require(\\r\\n            !blackList[from] || to == owner(), // allow blacklisted user to send token only to contract owner\\r\\n            \\\"EG: transfer from the blacklist address is not allowed\\\"\\r\\n        );\\r\\n        require(\\r\\n            !blackList[to],\\r\\n            \\\"EG: transfer to the blacklist address is not allowed\\\"\\r\\n        );\\r\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\r\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\r\\n        require(amount > 0, \\\"ERC20: Transfer amount must be greater than zero\\\");\\r\\n        require(\\r\\n            _balances[from] >= amount,\\r\\n            \\\"ERC20: tokens balance is insufficient\\\"\\r\\n        );\\r\\n        require(from != to, \\\"ERC20: Transfer to and from address are the same\\\");\\r\\n        require(\\r\\n            !inTokenCheck(),\\r\\n            \\\"Invalid reentrancy from token0/token1 balanceOf check\\\"\\r\\n        );\\r\\n\\r\\n        address _owner = owner();\\r\\n        bool isIgnoredAddress = from == _owner || to == _owner;\\r\\n\\r\\n        bool _isTradingEnabled = isTradingEnabled();\\r\\n\\r\\n        if (!(isIgnoredAddress || whiteList[from])) {\\r\\n            // allow whitelisted user to transfer unlimited tokens during cooldown.\\r\\n            if (inTradingStartCoolDown()) {\\r\\n                // cooldown\\r\\n                require(\\r\\n                    amount <= maxTransactionCoolDownAmount,\\r\\n                    \\\"EG: Transfer amount exceeds the maxTransactionCoolDownAmount\\\"\\r\\n                );\\r\\n            } else if (maxTransactionAmount > 0) {\\r\\n                // after cooldown\\r\\n                require(\\r\\n                    amount <= maxTransactionAmount,\\r\\n                    \\\"EG: Transfer amount exceeds the maxTransactionAmount\\\"\\r\\n                );\\r\\n            }\\r\\n        }\\r\\n\\r\\n        address _pair = uniswapV2Pair;\\r\\n        require(\\r\\n            _isTradingEnabled ||\\r\\n                isIgnoredAddress ||\\r\\n                (from != _pair && to != _pair),\\r\\n            \\\"EG: Trading is not enabled\\\"\\r\\n        );\\r\\n\\r\\n        if (\\r\\n            _isTradingEnabled && inTradingStartCoolDown() && !isIgnoredAddress\\r\\n        ) {\\r\\n            validateDuringTradingCoolDown(to, from);\\r\\n        }\\r\\n\\r\\n        uint256 takeFee = 0;\\r\\n\\r\\n        bool _isNotExcludeFee = !(whiteList[from] || whiteList[to]);\\r\\n\\r\\n        bool _isBuy = isEGPair(from);\\r\\n        bool _isSell = isEGPair(to);\\r\\n        if (_isNotExcludeFee) {\\r\\n            if (_isBuy) {\\r\\n                // liquidity ( buy / sell ) fee\\r\\n                takeFee = calculateBuyFee(amount);\\r\\n            } else if (_isSell) {\\r\\n                // liquidity ( buy / sell ) fee\\r\\n                takeFee = calculateSellFee(amount);\\r\\n            } else {\\r\\n                // transfer fee\\r\\n                takeFee = calculateTransferFee(amount);\\r\\n            }\\r\\n\\r\\n            uint256 swapAmount = min(_balanceOf(address(this)), amount);\\r\\n            if (autoSellTax && swapAmount > 0 && !_inSwap && _isSell) {\\r\\n                swapTokensForETH(swapAmount);\\r\\n            }\\r\\n        }\\r\\n        _tokenTransfer(from, to, amount, takeFee);\\r\\n    }\\r\\n\\r\\n    function min(uint256 a, uint256 b) private pure returns (uint256) {\\r\\n        return (a > b) ? b : a;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param amount amount\\r\\n     *\\r\\n     * @dev swap tax token on contract to ETH, add this ETH to contract balance\\r\\n     */\\r\\n    function swapTokensForETH(uint256 amount) private lockTheSwap {\\r\\n        address[] memory path = new address[](2);\\r\\n        path[0] = address(this);\\r\\n        path[1] = uniswapV2Router.WETH();\\r\\n        _approve(address(this), address(uniswapV2Router), amount);\\r\\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\\r\\n            amount,\\r\\n            0,\\r\\n            path,\\r\\n            address(this),\\r\\n            block.timestamp\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param sender sender\\r\\n     * @param recipient recipient\\r\\n     * @param amount amount\\r\\n     * @param takeFee fee\\r\\n     *\\r\\n     * @dev update balances of sender and receiver, add fee to contract balance\\r\\n     **/\\r\\n    function _tokenTransfer(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount,\\r\\n        uint256 takeFee\\r\\n    ) private {\\r\\n        uint256 senderBefore = _balances[sender];\\r\\n        uint256 senderAfter = senderBefore - amount;\\r\\n        _balances[sender] = senderAfter;\\r\\n\\r\\n        uint256 tTransferAmount = amount;\\r\\n\\r\\n        if (takeFee > 0) {\\r\\n            _balances[address(this)] = _balances[address(this)] + takeFee;\\r\\n            tTransferAmount = amount - takeFee;\\r\\n        }\\r\\n\\r\\n        uint256 recipientBefore = _balances[recipient];\\r\\n        uint256 recipientAfter = recipientBefore + tTransferAmount;\\r\\n        _balances[recipient] = recipientAfter;\\r\\n\\r\\n        emit Transfer(sender, recipient, tTransferAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev withdraw and distribute fee accumulated in smart contract to EG wallets\\r\\n     **/\\r\\n    function withdrawTokens() external onlyOwner {\\r\\n        uint256 amount = _balanceOf(address(this));\\r\\n        require(amount > 0, \\\"EG: There are no tokens to withdraw.\\\");\\r\\n        require(\\r\\n            marketingWalletFee +\\r\\n                liquidityWalletFee +\\r\\n                techWalletFee +\\r\\n                donationsWalletFee +\\r\\n                stakingRewardsWalletFee <=\\r\\n                100,\\r\\n            \\\"EG: Total Fees should not be greater than 100.\\\"\\r\\n        );\\r\\n        require(\\r\\n            marketingWallet != address(0),\\r\\n            \\\"EG: The Marketing wallet is not set.\\\"\\r\\n        );\\r\\n        require(\\r\\n            liquidityWallet != address(0),\\r\\n            \\\"EG: The Liquidity wallet is not set.\\\"\\r\\n        );\\r\\n        require(techWallet != address(0), \\\"EG: The Tech wallet is not set.\\\");\\r\\n        require(\\r\\n            donationsWallet != address(0),\\r\\n            \\\"EG: The Donations wallet is not set.\\\"\\r\\n        );\\r\\n        require(\\r\\n            stakingRewardsWallet != address(0),\\r\\n            \\\"EG: The Staking Rewards wallet is not set.\\\"\\r\\n        );\\r\\n\\r\\n        _transfer(\\r\\n            address(this),\\r\\n            marketingWallet,\\r\\n            (amount * marketingWalletFee) / 100\\r\\n        );\\r\\n        _transfer(\\r\\n            address(this),\\r\\n            liquidityWallet,\\r\\n            (amount * liquidityWalletFee) / 100\\r\\n        );\\r\\n        _transfer(address(this), techWallet, (amount * techWalletFee) / 100);\\r\\n        _transfer(\\r\\n            address(this),\\r\\n            donationsWallet,\\r\\n            (amount * donationsWalletFee) / 100\\r\\n        );\\r\\n        _transfer(\\r\\n            address(this),\\r\\n            stakingRewardsWallet,\\r\\n            (amount * stakingRewardsWalletFee) / 100\\r\\n        );\\r\\n\\r\\n        emit WithdrawTokens(amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param token token address\\r\\n     * @param to receive address\\r\\n     * @param amount token amount\\r\\n     *\\r\\n     * @dev Withdraw any tokens that are sent to the contract address\\r\\n     **/\\r\\n    function withdrawAlienTokens(\\r\\n        address token,\\r\\n        address payable to,\\r\\n        uint256 amount\\r\\n    ) external onlyOwner {\\r\\n        require(\\r\\n            token != address(0),\\r\\n            \\\"EG: The zero address should not be a token.\\\"\\r\\n        );\\r\\n        require(\\r\\n            to != address(0),\\r\\n            \\\"EG: The zero address should not be a transfer address.\\\"\\r\\n        );\\r\\n        require(\\r\\n            token != address(this),\\r\\n            \\\"EG: The token should not be the same as the contract address.\\\"\\r\\n        );\\r\\n\\r\\n        require(amount > 0, \\\"EG: Amount should be a postive number.\\\");\\r\\n        require(\\r\\n            IERC20(token).balanceOf(address(this)) >= amount,\\r\\n            \\\"EG: Out of balance.\\\"\\r\\n        );\\r\\n\\r\\n        IERC20Upgradeable(token).safeTransfer(to, amount);\\r\\n\\r\\n        emit WithdrawAlienTokens(token, to, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param to receive address\\r\\n     * @param amount token amount\\r\\n     *\\r\\n     * @dev You can withdraw native tokens (BNB) accumulated in the contract address\\r\\n     **/\\r\\n    function withdrawNativeTokens(\\r\\n        address payable to,\\r\\n        uint256 amount\\r\\n    ) external onlyOwner {\\r\\n        require(\\r\\n            to != address(0),\\r\\n            \\\"EG: The zero address should not be a transfer address.\\\"\\r\\n        );\\r\\n        require(amount > 0, \\\"EG: Amount should be a postive number.\\\");\\r\\n        require(\\r\\n            address(this).balance >= amount,\\r\\n            \\\"EG: Out of native token balance.\\\"\\r\\n        );\\r\\n\\r\\n        (bool success, ) = (to).call{value: amount}(\\\"\\\");\\r\\n        require(success, \\\"EG: Withdraw failed\\\");\\r\\n\\r\\n        emit WithdrawNativeTokens(to, amount);\\r\\n    }\\r\\n\\r\\n    function inTokenCheck() private view returns (bool) {\\r\\n        return _checkingTokens;\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"AddClientsToBlackList\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"account\",\"type\":\"address[]\"}],\"name\":\"AddClientsToWhiteList\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prevValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"BuyFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prevFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"DonationsWalletFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"prevAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"DonationsWalletUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prevFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"LiquidityWalletFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"prevAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"LiquidityWalletUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prevFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"MarketingWalletFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"prevAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"MarketingWalletUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prevValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nextValue\",\"type\":\"uint256\"}],\"name\":\"MaxTransactionAmountUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prevValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nextValue\",\"type\":\"uint256\"}],\"name\":\"MaxTransactionCoolDownAmountUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"RemoveClientsFromBlackList\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"account\",\"type\":\"address[]\"}],\"name\":\"RemoveClientsFromWhiteList\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"prevAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"RouterAddressUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prevValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"SellFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prevFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"StakingRewardsWalletFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"prevAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"StakingRewardsWalletUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prevFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"TechWalletFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"prevAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"TechWalletUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"TradingEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prevValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"TransferFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawAlienTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawNativeTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawTokens\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"addClientsToBlackList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"addClientsToWhiteList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoSellTax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"blackList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"donationsWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"donationsWalletFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inTradingStartCoolDown\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_routerAddress\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"}],\"name\":\"isEGPair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isTradingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityWalletFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingWalletFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTransactionAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTransactionCoolDownAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"removeClientsFromBlackList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"}],\"name\":\"removeClientsFromWhiteList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_auto\",\"type\":\"bool\"}],\"name\":\"setAutoSellTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_buyFee\",\"type\":\"uint256\"}],\"name\":\"setBuyFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"setDonationsWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setDonationsWalletFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"setLiquidityWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setLiquidityWalletFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"setMarketingWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setMarketingWalletFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMaxTransactionAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMaxTransactionCoolDownAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"routerAddress\",\"type\":\"address\"}],\"name\":\"setRouterAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_sellFee\",\"type\":\"uint256\"}],\"name\":\"setSellFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"setStakingRewardsWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setStakingRewardsWalletFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"setTechWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setTechWalletFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tradeStartDelay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tradeStartCoolDown\",\"type\":\"uint256\"}],\"name\":\"setTradingEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_transferFee\",\"type\":\"uint256\"}],\"name\":\"setTransferFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingRewardsWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingRewardsWalletFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"techWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"techWalletFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whiteList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawAlienTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawNativeTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "EG", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}