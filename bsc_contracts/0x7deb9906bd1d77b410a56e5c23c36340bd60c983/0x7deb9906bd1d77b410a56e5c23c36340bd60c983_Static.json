{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"../utils/Strings.sol\\\";\\nimport \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    function grantRole(bytes32 role, address account) external;\\n\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role, _msgSender());\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(uint160(account), 20),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\\n        _roles[role].adminRole = adminRole;\\n    }\\n\\n    function _grantRole(bytes32 role, address account) private {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    function _revokeRole(bytes32 role, address account) private {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AccessControl.sol\\\";\\nimport \\\"../utils/structs/EnumerableSet.sol\\\";\\n\\n/**\\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\\n */\\ninterface IAccessControlEnumerable {\\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\\n\\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\\n}\\n\\n/**\\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\\n */\\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) public view override returns (address) {\\n        return _roleMembers[role].at(index);\\n    }\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) public view override returns (uint256) {\\n        return _roleMembers[role].length();\\n    }\\n\\n    /**\\n     * @dev Overload {grantRole} to track enumerable memberships\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override {\\n        super.grantRole(role, account);\\n        _roleMembers[role].add(account);\\n    }\\n\\n    /**\\n     * @dev Overload {revokeRole} to track enumerable memberships\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override {\\n        super.revokeRole(role, account);\\n        _roleMembers[role].remove(account);\\n    }\\n\\n    /**\\n     * @dev Overload {renounceRole} to track enumerable memberships\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        super.renounceRole(role, account);\\n        _roleMembers[role].remove(account);\\n    }\\n\\n    /**\\n     * @dev Overload {_setupRole} to track enumerable memberships\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual override {\\n        super._setupRole(role, account);\\n        _roleMembers[role].add(account);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastvalue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastvalue;\\n                // Update the index for the moved value\\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/Interfaces/IMintableToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\ninterface IMintableToken {\\r\\n\\tfunction mint(address recipient_, uint256 amount_) external returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/Interfaces/IRebaseListener.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\ninterface IRebaseListener {\\r\\n\\tfunction tokenRebased(\\r\\n\\t\\taddress token,\\r\\n\\t\\tuint256 prevRebaseSupply,\\r\\n\\t\\tuint256 currentRebaseSupply,\\r\\n\\t\\tuint256 prevTotalSupply,\\r\\n\\t\\tuint256 currentTotalSupply\\r\\n\\t) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/Orchestrator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.4;\\r\\nimport '@openzeppelin/contracts/access/AccessControlEnumerable.sol';\\r\\nimport './Interfaces/IRebaseListener.sol';\\r\\n\\r\\ncontract Orchestrator is AccessControlEnumerable {\\r\\n\\tstruct Transaction {\\r\\n\\t\\tbool enabled;\\r\\n\\t\\taddress destination;\\r\\n\\t\\tbytes4 data;\\r\\n\\t}\\r\\n\\r\\n\\t// Transaction info that can be triggered after rebase\\r\\n\\tTransaction[] public transactions;\\r\\n\\r\\n\\t// Listeners than can be notified of a rebase\\r\\n\\tIRebaseListener[] public listeners;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Adds a transaction that gets called for a downstream receiver of rebases\\r\\n\\t * @param destination Address of contract destination\\r\\n\\t * @param data Transaction data payload\\r\\n\\t */\\r\\n\\tfunction addTransaction(address destination, string memory data)\\r\\n\\t\\texternal\\r\\n\\t\\tonlyRole(DEFAULT_ADMIN_ROLE)\\r\\n\\t{\\r\\n\\t\\trequire(transactions.length <= 10, 'Too many transactions');\\r\\n\\t\\tTransaction memory tran = Transaction({\\r\\n\\t\\t\\tenabled: true,\\r\\n\\t\\t\\tdestination: destination,\\r\\n\\t\\t\\tdata: bytes4(keccak256(bytes(data)))\\r\\n\\t\\t});\\r\\n\\t\\ttransactions.push(tran);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @param index Index of transaction to remove.\\r\\n\\t *              Transaction ordering may have changed since adding.\\r\\n\\t */\\r\\n\\tfunction removeTransaction(uint256 index)\\r\\n\\t\\texternal\\r\\n\\t\\tonlyRole(DEFAULT_ADMIN_ROLE)\\r\\n\\t{\\r\\n\\t\\trequire(index < transactions.length, 'index out of range');\\r\\n\\t\\tif (index < transactions.length - 1) {\\r\\n\\t\\t\\ttransactions[index] = transactions[transactions.length - 1];\\r\\n\\t\\t}\\r\\n\\t\\ttransactions.pop();\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @param index Index of transaction. Transaction ordering may have changed since adding.\\r\\n\\t * @param enabled True for enabled, false for disabled.\\r\\n\\t */\\r\\n\\tfunction setTransactionEnabled(uint256 index, bool enabled)\\r\\n\\t\\texternal\\r\\n\\t\\tonlyRole(DEFAULT_ADMIN_ROLE)\\r\\n\\t{\\r\\n\\t\\trequire(\\r\\n\\t\\t\\tindex < transactions.length,\\r\\n\\t\\t\\t'index must be in range of stored tx list'\\r\\n\\t\\t);\\r\\n\\t\\ttransactions[index].enabled = enabled;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @return Number of transactions, both enabled and disabled, in transactions list.\\r\\n\\t */\\r\\n\\tfunction transactionsSize() external view returns (uint256) {\\r\\n\\t\\treturn transactions.length;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Adds an address as IRebaseListener that gets called when a rebase happens\\r\\n\\t * @param listener Address of the listener contract\\r\\n\\t */\\r\\n\\tfunction addListener(IRebaseListener listener)\\r\\n\\t\\texternal\\r\\n\\t\\tonlyRole(DEFAULT_ADMIN_ROLE)\\r\\n\\t{\\r\\n\\t\\trequire(listeners.length <= 10, 'Too many listeners');\\r\\n\\r\\n\\t\\tfor (uint256 i = 0; i < listeners.length; i++) {\\r\\n\\t\\t\\trequire(listeners[i] != listener, 'Listener exists');\\r\\n\\t\\t}\\r\\n\\t\\tlisteners.push(listener);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Removes an address as IRebaseListener that gets called when a rebase happens\\r\\n\\t * @param listener Address of the listener contract\\r\\n\\t */\\r\\n\\tfunction removeListener(IRebaseListener listener)\\r\\n\\t\\texternal\\r\\n\\t\\tonlyRole(DEFAULT_ADMIN_ROLE)\\r\\n\\t{\\r\\n\\t\\tfor (uint256 i = 0; i < listeners.length; i++) {\\r\\n\\t\\t\\tif (listeners[i] == listener) {\\r\\n\\t\\t\\t\\tlisteners[i] = listeners[listeners.length - 1];\\r\\n\\t\\t\\t\\tlisteners.pop();\\r\\n\\t\\t\\t\\treturn;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\trevert('Listener not found');\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @return Number of listeners, in the listener list\\r\\n\\t */\\r\\n\\tfunction listenersSize() external view returns (uint256) {\\r\\n\\t\\treturn listeners.length;\\r\\n\\t}\\r\\n\\r\\n\\tfunction _notifyRebase(\\r\\n\\t\\tuint256 prevRebaseSupply,\\r\\n\\t\\tuint256 currentRebaseSupply,\\r\\n\\t\\tuint256 prevTotalSupply,\\r\\n\\t\\tuint256 currentTotalSupply\\r\\n\\t) internal {\\r\\n\\t\\tfor (uint256 i = 0; i < transactions.length; i++) {\\r\\n\\t\\t\\tTransaction storage t = transactions[i];\\r\\n\\t\\t\\tif (t.enabled) {\\r\\n\\t\\t\\t\\t_externalCall(t.destination, t.data);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfor (uint256 i = 0; i < listeners.length; i++) {\\r\\n\\t\\t\\tlisteners[i].tokenRebased(\\r\\n\\t\\t\\t\\taddress(this),\\r\\n\\t\\t\\t\\tprevRebaseSupply,\\r\\n\\t\\t\\t\\tcurrentRebaseSupply,\\r\\n\\t\\t\\t\\tprevTotalSupply,\\r\\n\\t\\t\\t\\tcurrentTotalSupply\\r\\n\\t\\t\\t);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t *  @dev wrapper to call the encoded transactions on downstream consumers.\\r\\n\\t *  @param destination Address of destination contract.\\r\\n\\t *  @param selector The selector of the function to be called.\\r\\n\\t */\\r\\n\\tfunction _externalCall(address destination, bytes4 selector) private {\\r\\n\\t\\t(bool success, bytes memory data) = destination.call(\\r\\n\\t\\t\\tabi.encodeWithSelector(selector)\\r\\n\\t\\t);\\r\\n\\t\\trequire(\\r\\n\\t\\t\\tsuccess && (data.length == 0 || abi.decode(data, (bool))),\\r\\n\\t\\t\\t'Orchestrator: Transaction Failed'\\r\\n\\t\\t);\\r\\n\\t}\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/lib/SafeMathint.sol\": {\r\n      \"content\": \"pragma solidity 0.8.4;\\r\\n\\r\\n/**\\r\\n * @title SafeMathInt\\r\\n * @dev Math operations for int256 with overflow safety checks.\\r\\n */\\r\\nlibrary SafeMathInt {\\r\\n\\tint256 private constant MIN_INT256 = int256(1) << 255;\\r\\n\\tint256 private constant MAX_INT256 = ~(int256(1) << 255);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Multiplies two int256 variables and fails on overflow.\\r\\n\\t */\\r\\n\\tfunction mul(int256 a, int256 b) internal pure returns (int256) {\\r\\n\\t\\tint256 c = a * b;\\r\\n\\r\\n\\t\\t// Detect overflow when multiplying MIN_INT256 with -1\\r\\n\\t\\trequire(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));\\r\\n\\t\\trequire((b == 0) || (c / b == a));\\r\\n\\t\\treturn c;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Division of two int256 variables and fails on overflow.\\r\\n\\t */\\r\\n\\tfunction div(int256 a, int256 b) internal pure returns (int256) {\\r\\n\\t\\t// Prevent overflow when dividing MIN_INT256 by -1\\r\\n\\t\\trequire(b != -1 || a != MIN_INT256);\\r\\n\\r\\n\\t\\t// Solidity already throws when dividing by 0.\\r\\n\\t\\treturn a / b;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Subtracts two int256 variables and fails on overflow.\\r\\n\\t */\\r\\n\\tfunction sub(int256 a, int256 b) internal pure returns (int256) {\\r\\n\\t\\tint256 c = a - b;\\r\\n\\t\\trequire((b >= 0 && c <= a) || (b < 0 && c > a));\\r\\n\\t\\treturn c;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Adds two int256 variables and fails on overflow.\\r\\n\\t */\\r\\n\\tfunction add(int256 a, int256 b) internal pure returns (int256) {\\r\\n\\t\\tint256 c = a + b;\\r\\n\\t\\trequire((b >= 0 && c >= a) || (b < 0 && c < a));\\r\\n\\t\\treturn c;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Converts to absolute value, and fails on overflow.\\r\\n\\t */\\r\\n\\tfunction abs(int256 a) internal pure returns (int256) {\\r\\n\\t\\trequire(a != MIN_INT256);\\r\\n\\t\\treturn a < 0 ? -a : a;\\r\\n\\t}\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/static.sol\": {\r\n      \"content\": \"pragma solidity 0.8.4;\\r\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\r\\nimport '@openzeppelin/contracts/access/AccessControlEnumerable.sol';\\r\\nimport '@openzeppelin/contracts/utils/math/SafeMath.sol';\\r\\nimport './lib/SafeMathint.sol';\\r\\nimport './Interfaces/IMintableToken.sol';\\r\\nimport './Orchestrator.sol';\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the {IERC20} interface.\\r\\n *\\r\\n * This implementation is agnostic to the way tokens are created. This means\\r\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\r\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\r\\n *\\r\\n * TIP: For a detailed writeup see our guide\\r\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\r\\n * to implement supply mechanisms].\\r\\n *\\r\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\r\\n * of returning `false` on failure. This behavior is nonetheless conventional\\r\\n * and does not conflict with the expectations of ERC20 applications.\\r\\n *\\r\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\r\\n * This allows applications to reconstruct the allowance for all accounts just\\r\\n * by listening to said events. Other implementations of the EIP may not emit\\r\\n * these events, as it isn't required by the specification.\\r\\n *\\r\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\r\\n * functions have been added to mitigate the well-known issues around setting\\r\\n * allowances. See {IERC20-approve}.\\r\\n */\\r\\ncontract Static is Context, IERC20, Orchestrator, IMintableToken {\\r\\n\\tusing SafeMath for uint256;\\r\\n\\tusing SafeMathInt for int256;\\r\\n\\r\\n\\tbytes32 public constant rebaserRole = keccak256('rebaser');\\r\\n\\tbytes32 public constant minterRole = keccak256('minter');\\r\\n\\tbytes32 public constant excluderRole = keccak256('excluder');\\r\\n\\r\\n\\tuint256 private constant MAX_UINT256 = ~uint256(0);\\r\\n\\tuint256 private constant MAX_SUPPLY = ~uint128(0);\\r\\n\\tuint256 private constant INITIAL_FRAGMENTS_SUPPLY = 0; // = 100 * 10**10 * (10**18);\\r\\n\\tuint256 public TOTAL_GONS;\\r\\n\\tuint256 private _gonsPerFragment = 10**18;\\r\\n\\r\\n\\tbool public rebaseAllowed = true;\\r\\n\\r\\n\\tmapping(address => uint256) private _balances;\\r\\n\\r\\n\\tmapping(address => mapping(address => uint256)) private _allowances;\\r\\n\\r\\n\\tmapping(address => bool) private _isExcluded;\\r\\n\\taddress[] public excluded;\\r\\n\\r\\n\\tuint256 private _totalSupply;\\r\\n\\tstring private _name;\\r\\n\\tstring private _symbol;\\r\\n\\tuint8 private _decimals;\\r\\n\\r\\n\\tevent LogRebase(uint256 indexed epoch, uint256 totalSupply);\\r\\n\\tevent GrantExclusion(address indexed account);\\r\\n\\tevent RevokeExclusion(address indexed account);\\r\\n\\r\\n\\tfunction disableRebase() external onlyRole(DEFAULT_ADMIN_ROLE) {\\r\\n\\t\\trebaseAllowed = false;\\r\\n\\t}\\r\\n\\r\\n\\tfunction rebase(uint256 epoch, int256 supplyDelta)\\r\\n\\t\\texternal\\r\\n\\t\\tonlyRole(rebaserRole)\\r\\n\\t\\treturns (uint256)\\r\\n\\t{\\r\\n\\t\\trequire(rebaseAllowed, 'Rebase is not allowed');\\r\\n\\t\\tuint256 prevRebaseSupply = rebaseSupply();\\r\\n\\t\\tuint256 prevTotalSupply = _totalSupply;\\r\\n\\r\\n\\t\\tuint256 total = _rebase(supplyDelta);\\r\\n\\r\\n\\t\\temit LogRebase(epoch, total);\\r\\n\\r\\n\\t\\t//notify downstream consumers about rebase\\r\\n\\t\\t_notifyRebase(\\r\\n\\t\\t\\tprevRebaseSupply,\\r\\n\\t\\t\\trebaseSupply(),\\r\\n\\t\\t\\tprevTotalSupply,\\r\\n\\t\\t\\t_totalSupply\\r\\n\\t\\t);\\r\\n\\r\\n\\t\\treturn total;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\r\\n\\t * a default value of 18.\\r\\n\\t *\\r\\n\\t * To select a different value for {decimals}, use {_setupDecimals}.\\r\\n\\t *\\r\\n\\t * All three of these values are immutable: they can only be set once during\\r\\n\\t * construction.\\r\\n\\t */\\r\\n\\tconstructor(string memory name_, string memory symbol_) {\\r\\n\\t\\t_name = name_;\\r\\n\\t\\t_symbol = symbol_;\\r\\n\\t\\t_decimals = 18;\\r\\n\\t\\t_totalSupply = INITIAL_FRAGMENTS_SUPPLY;\\r\\n\\t\\t//_balances[msg.sender] = TOTAL_GONS;\\r\\n\\t\\t//_gonsPerFragment = 0;  //TOTAL_GONS.div(_totalSupply);\\r\\n\\t\\t_setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Returns the name of the token.\\r\\n\\t */\\r\\n\\tfunction name() external view returns (string memory) {\\r\\n\\t\\treturn _name;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Returns the symbol of the token, usually a shorter version of the\\r\\n\\t * name.\\r\\n\\t */\\r\\n\\tfunction symbol() external view returns (string memory) {\\r\\n\\t\\treturn _symbol;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Returns the number of decimals used to get its user representation.\\r\\n\\t * For example, if `decimals` equals `2`, a balance of `505` tokens should\\r\\n\\t * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\r\\n\\t *\\r\\n\\t * Tokens usually opt for a value of 18, imitating the relationship between\\r\\n\\t * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\r\\n\\t * called.\\r\\n\\t *\\r\\n\\t * NOTE: This information is only used for _display_ purposes: it in\\r\\n\\t * no way affects any of the arithmetic of the contract, including\\r\\n\\t * {IERC20-balanceOf} and {IERC20-transfer}.\\r\\n\\t */\\r\\n\\tfunction decimals() external view returns (uint8) {\\r\\n\\t\\treturn _decimals;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev See {IERC20-totalSupply}.\\r\\n\\t */\\r\\n\\tfunction totalSupply() public view override returns (uint256) {\\r\\n\\t\\treturn _totalSupply;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Exposes the supply available for rebasing. Essentially this is total supply minus excluded accounts\\r\\n\\t * @return rebaseSupply The supply available for rebase\\r\\n\\t */\\r\\n\\tfunction rebaseSupply() public view returns (uint256) {\\r\\n\\t\\tuint256 excludedSupply = 0;\\r\\n\\t\\tfor (uint256 i = 0; i < excluded.length; i++) {\\r\\n\\t\\t\\texcludedSupply = excludedSupply.add(balanceOf(excluded[i]));\\r\\n\\t\\t}\\r\\n\\t\\treturn _totalSupply.sub(excludedSupply);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev See {IERC20-balanceOf}.\\r\\n\\t */\\r\\n\\tfunction balanceOf(address account) public view override returns (uint256) {\\r\\n\\t\\tif (_gonsPerFragment == 0) return 0;\\r\\n\\t\\treturn _balances[account].div(_gonsPerFragment);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev See {IERC20-transfer}.\\r\\n\\t *\\r\\n\\t * Requirements:\\r\\n\\t *\\r\\n\\t * - `recipient` cannot be the zero address.\\r\\n\\t * - the caller must have a balance of at least `amount`.\\r\\n\\t */\\r\\n\\tfunction transfer(address recipient, uint256 amount)\\r\\n\\t\\tpublic\\r\\n\\t\\tvirtual\\r\\n\\t\\toverride\\r\\n\\t\\treturns (bool)\\r\\n\\t{\\r\\n\\t\\t_transfer(_msgSender(), recipient, amount);\\r\\n\\t\\treturn true;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev See {IERC20-allowance}.\\r\\n\\t */\\r\\n\\tfunction allowance(address owner, address spender)\\r\\n\\t\\tpublic\\r\\n\\t\\tview\\r\\n\\t\\tvirtual\\r\\n\\t\\toverride\\r\\n\\t\\treturns (uint256)\\r\\n\\t{\\r\\n\\t\\treturn _allowances[owner][spender];\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev See {IERC20-approve}.\\r\\n\\t *\\r\\n\\t * Requirements:\\r\\n\\t *\\r\\n\\t * - `spender` cannot be the zero address.\\r\\n\\t */\\r\\n\\tfunction approve(address spender, uint256 amount)\\r\\n\\t\\tpublic\\r\\n\\t\\tvirtual\\r\\n\\t\\toverride\\r\\n\\t\\treturns (bool)\\r\\n\\t{\\r\\n\\t\\t_approve(_msgSender(), spender, amount);\\r\\n\\t\\treturn true;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev See {IERC20-transferFrom}.\\r\\n\\t *\\r\\n\\t * Emits an {Approval} event indicating the updated allowance. This is not\\r\\n\\t * required by the EIP. See the note at the beginning of {ERC20}.\\r\\n\\t *\\r\\n\\t * Requirements:\\r\\n\\t *\\r\\n\\t * - `sender` and `recipient` cannot be the zero address.\\r\\n\\t * - `sender` must have a balance of at least `amount`.\\r\\n\\t * - the caller must have allowance for ``sender``'s tokens of at least\\r\\n\\t * `amount`.\\r\\n\\t */\\r\\n\\tfunction transferFrom(\\r\\n\\t\\taddress sender,\\r\\n\\t\\taddress recipient,\\r\\n\\t\\tuint256 amount\\r\\n\\t) public virtual override returns (bool) {\\r\\n\\t\\t_transfer(sender, recipient, amount);\\r\\n\\t\\t_approve(\\r\\n\\t\\t\\tsender,\\r\\n\\t\\t\\t_msgSender(),\\r\\n\\t\\t\\t_allowances[sender][_msgSender()].sub(\\r\\n\\t\\t\\t\\tamount,\\r\\n\\t\\t\\t\\t'ERC20: transfer amount exceeds allowance'\\r\\n\\t\\t\\t)\\r\\n\\t\\t);\\r\\n\\t\\treturn true;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Atomically increases the allowance granted to `spender` by the caller.\\r\\n\\t *\\r\\n\\t * This is an alternative to {approve} that can be used as a mitigation for\\r\\n\\t * problems described in {IERC20-approve}.\\r\\n\\t *\\r\\n\\t * Emits an {Approval} event indicating the updated allowance.\\r\\n\\t *\\r\\n\\t * Requirements:\\r\\n\\t *\\r\\n\\t * - `spender` cannot be the zero address.\\r\\n\\t */\\r\\n\\tfunction increaseAllowance(address spender, uint256 addedValue)\\r\\n\\t\\texternal\\r\\n\\t\\tvirtual\\r\\n\\t\\treturns (bool)\\r\\n\\t{\\r\\n\\t\\t_approve(\\r\\n\\t\\t\\t_msgSender(),\\r\\n\\t\\t\\tspender,\\r\\n\\t\\t\\t_allowances[_msgSender()][spender].add(addedValue)\\r\\n\\t\\t);\\r\\n\\t\\treturn true;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Atomically decreases the allowance granted to `spender` by the caller.\\r\\n\\t *\\r\\n\\t * This is an alternative to {approve} that can be used as a mitigation for\\r\\n\\t * problems described in {IERC20-approve}.\\r\\n\\t *\\r\\n\\t * Emits an {Approval} event indicating the updated allowance.\\r\\n\\t *\\r\\n\\t * Requirements:\\r\\n\\t *\\r\\n\\t * - `spender` cannot be the zero address.\\r\\n\\t * - `spender` must have allowance for the caller of at least\\r\\n\\t * `subtractedValue`.\\r\\n\\t */\\r\\n\\tfunction decreaseAllowance(address spender, uint256 subtractedValue)\\r\\n\\t\\texternal\\r\\n\\t\\tvirtual\\r\\n\\t\\treturns (bool)\\r\\n\\t{\\r\\n\\t\\t_approve(\\r\\n\\t\\t\\t_msgSender(),\\r\\n\\t\\t\\tspender,\\r\\n\\t\\t\\t_allowances[_msgSender()][spender].sub(\\r\\n\\t\\t\\t\\tsubtractedValue,\\r\\n\\t\\t\\t\\t'ERC20: decreased allowance below zero'\\r\\n\\t\\t\\t)\\r\\n\\t\\t);\\r\\n\\t\\treturn true;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Moves tokens `amount` from `sender` to `recipient`.\\r\\n\\t *\\r\\n\\t * This is internal function is equivalent to {transfer}, and can be used to\\r\\n\\t * e.g. implement automatic token fees, slashing mechanisms, etc.\\r\\n\\t *\\r\\n\\t * Emits a {Transfer} event.\\r\\n\\t *\\r\\n\\t * Requirements:\\r\\n\\t *\\r\\n\\t * - `sender` cannot be the zero address.\\r\\n\\t * - `recipient` cannot be the zero address.\\r\\n\\t * - `sender` must have a balance of at least `amount`.\\r\\n\\t */\\r\\n\\tfunction _transfer(\\r\\n\\t\\taddress sender,\\r\\n\\t\\taddress recipient,\\r\\n\\t\\tuint256 amount\\r\\n\\t) internal virtual {\\r\\n\\t\\trequire(sender != address(0), 'ERC20: transfer from the zero address');\\r\\n\\t\\trequire(recipient != address(0), 'ERC20: transfer to the zero address');\\r\\n\\r\\n\\t\\t// _beforeTokenTransfer(sender, recipient, amount);\\r\\n\\r\\n\\t\\tuint256 gonValue = amount.mul(_gonsPerFragment);\\r\\n\\t\\t_balances[sender] = _balances[sender].sub(\\r\\n\\t\\t\\tgonValue,\\r\\n\\t\\t\\t'ERC20: transfer amount exceeds balance'\\r\\n\\t\\t);\\r\\n\\t\\t_balances[recipient] = _balances[recipient].add(gonValue);\\r\\n\\t\\temit Transfer(sender, recipient, amount);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\r\\n\\t *\\r\\n\\t * This internal function is equivalent to `approve`, and can be used to\\r\\n\\t * e.g. set automatic allowances for certain subsystems, etc.\\r\\n\\t *\\r\\n\\t * Emits an {Approval} event.\\r\\n\\t *\\r\\n\\t * Requirements:\\r\\n\\t *\\r\\n\\t * - `owner` cannot be the zero address.\\r\\n\\t * - `spender` cannot be the zero address.\\r\\n\\t */\\r\\n\\tfunction _approve(\\r\\n\\t\\taddress owner,\\r\\n\\t\\taddress spender,\\r\\n\\t\\tuint256 amount\\r\\n\\t) internal virtual {\\r\\n\\t\\trequire(owner != address(0), 'ERC20: approve from the zero address');\\r\\n\\t\\trequire(spender != address(0), 'ERC20: approve to the zero address');\\r\\n\\r\\n\\t\\t_allowances[owner][spender] = amount;\\r\\n\\t\\temit Approval(owner, spender, amount);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Notifies Fragments contract about a new rebase cycle.\\r\\n\\t * @param supplyDelta The number of new fragment tokens to add into circulation via expansion.\\r\\n\\t * Return The total number of fragments after the supply adjustment.\\r\\n\\t */\\r\\n\\tfunction _rebase(int256 supplyDelta) internal virtual returns (uint256) {\\r\\n\\t\\t// if supply delta is 0 nothing to rebase\\r\\n\\t\\t// if rebaseSupply is 0 nothing can be rebased\\r\\n\\t\\tif (supplyDelta == 0 || rebaseSupply() == 0) {\\r\\n\\t\\t\\treturn _totalSupply;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tuint256[] memory excludedBalances = _burnExcludedAccountTokens();\\r\\n\\r\\n\\t\\tif (supplyDelta < 0) {\\r\\n\\t\\t\\t_totalSupply = _totalSupply.sub(uint256(supplyDelta.abs()));\\r\\n\\t\\t} else {\\r\\n\\t\\t\\t_totalSupply = _totalSupply.add(uint256(supplyDelta));\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (_totalSupply > MAX_SUPPLY) {\\r\\n\\t\\t\\t_totalSupply = MAX_SUPPLY;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t_gonsPerFragment = TOTAL_GONS.div(_totalSupply);\\r\\n\\r\\n\\t\\t_mintExcludedAccountTokens(excludedBalances);\\r\\n\\r\\n\\t\\treturn _totalSupply;\\r\\n\\t}\\r\\n\\r\\n\\tfunction mint(address recipient_, uint256 amount_)\\r\\n\\t\\texternal\\r\\n\\t\\toverride\\r\\n\\t\\tonlyRole(minterRole)\\r\\n\\t\\treturns (bool)\\r\\n\\t{\\r\\n\\t\\tuint256 balanceBefore = balanceOf(recipient_);\\r\\n\\t\\t_mint(recipient_, amount_, true);\\r\\n\\t\\tuint256 balanceAfter = balanceOf(recipient_);\\r\\n\\t\\treturn balanceAfter > balanceBefore;\\r\\n\\t}\\r\\n\\r\\n\\tfunction _mint(\\r\\n\\t\\taddress recipient_,\\r\\n\\t\\tuint256 amount_,\\r\\n\\t\\tbool emitEvent\\r\\n\\t) private {\\r\\n\\t\\trequire(\\r\\n\\t\\t\\trecipient_ != address(0),\\r\\n\\t\\t\\t'ERC20: transfer to the zero address'\\r\\n\\t\\t);\\r\\n\\t\\trequire(amount_ > 0, \\\"ERC20: Can't mint 0 tokens\\\");\\r\\n\\r\\n\\t\\tTOTAL_GONS = TOTAL_GONS.add(_gonsPerFragment.mul(amount_));\\r\\n\\t\\t_totalSupply = _totalSupply.add(amount_);\\r\\n\\r\\n\\t\\t_balances[recipient_] = _balances[recipient_].add(\\r\\n\\t\\t\\tamount_.mul(_gonsPerFragment)\\r\\n\\t\\t);\\r\\n\\r\\n\\t\\tif (emitEvent) emit Transfer(address(0), recipient_, amount_);\\r\\n\\t}\\r\\n\\r\\n\\tfunction burnFrom(address account, uint256 amount) external virtual {\\r\\n\\t\\tuint256 currentAllowance = allowance(account, _msgSender());\\r\\n\\t\\trequire(\\r\\n\\t\\t\\tcurrentAllowance >= amount,\\r\\n\\t\\t\\t'ERC20: burn amount exceeds allowance'\\r\\n\\t\\t);\\r\\n\\t\\tunchecked {\\r\\n\\t\\t\\t_approve(account, _msgSender(), currentAllowance - amount);\\r\\n\\t\\t}\\r\\n\\t\\t_burn(account, amount, true);\\r\\n\\t}\\r\\n\\r\\n\\tfunction _burn(\\r\\n\\t\\taddress account,\\r\\n\\t\\tuint256 amount,\\r\\n\\t\\tbool emitEvent\\r\\n\\t) internal virtual {\\r\\n\\t\\trequire(account != address(0), 'ERC20: burn from the zero address');\\r\\n\\r\\n\\t\\tuint256 accountBalance = _balances[account];\\r\\n\\t\\trequire(\\r\\n\\t\\t\\taccountBalance >= amount.mul(_gonsPerFragment),\\r\\n\\t\\t\\t'ERC20: burn amount exceeds balance'\\r\\n\\t\\t);\\r\\n\\t\\tunchecked {\\r\\n\\t\\t\\t_balances[account] = _balances[account].sub(\\r\\n\\t\\t\\t\\tamount.mul(_gonsPerFragment)\\r\\n\\t\\t\\t);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tTOTAL_GONS = TOTAL_GONS.sub(_gonsPerFragment.mul(amount));\\r\\n\\t\\t_totalSupply = _totalSupply.sub(amount);\\r\\n\\r\\n\\t\\tif (emitEvent) {\\r\\n\\t\\t\\temit Transfer(account, address(0), amount);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/* ========== EXCLUSION LIST FUNCTIONS ========== */\\r\\n\\r\\n\\tfunction isExcluded(address account) external view returns (bool) {\\r\\n\\t\\treturn _isExcluded[account];\\r\\n\\t}\\r\\n\\r\\n\\tfunction numExcluded() external view returns (uint256) {\\r\\n\\t\\treturn excluded.length;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Grant an exclusion from rebases\\r\\n\\t * @param account The account to grant exclusion\\r\\n\\t *\\r\\n\\t * Requirements:\\r\\n\\t *\\r\\n\\t * - `account` must NOT already be excluded.\\r\\n\\t * - can only be called by `excluderRole`\\r\\n\\t */\\r\\n\\tfunction grantRebaseExclusion(address account)\\r\\n\\t\\texternal\\r\\n\\t\\tonlyRole(excluderRole)\\r\\n\\t{\\r\\n\\t\\trequire(!_isExcluded[account], 'Account is already excluded');\\r\\n\\t\\trequire(excluded.length <= 100, 'Too many excluded accounts');\\r\\n\\t\\t_isExcluded[account] = true;\\r\\n\\t\\texcluded.push(account);\\r\\n\\t\\temit GrantExclusion(account);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Revokes an exclusion from rebases\\r\\n\\t * @param account The account to revoke\\r\\n\\t *\\r\\n\\t * Requirements:\\r\\n\\t *\\r\\n\\t * - `account` must already be excluded.\\r\\n\\t * - can only be called by `excluderRole`\\r\\n\\t */\\r\\n\\tfunction revokeRebaseExclusion(address account)\\r\\n\\t\\texternal\\r\\n\\t\\tonlyRole(excluderRole)\\r\\n\\t{\\r\\n\\t\\trequire(_isExcluded[account], 'Account is not already excluded');\\r\\n\\t\\tfor (uint256 i = 0; i < excluded.length; i++) {\\r\\n\\t\\t\\tif (excluded[i] == account) {\\r\\n\\t\\t\\t\\texcluded[i] = excluded[excluded.length - 1];\\r\\n\\t\\t\\t\\t_isExcluded[account] = false;\\r\\n\\t\\t\\t\\texcluded.pop();\\r\\n\\t\\t\\t\\temit RevokeExclusion(account);\\r\\n\\t\\t\\t\\treturn;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Burns all tokens from excluded accounts\\r\\n\\t * @return excludedBalances The excluded account balances before burn\\r\\n\\t */\\r\\n\\tfunction _burnExcludedAccountTokens()\\r\\n\\t\\tprivate\\r\\n\\t\\treturns (uint256[] memory excludedBalances)\\r\\n\\t{\\r\\n\\t\\texcludedBalances = new uint256[](excluded.length);\\r\\n\\t\\tfor (uint256 i = 0; i < excluded.length; i++) {\\r\\n\\t\\t\\taddress account = excluded[i];\\r\\n\\t\\t\\tuint256 balance = balanceOf(account);\\r\\n\\t\\t\\texcludedBalances[i] = balance;\\r\\n\\t\\t\\tif (balance > 0) _burn(account, balance, false);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn excludedBalances;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Mints tokens to excluded accounts\\r\\n\\t * @param excludedBalances The amount of tokens to mint per address\\r\\n\\t */\\r\\n\\tfunction _mintExcludedAccountTokens(uint256[] memory excludedBalances)\\r\\n\\t\\tprivate\\r\\n\\t{\\r\\n\\t\\tfor (uint256 i = 0; i < excluded.length; i++) {\\r\\n\\t\\t\\tif (excludedBalances[i] > 0)\\r\\n\\t\\t\\t\\t_mint(excluded[i], excludedBalances[i], false);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"GrantExclusion\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"name\":\"LogRebase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"RevokeExclusion\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOTAL_GONS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IRebaseListener\",\"name\":\"listener\",\"type\":\"address\"}],\"name\":\"addListener\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"data\",\"type\":\"string\"}],\"name\":\"addTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableRebase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"excluded\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"excluderRole\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRoleMember\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleMemberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRebaseExclusion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcluded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"listeners\",\"outputs\":[{\"internalType\":\"contract IRebaseListener\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"listenersSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minterRole\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numExcluded\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"supplyDelta\",\"type\":\"int256\"}],\"name\":\"rebase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebaseAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebaseSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebaserRole\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IRebaseListener\",\"name\":\"listener\",\"type\":\"address\"}],\"name\":\"removeListener\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"removeTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRebaseExclusion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setTransactionEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transactions\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"data\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transactionsSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Static", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000006537461746963000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000065374617469630000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}