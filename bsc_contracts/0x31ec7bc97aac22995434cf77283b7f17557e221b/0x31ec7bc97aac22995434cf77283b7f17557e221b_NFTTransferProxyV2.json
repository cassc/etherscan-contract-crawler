{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/extensions/draft-ERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./draft-IERC20Permit.sol\\\";\\nimport \\\"../ERC20.sol\\\";\\nimport \\\"../../../utils/cryptography/draft-EIP712.sol\\\";\\nimport \\\"../../../utils/cryptography/ECDSA.sol\\\";\\nimport \\\"../../../utils/Counters.sol\\\";\\n\\n/**\\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * _Available since v3.4._\\n */\\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\\n    using Counters for Counters.Counter;\\n\\n    mapping(address => Counters.Counter) private _nonces;\\n\\n    // solhint-disable-next-line var-name-mixedcase\\n    bytes32 private constant _PERMIT_TYPEHASH =\\n        keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    /**\\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\\n     * to reserve a slot.\\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\\n     */\\n    // solhint-disable-next-line var-name-mixedcase\\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\\n\\n    /**\\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\\\"1\\\"`.\\n     *\\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\\n     */\\n    constructor(string memory name) EIP712(name, \\\"1\\\") {}\\n\\n    /**\\n     * @dev See {IERC20Permit-permit}.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"ERC20Permit: expired deadline\\\");\\n\\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\\n\\n        bytes32 hash = _hashTypedDataV4(structHash);\\n\\n        address signer = ECDSA.recover(hash, v, r, s);\\n        require(signer == owner, \\\"ERC20Permit: invalid signature\\\");\\n\\n        _approve(owner, spender, value);\\n    }\\n\\n    /**\\n     * @dev See {IERC20Permit-nonces}.\\n     */\\n    function nonces(address owner) public view virtual override returns (uint256) {\\n        return _nonces[owner].current();\\n    }\\n\\n    /**\\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\\n        return _domainSeparatorV4();\\n    }\\n\\n    /**\\n     * @dev \\\"Consume a nonce\\\": return the current value and increment.\\n     *\\n     * _Available since v4.1._\\n     */\\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\\n        Counters.Counter storage nonce = _nonces[owner];\\n        current = nonce.current();\\n        nonce.increment();\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20.sol\\\";\\nimport \\\"../../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\\n * tokens and those that they have an allowance for, in a way that can be\\n * recognized off-chain (via event analysis).\\n */\\nabstract contract ERC20Burnable is Context, ERC20 {\\n    /**\\n     * @dev Destroys `amount` tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 amount) public virtual {\\n        _burn(_msgSender(), amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\\n     * allowance.\\n     *\\n     * See {ERC20-_burn} and {ERC20-allowance}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have allowance for ``accounts``'s tokens of at least\\n     * `amount`.\\n     */\\n    function burnFrom(address account, uint256 amount) public virtual {\\n        _spendAllowance(account, _msgSender(), amount);\\n        _burn(account, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/ERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"./extensions/IERC721Metadata.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/Strings.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping(address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: address zero is not a valid owner\\\");\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _owners[tokenId];\\n        require(owner != address(0), \\\"ERC721: invalid token ID\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        _requireMinted(tokenId);\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overridden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not token owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        _requireMinted(tokenId);\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: caller is not token owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: caller is not token owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _owners[tokenId] != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        address owner = ERC721.ownerOf(tokenId);\\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n\\n        _afterTokenTransfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        _balances[owner] -= 1;\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n\\n        _afterTokenTransfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer from incorrect owner\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _balances[from] -= 1;\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n\\n        _afterTokenTransfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(\\n        address owner,\\n        address operator,\\n        bool approved\\n    ) internal virtual {\\n        require(owner != operator, \\\"ERC721: approve to caller\\\");\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Reverts if the `tokenId` has not been minted yet.\\n     */\\n    function _requireMinted(uint256 tokenId) internal view virtual {\\n        require(_exists(tokenId), \\\"ERC721: invalid token ID\\\");\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Counters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary Counters {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ECDSA.sol\\\";\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\\n *\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\n * ({_hashTypedDataV4}).\\n *\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\n *\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\n *\\n * _Available since v3.4._\\n */\\nabstract contract EIP712 {\\n    /* solhint-disable var-name-mixedcase */\\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\\n    // invalidate the cached domain separator if the chain id changes.\\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\\n    uint256 private immutable _CACHED_CHAIN_ID;\\n    address private immutable _CACHED_THIS;\\n\\n    bytes32 private immutable _HASHED_NAME;\\n    bytes32 private immutable _HASHED_VERSION;\\n    bytes32 private immutable _TYPE_HASH;\\n\\n    /* solhint-enable var-name-mixedcase */\\n\\n    /**\\n     * @dev Initializes the domain separator and parameter caches.\\n     *\\n     * The meaning of `name` and `version` is specified in\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\n     *\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\n     * - `version`: the current major version of the signing domain.\\n     *\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\n     * contract upgrade].\\n     */\\n    constructor(string memory name, string memory version) {\\n        bytes32 hashedName = keccak256(bytes(name));\\n        bytes32 hashedVersion = keccak256(bytes(version));\\n        bytes32 typeHash = keccak256(\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n        );\\n        _HASHED_NAME = hashedName;\\n        _HASHED_VERSION = hashedVersion;\\n        _CACHED_CHAIN_ID = block.chainid;\\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\\n        _CACHED_THIS = address(this);\\n        _TYPE_HASH = typeHash;\\n    }\\n\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\\n            return _CACHED_DOMAIN_SEPARATOR;\\n        } else {\\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\\n        }\\n    }\\n\\n    function _buildDomainSeparator(\\n        bytes32 typeHash,\\n        bytes32 nameHash,\\n        bytes32 versionHash\\n    ) private view returns (bytes32) {\\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.3) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ContractRegistryHashes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.18;\\n\\ncontract ContractRegistryHashes {\\n\\n    error OnlyRouter();\\n    error OnlyTreasury();\\n    error OnlyRealmGuardian();\\n    error OnlyStakingManager();\\n    error OnlyStakingManagerOrTokenCollector();\\n    error OnlyRewardDistributor();\\n    error OnlyCoinMaster();\\n    error OnlyTokenCollector();\\n\\n    error METFINotWithdrawable();\\n\\n    error InvalidContractAddress();\\n\\n    bytes32 constant internal MFI_HASH = 0xab12ee3d83a34822ca77656b4007d61405e0029c8476890a3303aabb7a0a3d26; // keccak256(abi.encodePacked('mfi'))\\n    bytes32 constant internal METFI_HASH = 0xc30505a9c296d74a341270378602ace8341352e684fc4f8fbf4bf9aa16ddffca; // keccak256(abi.encodePacked('metfi'))\\n\\n    bytes32 constant internal ROUTER_HASH = 0x5f6d4e9bb70c9d2aa50e18560b4cdd1b23b30d62b60873d5f23b103e5d7d0185;// keccak256(abi.encodePacked('router'))\\n    bytes32 constant internal TREASURY_HASH = 0xcbd818ad4dd6f1ff9338c2bb62480241424dd9a65f9f3284101a01cd099ad8ac; // keccak256(abi.encodePacked('treasury'))\\n    bytes32 constant internal METFI_VAULT_HASH = 0xacb5ae4bf471c8110adaac4702c4177629bf32af63ad6f68f546ac2fcd039e77; // keccak256(abi.encodePacked('metfi_vault'))\\n    bytes32 constant internal USER_CONFIG_HASH = 0x5e1885a4b18649f87409858a77d00e281ce6dd4507e43dc706a2d703d71aeb71; // keccak256(abi.encodePacked('user_config'))\\n    bytes32 constant internal ACCOUNT_TOKEN_HASH = 0xc5d51c4d622df5dca71195c62129359a2e761a24b2789b5a40667736c682f30f; // keccak256(abi.encodePacked('account_token'))\\n    bytes32 constant internal PLATFORM_VIEW_HASH = 0xd58c1d29f4951cf40818a252966d0f0711896e43c86ba803ffa9841180d7bca1; // keccak256(abi.encodePacked('platform_view'))\\n    bytes32 constant internal UNSTAKED_NFTS_HASH = 0x2d006620d1c948b883dc3097193eb76c239d12828bb85beea39994af1ecefb65; // keccak256(abi.encodePacked('unstaked_nfts'))\\n    bytes32 constant internal STAKING_MANAGER_HASH = 0x9518d9bd94df3303f323b9a5b2289cf4e06524a698aef176fcc9590318226540; // keccak256(abi.encodePacked('staking_manager'))\\n    bytes32 constant internal TOKEN_COLLECTOR_HASH = 0x66c4b93ccf2bde8d7ba39826420a87af960e88acb070c754e53aba0b8e51c02c; // keccak256(abi.encodePacked('token_collector'))\\n    bytes32 constant internal BURN_CONTROLLER_HASH = 0xa4636fb16cea2aa5153c9be70618a6afb5cefe7a593eeee2cfab523b8c195a73;  // keccak256(abi.encodePacked('burn_controller'))\\n    bytes32 constant internal REWARD_CONVERTER_HASH = 0xb7e5e8f89e319d42882d379ecafd17e93606cf39a2079af36730958267667728; // keccak256(abi.encodePacked('reward_converter'))\\n    bytes32 constant internal METFI_STAKING_POOL_HASH = 0x3d9cfbe20d3d50006bd02e057e662d569da593b764b8b8f923d3d313f2422b10;// keccak256(abi.encodePacked('metfi_staking_pool'))\\n    bytes32 constant internal REWARD_DISTRIBUTOR_HASH = 0x8d3e9afdbbce76f0b889c4bff442796e82871c8eccf3c648a01e55e080d66a49; // keccak256(abi.encodePacked('reward_distributor'))\\n    bytes32 constant internal PRIMARY_STABLECOIN_HASH = 0x0876039741972003251072838c80c5b1e815c7b3ed2e3b01411c485fec477ecc; // keccak256(abi.encodePacked('primary_stablecoin'))\\n    bytes32 constant internal ACTION_FUNCTIONS_HASH = 0x0970951b7db2cc0a769d9e3cb477e212250909cab0d2468854bafd755326bb7b; // keccak256(abi.encodePacked('action_functions'))\\n    bytes32 constant internal NFT_TRANSFER_PROXY_HASH = 0xbd165d9953042246fb908ee4e3ee644fbe1e3fe22c7d6830d417bdcece5d273b; // keccak256(abi.encodePacked('nft_transfer_proxy'))\\n    bytes32 constant internal STAR_ACHIEVERS_HASH = 0x22a6d61b8441b8b48421128668229a04c572ac6018e721043359db05f33c151b; // keccak256(abi.encodePacked('star_achievers'))\\n\\n    bytes32 constant internal LENDING_HASH = 0x16573015d5a4b6fc6913a13e8c047a772cc654c00c338536ccaa33e7fe263be9; // keccak256(abi.encodePacked('lending'))\\n    bytes32 constant internal LENDING_VIEW_HASH = 0xc74a7251498f700c757f7d9bedf70846e0808d0cfd266d18ff796d603e58ef42; // keccak256(abi.encodePacked('lending_view'))\\n    bytes32 constant internal LOAN_LIMITER_HASH = 0x840de5598c4c00225a8bc33abacc176aa8dc32e156f7069560dd186d8c08e83e; // keccak256(abi.encodePacked('loan_limiter'))\\n    bytes32 constant internal LENDING_AUCTION_HASH = 0x315a584ec231dc4ba7bfc5a8f8efed9f1d7f61fe4c54746decfc19ddd199a7c8; // keccak256(abi.encodePacked('lending_auction'))\\n    bytes32 constant internal LENDING_CHECKER_HASH = 0xd0beb74e409a61d00092877bb21f2e1b99afa0fb5b69fded573ce9d20f6426ee; // keccak256(abi.encodePacked('lending_checker'))\\n    bytes32 constant internal LENDING_CALCULATOR_HASH = 0xc8f991caa4a50f2a548f7cb4ae682c6276c4479baa4474b270262f1cf7ef0d13; // keccak256(abi.encodePacked('lending_calculator'))\\n    bytes32 constant internal LENDING_EXTENSION_CONTROLLER_HASH = 0x575b99354279563b4b104af43b2bd3663850df86e34a2a754269a4a55a0c1afd; // keccak256(abi.encodePacked('lending_extension_controller'))\\n\\n    bytes32 constant internal PANCAKE_ROUTER_HASH = 0xd8ed703341074e5699af5f26d9f38498fb901a7519f08174cfb1baf7b5ecbff9; // keccak256(abi.encodePacked('pancake_router'))\\n    bytes32 constant internal COMMUNITY_MANAGER_PAYOUT_CONTROLLER_HASH = 0x8e4bf4954dca9b537539c95d84bafae4fccf02da2ae09493581b7e530f914a17; // keccak256(abi.encodePacked('community_manager_payout_controller'))\\n\\n}\\n\"\r\n    },\r\n    \"contracts/ContractRegistryUser.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.18;\\n\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Counters.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\\\";\\n\\nimport \\\"./interfaces/IContractRegistry.sol\\\";\\nimport \\\"./ContractRegistryHashes.sol\\\";\\n\\nimport \\\"./interfaces/IMETFI.sol\\\";\\nimport \\\"./interfaces/ILending.sol\\\";\\nimport \\\"./interfaces/IRouterV3.sol\\\";\\nimport \\\"./interfaces/ITreasuryV2.sol\\\";\\nimport \\\"./interfaces/IUserConfig.sol\\\";\\nimport \\\"./interfaces/IMETFIVault.sol\\\";\\nimport \\\"./interfaces/ILendingView.sol\\\";\\nimport \\\"./interfaces/ILoanLimiter.sol\\\";\\nimport \\\"./interfaces/IAccountToken.sol\\\";\\nimport \\\"./interfaces/IPlatformView.sol\\\";\\nimport \\\"./interfaces/ISecurityProxy.sol\\\";\\nimport \\\"./interfaces/ILendingAuction.sol\\\";\\nimport \\\"./interfaces/ILendingChecker.sol\\\";\\nimport \\\"./interfaces/IPlatformViewV2.sol\\\";\\nimport \\\"./interfaces/IPriceCalculator.sol\\\";\\nimport \\\"./interfaces/IRewardConverter.sol\\\";\\nimport \\\"./interfaces/IPancakeRouter02.sol\\\";\\nimport \\\"./interfaces/IValueCalculator.sol\\\";\\nimport \\\"./interfaces/IStakingManagerV3.sol\\\";\\nimport \\\"./interfaces/ITokenCollectorV2.sol\\\";\\nimport \\\"./interfaces/IMETFIStakingPool.sol\\\";\\nimport \\\"./interfaces/IBurnControllerV2.sol\\\";\\nimport \\\"./interfaces/ILendingCalculator.sol\\\";\\nimport \\\"./interfaces/IManageableTreasury.sol\\\";\\nimport \\\"./interfaces/IDestroyableContract.sol\\\";\\nimport \\\"./interfaces/ILendingPlatformView.sol\\\";\\nimport \\\"./interfaces/ILiquidityController.sol\\\";\\nimport \\\"./interfaces/ILendingLoanExtensionController.sol\\\";\\n\\n\\ncontract ContractRegistryUser is ContractRegistryHashes, ILostTokenProvider {\\n\\n    using Address for address payable;\\n    using SafeERC20 for IERC20;\\n\\n    IContractRegistry internal contractRegistry;\\n\\n    constructor(IContractRegistry _contractRegistry) {\\n        if (address(_contractRegistry) == address(0)) {\\n            revert InvalidContractAddress();\\n        }\\n        contractRegistry = _contractRegistry;\\n    }\\n\\n    //-------------------------------------------------------------------------\\n\\n    function onlyRouter() internal view {\\n        if (msg.sender != contractRegistry.getContractAddress(ROUTER_HASH)) {\\n            revert OnlyRouter();\\n        }\\n    }\\n\\n    function onlyTreasury() internal view {\\n        if (msg.sender != contractRegistry.getContractAddress(TREASURY_HASH)) {\\n            revert OnlyTreasury();\\n        }\\n    }\\n\\n    function onlyRealmGuardian() internal view {\\n        if (!contractRegistry.isRealmGuardian(msg.sender)) {\\n            revert OnlyRealmGuardian();\\n        }\\n    }\\n\\n    function onlyStakingManager() internal view {\\n        if (msg.sender != contractRegistry.getContractAddress(STAKING_MANAGER_HASH)) {\\n            revert OnlyStakingManager();\\n        }\\n    }\\n\\n    function onlyStakingManagerOrTokenCollector() internal view {\\n        if (msg.sender != contractRegistry.getContractAddress(STAKING_MANAGER_HASH) && msg.sender != contractRegistry.getContractAddress(TOKEN_COLLECTOR_HASH)) {\\n            revert OnlyStakingManagerOrTokenCollector();\\n        }\\n    }\\n\\n    function onlyRewardDistributor() internal view {\\n        if (msg.sender != contractRegistry.getContractAddress(REWARD_DISTRIBUTOR_HASH)) {\\n            revert OnlyRewardDistributor();\\n        }\\n    }\\n\\n    function onlyCoinMaster() internal view {\\n        if (!contractRegistry.isCoinMaster(msg.sender)) {\\n            revert OnlyCoinMaster();\\n        }\\n    }\\n\\n    function onlyTokenCollector() internal view {\\n        if (msg.sender != contractRegistry.getContractAddress(TOKEN_COLLECTOR_HASH)) {\\n            revert OnlyTokenCollector();\\n        }\\n    }\\n\\n    //-------------------------------------------------------------------------\\n\\n    function getLostTokens(address tokenAddress) public virtual override {\\n        onlyTreasury();\\n\\n        IERC20 token = IERC20(tokenAddress);\\n        if (token.balanceOf(address(this)) > 0) {\\n            token.safeTransfer(msg.sender, token.balanceOf(address(this)));\\n        }\\n        if (address(this).balance > 0) {\\n            payable(msg.sender).sendValue(address(this).balance);\\n        }\\n    }\\n\\n    //-------------------------------------------------------------------------\\n\\n    function getMFI() internal view returns (IERC20) {\\n        return IERC20(contractRegistry.getContractAddress(MFI_HASH));\\n    }\\n\\n    function getMETFI() internal view returns (IMETFI) {\\n        return IMETFI(contractRegistry.getContractAddress(METFI_HASH));\\n    }\\n    function getMETFIERC20() internal view returns (IERC20) {\\n        return IERC20(contractRegistry.getContractAddress(METFI_HASH));\\n    }\\n\\n    function getRouter() internal view returns (IRouterV3) {\\n        return IRouterV3(contractRegistry.getContractAddress(ROUTER_HASH));\\n    }\\n\\n    function getLending() internal view returns (ILending) {\\n        return ILending(contractRegistry.getContractAddress(LENDING_HASH));\\n    }\\n\\n    function getTreasury() internal view returns (ITreasuryV2) {\\n        return ITreasuryV2(contractRegistry.getContractAddress(TREASURY_HASH));\\n    }\\n\\n    function getMETFIVault() internal view returns (IMETFIVault) {\\n        return IMETFIVault(contractRegistry.getContractAddress(METFI_VAULT_HASH));\\n    }\\n\\n    function getUserConfig() internal view returns (IUserConfig) {\\n        return IUserConfig(contractRegistry.getContractAddress(USER_CONFIG_HASH));\\n    }\\n\\n    function getLendingView() internal view returns (ILendingView) {\\n        return ILendingView(contractRegistry.getContractAddress(LENDING_VIEW_HASH));\\n    }\\n\\n    function getLoanLimiter() internal view returns (ILoanLimiter) {\\n        return ILoanLimiter(contractRegistry.getContractAddress(LOAN_LIMITER_HASH));\\n    }\\n\\n    function getAccountToken() internal view returns (IAccountToken) {\\n        return IAccountToken(contractRegistry.getContractAddress(ACCOUNT_TOKEN_HASH));\\n    }\\n\\n    function getAccountTokenIERC721() internal view returns (IERC721) {\\n        return IERC721(contractRegistry.getContractAddress(ACCOUNT_TOKEN_HASH));\\n    }\\n\\n    function getBurnController() internal view returns (IBurnControllerV2) {\\n        return IBurnControllerV2(contractRegistry.getContractAddress(BURN_CONTROLLER_HASH));\\n    }\\n\\n    function getStakingManager() internal view returns (IStakingManagerV3) {\\n        return IStakingManagerV3(contractRegistry.getContractAddress(STAKING_MANAGER_HASH));\\n    }\\n\\n    function getTokenCollector() internal view returns (ITokenCollectorV2) {\\n        return ITokenCollectorV2(contractRegistry.getContractAddress(TOKEN_COLLECTOR_HASH));\\n    }\\n\\n    function getLendingAuction() internal view returns (ILendingAuction) {\\n        return ILendingAuction(contractRegistry.getContractAddress(LENDING_AUCTION_HASH));\\n    }\\n\\n    function getLendingChecker() internal view returns (ILendingChecker) {\\n        return ILendingChecker(contractRegistry.getContractAddress(LENDING_CHECKER_HASH));\\n    }\\n\\n\\n    function getMETFIStakingPool() internal view returns (IMETFIStakingPool) {\\n        return IMETFIStakingPool(contractRegistry.getContractAddress(METFI_STAKING_POOL_HASH));\\n    }\\n\\n\\n    function getRewardDistributor() internal view returns (IRewardDistributor) {\\n        return IRewardDistributor(contractRegistry.getContractAddress(REWARD_DISTRIBUTOR_HASH));\\n    }\\n\\n    function getLendingCalculator() internal view returns (ILendingCalculator) {\\n        return ILendingCalculator(contractRegistry.getContractAddress(LENDING_CALCULATOR_HASH));\\n    }\\n\\n    function getLendingExtensionController() internal view returns (ILendingLoanExtensionController) {\\n        return ILendingLoanExtensionController(contractRegistry.getContractAddress(LENDING_EXTENSION_CONTROLLER_HASH));\\n    }\\n\\n    function getPlatformView() internal view returns (IPlatformView) {\\n        return IPlatformView(contractRegistry.getContractAddress(PLATFORM_VIEW_HASH));\\n    }\\n\\n    function getPriceCalculator(address token) internal view returns (IPriceCalculator) {\\n        return IPriceCalculator(contractRegistry.getPriceCalculator(token));\\n    }\\n\\n    function getRewardConverter() internal view returns (IRewardConverter) {\\n        return IRewardConverter(contractRegistry.getContractAddress(REWARD_CONVERTER_HASH));\\n    }\\n\\n    function getPancakeRouter() internal view returns (IPancakeRouter02) {\\n        return IPancakeRouter02(contractRegistry.getContractAddress(PANCAKE_ROUTER_HASH));\\n    }\\n\\n    function getPrimaryStableCoin() internal view returns (IERC20) {\\n        return IERC20(contractRegistry.getContractAddress(PRIMARY_STABLECOIN_HASH));\\n    }\\n\\n    function getPrimaryStableCoinMetadata() internal view returns (IERC20Metadata) {\\n        return IERC20Metadata(contractRegistry.getContractAddress(PRIMARY_STABLECOIN_HASH));\\n    }\\n\\n    function getLendingPlatformView() internal view returns (ILendingPlatformView) {\\n        return ILendingPlatformView(contractRegistry.getContractAddress(LENDING_HASH));\\n    }\\n\\n    function getPlatformViewV2() internal view returns (IPlatformViewV2) {\\n        return IPlatformViewV2(contractRegistry.getContractAddress(PLATFORM_VIEW_HASH));\\n    }\\n\\n\\n}\"\r\n    },\r\n    \"contracts/interfaces/IAccountToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.18;\\n\\ninterface IAccountToken {\\n\\n    enum LiquidationStatus {\\n        NOT_REQUESTED,\\n        IN_PROGRESS,\\n        AVAILABLE\\n    }\\n\\n    struct LiquidationInfo {\\n        LiquidationStatus status;\\n        uint256 requestTime;\\n        uint256 availableTime;\\n        uint256 expirationTime;\\n    }\\n\\n    event AccountCreated(address indexed to, uint256 indexed tokenId, uint256 indexed directUplink, uint256 apy, string referralLink);\\n    event ReferralLinkChanged(uint256 indexed tokenId, string oldLink, string newLink);\\n    event AccountLiquidated(uint256 indexed nftId);\\n    event AccountLiquidationStarted(uint256 indexed nftId);\\n    event AccountLiquidationCanceled(uint256 indexed nftId);\\n    event AccountUpgraded(uint256 indexed nftId, uint256 indexed level, uint256 apy);\\n\\n    function createAccount(address to, uint256 directUplink, uint256 level, string calldata newReferralLink) external returns (uint256);\\n\\n    function setReferralLink(uint256 tokenId, string calldata referralLink) external;\\n\\n    function accountLiquidated(uint256 tokenId) external view returns (bool);\\n\\n    function getAddressNFTs(address userAddress) external view returns (uint256[] memory NFTs, uint256 numberOfActive);\\n\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n    function upgradeAccountToLevel(uint256 tokenId, uint256 level) external;\\n\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    function getAccountLevel(uint256 tokenId) external view returns (uint256);\\n\\n    function getAccountDirectlyEnrolledMembers(uint256 tokenId) external view returns (uint256);\\n\\n    function getAccountReferralLink(uint256 tokenId) external view returns (string memory);\\n\\n    function getAccountByReferral(string calldata referralLink) external view returns (uint256);\\n\\n    function referralLinkExists(string calldata referralCode) external view returns (bool);\\n\\n    function getLevelMatrixParent(uint256, uint256) external view returns (uint256 newParent, uint256[] memory overtakenUsers);\\n\\n    function getDirectUplink(uint256) external view returns (uint256);\\n\\n    function getAverageAPY() external view returns (uint256);\\n\\n    function totalMembers() external view returns (uint256);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function getLiquidationInfo(uint256 tokenId) external view returns (LiquidationInfo memory);\\n\\n    function requestLiquidation(uint256 tokenId) external returns (bool);\\n\\n    function liquidateAccount(uint256 tokenId) external;\\n\\n    function cancelLiquidation(uint256 tokenId) external;\\n\\n}\"\r\n    },\r\n    \"contracts/interfaces/IBurnControllerV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.18;\\n\\ninterface IBurnControllerV2 {\\n\\n    function burnExisting() external;\\n    function burnWithTransfer(uint256 amount) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IBuybackController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.18;\\n\\ninterface IBuybackController {\\n\\n    event BoughtBackMFI(address indexed token, uint256 tokenAmount, uint256 mfiReceived);\\n\\n    function buyBackMFI(address token, uint256 tokenAmount, uint256 minMFIOut) external;\\n\\n}\"\r\n    },\r\n    \"contracts/interfaces/IContractRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.18;\\n\\nimport \\\"./IMatrix.sol\\\";\\nimport \\\"./ILiquidityController.sol\\\";\\nimport \\\"./IBuybackController.sol\\\";\\n\\ninterface IContractRegistry {\\n\\n    function contractAddressExists(bytes32 nameHash) external view returns (bool);\\n    function matrixExists(uint256 level) external view returns (bool);\\n    function liquidityControllerExists(string calldata name) external view returns (bool);\\n    function buybackControllerExists(string calldata name) external view returns (bool);\\n    function priceCalculatorExists(address currency) external view returns (bool);\\n\\n    function getContractAddress(bytes32 nameHash) external view returns (address);\\n    function getMatrix(uint256 level) external view returns (IMatrix);\\n    function getLiquidityController(string calldata name) external view returns (ILiquidityController);\\n    function getBuybackController(string calldata name) external view returns (IBuybackController);\\n    function getPriceCalculator(address currency) external view returns (address);\\n    function isRealmGuardian(address guardianAddress) external view returns (bool);\\n    function isCoinMaster(address masterAddress) external view returns (bool);\\n\\n}\"\r\n    },\r\n    \"contracts/interfaces/IDestroyableContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.18;\\n\\ninterface IDestroyableContract {\\n    function destroyContract(address payable to) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/ILending.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.18;\\n\\nimport \\\"./ILendingStructs.sol\\\";\\n\\n// @title MetFi Lending contract\\n// @author MetFi\\n// @notice This contract is responsible for managing loans\\ninterface ILending is ILendingStructs {\\n    //----------------- Getters -------------------------------------------------\\n\\n    function getLendingConfiguration()\\n        external\\n        view\\n        returns (LendingConfiguration memory);\\n\\n    function getLoanById(\\n        uint256 loanId\\n    ) external view returns (LoanInfo memory);\\n\\n    //----------------- User functions -------------------------------------------\\n\\n    function createLoan(CreateLoanRequest calldata request) external;\\n\\n    function cancelLoan(uint256 loanId) external;\\n\\n    function fundLoan(FundLoanRequest calldata request) external;\\n\\n    function repayLoan(RepayLoanRequest memory request) external;\\n\\n    function requestLoanExtension(\\n        ExtendLoanRequest calldata request\\n    ) external payable;\\n\\n    function removeFunding(uint256 loanId) external;\\n\\n    function addCollateral(AddCollateralRequest memory request) external;\\n\\n    function liquidateLoanByDeadline(uint256 loanId) external;\\n\\n    //----------------- System functions ------------------------------------------\\n\\n    function extendLoan(ExtendLoanRequest calldata request) external;\\n\\n    function liquidateLoans(uint256[] calldata loanId) external;\\n\\n    function invalidateLoans(uint256[] calldata loanId) external;\\n\\n    function migrateToNewLendingContract(\\n        uint256 maxLoansToProcess,\\n        address recipient\\n    ) external returns (uint256[] memory);\\n\\n    //----------------- Manager functions ------------------------------------------\\n    function setLendingConfiguration(\\n        LendingConfiguration calldata newConfiguration\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILendingAuction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.18;\\n\\nimport \\\"./ILendingStructs.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/ERC721.sol\\\";\\n\\n// @title MetFi Lending Calculator contract\\n// @author MetFi\\n// @notice This contract is responsible for auctioning liquidated loans\\ninterface ILendingAuction is IERC721Receiver {\\n    //----------------- Events -------------------------------------------------\\n\\n    event AuctionCreated(uint256 indexed auctionId, uint256 indexed tokenId);\\n\\n    event AuctionBid(\\n        uint256 indexed auctionId,\\n        uint256 indexed tokenId,\\n        uint256 oldBid,\\n        address oldBidder,\\n        uint256 newBid,\\n        address newBidder\\n    );\\n\\n    event AuctionClaimed(uint256 indexed auctionId, uint256 indexed tokenId);\\n\\n    event AuctionLiquidated(uint256 indexed auctionId, uint256 indexed tokenId);\\n\\n    event AuctionConfigurationChanged(\\n        AuctionConfiguration oldConfiguration,\\n        AuctionConfiguration newConfiguration\\n    );\\n\\n    //----------------- Structs -------------------------------------------------\\n\\n    struct AuctionInfo {\\n        uint256 auctionId;\\n        uint256 tokenId;\\n        uint256 currentBid;\\n        address currentBidder;\\n        uint256 liquidationDeadline;\\n        uint256 biddingDeadline;\\n        AuctionStage stage;\\n    }\\n\\n    struct AuctionConfiguration {\\n        uint256 minBidIncrement;\\n        uint256 startingPricePercentageOfFullPrice; // 1_000_000 = 100%\\n    }\\n\\n    enum AuctionStage {\\n        CREATED,\\n        CLAIMED,\\n        LIQUIDATED,\\n        MIGRATED\\n    }\\n\\n    //----------------- Getters -------------------------------------------------\\n\\n    function getAuctionInfo(\\n        uint256 auctionId\\n    ) external view returns (AuctionInfo memory);\\n\\n    function getActiveAuctions() external view returns (AuctionInfo[] memory);\\n\\n    function getAuctionsForLiquidation()\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    function getAuctionConfiguration()\\n        external\\n        view\\n        returns (AuctionConfiguration memory);\\n\\n    //----------------- User functions -------------------------------------------\\n\\n    function bidOnAuction(uint256 auctionId, uint256 amount) external;\\n\\n    function claimAuction(uint256 auctionId) external;\\n\\n    //----------------- System functions ------------------------------------------\\n\\n    function liquidateAuctions(uint256[] calldata auctionId) external;\\n\\n    function migrateToNewAuctionContract(\\n        uint256 maxAuctionsToProcess,\\n        address recipient\\n    ) external returns (uint256[] memory);\\n\\n    //----------------- Errors ----------------------------------------------------\\n\\n    error OnlyAuctionManager();\\n    error BidOnOwnBid();\\n    error OnlyTreasury();\\n    error OnlyLending();\\n    error AuctionDoesNotExist();\\n    error BlacklistedAddress();\\n    error InvalidAddress();\\n    error AuctionNotFinished();\\n    error AuctionFinished();\\n    error NoBids();\\n    error BidTooLow();\\n    error AuctionAlreadyClaimed();\\n    error FailsafeEnabled();\\n    error AuctionNotDisabledBeforeMigration();\\n    error OnlyRealmGuardian();\\n    error MigrationAlreadyFinished();\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILendingCalculator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.18;\\n\\nimport \\\"./ILendingStructs.sol\\\";\\n\\n// @title MetFi Lending Calculator contract\\n// @author MetFi\\n// @notice This contract is responsible for calculating loan values\\ninterface ILendingCalculator is ILendingStructs {\\n    function calculateLoanPercentageOfCollateralValue(\\n        uint256 tokenId,\\n        uint256 outstandingAmountBUSD,\\n        address[] calldata additionalCollateralAddresses,\\n        uint256[] calldata additionalCollateralAmounts\\n    ) external view returns (uint256);\\n\\n    function calculateLoanPercentageOfStakedMFIValue(\\n        uint256 outstandingLoanAmount,\\n        uint256 tokenId\\n    ) external view returns (uint256);\\n\\n    function calculateInterest(\\n        uint256 amount,\\n        uint256 apy,\\n        uint256 duration\\n    ) external pure returns (uint256);\\n\\n    function checkLoanForInvalidation(\\n        LoanInfo calldata loanInfo\\n    ) external view returns (bool);\\n\\n    function checkLoanForLiquidationByCollateral(\\n        LoanInfo calldata loanInfo\\n    ) external view returns (bool);\\n\\n    function checkLoanForLiquidationByDeadline(\\n        LoanInfo calldata loanInfo\\n    ) external view returns (bool);\\n\\n    function calculateLiquidationData(\\n        LoanInfo calldata loanInfo\\n    ) external view returns (LiquidationData memory, bool);\\n\\n    function calculateCurrentTotalNFTRewards(\\n        uint256 tokenId\\n    ) external view returns (uint256);\\n\\n    function calculateMaxLoanAmountForMFI(\\n        uint256 mfiAmount\\n    ) external view returns (uint256);\\n\\n    function calculateMaxLoanAmountForToken(\\n        uint256 tokenId\\n    ) external view returns (uint256);\\n\\n    function calculateMaxLoanAmountForLoan(\\n        uint256 loanId\\n    ) external view returns (uint256);\\n\\n    function calculateBUSDValueOf(\\n        address currency,\\n        uint256 amount\\n    ) external view returns (uint256);\\n\\n    function calculateMFIValueOf(\\n        address currency,\\n        uint256 amount\\n    ) external view returns (uint256);\\n\\n    function calculateNewLeverageIndexForLoanAndCollateral(\\n        LoanInfo calldata loan,\\n        address currency,\\n        uint256 amount\\n    ) external view returns (uint256);\\n\\n    function calculateMaxLoanAmountForMFIAndCollateral(\\n        uint256 mfiAmount,\\n        address[] calldata additionalCollateralAddresses,\\n        uint256[] calldata additionalCollateralAmounts,\\n        address newCollateralAddress,\\n        uint256 newCollateralAmount\\n    ) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILendingChecker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.18;\\n\\nimport \\\"./ILendingStructs.sol\\\";\\n\\n// @title MetFi Lending checker contract\\n// @author MetFi\\n// @notice This contract is responsible for checking loans and lending configuration values\\ninterface ILendingChecker is ILendingStructs {\\n    function checkLendingConfig(\\n        LendingConfiguration calldata config\\n    ) external pure;\\n\\n    function checkLoan(\\n        CreateLoanRequest calldata request,\\n        address msgSender\\n    ) external view;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILendingLoanExtensionController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.18;\\n\\nimport \\\"./ILendingStructs.sol\\\";\\n\\n// @title MetFi Lending Extension contract\\n// @author MetFi\\n// @notice This contract is responsible for EIP712 signatures for loan extensions\\ninterface ILendingLoanExtensionController is ILendingStructs {\\n    function checkLenderSignatures(\\n        ExtendLoanRequest calldata request,\\n        LenderInfo[] calldata lenders\\n    ) external view;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILendingPlatformView.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.18;\\n\\nimport \\\"./ILendingStructs.sol\\\";\\n\\n// @title MetFi Lending contract\\n// @author MetFi\\n// @notice This contract is responsible for managing loans\\ninterface ILendingPlatformView is ILendingStructs {\\n\\n    function borrowersLoans(address borrower, uint256 index) external view returns (uint256);\\n\\n    function getLoanById(\\n        uint256 loanId\\n    ) external view returns (LoanInfo memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILendingStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.18;\\n\\n// @title MetFi Lending Structs\\n// @author MetFi\\n// @notice This contract is a base for all lending contracts\\ninterface ILendingStructs {\\n    event LoanCreated(uint256 indexed loanId);\\n    event LoanLiquidated(uint256 indexed loanId);\\n    event LoanInvalidated(uint256 indexed loanId);\\n    event LoanFunded(\\n        uint256 indexed loanId,\\n        address indexed lender,\\n        uint256 amount\\n    );\\n    event LoanFullyFunded(uint256 indexed loanId);\\n    event LoanFundingRemoved(\\n        uint256 indexed loanId,\\n        address indexed lender,\\n        uint256 amount\\n    );\\n    event LoanRepaymentMade(uint256 indexed loanId);\\n    event LoanFullyRepaid(uint256 indexed loanId);\\n    event LoanExtensionRequested(uint256 indexed loanId);\\n    event LoanExtended(uint256 indexed loanId);\\n    event CollateralAdded(\\n        uint256 indexed loanId,\\n        address indexed currency,\\n        uint256 amount\\n    );\\n\\n    struct LendingConfiguration {\\n        uint256 maxLoanDuration; // in number of seconds\\n        uint256 minLoanDuration; // in number of seconds\\n        uint256 minLoanAmount; // in BUSD\\n        uint256 minFundAmount; // in BUSD\\n        uint256 treasuryInterestPercentage; // 10000 = 100%\\n        uint256 foreignCurrencyExchangeFeePercentage; // 1_000_000 = 100%\\n        uint256 fundGracePeriod; // number of seconds, after which lender can remove funds from loan\\n        uint256 liquidationLoanPercentageOfStakedValue; // 1_000_000 = 100%\\n        uint256 warningLoanPercentageOfStakedValue; // 1_000_000 = 100%\\n        uint256 creationLoanPercentageOfStakedValue; // 1_000_000 = 100%\\n        uint256 liquidationGracePeriod; // number of seconds before loan can be liquidated\\n        uint256 maxLiquidationGracePeriod; // number of seconds after which loan can no longer be liquidated\\n        uint256 maxFundingWaitTime; // number of seconds after which not fully funded loan will be invalidated\\n        uint256 repaymentGracePeriod; // number of seconds after loan deadline, when loan can still be repaid without liquidation\\n        uint256 loanExtensionFeeInBNB; // Sent to loanExtensionFeeReceiver\\n        address payable loanExtensionFeeReceiver; // Address that receives loan extension fees\\n        uint256 loanLiquidationFeeInBUSD; // Sent to loanLiquidationFeeReceiver as BNB\\n        address loanLiquidationFeeReceiver; // Address that receives loan liquidation fees\\n        uint256[] liquidationFeePayoutCurve; // in percentage points (1000 = 100%) example that follows curve (x*x)/100 : [0,0,0,0,1,2,3,4,6,8,10,12,14,16,19,22,25,28,32,36,40,44,48,52,57,62,67,72,78,84,90,96,102,108,115,122,129,136,144,152,160,168,176,184,193,202,211,220,230,240,250,260,270,280,291,302,313,324,336,348,360,372,384,396,409,422,435,448,462,476,490,504,518,532,547,562,577,592,608,624,640,656,672,688,705,722,739,756,774,792,810,828,846,864,883,902,921,940,960,980,1000]\\n    }\\n\\n    struct CreateLoanRequest {\\n        uint256 duration; // in seconds\\n        uint256 apyPercentage; // 10000 = 100%\\n        uint256 tokenId;\\n        uint256 amount;\\n    }\\n\\n    struct RepayLoanRequest {\\n        uint256 loanId;\\n        uint256 amount; // Max amount to repay\\n    }\\n\\n    struct FundLoanRequest {\\n        uint256 loanId;\\n        uint256 amount; // Max amount to fund\\n    }\\n\\n    struct ExtendLoanRequest {\\n        uint256 oldDeadline;\\n        uint256 newDeadline;\\n        uint256 newInterestRate;\\n        uint256 loanId;\\n        bytes[] lenderSignatures;\\n    }\\n\\n    struct AddCollateralRequest {\\n        uint256 loanId;\\n        address currency;\\n        uint256 amount;\\n    }\\n\\n    struct ExtendLoanLenderApproval {\\n        uint256 oldDeadline;\\n        uint256 newDeadline;\\n        uint256 newInterestRate;\\n        uint256 loanId;\\n    }\\n\\n    struct EarlyLoanRepaymentClaimRequest {\\n        uint256 loanId;\\n        uint256 lenderIndex; // To avoid gas fees\\n    }\\n\\n    struct LoanInfo {\\n        uint256 loanId;\\n        uint256 tokenId;\\n        uint256 apy;\\n        uint256 amount;\\n        address borrower;\\n        uint256 duration;\\n        uint256 deadline;\\n        uint256 amountFunded; // Amount funded by lenders\\n        uint256 repaidAmount; // Amount repaid by borrower\\n        uint256 totalInterest;\\n        uint256 creationTimestamp;\\n        uint256 liquidationTimestamp;\\n        uint256 fundedTimestamp;\\n        uint256 repaidTimestamp;\\n        uint256 totalRewardsAtLastRepaymentTime; // Or at funded time if no repayment has been made\\n        LoanStage stage;\\n        LenderInfo[] lenderInfo;\\n        address[] additionalCollateralAddresses; // additional collateral for loan\\n        uint256[] additionalCollateralAmounts; // additional collateral for loan\\n    }\\n\\n    struct LenderInfo {\\n        address lender;\\n        uint256 shareOfLoan; // Percentage of loan funded by lender 100 % = 100_000_000\\n        uint256 lastFundingTimestamp;\\n    }\\n\\n    struct LiquidationData {\\n        uint256 totalMFIInLiquidation;\\n        uint256 MFIIn;\\n        uint256 BUSDFromMFI;\\n        uint256[] collateralIn;\\n        uint256[] collateralForTreasury;\\n        uint256[] BUSDFromCollateralLiquidation;\\n        uint256[] lenderPayouts;\\n    }\\n\\n    enum LoanStage {\\n        Created, // Create by borrower\\n        Funded, // Completely funded by lenders\\n        Repaid, // Repaid by borrower. All lenders have been repaid and received their interest\\n        Liquidated, // Liquidated by the protocol. All lenders have been repaid and received their interest in proportion to the start time of the loan\\n        Invalidated, // Invalidated by the lender\\n        Migrated // Migrated to a new contract\\n    }\\n\\n    // Access Control\\n    error OnlyTreasury();\\n    error OnlyLendingManager();\\n    error BlacklistedAddress();\\n    error OnlyLender();\\n    error OnlyRealmGuardian();\\n\\n    // Extend\\n    error NotBorrower();\\n    error InvalidLenderSignatureCount();\\n    error LoanExtensionNotRequested();\\n    error InvalidLoanExtensionRequest();\\n\\n    // Create\\n    error NotTokenOwner();\\n    error LoanAmountTooLow();\\n    error LoanDurationTooLong();\\n    error NotEnoughCollateral();\\n    error LoanDurationTooShort();\\n    error LoanCreationNotAllowed();\\n    error NFTInLiquidation();\\n    error NFTInLiquidated();\\n    error OnlyOneActiveLoanPerNFT();\\n\\n    // Common\\n    error NotApproved();\\n    error InsufficientBalance();\\n    error LoanNotInFundedStage();\\n    error InsufficientAllowance();\\n    error LoanDoesNotExist();\\n    error FailsafeEnabled();\\n    error NotInitialized();\\n    error AlreadyInitialized();\\n    error MoreThanNeededAlreadyRepaid();\\n\\n    // Migration\\n    error LendingNotDisabledBeforeMigration();\\n    error MigrationAlreadyFinished();\\n\\n    // Fund\\n    error AmountTooLow();\\n    error LenderNotFound();\\n    error FundAmountTooLow();\\n    error LoanNotInCreatedStage();\\n    error CannotFundOwnLoan();\\n    error FundingTimeExpired();\\n    error CannotRemoveFundingBeforeGracePeriod(uint256 timestamp);\\n    error LoanExtensionFeeTooLow();\\n\\n    // Collateral\\n    error CollateralCurrencyNotApproved();\\n\\n    // Lending Configuration\\n    error InvalidAddress();\\n    error InvalidLoanDurationConfig();\\n    error InvalidLiquidationGracePeriod();\\n    error InvalidLiquidationFeePayoutCurve();\\n    error InvalidLoanPercentageOfStakedValue();\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILendingView.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.18;\\n\\nimport \\\"./ILendingStructs.sol\\\";\\n\\n// @title MetFi Lending View contract\\n// @author MetFi\\n// @notice This contract is a central point for getting information about loans\\ninterface ILendingView is ILendingStructs {\\n    function getLoanInfo(\\n        uint256 loanId\\n    ) external view returns (LoanInfo memory);\\n\\n    function getLoansByBorrower(\\n        address borrower\\n    ) external view returns (LoanInfo[] memory);\\n\\n    function getLoansByLender(\\n        address lender\\n    ) external view returns (LoanInfo[] memory);\\n\\n    function getLoanCollateralization(\\n        uint256 loanId\\n    ) external view returns (uint256);\\n\\n    function getActiveLoans() external view returns (LoanInfo[] memory);\\n\\n    function getLoanExtensionRequest(\\n        uint256 loanId\\n    ) external view returns (ExtendLoanRequest memory);\\n\\n    function getLoansForLiquidationByCollateralRatio()\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    function getLoansForInvalidation() external view returns (uint256[] memory);\\n\\n    function canLoanBeLiquidatedByCollateralRatio(\\n        uint256 loanId\\n    ) external view returns (bool);\\n\\n    function canLoanBeLiquidatedByDeadline(\\n        uint256 loanId\\n    ) external view returns (bool);\\n\\n    function getMaxLoanValueForToken(\\n        uint256 tokenId\\n    ) external view returns (uint256);\\n\\n    function getMaxLoanValueForLoan(\\n        uint256 loanId\\n    ) external view returns (uint256);\\n\\n    function getMaxLoanValueForMFI(\\n        uint256 mfiAmount\\n    ) external view returns (uint256);\\n\\n    function getNewLeverageIndexForLoanAndCollateral(\\n        uint256 loanId,\\n        address currency,\\n        uint256 amount\\n    ) external view returns (uint256);\\n\\n    function getBUSDValueOf(\\n        address currency,\\n        uint256 amount\\n    ) external view returns (uint256);\\n\\n    function getMFIValueOf(\\n        address currency,\\n        uint256 amount\\n    ) external view returns (uint256);\\n\\n    function getRemainingMaxLoanAmount() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILiquidityController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.18;\\n\\ninterface ILiquidityController {\\n\\n    event LiquidityProvided(address indexed tokenUsed, uint256 mfiProvided, uint256 liquidityTokensProvided, uint256 lpTokensReceived);\\n    event LiquidityRemoved(address indexed tokenUsed, uint256 lpTokensRedeemed, uint256 mfiReceived, uint256 liquidityTokensReceived);\\n\\n    function getLPTokenAddress(address tokenToUse) external view returns (address);\\n    function claimableTokensFromTreasuryLPTokens(address tokenToUse) external view returns (uint256);\\n    function mfiRequiredForProvidingLiquidity(address tokenToUse, uint256 amount, uint256 MFIMin) external view returns (uint256);\\n    function provideLiquidity(address tokenToUse, uint256 amount, uint256 MFIMin) external;\\n    function removeLiquidity(address tokenToUse, uint256 lpTokenAmount, uint256 tokenMin) external;\\n\\n}\"\r\n    },\r\n    \"contracts/interfaces/ILoanLimiter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.18;\\n\\nimport \\\"./ILendingStructs.sol\\\";\\n\\n// @title MetFi Lending Limiter contract\\n// @author MetFi\\n// @notice This contract is responsible for limiting loans\\ninterface ILoanLimiter is ILendingStructs{\\n    function canLoanBeCreated(CreateLoanRequest memory loanRequest) external view returns (bool);\\n\\n    function onLoanCreated(LoanInfo memory loanInfo, CreateLoanRequest memory loanRequest) external;\\n\\n    function onLoanFunded(LoanInfo memory loanInfo, FundLoanRequest memory fundLoanRequest) external;\\n\\n    function onLoanRepaid(LoanInfo memory loanInfo, RepayLoanRequest memory repayLoanRequest) external;\\n\\n    function onLoanExtended(LoanInfo memory loanInfo, ExtendLoanRequest memory extendLoanRequest) external;\\n\\n    function onLoanLiquidated(LoanInfo memory loanInfo) external;\\n\\n    function onLoanInvalidated(LoanInfo memory loanInfo) external;\\n\\n\\n}\"\r\n    },\r\n    \"contracts/interfaces/ILostTokenProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.18;\\n\\ninterface ILostTokenProvider {\\n    function getLostTokens(address tokenAddress) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IManageableTreasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.18;\\n\\ninterface IManageableTreasury {\\n\\n    function manage(address to, address token, uint256 amount) external;\\n\\n}\"\r\n    },\r\n    \"contracts/interfaces/IMatrix.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.18;\\n\\ninterface IMatrix {\\n\\n    event NodeAdded(uint256 indexed nftId, uint256 indexed parentId, uint256 indexed parentLeg);\\n    event SubtreeNodeAdded(uint256 indexed nftId, uint256 indexed offset, uint256 indexed level);\\n\\n    struct Node {\\n        uint256 ID;\\n        uint256 ParentID;\\n        uint256 L0;\\n        uint256 L1;\\n        uint256 L2;\\n        uint256 parentLeg;\\n    }\\n\\n    function addNode(uint256 nodeId, uint256 parentId) external;\\n    function getDistributionNodes(uint256 nodeId) external view returns (uint256[] memory distributionNodes);\\n    function getUsersInLevels(uint256 nodeId, uint256 numberOfLevels) external view returns (uint256[] memory levels, uint256 totalUsers);\\n    function getSubNodesToLevel(uint256 nodeId, uint256 toDepthLevel) external view returns (Node memory parentNode, Node[] memory subNodes);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IMETFI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.18;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\\\";\\n\\nimport \\\"./ILostTokenProvider.sol\\\";\\n\\ninterface IMETFI is IERC20, ILostTokenProvider, IERC20Permit {\\n\\n    function burn(uint256 amount) external;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMETFIStakingPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.18;\\n\\ninterface IMETFIStakingPool {\\n\\n    event METFIWithdrawn(address indexed user, uint256 amount);\\n    event METFIWithdrawnForNextStakingPeriod(address indexed user, uint256 amount);\\n    event METFIPercentageForPeriodChanged(uint256 percentage);\\n    event METFIBurnedFromPool(uint256 amount);\\n    event METFIStakingPoolMigrated(address indexed to, uint256 amount);\\n\\n    function withdrawMETFI(address to, uint256 METFIAmount) external;\\n    function withdrawMETFIForNextStakingPeriod() external returns (uint256 amount);\\n\\n}\"\r\n    },\r\n    \"contracts/interfaces/IMETFIVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.18;\\n\\ninterface IMETFIVault {\\n\\n    event METFIWithdrawn(address indexed to, uint256 amount);\\n\\n    function withdrawMETFI(address to, uint256 amount) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IPancakeRouter01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2;\\n\\ninterface IPancakeRouter01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n    external\\n    payable\\n    returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n    external\\n    returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n    external\\n    returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n    external\\n    payable\\n    returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IPancakeRouter02.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2;\\n\\nimport './IPancakeRouter01.sol';\\n\\ninterface IPancakeRouter02 is IPancakeRouter01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IPlatformView.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.18;\\n\\nimport \\\"./ITokenCollector.sol\\\";\\nimport \\\"./IMatrix.sol\\\";\\nimport \\\"./IRewardDistributor.sol\\\";\\nimport \\\"./IUserConfig.sol\\\";\\n\\ninterface IPlatformView {\\n\\n    struct NFTData {\\n        uint256 ID;\\n        uint256 level;\\n        string referralLink;\\n        uint256 directUplink;\\n        uint256 stakedTokens;\\n        IRewardDistributor.RewardAccountInfo rewardingInfo;\\n        uint256[][] usersInLevel;\\n        uint256[] totalUsersInMatrix;\\n        uint256 directlyEnrolledMembers;\\n        uint256 liquidationRequestTime;\\n        uint256 liquidationAvailableTime;\\n        uint256 liquidationExpiredTime;\\n        bool liquidated;\\n        bool stakingPaused;\\n        bool readOnly;\\n        IUserConfig.UserConfigValues userConfigValues;\\n    }\\n\\n    struct TreeNodeData {\\n        NFTData nftData;\\n        IMatrix.Node node;\\n    }\\n\\n    struct PlatformData {\\n        uint256 MFIPrice;\\n        uint256 totalMembers;\\n        uint256 averageAPY;\\n        uint256 treasuryValue;\\n        uint256 treasuryRiskFreeValue;\\n        uint256 stakedTokens;\\n        uint256 valuePerToken;\\n        uint256 backingPerToken;\\n        uint256 nextRebaseAt;\\n        uint256 totalRewardsPaid;\\n        ITokenCollector.CollectionType tokenCollectionType;\\n        ITokenCollector.PriceCalculationType priceCalculationType;\\n        uint256 tokenCollectionPercentage;\\n        uint256 mfiLiquidityReserve;\\n        uint256 stableCoinLiquidityReserve;\\n    }\\n\\n    function getWalletData(address wallet) external view returns (NFTData[] memory);\\n    function getNFTData(uint256 nftId) external view returns (NFTData memory NFT);\\n    function getReferralCodeData(string calldata referralCode) external view returns (NFTData memory);\\n    function referralLinkExists(string calldata referralCode) external view returns (bool);\\n\\n    function getAddressActiveLoanNFTs(address borrower) external view returns (uint256[] memory);\\n\\n    function getMFIPrice() external view returns (uint256);\\n    function getPlatformData() external view returns (PlatformData memory);\\n\\n    function getTreeData(uint256 nftId, uint256 matrixLevel, uint256 toDepthLevel) external view returns (TreeNodeData memory selectedNFT, TreeNodeData[] memory subNFTs);\\n\\n    function stakedTokens(uint256 nftId) external view returns (uint256);\\n    function stakingPaused(uint256 nftId) external view returns (bool);\\n    function stakedTokensForAddress(address wallet) external view returns (uint256);\\n    function getUsersInLevels(uint256 nodeId, uint256 level) external view returns (uint256[] memory levels, uint256 totalUsers);\\n\\n}\"\r\n    },\r\n    \"contracts/interfaces/IPlatformViewV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.18;\\n\\nimport \\\"./ITokenCollectorV2.sol\\\";\\nimport \\\"./IMatrix.sol\\\";\\nimport \\\"./IRewardDistributor.sol\\\";\\nimport \\\"./IUserConfig.sol\\\";\\n\\ninterface IPlatformViewV2 {\\n\\n    struct NFTData {\\n        uint256 ID;\\n        uint256 level;\\n        string referralLink;\\n        uint256 directUplink;\\n        uint256 stakedTokens;\\n        IRewardDistributor.RewardAccountInfo rewardingInfo;\\n        uint256[][] usersInLevel;\\n        uint256[] totalUsersInMatrix;\\n        uint256 directlyEnrolledMembers;\\n        uint256 liquidationRequestTime;\\n        uint256 liquidationAvailableTime;\\n        uint256 liquidationExpiredTime;\\n        bool liquidated;\\n        bool stakingPaused;\\n        bool readOnly;\\n        IUserConfig.UserConfigValues userConfigValues;\\n    }\\n\\n    struct TreeNodeData {\\n        NFTData nftData;\\n        IMatrix.Node node;\\n    }\\n\\n    struct PlatformData {\\n        uint256 METFIPrice;\\n        uint256 totalMembers;\\n        uint256 averageAPY;\\n        uint256 treasuryValue;\\n        uint256 treasuryRiskFreeValue;\\n        uint256 stakedTokens;\\n        uint256 valuePerToken;\\n        uint256 backingPerToken;\\n        uint256 nextRebaseAt;\\n        uint256 totalRewardsPaid;\\n        ITokenCollectorV2.CollectionType tokenCollectionType;\\n        ITokenCollectorV2.PriceCalculationType priceCalculationType;\\n        uint256 tokenCollectionPercentage;\\n        uint256 metfiLiquidityReserve;\\n        uint256 stableCoinLiquidityReserve;\\n        bool dynamicStaking;\\n        uint256[] currentStakingMultipliers;\\n        uint256 rebasesUntilNextHalvingOrDistribution;\\n    }\\n\\n    function getWalletData(address wallet) external view returns (NFTData[] memory);\\n    function getNFTData(uint256 nftId) external view returns (NFTData memory NFT);\\n    function getReferralCodeData(string calldata referralCode) external view returns (NFTData memory);\\n    function referralLinkExists(string calldata referralCode) external view returns (bool);\\n\\n    function getAddressActiveLoanNFTs(address borrower) external view returns (uint256[] memory);\\n\\n    function getMETFIPrice() external view returns (uint256);\\n    function getPlatformData() external view returns (PlatformData memory);\\n\\n    function getTreeData(uint256 nftId, uint256 matrixLevel, uint256 toDepthLevel) external view returns (TreeNodeData memory selectedNFT, TreeNodeData[] memory subNFTs);\\n\\n    function stakedTokens(uint256 nftId) external view returns (uint256);\\n    function stakingPaused(uint256 nftId) external view returns (bool);\\n    function stakedTokensForAddress(address wallet) external view returns (uint256);\\n    function getUsersInLevels(uint256 nodeId, uint256 level) external view returns (uint256[] memory levels, uint256 totalUsers);\\n\\n}\"\r\n    },\r\n    \"contracts/interfaces/IPriceCalculator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.18;\\n\\ninterface IPriceCalculator {\\n\\n    function exchangePairSet() external view returns (bool);\\n    function getReserves() external view returns (uint256 calculatedTokenReserve, uint256 reserveTokenReserve);\\n    function getPriceInUSD() external view returns (uint256);\\n    function tokensForPrice(uint256 reserveTokenAmount) external view returns (uint256);\\n    function priceForTokens(uint256 numberOfTokens) external view returns (uint256);\\n\\n}\"\r\n    },\r\n    \"contracts/interfaces/IRewardConverter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.18;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IRewardConverter {\\n\\n    function sendReward(uint256 nftId, IERC20 primaryStableCoin, uint256 amount) external;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRewardDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.18;\\n\\nimport \\\"./IMatrix.sol\\\";\\n\\ninterface IRewardDistributor {\\n\\n    event AccountCreated(uint256 indexed nftId, uint256 indexed parentId);\\n    event AccountUpgraded(uint256 indexed nftId, uint256 indexed level);\\n    event BonusActivated(uint256 indexed nftId);\\n    event AccountLiquidated(uint256 indexed nftId);\\n\\n    event RewardSent(uint256 indexed nftId, uint256 indexed from, uint256 indexed rewardType, uint256 level, uint256 matrixLevel, uint256 amount);\\n    event MatchingBonusSent(uint256 indexed nftId, uint256 indexed from, uint256 amount);\\n    event FastStartBonusReceived(uint256 indexed nftId, uint256 indexed from, uint256 amount, bool autoClaimed);\\n\\n    struct RewardAccountInfo {\\n        uint256 ID;\\n        uint256 directUplink;\\n        uint256 fastStartBonus;\\n        uint256 receivedMatchingBonus;\\n        uint256 receivedMatrixBonus;\\n        uint64 bonusDeadline;\\n        uint64 activeBonusUsers;\\n        bool bonusActive;\\n        bool accountLiquidated;\\n    }\\n\\n    function getAccountInfo(uint256 nftId) external view returns (RewardAccountInfo memory);\\n    function createAccount(uint256 nftId, uint256 parentId) external;\\n    function accountUpgraded(uint256 nftId, uint256 level) external;\\n    function liquidateAccount(uint256 nftId) external;\\n    function distributeRewards(uint256 distributionValue, uint256 rewardType, uint256 nftId, uint256 level) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IRouterV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.18;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./IRewardDistributor.sol\\\";\\nimport \\\"./ITokenCollector.sol\\\";\\nimport \\\"./IMatrix.sol\\\";\\nimport \\\"./ILendingStructs.sol\\\";\\n\\ninterface IRouterV3 {\\n\\n    event AccountCreated(uint256 indexed nftId, uint256 indexed parentId, uint256 indexed level, uint256 additionalTokensPrice, string referralLink, uint256 freeMFITokensReceived);\\n    event AccountLiquidationStarted(uint256 indexed nftId);\\n    event AccountLiquidationCanceled(uint256 indexed nftId);\\n    event AccountLiquidated(uint256 indexed nftId);\\n    event AccountUpgraded(uint256 indexed nftId, uint256 indexed level, uint256 additionalTokensPrice, uint256 freeMFITokensReceived);\\n    event TokensStaked(uint256 indexed nftId, uint256 numberOfTokens);\\n    event TokensBought(uint256 indexed nftId, uint256 usdtPrice, uint256 numberOfTokens, uint256 accountLevel);\\n    event AccountOvertaken(uint256 indexed overtakenAccount, uint256 indexed overtakenBy, uint256 indexed level);\\n    event StakingResumed(uint256 indexed nftId);\\n\\n    function resumeStaking(uint256 nftId) external;\\n\\n    function createAccount(address newOwner, uint256 level, uint256 minTokensOut, uint256 minBonusTokens, string calldata newReferralLink, uint256 additionalTokensValue, bool isCrypto, address paymentCurrency,uint256 maxTokensIn) external payable returns (uint256);\\n    function createAccountWithReferral(address newOwner, string calldata referralId, uint256 level, uint256 minTokensOut, uint256 minBonusTokens, string calldata newReferralLink, uint256 additionalTokensValue, bool isCrypto, address paymentCurrency,uint256 maxTokensIn) external payable returns (uint256);\\n    function upgradeNFTToLevel(uint256 nftId, uint256 minTokensOut, uint256 minBonusTokens, uint256 finalLevel, uint256 additionalTokensValue, address paymentCurrency,uint256 maxTokensIn) external payable;\\n\\n\\n    function setReferralLink(uint256 nftId, string calldata newReferralLink) external;\\n\\n    function liquidateAccount(uint256 nftId) external;\\n    function cancelLiquidation(uint256 nftId) external;\\n\\n    function stakeTokens(uint256 nftId, uint256 numberOfTokens) external;\\n\\n    function setUserConfigUintValue(uint256 nftId, string memory key, uint256 value) external;\\n    function setUserConfigStringValue(uint256 nftId, string memory key, string memory value) external;\\n\\n    function buyTokens(uint256 nftId, uint256 primaryStableCoinPrice, uint256 minTokensOut, IERC20 paymentCurrency) payable external;\\n\\n}\"\r\n    },\r\n    \"contracts/interfaces/ISecurityProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.18;\\n\\ninterface ISecurityProxy {\\n    function validateTransfer(address from, address to, uint256 amount) external view returns (bool);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IStakingManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.18;\\n\\ninterface IStakingManager {\\n\\n    event StakingAccountCreated(uint256 indexed nftId, uint256 indexed level, uint256 numberOfTokens);\\n    event StakingAccountLiquidated(uint256 indexed nftId, uint256 unstakedTokens);\\n    event TokensAddedToStaking(uint256 indexed nftId, uint256 numberOfTokens);\\n    event StakingAccountUpgraded(uint256 indexed nftId, uint256 indexed level, uint256 numberOfTokens);\\n    event StakingLevelRebased(uint256 indexed level, uint256 lockedTokens);\\n    event StakingRebased(uint256 totalTokens);\\n\\n    function getAccountTokens(uint256 tokenId) external view returns(uint256);\\n    function createStakingAccount(uint256 tokenId, uint256 tokenAmount, uint256 level) external;\\n    function liquidateAccount(uint256 tokenId, address owner) external;\\n    function addTokensToStaking(uint256 tokenId, uint256 numberOfTokens) external;\\n    function upgradeStakingAccountToLevel(uint256 tokenId, uint256 level) external;\\n    function timeToNextRebase() external view returns (uint256);\\n    function nextRebaseAt() external view returns (uint256);\\n    function rebase() external;\\n\\n    function enterLiquidation() external returns (uint256 totalMFIStaked);\\n\\n}\"\r\n    },\r\n    \"contracts/interfaces/IStakingManagerV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.18;\\n\\nimport \\\"./IStakingManager.sol\\\";\\n\\ninterface IStakingManagerV2 is IStakingManager {\\n\\n    event StakingPaused(uint256 indexed tokenId, uint256 MFIAmount);\\n    event StakingResumed(uint256 indexed tokenId, uint256 MFIAmount);\\n    event ClaimedTokensFromAccount(uint256 indexed tokenId, uint256 MFIAmount);\\n\\n    function isAccountPaused(uint256 tokenId) external view returns (bool);\\n    function pauseStaking(uint256 tokenId) external;\\n    function resumeStaking(uint256 tokenId) external;\\n    function claimTokensFromAccount(uint256 tokenId, uint256 numberOfTokens, address destinationAddress) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IStakingManagerV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.18;\\n\\nimport \\\"./IStakingManagerV2.sol\\\";\\n\\ninterface IStakingManagerV3 is IStakingManagerV2 {\\n\\n    event StakingPeriodLengthChanged(uint256 oldLength, uint256 newLength);\\n    event AddedAllowedMETFITakingContract(string indexed takingContract);\\n    event RemovedAllowedMETFITakingContract(string indexed takingContract);\\n\\n    function isInDynamicStaking() external view returns (bool);\\n    function rebasesUntilNextHalvingOrDistribution() external view returns (uint256);\\n    function currentStakingMultipliersOrNewTokensPerLevelPerMETFI() external view returns (uint256[] memory);\\n}\"\r\n    },\r\n    \"contracts/interfaces/ITokenCollector.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.18;\\n\\ninterface ITokenCollector {\\n\\n    event CollectedBonusTokens(uint256 busdPrice, uint256 numberOfTokens);\\n    event CollectedTokens(uint256 busdPrice, uint256 numberOfTokens, uint256 collectionType, uint256 slippageCalculationType);\\n    event CollectionTypeChanged(uint256 collectionType);\\n    event PriceCalculationTypeChanged(uint256 priceCalculationType);\\n\\n    enum CollectionType {\\n        MINTING,\\n        SWAP\\n    }\\n\\n    enum PriceCalculationType {\\n        TOKEN_PRICE_BASED,\\n        POOL_BASED\\n    }\\n\\n    function getBonusTokens(uint256 busdPrice) external returns (uint256);\\n    function getTokens(uint256 busdPrice, uint256 minTokensOut) external returns (uint256);\\n    function getCollectionType() external view returns (CollectionType);\\n    function getPriceCalculationType() external view returns (PriceCalculationType);\\n    function getAdditionalTokensPercentage() external view returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/interfaces/ITokenCollectorV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.18;\\n\\nimport \\\"./ITokenCollector.sol\\\";\\n\\ninterface ITokenCollectorV2 {\\n\\n    event CollectedBonusTokens(uint256 stableCoinPrice, uint256 numberOfTokens);\\n    event CollectedTokens(uint256 stableCoinPrice, uint256 numberOfTokens, uint256 collectionType, uint256 slippageCalculationType);\\n    event CollectionTypeChanged(uint256 collectionType);\\n    event PriceCalculationTypeChanged(uint256 priceCalculationType);\\n    event AdditionalTokensPercentageChanged(uint256 additionalTokensPercentage);\\n    event BonusTokenPercentageFromSwapChanged(uint256 bonusTokenPercentageFromSwap);\\n    event BoolValuesChanged(bool fullFromSwap, bool usePool);\\n\\n    enum CollectionType {\\n        SWAP,\\n        POOL\\n    }\\n\\n    enum PriceCalculationType {\\n        TOKEN_PRICE_BASED,\\n        POOL_BASED\\n    }\\n\\n    function getBonusTokens(uint256 stableCoinPrice, uint256 minBonusTokens) external returns (uint256);\\n    function getTokens(uint256 stableCoinPrice, uint256 minTokensOut) external returns (uint256);\\n    function getCollectionType() external view returns (CollectionType);\\n    function getPriceCalculationType() external view returns (PriceCalculationType);\\n    function getAdditionalTokensPercentage() external view returns (uint256);\\n\\n}\"\r\n    },\r\n    \"contracts/interfaces/ITreasuryV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.18;\\n\\ninterface ITreasuryV2 {\\n\\n    enum TokenType {\\n        RESERVE_TOKEN,\\n        LP_TOKEN,\\n        LIQUIDITY_TOKEN\\n    }\\n\\n    event StakingRewardsDistributed(uint256 indexed amount);\\n    event RewardsSent(uint256 nftId, uint256 amount);\\n\\n    function sendReward(uint256 nftId, uint256 amount) external;\\n\\n    function getTotalRewardsPaid() external view returns (uint256);\\n\\n    function getValue() external view returns (uint256 totalValue, uint256 riskFreeValue);\\n\\n    function getTokensForCollector(address token, uint256 amount, address to) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IUserConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.18;\\n\\ninterface IUserConfig {\\n\\n    event UserConfigUintValueUpdated(address indexed user, string indexed key, uint256 old_value, uint256 new_value);\\n    event UserConfigStringValueUpdated(address indexed user, string indexed key, string old_value, string new_value);\\n    event AllowedStringKeyAdded(string key);\\n    event AllowedUintKeyAdded(string key);\\n\\n    struct UserConfigUintValue {\\n        string key;\\n        uint256 value;\\n    }\\n\\n    struct UserConfigStringValue {\\n        string key;\\n        string value;\\n    }\\n\\n    struct UserConfigValues {\\n        UserConfigUintValue[] uintValues;\\n        UserConfigStringValue[] stringValues;\\n    }\\n\\n    function getAllUserConfigValues(uint256 nftId) external view returns (UserConfigValues memory values);\\n    function getUserConfigUintValue(uint256 nftId, string memory key) external view returns (uint256 value);\\n    function getUserConfigStringValue(uint256 nftId, string memory key) external view returns (string memory value);\\n\\n    function setUserConfigUintValue(uint256 nftId, string memory key, uint256 value) external;\\n    function setUserConfigStringValue(uint256 nftId, string memory key, string memory value) external;\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IValueCalculator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.18;\\n\\ninterface IValueCalculator {\\n    function calculateValue() external view returns (uint256, uint256);\\n}\"\r\n    },\r\n    \"contracts/NFTTransferProxyV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.18;\\n\\nimport \\\"./ContractRegistryUser.sol\\\";\\n\\ncontract NFTTransferProxyV2 is ContractRegistryUser {\\n\\n    event NFTTransferred(uint256 indexed nftId, address indexed to, address paymentCurrency);\\n\\n    using SafeERC20 for IERC20;\\n    using Address for address payable;\\n\\n    uint256 public transferFeeInUSD;\\n\\n    constructor(IContractRegistry _contractRegistry, uint256 _transferFeeInUSD) ContractRegistryUser(_contractRegistry) {\\n        require(_transferFeeInUSD <= 10, \\\"Fee limit exceeded\\\");\\n        transferFeeInUSD = _transferFeeInUSD;\\n    }\\n\\n    function transferWithFee(uint256 id, address destination, IERC20 paymentCurrency, uint256 maxAmountIn) external payable {\\n\\n        address paymentCurrencyAddress = address(paymentCurrency);\\n\\n        uint256 transferFeeInPrimaryStableCoin = transferFeeInUSD * (10 ** getPrimaryStableCoinMetadata().decimals());\\n        if (msg.value > 0) {\\n\\n            IPancakeRouter02 pancakeRouter = getPancakeRouter();\\n\\n            paymentCurrencyAddress = address(pancakeRouter.WETH());\\n\\n            address[] memory path = new address[](2);\\n            path[0] = pancakeRouter.WETH();\\n            path[1] = contractRegistry.getContractAddress(PRIMARY_STABLECOIN_HASH);\\n\\n            uint256 requiredBNBAmount = pancakeRouter.getAmountsIn(transferFeeInPrimaryStableCoin, path)[0];\\n            require(msg.value >= requiredBNBAmount, \\\"insufficient msg value\\\");\\n            require(maxAmountIn >= requiredBNBAmount, \\\"Slippage exceeded\\\");\\n\\n            uint256 leftOverBNB = msg.value - requiredBNBAmount;\\n\\n            pancakeRouter.swapExactETHForTokens{value : requiredBNBAmount}(transferFeeInPrimaryStableCoin, path, contractRegistry.getContractAddress(TREASURY_HASH), block.timestamp);\\n\\n            if (leftOverBNB > 0) {\\n                payable(msg.sender).sendValue(leftOverBNB);\\n            }\\n\\n\\n        } else if (paymentCurrency != getPrimaryStableCoin()) {\\n\\n            IPancakeRouter02 pancakeRouter = getPancakeRouter();\\n\\n            address[] memory path = new address[](2);\\n            path[0] = address(paymentCurrency);\\n            path[1] = contractRegistry.getContractAddress(PRIMARY_STABLECOIN_HASH);\\n\\n            uint256[] memory amounts = pancakeRouter.getAmountsIn(transferFeeInPrimaryStableCoin, path);\\n\\n            require(maxAmountIn >= amounts[0], \\\"Slippage exceeded\\\");\\n\\n            paymentCurrency.safeApprove(address(pancakeRouter), amounts[0]);\\n            paymentCurrency.safeTransferFrom(msg.sender, address(this), amounts[0]);\\n            pancakeRouter.swapExactTokensForTokens(amounts[0], amounts[1], path, contractRegistry.getContractAddress(TREASURY_HASH), block.timestamp);\\n\\n\\n        } else {\\n            paymentCurrency.safeTransferFrom(msg.sender, contractRegistry.getContractAddress(TREASURY_HASH), transferFeeInPrimaryStableCoin);\\n        }\\n\\n        getAccountTokenIERC721().safeTransferFrom(msg.sender, destination, id);\\n\\n        emit NFTTransferred(id, destination, paymentCurrencyAddress);\\n    }\\n\\n    function setTransferFeeInUSD(uint256 _transferFeeInUSD) external {\\n        onlyRealmGuardian();\\n        require(_transferFeeInUSD <= 10, \\\"Fee limit exceeded\\\");\\n        transferFeeInUSD = _transferFeeInUSD;\\n    }\\n\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IContractRegistry\",\"name\":\"_contractRegistry\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_transferFeeInUSD\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidContractAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"METFINotWithdrawable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyCoinMaster\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyRealmGuardian\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyRewardDistributor\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyRouter\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyStakingManager\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyStakingManagerOrTokenCollector\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyTokenCollector\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyTreasury\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"paymentCurrency\",\"type\":\"address\"}],\"name\":\"NFTTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"getLostTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_transferFeeInUSD\",\"type\":\"uint256\"}],\"name\":\"setTransferFeeInUSD\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferFeeInUSD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"paymentCurrency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxAmountIn\",\"type\":\"uint256\"}],\"name\":\"transferWithFee\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "NFTTransferProxyV2", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "000000000000000000000000578e948ec7f0fd1182aae4b2480e761b2f765825000000000000000000000000000000000000000000000000000000000000000a", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}