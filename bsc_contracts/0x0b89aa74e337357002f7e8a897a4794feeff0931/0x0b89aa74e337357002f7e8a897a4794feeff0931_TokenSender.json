{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/TokenSender.sol\": {\r\n      \"content\": \"// Copyright (C) 2018 Alon Bukai This program is free software: you \\n// can redistribute it and/or modify it under the terms of the GNU General \\n// Public License as published by the Free Software Foundation, version. \\n// This program is distributed in the hope that it will be useful, \\n// but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\\n// or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\\n// more details. You should have received a copy of the GNU General Public\\n// License along with this program. If not, see http://www.gnu.org/licenses/\\n\\npragma solidity ^0.4.24;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./ReentrancyGuard.sol\\\";\\n/// @notice `TokenSender` is a contract for sending multiple ETH/ERC20 Tokens to\\n///  multiple addresses. In addition this contract can call multiple contracts\\n///  with multiple amounts. There are also TightlyPacked functions which in\\n///  some situations allow for gas savings. TightlyPacked is cheaper if you\\n///  need to store input data and if amount is less than 12 bytes. Normal is\\n///  cheaper if you don't need to store input data or if amounts are greater\\n///  than 12 bytes. 12 bytes allows for sends of up to 2^96-1 units, 79 billion\\n///  ETH, so tightly packed functions will work for any ETH send but may not \\n///  work for token sends when the token has a high number of decimals or a \\n///  very large total supply. Supports deterministic deployment. As explained\\n///  here: https://github.com/ethereum/EIPs/issues/777#issuecomment-356103528\\ncontract TokenSender is ReentrancyGuard {\\n\\n    address private owner;\\n\\n    constructor() public {\\n        owner = msg.sender;\\n    }\\n\\n    /// @notice Send to multiple addresses using a byte32 array which\\n    ///  includes the address and the amount.\\n    ///  Addresses and amounts are stored in a packed bytes32 array\\n    ///  Address is stored in the 20 most significant bytes\\n    ///  The address is retrieved by bitshifting 96 bits to the right\\n    ///  Amount is stored in the 12 least significant bytes\\n    ///  The amount is retrieved by taking the 96 least significant bytes\\n    ///  and converting them into an unsigned integer\\n    ///  Payable\\n    /// @param _addressesAndAmounts Bitwise packed array of addresses\\n    ///  and amounts\\n\\n    function multiTransferTightlyPacked(bytes32[] _addressesAndAmounts)\\n        public \\n        payable \\n        nonReentrant \\n        returns(bool)\\n    {\\n        uint256 toReturn = msg.value;\\n        for (uint256 i = 0; i < _addressesAndAmounts.length; ++i) {\\n            address to = address(_addressesAndAmounts[i] >> 96);\\n            uint256 amount = uint256(uint96(_addressesAndAmounts[i]));\\n            _safeTransfer(to, uint256(uint96(_addressesAndAmounts[i])));\\n            toReturn = SafeMath.sub(toReturn, amount);\\n        }\\n        _safeTransfer(msg.sender, toReturn);\\n        return true;\\n    }\\n\\n    /// @notice Send to multiple addresses using two arrays which\\n    ///  includes the address and the amount.\\n    ///  Payable\\n    /// @param _addresses Array of addresses to send to\\n    /// @param _amounts Array of amounts to send\\n    function multiTransfer(address[] _addresses, uint256[] _amounts)\\n        public \\n        payable \\n        nonReentrant \\n        returns(bool)\\n    {\\n        uint256 toReturn = msg.value;\\n        for (uint256 i = 0; i < _addresses.length; ++i) {\\n            _safeTransfer(_addresses[i], _amounts[i]);\\n            toReturn = SafeMath.sub(toReturn, _amounts[i]);\\n        }\\n        _safeTransfer(msg.sender, toReturn);\\n        return true;\\n    }\\n\\n\\n    /// @notice Send to multiple addresses using array of recipients and amount to transfer to each recipient\\n    ///  includes the address and the amount.\\n    ///  Payable\\n    /// @param _addresses Array of addresses to send to\\n    /// @param _amount amount to send\\n    function multiTransferUint256(address[] _addresses, uint256 _amount)\\n        public \\n        payable \\n        nonReentrant \\n        returns(bool)\\n    {\\n        uint256 toReturn = msg.value;\\n        for (uint256 i = 0; i < _addresses.length; ++i) {\\n            _safeTransfer(_addresses[i], _amount);\\n            toReturn = SafeMath.sub(toReturn, _amount);\\n        }\\n        _safeTransfer(msg.sender, toReturn);\\n        return true;\\n    }\\n\\n    /// @notice Send ERC20 tokens to multiple contracts \\n    ///  using a byte32 array which includes the address and the amount.\\n    ///  Addresses and amounts are stored in a packed bytes32 array.\\n    ///  Address is stored in the 20 most significant bytes.\\n    ///  The address is retrieved by bitshifting 96 bits to the right\\n    ///  Amount is stored in the 12 least significant bytes.\\n    ///  The amount is retrieved by taking the 96 least significant bytes\\n    ///  and converting them into an unsigned integer.\\n    /// @param _token The token to send\\n    /// @param _addressesAndAmounts Bitwise packed array of addresses\\n    ///  and token amounts\\n    function multiERC20TransferTightlyPacked(\\n        IERC20 _token,\\n        bytes32[] _addressesAndAmounts\\n    ) public {\\n        for (uint256 i = 0; i < _addressesAndAmounts.length; ++i) {\\n            address to = address(_addressesAndAmounts[i] >> 96);\\n            uint256 amount = uint256(uint96(_addressesAndAmounts[i]));\\n            _safeERC20Transfer(_token, to, amount);\\n        }\\n    }\\n\\n    /// @notice Send ERC20 tokens to multiple contracts\\n    ///  using two arrays which includes the address and the amount.\\n    /// @param _token The token to send\\n    /// @param _addresses Array of addresses to send to\\n    /// @param _amounts Array of token amounts to send\\n    function multiERC20Transfer(\\n        IERC20 _token,\\n        address[] _addresses,\\n        uint256[] _amounts\\n    ) public {\\n        for (uint256 i = 0; i < _addresses.length; ++i) {\\n            _safeERC20Transfer(_token, _addresses[i], _amounts[i]);\\n        }\\n    }\\n\\n    /// @notice Send ERC20 tokens to multiple contracts\\n    ///  using array of address and the amount.\\n    /// @param _token The token to send\\n    /// @param _addresses Array of addresses to send to\\n    /// @param _amount token amount to send\\n    function multiTransferERC20Uint256(\\n        IERC20 _token,\\n        address[] _addresses,\\n        uint256 _amount\\n    ) public {\\n        for (uint256 i = 0; i < _addresses.length; ++i) {\\n            _safeERC20Transfer(_token, _addresses[i], _amount);\\n        }\\n    }\\n\\n    /// @notice Recovers lost funds for given address. \\n    ///  Only owner can recover funds.\\n    /// @param _token ERC-20 token address \\n    /// @param _amount amount to recover\\n    /// @param _loser address, that accidentally sent tokens to smart contract\\n\\n    function recoverFunds(IERC20 _token, uint256 _amount, address _loser) public nonReentrant {\\n        require(msg.sender == owner, \\\"Only owner can recover lost funds\\\");\\n        _token.transfer(_loser, _amount);\\n    }\\n\\n    /// @notice `_safeCall` is used internally to call a contract safely.\\n    function _safeTransfer(address _to, uint256 _amount) internal {\\n        require(_to != 0, \\\"Cannot transfer 0 ETH\\\");\\n        require(_to.send(_amount), _addressToString(_to));\\n    }\\n\\n    /// @notice `_safeERC20Transfer` is used internally to\\n    ///  transfer a quantity of ERC20 tokens safely.\\n    function _safeERC20Transfer(IERC20 _token, address _to, uint256 _amount) internal {\\n        require(_to != 0, \\\"Cannot transfer 0 ERC20\\\");\\n        require(_token.transferFrom(msg.sender, _to, _amount), \\\"Cannot transfer from ERC20. Please check token's allowance\\\");\\n    }\\n\\n    function _addressToString(address _address)\\n        internal\\n        pure\\n        returns(string memory)\\n    {\\n        bytes32 _bytes = bytes32(uint256(_address));\\n        bytes memory HEX = \\\"0123456789abcdef\\\";\\n        bytes memory _string = new bytes(42);\\n        _string[0] = \\\"0\\\";\\n        _string[1] = \\\"x\\\";\\n        for(uint256 i = 0; i < 20; ++i) {\\n            _string[2+i*2] = HEX[uint8(_bytes[i + 12] >> 4)];\\n            _string[3+i*2] = HEX[uint8(_bytes[i + 12] & 0x0f)];\\n        }\\n        return string(_string);\\n    }\\n\\n    /// @dev Default payable function to not allow sending to contract\\n    ///  Remember this does not necessarily prevent the contract\\n    ///  from accumulating funds.\\n    function () public payable {\\n        revert();\\n    }\\n}\"\r\n    },\r\n    \"/contracts/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\nlibrary SafeMath {\\n\\n  /**\\n  * @dev Multiplies two numbers, throws on overflow.\\n  */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n    c = a * b;\\n    assert(c / a == b);\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Integer division of two numbers, truncating the quotient.\\n  */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\\n    // uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n    return a / b;\\n  }\\n\\n  /**\\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n  */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    assert(b <= a);\\n    return a - b;\\n  }\\n\\n  /**\\n  * @dev Adds two numbers, throws on overflow.\\n  */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    c = a + b;\\n    assert(c >= a);\\n    return c;\\n  }\\n}\"\r\n    },\r\n    \"/contracts/ReentrancyGuard.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul\\n */\\ncontract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\"\r\n    },\r\n    \"/contracts/IERC20.sol\": {\r\n      \"content\": \"pragma solidity ^0.4.24;\\n\\ninterface IERC20 {\\n  /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"byzantium\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"_addresses\",\"type\":\"address[]\"},{\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"multiTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_addresses\",\"type\":\"address[]\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"multiTransferERC20Uint256\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addressesAndAmounts\",\"type\":\"bytes32[]\"}],\"name\":\"multiTransferTightlyPacked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_addresses\",\"type\":\"address[]\"},{\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"multiERC20Transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_loser\",\"type\":\"address\"}],\"name\":\"recoverFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addresses\",\"type\":\"address[]\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"multiTransferUint256\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_addressesAndAmounts\",\"type\":\"bytes32[]\"}],\"name\":\"multiERC20TransferTightlyPacked\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]", "ContractName": "TokenSender", "CompilerVersion": "v0.4.24+commit.e67f0147", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "byzantium", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}